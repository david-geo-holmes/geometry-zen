(function () {
  var async = {};
  var root, previous_async;
  root = this;
  if (root != null) {
    previous_async = root.async;
  }
  async.noConflict = function () {
    root.async = previous_async;
    return async;
  };
  function only_once(fn) {
    var called = false;
    return function () {
      if (called)
        throw new Error('Callback was already called.');
      called = true;
      fn.apply(root, arguments);
    };
  }
  var _each = function (arr, iterator) {
    if (arr.forEach) {
      return arr.forEach(iterator);
    }
    for (var i = 0; i < arr.length; i += 1) {
      iterator(arr[i], i, arr);
    }
  };
  var _map = function (arr, iterator) {
    if (arr.map) {
      return arr.map(iterator);
    }
    var results = [];
    _each(arr, function (x, i, a) {
      results.push(iterator(x, i, a));
    });
    return results;
  };
  var _reduce = function (arr, iterator, memo) {
    if (arr.reduce) {
      return arr.reduce(iterator, memo);
    }
    _each(arr, function (x, i, a) {
      memo = iterator(memo, x, i, a);
    });
    return memo;
  };
  var _keys = function (obj) {
    if (Object.keys) {
      return Object.keys(obj);
    }
    var keys = [];
    for (var k in obj) {
      if (obj.hasOwnProperty(k)) {
        keys.push(k);
      }
    }
    return keys;
  };
  if (typeof process === 'undefined' || !process.nextTick) {
    if (typeof setImmediate === 'function') {
      async.nextTick = function (fn) {
        setImmediate(fn);
      };
    } else {
      async.nextTick = function (fn) {
        setTimeout(fn, 0);
      };
    }
  } else {
    async.nextTick = process.nextTick;
  }
  async.each = function (arr, iterator, callback) {
    callback = callback || function () {
    };
    if (!arr.length) {
      return callback();
    }
    var completed = 0;
    _each(arr, function (x) {
      iterator(x, only_once(function (err) {
        if (err) {
          callback(err);
          callback = function () {
          };
        } else {
          completed += 1;
          if (completed >= arr.length) {
            callback(null);
          }
        }
      }));
    });
  };
  async.forEach = async.each;
  async.eachSeries = function (arr, iterator, callback) {
    callback = callback || function () {
    };
    if (!arr.length) {
      return callback();
    }
    var completed = 0;
    var iterate = function () {
      var sync = true;
      iterator(arr[completed], function (err) {
        if (err) {
          callback(err);
          callback = function () {
          };
        } else {
          completed += 1;
          if (completed >= arr.length) {
            callback(null);
          } else {
            if (sync) {
              async.nextTick(iterate);
            } else {
              iterate();
            }
          }
        }
      });
      sync = false;
    };
    iterate();
  };
  async.forEachSeries = async.eachSeries;
  async.eachLimit = function (arr, limit, iterator, callback) {
    var fn = _eachLimit(limit);
    fn.apply(null, [
      arr,
      iterator,
      callback
    ]);
  };
  async.forEachLimit = async.eachLimit;
  var _eachLimit = function (limit) {
    return function (arr, iterator, callback) {
      callback = callback || function () {
      };
      if (!arr.length || limit <= 0) {
        return callback();
      }
      var completed = 0;
      var started = 0;
      var running = 0;
      (function replenish() {
        if (completed >= arr.length) {
          return callback();
        }
        while (running < limit && started < arr.length) {
          started += 1;
          running += 1;
          iterator(arr[started - 1], function (err) {
            if (err) {
              callback(err);
              callback = function () {
              };
            } else {
              completed += 1;
              running -= 1;
              if (completed >= arr.length) {
                callback();
              } else {
                replenish();
              }
            }
          });
        }
      }());
    };
  };
  var doParallel = function (fn) {
    return function () {
      var args = Array.prototype.slice.call(arguments);
      return fn.apply(null, [async.each].concat(args));
    };
  };
  var doParallelLimit = function (limit, fn) {
    return function () {
      var args = Array.prototype.slice.call(arguments);
      return fn.apply(null, [_eachLimit(limit)].concat(args));
    };
  };
  var doSeries = function (fn) {
    return function () {
      var args = Array.prototype.slice.call(arguments);
      return fn.apply(null, [async.eachSeries].concat(args));
    };
  };
  var _asyncMap = function (eachfn, arr, iterator, callback) {
    var results = [];
    arr = _map(arr, function (x, i) {
      return {
        index: i,
        value: x
      };
    });
    eachfn(arr, function (x, callback) {
      iterator(x.value, function (err, v) {
        results[x.index] = v;
        callback(err);
      });
    }, function (err) {
      callback(err, results);
    });
  };
  async.map = doParallel(_asyncMap);
  async.mapSeries = doSeries(_asyncMap);
  async.mapLimit = function (arr, limit, iterator, callback) {
    return _mapLimit(limit)(arr, iterator, callback);
  };
  var _mapLimit = function (limit) {
    return doParallelLimit(limit, _asyncMap);
  };
  async.reduce = function (arr, memo, iterator, callback) {
    async.eachSeries(arr, function (x, callback) {
      iterator(memo, x, function (err, v) {
        memo = v;
        callback(err);
      });
    }, function (err) {
      callback(err, memo);
    });
  };
  async.inject = async.reduce;
  async.foldl = async.reduce;
  async.reduceRight = function (arr, memo, iterator, callback) {
    var reversed = _map(arr, function (x) {
        return x;
      }).reverse();
    async.reduce(reversed, memo, iterator, callback);
  };
  async.foldr = async.reduceRight;
  var _filter = function (eachfn, arr, iterator, callback) {
    var results = [];
    arr = _map(arr, function (x, i) {
      return {
        index: i,
        value: x
      };
    });
    eachfn(arr, function (x, callback) {
      iterator(x.value, function (v) {
        if (v) {
          results.push(x);
        }
        callback();
      });
    }, function (err) {
      callback(_map(results.sort(function (a, b) {
        return a.index - b.index;
      }), function (x) {
        return x.value;
      }));
    });
  };
  async.filter = doParallel(_filter);
  async.filterSeries = doSeries(_filter);
  async.select = async.filter;
  async.selectSeries = async.filterSeries;
  var _reject = function (eachfn, arr, iterator, callback) {
    var results = [];
    arr = _map(arr, function (x, i) {
      return {
        index: i,
        value: x
      };
    });
    eachfn(arr, function (x, callback) {
      iterator(x.value, function (v) {
        if (!v) {
          results.push(x);
        }
        callback();
      });
    }, function (err) {
      callback(_map(results.sort(function (a, b) {
        return a.index - b.index;
      }), function (x) {
        return x.value;
      }));
    });
  };
  async.reject = doParallel(_reject);
  async.rejectSeries = doSeries(_reject);
  var _detect = function (eachfn, arr, iterator, main_callback) {
    eachfn(arr, function (x, callback) {
      iterator(x, function (result) {
        if (result) {
          main_callback(x);
          main_callback = function () {
          };
        } else {
          callback();
        }
      });
    }, function (err) {
      main_callback();
    });
  };
  async.detect = doParallel(_detect);
  async.detectSeries = doSeries(_detect);
  async.some = function (arr, iterator, main_callback) {
    async.each(arr, function (x, callback) {
      iterator(x, function (v) {
        if (v) {
          main_callback(true);
          main_callback = function () {
          };
        }
        callback();
      });
    }, function (err) {
      main_callback(false);
    });
  };
  async.any = async.some;
  async.every = function (arr, iterator, main_callback) {
    async.each(arr, function (x, callback) {
      iterator(x, function (v) {
        if (!v) {
          main_callback(false);
          main_callback = function () {
          };
        }
        callback();
      });
    }, function (err) {
      main_callback(true);
    });
  };
  async.all = async.every;
  async.sortBy = function (arr, iterator, callback) {
    async.map(arr, function (x, callback) {
      iterator(x, function (err, criteria) {
        if (err) {
          callback(err);
        } else {
          callback(null, {
            value: x,
            criteria: criteria
          });
        }
      });
    }, function (err, results) {
      if (err) {
        return callback(err);
      } else {
        var fn = function (left, right) {
          var a = left.criteria, b = right.criteria;
          return a < b ? -1 : a > b ? 1 : 0;
        };
        callback(null, _map(results.sort(fn), function (x) {
          return x.value;
        }));
      }
    });
  };
  async.auto = function (tasks, callback) {
    callback = callback || function () {
    };
    var keys = _keys(tasks);
    if (!keys.length) {
      return callback(null);
    }
    var results = {};
    var listeners = [];
    var addListener = function (fn) {
      listeners.unshift(fn);
    };
    var removeListener = function (fn) {
      for (var i = 0; i < listeners.length; i += 1) {
        if (listeners[i] === fn) {
          listeners.splice(i, 1);
          return;
        }
      }
    };
    var taskComplete = function () {
      _each(listeners.slice(0), function (fn) {
        fn();
      });
    };
    addListener(function () {
      if (_keys(results).length === keys.length) {
        callback(null, results);
        callback = function () {
        };
      }
    });
    _each(keys, function (k) {
      var task = tasks[k] instanceof Function ? [tasks[k]] : tasks[k];
      var taskCallback = function (err) {
        if (err) {
          callback(err);
          callback = function () {
          };
        } else {
          var args = Array.prototype.slice.call(arguments, 1);
          if (args.length <= 1) {
            args = args[0];
          }
          results[k] = args;
          async.nextTick(taskComplete);
        }
      };
      var requires = task.slice(0, Math.abs(task.length - 1)) || [];
      var ready = function () {
        return _reduce(requires, function (a, x) {
          return a && results.hasOwnProperty(x);
        }, true) && !results.hasOwnProperty(k);
      };
      if (ready()) {
        task[task.length - 1](taskCallback, results);
      } else {
        var listener = function () {
          if (ready()) {
            removeListener(listener);
            task[task.length - 1](taskCallback, results);
          }
        };
        addListener(listener);
      }
    });
  };
  async.waterfall = function (tasks, callback) {
    callback = callback || function () {
    };
    if (!tasks.length) {
      return callback();
    }
    var wrapIterator = function (iterator) {
      return function (err) {
        if (err) {
          callback.apply(null, arguments);
          callback = function () {
          };
        } else {
          var args = Array.prototype.slice.call(arguments, 1);
          var next = iterator.next();
          if (next) {
            args.push(wrapIterator(next));
          } else {
            args.push(callback);
          }
          async.nextTick(function () {
            iterator.apply(null, args);
          });
        }
      };
    };
    wrapIterator(async.iterator(tasks))();
  };
  var _parallel = function (eachfn, tasks, callback) {
    callback = callback || function () {
    };
    if (tasks.constructor === Array) {
      eachfn.map(tasks, function (fn, callback) {
        if (fn) {
          fn(function (err) {
            var args = Array.prototype.slice.call(arguments, 1);
            if (args.length <= 1) {
              args = args[0];
            }
            callback.call(null, err, args);
          });
        }
      }, callback);
    } else {
      var results = {};
      eachfn.each(_keys(tasks), function (k, callback) {
        tasks[k](function (err) {
          var args = Array.prototype.slice.call(arguments, 1);
          if (args.length <= 1) {
            args = args[0];
          }
          results[k] = args;
          callback(err);
        });
      }, function (err) {
        callback(err, results);
      });
    }
  };
  async.parallel = function (tasks, callback) {
    _parallel({
      map: async.map,
      each: async.each
    }, tasks, callback);
  };
  async.parallelLimit = function (tasks, limit, callback) {
    _parallel({
      map: _mapLimit(limit),
      each: _eachLimit(limit)
    }, tasks, callback);
  };
  async.series = function (tasks, callback) {
    callback = callback || function () {
    };
    if (tasks.constructor === Array) {
      async.mapSeries(tasks, function (fn, callback) {
        if (fn) {
          fn(function (err) {
            var args = Array.prototype.slice.call(arguments, 1);
            if (args.length <= 1) {
              args = args[0];
            }
            callback.call(null, err, args);
          });
        }
      }, callback);
    } else {
      var results = {};
      async.eachSeries(_keys(tasks), function (k, callback) {
        tasks[k](function (err) {
          var args = Array.prototype.slice.call(arguments, 1);
          if (args.length <= 1) {
            args = args[0];
          }
          results[k] = args;
          callback(err);
        });
      }, function (err) {
        callback(err, results);
      });
    }
  };
  async.iterator = function (tasks) {
    var makeCallback = function (index) {
      var fn = function () {
        if (tasks.length) {
          tasks[index].apply(null, arguments);
        }
        return fn.next();
      };
      fn.next = function () {
        return index < tasks.length - 1 ? makeCallback(index + 1) : null;
      };
      return fn;
    };
    return makeCallback(0);
  };
  async.apply = function (fn) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function () {
      return fn.apply(null, args.concat(Array.prototype.slice.call(arguments)));
    };
  };
  var _concat = function (eachfn, arr, fn, callback) {
    var r = [];
    eachfn(arr, function (x, cb) {
      fn(x, function (err, y) {
        r = r.concat(y || []);
        cb(err);
      });
    }, function (err) {
      callback(err, r);
    });
  };
  async.concat = doParallel(_concat);
  async.concatSeries = doSeries(_concat);
  async.whilst = function (test, iterator, callback) {
    if (test()) {
      var sync = true;
      iterator(function (err) {
        if (err) {
          return callback(err);
        }
        if (sync) {
          async.nextTick(function () {
            async.whilst(test, iterator, callback);
          });
        } else {
          async.whilst(test, iterator, callback);
        }
      });
      sync = false;
    } else {
      callback();
    }
  };
  async.doWhilst = function (iterator, test, callback) {
    var sync = true;
    iterator(function (err) {
      if (err) {
        return callback(err);
      }
      if (test()) {
        if (sync) {
          async.nextTick(function () {
            async.doWhilst(iterator, test, callback);
          });
        } else {
          async.doWhilst(iterator, test, callback);
        }
      } else {
        callback();
      }
    });
    sync = false;
  };
  async.until = function (test, iterator, callback) {
    if (!test()) {
      var sync = true;
      iterator(function (err) {
        if (err) {
          return callback(err);
        }
        if (sync) {
          async.nextTick(function () {
            async.until(test, iterator, callback);
          });
        } else {
          async.until(test, iterator, callback);
        }
      });
      sync = false;
    } else {
      callback();
    }
  };
  async.doUntil = function (iterator, test, callback) {
    var sync = true;
    iterator(function (err) {
      if (err) {
        return callback(err);
      }
      if (!test()) {
        if (sync) {
          async.nextTick(function () {
            async.doUntil(iterator, test, callback);
          });
        } else {
          async.doUntil(iterator, test, callback);
        }
      } else {
        callback();
      }
    });
    sync = false;
  };
  async.queue = function (worker, concurrency) {
    function _insert(q, data, pos, callback) {
      if (data.constructor !== Array) {
        data = [data];
      }
      _each(data, function (task) {
        var item = {
            data: task,
            callback: typeof callback === 'function' ? callback : null
          };
        if (pos) {
          q.tasks.unshift(item);
        } else {
          q.tasks.push(item);
        }
        if (q.saturated && q.tasks.length === concurrency) {
          q.saturated();
        }
        async.nextTick(q.process);
      });
    }
    var workers = 0;
    var q = {
        tasks: [],
        concurrency: concurrency,
        saturated: null,
        empty: null,
        drain: null,
        push: function (data, callback) {
          _insert(q, data, false, callback);
        },
        unshift: function (data, callback) {
          _insert(q, data, true, callback);
        },
        process: function () {
          if (workers < q.concurrency && q.tasks.length) {
            var task = q.tasks.shift();
            if (q.empty && q.tasks.length === 0) {
              q.empty();
            }
            workers += 1;
            var sync = true;
            var next = function () {
              workers -= 1;
              if (task.callback) {
                task.callback.apply(task, arguments);
              }
              if (q.drain && q.tasks.length + workers === 0) {
                q.drain();
              }
              q.process();
            };
            var cb = only_once(function () {
                var cbArgs = arguments;
                if (sync) {
                  async.nextTick(function () {
                    next.apply(null, cbArgs);
                  });
                } else {
                  next.apply(null, arguments);
                }
              });
            worker(task.data, cb);
            sync = false;
          }
        },
        length: function () {
          return q.tasks.length;
        },
        running: function () {
          return workers;
        }
      };
    return q;
  };
  async.cargo = function (worker, payload) {
    var working = false, tasks = [];
    var cargo = {
        tasks: tasks,
        payload: payload,
        saturated: null,
        empty: null,
        drain: null,
        push: function (data, callback) {
          if (data.constructor !== Array) {
            data = [data];
          }
          _each(data, function (task) {
            tasks.push({
              data: task,
              callback: typeof callback === 'function' ? callback : null
            });
            if (cargo.saturated && tasks.length === payload) {
              cargo.saturated();
            }
          });
          async.nextTick(cargo.process);
        },
        process: function process() {
          if (working)
            return;
          if (tasks.length === 0) {
            if (cargo.drain)
              cargo.drain();
            return;
          }
          var ts = typeof payload === 'number' ? tasks.splice(0, payload) : tasks.splice(0);
          var ds = _map(ts, function (task) {
              return task.data;
            });
          if (cargo.empty)
            cargo.empty();
          working = true;
          worker(ds, function () {
            working = false;
            var args = arguments;
            _each(ts, function (data) {
              if (data.callback) {
                data.callback.apply(null, args);
              }
            });
            process();
          });
        },
        length: function () {
          return tasks.length;
        },
        running: function () {
          return working;
        }
      };
    return cargo;
  };
  var _console_fn = function (name) {
    return function (fn) {
      var args = Array.prototype.slice.call(arguments, 1);
      fn.apply(null, args.concat([function (err) {
          var args = Array.prototype.slice.call(arguments, 1);
          if (typeof console !== 'undefined') {
            if (err) {
              if (console.error) {
                console.error(err);
              }
            } else if (console[name]) {
              _each(args, function (x) {
                console[name](x);
              });
            }
          }
        }]));
    };
  };
  async.log = _console_fn('log');
  async.dir = _console_fn('dir');
  async.memoize = function (fn, hasher) {
    var memo = {};
    var queues = {};
    hasher = hasher || function (x) {
      return x;
    };
    var memoized = function () {
      var args = Array.prototype.slice.call(arguments);
      var callback = args.pop();
      var key = hasher.apply(null, args);
      if (key in memo) {
        callback.apply(null, memo[key]);
      } else if (key in queues) {
        queues[key].push(callback);
      } else {
        queues[key] = [callback];
        fn.apply(null, args.concat([function () {
            memo[key] = arguments;
            var q = queues[key];
            delete queues[key];
            for (var i = 0, l = q.length; i < l; i++) {
              q[i].apply(null, arguments);
            }
          }]));
      }
    };
    memoized.memo = memo;
    memoized.unmemoized = fn;
    return memoized;
  };
  async.unmemoize = function (fn) {
    return function () {
      return (fn.unmemoized || fn).apply(null, arguments);
    };
  };
  async.times = function (count, iterator, callback) {
    var counter = [];
    for (var i = 0; i < count; i++) {
      counter.push(i);
    }
    return async.map(counter, iterator, callback);
  };
  async.timesSeries = function (count, iterator, callback) {
    var counter = [];
    for (var i = 0; i < count; i++) {
      counter.push(i);
    }
    return async.mapSeries(counter, iterator, callback);
  };
  async.compose = function () {
    var fns = Array.prototype.reverse.call(arguments);
    return function () {
      var that = this;
      var args = Array.prototype.slice.call(arguments);
      var callback = args.pop();
      async.reduce(fns, args, function (newargs, fn, cb) {
        fn.apply(that, newargs.concat([function () {
            var err = arguments[0];
            var nextargs = Array.prototype.slice.call(arguments, 1);
            cb(err, nextargs);
          }]));
      }, function (err, results) {
        callback.apply(that, [err].concat(results));
      });
    };
  };
  if (typeof define !== 'undefined' && define.amd) {
    define([], function () {
      return async;
    });
  } else if (typeof module !== 'undefined' && module.exports) {
    module.exports = async;
  } else {
    root.async = async;
  }
}());
(function (window, undefined) {
  var rootjQuery, readyList, core_strundefined = typeof undefined, location = window.location, document = window.document, docElem = document.documentElement, _jQuery = window.jQuery, _$ = window.$, class2type = {}, core_deletedIds = [], core_version = '2.0.3', core_concat = core_deletedIds.concat, core_push = core_deletedIds.push, core_slice = core_deletedIds.slice, core_indexOf = core_deletedIds.indexOf, core_toString = class2type.toString, core_hasOwn = class2type.hasOwnProperty, core_trim = core_version.trim, jQuery = function (selector, context) {
      return new jQuery.fn.init(selector, context, rootjQuery);
    }, core_pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, core_rnotwhite = /\S+/g, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, rmsPrefix = /^-ms-/, rdashAlpha = /-([\da-z])/gi, fcamelCase = function (all, letter) {
      return letter.toUpperCase();
    }, completed = function () {
      document.removeEventListener('DOMContentLoaded', completed, false);
      window.removeEventListener('load', completed, false);
      jQuery.ready();
    };
  jQuery.fn = jQuery.prototype = {
    jquery: core_version,
    constructor: jQuery,
    init: function (selector, context, rootjQuery) {
      var match, elem;
      if (!selector) {
        return this;
      }
      if (typeof selector === 'string') {
        if (selector.charAt(0) === '<' && selector.charAt(selector.length - 1) === '>' && selector.length >= 3) {
          match = [
            null,
            selector,
            null
          ];
        } else {
          match = rquickExpr.exec(selector);
        }
        if (match && (match[1] || !context)) {
          if (match[1]) {
            context = context instanceof jQuery ? context[0] : context;
            jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
            if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
              for (match in context) {
                if (jQuery.isFunction(this[match])) {
                  this[match](context[match]);
                } else {
                  this.attr(match, context[match]);
                }
              }
            }
            return this;
          } else {
            elem = document.getElementById(match[2]);
            if (elem && elem.parentNode) {
              this.length = 1;
              this[0] = elem;
            }
            this.context = document;
            this.selector = selector;
            return this;
          }
        } else if (!context || context.jquery) {
          return (context || rootjQuery).find(selector);
        } else {
          return this.constructor(context).find(selector);
        }
      } else if (selector.nodeType) {
        this.context = this[0] = selector;
        this.length = 1;
        return this;
      } else if (jQuery.isFunction(selector)) {
        return rootjQuery.ready(selector);
      }
      if (selector.selector !== undefined) {
        this.selector = selector.selector;
        this.context = selector.context;
      }
      return jQuery.makeArray(selector, this);
    },
    selector: '',
    length: 0,
    toArray: function () {
      return core_slice.call(this);
    },
    get: function (num) {
      return num == null ? this.toArray() : num < 0 ? this[this.length + num] : this[num];
    },
    pushStack: function (elems) {
      var ret = jQuery.merge(this.constructor(), elems);
      ret.prevObject = this;
      ret.context = this.context;
      return ret;
    },
    each: function (callback, args) {
      return jQuery.each(this, callback, args);
    },
    ready: function (fn) {
      jQuery.ready.promise().done(fn);
      return this;
    },
    slice: function () {
      return this.pushStack(core_slice.apply(this, arguments));
    },
    first: function () {
      return this.eq(0);
    },
    last: function () {
      return this.eq(-1);
    },
    eq: function (i) {
      var len = this.length, j = +i + (i < 0 ? len : 0);
      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
    },
    map: function (callback) {
      return this.pushStack(jQuery.map(this, function (elem, i) {
        return callback.call(elem, i, elem);
      }));
    },
    end: function () {
      return this.prevObject || this.constructor(null);
    },
    push: core_push,
    sort: [].sort,
    splice: [].splice
  };
  jQuery.fn.init.prototype = jQuery.fn;
  jQuery.extend = jQuery.fn.extend = function () {
    var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
    if (typeof target === 'boolean') {
      deep = target;
      target = arguments[1] || {};
      i = 2;
    }
    if (typeof target !== 'object' && !jQuery.isFunction(target)) {
      target = {};
    }
    if (length === i) {
      target = this;
      --i;
    }
    for (; i < length; i++) {
      if ((options = arguments[i]) != null) {
        for (name in options) {
          src = target[name];
          copy = options[name];
          if (target === copy) {
            continue;
          }
          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && jQuery.isArray(src) ? src : [];
            } else {
              clone = src && jQuery.isPlainObject(src) ? src : {};
            }
            target[name] = jQuery.extend(deep, clone, copy);
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    }
    return target;
  };
  jQuery.extend({
    expando: 'jQuery' + (core_version + Math.random()).replace(/\D/g, ''),
    noConflict: function (deep) {
      if (window.$ === jQuery) {
        window.$ = _$;
      }
      if (deep && window.jQuery === jQuery) {
        window.jQuery = _jQuery;
      }
      return jQuery;
    },
    isReady: false,
    readyWait: 1,
    holdReady: function (hold) {
      if (hold) {
        jQuery.readyWait++;
      } else {
        jQuery.ready(true);
      }
    },
    ready: function (wait) {
      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
        return;
      }
      jQuery.isReady = true;
      if (wait !== true && --jQuery.readyWait > 0) {
        return;
      }
      readyList.resolveWith(document, [jQuery]);
      if (jQuery.fn.trigger) {
        jQuery(document).trigger('ready').off('ready');
      }
    },
    isFunction: function (obj) {
      return jQuery.type(obj) === 'function';
    },
    isArray: Array.isArray,
    isWindow: function (obj) {
      return obj != null && obj === obj.window;
    },
    isNumeric: function (obj) {
      return !isNaN(parseFloat(obj)) && isFinite(obj);
    },
    type: function (obj) {
      if (obj == null) {
        return String(obj);
      }
      return typeof obj === 'object' || typeof obj === 'function' ? class2type[core_toString.call(obj)] || 'object' : typeof obj;
    },
    isPlainObject: function (obj) {
      if (jQuery.type(obj) !== 'object' || obj.nodeType || jQuery.isWindow(obj)) {
        return false;
      }
      try {
        if (obj.constructor && !core_hasOwn.call(obj.constructor.prototype, 'isPrototypeOf')) {
          return false;
        }
      } catch (e) {
        return false;
      }
      return true;
    },
    isEmptyObject: function (obj) {
      var name;
      for (name in obj) {
        return false;
      }
      return true;
    },
    error: function (msg) {
      throw new Error(msg);
    },
    parseHTML: function (data, context, keepScripts) {
      if (!data || typeof data !== 'string') {
        return null;
      }
      if (typeof context === 'boolean') {
        keepScripts = context;
        context = false;
      }
      context = context || document;
      var parsed = rsingleTag.exec(data), scripts = !keepScripts && [];
      if (parsed) {
        return [context.createElement(parsed[1])];
      }
      parsed = jQuery.buildFragment([data], context, scripts);
      if (scripts) {
        jQuery(scripts).remove();
      }
      return jQuery.merge([], parsed.childNodes);
    },
    parseJSON: JSON.parse,
    parseXML: function (data) {
      var xml, tmp;
      if (!data || typeof data !== 'string') {
        return null;
      }
      try {
        tmp = new DOMParser();
        xml = tmp.parseFromString(data, 'text/xml');
      } catch (e) {
        xml = undefined;
      }
      if (!xml || xml.getElementsByTagName('parsererror').length) {
        jQuery.error('Invalid XML: ' + data);
      }
      return xml;
    },
    noop: function () {
    },
    globalEval: function (code) {
      var script, indirect = eval;
      code = jQuery.trim(code);
      if (code) {
        if (code.indexOf('use strict') === 1) {
          script = document.createElement('script');
          script.text = code;
          document.head.appendChild(script).parentNode.removeChild(script);
        } else {
          indirect(code);
        }
      }
    },
    camelCase: function (string) {
      return string.replace(rmsPrefix, 'ms-').replace(rdashAlpha, fcamelCase);
    },
    nodeName: function (elem, name) {
      return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    },
    each: function (obj, callback, args) {
      var value, i = 0, length = obj.length, isArray = isArraylike(obj);
      if (args) {
        if (isArray) {
          for (; i < length; i++) {
            value = callback.apply(obj[i], args);
            if (value === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            value = callback.apply(obj[i], args);
            if (value === false) {
              break;
            }
          }
        }
      } else {
        if (isArray) {
          for (; i < length; i++) {
            value = callback.call(obj[i], i, obj[i]);
            if (value === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            value = callback.call(obj[i], i, obj[i]);
            if (value === false) {
              break;
            }
          }
        }
      }
      return obj;
    },
    trim: function (text) {
      return text == null ? '' : core_trim.call(text);
    },
    makeArray: function (arr, results) {
      var ret = results || [];
      if (arr != null) {
        if (isArraylike(Object(arr))) {
          jQuery.merge(ret, typeof arr === 'string' ? [arr] : arr);
        } else {
          core_push.call(ret, arr);
        }
      }
      return ret;
    },
    inArray: function (elem, arr, i) {
      return arr == null ? -1 : core_indexOf.call(arr, elem, i);
    },
    merge: function (first, second) {
      var l = second.length, i = first.length, j = 0;
      if (typeof l === 'number') {
        for (; j < l; j++) {
          first[i++] = second[j];
        }
      } else {
        while (second[j] !== undefined) {
          first[i++] = second[j++];
        }
      }
      first.length = i;
      return first;
    },
    grep: function (elems, callback, inv) {
      var retVal, ret = [], i = 0, length = elems.length;
      inv = !!inv;
      for (; i < length; i++) {
        retVal = !!callback(elems[i], i);
        if (inv !== retVal) {
          ret.push(elems[i]);
        }
      }
      return ret;
    },
    map: function (elems, callback, arg) {
      var value, i = 0, length = elems.length, isArray = isArraylike(elems), ret = [];
      if (isArray) {
        for (; i < length; i++) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret[ret.length] = value;
          }
        }
      } else {
        for (i in elems) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret[ret.length] = value;
          }
        }
      }
      return core_concat.apply([], ret);
    },
    guid: 1,
    proxy: function (fn, context) {
      var tmp, args, proxy;
      if (typeof context === 'string') {
        tmp = fn[context];
        context = fn;
        fn = tmp;
      }
      if (!jQuery.isFunction(fn)) {
        return undefined;
      }
      args = core_slice.call(arguments, 2);
      proxy = function () {
        return fn.apply(context || this, args.concat(core_slice.call(arguments)));
      };
      proxy.guid = fn.guid = fn.guid || jQuery.guid++;
      return proxy;
    },
    access: function (elems, fn, key, value, chainable, emptyGet, raw) {
      var i = 0, length = elems.length, bulk = key == null;
      if (jQuery.type(key) === 'object') {
        chainable = true;
        for (i in key) {
          jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
        }
      } else if (value !== undefined) {
        chainable = true;
        if (!jQuery.isFunction(value)) {
          raw = true;
        }
        if (bulk) {
          if (raw) {
            fn.call(elems, value);
            fn = null;
          } else {
            bulk = fn;
            fn = function (elem, key, value) {
              return bulk.call(jQuery(elem), value);
            };
          }
        }
        if (fn) {
          for (; i < length; i++) {
            fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
          }
        }
      }
      return chainable ? elems : bulk ? fn.call(elems) : length ? fn(elems[0], key) : emptyGet;
    },
    now: Date.now,
    swap: function (elem, options, callback, args) {
      var ret, name, old = {};
      for (name in options) {
        old[name] = elem.style[name];
        elem.style[name] = options[name];
      }
      ret = callback.apply(elem, args || []);
      for (name in options) {
        elem.style[name] = old[name];
      }
      return ret;
    }
  });
  jQuery.ready.promise = function (obj) {
    if (!readyList) {
      readyList = jQuery.Deferred();
      if (document.readyState === 'complete') {
        setTimeout(jQuery.ready);
      } else {
        document.addEventListener('DOMContentLoaded', completed, false);
        window.addEventListener('load', completed, false);
      }
    }
    return readyList.promise(obj);
  };
  jQuery.each('Boolean Number String Function Array Date RegExp Object Error'.split(' '), function (i, name) {
    class2type['[object ' + name + ']'] = name.toLowerCase();
  });
  function isArraylike(obj) {
    var length = obj.length, type = jQuery.type(obj);
    if (jQuery.isWindow(obj)) {
      return false;
    }
    if (obj.nodeType === 1 && length) {
      return true;
    }
    return type === 'array' || type !== 'function' && (length === 0 || typeof length === 'number' && length > 0 && length - 1 in obj);
  }
  rootjQuery = jQuery(document);
  (function (window, undefined) {
    var i, support, cachedruns, Expr, getText, isXML, compile, outermostContext, sortInput, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = 'sizzle' + -new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), hasDuplicate = false, sortOrder = function (a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        return 0;
      }, strundefined = typeof undefined, MAX_NEGATIVE = 1 << 31, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = arr.indexOf || function (elem) {
        var i = 0, len = this.length;
        for (; i < len; i++) {
          if (this[i] === elem) {
            return i;
          }
        }
        return -1;
      }, booleans = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped', whitespace = '[\\x20\\t\\r\\n\\f]', characterEncoding = '(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+', identifier = characterEncoding.replace('w', 'w#'), attributes = '\\[' + whitespace + '*(' + characterEncoding + ')' + whitespace + '*(?:([*^$|!~]?=)' + whitespace + '*(?:([\'"])((?:\\\\.|[^\\\\])*?)\\3|(' + identifier + ')|)|)' + whitespace + '*\\]', pseudos = ':(' + characterEncoding + ')(?:\\((([\'"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|' + attributes.replace(3, 8) + ')*)|.*)\\)|)', rtrim = new RegExp('^' + whitespace + '+|((?:^|[^\\\\])(?:\\\\.)*)' + whitespace + '+$', 'g'), rcomma = new RegExp('^' + whitespace + '*,' + whitespace + '*'), rcombinators = new RegExp('^' + whitespace + '*([>+~]|' + whitespace + ')' + whitespace + '*'), rsibling = new RegExp(whitespace + '*[+~]'), rattributeQuotes = new RegExp('=' + whitespace + '*([^\\]\'"]*)' + whitespace + '*\\]', 'g'), rpseudo = new RegExp(pseudos), ridentifier = new RegExp('^' + identifier + '$'), matchExpr = {
        'ID': new RegExp('^#(' + characterEncoding + ')'),
        'CLASS': new RegExp('^\\.(' + characterEncoding + ')'),
        'TAG': new RegExp('^(' + characterEncoding.replace('w', 'w*') + ')'),
        'ATTR': new RegExp('^' + attributes),
        'PSEUDO': new RegExp('^' + pseudos),
        'CHILD': new RegExp('^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' + whitespace + '*(even|odd|(([+-]|)(\\d*)n|)' + whitespace + '*(?:([+-]|)' + whitespace + '*(\\d+)|))' + whitespace + '*\\)|)', 'i'),
        'bool': new RegExp('^(?:' + booleans + ')$', 'i'),
        'needsContext': new RegExp('^' + whitespace + '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' + whitespace + '*((?:-\\d)?\\d*)' + whitespace + '*\\)|)(?=[^-]|$)', 'i')
      }, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rescape = /'|\\/g, runescape = new RegExp('\\\\([\\da-f]{1,6}' + whitespace + '?|(' + whitespace + ')|.)', 'ig'), funescape = function (_, escaped, escapedWhitespace) {
        var high = '0x' + escaped - 65536;
        return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
      };
    try {
      push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
      arr[preferredDoc.childNodes.length].nodeType;
    } catch (e) {
      push = {
        apply: arr.length ? function (target, els) {
          push_native.apply(target, slice.call(els));
        } : function (target, els) {
          var j = target.length, i = 0;
          while (target[j++] = els[i++]) {
          }
          target.length = j - 1;
        }
      };
    }
    function Sizzle(selector, context, results, seed) {
      var match, elem, m, nodeType, i, groups, old, nid, newContext, newSelector;
      if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
        setDocument(context);
      }
      context = context || document;
      results = results || [];
      if (!selector || typeof selector !== 'string') {
        return results;
      }
      if ((nodeType = context.nodeType) !== 1 && nodeType !== 9) {
        return [];
      }
      if (documentIsHTML && !seed) {
        if (match = rquickExpr.exec(selector)) {
          if (m = match[1]) {
            if (nodeType === 9) {
              elem = context.getElementById(m);
              if (elem && elem.parentNode) {
                if (elem.id === m) {
                  results.push(elem);
                  return results;
                }
              } else {
                return results;
              }
            } else {
              if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                results.push(elem);
                return results;
              }
            }
          } else if (match[2]) {
            push.apply(results, context.getElementsByTagName(selector));
            return results;
          } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
            push.apply(results, context.getElementsByClassName(m));
            return results;
          }
        }
        if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
          nid = old = expando;
          newContext = context;
          newSelector = nodeType === 9 && selector;
          if (nodeType === 1 && context.nodeName.toLowerCase() !== 'object') {
            groups = tokenize(selector);
            if (old = context.getAttribute('id')) {
              nid = old.replace(rescape, '\\$&');
            } else {
              context.setAttribute('id', nid);
            }
            nid = '[id=\'' + nid + '\'] ';
            i = groups.length;
            while (i--) {
              groups[i] = nid + toSelector(groups[i]);
            }
            newContext = rsibling.test(selector) && context.parentNode || context;
            newSelector = groups.join(',');
          }
          if (newSelector) {
            try {
              push.apply(results, newContext.querySelectorAll(newSelector));
              return results;
            } catch (qsaError) {
            } finally {
              if (!old) {
                context.removeAttribute('id');
              }
            }
          }
        }
      }
      return select(selector.replace(rtrim, '$1'), context, results, seed);
    }
    function createCache() {
      var keys = [];
      function cache(key, value) {
        if (keys.push(key += ' ') > Expr.cacheLength) {
          delete cache[keys.shift()];
        }
        return cache[key] = value;
      }
      return cache;
    }
    function markFunction(fn) {
      fn[expando] = true;
      return fn;
    }
    function assert(fn) {
      var div = document.createElement('div');
      try {
        return !!fn(div);
      } catch (e) {
        return false;
      } finally {
        if (div.parentNode) {
          div.parentNode.removeChild(div);
        }
        div = null;
      }
    }
    function addHandle(attrs, handler) {
      var arr = attrs.split('|'), i = attrs.length;
      while (i--) {
        Expr.attrHandle[arr[i]] = handler;
      }
    }
    function siblingCheck(a, b) {
      var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
      if (diff) {
        return diff;
      }
      if (cur) {
        while (cur = cur.nextSibling) {
          if (cur === b) {
            return -1;
          }
        }
      }
      return a ? 1 : -1;
    }
    function createInputPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return name === 'input' && elem.type === type;
      };
    }
    function createButtonPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return (name === 'input' || name === 'button') && elem.type === type;
      };
    }
    function createPositionalPseudo(fn) {
      return markFunction(function (argument) {
        argument = +argument;
        return markFunction(function (seed, matches) {
          var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
          while (i--) {
            if (seed[j = matchIndexes[i]]) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }
    isXML = Sizzle.isXML = function (elem) {
      var documentElement = elem && (elem.ownerDocument || elem).documentElement;
      return documentElement ? documentElement.nodeName !== 'HTML' : false;
    };
    support = Sizzle.support = {};
    setDocument = Sizzle.setDocument = function (node) {
      var doc = node ? node.ownerDocument || node : preferredDoc, parent = doc.defaultView;
      if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
        return document;
      }
      document = doc;
      docElem = doc.documentElement;
      documentIsHTML = !isXML(doc);
      if (parent && parent.attachEvent && parent !== parent.top) {
        parent.attachEvent('onbeforeunload', function () {
          setDocument();
        });
      }
      support.attributes = assert(function (div) {
        div.className = 'i';
        return !div.getAttribute('className');
      });
      support.getElementsByTagName = assert(function (div) {
        div.appendChild(doc.createComment(''));
        return !div.getElementsByTagName('*').length;
      });
      support.getElementsByClassName = assert(function (div) {
        div.innerHTML = '<div class=\'a\'></div><div class=\'a i\'></div>';
        div.firstChild.className = 'i';
        return div.getElementsByClassName('i').length === 2;
      });
      support.getById = assert(function (div) {
        docElem.appendChild(div).id = expando;
        return !doc.getElementsByName || !doc.getElementsByName(expando).length;
      });
      if (support.getById) {
        Expr.find['ID'] = function (id, context) {
          if (typeof context.getElementById !== strundefined && documentIsHTML) {
            var m = context.getElementById(id);
            return m && m.parentNode ? [m] : [];
          }
        };
        Expr.filter['ID'] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            return elem.getAttribute('id') === attrId;
          };
        };
      } else {
        delete Expr.find['ID'];
        Expr.filter['ID'] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode('id');
            return node && node.value === attrId;
          };
        };
      }
      Expr.find['TAG'] = support.getElementsByTagName ? function (tag, context) {
        if (typeof context.getElementsByTagName !== strundefined) {
          return context.getElementsByTagName(tag);
        }
      } : function (tag, context) {
        var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
        if (tag === '*') {
          while (elem = results[i++]) {
            if (elem.nodeType === 1) {
              tmp.push(elem);
            }
          }
          return tmp;
        }
        return results;
      };
      Expr.find['CLASS'] = support.getElementsByClassName && function (className, context) {
        if (typeof context.getElementsByClassName !== strundefined && documentIsHTML) {
          return context.getElementsByClassName(className);
        }
      };
      rbuggyMatches = [];
      rbuggyQSA = [];
      if (support.qsa = rnative.test(doc.querySelectorAll)) {
        assert(function (div) {
          div.innerHTML = '<select><option selected=\'\'></option></select>';
          if (!div.querySelectorAll('[selected]').length) {
            rbuggyQSA.push('\\[' + whitespace + '*(?:value|' + booleans + ')');
          }
          if (!div.querySelectorAll(':checked').length) {
            rbuggyQSA.push(':checked');
          }
        });
        assert(function (div) {
          var input = doc.createElement('input');
          input.setAttribute('type', 'hidden');
          div.appendChild(input).setAttribute('t', '');
          if (div.querySelectorAll('[t^=\'\']').length) {
            rbuggyQSA.push('[*^$]=' + whitespace + '*(?:\'\'|"")');
          }
          if (!div.querySelectorAll(':enabled').length) {
            rbuggyQSA.push(':enabled', ':disabled');
          }
          div.querySelectorAll('*,:x');
          rbuggyQSA.push(',.*:');
        });
      }
      if (support.matchesSelector = rnative.test(matches = docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
        assert(function (div) {
          support.disconnectedMatch = matches.call(div, 'div');
          matches.call(div, '[s!=\'\']:x');
          rbuggyMatches.push('!=', pseudos);
        });
      }
      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join('|'));
      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join('|'));
      contains = rnative.test(docElem.contains) || docElem.compareDocumentPosition ? function (a, b) {
        var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
      } : function (a, b) {
        if (b) {
          while (b = b.parentNode) {
            if (b === a) {
              return true;
            }
          }
        }
        return false;
      };
      sortOrder = docElem.compareDocumentPosition ? function (a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var compare = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition(b);
        if (compare) {
          if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
            if (a === doc || contains(preferredDoc, a)) {
              return -1;
            }
            if (b === doc || contains(preferredDoc, b)) {
              return 1;
            }
            return sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
          }
          return compare & 4 ? -1 : 1;
        }
        return a.compareDocumentPosition ? -1 : 1;
      } : function (a, b) {
        var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
        if (a === b) {
          hasDuplicate = true;
          return 0;
        } else if (!aup || !bup) {
          return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
        } else if (aup === bup) {
          return siblingCheck(a, b);
        }
        cur = a;
        while (cur = cur.parentNode) {
          ap.unshift(cur);
        }
        cur = b;
        while (cur = cur.parentNode) {
          bp.unshift(cur);
        }
        while (ap[i] === bp[i]) {
          i++;
        }
        return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
      };
      return doc;
    };
    Sizzle.matches = function (expr, elements) {
      return Sizzle(expr, null, null, elements);
    };
    Sizzle.matchesSelector = function (elem, expr) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      expr = expr.replace(rattributeQuotes, '=\'$1\']');
      if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
        try {
          var ret = matches.call(elem, expr);
          if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
            return ret;
          }
        } catch (e) {
        }
      }
      return Sizzle(expr, document, null, [elem]).length > 0;
    };
    Sizzle.contains = function (context, elem) {
      if ((context.ownerDocument || context) !== document) {
        setDocument(context);
      }
      return contains(context, elem);
    };
    Sizzle.attr = function (elem, name) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
      return val === undefined ? support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null : val;
    };
    Sizzle.error = function (msg) {
      throw new Error('Syntax error, unrecognized expression: ' + msg);
    };
    Sizzle.uniqueSort = function (results) {
      var elem, duplicates = [], j = 0, i = 0;
      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable && results.slice(0);
      results.sort(sortOrder);
      if (hasDuplicate) {
        while (elem = results[i++]) {
          if (elem === results[i]) {
            j = duplicates.push(i);
          }
        }
        while (j--) {
          results.splice(duplicates[j], 1);
        }
      }
      return results;
    };
    getText = Sizzle.getText = function (elem) {
      var node, ret = '', i = 0, nodeType = elem.nodeType;
      if (!nodeType) {
        for (; node = elem[i]; i++) {
          ret += getText(node);
        }
      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
        if (typeof elem.textContent === 'string') {
          return elem.textContent;
        } else {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            ret += getText(elem);
          }
        }
      } else if (nodeType === 3 || nodeType === 4) {
        return elem.nodeValue;
      }
      return ret;
    };
    Expr = Sizzle.selectors = {
      cacheLength: 50,
      createPseudo: markFunction,
      match: matchExpr,
      attrHandle: {},
      find: {},
      relative: {
        '>': {
          dir: 'parentNode',
          first: true
        },
        ' ': { dir: 'parentNode' },
        '+': {
          dir: 'previousSibling',
          first: true
        },
        '~': { dir: 'previousSibling' }
      },
      preFilter: {
        'ATTR': function (match) {
          match[1] = match[1].replace(runescape, funescape);
          match[3] = (match[4] || match[5] || '').replace(runescape, funescape);
          if (match[2] === '~=') {
            match[3] = ' ' + match[3] + ' ';
          }
          return match.slice(0, 4);
        },
        'CHILD': function (match) {
          match[1] = match[1].toLowerCase();
          if (match[1].slice(0, 3) === 'nth') {
            if (!match[3]) {
              Sizzle.error(match[0]);
            }
            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === 'even' || match[3] === 'odd'));
            match[5] = +(match[7] + match[8] || match[3] === 'odd');
          } else if (match[3]) {
            Sizzle.error(match[0]);
          }
          return match;
        },
        'PSEUDO': function (match) {
          var excess, unquoted = !match[5] && match[2];
          if (matchExpr['CHILD'].test(match[0])) {
            return null;
          }
          if (match[3] && match[4] !== undefined) {
            match[2] = match[4];
          } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(')', unquoted.length - excess) - unquoted.length)) {
            match[0] = match[0].slice(0, excess);
            match[2] = unquoted.slice(0, excess);
          }
          return match.slice(0, 3);
        }
      },
      filter: {
        'TAG': function (nodeNameSelector) {
          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
          return nodeNameSelector === '*' ? function () {
            return true;
          } : function (elem) {
            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
          };
        },
        'CLASS': function (className) {
          var pattern = classCache[className + ' '];
          return pattern || (pattern = new RegExp('(^|' + whitespace + ')' + className + '(' + whitespace + '|$)')) && classCache(className, function (elem) {
            return pattern.test(typeof elem.className === 'string' && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute('class') || '');
          });
        },
        'ATTR': function (name, operator, check) {
          return function (elem) {
            var result = Sizzle.attr(elem, name);
            if (result == null) {
              return operator === '!=';
            }
            if (!operator) {
              return true;
            }
            result += '';
            return operator === '=' ? result === check : operator === '!=' ? result !== check : operator === '^=' ? check && result.indexOf(check) === 0 : operator === '*=' ? check && result.indexOf(check) > -1 : operator === '$=' ? check && result.slice(-check.length) === check : operator === '~=' ? (' ' + result + ' ').indexOf(check) > -1 : operator === '|=' ? result === check || result.slice(0, check.length + 1) === check + '-' : false;
          };
        },
        'CHILD': function (type, what, argument, first, last) {
          var simple = type.slice(0, 3) !== 'nth', forward = type.slice(-4) !== 'last', ofType = what === 'of-type';
          return first === 1 && last === 0 ? function (elem) {
            return !!elem.parentNode;
          } : function (elem, context, xml) {
            var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? 'nextSibling' : 'previousSibling', parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType;
            if (parent) {
              if (simple) {
                while (dir) {
                  node = elem;
                  while (node = node[dir]) {
                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                      return false;
                    }
                  }
                  start = dir = type === 'only' && !start && 'nextSibling';
                }
                return true;
              }
              start = [forward ? parent.firstChild : parent.lastChild];
              if (forward && useCache) {
                outerCache = parent[expando] || (parent[expando] = {});
                cache = outerCache[type] || [];
                nodeIndex = cache[0] === dirruns && cache[1];
                diff = cache[0] === dirruns && cache[2];
                node = nodeIndex && parent.childNodes[nodeIndex];
                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                  if (node.nodeType === 1 && ++diff && node === elem) {
                    outerCache[type] = [
                      dirruns,
                      nodeIndex,
                      diff
                    ];
                    break;
                  }
                }
              } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                diff = cache[1];
              } else {
                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                  if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                    if (useCache) {
                      (node[expando] || (node[expando] = {}))[type] = [
                        dirruns,
                        diff
                      ];
                    }
                    if (node === elem) {
                      break;
                    }
                  }
                }
              }
              diff -= last;
              return diff === first || diff % first === 0 && diff / first >= 0;
            }
          };
        },
        'PSEUDO': function (pseudo, argument) {
          var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error('unsupported pseudo: ' + pseudo);
          if (fn[expando]) {
            return fn(argument);
          }
          if (fn.length > 1) {
            args = [
              pseudo,
              pseudo,
              '',
              argument
            ];
            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
              var idx, matched = fn(seed, argument), i = matched.length;
              while (i--) {
                idx = indexOf.call(seed, matched[i]);
                seed[idx] = !(matches[idx] = matched[i]);
              }
            }) : function (elem) {
              return fn(elem, 0, args);
            };
          }
          return fn;
        }
      },
      pseudos: {
        'not': markFunction(function (selector) {
          var input = [], results = [], matcher = compile(selector.replace(rtrim, '$1'));
          return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
            var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
            while (i--) {
              if (elem = unmatched[i]) {
                seed[i] = !(matches[i] = elem);
              }
            }
          }) : function (elem, context, xml) {
            input[0] = elem;
            matcher(input, null, xml, results);
            return !results.pop();
          };
        }),
        'has': markFunction(function (selector) {
          return function (elem) {
            return Sizzle(selector, elem).length > 0;
          };
        }),
        'contains': markFunction(function (text) {
          return function (elem) {
            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
          };
        }),
        'lang': markFunction(function (lang) {
          if (!ridentifier.test(lang || '')) {
            Sizzle.error('unsupported lang: ' + lang);
          }
          lang = lang.replace(runescape, funescape).toLowerCase();
          return function (elem) {
            var elemLang;
            do {
              if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute('xml:lang') || elem.getAttribute('lang')) {
                elemLang = elemLang.toLowerCase();
                return elemLang === lang || elemLang.indexOf(lang + '-') === 0;
              }
            } while ((elem = elem.parentNode) && elem.nodeType === 1);
            return false;
          };
        }),
        'target': function (elem) {
          var hash = window.location && window.location.hash;
          return hash && hash.slice(1) === elem.id;
        },
        'root': function (elem) {
          return elem === docElem;
        },
        'focus': function (elem) {
          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },
        'enabled': function (elem) {
          return elem.disabled === false;
        },
        'disabled': function (elem) {
          return elem.disabled === true;
        },
        'checked': function (elem) {
          var nodeName = elem.nodeName.toLowerCase();
          return nodeName === 'input' && !!elem.checked || nodeName === 'option' && !!elem.selected;
        },
        'selected': function (elem) {
          if (elem.parentNode) {
            elem.parentNode.selectedIndex;
          }
          return elem.selected === true;
        },
        'empty': function (elem) {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            if (elem.nodeName > '@' || elem.nodeType === 3 || elem.nodeType === 4) {
              return false;
            }
          }
          return true;
        },
        'parent': function (elem) {
          return !Expr.pseudos['empty'](elem);
        },
        'header': function (elem) {
          return rheader.test(elem.nodeName);
        },
        'input': function (elem) {
          return rinputs.test(elem.nodeName);
        },
        'button': function (elem) {
          var name = elem.nodeName.toLowerCase();
          return name === 'input' && elem.type === 'button' || name === 'button';
        },
        'text': function (elem) {
          var attr;
          return elem.nodeName.toLowerCase() === 'input' && elem.type === 'text' && ((attr = elem.getAttribute('type')) == null || attr.toLowerCase() === elem.type);
        },
        'first': createPositionalPseudo(function () {
          return [0];
        }),
        'last': createPositionalPseudo(function (matchIndexes, length) {
          return [length - 1];
        }),
        'eq': createPositionalPseudo(function (matchIndexes, length, argument) {
          return [argument < 0 ? argument + length : argument];
        }),
        'even': createPositionalPseudo(function (matchIndexes, length) {
          var i = 0;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        'odd': createPositionalPseudo(function (matchIndexes, length) {
          var i = 1;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        'lt': createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; --i >= 0;) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        'gt': createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; ++i < length;) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        })
      }
    };
    Expr.pseudos['nth'] = Expr.pseudos['eq'];
    for (i in {
        radio: true,
        checkbox: true,
        file: true,
        password: true,
        image: true
      }) {
      Expr.pseudos[i] = createInputPseudo(i);
    }
    for (i in {
        submit: true,
        reset: true
      }) {
      Expr.pseudos[i] = createButtonPseudo(i);
    }
    function setFilters() {
    }
    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();
    function tokenize(selector, parseOnly) {
      var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + ' '];
      if (cached) {
        return parseOnly ? 0 : cached.slice(0);
      }
      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;
      while (soFar) {
        if (!matched || (match = rcomma.exec(soFar))) {
          if (match) {
            soFar = soFar.slice(match[0].length) || soFar;
          }
          groups.push(tokens = []);
        }
        matched = false;
        if (match = rcombinators.exec(soFar)) {
          matched = match.shift();
          tokens.push({
            value: matched,
            type: match[0].replace(rtrim, ' ')
          });
          soFar = soFar.slice(matched.length);
        }
        for (type in Expr.filter) {
          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: type,
              matches: match
            });
            soFar = soFar.slice(matched.length);
          }
        }
        if (!matched) {
          break;
        }
      }
      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
    }
    function toSelector(tokens) {
      var i = 0, len = tokens.length, selector = '';
      for (; i < len; i++) {
        selector += tokens[i].value;
      }
      return selector;
    }
    function addCombinator(matcher, combinator, base) {
      var dir = combinator.dir, checkNonElements = base && dir === 'parentNode', doneName = done++;
      return combinator.first ? function (elem, context, xml) {
        while (elem = elem[dir]) {
          if (elem.nodeType === 1 || checkNonElements) {
            return matcher(elem, context, xml);
          }
        }
      } : function (elem, context, xml) {
        var data, cache, outerCache, dirkey = dirruns + ' ' + doneName;
        if (xml) {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              if (matcher(elem, context, xml)) {
                return true;
              }
            }
          }
        } else {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              outerCache = elem[expando] || (elem[expando] = {});
              if ((cache = outerCache[dir]) && cache[0] === dirkey) {
                if ((data = cache[1]) === true || data === cachedruns) {
                  return data === true;
                }
              } else {
                cache = outerCache[dir] = [dirkey];
                cache[1] = matcher(elem, context, xml) || cachedruns;
                if (cache[1] === true) {
                  return true;
                }
              }
            }
          }
        }
      };
    }
    function elementMatcher(matchers) {
      return matchers.length > 1 ? function (elem, context, xml) {
        var i = matchers.length;
        while (i--) {
          if (!matchers[i](elem, context, xml)) {
            return false;
          }
        }
        return true;
      } : matchers[0];
    }
    function condense(unmatched, map, filter, context, xml) {
      var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
      for (; i < len; i++) {
        if (elem = unmatched[i]) {
          if (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);
            if (mapped) {
              map.push(i);
            }
          }
        }
      }
      return newUnmatched;
    }
    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
      if (postFilter && !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }
      if (postFinder && !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }
      return markFunction(function (seed, results, context, xml) {
        var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || '*', context.nodeType ? [context] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
        if (matcher) {
          matcher(matcherIn, matcherOut, context, xml);
        }
        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml);
          i = temp.length;
          while (i--) {
            if (elem = temp[i]) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }
        if (seed) {
          if (postFinder || preFilter) {
            if (postFinder) {
              temp = [];
              i = matcherOut.length;
              while (i--) {
                if (elem = matcherOut[i]) {
                  temp.push(matcherIn[i] = elem);
                }
              }
              postFinder(null, matcherOut = [], temp, xml);
            }
            i = matcherOut.length;
            while (i--) {
              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {
                seed[temp] = !(results[temp] = elem);
              }
            }
          }
        } else {
          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
          if (postFinder) {
            postFinder(null, results, matcherOut, xml);
          } else {
            push.apply(results, matcherOut);
          }
        }
      });
    }
    function matcherFromTokens(tokens) {
      var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[' '], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function (elem) {
          return elem === checkContext;
        }, implicitRelative, true), matchAnyContext = addCombinator(function (elem) {
          return indexOf.call(checkContext, elem) > -1;
        }, implicitRelative, true), matchers = [function (elem, context, xml) {
            return !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
          }];
      for (; i < len; i++) {
        if (matcher = Expr.relative[tokens[i].type]) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
          if (matcher[expando]) {
            j = ++i;
            for (; j < len; j++) {
              if (Expr.relative[tokens[j].type]) {
                break;
              }
            }
            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === ' ' ? '*' : '' })).replace(rtrim, '$1'), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
          }
          matchers.push(matcher);
        }
      }
      return elementMatcher(matchers);
    }
    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      var matcherCachedRuns = 0, bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function (seed, context, xml, results, expandContext) {
          var elem, j, matcher, setMatched = [], matchedCount = 0, i = '0', unmatched = seed && [], outermost = expandContext != null, contextBackup = outermostContext, elems = seed || byElement && Expr.find['TAG']('*', expandContext && context.parentNode || context), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1;
          if (outermost) {
            outermostContext = context !== document && context;
            cachedruns = matcherCachedRuns;
          }
          for (; (elem = elems[i]) != null; i++) {
            if (byElement && elem) {
              j = 0;
              while (matcher = elementMatchers[j++]) {
                if (matcher(elem, context, xml)) {
                  results.push(elem);
                  break;
                }
              }
              if (outermost) {
                dirruns = dirrunsUnique;
                cachedruns = ++matcherCachedRuns;
              }
            }
            if (bySet) {
              if (elem = !matcher && elem) {
                matchedCount--;
              }
              if (seed) {
                unmatched.push(elem);
              }
            }
          }
          matchedCount += i;
          if (bySet && i !== matchedCount) {
            j = 0;
            while (matcher = setMatchers[j++]) {
              matcher(unmatched, setMatched, context, xml);
            }
            if (seed) {
              if (matchedCount > 0) {
                while (i--) {
                  if (!(unmatched[i] || setMatched[i])) {
                    setMatched[i] = pop.call(results);
                  }
                }
              }
              setMatched = condense(setMatched);
            }
            push.apply(results, setMatched);
            if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
              Sizzle.uniqueSort(results);
            }
          }
          if (outermost) {
            dirruns = dirrunsUnique;
            outermostContext = contextBackup;
          }
          return unmatched;
        };
      return bySet ? markFunction(superMatcher) : superMatcher;
    }
    compile = Sizzle.compile = function (selector, group) {
      var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + ' '];
      if (!cached) {
        if (!group) {
          group = tokenize(selector);
        }
        i = group.length;
        while (i--) {
          cached = matcherFromTokens(group[i]);
          if (cached[expando]) {
            setMatchers.push(cached);
          } else {
            elementMatchers.push(cached);
          }
        }
        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
      }
      return cached;
    };
    function multipleContexts(selector, contexts, results) {
      var i = 0, len = contexts.length;
      for (; i < len; i++) {
        Sizzle(selector, contexts[i], results);
      }
      return results;
    }
    function select(selector, context, results, seed) {
      var i, tokens, token, type, find, match = tokenize(selector);
      if (!seed) {
        if (match.length === 1) {
          tokens = match[0] = match[0].slice(0);
          if (tokens.length > 2 && (token = tokens[0]).type === 'ID' && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
            context = (Expr.find['ID'](token.matches[0].replace(runescape, funescape), context) || [])[0];
            if (!context) {
              return results;
            }
            selector = selector.slice(tokens.shift().value.length);
          }
          i = matchExpr['needsContext'].test(selector) ? 0 : tokens.length;
          while (i--) {
            token = tokens[i];
            if (Expr.relative[type = token.type]) {
              break;
            }
            if (find = Expr.find[type]) {
              if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && context.parentNode || context)) {
                tokens.splice(i, 1);
                selector = seed.length && toSelector(tokens);
                if (!selector) {
                  push.apply(results, seed);
                  return results;
                }
                break;
              }
            }
          }
        }
      }
      compile(selector, match)(seed, context, !documentIsHTML, results, rsibling.test(selector));
      return results;
    }
    support.sortStable = expando.split('').sort(sortOrder).join('') === expando;
    support.detectDuplicates = hasDuplicate;
    setDocument();
    support.sortDetached = assert(function (div1) {
      return div1.compareDocumentPosition(document.createElement('div')) & 1;
    });
    if (!assert(function (div) {
        div.innerHTML = '<a href=\'#\'></a>';
        return div.firstChild.getAttribute('href') === '#';
      })) {
      addHandle('type|href|height|width', function (elem, name, isXML) {
        if (!isXML) {
          return elem.getAttribute(name, name.toLowerCase() === 'type' ? 1 : 2);
        }
      });
    }
    if (!support.attributes || !assert(function (div) {
        div.innerHTML = '<input/>';
        div.firstChild.setAttribute('value', '');
        return div.firstChild.getAttribute('value') === '';
      })) {
      addHandle('value', function (elem, name, isXML) {
        if (!isXML && elem.nodeName.toLowerCase() === 'input') {
          return elem.defaultValue;
        }
      });
    }
    if (!assert(function (div) {
        return div.getAttribute('disabled') == null;
      })) {
      addHandle(booleans, function (elem, name, isXML) {
        var val;
        if (!isXML) {
          return (val = elem.getAttributeNode(name)) && val.specified ? val.value : elem[name] === true ? name.toLowerCase() : null;
        }
      });
    }
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[':'] = jQuery.expr.pseudos;
    jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
  }(window));
  var optionsCache = {};
  function createOptions(options) {
    var object = optionsCache[options] = {};
    jQuery.each(options.match(core_rnotwhite) || [], function (_, flag) {
      object[flag] = true;
    });
    return object;
  }
  jQuery.Callbacks = function (options) {
    options = typeof options === 'string' ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);
    var memory, fired, firing, firingStart, firingLength, firingIndex, list = [], stack = !options.once && [], fire = function (data) {
        memory = options.memory && data;
        fired = true;
        firingIndex = firingStart || 0;
        firingStart = 0;
        firingLength = list.length;
        firing = true;
        for (; list && firingIndex < firingLength; firingIndex++) {
          if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
            memory = false;
            break;
          }
        }
        firing = false;
        if (list) {
          if (stack) {
            if (stack.length) {
              fire(stack.shift());
            }
          } else if (memory) {
            list = [];
          } else {
            self.disable();
          }
        }
      }, self = {
        add: function () {
          if (list) {
            var start = list.length;
            (function add(args) {
              jQuery.each(args, function (_, arg) {
                var type = jQuery.type(arg);
                if (type === 'function') {
                  if (!options.unique || !self.has(arg)) {
                    list.push(arg);
                  }
                } else if (arg && arg.length && type !== 'string') {
                  add(arg);
                }
              });
            }(arguments));
            if (firing) {
              firingLength = list.length;
            } else if (memory) {
              firingStart = start;
              fire(memory);
            }
          }
          return this;
        },
        remove: function () {
          if (list) {
            jQuery.each(arguments, function (_, arg) {
              var index;
              while ((index = jQuery.inArray(arg, list, index)) > -1) {
                list.splice(index, 1);
                if (firing) {
                  if (index <= firingLength) {
                    firingLength--;
                  }
                  if (index <= firingIndex) {
                    firingIndex--;
                  }
                }
              }
            });
          }
          return this;
        },
        has: function (fn) {
          return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
        },
        empty: function () {
          list = [];
          firingLength = 0;
          return this;
        },
        disable: function () {
          list = stack = memory = undefined;
          return this;
        },
        disabled: function () {
          return !list;
        },
        lock: function () {
          stack = undefined;
          if (!memory) {
            self.disable();
          }
          return this;
        },
        locked: function () {
          return !stack;
        },
        fireWith: function (context, args) {
          if (list && (!fired || stack)) {
            args = args || [];
            args = [
              context,
              args.slice ? args.slice() : args
            ];
            if (firing) {
              stack.push(args);
            } else {
              fire(args);
            }
          }
          return this;
        },
        fire: function () {
          self.fireWith(this, arguments);
          return this;
        },
        fired: function () {
          return !!fired;
        }
      };
    return self;
  };
  jQuery.extend({
    Deferred: function (func) {
      var tuples = [
          [
            'resolve',
            'done',
            jQuery.Callbacks('once memory'),
            'resolved'
          ],
          [
            'reject',
            'fail',
            jQuery.Callbacks('once memory'),
            'rejected'
          ],
          [
            'notify',
            'progress',
            jQuery.Callbacks('memory')
          ]
        ], state = 'pending', promise = {
          state: function () {
            return state;
          },
          always: function () {
            deferred.done(arguments).fail(arguments);
            return this;
          },
          then: function () {
            var fns = arguments;
            return jQuery.Deferred(function (newDefer) {
              jQuery.each(tuples, function (i, tuple) {
                var action = tuple[0], fn = jQuery.isFunction(fns[i]) && fns[i];
                deferred[tuple[1]](function () {
                  var returned = fn && fn.apply(this, arguments);
                  if (returned && jQuery.isFunction(returned.promise)) {
                    returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
                  } else {
                    newDefer[action + 'With'](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                  }
                });
              });
              fns = null;
            }).promise();
          },
          promise: function (obj) {
            return obj != null ? jQuery.extend(obj, promise) : promise;
          }
        }, deferred = {};
      promise.pipe = promise.then;
      jQuery.each(tuples, function (i, tuple) {
        var list = tuple[2], stateString = tuple[3];
        promise[tuple[1]] = list.add;
        if (stateString) {
          list.add(function () {
            state = stateString;
          }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
        }
        deferred[tuple[0]] = function () {
          deferred[tuple[0] + 'With'](this === deferred ? promise : this, arguments);
          return this;
        };
        deferred[tuple[0] + 'With'] = list.fireWith;
      });
      promise.promise(deferred);
      if (func) {
        func.call(deferred, deferred);
      }
      return deferred;
    },
    when: function (subordinate) {
      var i = 0, resolveValues = core_slice.call(arguments), length = resolveValues.length, remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0, deferred = remaining === 1 ? subordinate : jQuery.Deferred(), updateFunc = function (i, contexts, values) {
          return function (value) {
            contexts[i] = this;
            values[i] = arguments.length > 1 ? core_slice.call(arguments) : value;
            if (values === progressValues) {
              deferred.notifyWith(contexts, values);
            } else if (!--remaining) {
              deferred.resolveWith(contexts, values);
            }
          };
        }, progressValues, progressContexts, resolveContexts;
      if (length > 1) {
        progressValues = new Array(length);
        progressContexts = new Array(length);
        resolveContexts = new Array(length);
        for (; i < length; i++) {
          if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
            resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));
          } else {
            --remaining;
          }
        }
      }
      if (!remaining) {
        deferred.resolveWith(resolveContexts, resolveValues);
      }
      return deferred.promise();
    }
  });
  jQuery.support = function (support) {
    var input = document.createElement('input'), fragment = document.createDocumentFragment(), div = document.createElement('div'), select = document.createElement('select'), opt = select.appendChild(document.createElement('option'));
    if (!input.type) {
      return support;
    }
    input.type = 'checkbox';
    support.checkOn = input.value !== '';
    support.optSelected = opt.selected;
    support.reliableMarginRight = true;
    support.boxSizingReliable = true;
    support.pixelPosition = false;
    input.checked = true;
    support.noCloneChecked = input.cloneNode(true).checked;
    select.disabled = true;
    support.optDisabled = !opt.disabled;
    input = document.createElement('input');
    input.value = 't';
    input.type = 'radio';
    support.radioValue = input.value === 't';
    input.setAttribute('checked', 't');
    input.setAttribute('name', 't');
    fragment.appendChild(input);
    support.checkClone = fragment.cloneNode(true).cloneNode(true).lastChild.checked;
    support.focusinBubbles = 'onfocusin' in window;
    div.style.backgroundClip = 'content-box';
    div.cloneNode(true).style.backgroundClip = '';
    support.clearCloneStyle = div.style.backgroundClip === 'content-box';
    jQuery(function () {
      var container, marginDiv, divReset = 'padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box', body = document.getElementsByTagName('body')[0];
      if (!body) {
        return;
      }
      container = document.createElement('div');
      container.style.cssText = 'border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px';
      body.appendChild(container).appendChild(div);
      div.innerHTML = '';
      div.style.cssText = '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%';
      jQuery.swap(body, body.style.zoom != null ? { zoom: 1 } : {}, function () {
        support.boxSizing = div.offsetWidth === 4;
      });
      if (window.getComputedStyle) {
        support.pixelPosition = (window.getComputedStyle(div, null) || {}).top !== '1%';
        support.boxSizingReliable = (window.getComputedStyle(div, null) || { width: '4px' }).width === '4px';
        marginDiv = div.appendChild(document.createElement('div'));
        marginDiv.style.cssText = div.style.cssText = divReset;
        marginDiv.style.marginRight = marginDiv.style.width = '0';
        div.style.width = '1px';
        support.reliableMarginRight = !parseFloat((window.getComputedStyle(marginDiv, null) || {}).marginRight);
      }
      body.removeChild(container);
    });
    return support;
  }({});
  var data_user, data_priv, rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/, rmultiDash = /([A-Z])/g;
  function Data() {
    Object.defineProperty(this.cache = {}, 0, {
      get: function () {
        return {};
      }
    });
    this.expando = jQuery.expando + Math.random();
  }
  Data.uid = 1;
  Data.accepts = function (owner) {
    return owner.nodeType ? owner.nodeType === 1 || owner.nodeType === 9 : true;
  };
  Data.prototype = {
    key: function (owner) {
      if (!Data.accepts(owner)) {
        return 0;
      }
      var descriptor = {}, unlock = owner[this.expando];
      if (!unlock) {
        unlock = Data.uid++;
        try {
          descriptor[this.expando] = { value: unlock };
          Object.defineProperties(owner, descriptor);
        } catch (e) {
          descriptor[this.expando] = unlock;
          jQuery.extend(owner, descriptor);
        }
      }
      if (!this.cache[unlock]) {
        this.cache[unlock] = {};
      }
      return unlock;
    },
    set: function (owner, data, value) {
      var prop, unlock = this.key(owner), cache = this.cache[unlock];
      if (typeof data === 'string') {
        cache[data] = value;
      } else {
        if (jQuery.isEmptyObject(cache)) {
          jQuery.extend(this.cache[unlock], data);
        } else {
          for (prop in data) {
            cache[prop] = data[prop];
          }
        }
      }
      return cache;
    },
    get: function (owner, key) {
      var cache = this.cache[this.key(owner)];
      return key === undefined ? cache : cache[key];
    },
    access: function (owner, key, value) {
      var stored;
      if (key === undefined || key && typeof key === 'string' && value === undefined) {
        stored = this.get(owner, key);
        return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
      }
      this.set(owner, key, value);
      return value !== undefined ? value : key;
    },
    remove: function (owner, key) {
      var i, name, camel, unlock = this.key(owner), cache = this.cache[unlock];
      if (key === undefined) {
        this.cache[unlock] = {};
      } else {
        if (jQuery.isArray(key)) {
          name = key.concat(key.map(jQuery.camelCase));
        } else {
          camel = jQuery.camelCase(key);
          if (key in cache) {
            name = [
              key,
              camel
            ];
          } else {
            name = camel;
            name = name in cache ? [name] : name.match(core_rnotwhite) || [];
          }
        }
        i = name.length;
        while (i--) {
          delete cache[name[i]];
        }
      }
    },
    hasData: function (owner) {
      return !jQuery.isEmptyObject(this.cache[owner[this.expando]] || {});
    },
    discard: function (owner) {
      if (owner[this.expando]) {
        delete this.cache[owner[this.expando]];
      }
    }
  };
  data_user = new Data();
  data_priv = new Data();
  jQuery.extend({
    acceptData: Data.accepts,
    hasData: function (elem) {
      return data_user.hasData(elem) || data_priv.hasData(elem);
    },
    data: function (elem, name, data) {
      return data_user.access(elem, name, data);
    },
    removeData: function (elem, name) {
      data_user.remove(elem, name);
    },
    _data: function (elem, name, data) {
      return data_priv.access(elem, name, data);
    },
    _removeData: function (elem, name) {
      data_priv.remove(elem, name);
    }
  });
  jQuery.fn.extend({
    data: function (key, value) {
      var attrs, name, elem = this[0], i = 0, data = null;
      if (key === undefined) {
        if (this.length) {
          data = data_user.get(elem);
          if (elem.nodeType === 1 && !data_priv.get(elem, 'hasDataAttrs')) {
            attrs = elem.attributes;
            for (; i < attrs.length; i++) {
              name = attrs[i].name;
              if (name.indexOf('data-') === 0) {
                name = jQuery.camelCase(name.slice(5));
                dataAttr(elem, name, data[name]);
              }
            }
            data_priv.set(elem, 'hasDataAttrs', true);
          }
        }
        return data;
      }
      if (typeof key === 'object') {
        return this.each(function () {
          data_user.set(this, key);
        });
      }
      return jQuery.access(this, function (value) {
        var data, camelKey = jQuery.camelCase(key);
        if (elem && value === undefined) {
          data = data_user.get(elem, key);
          if (data !== undefined) {
            return data;
          }
          data = data_user.get(elem, camelKey);
          if (data !== undefined) {
            return data;
          }
          data = dataAttr(elem, camelKey, undefined);
          if (data !== undefined) {
            return data;
          }
          return;
        }
        this.each(function () {
          var data = data_user.get(this, camelKey);
          data_user.set(this, camelKey, value);
          if (key.indexOf('-') !== -1 && data !== undefined) {
            data_user.set(this, key, value);
          }
        });
      }, null, value, arguments.length > 1, null, true);
    },
    removeData: function (key) {
      return this.each(function () {
        data_user.remove(this, key);
      });
    }
  });
  function dataAttr(elem, key, data) {
    var name;
    if (data === undefined && elem.nodeType === 1) {
      name = 'data-' + key.replace(rmultiDash, '-$1').toLowerCase();
      data = elem.getAttribute(name);
      if (typeof data === 'string') {
        try {
          data = data === 'true' ? true : data === 'false' ? false : data === 'null' ? null : +data + '' === data ? +data : rbrace.test(data) ? JSON.parse(data) : data;
        } catch (e) {
        }
        data_user.set(elem, key, data);
      } else {
        data = undefined;
      }
    }
    return data;
  }
  jQuery.extend({
    queue: function (elem, type, data) {
      var queue;
      if (elem) {
        type = (type || 'fx') + 'queue';
        queue = data_priv.get(elem, type);
        if (data) {
          if (!queue || jQuery.isArray(data)) {
            queue = data_priv.access(elem, type, jQuery.makeArray(data));
          } else {
            queue.push(data);
          }
        }
        return queue || [];
      }
    },
    dequeue: function (elem, type) {
      type = type || 'fx';
      var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function () {
          jQuery.dequeue(elem, type);
        };
      if (fn === 'inprogress') {
        fn = queue.shift();
        startLength--;
      }
      if (fn) {
        if (type === 'fx') {
          queue.unshift('inprogress');
        }
        delete hooks.stop;
        fn.call(elem, next, hooks);
      }
      if (!startLength && hooks) {
        hooks.empty.fire();
      }
    },
    _queueHooks: function (elem, type) {
      var key = type + 'queueHooks';
      return data_priv.get(elem, key) || data_priv.access(elem, key, {
        empty: jQuery.Callbacks('once memory').add(function () {
          data_priv.remove(elem, [
            type + 'queue',
            key
          ]);
        })
      });
    }
  });
  jQuery.fn.extend({
    queue: function (type, data) {
      var setter = 2;
      if (typeof type !== 'string') {
        data = type;
        type = 'fx';
        setter--;
      }
      if (arguments.length < setter) {
        return jQuery.queue(this[0], type);
      }
      return data === undefined ? this : this.each(function () {
        var queue = jQuery.queue(this, type, data);
        jQuery._queueHooks(this, type);
        if (type === 'fx' && queue[0] !== 'inprogress') {
          jQuery.dequeue(this, type);
        }
      });
    },
    dequeue: function (type) {
      return this.each(function () {
        jQuery.dequeue(this, type);
      });
    },
    delay: function (time, type) {
      time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
      type = type || 'fx';
      return this.queue(type, function (next, hooks) {
        var timeout = setTimeout(next, time);
        hooks.stop = function () {
          clearTimeout(timeout);
        };
      });
    },
    clearQueue: function (type) {
      return this.queue(type || 'fx', []);
    },
    promise: function (type, obj) {
      var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function () {
          if (!--count) {
            defer.resolveWith(elements, [elements]);
          }
        };
      if (typeof type !== 'string') {
        obj = type;
        type = undefined;
      }
      type = type || 'fx';
      while (i--) {
        tmp = data_priv.get(elements[i], type + 'queueHooks');
        if (tmp && tmp.empty) {
          count++;
          tmp.empty.add(resolve);
        }
      }
      resolve();
      return defer.promise(obj);
    }
  });
  var nodeHook, boolHook, rclass = /[\t\r\n\f]/g, rreturn = /\r/g, rfocusable = /^(?:input|select|textarea|button)$/i;
  jQuery.fn.extend({
    attr: function (name, value) {
      return jQuery.access(this, jQuery.attr, name, value, arguments.length > 1);
    },
    removeAttr: function (name) {
      return this.each(function () {
        jQuery.removeAttr(this, name);
      });
    },
    prop: function (name, value) {
      return jQuery.access(this, jQuery.prop, name, value, arguments.length > 1);
    },
    removeProp: function (name) {
      return this.each(function () {
        delete this[jQuery.propFix[name] || name];
      });
    },
    addClass: function (value) {
      var classes, elem, cur, clazz, j, i = 0, len = this.length, proceed = typeof value === 'string' && value;
      if (jQuery.isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).addClass(value.call(this, j, this.className));
        });
      }
      if (proceed) {
        classes = (value || '').match(core_rnotwhite) || [];
        for (; i < len; i++) {
          elem = this[i];
          cur = elem.nodeType === 1 && (elem.className ? (' ' + elem.className + ' ').replace(rclass, ' ') : ' ');
          if (cur) {
            j = 0;
            while (clazz = classes[j++]) {
              if (cur.indexOf(' ' + clazz + ' ') < 0) {
                cur += clazz + ' ';
              }
            }
            elem.className = jQuery.trim(cur);
          }
        }
      }
      return this;
    },
    removeClass: function (value) {
      var classes, elem, cur, clazz, j, i = 0, len = this.length, proceed = arguments.length === 0 || typeof value === 'string' && value;
      if (jQuery.isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).removeClass(value.call(this, j, this.className));
        });
      }
      if (proceed) {
        classes = (value || '').match(core_rnotwhite) || [];
        for (; i < len; i++) {
          elem = this[i];
          cur = elem.nodeType === 1 && (elem.className ? (' ' + elem.className + ' ').replace(rclass, ' ') : '');
          if (cur) {
            j = 0;
            while (clazz = classes[j++]) {
              while (cur.indexOf(' ' + clazz + ' ') >= 0) {
                cur = cur.replace(' ' + clazz + ' ', ' ');
              }
            }
            elem.className = value ? jQuery.trim(cur) : '';
          }
        }
      }
      return this;
    },
    toggleClass: function (value, stateVal) {
      var type = typeof value;
      if (typeof stateVal === 'boolean' && type === 'string') {
        return stateVal ? this.addClass(value) : this.removeClass(value);
      }
      if (jQuery.isFunction(value)) {
        return this.each(function (i) {
          jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
        });
      }
      return this.each(function () {
        if (type === 'string') {
          var className, i = 0, self = jQuery(this), classNames = value.match(core_rnotwhite) || [];
          while (className = classNames[i++]) {
            if (self.hasClass(className)) {
              self.removeClass(className);
            } else {
              self.addClass(className);
            }
          }
        } else if (type === core_strundefined || type === 'boolean') {
          if (this.className) {
            data_priv.set(this, '__className__', this.className);
          }
          this.className = this.className || value === false ? '' : data_priv.get(this, '__className__') || '';
        }
      });
    },
    hasClass: function (selector) {
      var className = ' ' + selector + ' ', i = 0, l = this.length;
      for (; i < l; i++) {
        if (this[i].nodeType === 1 && (' ' + this[i].className + ' ').replace(rclass, ' ').indexOf(className) >= 0) {
          return true;
        }
      }
      return false;
    },
    val: function (value) {
      var hooks, ret, isFunction, elem = this[0];
      if (!arguments.length) {
        if (elem) {
          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
          if (hooks && 'get' in hooks && (ret = hooks.get(elem, 'value')) !== undefined) {
            return ret;
          }
          ret = elem.value;
          return typeof ret === 'string' ? ret.replace(rreturn, '') : ret == null ? '' : ret;
        }
        return;
      }
      isFunction = jQuery.isFunction(value);
      return this.each(function (i) {
        var val;
        if (this.nodeType !== 1) {
          return;
        }
        if (isFunction) {
          val = value.call(this, i, jQuery(this).val());
        } else {
          val = value;
        }
        if (val == null) {
          val = '';
        } else if (typeof val === 'number') {
          val += '';
        } else if (jQuery.isArray(val)) {
          val = jQuery.map(val, function (value) {
            return value == null ? '' : value + '';
          });
        }
        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
        if (!hooks || !('set' in hooks) || hooks.set(this, val, 'value') === undefined) {
          this.value = val;
        }
      });
    }
  });
  jQuery.extend({
    valHooks: {
      option: {
        get: function (elem) {
          var val = elem.attributes.value;
          return !val || val.specified ? elem.value : elem.text;
        }
      },
      select: {
        get: function (elem) {
          var value, option, options = elem.options, index = elem.selectedIndex, one = elem.type === 'select-one' || index < 0, values = one ? null : [], max = one ? index + 1 : options.length, i = index < 0 ? max : one ? index : 0;
          for (; i < max; i++) {
            option = options[i];
            if ((option.selected || i === index) && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute('disabled') === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, 'optgroup'))) {
              value = jQuery(option).val();
              if (one) {
                return value;
              }
              values.push(value);
            }
          }
          return values;
        },
        set: function (elem, value) {
          var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
          while (i--) {
            option = options[i];
            if (option.selected = jQuery.inArray(jQuery(option).val(), values) >= 0) {
              optionSet = true;
            }
          }
          if (!optionSet) {
            elem.selectedIndex = -1;
          }
          return values;
        }
      }
    },
    attr: function (elem, name, value) {
      var hooks, ret, nType = elem.nodeType;
      if (!elem || nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      if (typeof elem.getAttribute === core_strundefined) {
        return jQuery.prop(elem, name, value);
      }
      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        name = name.toLowerCase();
        hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
      }
      if (value !== undefined) {
        if (value === null) {
          jQuery.removeAttr(elem, name);
        } else if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        } else {
          elem.setAttribute(name, value + '');
          return value;
        }
      } else if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      } else {
        ret = jQuery.find.attr(elem, name);
        return ret == null ? undefined : ret;
      }
    },
    removeAttr: function (elem, value) {
      var name, propName, i = 0, attrNames = value && value.match(core_rnotwhite);
      if (attrNames && elem.nodeType === 1) {
        while (name = attrNames[i++]) {
          propName = jQuery.propFix[name] || name;
          if (jQuery.expr.match.bool.test(name)) {
            elem[propName] = false;
          }
          elem.removeAttribute(name);
        }
      }
    },
    attrHooks: {
      type: {
        set: function (elem, value) {
          if (!jQuery.support.radioValue && value === 'radio' && jQuery.nodeName(elem, 'input')) {
            var val = elem.value;
            elem.setAttribute('type', value);
            if (val) {
              elem.value = val;
            }
            return value;
          }
        }
      }
    },
    propFix: {
      'for': 'htmlFor',
      'class': 'className'
    },
    prop: function (elem, name, value) {
      var ret, hooks, notxml, nType = elem.nodeType;
      if (!elem || nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
      if (notxml) {
        name = jQuery.propFix[name] || name;
        hooks = jQuery.propHooks[name];
      }
      if (value !== undefined) {
        return hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : elem[name] = value;
      } else {
        return hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];
      }
    },
    propHooks: {
      tabIndex: {
        get: function (elem) {
          return elem.hasAttribute('tabindex') || rfocusable.test(elem.nodeName) || elem.href ? elem.tabIndex : -1;
        }
      }
    }
  });
  boolHook = {
    set: function (elem, value, name) {
      if (value === false) {
        jQuery.removeAttr(elem, name);
      } else {
        elem.setAttribute(name, name);
      }
      return name;
    }
  };
  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
    var getter = jQuery.expr.attrHandle[name] || jQuery.find.attr;
    jQuery.expr.attrHandle[name] = function (elem, name, isXML) {
      var fn = jQuery.expr.attrHandle[name], ret = isXML ? undefined : (jQuery.expr.attrHandle[name] = undefined) != getter(elem, name, isXML) ? name.toLowerCase() : null;
      jQuery.expr.attrHandle[name] = fn;
      return ret;
    };
  });
  if (!jQuery.support.optSelected) {
    jQuery.propHooks.selected = {
      get: function (elem) {
        var parent = elem.parentNode;
        if (parent && parent.parentNode) {
          parent.parentNode.selectedIndex;
        }
        return null;
      }
    };
  }
  jQuery.each([
    'tabIndex',
    'readOnly',
    'maxLength',
    'cellSpacing',
    'cellPadding',
    'rowSpan',
    'colSpan',
    'useMap',
    'frameBorder',
    'contentEditable'
  ], function () {
    jQuery.propFix[this.toLowerCase()] = this;
  });
  jQuery.each([
    'radio',
    'checkbox'
  ], function () {
    jQuery.valHooks[this] = {
      set: function (elem, value) {
        if (jQuery.isArray(value)) {
          return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0;
        }
      }
    };
    if (!jQuery.support.checkOn) {
      jQuery.valHooks[this].get = function (elem) {
        return elem.getAttribute('value') === null ? 'on' : elem.value;
      };
    }
  });
  var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|contextmenu)|click/, rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
  function returnTrue() {
    return true;
  }
  function returnFalse() {
    return false;
  }
  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch (err) {
    }
  }
  jQuery.event = {
    global: {},
    add: function (elem, types, handler, data, selector) {
      var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.get(elem);
      if (!elemData) {
        return;
      }
      if (handler.handler) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      }
      if (!handler.guid) {
        handler.guid = jQuery.guid++;
      }
      if (!(events = elemData.events)) {
        events = elemData.events = {};
      }
      if (!(eventHandle = elemData.handle)) {
        eventHandle = elemData.handle = function (e) {
          return typeof jQuery !== core_strundefined && (!e || jQuery.event.triggered !== e.type) ? jQuery.event.dispatch.apply(eventHandle.elem, arguments) : undefined;
        };
        eventHandle.elem = elem;
      }
      types = (types || '').match(core_rnotwhite) || [''];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || '').split('.').sort();
        if (!type) {
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        special = jQuery.event.special[type] || {};
        handleObj = jQuery.extend({
          type: type,
          origType: origType,
          data: data,
          handler: handler,
          guid: handler.guid,
          selector: selector,
          needsContext: selector && jQuery.expr.match.needsContext.test(selector),
          namespace: namespaces.join('.')
        }, handleObjIn);
        if (!(handlers = events[type])) {
          handlers = events[type] = [];
          handlers.delegateCount = 0;
          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
            if (elem.addEventListener) {
              elem.addEventListener(type, eventHandle, false);
            }
          }
        }
        if (special.add) {
          special.add.call(elem, handleObj);
          if (!handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        }
        if (selector) {
          handlers.splice(handlers.delegateCount++, 0, handleObj);
        } else {
          handlers.push(handleObj);
        }
        jQuery.event.global[type] = true;
      }
      elem = null;
    },
    remove: function (elem, types, handler, selector, mappedTypes) {
      var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.hasData(elem) && data_priv.get(elem);
      if (!elemData || !(events = elemData.events)) {
        return;
      }
      types = (types || '').match(core_rnotwhite) || [''];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || '').split('.').sort();
        if (!type) {
          for (type in events) {
            jQuery.event.remove(elem, type + types[t], handler, selector, true);
          }
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        handlers = events[type] || [];
        tmp = tmp[2] && new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)');
        origCount = j = handlers.length;
        while (j--) {
          handleObj = handlers[j];
          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === '**' && handleObj.selector)) {
            handlers.splice(j, 1);
            if (handleObj.selector) {
              handlers.delegateCount--;
            }
            if (special.remove) {
              special.remove.call(elem, handleObj);
            }
          }
        }
        if (origCount && !handlers.length) {
          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
            jQuery.removeEvent(elem, type, elemData.handle);
          }
          delete events[type];
        }
      }
      if (jQuery.isEmptyObject(events)) {
        delete elemData.handle;
        data_priv.remove(elem, 'events');
      }
    },
    trigger: function (event, data, elem, onlyHandlers) {
      var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [elem || document], type = core_hasOwn.call(event, 'type') ? event.type : event, namespaces = core_hasOwn.call(event, 'namespace') ? event.namespace.split('.') : [];
      cur = tmp = elem = elem || document;
      if (elem.nodeType === 3 || elem.nodeType === 8) {
        return;
      }
      if (rfocusMorph.test(type + jQuery.event.triggered)) {
        return;
      }
      if (type.indexOf('.') >= 0) {
        namespaces = type.split('.');
        type = namespaces.shift();
        namespaces.sort();
      }
      ontype = type.indexOf(':') < 0 && 'on' + type;
      event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === 'object' && event);
      event.isTrigger = onlyHandlers ? 2 : 3;
      event.namespace = namespaces.join('.');
      event.namespace_re = event.namespace ? new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)') : null;
      event.result = undefined;
      if (!event.target) {
        event.target = elem;
      }
      data = data == null ? [event] : jQuery.makeArray(data, [event]);
      special = jQuery.event.special[type] || {};
      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
        return;
      }
      if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
        bubbleType = special.delegateType || type;
        if (!rfocusMorph.test(bubbleType + type)) {
          cur = cur.parentNode;
        }
        for (; cur; cur = cur.parentNode) {
          eventPath.push(cur);
          tmp = cur;
        }
        if (tmp === (elem.ownerDocument || document)) {
          eventPath.push(tmp.defaultView || tmp.parentWindow || window);
        }
      }
      i = 0;
      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
        event.type = i > 1 ? bubbleType : special.bindType || type;
        handle = (data_priv.get(cur, 'events') || {})[event.type] && data_priv.get(cur, 'handle');
        if (handle) {
          handle.apply(cur, data);
        }
        handle = ontype && cur[ontype];
        if (handle && jQuery.acceptData(cur) && handle.apply && handle.apply(cur, data) === false) {
          event.preventDefault();
        }
      }
      event.type = type;
      if (!onlyHandlers && !event.isDefaultPrevented()) {
        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {
          if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
            tmp = elem[ontype];
            if (tmp) {
              elem[ontype] = null;
            }
            jQuery.event.triggered = type;
            elem[type]();
            jQuery.event.triggered = undefined;
            if (tmp) {
              elem[ontype] = tmp;
            }
          }
        }
      }
      return event.result;
    },
    dispatch: function (event) {
      event = jQuery.event.fix(event);
      var i, j, ret, matched, handleObj, handlerQueue = [], args = core_slice.call(arguments), handlers = (data_priv.get(this, 'events') || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
      args[0] = event;
      event.delegateTarget = this;
      if (special.preDispatch && special.preDispatch.call(this, event) === false) {
        return;
      }
      handlerQueue = jQuery.event.handlers.call(this, event, handlers);
      i = 0;
      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
        event.currentTarget = matched.elem;
        j = 0;
        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
          if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
            if (ret !== undefined) {
              if ((event.result = ret) === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      }
      if (special.postDispatch) {
        special.postDispatch.call(this, event);
      }
      return event.result;
    },
    handlers: function (event, handlers) {
      var i, matches, sel, handleObj, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
      if (delegateCount && cur.nodeType && (!event.button || event.type !== 'click')) {
        for (; cur !== this; cur = cur.parentNode || this) {
          if (cur.disabled !== true || event.type !== 'click') {
            matches = [];
            for (i = 0; i < delegateCount; i++) {
              handleObj = handlers[i];
              sel = handleObj.selector + ' ';
              if (matches[sel] === undefined) {
                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length;
              }
              if (matches[sel]) {
                matches.push(handleObj);
              }
            }
            if (matches.length) {
              handlerQueue.push({
                elem: cur,
                handlers: matches
              });
            }
          }
        }
      }
      if (delegateCount < handlers.length) {
        handlerQueue.push({
          elem: this,
          handlers: handlers.slice(delegateCount)
        });
      }
      return handlerQueue;
    },
    props: 'altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which'.split(' '),
    fixHooks: {},
    keyHooks: {
      props: 'char charCode key keyCode'.split(' '),
      filter: function (event, original) {
        if (event.which == null) {
          event.which = original.charCode != null ? original.charCode : original.keyCode;
        }
        return event;
      }
    },
    mouseHooks: {
      props: 'button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement'.split(' '),
      filter: function (event, original) {
        var eventDoc, doc, body, button = original.button;
        if (event.pageX == null && original.clientX != null) {
          eventDoc = event.target.ownerDocument || document;
          doc = eventDoc.documentElement;
          body = eventDoc.body;
          event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
          event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
        }
        if (!event.which && button !== undefined) {
          event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
        }
        return event;
      }
    },
    fix: function (event) {
      if (event[jQuery.expando]) {
        return event;
      }
      var i, prop, copy, type = event.type, originalEvent = event, fixHook = this.fixHooks[type];
      if (!fixHook) {
        this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
      }
      copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
      event = new jQuery.Event(originalEvent);
      i = copy.length;
      while (i--) {
        prop = copy[i];
        event[prop] = originalEvent[prop];
      }
      if (!event.target) {
        event.target = document;
      }
      if (event.target.nodeType === 3) {
        event.target = event.target.parentNode;
      }
      return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
    },
    special: {
      load: { noBubble: true },
      focus: {
        trigger: function () {
          if (this !== safeActiveElement() && this.focus) {
            this.focus();
            return false;
          }
        },
        delegateType: 'focusin'
      },
      blur: {
        trigger: function () {
          if (this === safeActiveElement() && this.blur) {
            this.blur();
            return false;
          }
        },
        delegateType: 'focusout'
      },
      click: {
        trigger: function () {
          if (this.type === 'checkbox' && this.click && jQuery.nodeName(this, 'input')) {
            this.click();
            return false;
          }
        },
        _default: function (event) {
          return jQuery.nodeName(event.target, 'a');
        }
      },
      beforeunload: {
        postDispatch: function (event) {
          if (event.result !== undefined) {
            event.originalEvent.returnValue = event.result;
          }
        }
      }
    },
    simulate: function (type, elem, event, bubble) {
      var e = jQuery.extend(new jQuery.Event(), event, {
          type: type,
          isSimulated: true,
          originalEvent: {}
        });
      if (bubble) {
        jQuery.event.trigger(e, null, elem);
      } else {
        jQuery.event.dispatch.call(elem, e);
      }
      if (e.isDefaultPrevented()) {
        event.preventDefault();
      }
    }
  };
  jQuery.removeEvent = function (elem, type, handle) {
    if (elem.removeEventListener) {
      elem.removeEventListener(type, handle, false);
    }
  };
  jQuery.Event = function (src, props) {
    if (!(this instanceof jQuery.Event)) {
      return new jQuery.Event(src, props);
    }
    if (src && src.type) {
      this.originalEvent = src;
      this.type = src.type;
      this.isDefaultPrevented = src.defaultPrevented || src.getPreventDefault && src.getPreventDefault() ? returnTrue : returnFalse;
    } else {
      this.type = src;
    }
    if (props) {
      jQuery.extend(this, props);
    }
    this.timeStamp = src && src.timeStamp || jQuery.now();
    this[jQuery.expando] = true;
  };
  jQuery.Event.prototype = {
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,
    preventDefault: function () {
      var e = this.originalEvent;
      this.isDefaultPrevented = returnTrue;
      if (e && e.preventDefault) {
        e.preventDefault();
      }
    },
    stopPropagation: function () {
      var e = this.originalEvent;
      this.isPropagationStopped = returnTrue;
      if (e && e.stopPropagation) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function () {
      this.isImmediatePropagationStopped = returnTrue;
      this.stopPropagation();
    }
  };
  jQuery.each({
    mouseenter: 'mouseover',
    mouseleave: 'mouseout'
  }, function (orig, fix) {
    jQuery.event.special[orig] = {
      delegateType: fix,
      bindType: fix,
      handle: function (event) {
        var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
        if (!related || related !== target && !jQuery.contains(target, related)) {
          event.type = handleObj.origType;
          ret = handleObj.handler.apply(this, arguments);
          event.type = fix;
        }
        return ret;
      }
    };
  });
  if (!jQuery.support.focusinBubbles) {
    jQuery.each({
      focus: 'focusin',
      blur: 'focusout'
    }, function (orig, fix) {
      var attaches = 0, handler = function (event) {
          jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
        };
      jQuery.event.special[fix] = {
        setup: function () {
          if (attaches++ === 0) {
            document.addEventListener(orig, handler, true);
          }
        },
        teardown: function () {
          if (--attaches === 0) {
            document.removeEventListener(orig, handler, true);
          }
        }
      };
    });
  }
  jQuery.fn.extend({
    on: function (types, selector, data, fn, one) {
      var origFn, type;
      if (typeof types === 'object') {
        if (typeof selector !== 'string') {
          data = data || selector;
          selector = undefined;
        }
        for (type in types) {
          this.on(type, selector, data, types[type], one);
        }
        return this;
      }
      if (data == null && fn == null) {
        fn = selector;
        data = selector = undefined;
      } else if (fn == null) {
        if (typeof selector === 'string') {
          fn = data;
          data = undefined;
        } else {
          fn = data;
          data = selector;
          selector = undefined;
        }
      }
      if (fn === false) {
        fn = returnFalse;
      } else if (!fn) {
        return this;
      }
      if (one === 1) {
        origFn = fn;
        fn = function (event) {
          jQuery().off(event);
          return origFn.apply(this, arguments);
        };
        fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
      }
      return this.each(function () {
        jQuery.event.add(this, types, fn, data, selector);
      });
    },
    one: function (types, selector, data, fn) {
      return this.on(types, selector, data, fn, 1);
    },
    off: function (types, selector, fn) {
      var handleObj, type;
      if (types && types.preventDefault && types.handleObj) {
        handleObj = types.handleObj;
        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + '.' + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
        return this;
      }
      if (typeof types === 'object') {
        for (type in types) {
          this.off(type, selector, types[type]);
        }
        return this;
      }
      if (selector === false || typeof selector === 'function') {
        fn = selector;
        selector = undefined;
      }
      if (fn === false) {
        fn = returnFalse;
      }
      return this.each(function () {
        jQuery.event.remove(this, types, fn, selector);
      });
    },
    trigger: function (type, data) {
      return this.each(function () {
        jQuery.event.trigger(type, data, this);
      });
    },
    triggerHandler: function (type, data) {
      var elem = this[0];
      if (elem) {
        return jQuery.event.trigger(type, data, elem, true);
      }
    }
  });
  var isSimple = /^.[^:#\[\.,]*$/, rparentsprev = /^(?:parents|prev(?:Until|All))/, rneedsContext = jQuery.expr.match.needsContext, guaranteedUnique = {
      children: true,
      contents: true,
      next: true,
      prev: true
    };
  jQuery.fn.extend({
    find: function (selector) {
      var i, ret = [], self = this, len = self.length;
      if (typeof selector !== 'string') {
        return this.pushStack(jQuery(selector).filter(function () {
          for (i = 0; i < len; i++) {
            if (jQuery.contains(self[i], this)) {
              return true;
            }
          }
        }));
      }
      for (i = 0; i < len; i++) {
        jQuery.find(selector, self[i], ret);
      }
      ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
      ret.selector = this.selector ? this.selector + ' ' + selector : selector;
      return ret;
    },
    has: function (target) {
      var targets = jQuery(target, this), l = targets.length;
      return this.filter(function () {
        var i = 0;
        for (; i < l; i++) {
          if (jQuery.contains(this, targets[i])) {
            return true;
          }
        }
      });
    },
    not: function (selector) {
      return this.pushStack(winnow(this, selector || [], true));
    },
    filter: function (selector) {
      return this.pushStack(winnow(this, selector || [], false));
    },
    is: function (selector) {
      return !!winnow(this, typeof selector === 'string' && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
    },
    closest: function (selectors, context) {
      var cur, i = 0, l = this.length, matched = [], pos = rneedsContext.test(selectors) || typeof selectors !== 'string' ? jQuery(selectors, context || this.context) : 0;
      for (; i < l; i++) {
        for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
          if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
            cur = matched.push(cur);
            break;
          }
        }
      }
      return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
    },
    index: function (elem) {
      if (!elem) {
        return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
      }
      if (typeof elem === 'string') {
        return core_indexOf.call(jQuery(elem), this[0]);
      }
      return core_indexOf.call(this, elem.jquery ? elem[0] : elem);
    },
    add: function (selector, context) {
      var set = typeof selector === 'string' ? jQuery(selector, context) : jQuery.makeArray(selector && selector.nodeType ? [selector] : selector), all = jQuery.merge(this.get(), set);
      return this.pushStack(jQuery.unique(all));
    },
    addBack: function (selector) {
      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
    }
  });
  function sibling(cur, dir) {
    while ((cur = cur[dir]) && cur.nodeType !== 1) {
    }
    return cur;
  }
  jQuery.each({
    parent: function (elem) {
      var parent = elem.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function (elem) {
      return jQuery.dir(elem, 'parentNode');
    },
    parentsUntil: function (elem, i, until) {
      return jQuery.dir(elem, 'parentNode', until);
    },
    next: function (elem) {
      return sibling(elem, 'nextSibling');
    },
    prev: function (elem) {
      return sibling(elem, 'previousSibling');
    },
    nextAll: function (elem) {
      return jQuery.dir(elem, 'nextSibling');
    },
    prevAll: function (elem) {
      return jQuery.dir(elem, 'previousSibling');
    },
    nextUntil: function (elem, i, until) {
      return jQuery.dir(elem, 'nextSibling', until);
    },
    prevUntil: function (elem, i, until) {
      return jQuery.dir(elem, 'previousSibling', until);
    },
    siblings: function (elem) {
      return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
    },
    children: function (elem) {
      return jQuery.sibling(elem.firstChild);
    },
    contents: function (elem) {
      return elem.contentDocument || jQuery.merge([], elem.childNodes);
    }
  }, function (name, fn) {
    jQuery.fn[name] = function (until, selector) {
      var matched = jQuery.map(this, fn, until);
      if (name.slice(-5) !== 'Until') {
        selector = until;
      }
      if (selector && typeof selector === 'string') {
        matched = jQuery.filter(selector, matched);
      }
      if (this.length > 1) {
        if (!guaranteedUnique[name]) {
          jQuery.unique(matched);
        }
        if (rparentsprev.test(name)) {
          matched.reverse();
        }
      }
      return this.pushStack(matched);
    };
  });
  jQuery.extend({
    filter: function (expr, elems, not) {
      var elem = elems[0];
      if (not) {
        expr = ':not(' + expr + ')';
      }
      return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
        return elem.nodeType === 1;
      }));
    },
    dir: function (elem, dir, until) {
      var matched = [], truncate = until !== undefined;
      while ((elem = elem[dir]) && elem.nodeType !== 9) {
        if (elem.nodeType === 1) {
          if (truncate && jQuery(elem).is(until)) {
            break;
          }
          matched.push(elem);
        }
      }
      return matched;
    },
    sibling: function (n, elem) {
      var matched = [];
      for (; n; n = n.nextSibling) {
        if (n.nodeType === 1 && n !== elem) {
          matched.push(n);
        }
      }
      return matched;
    }
  });
  function winnow(elements, qualifier, not) {
    if (jQuery.isFunction(qualifier)) {
      return jQuery.grep(elements, function (elem, i) {
        return !!qualifier.call(elem, i, elem) !== not;
      });
    }
    if (qualifier.nodeType) {
      return jQuery.grep(elements, function (elem) {
        return elem === qualifier !== not;
      });
    }
    if (typeof qualifier === 'string') {
      if (isSimple.test(qualifier)) {
        return jQuery.filter(qualifier, elements, not);
      }
      qualifier = jQuery.filter(qualifier, elements);
    }
    return jQuery.grep(elements, function (elem) {
      return core_indexOf.call(qualifier, elem) >= 0 !== not;
    });
  }
  var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, rtagName = /<([\w:]+)/, rhtml = /<|&#?\w+;/, rnoInnerhtml = /<(?:script|style|link)/i, manipulation_rcheckableType = /^(?:checkbox|radio)$/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptType = /^$|\/(?:java|ecma)script/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, wrapMap = {
      option: [
        1,
        '<select multiple=\'multiple\'>',
        '</select>'
      ],
      thead: [
        1,
        '<table>',
        '</table>'
      ],
      col: [
        2,
        '<table><colgroup>',
        '</colgroup></table>'
      ],
      tr: [
        2,
        '<table><tbody>',
        '</tbody></table>'
      ],
      td: [
        3,
        '<table><tbody><tr>',
        '</tr></tbody></table>'
      ],
      _default: [
        0,
        '',
        ''
      ]
    };
  wrapMap.optgroup = wrapMap.option;
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;
  jQuery.fn.extend({
    text: function (value) {
      return jQuery.access(this, function (value) {
        return value === undefined ? jQuery.text(this) : this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(value));
      }, null, value, arguments.length);
    },
    append: function () {
      return this.domManip(arguments, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.appendChild(elem);
        }
      });
    },
    prepend: function () {
      return this.domManip(arguments, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.insertBefore(elem, target.firstChild);
        }
      });
    },
    before: function () {
      return this.domManip(arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this);
        }
      });
    },
    after: function () {
      return this.domManip(arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this.nextSibling);
        }
      });
    },
    remove: function (selector, keepData) {
      var elem, elems = selector ? jQuery.filter(selector, this) : this, i = 0;
      for (; (elem = elems[i]) != null; i++) {
        if (!keepData && elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem));
        }
        if (elem.parentNode) {
          if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
            setGlobalEval(getAll(elem, 'script'));
          }
          elem.parentNode.removeChild(elem);
        }
      }
      return this;
    },
    empty: function () {
      var elem, i = 0;
      for (; (elem = this[i]) != null; i++) {
        if (elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem, false));
          elem.textContent = '';
        }
      }
      return this;
    },
    clone: function (dataAndEvents, deepDataAndEvents) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
      return this.map(function () {
        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
      });
    },
    html: function (value) {
      return jQuery.access(this, function (value) {
        var elem = this[0] || {}, i = 0, l = this.length;
        if (value === undefined && elem.nodeType === 1) {
          return elem.innerHTML;
        }
        if (typeof value === 'string' && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [
            '',
            ''
          ])[1].toLowerCase()]) {
          value = value.replace(rxhtmlTag, '<$1></$2>');
          try {
            for (; i < l; i++) {
              elem = this[i] || {};
              if (elem.nodeType === 1) {
                jQuery.cleanData(getAll(elem, false));
                elem.innerHTML = value;
              }
            }
            elem = 0;
          } catch (e) {
          }
        }
        if (elem) {
          this.empty().append(value);
        }
      }, null, value, arguments.length);
    },
    replaceWith: function () {
      var args = jQuery.map(this, function (elem) {
          return [
            elem.nextSibling,
            elem.parentNode
          ];
        }), i = 0;
      this.domManip(arguments, function (elem) {
        var next = args[i++], parent = args[i++];
        if (parent) {
          if (next && next.parentNode !== parent) {
            next = this.nextSibling;
          }
          jQuery(this).remove();
          parent.insertBefore(elem, next);
        }
      }, true);
      return i ? this : this.remove();
    },
    detach: function (selector) {
      return this.remove(selector, true);
    },
    domManip: function (args, callback, allowIntersection) {
      args = core_concat.apply([], args);
      var fragment, first, scripts, hasScripts, node, doc, i = 0, l = this.length, set = this, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
      if (isFunction || !(l <= 1 || typeof value !== 'string' || jQuery.support.checkClone || !rchecked.test(value))) {
        return this.each(function (index) {
          var self = set.eq(index);
          if (isFunction) {
            args[0] = value.call(this, index, self.html());
          }
          self.domManip(args, callback, allowIntersection);
        });
      }
      if (l) {
        fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, !allowIntersection && this);
        first = fragment.firstChild;
        if (fragment.childNodes.length === 1) {
          fragment = first;
        }
        if (first) {
          scripts = jQuery.map(getAll(fragment, 'script'), disableScript);
          hasScripts = scripts.length;
          for (; i < l; i++) {
            node = fragment;
            if (i !== iNoClone) {
              node = jQuery.clone(node, true, true);
              if (hasScripts) {
                jQuery.merge(scripts, getAll(node, 'script'));
              }
            }
            callback.call(this[i], node, i);
          }
          if (hasScripts) {
            doc = scripts[scripts.length - 1].ownerDocument;
            jQuery.map(scripts, restoreScript);
            for (i = 0; i < hasScripts; i++) {
              node = scripts[i];
              if (rscriptType.test(node.type || '') && !data_priv.access(node, 'globalEval') && jQuery.contains(doc, node)) {
                if (node.src) {
                  jQuery._evalUrl(node.src);
                } else {
                  jQuery.globalEval(node.textContent.replace(rcleanScript, ''));
                }
              }
            }
          }
        }
      }
      return this;
    }
  });
  jQuery.each({
    appendTo: 'append',
    prependTo: 'prepend',
    insertBefore: 'before',
    insertAfter: 'after',
    replaceAll: 'replaceWith'
  }, function (name, original) {
    jQuery.fn[name] = function (selector) {
      var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;
      for (; i <= last; i++) {
        elems = i === last ? this : this.clone(true);
        jQuery(insert[i])[original](elems);
        core_push.apply(ret, elems.get());
      }
      return this.pushStack(ret);
    };
  });
  jQuery.extend({
    clone: function (elem, dataAndEvents, deepDataAndEvents) {
      var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = jQuery.contains(elem.ownerDocument, elem);
      if (!jQuery.support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
        destElements = getAll(clone);
        srcElements = getAll(elem);
        for (i = 0, l = srcElements.length; i < l; i++) {
          fixInput(srcElements[i], destElements[i]);
        }
      }
      if (dataAndEvents) {
        if (deepDataAndEvents) {
          srcElements = srcElements || getAll(elem);
          destElements = destElements || getAll(clone);
          for (i = 0, l = srcElements.length; i < l; i++) {
            cloneCopyEvent(srcElements[i], destElements[i]);
          }
        } else {
          cloneCopyEvent(elem, clone);
        }
      }
      destElements = getAll(clone, 'script');
      if (destElements.length > 0) {
        setGlobalEval(destElements, !inPage && getAll(elem, 'script'));
      }
      return clone;
    },
    buildFragment: function (elems, context, scripts, selection) {
      var elem, tmp, tag, wrap, contains, j, i = 0, l = elems.length, fragment = context.createDocumentFragment(), nodes = [];
      for (; i < l; i++) {
        elem = elems[i];
        if (elem || elem === 0) {
          if (jQuery.type(elem) === 'object') {
            jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
          } else if (!rhtml.test(elem)) {
            nodes.push(context.createTextNode(elem));
          } else {
            tmp = tmp || fragment.appendChild(context.createElement('div'));
            tag = (rtagName.exec(elem) || [
              '',
              ''
            ])[1].toLowerCase();
            wrap = wrapMap[tag] || wrapMap._default;
            tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, '<$1></$2>') + wrap[2];
            j = wrap[0];
            while (j--) {
              tmp = tmp.lastChild;
            }
            jQuery.merge(nodes, tmp.childNodes);
            tmp = fragment.firstChild;
            tmp.textContent = '';
          }
        }
      }
      fragment.textContent = '';
      i = 0;
      while (elem = nodes[i++]) {
        if (selection && jQuery.inArray(elem, selection) !== -1) {
          continue;
        }
        contains = jQuery.contains(elem.ownerDocument, elem);
        tmp = getAll(fragment.appendChild(elem), 'script');
        if (contains) {
          setGlobalEval(tmp);
        }
        if (scripts) {
          j = 0;
          while (elem = tmp[j++]) {
            if (rscriptType.test(elem.type || '')) {
              scripts.push(elem);
            }
          }
        }
      }
      return fragment;
    },
    cleanData: function (elems) {
      var data, elem, events, type, key, j, special = jQuery.event.special, i = 0;
      for (; (elem = elems[i]) !== undefined; i++) {
        if (Data.accepts(elem)) {
          key = elem[data_priv.expando];
          if (key && (data = data_priv.cache[key])) {
            events = Object.keys(data.events || {});
            if (events.length) {
              for (j = 0; (type = events[j]) !== undefined; j++) {
                if (special[type]) {
                  jQuery.event.remove(elem, type);
                } else {
                  jQuery.removeEvent(elem, type, data.handle);
                }
              }
            }
            if (data_priv.cache[key]) {
              delete data_priv.cache[key];
            }
          }
        }
        delete data_user.cache[elem[data_user.expando]];
      }
    },
    _evalUrl: function (url) {
      return jQuery.ajax({
        url: url,
        type: 'GET',
        dataType: 'script',
        async: false,
        global: false,
        'throws': true
      });
    }
  });
  function manipulationTarget(elem, content) {
    return jQuery.nodeName(elem, 'table') && jQuery.nodeName(content.nodeType === 1 ? content : content.firstChild, 'tr') ? elem.getElementsByTagName('tbody')[0] || elem.appendChild(elem.ownerDocument.createElement('tbody')) : elem;
  }
  function disableScript(elem) {
    elem.type = (elem.getAttribute('type') !== null) + '/' + elem.type;
    return elem;
  }
  function restoreScript(elem) {
    var match = rscriptTypeMasked.exec(elem.type);
    if (match) {
      elem.type = match[1];
    } else {
      elem.removeAttribute('type');
    }
    return elem;
  }
  function setGlobalEval(elems, refElements) {
    var l = elems.length, i = 0;
    for (; i < l; i++) {
      data_priv.set(elems[i], 'globalEval', !refElements || data_priv.get(refElements[i], 'globalEval'));
    }
  }
  function cloneCopyEvent(src, dest) {
    var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
    if (dest.nodeType !== 1) {
      return;
    }
    if (data_priv.hasData(src)) {
      pdataOld = data_priv.access(src);
      pdataCur = data_priv.set(dest, pdataOld);
      events = pdataOld.events;
      if (events) {
        delete pdataCur.handle;
        pdataCur.events = {};
        for (type in events) {
          for (i = 0, l = events[type].length; i < l; i++) {
            jQuery.event.add(dest, type, events[type][i]);
          }
        }
      }
    }
    if (data_user.hasData(src)) {
      udataOld = data_user.access(src);
      udataCur = jQuery.extend({}, udataOld);
      data_user.set(dest, udataCur);
    }
  }
  function getAll(context, tag) {
    var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || '*') : context.querySelectorAll ? context.querySelectorAll(tag || '*') : [];
    return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret;
  }
  function fixInput(src, dest) {
    var nodeName = dest.nodeName.toLowerCase();
    if (nodeName === 'input' && manipulation_rcheckableType.test(src.type)) {
      dest.checked = src.checked;
    } else if (nodeName === 'input' || nodeName === 'textarea') {
      dest.defaultValue = src.defaultValue;
    }
  }
  jQuery.fn.extend({
    wrapAll: function (html) {
      var wrap;
      if (jQuery.isFunction(html)) {
        return this.each(function (i) {
          jQuery(this).wrapAll(html.call(this, i));
        });
      }
      if (this[0]) {
        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
        if (this[0].parentNode) {
          wrap.insertBefore(this[0]);
        }
        wrap.map(function () {
          var elem = this;
          while (elem.firstElementChild) {
            elem = elem.firstElementChild;
          }
          return elem;
        }).append(this);
      }
      return this;
    },
    wrapInner: function (html) {
      if (jQuery.isFunction(html)) {
        return this.each(function (i) {
          jQuery(this).wrapInner(html.call(this, i));
        });
      }
      return this.each(function () {
        var self = jQuery(this), contents = self.contents();
        if (contents.length) {
          contents.wrapAll(html);
        } else {
          self.append(html);
        }
      });
    },
    wrap: function (html) {
      var isFunction = jQuery.isFunction(html);
      return this.each(function (i) {
        jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
      });
    },
    unwrap: function () {
      return this.parent().each(function () {
        if (!jQuery.nodeName(this, 'body')) {
          jQuery(this).replaceWith(this.childNodes);
        }
      }).end();
    }
  });
  var curCSS, iframe, rdisplayswap = /^(none|table(?!-c[ea]).+)/, rmargin = /^margin/, rnumsplit = new RegExp('^(' + core_pnum + ')(.*)$', 'i'), rnumnonpx = new RegExp('^(' + core_pnum + ')(?!px)[a-z%]+$', 'i'), rrelNum = new RegExp('^([+-])=(' + core_pnum + ')', 'i'), elemdisplay = { BODY: 'block' }, cssShow = {
      position: 'absolute',
      visibility: 'hidden',
      display: 'block'
    }, cssNormalTransform = {
      letterSpacing: 0,
      fontWeight: 400
    }, cssExpand = [
      'Top',
      'Right',
      'Bottom',
      'Left'
    ], cssPrefixes = [
      'Webkit',
      'O',
      'Moz',
      'ms'
    ];
  function vendorPropName(style, name) {
    if (name in style) {
      return name;
    }
    var capName = name.charAt(0).toUpperCase() + name.slice(1), origName = name, i = cssPrefixes.length;
    while (i--) {
      name = cssPrefixes[i] + capName;
      if (name in style) {
        return name;
      }
    }
    return origName;
  }
  function isHidden(elem, el) {
    elem = el || elem;
    return jQuery.css(elem, 'display') === 'none' || !jQuery.contains(elem.ownerDocument, elem);
  }
  function getStyles(elem) {
    return window.getComputedStyle(elem, null);
  }
  function showHide(elements, show) {
    var display, elem, hidden, values = [], index = 0, length = elements.length;
    for (; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      values[index] = data_priv.get(elem, 'olddisplay');
      display = elem.style.display;
      if (show) {
        if (!values[index] && display === 'none') {
          elem.style.display = '';
        }
        if (elem.style.display === '' && isHidden(elem)) {
          values[index] = data_priv.access(elem, 'olddisplay', css_defaultDisplay(elem.nodeName));
        }
      } else {
        if (!values[index]) {
          hidden = isHidden(elem);
          if (display && display !== 'none' || !hidden) {
            data_priv.set(elem, 'olddisplay', hidden ? display : jQuery.css(elem, 'display'));
          }
        }
      }
    }
    for (index = 0; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      if (!show || elem.style.display === 'none' || elem.style.display === '') {
        elem.style.display = show ? values[index] || '' : 'none';
      }
    }
    return elements;
  }
  jQuery.fn.extend({
    css: function (name, value) {
      return jQuery.access(this, function (elem, name, value) {
        var styles, len, map = {}, i = 0;
        if (jQuery.isArray(name)) {
          styles = getStyles(elem);
          len = name.length;
          for (; i < len; i++) {
            map[name[i]] = jQuery.css(elem, name[i], false, styles);
          }
          return map;
        }
        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
      }, name, value, arguments.length > 1);
    },
    show: function () {
      return showHide(this, true);
    },
    hide: function () {
      return showHide(this);
    },
    toggle: function (state) {
      if (typeof state === 'boolean') {
        return state ? this.show() : this.hide();
      }
      return this.each(function () {
        if (isHidden(this)) {
          jQuery(this).show();
        } else {
          jQuery(this).hide();
        }
      });
    }
  });
  jQuery.extend({
    cssHooks: {
      opacity: {
        get: function (elem, computed) {
          if (computed) {
            var ret = curCSS(elem, 'opacity');
            return ret === '' ? '1' : ret;
          }
        }
      }
    },
    cssNumber: {
      'columnCount': true,
      'fillOpacity': true,
      'fontWeight': true,
      'lineHeight': true,
      'opacity': true,
      'order': true,
      'orphans': true,
      'widows': true,
      'zIndex': true,
      'zoom': true
    },
    cssProps: { 'float': 'cssFloat' },
    style: function (elem, name, value, extra) {
      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
        return;
      }
      var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (value !== undefined) {
        type = typeof value;
        if (type === 'string' && (ret = rrelNum.exec(value))) {
          value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
          type = 'number';
        }
        if (value == null || type === 'number' && isNaN(value)) {
          return;
        }
        if (type === 'number' && !jQuery.cssNumber[origName]) {
          value += 'px';
        }
        if (!jQuery.support.clearCloneStyle && value === '' && name.indexOf('background') === 0) {
          style[name] = 'inherit';
        }
        if (!hooks || !('set' in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
          style[name] = value;
        }
      } else {
        if (hooks && 'get' in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
          return ret;
        }
        return style[name];
      }
    },
    css: function (elem, name, extra, styles) {
      var val, num, hooks, origName = jQuery.camelCase(name);
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (hooks && 'get' in hooks) {
        val = hooks.get(elem, true, extra);
      }
      if (val === undefined) {
        val = curCSS(elem, name, styles);
      }
      if (val === 'normal' && name in cssNormalTransform) {
        val = cssNormalTransform[name];
      }
      if (extra === '' || extra) {
        num = parseFloat(val);
        return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
      }
      return val;
    }
  });
  curCSS = function (elem, name, _computed) {
    var width, minWidth, maxWidth, computed = _computed || getStyles(elem), ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined, style = elem.style;
    if (computed) {
      if (ret === '' && !jQuery.contains(elem.ownerDocument, elem)) {
        ret = jQuery.style(elem, name);
      }
      if (rnumnonpx.test(ret) && rmargin.test(name)) {
        width = style.width;
        minWidth = style.minWidth;
        maxWidth = style.maxWidth;
        style.minWidth = style.maxWidth = style.width = ret;
        ret = computed.width;
        style.width = width;
        style.minWidth = minWidth;
        style.maxWidth = maxWidth;
      }
    }
    return ret;
  };
  function setPositiveNumber(elem, value, subtract) {
    var matches = rnumsplit.exec(value);
    return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || 'px') : value;
  }
  function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
    var i = extra === (isBorderBox ? 'border' : 'content') ? 4 : name === 'width' ? 1 : 0, val = 0;
    for (; i < 4; i += 2) {
      if (extra === 'margin') {
        val += jQuery.css(elem, extra + cssExpand[i], true, styles);
      }
      if (isBorderBox) {
        if (extra === 'content') {
          val -= jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
        }
        if (extra !== 'margin') {
          val -= jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
        }
      } else {
        val += jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
        if (extra !== 'padding') {
          val += jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
        }
      }
    }
    return val;
  }
  function getWidthOrHeight(elem, name, extra) {
    var valueIsBorderBox = true, val = name === 'width' ? elem.offsetWidth : elem.offsetHeight, styles = getStyles(elem), isBorderBox = jQuery.support.boxSizing && jQuery.css(elem, 'boxSizing', false, styles) === 'border-box';
    if (val <= 0 || val == null) {
      val = curCSS(elem, name, styles);
      if (val < 0 || val == null) {
        val = elem.style[name];
      }
      if (rnumnonpx.test(val)) {
        return val;
      }
      valueIsBorderBox = isBorderBox && (jQuery.support.boxSizingReliable || val === elem.style[name]);
      val = parseFloat(val) || 0;
    }
    return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? 'border' : 'content'), valueIsBorderBox, styles) + 'px';
  }
  function css_defaultDisplay(nodeName) {
    var doc = document, display = elemdisplay[nodeName];
    if (!display) {
      display = actualDisplay(nodeName, doc);
      if (display === 'none' || !display) {
        iframe = (iframe || jQuery('<iframe frameborder=\'0\' width=\'0\' height=\'0\'/>').css('cssText', 'display:block !important')).appendTo(doc.documentElement);
        doc = (iframe[0].contentWindow || iframe[0].contentDocument).document;
        doc.write('<!doctype html><html><body>');
        doc.close();
        display = actualDisplay(nodeName, doc);
        iframe.detach();
      }
      elemdisplay[nodeName] = display;
    }
    return display;
  }
  function actualDisplay(name, doc) {
    var elem = jQuery(doc.createElement(name)).appendTo(doc.body), display = jQuery.css(elem[0], 'display');
    elem.remove();
    return display;
  }
  jQuery.each([
    'height',
    'width'
  ], function (i, name) {
    jQuery.cssHooks[name] = {
      get: function (elem, computed, extra) {
        if (computed) {
          return elem.offsetWidth === 0 && rdisplayswap.test(jQuery.css(elem, 'display')) ? jQuery.swap(elem, cssShow, function () {
            return getWidthOrHeight(elem, name, extra);
          }) : getWidthOrHeight(elem, name, extra);
        }
      },
      set: function (elem, value, extra) {
        var styles = extra && getStyles(elem);
        return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, jQuery.support.boxSizing && jQuery.css(elem, 'boxSizing', false, styles) === 'border-box', styles) : 0);
      }
    };
  });
  jQuery(function () {
    if (!jQuery.support.reliableMarginRight) {
      jQuery.cssHooks.marginRight = {
        get: function (elem, computed) {
          if (computed) {
            return jQuery.swap(elem, { 'display': 'inline-block' }, curCSS, [
              elem,
              'marginRight'
            ]);
          }
        }
      };
    }
    if (!jQuery.support.pixelPosition && jQuery.fn.position) {
      jQuery.each([
        'top',
        'left'
      ], function (i, prop) {
        jQuery.cssHooks[prop] = {
          get: function (elem, computed) {
            if (computed) {
              computed = curCSS(elem, prop);
              return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + 'px' : computed;
            }
          }
        };
      });
    }
  });
  if (jQuery.expr && jQuery.expr.filters) {
    jQuery.expr.filters.hidden = function (elem) {
      return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
    };
    jQuery.expr.filters.visible = function (elem) {
      return !jQuery.expr.filters.hidden(elem);
    };
  }
  jQuery.each({
    margin: '',
    padding: '',
    border: 'Width'
  }, function (prefix, suffix) {
    jQuery.cssHooks[prefix + suffix] = {
      expand: function (value) {
        var i = 0, expanded = {}, parts = typeof value === 'string' ? value.split(' ') : [value];
        for (; i < 4; i++) {
          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
        }
        return expanded;
      }
    };
    if (!rmargin.test(prefix)) {
      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    }
  });
  var r20 = /%20/g, rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
  jQuery.fn.extend({
    serialize: function () {
      return jQuery.param(this.serializeArray());
    },
    serializeArray: function () {
      return this.map(function () {
        var elements = jQuery.prop(this, 'elements');
        return elements ? jQuery.makeArray(elements) : this;
      }).filter(function () {
        var type = this.type;
        return this.name && !jQuery(this).is(':disabled') && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !manipulation_rcheckableType.test(type));
      }).map(function (i, elem) {
        var val = jQuery(this).val();
        return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {
          return {
            name: elem.name,
            value: val.replace(rCRLF, '\r\n')
          };
        }) : {
          name: elem.name,
          value: val.replace(rCRLF, '\r\n')
        };
      }).get();
    }
  });
  jQuery.param = function (a, traditional) {
    var prefix, s = [], add = function (key, value) {
        value = jQuery.isFunction(value) ? value() : value == null ? '' : value;
        s[s.length] = encodeURIComponent(key) + '=' + encodeURIComponent(value);
      };
    if (traditional === undefined) {
      traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
    }
    if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
      jQuery.each(a, function () {
        add(this.name, this.value);
      });
    } else {
      for (prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    }
    return s.join('&').replace(r20, '+');
  };
  function buildParams(prefix, obj, traditional, add) {
    var name;
    if (jQuery.isArray(obj)) {
      jQuery.each(obj, function (i, v) {
        if (traditional || rbracket.test(prefix)) {
          add(prefix, v);
        } else {
          buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add);
        }
      });
    } else if (!traditional && jQuery.type(obj) === 'object') {
      for (name in obj) {
        buildParams(prefix + '[' + name + ']', obj[name], traditional, add);
      }
    } else {
      add(prefix, obj);
    }
  }
  jQuery.each(('blur focus focusin focusout load resize scroll unload click dblclick ' + 'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' + 'change select submit keydown keypress keyup error contextmenu').split(' '), function (i, name) {
    jQuery.fn[name] = function (data, fn) {
      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
    };
  });
  jQuery.fn.extend({
    hover: function (fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    },
    bind: function (types, data, fn) {
      return this.on(types, null, data, fn);
    },
    unbind: function (types, fn) {
      return this.off(types, null, fn);
    },
    delegate: function (selector, types, data, fn) {
      return this.on(types, selector, data, fn);
    },
    undelegate: function (selector, types, fn) {
      return arguments.length === 1 ? this.off(selector, '**') : this.off(types, selector || '**', fn);
    }
  });
  var ajaxLocParts, ajaxLocation, ajax_nonce = jQuery.now(), ajax_rquery = /\?/, rhash = /#.*$/, rts = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, rurl = /^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/, _load = jQuery.fn.load, prefilters = {}, transports = {}, allTypes = '*/'.concat('*');
  try {
    ajaxLocation = location.href;
  } catch (e) {
    ajaxLocation = document.createElement('a');
    ajaxLocation.href = '';
    ajaxLocation = ajaxLocation.href;
  }
  ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
  function addToPrefiltersOrTransports(structure) {
    return function (dataTypeExpression, func) {
      if (typeof dataTypeExpression !== 'string') {
        func = dataTypeExpression;
        dataTypeExpression = '*';
      }
      var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(core_rnotwhite) || [];
      if (jQuery.isFunction(func)) {
        while (dataType = dataTypes[i++]) {
          if (dataType[0] === '+') {
            dataType = dataType.slice(1) || '*';
            (structure[dataType] = structure[dataType] || []).unshift(func);
          } else {
            (structure[dataType] = structure[dataType] || []).push(func);
          }
        }
      }
    };
  }
  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
    var inspected = {}, seekingTransport = structure === transports;
    function inspect(dataType) {
      var selected;
      inspected[dataType] = true;
      jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
        if (typeof dataTypeOrTransport === 'string' && !seekingTransport && !inspected[dataTypeOrTransport]) {
          options.dataTypes.unshift(dataTypeOrTransport);
          inspect(dataTypeOrTransport);
          return false;
        } else if (seekingTransport) {
          return !(selected = dataTypeOrTransport);
        }
      });
      return selected;
    }
    return inspect(options.dataTypes[0]) || !inspected['*'] && inspect('*');
  }
  function ajaxExtend(target, src) {
    var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
    for (key in src) {
      if (src[key] !== undefined) {
        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
      }
    }
    if (deep) {
      jQuery.extend(true, target, deep);
    }
    return target;
  }
  jQuery.fn.load = function (url, params, callback) {
    if (typeof url !== 'string' && _load) {
      return _load.apply(this, arguments);
    }
    var selector, type, response, self = this, off = url.indexOf(' ');
    if (off >= 0) {
      selector = url.slice(off);
      url = url.slice(0, off);
    }
    if (jQuery.isFunction(params)) {
      callback = params;
      params = undefined;
    } else if (params && typeof params === 'object') {
      type = 'POST';
    }
    if (self.length > 0) {
      jQuery.ajax({
        url: url,
        type: type,
        dataType: 'html',
        data: params
      }).done(function (responseText) {
        response = arguments;
        self.html(selector ? jQuery('<div>').append(jQuery.parseHTML(responseText)).find(selector) : responseText);
      }).complete(callback && function (jqXHR, status) {
        self.each(callback, response || [
          jqXHR.responseText,
          status,
          jqXHR
        ]);
      });
    }
    return this;
  };
  jQuery.each([
    'ajaxStart',
    'ajaxStop',
    'ajaxComplete',
    'ajaxError',
    'ajaxSuccess',
    'ajaxSend'
  ], function (i, type) {
    jQuery.fn[type] = function (fn) {
      return this.on(type, fn);
    };
  });
  jQuery.extend({
    active: 0,
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: ajaxLocation,
      type: 'GET',
      isLocal: rlocalProtocol.test(ajaxLocParts[1]),
      global: true,
      processData: true,
      async: true,
      contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
      accepts: {
        '*': allTypes,
        text: 'text/plain',
        html: 'text/html',
        xml: 'application/xml, text/xml',
        json: 'application/json, text/javascript'
      },
      contents: {
        xml: /xml/,
        html: /html/,
        json: /json/
      },
      responseFields: {
        xml: 'responseXML',
        text: 'responseText',
        json: 'responseJSON'
      },
      converters: {
        '* text': String,
        'text html': true,
        'text json': jQuery.parseJSON,
        'text xml': jQuery.parseXML
      },
      flatOptions: {
        url: true,
        context: true
      }
    },
    ajaxSetup: function (target, settings) {
      return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
    },
    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    ajaxTransport: addToPrefiltersOrTransports(transports),
    ajax: function (url, options) {
      if (typeof url === 'object') {
        options = url;
        url = undefined;
      }
      options = options || {};
      var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, parts, fireGlobals, i, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks('once memory'), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, state = 0, strAbort = 'canceled', jqXHR = {
          readyState: 0,
          getResponseHeader: function (key) {
            var match;
            if (state === 2) {
              if (!responseHeaders) {
                responseHeaders = {};
                while (match = rheaders.exec(responseHeadersString)) {
                  responseHeaders[match[1].toLowerCase()] = match[2];
                }
              }
              match = responseHeaders[key.toLowerCase()];
            }
            return match == null ? null : match;
          },
          getAllResponseHeaders: function () {
            return state === 2 ? responseHeadersString : null;
          },
          setRequestHeader: function (name, value) {
            var lname = name.toLowerCase();
            if (!state) {
              name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
              requestHeaders[name] = value;
            }
            return this;
          },
          overrideMimeType: function (type) {
            if (!state) {
              s.mimeType = type;
            }
            return this;
          },
          statusCode: function (map) {
            var code;
            if (map) {
              if (state < 2) {
                for (code in map) {
                  statusCode[code] = [
                    statusCode[code],
                    map[code]
                  ];
                }
              } else {
                jqXHR.always(map[jqXHR.status]);
              }
            }
            return this;
          },
          abort: function (statusText) {
            var finalText = statusText || strAbort;
            if (transport) {
              transport.abort(finalText);
            }
            done(0, finalText);
            return this;
          }
        };
      deferred.promise(jqXHR).complete = completeDeferred.add;
      jqXHR.success = jqXHR.done;
      jqXHR.error = jqXHR.fail;
      s.url = ((url || s.url || ajaxLocation) + '').replace(rhash, '').replace(rprotocol, ajaxLocParts[1] + '//');
      s.type = options.method || options.type || s.method || s.type;
      s.dataTypes = jQuery.trim(s.dataType || '*').toLowerCase().match(core_rnotwhite) || [''];
      if (s.crossDomain == null) {
        parts = rurl.exec(s.url.toLowerCase());
        s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === 'http:' ? '80' : '443')) !== (ajaxLocParts[3] || (ajaxLocParts[1] === 'http:' ? '80' : '443'))));
      }
      if (s.data && s.processData && typeof s.data !== 'string') {
        s.data = jQuery.param(s.data, s.traditional);
      }
      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
      if (state === 2) {
        return jqXHR;
      }
      fireGlobals = s.global;
      if (fireGlobals && jQuery.active++ === 0) {
        jQuery.event.trigger('ajaxStart');
      }
      s.type = s.type.toUpperCase();
      s.hasContent = !rnoContent.test(s.type);
      cacheURL = s.url;
      if (!s.hasContent) {
        if (s.data) {
          cacheURL = s.url += (ajax_rquery.test(cacheURL) ? '&' : '?') + s.data;
          delete s.data;
        }
        if (s.cache === false) {
          s.url = rts.test(cacheURL) ? cacheURL.replace(rts, '$1_=' + ajax_nonce++) : cacheURL + (ajax_rquery.test(cacheURL) ? '&' : '?') + '_=' + ajax_nonce++;
        }
      }
      if (s.ifModified) {
        if (jQuery.lastModified[cacheURL]) {
          jqXHR.setRequestHeader('If-Modified-Since', jQuery.lastModified[cacheURL]);
        }
        if (jQuery.etag[cacheURL]) {
          jqXHR.setRequestHeader('If-None-Match', jQuery.etag[cacheURL]);
        }
      }
      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
        jqXHR.setRequestHeader('Content-Type', s.contentType);
      }
      jqXHR.setRequestHeader('Accept', s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== '*' ? ', ' + allTypes + '; q=0.01' : '') : s.accepts['*']);
      for (i in s.headers) {
        jqXHR.setRequestHeader(i, s.headers[i]);
      }
      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
        return jqXHR.abort();
      }
      strAbort = 'abort';
      for (i in {
          success: 1,
          error: 1,
          complete: 1
        }) {
        jqXHR[i](s[i]);
      }
      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
      if (!transport) {
        done(-1, 'No Transport');
      } else {
        jqXHR.readyState = 1;
        if (fireGlobals) {
          globalEventContext.trigger('ajaxSend', [
            jqXHR,
            s
          ]);
        }
        if (s.async && s.timeout > 0) {
          timeoutTimer = setTimeout(function () {
            jqXHR.abort('timeout');
          }, s.timeout);
        }
        try {
          state = 1;
          transport.send(requestHeaders, done);
        } catch (e) {
          if (state < 2) {
            done(-1, e);
          } else {
            throw e;
          }
        }
      }
      function done(status, nativeStatusText, responses, headers) {
        var isSuccess, success, error, response, modified, statusText = nativeStatusText;
        if (state === 2) {
          return;
        }
        state = 2;
        if (timeoutTimer) {
          clearTimeout(timeoutTimer);
        }
        transport = undefined;
        responseHeadersString = headers || '';
        jqXHR.readyState = status > 0 ? 4 : 0;
        isSuccess = status >= 200 && status < 300 || status === 304;
        if (responses) {
          response = ajaxHandleResponses(s, jqXHR, responses);
        }
        response = ajaxConvert(s, response, jqXHR, isSuccess);
        if (isSuccess) {
          if (s.ifModified) {
            modified = jqXHR.getResponseHeader('Last-Modified');
            if (modified) {
              jQuery.lastModified[cacheURL] = modified;
            }
            modified = jqXHR.getResponseHeader('etag');
            if (modified) {
              jQuery.etag[cacheURL] = modified;
            }
          }
          if (status === 204 || s.type === 'HEAD') {
            statusText = 'nocontent';
          } else if (status === 304) {
            statusText = 'notmodified';
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        } else {
          error = statusText;
          if (status || !statusText) {
            statusText = 'error';
            if (status < 0) {
              status = 0;
            }
          }
        }
        jqXHR.status = status;
        jqXHR.statusText = (nativeStatusText || statusText) + '';
        if (isSuccess) {
          deferred.resolveWith(callbackContext, [
            success,
            statusText,
            jqXHR
          ]);
        } else {
          deferred.rejectWith(callbackContext, [
            jqXHR,
            statusText,
            error
          ]);
        }
        jqXHR.statusCode(statusCode);
        statusCode = undefined;
        if (fireGlobals) {
          globalEventContext.trigger(isSuccess ? 'ajaxSuccess' : 'ajaxError', [
            jqXHR,
            s,
            isSuccess ? success : error
          ]);
        }
        completeDeferred.fireWith(callbackContext, [
          jqXHR,
          statusText
        ]);
        if (fireGlobals) {
          globalEventContext.trigger('ajaxComplete', [
            jqXHR,
            s
          ]);
          if (!--jQuery.active) {
            jQuery.event.trigger('ajaxStop');
          }
        }
      }
      return jqXHR;
    },
    getJSON: function (url, data, callback) {
      return jQuery.get(url, data, callback, 'json');
    },
    getScript: function (url, callback) {
      return jQuery.get(url, undefined, callback, 'script');
    }
  });
  jQuery.each([
    'get',
    'post'
  ], function (i, method) {
    jQuery[method] = function (url, data, callback, type) {
      if (jQuery.isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      }
      return jQuery.ajax({
        url: url,
        type: method,
        dataType: type,
        data: data,
        success: callback
      });
    };
  });
  function ajaxHandleResponses(s, jqXHR, responses) {
    var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
    while (dataTypes[0] === '*') {
      dataTypes.shift();
      if (ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader('Content-Type');
      }
    }
    if (ct) {
      for (type in contents) {
        if (contents[type] && contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    }
    if (dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      for (type in responses) {
        if (!dataTypes[0] || s.converters[type + ' ' + dataTypes[0]]) {
          finalDataType = type;
          break;
        }
        if (!firstDataType) {
          firstDataType = type;
        }
      }
      finalDataType = finalDataType || firstDataType;
    }
    if (finalDataType) {
      if (finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }
      return responses[finalDataType];
    }
  }
  function ajaxConvert(s, response, jqXHR, isSuccess) {
    var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
    if (dataTypes[1]) {
      for (conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    }
    current = dataTypes.shift();
    while (current) {
      if (s.responseFields[current]) {
        jqXHR[s.responseFields[current]] = response;
      }
      if (!prev && isSuccess && s.dataFilter) {
        response = s.dataFilter(response, s.dataType);
      }
      prev = current;
      current = dataTypes.shift();
      if (current) {
        if (current === '*') {
          current = prev;
        } else if (prev !== '*' && prev !== current) {
          conv = converters[prev + ' ' + current] || converters['* ' + current];
          if (!conv) {
            for (conv2 in converters) {
              tmp = conv2.split(' ');
              if (tmp[1] === current) {
                conv = converters[prev + ' ' + tmp[0]] || converters['* ' + tmp[0]];
                if (conv) {
                  if (conv === true) {
                    conv = converters[conv2];
                  } else if (converters[conv2] !== true) {
                    current = tmp[0];
                    dataTypes.unshift(tmp[1]);
                  }
                  break;
                }
              }
            }
          }
          if (conv !== true) {
            if (conv && s['throws']) {
              response = conv(response);
            } else {
              try {
                response = conv(response);
              } catch (e) {
                return {
                  state: 'parsererror',
                  error: conv ? e : 'No conversion from ' + prev + ' to ' + current
                };
              }
            }
          }
        }
      }
    }
    return {
      state: 'success',
      data: response
    };
  }
  jQuery.ajaxSetup({
    accepts: { script: 'text/javascript, application/javascript, application/ecmascript, application/x-ecmascript' },
    contents: { script: /(?:java|ecma)script/ },
    converters: {
      'text script': function (text) {
        jQuery.globalEval(text);
        return text;
      }
    }
  });
  jQuery.ajaxPrefilter('script', function (s) {
    if (s.cache === undefined) {
      s.cache = false;
    }
    if (s.crossDomain) {
      s.type = 'GET';
    }
  });
  jQuery.ajaxTransport('script', function (s) {
    if (s.crossDomain) {
      var script, callback;
      return {
        send: function (_, complete) {
          script = jQuery('<script>').prop({
            async: true,
            charset: s.scriptCharset,
            src: s.url
          }).on('load error', callback = function (evt) {
            script.remove();
            callback = null;
            if (evt) {
              complete(evt.type === 'error' ? 404 : 200, evt.type);
            }
          });
          document.head.appendChild(script[0]);
        },
        abort: function () {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
  jQuery.ajaxSetup({
    jsonp: 'callback',
    jsonpCallback: function () {
      var callback = oldCallbacks.pop() || jQuery.expando + '_' + ajax_nonce++;
      this[callback] = true;
      return callback;
    }
  });
  jQuery.ajaxPrefilter('json jsonp', function (s, originalSettings, jqXHR) {
    var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? 'url' : typeof s.data === 'string' && !(s.contentType || '').indexOf('application/x-www-form-urlencoded') && rjsonp.test(s.data) && 'data');
    if (jsonProp || s.dataTypes[0] === 'jsonp') {
      callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
      if (jsonProp) {
        s[jsonProp] = s[jsonProp].replace(rjsonp, '$1' + callbackName);
      } else if (s.jsonp !== false) {
        s.url += (ajax_rquery.test(s.url) ? '&' : '?') + s.jsonp + '=' + callbackName;
      }
      s.converters['script json'] = function () {
        if (!responseContainer) {
          jQuery.error(callbackName + ' was not called');
        }
        return responseContainer[0];
      };
      s.dataTypes[0] = 'json';
      overwritten = window[callbackName];
      window[callbackName] = function () {
        responseContainer = arguments;
      };
      jqXHR.always(function () {
        window[callbackName] = overwritten;
        if (s[callbackName]) {
          s.jsonpCallback = originalSettings.jsonpCallback;
          oldCallbacks.push(callbackName);
        }
        if (responseContainer && jQuery.isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }
        responseContainer = overwritten = undefined;
      });
      return 'script';
    }
  });
  jQuery.ajaxSettings.xhr = function () {
    try {
      return new XMLHttpRequest();
    } catch (e) {
    }
  };
  var xhrSupported = jQuery.ajaxSettings.xhr(), xhrSuccessStatus = {
      0: 200,
      1223: 204
    }, xhrId = 0, xhrCallbacks = {};
  if (window.ActiveXObject) {
    jQuery(window).on('unload', function () {
      for (var key in xhrCallbacks) {
        xhrCallbacks[key]();
      }
      xhrCallbacks = undefined;
    });
  }
  jQuery.support.cors = !!xhrSupported && 'withCredentials' in xhrSupported;
  jQuery.support.ajax = xhrSupported = !!xhrSupported;
  jQuery.ajaxTransport(function (options) {
    var callback;
    if (jQuery.support.cors || xhrSupported && !options.crossDomain) {
      return {
        send: function (headers, complete) {
          var i, id, xhr = options.xhr();
          xhr.open(options.type, options.url, options.async, options.username, options.password);
          if (options.xhrFields) {
            for (i in options.xhrFields) {
              xhr[i] = options.xhrFields[i];
            }
          }
          if (options.mimeType && xhr.overrideMimeType) {
            xhr.overrideMimeType(options.mimeType);
          }
          if (!options.crossDomain && !headers['X-Requested-With']) {
            headers['X-Requested-With'] = 'XMLHttpRequest';
          }
          for (i in headers) {
            xhr.setRequestHeader(i, headers[i]);
          }
          callback = function (type) {
            return function () {
              if (callback) {
                delete xhrCallbacks[id];
                callback = xhr.onload = xhr.onerror = null;
                if (type === 'abort') {
                  xhr.abort();
                } else if (type === 'error') {
                  complete(xhr.status || 404, xhr.statusText);
                } else {
                  complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, typeof xhr.responseText === 'string' ? { text: xhr.responseText } : undefined, xhr.getAllResponseHeaders());
                }
              }
            };
          };
          xhr.onload = callback();
          xhr.onerror = callback('error');
          callback = xhrCallbacks[id = xhrId++] = callback('abort');
          xhr.send(options.hasContent && options.data || null);
        },
        abort: function () {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rfxnum = new RegExp('^(?:([+-])=|)(' + core_pnum + ')([a-z%]*)$', 'i'), rrun = /queueHooks$/, animationPrefilters = [defaultPrefilter], tweeners = {
      '*': [function (prop, value) {
          var tween = this.createTween(prop, value), target = tween.cur(), parts = rfxnum.exec(value), unit = parts && parts[3] || (jQuery.cssNumber[prop] ? '' : 'px'), start = (jQuery.cssNumber[prop] || unit !== 'px' && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)), scale = 1, maxIterations = 20;
          if (start && start[3] !== unit) {
            unit = unit || start[3];
            parts = parts || [];
            start = +target || 1;
            do {
              scale = scale || '.5';
              start = start / scale;
              jQuery.style(tween.elem, prop, start + unit);
            } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
          }
          if (parts) {
            start = tween.start = +start || +target || 0;
            tween.unit = unit;
            tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];
          }
          return tween;
        }]
    };
  function createFxNow() {
    setTimeout(function () {
      fxNow = undefined;
    });
    return fxNow = jQuery.now();
  }
  function createTween(value, prop, animation) {
    var tween, collection = (tweeners[prop] || []).concat(tweeners['*']), index = 0, length = collection.length;
    for (; index < length; index++) {
      if (tween = collection[index].call(animation, prop, value)) {
        return tween;
      }
    }
  }
  function Animation(elem, properties, options) {
    var result, stopped, index = 0, length = animationPrefilters.length, deferred = jQuery.Deferred().always(function () {
        delete tick.elem;
      }), tick = function () {
        if (stopped) {
          return false;
        }
        var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
        for (; index < length; index++) {
          animation.tweens[index].run(percent);
        }
        deferred.notifyWith(elem, [
          animation,
          percent,
          remaining
        ]);
        if (percent < 1 && length) {
          return remaining;
        } else {
          deferred.resolveWith(elem, [animation]);
          return false;
        }
      }, animation = deferred.promise({
        elem: elem,
        props: jQuery.extend({}, properties),
        opts: jQuery.extend(true, { specialEasing: {} }, options),
        originalProperties: properties,
        originalOptions: options,
        startTime: fxNow || createFxNow(),
        duration: options.duration,
        tweens: [],
        createTween: function (prop, end) {
          var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
          animation.tweens.push(tween);
          return tween;
        },
        stop: function (gotoEnd) {
          var index = 0, length = gotoEnd ? animation.tweens.length : 0;
          if (stopped) {
            return this;
          }
          stopped = true;
          for (; index < length; index++) {
            animation.tweens[index].run(1);
          }
          if (gotoEnd) {
            deferred.resolveWith(elem, [
              animation,
              gotoEnd
            ]);
          } else {
            deferred.rejectWith(elem, [
              animation,
              gotoEnd
            ]);
          }
          return this;
        }
      }), props = animation.props;
    propFilter(props, animation.opts.specialEasing);
    for (; index < length; index++) {
      result = animationPrefilters[index].call(animation, elem, props, animation.opts);
      if (result) {
        return result;
      }
    }
    jQuery.map(props, createTween, animation);
    if (jQuery.isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    }
    jQuery.fx.timer(jQuery.extend(tick, {
      elem: elem,
      anim: animation,
      queue: animation.opts.queue
    }));
    return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
  }
  function propFilter(props, specialEasing) {
    var index, name, easing, value, hooks;
    for (index in props) {
      name = jQuery.camelCase(index);
      easing = specialEasing[name];
      value = props[index];
      if (jQuery.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }
      if (index !== name) {
        props[name] = value;
        delete props[index];
      }
      hooks = jQuery.cssHooks[name];
      if (hooks && 'expand' in hooks) {
        value = hooks.expand(value);
        delete props[name];
        for (index in value) {
          if (!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }
  jQuery.Animation = jQuery.extend(Animation, {
    tweener: function (props, callback) {
      if (jQuery.isFunction(props)) {
        callback = props;
        props = ['*'];
      } else {
        props = props.split(' ');
      }
      var prop, index = 0, length = props.length;
      for (; index < length; index++) {
        prop = props[index];
        tweeners[prop] = tweeners[prop] || [];
        tweeners[prop].unshift(callback);
      }
    },
    prefilter: function (callback, prepend) {
      if (prepend) {
        animationPrefilters.unshift(callback);
      } else {
        animationPrefilters.push(callback);
      }
    }
  });
  function defaultPrefilter(elem, props, opts) {
    var prop, value, toggle, tween, hooks, oldfire, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHidden(elem), dataShow = data_priv.get(elem, 'fxshow');
    if (!opts.queue) {
      hooks = jQuery._queueHooks(elem, 'fx');
      if (hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;
        hooks.empty.fire = function () {
          if (!hooks.unqueued) {
            oldfire();
          }
        };
      }
      hooks.unqueued++;
      anim.always(function () {
        anim.always(function () {
          hooks.unqueued--;
          if (!jQuery.queue(elem, 'fx').length) {
            hooks.empty.fire();
          }
        });
      });
    }
    if (elem.nodeType === 1 && ('height' in props || 'width' in props)) {
      opts.overflow = [
        style.overflow,
        style.overflowX,
        style.overflowY
      ];
      if (jQuery.css(elem, 'display') === 'inline' && jQuery.css(elem, 'float') === 'none') {
        style.display = 'inline-block';
      }
    }
    if (opts.overflow) {
      style.overflow = 'hidden';
      anim.always(function () {
        style.overflow = opts.overflow[0];
        style.overflowX = opts.overflow[1];
        style.overflowY = opts.overflow[2];
      });
    }
    for (prop in props) {
      value = props[prop];
      if (rfxtypes.exec(value)) {
        delete props[prop];
        toggle = toggle || value === 'toggle';
        if (value === (hidden ? 'hide' : 'show')) {
          if (value === 'show' && dataShow && dataShow[prop] !== undefined) {
            hidden = true;
          } else {
            continue;
          }
        }
        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
      }
    }
    if (!jQuery.isEmptyObject(orig)) {
      if (dataShow) {
        if ('hidden' in dataShow) {
          hidden = dataShow.hidden;
        }
      } else {
        dataShow = data_priv.access(elem, 'fxshow', {});
      }
      if (toggle) {
        dataShow.hidden = !hidden;
      }
      if (hidden) {
        jQuery(elem).show();
      } else {
        anim.done(function () {
          jQuery(elem).hide();
        });
      }
      anim.done(function () {
        var prop;
        data_priv.remove(elem, 'fxshow');
        for (prop in orig) {
          jQuery.style(elem, prop, orig[prop]);
        }
      });
      for (prop in orig) {
        tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
        if (!(prop in dataShow)) {
          dataShow[prop] = tween.start;
          if (hidden) {
            tween.end = tween.start;
            tween.start = prop === 'width' || prop === 'height' ? 1 : 0;
          }
        }
      }
    }
  }
  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }
  jQuery.Tween = Tween;
  Tween.prototype = {
    constructor: Tween,
    init: function (elem, options, prop, end, easing, unit) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || 'swing';
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || (jQuery.cssNumber[prop] ? '' : 'px');
    },
    cur: function () {
      var hooks = Tween.propHooks[this.prop];
      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
    },
    run: function (percent) {
      var eased, hooks = Tween.propHooks[this.prop];
      if (this.options.duration) {
        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
      } else {
        this.pos = eased = percent;
      }
      this.now = (this.end - this.start) * eased + this.start;
      if (this.options.step) {
        this.options.step.call(this.elem, this.now, this);
      }
      if (hooks && hooks.set) {
        hooks.set(this);
      } else {
        Tween.propHooks._default.set(this);
      }
      return this;
    }
  };
  Tween.prototype.init.prototype = Tween.prototype;
  Tween.propHooks = {
    _default: {
      get: function (tween) {
        var result;
        if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
          return tween.elem[tween.prop];
        }
        result = jQuery.css(tween.elem, tween.prop, '');
        return !result || result === 'auto' ? 0 : result;
      },
      set: function (tween) {
        if (jQuery.fx.step[tween.prop]) {
          jQuery.fx.step[tween.prop](tween);
        } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
        } else {
          tween.elem[tween.prop] = tween.now;
        }
      }
    }
  };
  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
    set: function (tween) {
      if (tween.elem.nodeType && tween.elem.parentNode) {
        tween.elem[tween.prop] = tween.now;
      }
    }
  };
  jQuery.each([
    'toggle',
    'show',
    'hide'
  ], function (i, name) {
    var cssFn = jQuery.fn[name];
    jQuery.fn[name] = function (speed, easing, callback) {
      return speed == null || typeof speed === 'boolean' ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
    };
  });
  jQuery.fn.extend({
    fadeTo: function (speed, to, easing, callback) {
      return this.filter(isHidden).css('opacity', 0).show().end().animate({ opacity: to }, speed, easing, callback);
    },
    animate: function (prop, speed, easing, callback) {
      var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function () {
          var anim = Animation(this, jQuery.extend({}, prop), optall);
          if (empty || data_priv.get(this, 'finish')) {
            anim.stop(true);
          }
        };
      doAnimation.finish = doAnimation;
      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
    },
    stop: function (type, clearQueue, gotoEnd) {
      var stopQueue = function (hooks) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop(gotoEnd);
      };
      if (typeof type !== 'string') {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }
      if (clearQueue && type !== false) {
        this.queue(type || 'fx', []);
      }
      return this.each(function () {
        var dequeue = true, index = type != null && type + 'queueHooks', timers = jQuery.timers, data = data_priv.get(this);
        if (index) {
          if (data[index] && data[index].stop) {
            stopQueue(data[index]);
          }
        } else {
          for (index in data) {
            if (data[index] && data[index].stop && rrun.test(index)) {
              stopQueue(data[index]);
            }
          }
        }
        for (index = timers.length; index--;) {
          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
            timers[index].anim.stop(gotoEnd);
            dequeue = false;
            timers.splice(index, 1);
          }
        }
        if (dequeue || !gotoEnd) {
          jQuery.dequeue(this, type);
        }
      });
    },
    finish: function (type) {
      if (type !== false) {
        type = type || 'fx';
      }
      return this.each(function () {
        var index, data = data_priv.get(this), queue = data[type + 'queue'], hooks = data[type + 'queueHooks'], timers = jQuery.timers, length = queue ? queue.length : 0;
        data.finish = true;
        jQuery.queue(this, type, []);
        if (hooks && hooks.stop) {
          hooks.stop.call(this, true);
        }
        for (index = timers.length; index--;) {
          if (timers[index].elem === this && timers[index].queue === type) {
            timers[index].anim.stop(true);
            timers.splice(index, 1);
          }
        }
        for (index = 0; index < length; index++) {
          if (queue[index] && queue[index].finish) {
            queue[index].finish.call(this);
          }
        }
        delete data.finish;
      });
    }
  });
  function genFx(type, includeWidth) {
    var which, attrs = { height: type }, i = 0;
    includeWidth = includeWidth ? 1 : 0;
    for (; i < 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs['margin' + which] = attrs['padding' + which] = type;
    }
    if (includeWidth) {
      attrs.opacity = attrs.width = type;
    }
    return attrs;
  }
  jQuery.each({
    slideDown: genFx('show'),
    slideUp: genFx('hide'),
    slideToggle: genFx('toggle'),
    fadeIn: { opacity: 'show' },
    fadeOut: { opacity: 'hide' },
    fadeToggle: { opacity: 'toggle' }
  }, function (name, props) {
    jQuery.fn[name] = function (speed, easing, callback) {
      return this.animate(props, speed, easing, callback);
    };
  });
  jQuery.speed = function (speed, easing, fn) {
    var opt = speed && typeof speed === 'object' ? jQuery.extend({}, speed) : {
        complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
        duration: speed,
        easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
      };
    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === 'number' ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
    if (opt.queue == null || opt.queue === true) {
      opt.queue = 'fx';
    }
    opt.old = opt.complete;
    opt.complete = function () {
      if (jQuery.isFunction(opt.old)) {
        opt.old.call(this);
      }
      if (opt.queue) {
        jQuery.dequeue(this, opt.queue);
      }
    };
    return opt;
  };
  jQuery.easing = {
    linear: function (p) {
      return p;
    },
    swing: function (p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    }
  };
  jQuery.timers = [];
  jQuery.fx = Tween.prototype.init;
  jQuery.fx.tick = function () {
    var timer, timers = jQuery.timers, i = 0;
    fxNow = jQuery.now();
    for (; i < timers.length; i++) {
      timer = timers[i];
      if (!timer() && timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }
    if (!timers.length) {
      jQuery.fx.stop();
    }
    fxNow = undefined;
  };
  jQuery.fx.timer = function (timer) {
    if (timer() && jQuery.timers.push(timer)) {
      jQuery.fx.start();
    }
  };
  jQuery.fx.interval = 13;
  jQuery.fx.start = function () {
    if (!timerId) {
      timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
    }
  };
  jQuery.fx.stop = function () {
    clearInterval(timerId);
    timerId = null;
  };
  jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    _default: 400
  };
  jQuery.fx.step = {};
  if (jQuery.expr && jQuery.expr.filters) {
    jQuery.expr.filters.animated = function (elem) {
      return jQuery.grep(jQuery.timers, function (fn) {
        return elem === fn.elem;
      }).length;
    };
  }
  jQuery.fn.offset = function (options) {
    if (arguments.length) {
      return options === undefined ? this : this.each(function (i) {
        jQuery.offset.setOffset(this, options, i);
      });
    }
    var docElem, win, elem = this[0], box = {
        top: 0,
        left: 0
      }, doc = elem && elem.ownerDocument;
    if (!doc) {
      return;
    }
    docElem = doc.documentElement;
    if (!jQuery.contains(docElem, elem)) {
      return box;
    }
    if (typeof elem.getBoundingClientRect !== core_strundefined) {
      box = elem.getBoundingClientRect();
    }
    win = getWindow(doc);
    return {
      top: box.top + win.pageYOffset - docElem.clientTop,
      left: box.left + win.pageXOffset - docElem.clientLeft
    };
  };
  jQuery.offset = {
    setOffset: function (elem, options, i) {
      var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, 'position'), curElem = jQuery(elem), props = {};
      if (position === 'static') {
        elem.style.position = 'relative';
      }
      curOffset = curElem.offset();
      curCSSTop = jQuery.css(elem, 'top');
      curCSSLeft = jQuery.css(elem, 'left');
      calculatePosition = (position === 'absolute' || position === 'fixed') && (curCSSTop + curCSSLeft).indexOf('auto') > -1;
      if (calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }
      if (jQuery.isFunction(options)) {
        options = options.call(elem, i, curOffset);
      }
      if (options.top != null) {
        props.top = options.top - curOffset.top + curTop;
      }
      if (options.left != null) {
        props.left = options.left - curOffset.left + curLeft;
      }
      if ('using' in options) {
        options.using.call(elem, props);
      } else {
        curElem.css(props);
      }
    }
  };
  jQuery.fn.extend({
    position: function () {
      if (!this[0]) {
        return;
      }
      var offsetParent, offset, elem = this[0], parentOffset = {
          top: 0,
          left: 0
        };
      if (jQuery.css(elem, 'position') === 'fixed') {
        offset = elem.getBoundingClientRect();
      } else {
        offsetParent = this.offsetParent();
        offset = this.offset();
        if (!jQuery.nodeName(offsetParent[0], 'html')) {
          parentOffset = offsetParent.offset();
        }
        parentOffset.top += jQuery.css(offsetParent[0], 'borderTopWidth', true);
        parentOffset.left += jQuery.css(offsetParent[0], 'borderLeftWidth', true);
      }
      return {
        top: offset.top - parentOffset.top - jQuery.css(elem, 'marginTop', true),
        left: offset.left - parentOffset.left - jQuery.css(elem, 'marginLeft', true)
      };
    },
    offsetParent: function () {
      return this.map(function () {
        var offsetParent = this.offsetParent || docElem;
        while (offsetParent && (!jQuery.nodeName(offsetParent, 'html') && jQuery.css(offsetParent, 'position') === 'static')) {
          offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || docElem;
      });
    }
  });
  jQuery.each({
    scrollLeft: 'pageXOffset',
    scrollTop: 'pageYOffset'
  }, function (method, prop) {
    var top = 'pageYOffset' === prop;
    jQuery.fn[method] = function (val) {
      return jQuery.access(this, function (elem, method, val) {
        var win = getWindow(elem);
        if (val === undefined) {
          return win ? win[prop] : elem[method];
        }
        if (win) {
          win.scrollTo(!top ? val : window.pageXOffset, top ? val : window.pageYOffset);
        } else {
          elem[method] = val;
        }
      }, method, val, arguments.length, null);
    };
  });
  function getWindow(elem) {
    return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
  }
  jQuery.each({
    Height: 'height',
    Width: 'width'
  }, function (name, type) {
    jQuery.each({
      padding: 'inner' + name,
      content: type,
      '': 'outer' + name
    }, function (defaultExtra, funcName) {
      jQuery.fn[funcName] = function (margin, value) {
        var chainable = arguments.length && (defaultExtra || typeof margin !== 'boolean'), extra = defaultExtra || (margin === true || value === true ? 'margin' : 'border');
        return jQuery.access(this, function (elem, type, value) {
          var doc;
          if (jQuery.isWindow(elem)) {
            return elem.document.documentElement['client' + name];
          }
          if (elem.nodeType === 9) {
            doc = elem.documentElement;
            return Math.max(elem.body['scroll' + name], doc['scroll' + name], elem.body['offset' + name], doc['offset' + name], doc['client' + name]);
          }
          return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
        }, type, chainable ? margin : undefined, chainable, null);
      };
    });
  });
  jQuery.fn.size = function () {
    return this.length;
  };
  jQuery.fn.andSelf = jQuery.fn.addBack;
  if (typeof module === 'object' && module && typeof module.exports === 'object') {
    module.exports = jQuery;
  } else {
    if (typeof define === 'function' && define.amd) {
      define('jquery', [], function () {
        return jQuery;
      });
    }
  }
  if (typeof window === 'object' && typeof window.document === 'object') {
    window.jQuery = window.$ = jQuery;
  }
}(window));
(function () {
  var COMPILED = !0, goog = goog || {};
  goog.global = this;
  goog.exportPath_ = function (a, b, c) {
    a = a.split('.');
    c = c || goog.global;
    a[0] in c || !c.execScript || c.execScript('var ' + a[0]);
    for (var d; a.length && (d = a.shift());)
      a.length || void 0 === b ? c = c[d] ? c[d] : c[d] = {} : c[d] = b;
  };
  goog.define = function (a, b) {
    var c = b;
    COMPILED || goog.global.CLOSURE_DEFINES && Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_DEFINES, a) && (c = goog.global.CLOSURE_DEFINES[a]);
    goog.exportPath_(a, c);
  };
  goog.DEBUG = !1;
  goog.LOCALE = 'en';
  goog.TRUSTED_SITE = !0;
  goog.provide = function (a) {
    if (!COMPILED) {
      if (goog.isProvided_(a))
        throw Error('Namespace "' + a + '" already declared.');
      delete goog.implicitNamespaces_[a];
      for (var b = a; (b = b.substring(0, b.lastIndexOf('.'))) && !goog.getObjectByName(b);)
        goog.implicitNamespaces_[b] = !0;
    }
    goog.exportPath_(a);
  };
  goog.setTestOnly = function (a) {
    if (COMPILED && !goog.DEBUG)
      throw a = a || '', Error('Importing test-only code into non-debug environment' + a ? ': ' + a : '.');
  };
  COMPILED || (goog.isProvided_ = function (a) {
    return !goog.implicitNamespaces_[a] && !!goog.getObjectByName(a);
  }, goog.implicitNamespaces_ = {});
  goog.getObjectByName = function (a, b) {
    for (var c = a.split('.'), d = b || goog.global, e; e = c.shift();)
      if (goog.isDefAndNotNull(d[e]))
        d = d[e];
      else
        return null;
    return d;
  };
  goog.globalize = function (a, b) {
    var c = b || goog.global, d;
    for (d in a)
      c[d] = a[d];
  };
  goog.addDependency = function (a, b, c) {
    if (goog.DEPENDENCIES_ENABLED) {
      var d;
      a = a.replace(/\\/g, '/');
      for (var e = goog.dependencies_, f = 0; d = b[f]; f++)
        e.nameToPath[d] = a, a in e.pathToNames || (e.pathToNames[a] = {}), e.pathToNames[a][d] = !0;
      for (d = 0; b = c[d]; d++)
        a in e.requires || (e.requires[a] = {}), e.requires[a][b] = !0;
    }
  };
  goog.ENABLE_DEBUG_LOADER = !0;
  goog.require = function (a) {
    if (!COMPILED && !goog.isProvided_(a)) {
      if (goog.ENABLE_DEBUG_LOADER) {
        var b = goog.getPathFromDeps_(a);
        if (b) {
          goog.included_[b] = !0;
          goog.writeScripts_();
          return;
        }
      }
      a = 'goog.require could not find: ' + a;
      goog.global.console && goog.global.console.error(a);
      throw Error(a);
    }
  };
  goog.basePath = '';
  goog.nullFunction = function () {
  };
  goog.identityFunction = function (a, b) {
    return a;
  };
  goog.abstractMethod = function () {
    throw Error('unimplemented abstract method');
  };
  goog.addSingletonGetter = function (a) {
    a.getInstance = function () {
      if (a.instance_)
        return a.instance_;
      goog.DEBUG && (goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = a);
      return a.instance_ = new a();
    };
  };
  goog.instantiatedSingletons_ = [];
  goog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;
  goog.DEPENDENCIES_ENABLED && (goog.included_ = {}, goog.dependencies_ = {
    pathToNames: {},
    nameToPath: {},
    requires: {},
    visited: {},
    written: {}
  }, goog.inHtmlDocument_ = function () {
    var a = goog.global.document;
    return 'undefined' != typeof a && 'write' in a;
  }, goog.findBasePath_ = function () {
    if (goog.global.CLOSURE_BASE_PATH)
      goog.basePath = goog.global.CLOSURE_BASE_PATH;
    else if (goog.inHtmlDocument_())
      for (var a = goog.global.document.getElementsByTagName('script'), b = a.length - 1; 0 <= b; --b) {
        var c = a[b].src, d = c.lastIndexOf('?'), d = -1 == d ? c.length : d;
        if ('base.js' == c.substr(d - 7, 7)) {
          goog.basePath = c.substr(0, d - 7);
          break;
        }
      }
  }, goog.importScript_ = function (a) {
    var b = goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_;
    !goog.dependencies_.written[a] && b(a) && (goog.dependencies_.written[a] = !0);
  }, goog.writeScriptTag_ = function (a) {
    if (goog.inHtmlDocument_()) {
      var b = goog.global.document;
      if ('complete' == b.readyState) {
        if (/\bdeps.js$/.test(a))
          return !1;
        throw Error('Cannot write "' + a + '" after document load');
      }
      b.write('<script type="text/javascript" src="' + a + '"></script>');
      return !0;
    }
    return !1;
  }, goog.writeScripts_ = function () {
    function a(e) {
      if (!(e in d.written)) {
        if (!(e in d.visited) && (d.visited[e] = !0, e in d.requires))
          for (var g in d.requires[e])
            if (!goog.isProvided_(g))
              if (g in d.nameToPath)
                a(d.nameToPath[g]);
              else
                throw Error('Undefined nameToPath for ' + g);
        e in c || (c[e] = !0, b.push(e));
      }
    }
    var b = [], c = {}, d = goog.dependencies_, e;
    for (e in goog.included_)
      d.written[e] || a(e);
    for (e = 0; e < b.length; e++)
      if (b[e])
        goog.importScript_(goog.basePath + b[e]);
      else
        throw Error('Undefined script input');
  }, goog.getPathFromDeps_ = function (a) {
    return a in goog.dependencies_.nameToPath ? goog.dependencies_.nameToPath[a] : null;
  }, goog.findBasePath_(), goog.global.CLOSURE_NO_DEPS || goog.importScript_(goog.basePath + 'deps.js'));
  goog.typeOf = function (a) {
    var b = typeof a;
    if ('object' == b)
      if (a) {
        if (a instanceof Array)
          return 'array';
        if (a instanceof Object)
          return b;
        var c = Object.prototype.toString.call(a);
        if ('[object Window]' == c)
          return 'object';
        if ('[object Array]' == c || 'number' == typeof a.length && 'undefined' != typeof a.splice && 'undefined' != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable('splice'))
          return 'array';
        if ('[object Function]' == c || 'undefined' != typeof a.call && 'undefined' != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable('call'))
          return 'function';
      } else
        return 'null';
    else if ('function' == b && 'undefined' == typeof a.call)
      return 'object';
    return b;
  };
  goog.isDef = function (a) {
    return void 0 !== a;
  };
  goog.isNull = function (a) {
    return null === a;
  };
  goog.isDefAndNotNull = function (a) {
    return null != a;
  };
  goog.isArray = function (a) {
    return 'array' == goog.typeOf(a);
  };
  goog.isArrayLike = function (a) {
    var b = goog.typeOf(a);
    return 'array' == b || 'object' == b && 'number' == typeof a.length;
  };
  goog.isDateLike = function (a) {
    return goog.isObject(a) && 'function' == typeof a.getFullYear;
  };
  goog.isString = function (a) {
    return 'string' == typeof a;
  };
  goog.isBoolean = function (a) {
    return 'boolean' == typeof a;
  };
  goog.isNumber = function (a) {
    return 'number' == typeof a;
  };
  goog.isFunction = function (a) {
    return 'function' == goog.typeOf(a);
  };
  goog.isObject = function (a) {
    var b = typeof a;
    return 'object' == b && null != a || 'function' == b;
  };
  goog.getUid = function (a) {
    return a[goog.UID_PROPERTY_] || (a[goog.UID_PROPERTY_] = ++goog.uidCounter_);
  };
  goog.removeUid = function (a) {
    'removeAttribute' in a && a.removeAttribute(goog.UID_PROPERTY_);
    try {
      delete a[goog.UID_PROPERTY_];
    } catch (b) {
    }
  };
  goog.UID_PROPERTY_ = 'closure_uid_' + (1000000000 * Math.random() >>> 0);
  goog.uidCounter_ = 0;
  goog.getHashCode = goog.getUid;
  goog.removeHashCode = goog.removeUid;
  goog.cloneObject = function (a) {
    var b = goog.typeOf(a);
    if ('object' == b || 'array' == b) {
      if (a.clone)
        return a.clone();
      var b = 'array' == b ? [] : {}, c;
      for (c in a)
        b[c] = goog.cloneObject(a[c]);
      return b;
    }
    return a;
  };
  goog.bindNative_ = function (a, b, c) {
    return a.call.apply(a.bind, arguments);
  };
  goog.bindJs_ = function (a, b, c) {
    if (!a)
      throw Error();
    if (2 < arguments.length) {
      var d = Array.prototype.slice.call(arguments, 2);
      return function () {
        var c = Array.prototype.slice.call(arguments);
        Array.prototype.unshift.apply(c, d);
        return a.apply(b, c);
      };
    }
    return function () {
      return a.apply(b, arguments);
    };
  };
  goog.bind = function (a, b, c) {
    Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf('native code') ? goog.bind = goog.bindNative_ : goog.bind = goog.bindJs_;
    return goog.bind.apply(null, arguments);
  };
  goog.partial = function (a, b) {
    var c = Array.prototype.slice.call(arguments, 1);
    return function () {
      var b = Array.prototype.slice.call(arguments);
      b.unshift.apply(b, c);
      return a.apply(this, b);
    };
  };
  goog.mixin = function (a, b) {
    for (var c in b)
      a[c] = b[c];
  };
  goog.now = goog.TRUSTED_SITE && Date.now || function () {
    return +new Date();
  };
  goog.globalEval = function (a) {
    if (goog.global.execScript)
      goog.global.execScript(a, 'JavaScript');
    else if (goog.global.eval)
      if (null == goog.evalWorksForGlobals_ && (goog.global.eval('var _et_ = 1;'), 'undefined' != typeof goog.global._et_ ? (delete goog.global._et_, goog.evalWorksForGlobals_ = !0) : goog.evalWorksForGlobals_ = !1), goog.evalWorksForGlobals_)
        goog.global.eval(a);
      else {
        var b = goog.global.document, c = b.createElement('script');
        c.type = 'text/javascript';
        c.defer = !1;
        c.appendChild(b.createTextNode(a));
        b.body.appendChild(c);
        b.body.removeChild(c);
      }
    else
      throw Error('goog.globalEval not available');
  };
  goog.evalWorksForGlobals_ = null;
  goog.getCssName = function (a, b) {
    var c = function (a) {
        return goog.cssNameMapping_[a] || a;
      }, d = function (a) {
        a = a.split('-');
        for (var b = [], d = 0; d < a.length; d++)
          b.push(c(a[d]));
        return b.join('-');
      }, d = goog.cssNameMapping_ ? 'BY_WHOLE' == goog.cssNameMappingStyle_ ? c : d : function (a) {
        return a;
      };
    return b ? a + '-' + d(b) : d(a);
  };
  goog.setCssNameMapping = function (a, b) {
    goog.cssNameMapping_ = a;
    goog.cssNameMappingStyle_ = b;
  };
  !COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING && (goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING);
  goog.getMsg = function (a, b) {
    var c = b || {}, d;
    for (d in c) {
      var e = ('' + c[d]).replace(/\$/g, '$$$$');
      a = a.replace(RegExp('\\{\\$' + d + '\\}', 'gi'), e);
    }
    return a;
  };
  goog.getMsgWithFallback = function (a, b) {
    return a;
  };
  goog.exportSymbol = function (a, b, c) {
    goog.exportPath_(a, b, c);
  };
  goog.exportProperty = function (a, b, c) {
    a[b] = c;
  };
  goog.inherits = function (a, b) {
    function c() {
    }
    c.prototype = b.prototype;
    a.superClass_ = b.prototype;
    a.prototype = new c();
    a.prototype.constructor = a;
  };
  goog.base = function (a, b, c) {
    var d = arguments.callee.caller;
    if (goog.DEBUG && !d)
      throw Error('arguments.caller not defined.  goog.base() expects not to be running in strict mode. See http://www.ecma-international.org/ecma-262/5.1/#sec-C');
    if (d.superClass_)
      return d.superClass_.constructor.apply(a, Array.prototype.slice.call(arguments, 1));
    for (var e = Array.prototype.slice.call(arguments, 2), f = !1, g = a.constructor; g; g = g.superClass_ && g.superClass_.constructor)
      if (g.prototype[b] === d)
        f = !0;
      else if (f)
        return g.prototype[b].apply(a, e);
    if (a[b] === d)
      return a.constructor.prototype[b].apply(a, e);
    throw Error('goog.base called from a method of one name to a method of a different name');
  };
  goog.scope = function (a) {
    a.call(goog.global);
  };
  goog.string = {};
  goog.string.Unicode = { NBSP: '\xa0' };
  goog.string.startsWith = function (a, b) {
    return 0 == a.lastIndexOf(b, 0);
  };
  goog.string.endsWith = function (a, b) {
    var c = a.length - b.length;
    return 0 <= c && a.indexOf(b, c) == c;
  };
  goog.string.caseInsensitiveStartsWith = function (a, b) {
    return 0 == goog.string.caseInsensitiveCompare(b, a.substr(0, b.length));
  };
  goog.string.caseInsensitiveEndsWith = function (a, b) {
    return 0 == goog.string.caseInsensitiveCompare(b, a.substr(a.length - b.length, b.length));
  };
  goog.string.caseInsensitiveEquals = function (a, b) {
    return a.toLowerCase() == b.toLowerCase();
  };
  goog.string.subs = function (a, b) {
    for (var c = a.split('%s'), d = '', e = Array.prototype.slice.call(arguments, 1); e.length && 1 < c.length;)
      d += c.shift() + e.shift();
    return d + c.join('%s');
  };
  goog.string.collapseWhitespace = function (a) {
    return a.replace(/[\s\xa0]+/g, ' ').replace(/^\s+|\s+$/g, '');
  };
  goog.string.isEmpty = function (a) {
    return /^[\s\xa0]*$/.test(a);
  };
  goog.string.isEmptySafe = function (a) {
    return goog.string.isEmpty(goog.string.makeSafe(a));
  };
  goog.string.isBreakingWhitespace = function (a) {
    return !/[^\t\n\r ]/.test(a);
  };
  goog.string.isAlpha = function (a) {
    return !/[^a-zA-Z]/.test(a);
  };
  goog.string.isNumeric = function (a) {
    return !/[^0-9]/.test(a);
  };
  goog.string.isAlphaNumeric = function (a) {
    return !/[^a-zA-Z0-9]/.test(a);
  };
  goog.string.isSpace = function (a) {
    return ' ' == a;
  };
  goog.string.isUnicodeChar = function (a) {
    return 1 == a.length && ' ' <= a && '~' >= a || '\x80' <= a && '\ufffd' >= a;
  };
  goog.string.stripNewlines = function (a) {
    return a.replace(/(\r\n|\r|\n)+/g, ' ');
  };
  goog.string.canonicalizeNewlines = function (a) {
    return a.replace(/(\r\n|\r|\n)/g, '\n');
  };
  goog.string.normalizeWhitespace = function (a) {
    return a.replace(/\xa0|\s/g, ' ');
  };
  goog.string.normalizeSpaces = function (a) {
    return a.replace(/\xa0|[ \t]+/g, ' ');
  };
  goog.string.collapseBreakingSpaces = function (a) {
    return a.replace(/[\t\r\n ]+/g, ' ').replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, '');
  };
  goog.string.trim = function (a) {
    return a.replace(/^[\s\xa0]+|[\s\xa0]+$/g, '');
  };
  goog.string.trimLeft = function (a) {
    return a.replace(/^[\s\xa0]+/, '');
  };
  goog.string.trimRight = function (a) {
    return a.replace(/[\s\xa0]+$/, '');
  };
  goog.string.caseInsensitiveCompare = function (a, b) {
    var c = String(a).toLowerCase(), d = String(b).toLowerCase();
    return c < d ? -1 : c == d ? 0 : 1;
  };
  goog.string.numerateCompareRegExp_ = /(\.\d+)|(\d+)|(\D+)/g;
  goog.string.numerateCompare = function (a, b) {
    if (a == b)
      return 0;
    if (!a)
      return -1;
    if (!b)
      return 1;
    for (var c = a.toLowerCase().match(goog.string.numerateCompareRegExp_), d = b.toLowerCase().match(goog.string.numerateCompareRegExp_), e = Math.min(c.length, d.length), f = 0; f < e; f++) {
      var g = c[f], h = d[f];
      if (g != h)
        return c = parseInt(g, 10), !isNaN(c) && (d = parseInt(h, 10), !isNaN(d) && c - d) ? c - d : g < h ? -1 : 1;
    }
    return c.length != d.length ? c.length - d.length : a < b ? -1 : 1;
  };
  goog.string.urlEncode = function (a) {
    return encodeURIComponent(String(a));
  };
  goog.string.urlDecode = function (a) {
    return decodeURIComponent(a.replace(/\+/g, ' '));
  };
  goog.string.newLineToBr = function (a, b) {
    return a.replace(/(\r\n|\r|\n)/g, b ? '<br />' : '<br>');
  };
  goog.string.htmlEscape = function (a, b) {
    if (b)
      return a.replace(goog.string.amperRe_, '&amp;').replace(goog.string.ltRe_, '&lt;').replace(goog.string.gtRe_, '&gt;').replace(goog.string.quotRe_, '&quot;');
    if (!goog.string.allRe_.test(a))
      return a;
    -1 != a.indexOf('&') && (a = a.replace(goog.string.amperRe_, '&amp;'));
    -1 != a.indexOf('<') && (a = a.replace(goog.string.ltRe_, '&lt;'));
    -1 != a.indexOf('>') && (a = a.replace(goog.string.gtRe_, '&gt;'));
    -1 != a.indexOf('"') && (a = a.replace(goog.string.quotRe_, '&quot;'));
    return a;
  };
  goog.string.amperRe_ = /&/g;
  goog.string.ltRe_ = /</g;
  goog.string.gtRe_ = />/g;
  goog.string.quotRe_ = /\"/g;
  goog.string.allRe_ = /[&<>\"]/;
  goog.string.unescapeEntities = function (a) {
    return goog.string.contains(a, '&') ? 'document' in goog.global ? goog.string.unescapeEntitiesUsingDom_(a) : goog.string.unescapePureXmlEntities_(a) : a;
  };
  goog.string.unescapeEntitiesUsingDom_ = function (a) {
    var b = {
        '&amp;': '&',
        '&lt;': '<',
        '&gt;': '>',
        '&quot;': '"'
      }, c = document.createElement('div');
    return a.replace(goog.string.HTML_ENTITY_PATTERN_, function (a, e) {
      var f = b[a];
      if (f)
        return f;
      if ('#' == e.charAt(0)) {
        var g = Number('0' + e.substr(1));
        isNaN(g) || (f = String.fromCharCode(g));
      }
      f || (c.innerHTML = a + ' ', f = c.firstChild.nodeValue.slice(0, -1));
      return b[a] = f;
    });
  };
  goog.string.unescapePureXmlEntities_ = function (a) {
    return a.replace(/&([^;]+);/g, function (a, c) {
      switch (c) {
      case 'amp':
        return '&';
      case 'lt':
        return '<';
      case 'gt':
        return '>';
      case 'quot':
        return '"';
      default:
        if ('#' == c.charAt(0)) {
          var d = Number('0' + c.substr(1));
          if (!isNaN(d))
            return String.fromCharCode(d);
        }
        return a;
      }
    });
  };
  goog.string.HTML_ENTITY_PATTERN_ = /&([^;\s<&]+);?/g;
  goog.string.whitespaceEscape = function (a, b) {
    return goog.string.newLineToBr(a.replace(/  /g, ' &#160;'), b);
  };
  goog.string.stripQuotes = function (a, b) {
    for (var c = b.length, d = 0; d < c; d++) {
      var e = 1 == c ? b : b.charAt(d);
      if (a.charAt(0) == e && a.charAt(a.length - 1) == e)
        return a.substring(1, a.length - 1);
    }
    return a;
  };
  goog.string.truncate = function (a, b, c) {
    c && (a = goog.string.unescapeEntities(a));
    a.length > b && (a = a.substring(0, b - 3) + '...');
    c && (a = goog.string.htmlEscape(a));
    return a;
  };
  goog.string.truncateMiddle = function (a, b, c, d) {
    c && (a = goog.string.unescapeEntities(a));
    if (d && a.length > b) {
      d > b && (d = b);
      var e = a.length - d;
      a = a.substring(0, b - d) + '...' + a.substring(e);
    } else
      a.length > b && (d = Math.floor(b / 2), e = a.length - d, a = a.substring(0, d + b % 2) + '...' + a.substring(e));
    c && (a = goog.string.htmlEscape(a));
    return a;
  };
  goog.string.specialEscapeChars_ = {
    '\0': '\\0',
    '\b': '\\b',
    '\f': '\\f',
    '\n': '\\n',
    '\r': '\\r',
    '\t': '\\t',
    '\x0B': '\\x0B',
    '"': '\\"',
    '\\': '\\\\'
  };
  goog.string.jsEscapeCache_ = { '\'': '\\\'' };
  goog.string.quote = function (a) {
    a = String(a);
    if (a.quote)
      return a.quote();
    for (var b = ['"'], c = 0; c < a.length; c++) {
      var d = a.charAt(c), e = d.charCodeAt(0);
      b[c + 1] = goog.string.specialEscapeChars_[d] || (31 < e && 127 > e ? d : goog.string.escapeChar(d));
    }
    b.push('"');
    return b.join('');
  };
  goog.string.escapeString = function (a) {
    for (var b = [], c = 0; c < a.length; c++)
      b[c] = goog.string.escapeChar(a.charAt(c));
    return b.join('');
  };
  goog.string.escapeChar = function (a) {
    if (a in goog.string.jsEscapeCache_)
      return goog.string.jsEscapeCache_[a];
    if (a in goog.string.specialEscapeChars_)
      return goog.string.jsEscapeCache_[a] = goog.string.specialEscapeChars_[a];
    var b = a, c = a.charCodeAt(0);
    if (31 < c && 127 > c)
      b = a;
    else {
      if (256 > c) {
        if (b = '\\x', 16 > c || 256 < c)
          b += '0';
      } else
        b = '\\u', 4096 > c && (b += '0');
      b += c.toString(16).toUpperCase();
    }
    return goog.string.jsEscapeCache_[a] = b;
  };
  goog.string.toMap = function (a) {
    for (var b = {}, c = 0; c < a.length; c++)
      b[a.charAt(c)] = !0;
    return b;
  };
  goog.string.contains = function (a, b) {
    return -1 != a.indexOf(b);
  };
  goog.string.countOf = function (a, b) {
    return a && b ? a.split(b).length - 1 : 0;
  };
  goog.string.removeAt = function (a, b, c) {
    var d = a;
    0 <= b && (b < a.length && 0 < c) && (d = a.substr(0, b) + a.substr(b + c, a.length - b - c));
    return d;
  };
  goog.string.remove = function (a, b) {
    var c = RegExp(goog.string.regExpEscape(b), '');
    return a.replace(c, '');
  };
  goog.string.removeAll = function (a, b) {
    var c = RegExp(goog.string.regExpEscape(b), 'g');
    return a.replace(c, '');
  };
  goog.string.regExpEscape = function (a) {
    return String(a).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
  };
  goog.string.repeat = function (a, b) {
    return Array(b + 1).join(a);
  };
  goog.string.padNumber = function (a, b, c) {
    a = goog.isDef(c) ? a.toFixed(c) : String(a);
    c = a.indexOf('.');
    -1 == c && (c = a.length);
    return goog.string.repeat('0', Math.max(0, b - c)) + a;
  };
  goog.string.makeSafe = function (a) {
    return null == a ? '' : String(a);
  };
  goog.string.buildString = function (a) {
    return Array.prototype.join.call(arguments, '');
  };
  goog.string.getRandomString = function () {
    return Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ goog.now()).toString(36);
  };
  goog.string.compareVersions = function (a, b) {
    for (var c = 0, d = goog.string.trim(String(a)).split('.'), e = goog.string.trim(String(b)).split('.'), f = Math.max(d.length, e.length), g = 0; 0 == c && g < f; g++) {
      var h = d[g] || '', k = e[g] || '', l = /(\d*)(\D*)/g, m = /(\d*)(\D*)/g;
      do {
        var n = l.exec(h) || [
            '',
            '',
            ''
          ], p = m.exec(k) || [
            '',
            '',
            ''
          ];
        if (0 == n[0].length && 0 == p[0].length)
          break;
        var c = 0 == n[1].length ? 0 : parseInt(n[1], 10), q = 0 == p[1].length ? 0 : parseInt(p[1], 10), c = goog.string.compareElements_(c, q) || goog.string.compareElements_(0 == n[2].length, 0 == p[2].length) || goog.string.compareElements_(n[2], p[2]);
      } while (0 == c);
    }
    return c;
  };
  goog.string.compareElements_ = function (a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  };
  goog.string.HASHCODE_MAX_ = 4294967296;
  goog.string.hashCode = function (a) {
    for (var b = 0, c = 0; c < a.length; ++c)
      b = 31 * b + a.charCodeAt(c), b %= goog.string.HASHCODE_MAX_;
    return b;
  };
  goog.string.uniqueStringCounter_ = 2147483648 * Math.random() | 0;
  goog.string.createUniqueString = function () {
    return 'goog_' + goog.string.uniqueStringCounter_++;
  };
  goog.string.toNumber = function (a) {
    var b = Number(a);
    return 0 == b && goog.string.isEmpty(a) ? NaN : b;
  };
  goog.string.isLowerCamelCase = function (a) {
    return /^[a-z]+([A-Z][a-z]*)*$/.test(a);
  };
  goog.string.isUpperCamelCase = function (a) {
    return /^([A-Z][a-z]*)+$/.test(a);
  };
  goog.string.toCamelCase = function (a) {
    return String(a).replace(/\-([a-z])/g, function (a, c) {
      return c.toUpperCase();
    });
  };
  goog.string.toSelectorCase = function (a) {
    return String(a).replace(/([A-Z])/g, '-$1').toLowerCase();
  };
  goog.string.toTitleCase = function (a, b) {
    var c = goog.isString(b) ? goog.string.regExpEscape(b) : '\\s';
    return a.replace(RegExp('(^' + (c ? '|[' + c + ']+' : '') + ')([a-z])', 'g'), function (a, b, c) {
      return b + c.toUpperCase();
    });
  };
  goog.string.parseInt = function (a) {
    isFinite(a) && (a = String(a));
    return goog.isString(a) ? /^\s*-?0x/i.test(a) ? parseInt(a, 16) : parseInt(a, 10) : NaN;
  };
  goog.string.splitLimit = function (a, b, c) {
    a = a.split(b);
    for (var d = []; 0 < c && a.length;)
      d.push(a.shift()), c--;
    a.length && d.push(a.join(b));
    return d;
  };
  goog.debug = {};
  goog.debug.Error = function (a) {
    Error.captureStackTrace ? Error.captureStackTrace(this, goog.debug.Error) : this.stack = Error().stack || '';
    a && (this.message = String(a));
  };
  goog.inherits(goog.debug.Error, Error);
  goog.debug.Error.prototype.name = 'CustomError';
  goog.asserts = {};
  goog.asserts.ENABLE_ASSERTS = goog.DEBUG;
  goog.asserts.AssertionError = function (a, b) {
    b.unshift(a);
    goog.debug.Error.call(this, goog.string.subs.apply(null, b));
    b.shift();
    this.messagePattern = a;
  };
  goog.inherits(goog.asserts.AssertionError, goog.debug.Error);
  goog.asserts.AssertionError.prototype.name = 'AssertionError';
  goog.asserts.doAssertFailure_ = function (a, b, c, d) {
    var e = 'Assertion failed';
    if (c)
      var e = e + (': ' + c), f = d;
    else
      a && (e += ': ' + a, f = b);
    throw new goog.asserts.AssertionError('' + e, f || []);
  };
  goog.asserts.assert = function (a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !a && goog.asserts.doAssertFailure_('', null, b, Array.prototype.slice.call(arguments, 2));
    return a;
  };
  goog.asserts.fail = function (a, b) {
    if (goog.asserts.ENABLE_ASSERTS)
      throw new goog.asserts.AssertionError('Failure' + (a ? ': ' + a : ''), Array.prototype.slice.call(arguments, 1));
  };
  goog.asserts.assertNumber = function (a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !goog.isNumber(a) && goog.asserts.doAssertFailure_('Expected number but got %s: %s.', [
      goog.typeOf(a),
      a
    ], b, Array.prototype.slice.call(arguments, 2));
    return a;
  };
  goog.asserts.assertString = function (a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !goog.isString(a) && goog.asserts.doAssertFailure_('Expected string but got %s: %s.', [
      goog.typeOf(a),
      a
    ], b, Array.prototype.slice.call(arguments, 2));
    return a;
  };
  goog.asserts.assertFunction = function (a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !goog.isFunction(a) && goog.asserts.doAssertFailure_('Expected function but got %s: %s.', [
      goog.typeOf(a),
      a
    ], b, Array.prototype.slice.call(arguments, 2));
    return a;
  };
  goog.asserts.assertObject = function (a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !goog.isObject(a) && goog.asserts.doAssertFailure_('Expected object but got %s: %s.', [
      goog.typeOf(a),
      a
    ], b, Array.prototype.slice.call(arguments, 2));
    return a;
  };
  goog.asserts.assertArray = function (a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !goog.isArray(a) && goog.asserts.doAssertFailure_('Expected array but got %s: %s.', [
      goog.typeOf(a),
      a
    ], b, Array.prototype.slice.call(arguments, 2));
    return a;
  };
  goog.asserts.assertBoolean = function (a, b, c) {
    goog.asserts.ENABLE_ASSERTS && !goog.isBoolean(a) && goog.asserts.doAssertFailure_('Expected boolean but got %s: %s.', [
      goog.typeOf(a),
      a
    ], b, Array.prototype.slice.call(arguments, 2));
    return a;
  };
  goog.asserts.assertInstanceof = function (a, b, c, d) {
    !goog.asserts.ENABLE_ASSERTS || a instanceof b || goog.asserts.doAssertFailure_('instanceof check failed.', null, c, Array.prototype.slice.call(arguments, 3));
    return a;
  };
  goog.asserts.assertObjectPrototypeIsIntact = function () {
    for (var a in Object.prototype)
      goog.asserts.fail(a + ' should not be enumerable in Object.prototype.');
  };
  var Sk = Sk || {};
  Sk.configure = function (a) {
    Sk.output = a.output || Sk.output;
    goog.asserts.assert('function' === typeof Sk.output);
    Sk.debugout = a.debugout || Sk.debugout;
    goog.asserts.assert('function' === typeof Sk.debugout);
    Sk.read = a.read || Sk.read;
    goog.asserts.assert('function' === typeof Sk.read);
    Sk.timeoutMsg = a.timeoutMsg || Sk.timeoutMsg;
    goog.asserts.assert('function' === typeof Sk.timeoutMsg);
    goog.exportSymbol('Sk.timeoutMsg', Sk.timeoutMsg);
    Sk.sysargv = a.sysargv || Sk.sysargv;
    goog.asserts.assert(goog.isArrayLike(Sk.sysargv));
    Sk.python3 = a.python3 || Sk.python3;
    goog.asserts.assert('boolean' === typeof Sk.python3);
    Sk.inputfun = a.inputfun || Sk.inputfun;
    goog.asserts.assert('function' === typeof Sk.inputfun);
    Sk.throwSystemExit = a.systemexit || !1;
    goog.asserts.assert('boolean' === typeof Sk.throwSystemExit);
    a.syspath && (Sk.syspath = a.syspath, goog.asserts.assert(goog.isArrayLike(Sk.syspath)), Sk.realsyspath = void 0, Sk.sysmodules = new Sk.builtin.dict([]));
    Sk.misceval.softspace_ = !1;
  };
  goog.exportSymbol('Sk.configure', Sk.configure);
  Sk.timeoutMsg = function () {
    return 'Program exceeded run time limit.';
  };
  goog.exportSymbol('Sk.timeoutMsg', Sk.timeoutMsg);
  Sk.output = function (a) {
  };
  Sk.read = function (a) {
    throw 'Sk.read has not been implemented';
  };
  Sk.sysargv = [];
  Sk.getSysArgv = function () {
    return Sk.sysargv;
  };
  goog.exportSymbol('Sk.getSysArgv', Sk.getSysArgv);
  Sk.syspath = [];
  Sk.inBrowser = void 0 !== goog.global.document;
  Sk.debugout = function (a) {
  };
  (function () {
    void 0 !== goog.global.write ? Sk.output = goog.global.write : void 0 !== goog.global.console && void 0 !== goog.global.console.log ? Sk.output = function (a) {
      goog.global.console.log(a);
    } : void 0 !== goog.global.print && (Sk.output = goog.global.print);
    void 0 !== goog.global.print && (Sk.debugout = goog.global.print);
  }());
  Sk.inBrowser || (goog.global.CLOSURE_IMPORT_SCRIPT = function (a) {
    goog.global.eval(goog.global.read('support/closure-library/closure/goog/' + a));
    return !0;
  });
  Sk.python3 = !1;
  Sk.inputfun = function (a) {
    return prompt(a);
  };
  goog.exportSymbol('Sk.python3', Sk.python3);
  goog.exportSymbol('Sk.inputfun', Sk.inputfun);
  Sk.builtin = {};
  Sk.builtin.range = function (a, b, c) {
    var d = [], e;
    Sk.builtin.pyCheckArgs('range', arguments, 1, 3);
    Sk.builtin.pyCheckType('start', 'integer', Sk.builtin.checkInt(a));
    void 0 !== b && Sk.builtin.pyCheckType('stop', 'integer', Sk.builtin.checkInt(b));
    void 0 !== c && Sk.builtin.pyCheckType('step', 'integer', Sk.builtin.checkInt(c));
    a = Sk.builtin.asnum$(a);
    b = Sk.builtin.asnum$(b);
    c = Sk.builtin.asnum$(c);
    void 0 === b && void 0 === c ? (b = a, a = 0, c = 1) : void 0 === c && (c = 1);
    if (0 === c)
      throw new Sk.builtin.ValueError('range() step argument must not be zero');
    if (0 < c)
      for (e = a; e < b; e += c)
        d.push(new Sk.builtin.nmber(e, Sk.builtin.nmber.int$));
    else
      for (e = a; e > b; e += c)
        d.push(new Sk.builtin.nmber(e, Sk.builtin.nmber.int$));
    return new Sk.builtin.list(d);
  };
  Sk.builtin.asnum$ = function (a) {
    return void 0 === a || null === a ? a : a.constructor === Sk.builtin.none ? null : a.constructor === Sk.builtin.bool ? a.v ? 1 : 0 : 'number' === typeof a ? a : 'string' === typeof a ? a : a.constructor === Sk.builtin.nmber ? a.v : a.constructor === Sk.builtin.lng ? a.cantBeInt() ? a.str$(10, !0) : a.toInt$() : a.constructor === Sk.builtin.biginteger ? 0 < a.trueCompare(new Sk.builtin.biginteger(Sk.builtin.lng.threshold$)) || 0 > a.trueCompare(new Sk.builtin.biginteger(-Sk.builtin.lng.threshold$)) ? a.toString() : a.intValue() : a;
  };
  goog.exportSymbol('Sk.builtin.asnum$', Sk.builtin.asnum$);
  Sk.builtin.assk$ = function (a, b) {
    return new Sk.builtin.nmber(a, b);
  };
  goog.exportSymbol('Sk.builtin.assk$', Sk.builtin.assk$);
  Sk.builtin.asnum$nofloat = function (a) {
    if (void 0 === a || null === a)
      return a;
    if (a.constructor === Sk.builtin.none)
      return null;
    if (a.constructor === Sk.builtin.bool)
      return a.v ? 1 : 0;
    'number' === typeof a && (a = a.toString());
    a.constructor === Sk.builtin.nmber && (a = a.v.toString());
    a.constructor === Sk.builtin.lng && (a = a.str$(10, !0));
    a.constructor === Sk.builtin.biginteger && (a = a.toString());
    if (0 > a.indexOf('.') && 0 > a.indexOf('e') && 0 > a.indexOf('E'))
      return a;
    var b = 0, c;
    0 <= a.indexOf('e') ? (c = a.substr(0, a.indexOf('e')), b = a.substr(a.indexOf('e') + 1)) : 0 <= a.indexOf('E') ? (c = a.substr(0, a.indexOf('e')), b = a.substr(a.indexOf('E') + 1)) : c = a;
    b = parseInt(b, 10);
    a = c.indexOf('.');
    if (0 > a) {
      if (0 <= b) {
        for (; 0 < b--;)
          c += '0';
        return c;
      }
      return c.length > -b ? c.substr(0, c.length + b) : 0;
    }
    c = 0 == a ? c.substr(1) : a < c.length ? c.substr(0, a) + c.substr(a + 1) : c.substr(0, a);
    for (a += b; a > c.length;)
      c += '0';
    return c = 0 >= a ? 0 : c.substr(0, a);
  };
  goog.exportSymbol('Sk.builtin.asnum$nofloat', Sk.builtin.asnum$nofloat);
  Sk.builtin.round = function (a, b) {
    var c;
    Sk.builtin.pyCheckArgs('round', arguments, 1, 2);
    if (!Sk.builtin.checkNumber(a))
      throw new Sk.builtin.TypeError('a float is required');
    if (void 0 !== b && !Sk.misceval.isIndex(b))
      throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(b) + '\' object cannot be interpreted as an index');
    void 0 === b && (b = 0);
    a = Sk.builtin.asnum$(a);
    b = Sk.misceval.asIndex(b);
    c = Math.pow(10, b);
    c = Math.round(a * c) / c;
    return new Sk.builtin.nmber(c, Sk.builtin.nmber.float$);
  };
  Sk.builtin.len = function (a) {
    Sk.builtin.pyCheckArgs('len', arguments, 1, 1);
    if (a.sq$length)
      return new Sk.builtin.nmber(a.sq$length(), Sk.builtin.nmber.int$);
    if (a.mp$length)
      return new Sk.builtin.nmber(a.mp$length(), Sk.builtin.nmber.int$);
    if (a.tp$length)
      return new Sk.builtin.nmber(a.tp$length(), Sk.builtin.nmber.int$);
    throw new Sk.builtin.TypeError('object of type \'' + Sk.abstr.typeName(a) + '\' has no len()');
  };
  Sk.builtin.min = function () {
    Sk.builtin.pyCheckArgs('min', arguments, 1);
    for (var a = Sk.misceval.arrayFromArguments(arguments), b = a[0], c = 1; c < a.length; ++c)
      Sk.misceval.richCompareBool(a[c], b, 'Lt') && (b = a[c]);
    return b;
  };
  Sk.builtin.max = function () {
    Sk.builtin.pyCheckArgs('max', arguments, 1);
    for (var a = Sk.misceval.arrayFromArguments(arguments), b = a[0], c = 1; c < a.length; ++c)
      Sk.misceval.richCompareBool(a[c], b, 'Gt') && (b = a[c]);
    return b;
  };
  Sk.builtin.any = function (a) {
    var b, c;
    Sk.builtin.pyCheckArgs('any', arguments, 1);
    if (!Sk.builtin.checkIterable(a))
      throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(a) + '\' object is not iterable');
    b = a.tp$iter();
    for (c = b.tp$iternext(); void 0 !== c; c = b.tp$iternext())
      if (Sk.misceval.isTrue(c))
        return !0;
    return !1;
  };
  Sk.builtin.all = function (a) {
    var b, c;
    Sk.builtin.pyCheckArgs('all', arguments, 1);
    if (!Sk.builtin.checkIterable(a))
      throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(a) + '\' object is not iterable');
    b = a.tp$iter();
    for (c = b.tp$iternext(); void 0 !== c; c = b.tp$iternext())
      if (!Sk.misceval.isTrue(c))
        return !1;
    return !0;
  };
  Sk.builtin.sum = function (a, b) {
    var c, d, e, f;
    Sk.builtin.pyCheckArgs('sum', arguments, 1, 2);
    Sk.builtin.pyCheckType('iter', 'iterable', Sk.builtin.checkIterable(a));
    if (void 0 !== b && Sk.builtin.checkString(b))
      throw new Sk.builtin.TypeError('sum() can\'t sum strings [use \'\'.join(seq) instead]');
    c = void 0 === b ? new Sk.builtin.nmber(0, Sk.builtin.nmber.int$) : b;
    d = a.tp$iter();
    for (e = d.tp$iternext(); void 0 !== e; e = d.tp$iternext())
      if (e.skType === Sk.builtin.nmber.float$ ? (f = !0, c.skType !== Sk.builtin.nmber.float$ && (c = new Sk.builtin.nmber(Sk.builtin.asnum$(c), Sk.builtin.nmber.float$))) : e instanceof Sk.builtin.lng && (f || c instanceof Sk.builtin.lng || (c = new Sk.builtin.lng(c))), void 0 !== c.nb$add(e))
        c = c.nb$add(e);
      else
        throw new Sk.builtin.TypeError('unsupported operand type(s) for +: \'' + Sk.abstr.typeName(c) + '\' and \'' + Sk.abstr.typeName(e) + '\'');
    return c;
  };
  Sk.builtin.zip = function () {
    if (0 === arguments.length)
      return new Sk.builtin.list([]);
    for (var a = [], b = 0; b < arguments.length; b++)
      if (arguments[b].tp$iter)
        a.push(arguments[b].tp$iter());
      else
        throw 'TypeError: argument ' + b + ' must support iteration';
    for (var c = [], d = !1; !d;) {
      for (var e = [], b = 0; b < arguments.length; b++) {
        var f = a[b].tp$iternext();
        if (void 0 === f) {
          d = !0;
          break;
        }
        e.push(f);
      }
      d || c.push(new Sk.builtin.tuple(e));
    }
    return new Sk.builtin.list(c);
  };
  Sk.builtin.abs = function (a) {
    Sk.ffi.checkFunctionArgs('abs', arguments, 1, 1);
    if (Sk.ffi.isNum(a))
      return Sk.ffi.numberToPy(Math.abs(Sk.ffi.remapToJs(a)), Sk.ffi.getType(a));
    try {
      var b = a.__abs__;
      if (b)
        return Sk.ffi.callsim(b, a);
      throw new Sk.builtin.NotImplementedError('abs');
    } catch (c) {
      throw Sk.ffi.err.argument('x').inFunction('abs').mustHaveType('number');
    }
  };
  Sk.builtin.ord = function (a) {
    Sk.builtin.pyCheckArgs('ord', arguments, 1, 1);
    if (!Sk.builtin.checkString(a))
      throw new Sk.builtin.TypeError('ord() expected a string of length 1, but ' + Sk.abstr.typeName(a) + ' found');
    if (1 !== a.v.length)
      throw new Sk.builtin.TypeError('ord() expected a character, but string of length ' + a.v.length + ' found');
    return new Sk.builtin.nmber(a.v.charCodeAt(0), Sk.builtin.nmber.int$);
  };
  Sk.builtin.chr = function (a) {
    Sk.builtin.pyCheckArgs('chr', arguments, 1, 1);
    if (!Sk.builtin.checkInt(a))
      throw new Sk.builtin.TypeError('an integer is required');
    a = Sk.builtin.asnum$(a);
    if (0 > a || 255 < a)
      throw new Sk.builtin.ValueError('chr() arg not in range(256)');
    return new Sk.builtin.str(String.fromCharCode(a));
  };
  Sk.builtin.int2str_ = function (a, b, c) {
    var d = '';
    if (a instanceof Sk.builtin.lng) {
      var e = '';
      2 !== b && (e = 'L');
      d = a.str$(b, !1);
      return a.nb$isnegative() ? new Sk.builtin.str('-' + c + d + e) : new Sk.builtin.str(c + d + e);
    }
    a = Sk.misceval.asIndex(a);
    d = a.toString(b);
    return 0 > a ? new Sk.builtin.str('-' + c + d.slice(1)) : new Sk.builtin.str(c + d);
  };
  Sk.builtin.hex = function (a) {
    Sk.builtin.pyCheckArgs('hex', arguments, 1, 1);
    if (!Sk.misceval.isIndex(a))
      throw new Sk.builtin.TypeError('hex() argument can\'t be converted to hex');
    return Sk.builtin.int2str_(a, 16, '0x');
  };
  Sk.builtin.oct = function (a) {
    Sk.builtin.pyCheckArgs('oct', arguments, 1, 1);
    if (!Sk.misceval.isIndex(a))
      throw new Sk.builtin.TypeError('oct() argument can\'t be converted to hex');
    return Sk.builtin.int2str_(a, 8, '0');
  };
  Sk.builtin.bin = function (a) {
    Sk.builtin.pyCheckArgs('bin', arguments, 1, 1);
    if (!Sk.misceval.isIndex(a))
      throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(a) + '\' object can\'t be interpreted as an index');
    return Sk.builtin.int2str_(a, 2, '0b');
  };
  Sk.builtin.dir = function (a) {
    Sk.builtin.pyCheckArgs('dir', arguments, 1, 1);
    var b = function (a) {
        var b = null;
        if (-1 !== [
            '__bases__',
            '__mro__',
            '__class__'
          ].indexOf(a))
          return null;
        -1 !== a.indexOf('$') ? b = Sk.builtin.dir.slotNameToRichName(a) : '_' !== a.charAt(a.length - 1) ? b = a : '_' === a.charAt(0) && (b = a);
        return b;
      }, c = [], d, e, f, g, h;
    for (d in a.constructor.prototype)
      (e = b(d)) && c.push(new Sk.builtin.str(e));
    if (a.$d)
      if (a.$d.tp$iter)
        for (f = a.$d.tp$iter(), d = f.tp$iternext(); void 0 !== d; d = f.tp$iternext())
          e = new Sk.builtin.str(d), (e = b(e.v)) && c.push(new Sk.builtin.str(e));
      else
        for (e in a.$d)
          c.push(new Sk.builtin.str(e));
    if (f = a.tp$mro)
      for (f = a.tp$mro, d = 0; d < f.v.length; ++d)
        for (h in g = f.v[d], g)
          g.hasOwnProperty(h) && (e = b(h)) && c.push(new Sk.builtin.str(e));
    c.sort(function (a, b) {
      return (a.v > b.v) - (a.v < b.v);
    });
    return new Sk.builtin.list(c.filter(function (a, b, c) {
      return a !== c[b + 1];
    }));
  };
  Sk.builtin.dir.slotNameToRichName = function (a) {
  };
  Sk.builtin.repr = function (a) {
    Sk.builtin.pyCheckArgs('repr', arguments, 1, 1);
    return Sk.misceval.objectRepr(a);
  };
  Sk.builtin.open = function (a, b, c) {
    Sk.builtin.pyCheckArgs('open', arguments, 1, 3);
    void 0 === b && (b = new Sk.builtin.str('r'));
    if ('r' !== b.v && 'rb' !== b.v)
      throw 'todo; haven\'t implemented non-read opens';
    return new Sk.builtin.file(a, b, c);
  };
  Sk.builtin.isinstance = function (a, b) {
    Sk.builtin.pyCheckArgs('isinstance', arguments, 2, 2);
    if (!(Sk.builtin.checkClass(b) || b instanceof Sk.builtin.tuple))
      throw new Sk.builtin.TypeError('isinstance() arg 2 must be a class, type, or tuple of classes and types');
    if (b === Sk.builtin.int_.prototype.ob$type)
      return 'number' === a.tp$name && a.skType === Sk.builtin.nmber.int$;
    if (b === Sk.builtin.float_.prototype.ob$type)
      return 'number' === a.tp$name && a.skType === Sk.builtin.nmber.float$;
    if (b === Sk.builtin.none.prototype.ob$type)
      return a instanceof Sk.builtin.none;
    if (a.ob$type === b)
      return !0;
    if (b instanceof Sk.builtin.tuple) {
      for (var c = 0; c < b.v.length; ++c)
        if (Sk.builtin.isinstance(a, b.v[c]))
          return !0;
      return !1;
    }
    var d = function (a, b) {
      if (a === b)
        return !0;
      if (void 0 === a.$d)
        return !1;
      for (var c = a.$d.mp$subscript(Sk.builtin.type.basesStr_), h = 0; h < c.v.length; ++h)
        if (d(c.v[h], b))
          return !0;
      return !1;
    };
    return d(a.ob$type, b);
  };
  Sk.builtin.hashCount = 0;
  Sk.builtin.hash = function (a) {
    Sk.builtin.pyCheckArgs('hash', arguments, 1, 1);
    if (a instanceof Object && void 0 !== a.tp$hash) {
      if (a.$savedHash_)
        return a.$savedHash_;
      a.$savedHash_ = a.tp$hash();
      return a.$savedHash_;
    }
    return a instanceof Object && void 0 !== a.__hash__ ? Sk.misceval.callsim(a.__hash__, a) : a instanceof Sk.builtin.bool ? a.v ? 1 : 0 : a instanceof Sk.builtin.none ? 0 : a instanceof Object ? (void 0 === a.__id && (Sk.builtin.hashCount += 1, a.__id = Sk.builtin.hashCount), a.__id) : 'number' === typeof a ? a : null === a ? 0 : !0 === a ? 1 : !1 === a ? 0 : typeof a + ' ' + String(a);
  };
  Sk.builtin.getattr = function (a, b, c) {
    Sk.builtin.pyCheckArgs('getattr', arguments, 2, 3);
    if (!Sk.builtin.checkString(b))
      throw new Sk.builtin.TypeError('attribute name must be string');
    var d = a.tp$getattr(b.v);
    if (void 0 === d) {
      if (void 0 !== c)
        return c;
      throw new Sk.builtin.AttributeError('\'' + Sk.abstr.typeName(a) + '\' object has no attribute \'' + b.v + '\'');
    }
    return d;
  };
  Sk.builtin.raw_input = function (a, b, c) {
    a = Sk.inputfun(a.v);
    return new Sk.builtin.str(a);
  };
  Sk.builtin.input = function (a, b, c) {
    a = Sk.inputfun(a.v);
    return new Sk.builtin.str(a);
  };
  Sk.builtin.jseval = function (a) {
    goog.global.eval(a);
  };
  Sk.builtin.jsmillis = function () {
    return new Date().valueOf();
  };
  Sk.builtin.superbi = function () {
    throw new Sk.builtin.NotImplementedError('super is not yet implemented, please report your use case as a github issue.');
  };
  Sk.builtin.eval_ = function () {
    throw new Sk.builtin.NotImplementedError('eval is not yet implemented');
  };
  Sk.builtin.map = function (a, b) {
    Sk.builtin.pyCheckArgs('map', arguments, 2);
    a instanceof Sk.builtin.none && (a = {
      func_code: function (a) {
        return a;
      }
    });
    if (2 < arguments.length) {
      var c = [], d = Array.prototype.slice.apply(arguments).slice(1), e;
      for (e in d) {
        if (void 0 === d[e].tp$iter) {
          var f = parseInt(e, 10) + 2;
          throw new Sk.builtin.TypeError('argument ' + f + ' to map() must support iteration');
        }
        d[e] = d[e].tp$iter();
      }
      for (;;) {
        var g = [], h = 0;
        for (e in d)
          f = d[e].tp$iternext(), void 0 === f ? (g.push(Sk.builtin.none.none$), h++) : g.push(f);
        if (h !== d.length)
          c.push(g);
        else
          break;
      }
      b = new Sk.builtin.list(c);
    }
    if (void 0 === b.tp$iter)
      throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(b) + '\' object is not iterable');
    c = [];
    d = b.tp$iter();
    for (f = d.tp$iternext(); void 0 !== f;)
      f instanceof Array || (f = [f]), c.push(a.func_code.apply(this, f)), f = d.tp$iternext();
    return new Sk.builtin.list(c);
  };
  Sk.builtin.reduce = function (a, b, c) {
    Sk.builtin.pyCheckArgs('reduce', arguments, 2, 3);
    var d = b.tp$iter();
    if (void 0 === c && (c = d.tp$iternext(), void 0 === c))
      throw new Sk.builtin.TypeError('reduce() of empty sequence with no initial value');
    for (var e = c, f = d.tp$iternext(); void 0 !== f;)
      e = a.func_code(e, f), f = d.tp$iternext();
    return e;
  };
  Sk.builtin.filter = function (a, b) {
    Sk.builtin.pyCheckArgs('filter', arguments, 2, 2);
    if (void 0 === b.tp$iter)
      throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(b) + '\' object is not iterable');
    a instanceof Sk.builtin.none && (a = {
      func_code: function (a) {
        return Sk.builtin.bool(a);
      }
    });
    var c = function () {
        return [];
      }, d = function (a, b) {
        a.push(b);
        return a;
      }, e = function (a) {
        return new Sk.builtin.list(a);
      };
    b.__class__ === Sk.builtin.str ? (c = function () {
      return new Sk.builtin.str('');
    }, d = function (a, b) {
      return a.sq$concat(b);
    }, e = function (a) {
      return a;
    }) : b.__class__ === Sk.builtin.tuple && (e = function (a) {
      return new Sk.builtin.tuple(a);
    });
    var f = b.tp$iter(), g = f.tp$iternext(), c = c();
    if (void 0 === g)
      return e(c);
    for (; void 0 !== g;)
      Sk.misceval.isTrue(a.func_code(g)) && (c = d(c, g)), g = f.tp$iternext();
    return e(c);
  };
  Sk.builtin.hasattr = function (a, b) {
    Sk.builtin.pyCheckArgs('hasattr', arguments, 2, 2);
    if (!Sk.builtin.checkString(b))
      throw new Sk.builtin.TypeError('hasattr(): attribute name must be string');
    if (a.tp$getattr)
      return a.tp$getattr(b.v) ? !0 : !1;
    throw new Sk.builtin.AttributeError('Object has no tp$getattr method');
  };
  Sk.builtin.pow = function (a, b, c) {
    Sk.builtin.pyCheckArgs('pow', arguments, 2, 3);
    var d = Sk.builtin.asnum$(a), e = Sk.builtin.asnum$(b);
    Sk.builtin.asnum$(c);
    if (!Sk.builtin.checkNumber(a) || !Sk.builtin.checkNumber(b)) {
      if (void 0 === c)
        throw new Sk.builtin.TypeError('unsupported operand type(s) for pow(): \'' + Sk.abstr.typeName(a) + '\' and \'' + Sk.abstr.typeName(b) + '\'');
      throw new Sk.builtin.TypeError('unsupported operand type(s) for pow(): \'' + Sk.abstr.typeName(a) + '\', \'' + Sk.abstr.typeName(b) + '\', \'' + Sk.abstr.typeName(c) + '\'');
    }
    if (0 > d && b.skType === Sk.builtin.nmber.float$)
      throw new Sk.builtin.ValueError('negative number cannot be raised to a fractional power');
    if (void 0 === c)
      return d = Math.pow(d, e), a.skType === Sk.builtin.nmber.float$ || b.skType === Sk.builtin.nmber.float$ || 0 > e ? new Sk.builtin.nmber(d, Sk.builtin.nmber.float$) : a instanceof Sk.builtin.lng || b instanceof Sk.builtin.lng ? new Sk.builtin.lng(d) : new Sk.builtin.nmber(d, Sk.builtin.nmber.int$);
    if (!Sk.builtin.checkInt(a) || !Sk.builtin.checkInt(b) || !Sk.builtin.checkInt(c))
      throw new Sk.builtin.TypeError('pow() 3rd argument not allowed unless all arguments are integers');
    if (0 > e)
      throw new Sk.builtin.TypeError('pow() 2nd argument cannot be negative when 3rd argument specified');
    return a instanceof Sk.builtin.lng || (b instanceof Sk.builtin.lng || c instanceof Sk.builtin.lng) || Infinity === Math.pow(d, e) ? (a = new Sk.builtin.lng(a), a.nb$power(b, c)) : new Sk.builtin.nmber(Math.pow(d, e), Sk.builtin.nmber.int$).nb$remainder(c);
  };
  Sk.builtin.quit = function (a) {
    a = new Sk.builtin.str(a).v;
    throw new Sk.builtin.SystemExit(a);
  };
  Sk.builtin.sorted = function (a, b, c, d) {
    var e;
    if (void 0 === c || c instanceof Sk.builtin.none)
      b instanceof Sk.builtin.none || void 0 === b || (e = b), a = new Sk.builtin.list(a);
    else {
      e = b instanceof Sk.builtin.none ? {
        func_code: function (a, b) {
          return Sk.misceval.richCompareBool(a[0], b[0], 'Lt') ? new Sk.builtin.nmber(-1, Sk.builtin.nmber.int$) : new Sk.builtin.nmber(0, Sk.builtin.nmber.int$);
        }
      } : {
        func_code: function (a, c) {
          return b.func_code(a[0], c[0]);
        }
      };
      a = a.tp$iter();
      for (var f = a.tp$iternext(), g = []; void 0 !== f;)
        g.push([
          c.func_code(f),
          f
        ]), f = a.tp$iternext();
      a = new Sk.builtin.list(g);
    }
    void 0 !== e ? a.list_sort_(a, e) : a.list_sort_(a);
    d && a.list_reverse_(a);
    if (void 0 !== c && !(c instanceof Sk.builtin.none)) {
      a = a.tp$iter();
      f = a.tp$iternext();
      for (g = []; void 0 !== f;)
        g.push(f[1]), f = a.tp$iternext();
      a = new Sk.builtin.list(g);
    }
    return a;
  };
  Sk.builtin.bytearray = function () {
    throw new Sk.builtin.NotImplementedError('bytearray is not yet implemented');
  };
  Sk.builtin.callable = function () {
    throw new Sk.builtin.NotImplementedError('callable is not yet implemented');
  };
  Sk.builtin.complex = function () {
    throw new Sk.builtin.NotImplementedError('complex is not yet implemented');
  };
  Sk.builtin.delattr = function () {
    throw new Sk.builtin.NotImplementedError('delattr is not yet implemented');
  };
  Sk.builtin.divmod = function () {
    throw new Sk.builtin.NotImplementedError('divmod is not yet implemented');
  };
  Sk.builtin.execfile = function () {
    throw new Sk.builtin.NotImplementedError('execfile is not yet implemented');
  };
  Sk.builtin.format = function () {
    throw new Sk.builtin.NotImplementedError('format is not yet implemented');
  };
  Sk.builtin.frozenset = function () {
    throw new Sk.builtin.NotImplementedError('frozenset is not yet implemented');
  };
  Sk.builtin.globals = function () {
    throw new Sk.builtin.NotImplementedError('globals is not yet implemented');
  };
  Sk.builtin.help = function () {
    throw new Sk.builtin.NotImplementedError('help is not yet implemented');
  };
  Sk.builtin.issubclass = function () {
    throw new Sk.builtin.NotImplementedError('issubclass is not yet implemented');
  };
  Sk.builtin.iter = function () {
    throw new Sk.builtin.NotImplementedError('iter is not yet implemented');
  };
  Sk.builtin.locals = function () {
    throw new Sk.builtin.NotImplementedError('locals is not yet implemented');
  };
  Sk.builtin.memoryview = function () {
    throw new Sk.builtin.NotImplementedError('memoryview is not yet implemented');
  };
  Sk.builtin.next_ = function () {
    throw new Sk.builtin.NotImplementedError('next is not yet implemented');
  };
  Sk.builtin.property = function () {
    throw new Sk.builtin.NotImplementedError('property is not yet implemented');
  };
  Sk.builtin.reload = function () {
    throw new Sk.builtin.NotImplementedError('reload is not yet implemented');
  };
  Sk.builtin.reversed = function () {
    throw new Sk.builtin.NotImplementedError('reversed is not yet implemented');
  };
  Sk.builtin.unichr = function () {
    throw new Sk.builtin.NotImplementedError('unichr is not yet implemented');
  };
  Sk.builtin.vars = function () {
    throw new Sk.builtin.NotImplementedError('vars is not yet implemented');
  };
  Sk.builtin.xrange = Sk.builtin.range;
  Sk.builtin.apply_ = function () {
    throw new Sk.builtin.NotImplementedError('apply is not yet implemented');
  };
  Sk.builtin.buffer = function () {
    throw new Sk.builtin.NotImplementedError('buffer is not yet implemented');
  };
  Sk.builtin.coerce = function () {
    throw new Sk.builtin.NotImplementedError('coerce is not yet implemented');
  };
  Sk.builtin.intern = function () {
    throw new Sk.builtin.NotImplementedError('intern is not yet implemented');
  };
  Sk.builtin.Exception = function (a) {
    a = Array.prototype.slice.call(arguments);
    for (var b = 0; b < a.length; ++b)
      'string' === typeof a[b] && (a[b] = new Sk.builtin.str(a[b]));
    this.args = new Sk.builtin.tuple(a);
    Sk.currFilename ? this.filename = Sk.currFilename : 3 <= this.args.sq$length() ? this.filename = this.args.v[1].v ? this.args.v[1].v : '<unknown>' : this.filename = '<unknown>';
    3 <= this.args.sq$length() ? this.lineno = this.args.v[2] : this.lineno = 0 < Sk.currLineNo ? Sk.currLineNo : '<unknown>';
    this.colno = 0 < Sk.currColNo ? Sk.currColNo : '<unknown>';
  };
  Sk.builtin.Exception.prototype.tp$name = 'Exception';
  Sk.builtin.Exception.prototype.tp$str = function () {
    var a;
    a = '' + this.tp$name;
    this.args && (a += ': ' + (0 < this.args.v.length ? this.args.v[0].v : ''));
    a += ' on line ' + this.lineno;
    if (4 < this.args.v.length) {
      a += '\n' + this.args.v[4].v + '\n';
      for (var b = 0; b < this.args.v[3]; ++b)
        a += ' ';
      a += '^\n';
    }
    return new Sk.builtin.str(a);
  };
  Sk.builtin.Exception.prototype.toString = function () {
    return this.tp$str().v;
  };
  goog.exportSymbol('Sk.builtin.Exception', Sk.builtin.Exception);
  Sk.builtin.AssertionError = function (a) {
    if (!(this instanceof Sk.builtin.AssertionError)) {
      var b = Object.create(Sk.builtin.AssertionError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.AssertionError, Sk.builtin.Exception);
  Sk.builtin.AssertionError.prototype.tp$name = 'AssertionError';
  goog.exportSymbol('Sk.builtin.AssertionError', Sk.builtin.AssertionError);
  Sk.builtin.AttributeError = function (a) {
    if (!(this instanceof Sk.builtin.AttributeError)) {
      var b = Object.create(Sk.builtin.AttributeError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.AttributeError, Sk.builtin.Exception);
  Sk.builtin.AttributeError.prototype.tp$name = 'AttributeError';
  Sk.builtin.ImportError = function (a) {
    if (!(this instanceof Sk.builtin.ImportError)) {
      var b = Object.create(Sk.builtin.ImportError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.ImportError, Sk.builtin.Exception);
  Sk.builtin.ImportError.prototype.tp$name = 'ImportError';
  Sk.builtin.IndentationError = function (a) {
    if (!(this instanceof Sk.builtin.IndentationError)) {
      var b = Object.create(Sk.builtin.IndentationError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.IndentationError, Sk.builtin.Exception);
  Sk.builtin.IndentationError.prototype.tp$name = 'IndentationError';
  Sk.builtin.IndexError = function (a) {
    if (!(this instanceof Sk.builtin.IndexError)) {
      var b = Object.create(Sk.builtin.IndexError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.IndexError, Sk.builtin.Exception);
  Sk.builtin.IndexError.prototype.tp$name = 'IndexError';
  Sk.builtin.KeyError = function (a) {
    if (!(this instanceof Sk.builtin.KeyError)) {
      var b = Object.create(Sk.builtin.KeyError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.KeyError, Sk.builtin.Exception);
  Sk.builtin.KeyError.prototype.tp$name = 'KeyError';
  Sk.builtin.NameError = function (a) {
    if (!(this instanceof Sk.builtin.NameError)) {
      var b = Object.create(Sk.builtin.NameError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.NameError, Sk.builtin.Exception);
  Sk.builtin.NameError.prototype.tp$name = 'NameError';
  Sk.builtin.OverflowError = function (a) {
    if (!(this instanceof Sk.builtin.OverflowError)) {
      var b = Object.create(Sk.builtin.OverflowError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.OverflowError, Sk.builtin.Exception);
  Sk.builtin.OverflowError.prototype.tp$name = 'OverflowError';
  Sk.builtin.ParseError = function (a) {
    if (!(this instanceof Sk.builtin.ParseError)) {
      var b = Object.create(Sk.builtin.ParseError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.ParseError, Sk.builtin.Exception);
  Sk.builtin.ParseError.prototype.tp$name = 'ParseError';
  Sk.builtin.SystemExit = function (a) {
    if (!(this instanceof Sk.builtin.SystemExit)) {
      var b = Object.create(Sk.builtin.SystemExit.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.SystemExit, Sk.builtin.Exception);
  Sk.builtin.SystemExit.prototype.tp$name = 'SystemExit';
  goog.exportSymbol('Sk.builtin.SystemExit', Sk.builtin.SystemExit);
  Sk.builtin.SyntaxError = function (a) {
    if (!(this instanceof Sk.builtin.SyntaxError)) {
      var b = Object.create(Sk.builtin.SyntaxError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.SyntaxError, Sk.builtin.Exception);
  Sk.builtin.SyntaxError.prototype.tp$name = 'SyntaxError';
  Sk.builtin.TokenError = function (a) {
    if (!(this instanceof Sk.builtin.TokenError)) {
      var b = Object.create(Sk.builtin.TokenError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.TokenError, Sk.builtin.Exception);
  Sk.builtin.TokenError.prototype.tp$name = 'TokenError';
  Sk.builtin.TypeError = function (a) {
    if (!(this instanceof Sk.builtin.TypeError)) {
      var b = Object.create(Sk.builtin.TypeError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.TypeError, Sk.builtin.Exception);
  Sk.builtin.TypeError.prototype.tp$name = 'TypeError';
  goog.exportSymbol('Sk.builtin.TypeError', Sk.builtin.TypeError);
  Sk.builtin.ValueError = function (a) {
    if (!(this instanceof Sk.builtin.ValueError)) {
      var b = Object.create(Sk.builtin.ValueError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.ValueError, Sk.builtin.Exception);
  Sk.builtin.ValueError.prototype.tp$name = 'ValueError';
  goog.exportSymbol('Sk.builtin.ValueError', Sk.builtin.ValueError);
  Sk.builtin.ZeroDivisionError = function (a) {
    if (!(this instanceof Sk.builtin.ZeroDivisionError)) {
      var b = Object.create(Sk.builtin.ZeroDivisionError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.ZeroDivisionError, Sk.builtin.Exception);
  Sk.builtin.ZeroDivisionError.prototype.tp$name = 'ZeroDivisionError';
  Sk.builtin.TimeLimitError = function (a) {
    if (!(this instanceof Sk.builtin.TimeLimitError)) {
      var b = Object.create(Sk.builtin.TimeLimitError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.TimeLimitError, Sk.builtin.Exception);
  Sk.builtin.TimeLimitError.prototype.tp$name = 'TimeLimitError';
  goog.exportSymbol('Sk.builtin.TimeLimitError', Sk.builtin.TimeLimitError);
  Sk.builtin.IOError = function (a) {
    if (!(this instanceof Sk.builtin.IOError)) {
      var b = Object.create(Sk.builtin.IOError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.IOError, Sk.builtin.Exception);
  Sk.builtin.IOError.prototype.tp$name = 'IOError';
  goog.exportSymbol('Sk.builtin.IOError', Sk.builtin.IOError);
  Sk.builtin.NotImplementedError = function (a) {
    if (!(this instanceof Sk.builtin.NotImplementedError)) {
      var b = Object.create(Sk.builtin.NotImplementedError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.NotImplementedError, Sk.builtin.Exception);
  Sk.builtin.NotImplementedError.prototype.tp$name = 'NotImplementedError';
  goog.exportSymbol('Sk.builtin.NotImplementedError', Sk.builtin.NotImplementedError);
  Sk.builtin.NegativePowerError = function (a) {
    if (!(this instanceof Sk.builtin.NegativePowerError)) {
      var b = Object.create(Sk.builtin.NegativePowerError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.NegativePowerError, Sk.builtin.Exception);
  Sk.builtin.NegativePowerError.prototype.tp$name = 'NegativePowerError';
  goog.exportSymbol('Sk.builtin.NegativePowerError', Sk.builtin.NegativePowerError);
  Sk.builtin.OperationError = function (a) {
    if (!(this instanceof Sk.builtin.OperationError)) {
      var b = Object.create(Sk.builtin.OperationError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.OperationError, Sk.builtin.Exception);
  Sk.builtin.OperationError.prototype.tp$name = 'OperationError';
  goog.exportSymbol('Sk.builtin.OperationError', Sk.builtin.OperationError);
  Sk.builtin.SystemError = function (a) {
    if (!(this instanceof Sk.builtin.SystemError)) {
      var b = Object.create(Sk.builtin.SystemError.prototype);
      b.constructor.apply(b, arguments);
      return b;
    }
    Sk.builtin.Exception.apply(this, arguments);
  };
  goog.inherits(Sk.builtin.SystemError, Sk.builtin.Exception);
  Sk.builtin.SystemError.prototype.tp$name = 'SystemError';
  goog.exportSymbol('Sk.builtin.SystemError', Sk.builtin.SystemError);
  Sk.currLineNo = -1;
  Sk.currColNo = -1;
  Sk.currFilename = '';
  goog.exportSymbol('Sk', Sk);
  goog.exportProperty(Sk, 'currLineNo', Sk.currLineNo);
  goog.exportProperty(Sk, 'currColNo', Sk.currColNo);
  goog.exportProperty(Sk, 'currFilename', Sk.currFilename);
  Sk.builtin.type = function (a, b, c) {
    if (void 0 === b && void 0 === c)
      return a.constructor === Sk.builtin.nmber ? a.skType === Sk.builtin.nmber.int$ ? Sk.builtin.int_.prototype.ob$type : Sk.builtin.float_.prototype.ob$type : a.ob$type;
    var d = function (a, b, c, e) {
        if (!(this instanceof d))
          return new d(a, b, c, e);
        e = e || [];
        this.$d = new Sk.builtin.dict([]);
        var l = Sk.builtin.type.typeLookup(this.ob$type, '__init__');
        void 0 !== l && (e.unshift(this), Sk.misceval.apply(l, a, b, c, e));
        return this;
      }, e;
    for (e in c)
      d.prototype[e] = c[e], d[e] = c[e];
    d.__class__ = d;
    d.sk$klass = !0;
    d.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
    d.prototype.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;
    d.prototype.tp$descr_get = function () {
      goog.asserts.fail('in type tp$descr_get');
    };
    d.prototype.tp$repr = function () {
      var b = this.tp$getattr('__repr__');
      if (void 0 !== b)
        return Sk.misceval.apply(b, void 0, void 0, void 0, []);
      var b = c.__module__, d = '';
      b && (d = b.v + '.');
      return new Sk.builtin.str('<' + d + a + ' object>');
    };
    d.prototype.tp$str = function () {
      var a = this.tp$getattr('__str__');
      return void 0 !== a ? Sk.misceval.apply(a, void 0, void 0, void 0, []) : this.tp$repr();
    };
    d.prototype.tp$length = function () {
      var a = this.tp$getattr('__len__');
      if (void 0 !== a)
        return Sk.misceval.apply(a, void 0, void 0, void 0, []);
      a = Sk.abstr.typeName(this);
      throw new Sk.builtin.AttributeError(a + ' instance has no attribute \'__len__\'');
    };
    d.prototype.tp$call = function (a, b) {
      var c = this.tp$getattr('__call__');
      if (c)
        return Sk.misceval.apply(c, void 0, void 0, b, a);
      throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(this) + '\' object is not callable');
    };
    d.prototype.tp$iter = function () {
      var a = this.tp$getattr('__iter__'), b = Sk.abstr.typeName(this);
      if (a)
        return Sk.misceval.callsim(a);
      throw new Sk.builtin.TypeError('\'' + b + '\' object is not iterable');
    };
    d.prototype.tp$iternext = function () {
      var a = this.tp$getattr('next');
      goog.asserts.assert(void 0 !== a, 'iter() should have caught this');
      return Sk.misceval.callsim(a);
    };
    d.prototype.tp$getitem = function (a) {
      var b = this.tp$getattr('__getitem__');
      if (void 0 !== b)
        return Sk.misceval.apply(b, void 0, void 0, void 0, [a]);
      throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(this) + '\' object does not support indexing');
    };
    d.prototype.tp$setitem = function (a, b) {
      var c = this.tp$getattr('__setitem__');
      if (void 0 !== c)
        return Sk.misceval.apply(c, void 0, void 0, void 0, [
          a,
          b
        ]);
      throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(this) + '\' object does not support item assignment');
    };
    d.prototype.tp$name = a;
    b && (d.$d = new Sk.builtin.dict([]), d.$d.mp$ass_subscript(Sk.builtin.type.basesStr_, new Sk.builtin.tuple(b)), b = Sk.builtin.type.buildMRO(d), d.$d.mp$ass_subscript(Sk.builtin.type.mroStr_, b), d.tp$mro = b);
    d.prototype.ob$type = d;
    Sk.builtin.type.makeIntoTypeObj(a, d);
    d.tp$setattr = Sk.builtin.type.prototype.tp$setattr;
    return d;
  };
  Sk.builtin.type.makeTypeObj = function (a, b) {
    Sk.builtin.type.makeIntoTypeObj(a, b);
    return b;
  };
  Sk.builtin.type.makeIntoTypeObj = function (a, b) {
    goog.asserts.assert(void 0 !== a);
    goog.asserts.assert(void 0 !== b);
    b.ob$type = Sk.builtin.type;
    b.tp$name = a;
    b.tp$repr = function () {
      var a = b.__module__, d = '';
      a && (d = a.v + '.');
      var e = 'class';
      a || b.sk$klass || (e = 'type');
      return new Sk.builtin.str('<' + e + ' \'' + d + b.tp$name + '\'>');
    };
    b.tp$str = void 0;
    b.tp$getattr = Sk.builtin.type.prototype.tp$getattr;
    b.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;
    b.tp$richcompare = Sk.builtin.type.prototype.tp$richcompare;
    b.sk$type = !0;
    return b;
  };
  Sk.builtin.type.ob$type = Sk.builtin.type;
  Sk.builtin.type.tp$name = 'type';
  Sk.builtin.type.tp$repr = function () {
    return new Sk.builtin.str('<type \'type\'>');
  };
  Sk.builtin.type.prototype.tp$getattr = function (a) {
    var b = Sk.builtin.type.typeLookup(this, a), c;
    void 0 !== b && (null !== b && void 0 !== b.ob$type) && (c = b.ob$type.tp$descr_get);
    if (this.$d && (a = this.$d.mp$lookup(new Sk.builtin.str(a)), void 0 !== a))
      return a;
    if (c)
      return c.call(b, null, this);
    if (void 0 !== b)
      return b;
  };
  Sk.builtin.type.prototype.tp$setattr = function (a, b) {
    this[a] = b;
  };
  Sk.builtin.type.typeLookup = function (a, b) {
    var c = a.tp$mro, d = new Sk.builtin.str(b), e, f;
    if (!c)
      return a.prototype[b];
    for (f = 0; f < c.v.length; ++f) {
      e = c.v[f];
      if (e.hasOwnProperty(b))
        return e[b];
      e = e.$d.mp$lookup(d);
      if (void 0 !== e)
        return e;
    }
  };
  Sk.builtin.type.mroMerge_ = function (a) {
    for (var b = [];;) {
      for (var c = 0; c < a.length; ++c) {
        var d = a[c];
        if (0 !== d.length)
          break;
      }
      if (c === a.length)
        return b;
      for (var e = [], c = 0; c < a.length; ++c)
        if (d = a[c], 0 !== d.length) {
          var d = d[0], f = 0;
          a:
            for (; f < a.length; ++f)
              for (var g = a[f], h = 1; h < g.length; ++h)
                if (g[h] === d)
                  break a;
          f === a.length && e.push(d);
        }
      if (0 === e.length)
        throw new Sk.builtin.TypeError('Inconsistent precedences in type hierarchy');
      e = e[0];
      b.push(e);
      for (c = 0; c < a.length; ++c)
        d = a[c], 0 < d.length && d[0] === e && d.splice(0, 1);
    }
  };
  Sk.builtin.type.buildMRO_ = function (a) {
    var b = [[a]];
    a = a.$d.mp$subscript(Sk.builtin.type.basesStr_);
    for (var c = 0; c < a.v.length; ++c)
      b.push(Sk.builtin.type.buildMRO_(a.v[c]));
    for (var d = [], c = 0; c < a.v.length; ++c)
      d.push(a.v[c]);
    b.push(d);
    return Sk.builtin.type.mroMerge_(b);
  };
  Sk.builtin.type.buildMRO = function (a) {
    return new Sk.builtin.tuple(Sk.builtin.type.buildMRO_(a));
  };
  Sk.builtin.type.prototype.tp$richcompare = function (a, b) {
    if (a.ob$type == Sk.builtin.type && this.tp$repr && a.tp$repr) {
      var c = this.tp$repr(), d = a.tp$repr();
      return c.tp$richcompare(d, b);
    }
  };
  Sk.builtin.object = function () {
    if (!(this instanceof Sk.builtin.object))
      return new Sk.builtin.object();
    this.$d = new Sk.builtin.dict([]);
    return this;
  };
  Sk.builtin.object.prototype.GenericGetAttr = function (a) {
    goog.asserts.assert('string' === typeof a);
    var b = this.ob$type;
    goog.asserts.assert(void 0 !== b, 'object has no ob$type!');
    var b = Sk.builtin.type.typeLookup(b, a), c;
    void 0 !== b && (null !== b && void 0 !== b.ob$type) && (c = b.ob$type.tp$descr_get);
    if (this.$d) {
      var d;
      if (this.$d.mp$lookup)
        d = this.$d.mp$lookup(new Sk.builtin.str(a));
      else if (this.$d.mp$subscript)
        try {
          d = this.$d.mp$subscript(new Sk.builtin.str(a));
        } catch (e) {
          d = void 0;
        }
      else
        'object' === typeof this.$d && (d = this.$d[a]);
      if (void 0 !== d)
        return d;
    }
    if (c)
      return c.call(b, this, this.ob$type);
    if (void 0 !== b)
      return b;
  };
  goog.exportSymbol('Sk.builtin.object.prototype.GenericGetAttr', Sk.builtin.object.prototype.GenericGetAttr);
  Sk.builtin.object.prototype.GenericSetAttr = function (a, b) {
    goog.asserts.assert('string' === typeof a);
    this.$d.mp$ass_subscript ? this.$d.mp$ass_subscript(new Sk.builtin.str(a), b) : 'object' === typeof this.$d && (this.$d[a] = b);
  };
  goog.exportSymbol('Sk.builtin.object.prototype.GenericSetAttr', Sk.builtin.object.prototype.GenericSetAttr);
  Sk.builtin.object.prototype.HashNotImplemented = function () {
    throw new Sk.builtin.TypeError('unhashable type: \'' + Sk.abstr.typeName(this) + '\'');
  };
  Sk.builtin.object.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
  Sk.builtin.object.prototype.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;
  Sk.builtin.object.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('object', Sk.builtin.object);
  Sk.builtin.none = function () {
  };
  Sk.builtin.none.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('NoneType', Sk.builtin.none);
  Sk.builtin.none.prototype.tp$name = 'NoneType';
  Sk.builtin.none.none$ = Object.create(Sk.builtin.none.prototype, {
    v: {
      value: null,
      enumerable: !0
    }
  });
  goog.exportSymbol('Sk.builtin.none', Sk.builtin.none);
  Sk.builtin.bool = function (a) {
    Sk.ffi.checkFunctionArgs('bool', arguments, 1);
    return Sk.misceval.isTrue(a) ? Sk.builtin.bool.true$ : Sk.builtin.bool.false$;
  };
  Sk.builtin.bool.prototype.tp$name = 'bool';
  Sk.builtin.bool.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('bool', Sk.builtin.bool);
  Sk.builtin.bool.true$ = Object.create(Sk.builtin.bool.prototype, {
    v: {
      value: !0,
      enumerable: !0
    }
  });
  Sk.builtin.bool.false$ = Object.create(Sk.builtin.bool.prototype, {
    v: {
      value: !1,
      enumerable: !0
    }
  });
  Sk.builtin.bool.prototype.tp$str = function () {
    return this.v ? new Sk.builtin.str('True') : new Sk.builtin.str('False');
  };
  Sk.builtin.bool.prototype.tp$repr = function () {
    return this.v ? new Sk.builtin.str('True') : new Sk.builtin.str('False');
  };
  goog.exportSymbol('Sk.builtin.bool', Sk.builtin.bool);
  Sk.builtin.pyCheckArgs = function (a, b, c, d, e, f) {
    b = b.length;
    var g = '';
    void 0 === d && (d = Infinity);
    e && (b -= 1);
    f && (b -= 1);
    if (b < c || b > d)
      throw g = (c === d ? a + '() takes exactly ' + c + ' arguments' : b < c ? a + '() takes at least ' + c + ' arguments' : a + '() takes at most ' + d + ' arguments') + (' (' + b + ' given)'), new Sk.builtin.TypeError(g);
  };
  goog.exportSymbol('Sk.builtin.pyCheckArgs', Sk.builtin.pyCheckArgs);
  Sk.builtin.pyCheckType = function (a, b, c) {
    if (!c)
      throw new Sk.builtin.TypeError(a + ' must be a ' + b);
  };
  goog.exportSymbol('Sk.builtin.pyCheckType', Sk.builtin.pyCheckType);
  Sk.builtin.checkSequence = function (a) {
    return null !== a && void 0 !== a.mp$subscript;
  };
  goog.exportSymbol('Sk.builtin.checkSequence', Sk.builtin.checkSequence);
  Sk.builtin.checkIterable = function (a) {
    return null !== a && void 0 !== a.tp$iter;
  };
  goog.exportSymbol('Sk.builtin.checkIterable', Sk.builtin.checkIterable);
  Sk.builtin.checkNumber = function (a) {
    return null !== a && ('number' === typeof a || a instanceof Sk.builtin.nmber || a instanceof Sk.builtin.lng);
  };
  goog.exportSymbol('Sk.builtin.checkNumber', Sk.builtin.checkNumber);
  Sk.builtin.checkInt = function (a) {
    return null !== a && ('number' === typeof a && a === (a | 0) || a instanceof Sk.builtin.nmber && a.skType === Sk.builtin.nmber.int$ || a instanceof Sk.builtin.lng);
  };
  goog.exportSymbol('Sk.builtin.checkInt', Sk.builtin.checkInt);
  Sk.builtin.checkString = function (a) {
    return null !== a && a.__class__ == Sk.builtin.str;
  };
  goog.exportSymbol('Sk.builtin.checkString', Sk.builtin.checkString);
  Sk.builtin.checkClass = function (a) {
    return null !== a && a.sk$type;
  };
  goog.exportSymbol('Sk.builtin.checkClass', Sk.builtin.checkClass);
  Sk.builtin.checkBool = function (a) {
    return a instanceof Sk.builtin.bool;
  };
  goog.exportSymbol('Sk.builtin.checkBool', Sk.builtin.checkBool);
  Sk.builtin.checkFunction = function (a) {
    return null !== a && void 0 !== a.tp$call;
  };
  goog.exportSymbol('Sk.builtin.checkFunction', Sk.builtin.checkFunction);
  Sk.builtin.func = function (a, b, c, d) {
    this.func_code = a;
    this.func_globals = b || null;
    if (void 0 !== d)
      for (var e in d)
        c[e] = d[e];
    this.func_closure = c;
    return this;
  };
  goog.exportSymbol('Sk.builtin.func', Sk.builtin.func);
  Sk.builtin.func.prototype.tp$name = 'function';
  Sk.builtin.func.prototype.tp$descr_get = function (a, b) {
    goog.asserts.assert(void 0 !== a && void 0 !== b);
    return null == a ? this : new Sk.builtin.method(this, a);
  };
  Sk.builtin.func.prototype.tp$call = function (a, b) {
    var c;
    this.func_closure && a.push(this.func_closure);
    c = this.func_code.co_kwargs;
    var d = [];
    if (this.func_code.no_kw && b)
      throw c = this.func_code && this.func_code.co_name && this.func_code.co_name.v || '<native JS>', new Sk.builtin.TypeError(c + '() takes no keyword arguments');
    if (b)
      for (var e = b.length, f = this.func_code.co_varnames, g = f && f.length, h = 0; h < e; h += 2) {
        for (var k = 0; k < g && b[h] !== f[k]; ++k);
        if (f && k !== g)
          a[k] = b[h + 1];
        else if (c)
          d.push(new Sk.builtin.str(b[h])), d.push(b[h + 1]);
        else
          throw c = this.func_code && this.func_code.co_name && this.func_code.co_name.v || '<native JS>', new Sk.builtin.TypeError(c + '() got an unexpected keyword argument \'' + b[h] + '\'');
      }
    c && a.unshift(d);
    return this.func_code.apply(this.func_globals, a);
  };
  Sk.builtin.func.prototype.tp$getattr = function (a) {
    return this[a];
  };
  Sk.builtin.func.prototype.tp$setattr = function (a, b) {
    this[a] = b;
  };
  Sk.builtin.func.prototype.ob$type = Sk.builtin.type.makeTypeObj('function', new Sk.builtin.func(null, null));
  Sk.builtin.func.prototype.tp$repr = function () {
    return new Sk.builtin.str('<function ' + (this.func_code && this.func_code.co_name && this.func_code.co_name.v || '<native JS>') + '>');
  };
  Sk.nativejs = {
    FN_ARGS: /^function\s*[^\(]*\(\s*([^\)]*)\)/m,
    FN_ARG_SPLIT: /,/,
    FN_ARG: /^\s*(_?)(\S+?)\1\s*$/,
    STRIP_COMMENTS: /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm,
    formalParameterList: function (a) {
      var b = [];
      a = a.toString().replace(this.STRIP_COMMENTS, '').match(this.FN_ARGS)[1].split(this.FN_ARG_SPLIT);
      for (var c in a)
        a[c].replace(this.FN_ARG, function (a, c, f) {
          b.push(f);
        });
      return b;
    },
    func: function (a) {
      a.co_name = new Sk.builtin.str(a.name);
      a.co_varnames = Sk.nativejs.formalParameterList(a);
      return new Sk.builtin.func(a);
    },
    func_nokw: function (a) {
      a.co_name = new Sk.builtin.str(a.name);
      a.co_varnames = Sk.nativejs.formalParameterList(a);
      a.no_kw = !0;
      return new Sk.builtin.func(a);
    }
  };
  goog.exportSymbol('Sk.nativejs.func', Sk.nativejs.func);
  goog.exportSymbol('Sk.nativejs.func_nokw', Sk.nativejs.func_nokw);
  Sk.builtin.method = function (a, b) {
    this.im_func = a;
    this.im_self = b;
  };
  goog.exportSymbol('Sk.builtin.method', Sk.builtin.method);
  Sk.builtin.method.prototype.tp$call = function (a, b) {
    goog.asserts.assert(this.im_self, 'should just be a function, not a method since there\'s no self?');
    goog.asserts.assert(this.im_func instanceof Sk.builtin.func);
    a.unshift(this.im_self);
    if (b)
      for (var c = b.length, d = 0; d < c; d += 2) {
        for (var e = this.im_func.func_code.co_varnames, f = e && e.length, g = 0; g < f && b[d] !== e[g]; ++g);
        a[g] = b[d + 1];
      }
    return this.im_func.func_code.apply(this.im_func.func_globals, a);
  };
  Sk.builtin.method.prototype.tp$repr = function () {
    return new Sk.builtin.str('<bound method ' + this.im_self.ob$type.tp$name + '.' + (this.im_func.func_code && this.im_func.func_code.co_name && this.im_func.func_code.co_name.v || '<native JS>') + ' of ' + this.im_self.tp$repr().v + '>');
  };
  Sk.misceval = {};
  Sk.misceval.isIndex = function (a) {
    return null === a || a.constructor === Sk.builtin.lng || a.tp$index || !0 === a || !1 === a ? !0 : Sk.builtin.checkInt(a);
  };
  goog.exportSymbol('Sk.misceval.isIndex', Sk.misceval.isIndex);
  Sk.misceval.asIndex = function (a) {
    if (Sk.misceval.isIndex(a) && null !== a) {
      if (!0 === a)
        return 1;
      if (!1 === a)
        return 0;
      if ('number' === typeof a)
        return a;
      if (a.constructor === Sk.builtin.nmber)
        return a.v;
      if (a.constructor === Sk.builtin.lng)
        return a.tp$index();
      goog.asserts.fail('todo;');
    }
  };
  Sk.misceval.applySlice = function (a, b, c) {
    return a.sq$slice && Sk.misceval.isIndex(b) && Sk.misceval.isIndex(c) ? (b = Sk.misceval.asIndex(b), void 0 === b && (b = 0), c = Sk.misceval.asIndex(c), void 0 === c && (c = 1e+100), Sk.abstr.sequenceGetSlice(a, b, c)) : Sk.abstr.objectGetItem(a, new Sk.builtin.slice(b, c, null));
  };
  goog.exportSymbol('Sk.misceval.applySlice', Sk.misceval.applySlice);
  Sk.misceval.assignSlice = function (a, b, c, d) {
    if (a.sq$ass_slice && Sk.misceval.isIndex(b) && Sk.misceval.isIndex(c))
      b = Sk.misceval.asIndex(b) || 0, c = Sk.misceval.asIndex(c) || 1e+100, null === d ? Sk.abstr.sequenceDelSlice(a, b, c) : Sk.abstr.sequenceSetSlice(a, b, c, d);
    else
      return c = new Sk.builtin.slice(b, c), null === d ? Sk.abstr.objectDelItem(a, c) : Sk.abstr.objectSetItem(a, c, d);
  };
  goog.exportSymbol('Sk.misceval.assignSlice', Sk.misceval.assignSlice);
  Sk.misceval.arrayFromArguments = function (a) {
    if (1 != a.length)
      return a;
    var b = a[0];
    if (b instanceof Sk.builtin.set)
      b = b.tp$iter().$obj;
    else if (b instanceof Sk.builtin.dict)
      b = Sk.builtin.dict.prototype.keys.func_code(b);
    else if (b instanceof Sk.builtin.str) {
      a = [];
      for (var b = b.tp$iter(), c = b.tp$iternext(); void 0 !== c; c = b.tp$iternext())
        a.push(c);
      return a;
    }
    return b instanceof Sk.builtin.list || b instanceof Sk.builtin.tuple ? b.v : a;
  };
  goog.exportSymbol('Sk.misceval.arrayFromArguments', Sk.misceval.arrayFromArguments);
  Sk.misceval.swappedOp_ = {
    Eq: 'Eq',
    NotEq: 'NotEq',
    Lt: 'GtE',
    LtE: 'Gt',
    Gt: 'LtE',
    GtE: 'Lt',
    Is: 'IsNot',
    IsNot: 'Is',
    In_: 'NotIn',
    NotIn: 'In_'
  };
  Sk.misceval.richCompareBool = function (a, b, c) {
    goog.asserts.assert(null !== a && void 0 !== a, 'passed undefined or null parameter to Sk.misceval.richCompareBool');
    goog.asserts.assert(null !== b && void 0 !== b, 'passed undefined or null parameter to Sk.misceval.richCompareBool');
    var d = new Sk.builtin.type(a), e = new Sk.builtin.type(b);
    if (d !== e && ('GtE' === c || 'Gt' === c || 'LtE' === c || 'Lt' === c)) {
      var f = [
          Sk.builtin.float_.prototype.ob$type,
          Sk.builtin.int_.prototype.ob$type,
          Sk.builtin.lng.prototype.ob$type,
          Sk.builtin.bool.prototype.ob$type
        ], g = [
          Sk.builtin.dict.prototype.ob$type,
          Sk.builtin.enumerate.prototype.ob$type,
          Sk.builtin.list.prototype.ob$type,
          Sk.builtin.str.prototype.ob$type,
          Sk.builtin.tuple.prototype.ob$type
        ], h = f.indexOf(d), k = g.indexOf(d), f = f.indexOf(e), g = g.indexOf(e);
      if (d === Sk.builtin.none.prototype.ob$type)
        switch (c) {
        case 'Lt':
          return !0;
        case 'LtE':
          return !0;
        case 'Gt':
          return !1;
        case 'GtE':
          return !1;
        }
      if (e === Sk.builtin.none.prototype.ob$type)
        switch (c) {
        case 'Lt':
          return !1;
        case 'LtE':
          return !1;
        case 'Gt':
          return !0;
        case 'GtE':
          return !0;
        }
      if (-1 !== h && -1 !== g)
        switch (c) {
        case 'Lt':
          return !0;
        case 'LtE':
          return !0;
        case 'Gt':
          return !1;
        case 'GtE':
          return !1;
        }
      if (-1 !== k && -1 !== f)
        switch (c) {
        case 'Lt':
          return !1;
        case 'LtE':
          return !1;
        case 'Gt':
          return !0;
        case 'GtE':
          return !0;
        }
      if (-1 !== k && -1 !== g)
        switch (c) {
        case 'Lt':
          return k < g;
        case 'LtE':
          return k <= g;
        case 'Gt':
          return k > g;
        case 'GtE':
          return k >= g;
        }
    }
    if ('Is' === c)
      return a instanceof Sk.builtin.nmber && b instanceof Sk.builtin.nmber ? 0 === a.numberCompare(b) && a.skType === b.skType : a instanceof Sk.builtin.lng && b instanceof Sk.builtin.lng ? 0 === a.longCompare(b) : a === b;
    if ('IsNot' === c)
      return a instanceof Sk.builtin.nmber && b instanceof Sk.builtin.nmber ? 0 !== a.numberCompare(b) || a.skType !== b.skType : a instanceof Sk.builtin.lng && b instanceof Sk.builtin.lng ? 0 !== a.longCompare(b) : a !== b;
    if ('In' === c)
      return Sk.abstr.sequenceContains(b, a);
    if ('NotIn' === c)
      return !Sk.abstr.sequenceContains(b, a);
    var l;
    if (a.tp$richcompare && void 0 !== (l = a.tp$richcompare(b, c)) || b.tp$richcompare && void 0 !== (l = b.tp$richcompare(a, Sk.misceval.swappedOp_[c])))
      return l;
    e = {
      Eq: '__eq__',
      NotEq: '__ne__',
      Gt: '__gt__',
      GtE: '__ge__',
      Lt: '__lt__',
      LtE: '__le__'
    };
    d = e[c];
    e = e[Sk.misceval.swappedOp_[c]];
    if (a[d])
      return Sk.misceval.callsim(a[d], a, b);
    if (b[e])
      return Sk.misceval.callsim(b[e], b, a);
    if (a.__cmp__) {
      d = Sk.misceval.callsim(a.__cmp__, a, b);
      d = Sk.builtin.asnum$(d);
      if ('Eq' === c)
        return 0 === d;
      if ('NotEq' === c)
        return 0 !== d;
      if ('Lt' === c)
        return 0 > d;
      if ('Gt' === c)
        return 0 < d;
      if ('LtE' === c)
        return 0 >= d;
      if ('GtE' === c)
        return 0 <= d;
    }
    if (b.__cmp__) {
      d = Sk.misceval.callsim(b.__cmp__, b, a);
      d = Sk.builtin.asnum$(d);
      if ('Eq' === c)
        return 0 === d;
      if ('NotEq' === c)
        return 0 !== d;
      if ('Lt' === c)
        return 0 < d;
      if ('Gt' === c)
        return 0 > d;
      if ('LtE' === c)
        return 0 <= d;
      if ('GtE' === c)
        return 0 >= d;
    }
    if (a instanceof Sk.builtin.none && b instanceof Sk.builtin.none || a instanceof Sk.builtin.bool && b instanceof Sk.builtin.bool) {
      if ('Eq' === c)
        return a.v === b.v;
      if ('NotEq' === c)
        return a.v !== b.v;
      if ('Gt' === c)
        return a.v > b.v;
      if ('GtE' === c)
        return a.v >= b.v;
      if ('Lt' === c)
        return a.v < b.v;
      if ('LtE' === c)
        return a.v <= b.v;
    }
    if ('Eq' === c)
      return a instanceof Sk.builtin.str && b instanceof Sk.builtin.str ? a.v === b.v : a === b;
    if ('NotEq' === c)
      return a instanceof Sk.builtin.str && b instanceof Sk.builtin.str ? a.v !== b.v : a !== b;
    a = Sk.abstr.typeName(a);
    b = Sk.abstr.typeName(b);
    throw new Sk.builtin.ValueError('don\'t know how to compare \'' + a + '\' and \'' + b + '\'');
  };
  goog.exportSymbol('Sk.misceval.richCompareBool', Sk.misceval.richCompareBool);
  Sk.misceval.objectRepr = function (a) {
    goog.asserts.assert(void 0 !== a, 'trying to repr undefined');
    return null === a || a instanceof Sk.builtin.none ? new Sk.builtin.str('None') : !0 === a ? new Sk.builtin.str('True') : !1 === a ? new Sk.builtin.str('False') : 'number' === typeof a ? new Sk.builtin.str('' + a) : a.tp$repr ? a.constructor === Sk.builtin.nmber ? Infinity === a.v ? new Sk.builtin.str('inf') : -Infinity === a.v ? new Sk.builtin.str('-inf') : new Sk.builtin.str('' + a.v) : a.tp$repr() : a.tp$name ? new Sk.builtin.str('<' + a.tp$name + ' object>') : new Sk.builtin.str('<unknown>');
  };
  goog.exportSymbol('Sk.misceval.objectRepr', Sk.misceval.objectRepr);
  Sk.misceval.opAllowsEquality = function (a) {
    switch (a) {
    case 'LtE':
    case 'Eq':
    case 'GtE':
      return !0;
    }
    return !1;
  };
  goog.exportSymbol('Sk.misceval.opAllowsEquality', Sk.misceval.opAllowsEquality);
  Sk.misceval.isTrue = function (a) {
    return !0 === a ? !0 : !1 === a || null === a || a.constructor === Sk.builtin.none ? !1 : a.constructor === Sk.builtin.bool ? a.v : 'number' === typeof a ? 0 !== a : a instanceof Sk.builtin.lng ? a.nb$nonzero() : a.constructor === Sk.builtin.nmber ? 0 !== a.v : a.mp$length ? 0 !== a.mp$length() : a.sq$length ? 0 !== a.sq$length() : !0;
  };
  goog.exportSymbol('Sk.misceval.isTrue', Sk.misceval.isTrue);
  Sk.misceval.softspace_ = !1;
  Sk.misceval.print_ = function (a) {
    Sk.misceval.softspace_ && ('\n' !== a && Sk.output(' '), Sk.misceval.softspace_ = !1);
    a = new Sk.builtin.str(a);
    Sk.output(a.v);
    if (0 === a.v.length || '\n' !== a.v[a.v.length - 1] && '\t' !== a.v[a.v.length - 1] && '\r' !== a.v[a.v.length - 1] || ' ' === a.v[a.v.length - 1])
      Sk.misceval.softspace_ = !0;
  };
  goog.exportSymbol('Sk.misceval.print_', Sk.misceval.print_);
  Sk.misceval.loadname = function (a, b) {
    var c = b[a];
    if (void 0 !== c)
      return c;
    c = Sk.builtins[a];
    if (void 0 !== c)
      return c;
    a = a.replace('_$rw$', '');
    a = a.replace('_$rn$', '');
    throw new Sk.builtin.NameError('name \'' + a + '\' is not defined');
  };
  goog.exportSymbol('Sk.misceval.loadname', Sk.misceval.loadname);
  Sk.misceval.call = function (a, b, c, d, e) {
    e = Array.prototype.slice.call(arguments, 4);
    return Sk.misceval.apply(a, b, c, d, e);
  };
  goog.exportSymbol('Sk.misceval.call', Sk.misceval.call);
  Sk.misceval.callsim = function (a, b) {
    b = Array.prototype.slice.call(arguments, 1);
    return Sk.misceval.apply(a, void 0, void 0, void 0, b);
  };
  goog.exportSymbol('Sk.misceval.callsim', Sk.misceval.callsim);
  Sk.misceval.apply = function (a, b, c, d, e) {
    if (null === a || a instanceof Sk.builtin.none)
      throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(a) + '\' object is not callable');
    if ('function' === typeof a) {
      if (a.sk$klass)
        return a.apply(null, [
          b,
          c,
          d,
          e
        ]);
      if (c) {
        c = c.tp$iter();
        for (var f = c.tp$iternext(); void 0 !== f; f = c.tp$iternext())
          e.push(f);
      }
      b && goog.asserts.fail('kwdict not implemented;');
      goog.asserts.assert(void 0 === d || 0 === d.length);
      return a.apply(null, e);
    }
    var g = a.tp$call;
    if (void 0 !== g) {
      if (c)
        for (c = c.tp$iter(), f = c.tp$iternext(); void 0 !== f; f = c.tp$iternext())
          e.push(f);
      b && goog.asserts.fail('kwdict not implemented;');
      return g.call(a, e, d, b);
    }
    g = a.__call__;
    if (void 0 !== g)
      return e.unshift(a), Sk.misceval.apply(g, d, e, b, c);
    throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(a) + '\' object is not callable');
  };
  goog.exportSymbol('Sk.misceval.apply', Sk.misceval.apply);
  Sk.misceval.buildClass = function (a, b, c, d) {
    var e = Sk.builtin.type, f = {};
    b(a, f, []);
    f.__module__ = a.__name__;
    return Sk.misceval.callsim(e, c, d, f);
  };
  goog.exportSymbol('Sk.misceval.buildClass', Sk.misceval.buildClass);
  Sk.abstr = {};
  Sk.abstr.typeName = function (a) {
    return a instanceof Sk.builtin.nmber ? a.skType : void 0 !== a.tp$name ? a.tp$name : '<invalid type>';
  };
  Sk.abstr.binop_type_error = function (a, b, c) {
    a = Sk.abstr.typeName(a);
    b = Sk.abstr.typeName(b);
    throw new Sk.builtin.TypeError('unsupported operand type(s) for ' + c + ': \'' + a + '\' and \'' + b + '\'');
  };
  Sk.abstr.boNameToSlotFuncLhs_ = function (a, b) {
    if (null !== a)
      switch (b) {
      case 'Add':
        return a.nb$add ? a.nb$add : a.__add__;
      case 'Sub':
        return a.nb$subtract ? a.nb$subtract : a.__sub__;
      case 'Mult':
        return a.nb$multiply ? a.nb$multiply : a.__mul__;
      case 'Div':
        return a.nb$divide ? a.nb$divide : a.__div__;
      case 'FloorDiv':
        return a.nb$floor_divide ? a.nb$floor_divide : a.__floordiv__;
      case 'Mod':
        return a.nb$remainder ? a.nb$remainder : a.__mod__;
      case 'Pow':
        return a.nb$power ? a.nb$power : a.__pow__;
      case 'LShift':
        return a.nb$lshift ? a.nb$lshift : a.__lshift__;
      case 'RShift':
        return a.nb$rshift ? a.nb$rshift : a.__rshift__;
      case 'BitAnd':
        return a.nb$and ? a.nb$and : a.__and__;
      case 'BitXor':
        return a.nb$xor ? a.nb$xor : a.__xor__;
      case 'BitOr':
        return a.nb$or ? a.nb$or : a.__or__;
      }
  };
  Sk.abstr.boNameToSlotFuncRhs_ = function (a, b) {
    if (null !== a)
      switch (b) {
      case 'Add':
        return a.nb$add ? a.nb$add : a.__radd__;
      case 'Sub':
        return a.nb$subtract ? a.nb$subtract : a.__rsub__;
      case 'Mult':
        return a.nb$multiply ? a.nb$multiply : a.__rmul__;
      case 'Div':
        return a.nb$divide ? a.nb$divide : a.__rdiv__;
      case 'FloorDiv':
        return a.nb$floor_divide ? a.nb$floor_divide : a.__rfloordiv__;
      case 'Mod':
        return a.nb$remainder ? a.nb$remainder : a.__rmod__;
      case 'Pow':
        return a.nb$power ? a.nb$power : a.__rpow__;
      case 'LShift':
        return a.nb$lshift ? a.nb$lshift : a.__rlshift__;
      case 'RShift':
        return a.nb$rshift ? a.nb$rshift : a.__rrshift__;
      case 'BitAnd':
        return a.nb$and ? a.nb$and : a.__rand__;
      case 'BitXor':
        return a.nb$xor ? a.nb$xor : a.__rxor__;
      case 'BitOr':
        return a.nb$or ? a.nb$or : a.__ror__;
      }
  };
  Sk.abstr.iboNameToSlotFunc_ = function (a, b) {
    if (null !== a)
      switch (b) {
      case 'Add':
        return a.nb$inplace_add ? a.nb$inplace_add : a.__iadd__;
      case 'Sub':
        return a.nb$inplace_subtract ? a.nb$inplace_subtract : a.__isub__;
      case 'Mult':
        return a.nb$inplace_multiply ? a.nb$inplace_multiply : a.__imul__;
      case 'Div':
        return a.nb$inplace_divide ? a.nb$inplace_divide : a.__idiv__;
      case 'FloorDiv':
        return a.nb$inplace_floor_divide ? a.nb$inplace_floor_divide : a.__ifloordiv__;
      case 'Mod':
        return a.nb$inplace_remainder;
      case 'Pow':
        return a.nb$inplace_power;
      case 'LShift':
        return a.nb$inplace_lshift ? a.nb$inplace_lshift : a.__ilshift__;
      case 'RShift':
        return a.nb$inplace_rshift ? a.nb$inplace_rshift : a.__irshift__;
      case 'BitAnd':
        return a.nb$inplace_and;
      case 'BitOr':
        return a.nb$inplace_or;
      case 'BitXor':
        return a.nb$inplace_xor ? a.nb$inplace_xor : a.__ixor__;
      }
  };
  Sk.abstr.binary_op_ = function (a, b, c) {
    var d;
    d = Sk.abstr.boNameToSlotFuncLhs_(a, c);
    if (void 0 !== d && (d = d.call ? d.call(a, b) : Sk.misceval.callsim(d, a, b), void 0 !== d))
      return d;
    d = Sk.abstr.boNameToSlotFuncRhs_(b, c);
    if (void 0 !== d && (d = d.call ? d.call(b, a) : Sk.misceval.callsim(d, b, a), void 0 !== d))
      return d;
    Sk.abstr.binop_type_error(a, b, c);
  };
  Sk.abstr.binary_iop_ = function (a, b, c) {
    var d;
    d = Sk.abstr.iboNameToSlotFunc_(a, c);
    if (void 0 !== d && (d = d.call ? d.call(a, b) : Sk.misceval.callsim(d, a, b), void 0 !== d))
      return d;
    d = Sk.abstr.iboNameToSlotFunc_(b, c);
    if (void 0 !== d && (d = d.call ? d.call(b, a) : Sk.misceval.callsim(d, b, a), void 0 !== d))
      return d;
    Sk.abstr.binop_type_error(a, b, c);
  };
  Sk.abstr.numOpAndPromote = function (a, b, c) {
    if (null !== a && null !== b) {
      if ('number' === typeof a && 'number' === typeof b)
        return c = c(a, b), (c > Sk.builtin.lng.threshold$ || c < -Sk.builtin.lng.threshold$) && Math.floor(c) === c ? [
          Sk.builtin.lng.fromInt$(a),
          Sk.builtin.lng.fromInt$(b)
        ] : c;
      if (void 0 === a || void 0 === b)
        throw new Sk.builtin.NameError('Undefined variable in expression');
      if (a.constructor === Sk.builtin.lng || a.constructor === Sk.builtin.nmber)
        return [
          a,
          b
        ];
      if ('number' === typeof a)
        return [
          new Sk.builtin.nmber(a, void 0),
          b
        ];
    }
  };
  Sk.abstr.boNumPromote_ = {
    Add: function (a, b) {
      return a + b;
    },
    Sub: function (a, b) {
      return a - b;
    },
    Mult: function (a, b) {
      return a * b;
    },
    Mod: function (a, b) {
      if (0 === b)
        throw new Sk.builtin.ZeroDivisionError('division or modulo by zero');
      var c = a % b;
      return 0 > c * b ? c + b : c;
    },
    Div: function (a, b) {
      if (0 === b)
        throw new Sk.builtin.ZeroDivisionError('division or modulo by zero');
      return a / b;
    },
    FloorDiv: function (a, b) {
      if (0 === b)
        throw new Sk.builtin.ZeroDivisionError('division or modulo by zero');
      return Math.floor(a / b);
    },
    Pow: Math.pow,
    BitAnd: function (a, b) {
      var c = a & b;
      0 > c && (c += 4294967296);
      return c;
    },
    BitOr: function (a, b) {
      var c = a | b;
      0 > c && (c += 4294967296);
      return c;
    },
    BitXor: function (a, b) {
      var c = a ^ b;
      0 > c && (c += 4294967296);
      return c;
    },
    LShift: function (a, b) {
      if (0 > b)
        throw new Sk.builtin.ValueError('negative shift count');
      var c = a << b;
      return c > a ? c : a * Math.pow(2, b);
    },
    RShift: function (a, b) {
      if (0 > b)
        throw new Sk.builtin.ValueError('negative shift count');
      var c = a >> b;
      0 < a && 0 > c && (c &= Math.pow(2, 32 - b) - 1);
      return c;
    }
  };
  Sk.abstr.numberBinOp = function (a, b, c) {
    var d = Sk.abstr.boNumPromote_[c];
    if (void 0 !== d) {
      d = Sk.abstr.numOpAndPromote(a, b, d);
      if ('number' === typeof d)
        return d;
      if (void 0 !== d && d.constructor === Sk.builtin.nmber || void 0 !== d && d.constructor === Sk.builtin.lng)
        return d;
      void 0 !== d && (a = d[0], b = d[1]);
    }
    return Sk.abstr.binary_op_(a, b, c);
  };
  goog.exportSymbol('Sk.abstr.numberBinOp', Sk.abstr.numberBinOp);
  Sk.abstr.numberInplaceBinOp = function (a, b, c) {
    var d = Sk.abstr.boNumPromote_[c];
    if (void 0 !== d) {
      d = Sk.abstr.numOpAndPromote(a, b, d);
      if ('number' === typeof d)
        return d;
      if (void 0 !== d && d.constructor === Sk.builtin.nmber || void 0 !== d && d.constructor === Sk.builtin.lng)
        return d;
      void 0 !== d && (a = d[0], b = d[1]);
    }
    return Sk.abstr.binary_iop_(a, b, c);
  };
  goog.exportSymbol('Sk.abstr.numberInplaceBinOp', Sk.abstr.numberInplaceBinOp);
  Sk.abstr.uboNameToSlotFunc_ = function (a, b) {
    if (null !== a)
      switch (b) {
      case 'USub':
        return a.nb$negative ? a.nb$negative : a.__neg__;
      case 'Invert':
        return a.nb$invert ? a.nb$invert : a.__invert__;
      case 'UAdd':
        return a.nb$positive ? a.nb$positive : a.__pos__;
      default:
        throw new Sk.builtin.AssertionError('7fb8237f-879b-4192-89ce-13ad6fa3b2d8 ' + b);
      }
  };
  Sk.abstr.numberUnaryOp = function (a, b) {
    if ('Not' === b)
      return Sk.misceval.isTrue(a) ? Sk.builtin.bool.false$ : Sk.builtin.bool.true$;
    if (a instanceof Sk.builtin.nmber || a instanceof Sk.builtin.bool) {
      var c = Sk.builtin.asnum$(a);
      if ('USub' === b)
        return new Sk.builtin.nmber(-c, c.skType);
      if ('Invert' === b)
        return new Sk.builtin.nmber(~c, c.skType);
      if ('UAdd' === b)
        return new Sk.builtin.nmber(c, c.skType);
    } else if (c = Sk.abstr.uboNameToSlotFunc_(a, b), void 0 != c)
      return c.call ? c.call(a) : Sk.misceval.callsim(c, a);
    c = Sk.abstr.typeName(a);
    throw new Sk.builtin.TypeError('unsupported operand type for ' + b + ' \'' + c + '\'');
  };
  goog.exportSymbol('Sk.abstr.numberUnaryOp', Sk.abstr.numberUnaryOp);
  Sk.abstr.fixSeqIndex_ = function (a, b) {
    b = Sk.builtin.asnum$(b);
    0 > b && a.sq$length && (b += a.sq$length());
    return b;
  };
  Sk.abstr.sequenceContains = function (a, b) {
    if (a.sq$contains)
      return a.sq$contains(b);
    var c = Sk.abstr.typeName(a);
    if (!a.tp$iter)
      throw new Sk.builtin.TypeError('argument of type \'' + c + '\' is not iterable');
    for (var c = a.tp$iter(), d = c.tp$iternext(); void 0 !== d; d = c.tp$iternext())
      if (Sk.misceval.richCompareBool(d, b, 'Eq'))
        return !0;
    return !1;
  };
  Sk.abstr.sequenceGetItem = function (a, b) {
    goog.asserts.fail();
  };
  Sk.abstr.sequenceSetItem = function (a, b, c) {
    goog.asserts.fail();
  };
  Sk.abstr.sequenceDelItem = function (a, b) {
    if (a.sq$del_item)
      b = Sk.abstr.fixSeqIndex_(a, b), a.sq$del_item(b);
    else {
      var c = Sk.abstr.typeName(a);
      throw new Sk.builtin.TypeError('\'' + c + '\' object does not support item deletion');
    }
  };
  Sk.abstr.sequenceRepeat = function (a, b, c) {
    c = Sk.builtin.asnum$(c);
    if (void 0 === Sk.misceval.asIndex(c))
      throw a = Sk.abstr.typeName(c), new Sk.builtin.TypeError('can\'t multiply sequence by non-int of type \'' + a + '\'');
    return a.call(b, c);
  };
  Sk.abstr.sequenceGetSlice = function (a, b, c) {
    if (a.sq$slice)
      return b = Sk.abstr.fixSeqIndex_(a, b), c = Sk.abstr.fixSeqIndex_(a, c), a.sq$slice(b, c);
    if (a.mp$subscript)
      return a.mp$subscript(new Sk.builtin.slice(b, c));
    a = Sk.abstr.typeName(a);
    throw new Sk.builtin.TypeError('\'' + a + '\' object is unsliceable');
  };
  Sk.abstr.sequenceDelSlice = function (a, b, c) {
    if (a.sq$del_slice)
      b = Sk.abstr.fixSeqIndex_(a, b), c = Sk.abstr.fixSeqIndex_(a, c), a.sq$del_slice(b, c);
    else
      throw a = Sk.abstr.typeName(a), new Sk.builtin.TypeError('\'' + a + '\' doesn\'t support slice deletion');
  };
  Sk.abstr.sequenceSetSlice = function (a, b, c, d) {
    if (a.sq$ass_slice)
      b = Sk.abstr.fixSeqIndex_(a, b), c = Sk.abstr.fixSeqIndex_(a, c), a.sq$ass_slice(b, c, d);
    else if (a.mp$ass_subscript)
      a.mp$ass_subscript(new Sk.builtin.slice(b, c), d);
    else
      throw a = Sk.abstr.typeName(a), new Sk.builtin.TypeError('\'' + a + '\' object doesn\'t support slice assignment');
  };
  Sk.abstr.objectDelItem = function (a, b) {
    if (null !== a) {
      if (a.mp$del_subscript) {
        a.mp$del_subscript(b);
        return;
      }
      if (a.sq$ass_item) {
        var c = Sk.misceval.asIndex(b);
        if (void 0 === c)
          throw c = Sk.abstr.typeName(b), new Sk.builtin.TypeError('sequence index must be integer, not \'' + c + '\'');
        Sk.abstr.sequenceDelItem(a, c);
        return;
      }
    }
    c = Sk.abstr.typeName(a);
    throw new Sk.builtin.TypeError('\'' + c + '\' object does not support item deletion');
  };
  goog.exportSymbol('Sk.abstr.objectDelItem', Sk.abstr.objectDelItem);
  Sk.abstr.objectGetItem = function (a, b) {
    if (null !== a) {
      if (a.mp$subscript)
        return a.mp$subscript(b);
      if (Sk.misceval.isIndex(b) && a.sq$item)
        return Sk.abstr.sequenceGetItem(a, Sk.misceval.asIndex(b));
      if (a.tp$getitem)
        return a.tp$getitem(b);
    }
    var c = Sk.abstr.typeName(a);
    throw new Sk.builtin.TypeError('\'' + c + '\' does not support indexing');
  };
  goog.exportSymbol('Sk.abstr.objectGetItem', Sk.abstr.objectGetItem);
  Sk.abstr.objectSetItem = function (a, b, c) {
    if (null !== a) {
      if (a.mp$ass_subscript)
        return a.mp$ass_subscript(b, c);
      if (Sk.misceval.isIndex(b) && a.sq$ass_item)
        return Sk.abstr.sequenceSetItem(a, Sk.misceval.asIndex(b), c);
      if (a.tp$setitem)
        return a.tp$setitem(b, c);
    }
    a = Sk.abstr.typeName(a);
    throw new Sk.builtin.TypeError('\'' + a + '\' does not support item assignment');
  };
  goog.exportSymbol('Sk.abstr.objectSetItem', Sk.abstr.objectSetItem);
  Sk.abstr.gattr = function (a, b) {
    var c = Sk.abstr.typeName(a);
    if (null === a)
      throw new Sk.builtin.AttributeError('\'' + c + '\' object has no attribute \'' + b + '\'');
    var d = void 0;
    a.__getattr__ ? d = Sk.misceval.callsim(a.__getattr__, a, b) : void 0 !== a.tp$getattr && (d = a.tp$getattr(b));
    if (void 0 === d)
      throw new Sk.builtin.AttributeError('\'' + c + '\' object has no attribute \'' + b + '\'');
    return d;
  };
  goog.exportSymbol('Sk.abstr.gattr', Sk.abstr.gattr);
  Sk.abstr.sattr = function (a, b, c) {
    var d = Sk.abstr.typeName(a);
    if (null === a)
      throw new Sk.builtin.AttributeError('\'' + d + '\' object has no attribute \'' + b + '\'');
    if (a.__setattr__)
      Sk.misceval.callsim(a.__setattr__, a, b, c);
    else if (void 0 !== a.tp$setattr)
      a.tp$setattr(b, c);
    else
      throw new Sk.builtin.AttributeError('\'' + d + '\' object has no attribute \'' + b + '\'');
  };
  goog.exportSymbol('Sk.abstr.sattr', Sk.abstr.sattr);
  Sk.abstr.iter = function (a) {
    if (a.tp$iter)
      return a.tp$iter();
    throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(a) + '\' object is not iterable');
  };
  goog.exportSymbol('Sk.abstr.iter', Sk.abstr.iter);
  Sk.abstr.iternext = function (a) {
    return a.tp$iternext();
  };
  goog.exportSymbol('Sk.abstr.iternext', Sk.abstr.iternext);
  Sk.mergeSort = function (a, b, c, d) {
    Sk.quickSort(a, b, c, d);
  };
  Sk.quickSort = function (a, b, c, d) {
    goog.asserts.assert(!c, 'todo;');
    b || (b = Sk.mergeSort.stdCmp);
    var e = function (a, c, d, k) {
      if (d - 1 > c) {
        var l = c + Math.floor(Math.random() * (d - c)), m, n = a[l];
        m = a[l];
        a[l] = a[d - 1];
        a[d - 1] = m;
        var l = c, p;
        for (p = c; p < d - 1; ++p)
          m = k ? Sk.misceval.callsim(b, n, a[p]) : Sk.misceval.callsim(b, a[p], n), 0 > Sk.builtin.asnum$(m) && (m = a[l], a[l] = a[p], a[p] = m, ++l);
        m = a[d - 1];
        a[d - 1] = a[l];
        a[l] = m;
        e(a, c, l, k);
        e(a, l + 1, d, k);
      }
    };
    e(a, 0, a.length, d);
    return null;
  };
  Sk.mergeSort.stdCmp = new Sk.builtin.func(function (a, b) {
    return Sk.misceval.richCompareBool(a, b, 'Lt') ? -1 : 0;
  });
  Sk.builtin.list = function (a) {
    if (!(this instanceof Sk.builtin.list))
      return new Sk.builtin.list(a);
    if (void 0 === a)
      this.v = [];
    else if ('[object Array]' === Object.prototype.toString.apply(a))
      this.v = a;
    else if (a.tp$iter) {
      this.v = [];
      a = a.tp$iter();
      for (var b = a.tp$iternext(); void 0 !== b; b = a.tp$iternext())
        this.v.push(b);
    } else
      throw new Sk.builtin.ValueError('expecting Array or iterable');
    this.__class__ = Sk.builtin.list;
    this.v = this.v;
    return this;
  };
  Sk.builtin.list.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('list', Sk.builtin.list);
  Sk.builtin.list.prototype.list_iter_ = function () {
    var a = {
        tp$iter: function () {
          return a;
        },
        $obj: this,
        $index: 0,
        tp$iternext: function () {
          return a.$index >= a.$obj.v.length ? void 0 : a.$obj.v[a.$index++];
        }
      };
    return a;
  };
  Sk.builtin.list.prototype.list_concat_ = function (a) {
    if (!a.__class__ || a.__class__ != Sk.builtin.list)
      throw new Sk.builtin.TypeError('can only concatenate list to list');
    for (var b = this.v.slice(), c = 0; c < a.v.length; ++c)
      b.push(a.v[c]);
    return new Sk.builtin.list(b);
  };
  Sk.builtin.list.prototype.list_del_item_ = function (a) {
    a = Sk.builtin.asnum$(a);
    if (0 > a || a >= this.v.length)
      throw new Sk.builtin.IndexError('list assignment index out of range');
    this.list_del_slice_(a, a + 1);
  };
  Sk.builtin.list.prototype.list_del_slice_ = function (a, b) {
    a = Sk.builtin.asnum$(a);
    b = Sk.builtin.asnum$(b);
    var c = [];
    c.unshift(b - a);
    c.unshift(a);
    this.v.splice.apply(this.v, c);
  };
  Sk.builtin.list.prototype.list_ass_item_ = function (a, b) {
    a = Sk.builtin.asnum$(a);
    if (0 > a || a >= this.v.length)
      throw new Sk.builtin.IndexError('list assignment index out of range');
    this.v[a] = b;
  };
  Sk.builtin.list.prototype.list_ass_slice_ = function (a, b, c) {
    a = Sk.builtin.asnum$(a);
    b = Sk.builtin.asnum$(b);
    c = c.v.slice(0);
    c.unshift(b - a);
    c.unshift(a);
    this.v.splice.apply(this.v, c);
  };
  Sk.builtin.list.prototype.tp$name = 'list';
  Sk.builtin.list.prototype.tp$repr = function () {
    for (var a = [], b = this.tp$iter(), c = b.tp$iternext(); void 0 !== c; c = b.tp$iternext())
      a.push(Sk.misceval.objectRepr(c).v);
    return new Sk.builtin.str('[' + a.join(', ') + ']');
  };
  Sk.builtin.list.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
  Sk.builtin.list.prototype.tp$hash = Sk.builtin.object.prototype.HashNotImplemented;
  Sk.builtin.list.prototype.tp$richcompare = function (a, b) {
    if (this === a && Sk.misceval.opAllowsEquality(b))
      return !0;
    if (!a.__class__ || a.__class__ != Sk.builtin.list)
      return 'Eq' === b ? !1 : 'NotEq' === b ? !0 : !1;
    var c = this.v;
    a = a.v;
    var d = c.length, e = a.length, f;
    for (f = 0; f < d && f < e && Sk.misceval.richCompareBool(c[f], a[f], 'Eq'); ++f);
    if (f >= d || f >= e)
      switch (b) {
      case 'Lt':
        return d < e;
      case 'LtE':
        return d <= e;
      case 'Eq':
        return d === e;
      case 'NotEq':
        return d !== e;
      case 'Gt':
        return d > e;
      case 'GtE':
        return d >= e;
      default:
        goog.asserts.fail();
      }
    return 'Eq' === b ? !1 : 'NotEq' === b ? !0 : Sk.misceval.richCompareBool(c[f], a[f], b);
  };
  Sk.builtin.list.prototype.tp$iter = Sk.builtin.list.prototype.list_iter_;
  Sk.builtin.list.prototype.sq$length = function () {
    return this.v.length;
  };
  Sk.builtin.list.prototype.sq$concat = Sk.builtin.list.prototype.list_concat_;
  Sk.builtin.list.prototype.nb$add = Sk.builtin.list.prototype.list_concat_;
  Sk.builtin.list.prototype.nb$inplace_add = Sk.builtin.list.prototype.list_concat_;
  Sk.builtin.list.prototype.sq$repeat = function (a) {
    a = Sk.builtin.asnum$(a);
    for (var b = [], c = 0; c < a; ++c)
      for (var d = 0; d < this.v.length; ++d)
        b.push(this.v[d]);
    return new Sk.builtin.list(b);
  };
  Sk.builtin.list.prototype.nb$multiply = Sk.builtin.list.prototype.sq$repeat;
  Sk.builtin.list.prototype.nb$inplace_multiply = Sk.builtin.list.prototype.sq$repeat;
  Sk.builtin.list.prototype.sq$ass_item = Sk.builtin.list.prototype.list_ass_item_;
  Sk.builtin.list.prototype.sq$del_item = Sk.builtin.list.prototype.list_del_item_;
  Sk.builtin.list.prototype.sq$ass_slice = Sk.builtin.list.prototype.list_ass_slice_;
  Sk.builtin.list.prototype.sq$del_slice = Sk.builtin.list.prototype.list_del_slice_;
  Sk.builtin.list.prototype.list_subscript_ = function (a) {
    if (Sk.misceval.isIndex(a)) {
      var b = Sk.misceval.asIndex(a);
      if (void 0 !== b) {
        0 > b && (b = this.v.length + b);
        if (0 > b || b >= this.v.length)
          throw new Sk.builtin.IndexError('list index out of range');
        return this.v[b];
      }
    } else if (a instanceof Sk.builtin.slice) {
      var c = [];
      a.sssiter$(this, function (a, b) {
        c.push(b.v[a]);
      });
      return new Sk.builtin.list(c);
    }
    throw new Sk.builtin.TypeError('list indices must be integers, not ' + Sk.abstr.typeName(a));
  };
  Sk.builtin.list.prototype.list_ass_subscript_ = function (a, b) {
    if (Sk.misceval.isIndex(a)) {
      var c = Sk.misceval.asIndex(a);
      if (void 0 !== c) {
        0 > c && (c = this.v.length + c);
        this.list_ass_item_(c, b);
        return;
      }
    } else if (a instanceof Sk.builtin.slice) {
      if (1 === (null !== a.step ? a.step : 1))
        this.list_ass_slice_(a.start, a.stop, b);
      else {
        var d = [];
        a.sssiter$(this, function (a, b) {
          d.push(a);
        });
        var e = 0;
        if (d.length !== b.v.length)
          throw new Sk.builtin.ValueError('attempt to assign sequence of size ' + b.v.length + ' to extended slice of size ' + d.length);
        for (c = 0; c < d.length; ++c)
          this.v.splice(d[c], 1, b.v[e]), e += 1;
      }
      return;
    }
    throw new Sk.builtin.TypeError('list indices must be integers, not ' + Sk.abstr.typeName(a));
  };
  Sk.builtin.list.prototype.list_del_subscript_ = function (a) {
    if (Sk.misceval.isIndex(a)) {
      var b = Sk.misceval.asIndex(a);
      if (void 0 !== b) {
        0 > b && (b = this.v.length + b);
        this.list_del_item_(b);
        return;
      }
    } else if (a instanceof Sk.builtin.slice) {
      if (1 === a.step)
        this.list_del_slice_(a.start, a.stop);
      else {
        var c = this, d = 0, e = 0 < (null === a.step ? 1 : a.step) ? 1 : 0;
        a.sssiter$(this, function (a, b) {
          c.v.splice(a - d, 1);
          d += e;
        });
      }
      return;
    }
    throw new Sk.builtin.TypeError('list indices must be integers, not ' + typeof a);
  };
  Sk.builtin.list.prototype.mp$subscript = Sk.builtin.list.prototype.list_subscript_;
  Sk.builtin.list.prototype.mp$ass_subscript = Sk.builtin.list.prototype.list_ass_subscript_;
  Sk.builtin.list.prototype.mp$del_subscript = Sk.builtin.list.prototype.list_del_subscript_;
  Sk.builtin.list.prototype.__getitem__ = new Sk.builtin.func(function (a, b) {
    return Sk.builtin.list.prototype.list_subscript_.call(a, b);
  });
  Sk.builtin.list.prototype.list_sort_ = function (a, b, c, d) {
    var e = void 0 !== c && null !== c, f = void 0 !== b && null !== b;
    void 0 == d && (d = !1);
    var g = new Sk.builtin.timSort(a);
    a.v = [];
    var h = new Sk.builtin.nmber(0, Sk.builtin.nmber.int$);
    if (e) {
      g.lt = f ? function (a, c) {
        return Sk.misceval.richCompareBool(b.func_code(a[0], c[0]), h, 'Lt');
      } : function (a, b) {
        return Sk.misceval.richCompareBool(a[0], b[0], 'Lt');
      };
      for (var k = 0; k < g.listlength; k++) {
        var f = g.list.v[k], l = c.func_code(f);
        g.list.v[k] = [
          l,
          f
        ];
      }
    } else
      f && (g.lt = function (a, c) {
        return Sk.misceval.richCompareBool(b.func_code(a, c), h, 'Lt');
      });
    d && g.list.list_reverse_(g.list);
    g.sort();
    d && g.list.list_reverse_(g.list);
    if (e)
      for (c = 0; c < g.listlength; c++)
        f = g.list.v[c][1], g.list.v[c] = f;
    c = 0 < a.sq$length();
    a.v = g.list.v;
    if (c)
      throw new Sk.builtin.OperationError('list modified during sort');
  };
  Sk.builtin.list.prototype.list_reverse_ = function (a) {
    Sk.builtin.pyCheckArgs('reverse', arguments, 1, 1);
    for (var b = a.v, c = [], d = a.v.length - 1; -1 < d; --d)
      c.push(b[d]);
    a.v = c;
    return null;
  };
  Sk.builtin.list.prototype.__iter__ = new Sk.builtin.func(function (a) {
    Sk.builtin.pyCheckArgs('__iter__', arguments, 1, 1);
    return a.list_iter_();
  });
  Sk.builtin.list.prototype.append = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('append', arguments, 2, 2);
    a.v.push(b);
    return null;
  });
  Sk.builtin.list.prototype.insert = new Sk.builtin.func(function (a, b, c) {
    Sk.builtin.pyCheckArgs('insert', arguments, 3, 3);
    if (!Sk.builtin.checkNumber(b))
      throw new Sk.builtin.TypeError('an integer is required');
    b = Sk.builtin.asnum$(b);
    0 > b ? b = 0 : b > a.v.length && (b = a.v.length);
    a.v.splice(b, 0, c);
  });
  Sk.builtin.list.prototype.extend = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('extend', arguments, 2, 2);
    if (!Sk.builtin.checkIterable(b))
      throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(b) + '\' object is not iterable');
    if (a == b) {
      for (var c = [], d = b.tp$iter(), e = d.tp$iternext(); void 0 !== e; e = d.tp$iternext())
        c.push(e);
      a.v.push.apply(a.v, c);
      return null;
    }
    d = b.tp$iter();
    for (e = d.tp$iternext(); void 0 !== e; e = d.tp$iternext())
      a.v.push(e);
    return null;
  });
  Sk.builtin.list.prototype.pop = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('pop', arguments, 1, 2);
    void 0 === b && (b = a.v.length - 1);
    if (!Sk.builtin.checkNumber(b))
      throw new Sk.builtin.TypeError('an integer is required');
    b = Sk.builtin.asnum$(b);
    if (0 > b || b >= a.v.length)
      throw new Sk.builtin.IndexError('pop index out of range');
    var c = a.v[b];
    a.v.splice(b, 1);
    return c;
  });
  Sk.builtin.list.prototype.remove = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('remove', arguments, 2, 2);
    var c = Sk.builtin.list.prototype.index.func_code(a, b);
    a.v.splice(c, 1);
    return null;
  });
  Sk.builtin.list.prototype.index = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('index', arguments, 2, 2);
    for (var c = a.v.length, d = a.v, e = 0; e < c; ++e)
      if (Sk.misceval.richCompareBool(d[e], b, 'Eq'))
        return e;
    throw new Sk.builtin.ValueError('list.index(x): x not in list');
  });
  Sk.builtin.list.prototype.count = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('count', arguments, 2, 2);
    for (var c = a.v.length, d = a.v, e = 0, f = 0; f < c; ++f)
      Sk.misceval.richCompareBool(d[f], b, 'Eq') && (e += 1);
    return e;
  });
  Sk.builtin.list.prototype.reverse = new Sk.builtin.func(Sk.builtin.list.prototype.list_reverse_);
  Sk.builtin.list.prototype.sort = new Sk.builtin.func(Sk.builtin.list.prototype.list_sort_);
  Sk.builtin.list.prototype.sort.func_code.co_varnames = [
    '__self__',
    'cmp',
    'key',
    'reverse'
  ];
  goog.exportSymbol('Sk.builtin.list', Sk.builtin.list);
  var interned = {};
  Sk.builtin.str = function (a) {
    void 0 === a && (a = '');
    if (a instanceof Sk.builtin.str && a !== Sk.builtin.str.prototype.ob$type)
      return a;
    if (!(this instanceof Sk.builtin.str))
      return new Sk.builtin.str(a);
    if (!0 === a)
      a = 'True';
    else if (!1 === a)
      a = 'False';
    else if (null === a || a instanceof Sk.builtin.none)
      a = 'None';
    else if (a instanceof Sk.builtin.bool)
      a = a.v ? 'True' : 'False';
    else if ('number' === typeof a)
      a = a.toString(), 'Infinity' === a ? a = 'inf' : '-Infinity' === a && (a = '-inf');
    else if ('string' !== typeof a) {
      if (void 0 !== a.tp$str) {
        a = a.tp$str();
        if (!(a instanceof Sk.builtin.str))
          throw new Sk.builtin.ValueError('__str__ didn\'t return a str');
        return a;
      }
      return Sk.misceval.objectRepr(a);
    }
    if (Object.prototype.hasOwnProperty.call(interned, '1' + a))
      return interned['1' + a];
    this.__class__ = Sk.builtin.str;
    this.v = this.v = a;
    interned['1' + a] = this;
    return this;
  };
  goog.exportSymbol('Sk.builtin.str', Sk.builtin.str);
  Sk.builtin.str.$emptystr = new Sk.builtin.str('');
  Sk.builtin.str.prototype.mp$subscript = function (a) {
    a = Sk.builtin.asnum$(a);
    if ('number' === typeof a && Math.floor(a) === a) {
      0 > a && (a = this.v.length + a);
      if (0 > a || a >= this.v.length)
        throw new Sk.builtin.IndexError('string index out of range');
      return new Sk.builtin.str(this.v.charAt(a));
    }
    if (a instanceof Sk.builtin.slice) {
      var b = '';
      a.sssiter$(this, function (a, d) {
        0 <= a && a < d.v.length && (b += d.v.charAt(a));
      });
      return new Sk.builtin.str(b);
    }
    throw new Sk.builtin.TypeError('string indices must be numbers, not ' + typeof a);
  };
  Sk.builtin.str.prototype.sq$length = function () {
    return this.v.length;
  };
  Sk.builtin.str.prototype.sq$concat = function (a) {
    if (!a || !Sk.builtin.checkString(a))
      throw a = Sk.abstr.typeName(a), new Sk.builtin.TypeError('cannot concatenate \'str\' and \'' + a + '\' objects');
    return new Sk.builtin.str(this.v + a.v);
  };
  Sk.builtin.str.prototype.nb$add = Sk.builtin.str.prototype.sq$concat;
  Sk.builtin.str.prototype.nb$inplace_add = Sk.builtin.str.prototype.sq$concat;
  Sk.builtin.str.prototype.sq$repeat = function (a) {
    a = Sk.builtin.asnum$(a);
    for (var b = '', c = 0; c < a; ++c)
      b += this.v;
    return new Sk.builtin.str(b);
  };
  Sk.builtin.str.prototype.nb$multiply = Sk.builtin.str.prototype.sq$repeat;
  Sk.builtin.str.prototype.nb$inplace_multiply = Sk.builtin.str.prototype.sq$repeat;
  Sk.builtin.str.prototype.sq$item = function () {
    goog.asserts.fail();
  };
  Sk.builtin.str.prototype.sq$slice = function (a, b) {
    a = Sk.builtin.asnum$(a);
    b = Sk.builtin.asnum$(b);
    0 > a && (a = 0);
    return new Sk.builtin.str(this.v.substr(a, b - a));
  };
  Sk.builtin.str.prototype.sq$contains = function (a) {
    if (void 0 === a.v || a.v.constructor != String)
      throw new Sk.builtin.TypeError('TypeError: \'In <string> requires string as left operand');
    return -1 != this.v.indexOf(a.v) ? !0 : !1;
  };
  Sk.builtin.str.prototype.tp$name = 'str';
  Sk.builtin.str.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
  Sk.builtin.str.prototype.tp$iter = function () {
    var a = {
        tp$iter: function () {
          return a;
        },
        $obj: this,
        $index: 0,
        tp$iternext: function () {
          return a.$index >= a.$obj.v.length ? void 0 : new Sk.builtin.str(a.$obj.v.substr(a.$index++, 1));
        }
      };
    return a;
  };
  Sk.builtin.str.prototype.tp$richcompare = function (a, b) {
    if (a instanceof Sk.builtin.str) {
      if (this === a)
        switch (b) {
        case 'Eq':
        case 'LtE':
        case 'GtE':
          return !0;
        case 'NotEq':
        case 'Lt':
        case 'Gt':
          return !1;
        }
      var c = this.v.length, d = a.v.length, e = Math.min(c, d), f = 0;
      if (0 < e)
        for (var g = 0; g < e; ++g) {
          if (this.v[g] != a.v[g]) {
            f = this.v[g].charCodeAt(0) - a.v[g].charCodeAt(0);
            break;
          }
        }
      else
        f = 0;
      0 == f && (f = c < d ? -1 : c > d ? 1 : 0);
      switch (b) {
      case 'Lt':
        return 0 > f;
      case 'LtE':
        return 0 >= f;
      case 'Eq':
        return 0 == f;
      case 'NotEq':
        return 0 != f;
      case 'Gt':
        return 0 < f;
      case 'GtE':
        return 0 <= f;
      default:
        goog.asserts.fail();
      }
    }
  };
  Sk.builtin.str.prototype.tp$repr = function () {
    var a = '\'';
    -1 !== this.v.indexOf('\'') && -1 === this.v.indexOf('"') && (a = '"');
    for (var b = this.v.length, c = a, d = 0; d < b; ++d) {
      var e = this.v.charAt(d);
      e === a || '\\' === e ? c += '\\' + e : '\t' === e ? c += '\\t' : '\n' === e ? c += '\\n' : '\r' === e ? c += '\\r' : ' ' > e || 127 <= e ? (e = e.charCodeAt(0).toString(16), 2 > e.length && (e = '0' + e), c += '\\x' + e) : c += e;
    }
    return new Sk.builtin.str(c + a);
  };
  Sk.builtin.str.re_escape_ = function (a) {
    for (var b = [], c = /^[A-Za-z0-9]+$/, d = 0; d < a.length; ++d) {
      var e = a.charAt(d);
      c.test(e) ? b.push(e) : '\\000' === e ? b.push('\\000') : b.push('\\' + e);
    }
    return b.join('');
  };
  Sk.builtin.str.prototype.lower = new Sk.builtin.func(function (a) {
    Sk.builtin.pyCheckArgs('lower', arguments, 1, 1);
    return new Sk.builtin.str(a.v.toLowerCase());
  });
  Sk.builtin.str.prototype.upper = new Sk.builtin.func(function (a) {
    Sk.builtin.pyCheckArgs('upper', arguments, 1, 1);
    return new Sk.builtin.str(a.v.toUpperCase());
  });
  Sk.builtin.str.prototype.capitalize = new Sk.builtin.func(function (a) {
    Sk.builtin.pyCheckArgs('capitalize', arguments, 1, 1);
    var b = a.v, c, d;
    if (0 === b.length)
      return new Sk.builtin.str('');
    c = b.charAt(0).toUpperCase();
    for (d = 1; d < b.length; d++)
      c += b.charAt(d).toLowerCase();
    return new Sk.builtin.str(c);
  });
  Sk.builtin.str.prototype.join = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('join', arguments, 2, 2);
    Sk.builtin.pyCheckType('seq', 'iterable', Sk.builtin.checkIterable(b));
    for (var c = [], d = b.tp$iter(), e = d.tp$iternext(); void 0 !== e; e = d.tp$iternext()) {
      if (e.constructor !== Sk.builtin.str)
        throw 'TypeError: sequence item ' + c.length + ': expected string, ' + typeof e + ' found';
      c.push(e.v);
    }
    return new Sk.builtin.str(c.join(a.v));
  });
  Sk.builtin.str.prototype.split = new Sk.builtin.func(function (a, b, c) {
    Sk.builtin.pyCheckArgs('split', arguments, 1, 3);
    if (void 0 === b || b instanceof Sk.builtin.none)
      b = null;
    if (null !== b && !Sk.builtin.checkString(b))
      throw new Sk.builtin.TypeError('expected a string');
    if (null !== b && '' === b.v)
      throw new Sk.builtin.ValueError('empty separator');
    if (void 0 !== c && !Sk.builtin.checkInt(c))
      throw new Sk.builtin.TypeError('an integer is required');
    c = Sk.builtin.asnum$(c);
    var d = /[\s]+/g, e = a.v;
    null === b ? e = e.trimLeft() : (d = b.v.replace(/([.*+?=|\\\/()\[\]\{\}^$])/g, '\\$1'), d = RegExp(d, 'g'));
    for (var f = [], g, h = 0, k = 0; null != (g = d.exec(e)) && g.index !== d.lastIndex && !(f.push(new Sk.builtin.str(e.substring(h, g.index))), h = d.lastIndex, k += 1, c && k >= c););
    e = e.substring(h);
    (null !== b || 0 < e.length) && f.push(new Sk.builtin.str(e));
    return new Sk.builtin.list(f);
  });
  Sk.builtin.str.prototype.strip = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('strip', arguments, 1, 2);
    if (void 0 !== b && !Sk.builtin.checkString(b))
      throw new Sk.builtin.TypeError('strip arg must be None or str');
    var c;
    void 0 === b ? c = /^\s+|\s+$/g : (c = Sk.builtin.str.re_escape_(b.v), c = RegExp('^[' + c + ']+|[' + c + ']+$', 'g'));
    return new Sk.builtin.str(a.v.replace(c, ''));
  });
  Sk.builtin.str.prototype.lstrip = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('lstrip', arguments, 1, 2);
    if (void 0 !== b && !Sk.builtin.checkString(b))
      throw new Sk.builtin.TypeError('lstrip arg must be None or str');
    var c;
    void 0 === b ? c = /^\s+/g : (c = Sk.builtin.str.re_escape_(b.v), c = RegExp('^[' + c + ']+', 'g'));
    return new Sk.builtin.str(a.v.replace(c, ''));
  });
  Sk.builtin.str.prototype.rstrip = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('rstrip', arguments, 1, 2);
    if (void 0 !== b && !Sk.builtin.checkString(b))
      throw new Sk.builtin.TypeError('rstrip arg must be None or str');
    var c;
    void 0 === b ? c = /\s+$/g : (c = Sk.builtin.str.re_escape_(b.v), c = RegExp('[' + c + ']+$', 'g'));
    return new Sk.builtin.str(a.v.replace(c, ''));
  });
  Sk.builtin.str.prototype.partition = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('partition', arguments, 2, 2);
    Sk.builtin.pyCheckType('sep', 'string', Sk.builtin.checkString(b));
    var c = new Sk.builtin.str(b), d = a.v.indexOf(c.v);
    return 0 > d ? new Sk.builtin.tuple([
      a,
      Sk.builtin.str.$emptystr,
      Sk.builtin.str.$emptystr
    ]) : new Sk.builtin.tuple([
      new Sk.builtin.str(a.v.substring(0, d)),
      c,
      new Sk.builtin.str(a.v.substring(d + c.v.length))
    ]);
  });
  Sk.builtin.str.prototype.rpartition = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('rpartition', arguments, 2, 2);
    Sk.builtin.pyCheckType('sep', 'string', Sk.builtin.checkString(b));
    var c = new Sk.builtin.str(b), d = a.v.lastIndexOf(c.v);
    return 0 > d ? new Sk.builtin.tuple([
      Sk.builtin.str.$emptystr,
      Sk.builtin.str.$emptystr,
      a
    ]) : new Sk.builtin.tuple([
      new Sk.builtin.str(a.v.substring(0, d)),
      c,
      new Sk.builtin.str(a.v.substring(d + c.v.length))
    ]);
  });
  Sk.builtin.str.prototype.count = new Sk.builtin.func(function (a, b, c, d) {
    Sk.builtin.pyCheckArgs('count', arguments, 2, 4);
    if (!Sk.builtin.checkString(b))
      throw new Sk.builtin.TypeError('expected a character buffer object');
    if (void 0 !== c && !Sk.builtin.checkInt(c))
      throw new Sk.builtin.TypeError('slice indices must be integers or None or have an __index__ method');
    if (void 0 !== d && !Sk.builtin.checkInt(d))
      throw new Sk.builtin.TypeError('slice indices must be integers or None or have an __index__ method');
    void 0 === c ? c = 0 : (c = Sk.builtin.asnum$(c), c = 0 <= c ? c : a.v.length + c);
    void 0 === d ? d = a.v.length : (d = Sk.builtin.asnum$(d), d = 0 <= d ? d : a.v.length + d);
    var e = RegExp(b.v, 'g');
    return (e = a.v.slice(c, d).match(e)) ? e.length : 0;
  });
  Sk.builtin.str.prototype.ljust = new Sk.builtin.func(function (a, b, c) {
    Sk.builtin.pyCheckArgs('ljust', arguments, 2, 3);
    if (!Sk.builtin.checkInt(b))
      throw new Sk.builtin.TypeError('integer argument exepcted, got ' + Sk.abstr.typeName(b));
    if (void 0 !== c && (!Sk.builtin.checkString(c) || 1 !== c.v.length))
      throw new Sk.builtin.TypeError('must be char, not ' + Sk.abstr.typeName(c));
    c = void 0 === c ? ' ' : c.v;
    b = Sk.builtin.asnum$(b);
    if (a.v.length >= b)
      return a;
    var d = Array.prototype.join.call({ length: Math.floor(b - a.v.length) + 1 }, c);
    return new Sk.builtin.str(a.v + d);
  });
  Sk.builtin.str.prototype.rjust = new Sk.builtin.func(function (a, b, c) {
    Sk.builtin.pyCheckArgs('rjust', arguments, 2, 3);
    if (!Sk.builtin.checkInt(b))
      throw new Sk.builtin.TypeError('integer argument exepcted, got ' + Sk.abstr.typeName(b));
    if (void 0 !== c && (!Sk.builtin.checkString(c) || 1 !== c.v.length))
      throw new Sk.builtin.TypeError('must be char, not ' + Sk.abstr.typeName(c));
    c = void 0 === c ? ' ' : c.v;
    b = Sk.builtin.asnum$(b);
    if (a.v.length >= b)
      return a;
    var d = Array.prototype.join.call({ length: Math.floor(b - a.v.length) + 1 }, c);
    return new Sk.builtin.str(d + a.v);
  });
  Sk.builtin.str.prototype.center = new Sk.builtin.func(function (a, b, c) {
    Sk.builtin.pyCheckArgs('center', arguments, 2, 3);
    if (!Sk.builtin.checkInt(b))
      throw new Sk.builtin.TypeError('integer argument exepcted, got ' + Sk.abstr.typeName(b));
    if (void 0 !== c && (!Sk.builtin.checkString(c) || 1 !== c.v.length))
      throw new Sk.builtin.TypeError('must be char, not ' + Sk.abstr.typeName(c));
    c = void 0 === c ? ' ' : c.v;
    b = Sk.builtin.asnum$(b);
    if (a.v.length >= b)
      return a;
    var d = Array.prototype.join.call({ length: Math.floor((b - a.v.length) / 2) + 1 }, c), d = d + a.v + d;
    d.length < b && (d += c);
    return new Sk.builtin.str(d);
  });
  Sk.builtin.str.prototype.find = new Sk.builtin.func(function (a, b, c, d) {
    Sk.builtin.pyCheckArgs('find', arguments, 2, 4);
    if (!Sk.builtin.checkString(b))
      throw new Sk.builtin.TypeError('expected a character buffer object');
    if (void 0 !== c && !Sk.builtin.checkInt(c))
      throw new Sk.builtin.TypeError('slice indices must be integers or None or have an __index__ method');
    if (void 0 !== d && !Sk.builtin.checkInt(d))
      throw new Sk.builtin.TypeError('slice indices must be integers or None or have an __index__ method');
    void 0 === c ? c = 0 : (c = Sk.builtin.asnum$(c), c = 0 <= c ? c : a.v.length + c);
    void 0 === d ? d = a.v.length : (d = Sk.builtin.asnum$(d), d = 0 <= d ? d : a.v.length + d);
    var e = a.v.indexOf(b.v, c);
    return new Sk.builtin.nmber(e >= c && e < d ? e : -1, Sk.builtin.nmber.int$);
  });
  Sk.builtin.str.prototype.index = new Sk.builtin.func(function (a, b, c, d) {
    Sk.builtin.pyCheckArgs('index', arguments, 2, 4);
    var e = Sk.misceval.callsim(a.find, a, b, c, d);
    if (-1 === Sk.builtin.asnum$(e))
      throw new Sk.builtin.ValueError('substring not found');
    return e;
  });
  Sk.builtin.str.prototype.rfind = new Sk.builtin.func(function (a, b, c, d) {
    Sk.builtin.pyCheckArgs('rfind', arguments, 2, 4);
    if (!Sk.builtin.checkString(b))
      throw new Sk.builtin.TypeError('expected a character buffer object');
    if (void 0 !== c && !Sk.builtin.checkInt(c))
      throw new Sk.builtin.TypeError('slice indices must be integers or None or have an __index__ method');
    if (void 0 !== d && !Sk.builtin.checkInt(d))
      throw new Sk.builtin.TypeError('slice indices must be integers or None or have an __index__ method');
    void 0 === c ? c = 0 : (c = Sk.builtin.asnum$(c), c = 0 <= c ? c : a.v.length + c);
    void 0 === d ? d = a.v.length : (d = Sk.builtin.asnum$(d), d = 0 <= d ? d : a.v.length + d);
    var e = a.v.lastIndexOf(b.v, d), e = e !== d ? e : a.v.lastIndexOf(b.v, d - 1);
    return new Sk.builtin.nmber(e >= c && e < d ? e : -1, Sk.builtin.nmber.int$);
  });
  Sk.builtin.str.prototype.rindex = new Sk.builtin.func(function (a, b, c, d) {
    Sk.builtin.pyCheckArgs('rindex', arguments, 2, 4);
    var e = Sk.misceval.callsim(a.rfind, a, b, c, d);
    if (-1 === Sk.builtin.asnum$(e))
      throw new Sk.builtin.ValueError('substring not found');
    return e;
  });
  Sk.builtin.str.prototype.startswith = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('startswith', arguments, 2, 2);
    Sk.builtin.pyCheckType('tgt', 'string', Sk.builtin.checkString(b));
    return Sk.builtin.bool(0 == a.v.indexOf(b.v));
  });
  Sk.builtin.str.prototype.endswith = new Sk.builtin.func(function (a, b) {
    Sk.builtin.pyCheckArgs('endswith', arguments, 2, 2);
    Sk.builtin.pyCheckType('tgt', 'string', Sk.builtin.checkString(b));
    return Sk.builtin.bool(-1 !== a.v.indexOf(b.v, a.v.length - b.v.length));
  });
  Sk.builtin.str.prototype.replace = new Sk.builtin.func(function (a, b, c, d) {
    Sk.builtin.pyCheckArgs('replace', arguments, 3, 4);
    Sk.builtin.pyCheckType('oldS', 'string', Sk.builtin.checkString(b));
    Sk.builtin.pyCheckType('newS', 'string', Sk.builtin.checkString(c));
    if (void 0 !== d && !Sk.builtin.checkInt(d))
      throw new Sk.builtin.TypeError('integer argument expected, got ' + Sk.abstr.typeName(d));
    d = Sk.builtin.asnum$(d);
    var e = RegExp(Sk.builtin.str.re_escape_(b.v), 'g');
    if (void 0 === d || 0 > d)
      return new Sk.builtin.str(a.v.replace(e, c.v));
    var f = 0;
    return new Sk.builtin.str(a.v.replace(e, function (a) {
      f++;
      return f <= d ? c.v : a;
    }));
  });
  Sk.builtin.str.prototype.isdigit = new Sk.builtin.func(function (a) {
    Sk.builtin.pyCheckArgs('isdigit', arguments, 1, 1);
    if (0 === a.v.length)
      return Sk.builtin.bool(!1);
    var b;
    for (b = 0; b < a.v.length; b++) {
      var c = a.v.charAt(b);
      if ('0' > c || '9' < c)
        return Sk.builtin.bool(!1);
    }
    return Sk.builtin.bool(!0);
  });
  Sk.builtin.str.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('str', Sk.builtin.str);
  Sk.builtin.str.prototype.nb$remainder = function (a) {
    a.constructor === Sk.builtin.tuple || void 0 !== a.mp$subscript && a.constructor !== Sk.builtin.str || (a = new Sk.builtin.tuple([a]));
    var b = 0, c = this.v.replace(/%(\([a-zA-Z0-9]+\))?([#0 +\-]+)?(\*|[0-9]+)?(\.(\*|[0-9]+))?[hlL]?([diouxXeEfFgGcrs%])/g, function (c, e, f, g, h, k, l) {
        g = Sk.builtin.asnum$(g);
        h = Sk.builtin.asnum$(h);
        var m;
        if (void 0 === e || '' === e)
          m = b++;
        var n = !1, p = !1, q = !1, s = !1, r = !1;
        f && (-1 !== f.indexOf('-') ? p = !0 : -1 !== f.indexOf('0') && (n = !0), -1 !== f.indexOf('+') ? s = !0 : -1 !== f.indexOf(' ') && (q = !0), r = -1 !== f.indexOf('#'));
        h && (h = parseInt(h.substr(1), 10));
        f = function (a, b) {
          b = Sk.builtin.asnum$(b);
          var c, d, e = !1;
          'number' === typeof a ? (0 > a && (a = -a, e = !0), d = a.toString(b)) : a instanceof Sk.builtin.nmber ? (d = a.str$(b, !1), 2 < d.length && '.0' === d.substr(-2) && (d = d.substr(0, d.length - 2)), e = a.nb$isnegative()) : a instanceof Sk.builtin.lng && (d = a.str$(b, !1), e = a.nb$isnegative());
          goog.asserts.assert(void 0 !== d, 'unhandled number format');
          var f = !1;
          if (h)
            for (c = d.length; c < h; ++c)
              d = '0' + d, f = !0;
          c = '';
          e ? c = '-' : s ? c = '+' + c : q && (c = ' ' + c);
          r && (16 === b ? c += '0x' : 8 !== b || (f || '0' === d) || (c += '0'));
          return [
            c,
            d
          ];
        };
        c = function (a) {
          var b = a[0];
          a = a[1];
          var c;
          if (g)
            if (g = parseInt(g, 10), c = a.length + b.length, n)
              for (; c < g; ++c)
                a = '0' + a;
            else if (p)
              for (; c < g; ++c)
                a += ' ';
            else
              for (; c < g; ++c)
                b = ' ' + b;
          return b + a;
        };
        if (a.constructor === Sk.builtin.tuple)
          e = a.v[m];
        else if (void 0 !== a.mp$subscript)
          e = e.substring(1, e.length - 1), e = a.mp$subscript(new Sk.builtin.str(e));
        else
          throw new Sk.builtin.AttributeError(a.tp$name + ' instance has no attribute \'mp$subscript\'');
        switch (l) {
        case 'd':
        case 'i':
          return c(f(e, 10));
        case 'o':
          return c(f(e, 8));
        case 'x':
          return c(f(e, 16));
        case 'X':
          return c(f(e, 16)).toUpperCase();
        case 'f':
        case 'F':
        case 'e':
        case 'E':
        case 'g':
        case 'G':
          e = Sk.builtin.asnum$(e);
          'string' === typeof e && (e = Number(e));
          if (Infinity === e)
            return 'inf';
          if (-Infinity === e)
            return '-inf';
          if (isNaN(e))
            return 'nan';
          m = [
            'toExponential',
            'toFixed',
            'toPrecision'
          ]['efg'.indexOf(l.toLowerCase())];
          if (void 0 === h || '' === h)
            if ('e' === l || 'E' === l)
              h = 6;
            else if ('f' === l || 'F' === l)
              h = 7;
          e = e[m](h);
          -1 !== 'EFG'.indexOf(l) && (e = e.toUpperCase());
          return c([
            '',
            e
          ]);
        case 'c':
          if ('number' === typeof e)
            return String.fromCharCode(e);
          if (e instanceof Sk.builtin.nmber)
            return String.fromCharCode(e.v);
          if (e instanceof Sk.builtin.lng)
            return String.fromCharCode(e.str$(10, !1)[0]);
          if (e.constructor === Sk.builtin.str)
            return e.v.substr(0, 1);
          throw new Sk.builtin.TypeError('an integer is required');
        case 'r':
          return l = Sk.builtin.repr(e), h ? l.v.substr(0, h) : l.v;
        case 's':
          return l = new Sk.builtin.str(e), h ? l.v.substr(0, h) : l.v;
        case '%':
          return '%';
        }
      });
    return new Sk.builtin.str(c);
  };
  Sk.builtin.tuple = function (a) {
    if (!(this instanceof Sk.builtin.tuple))
      return new Sk.builtin.tuple(a);
    void 0 === a && (a = []);
    if ('[object Array]' === Object.prototype.toString.apply(a))
      this.v = a;
    else if (a.tp$iter) {
      this.v = [];
      a = a.tp$iter();
      for (var b = a.tp$iternext(); void 0 !== b; b = a.tp$iternext())
        this.v.push(b);
    } else
      throw new Sk.builtin.ValueError('expecting Array or iterable');
    this.__class__ = Sk.builtin.tuple;
    this.v = this.v;
    return this;
  };
  Sk.builtin.tuple.prototype.tp$name = 'tuple';
  Sk.builtin.tuple.prototype.tp$repr = function () {
    if (0 === this.v.length)
      return new Sk.builtin.str('()');
    for (var a = [], b = 0; b < this.v.length; ++b)
      a[b] = Sk.misceval.objectRepr(this.v[b]).v;
    a = a.join(', ');
    1 === this.v.length && (a += ',');
    return new Sk.builtin.str('(' + a + ')');
  };
  Sk.builtin.tuple.prototype.mp$subscript = function (a) {
    if (Sk.misceval.isIndex(a)) {
      var b = Sk.misceval.asIndex(a);
      if (void 0 !== b) {
        0 > b && (b = this.v.length + b);
        if (0 > b || b >= this.v.length)
          throw new Sk.builtin.IndexError('tuple index out of range');
        return this.v[b];
      }
    } else if (a instanceof Sk.builtin.slice) {
      var c = [];
      a.sssiter$(this, function (a, b) {
        c.push(b.v[a]);
      });
      return new Sk.builtin.tuple(c);
    }
    throw new Sk.builtin.TypeError('tuple indices must be integers, not ' + Sk.abstr.typeName(a));
  };
  Sk.builtin.tuple.prototype.tp$hash = function () {
    for (var a = 1000003, b = 3430008, c = this.v.length, d = 0; d < c; ++d) {
      var e = Sk.builtin.hash(this.v[d]);
      if (-1 === e)
        return -1;
      b = (b ^ e) * a;
      a += 82520 + c + c;
    }
    b += 97531;
    -1 === b && (b = -2);
    return b;
  };
  Sk.builtin.tuple.prototype.sq$repeat = function (a) {
    a = Sk.builtin.asnum$(a);
    for (var b = [], c = 0; c < a; ++c)
      for (var d = 0; d < this.v.length; ++d)
        b.push(this.v[d]);
    return new Sk.builtin.tuple(b);
  };
  Sk.builtin.tuple.prototype.nb$multiply = Sk.builtin.tuple.prototype.sq$repeat;
  Sk.builtin.tuple.prototype.nb$inplace_multiply = Sk.builtin.tuple.prototype.sq$repeat;
  Sk.builtin.tuple.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('tuple', Sk.builtin.tuple);
  Sk.builtin.tuple.prototype.tp$iter = function () {
    var a = {
        tp$iter: function () {
          return a;
        },
        $obj: this,
        $index: 0,
        tp$iternext: function () {
          return a.$index >= a.$obj.v.length ? void 0 : a.$obj.v[a.$index++];
        }
      };
    return a;
  };
  Sk.builtin.tuple.prototype.__iter__ = new Sk.builtin.func(function (a) {
    Sk.builtin.pyCheckArgs('__iter__', arguments, 1, 1);
    return a.tp$iter();
  });
  Sk.builtin.tuple.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
  Sk.builtin.tuple.prototype.tp$richcompare = function (a, b) {
    if (!a.__class__ || a.__class__ != Sk.builtin.tuple)
      return 'Eq' === b ? !1 : 'NotEq' === b ? !0 : !1;
    var c = this.v;
    a = a.v;
    var d = c.length, e = a.length, f;
    for (f = 0; f < d && f < e && Sk.misceval.richCompareBool(c[f], a[f], 'Eq'); ++f);
    if (f >= d || f >= e)
      switch (b) {
      case 'Lt':
        return d < e;
      case 'LtE':
        return d <= e;
      case 'Eq':
        return d === e;
      case 'NotEq':
        return d !== e;
      case 'Gt':
        return d > e;
      case 'GtE':
        return d >= e;
      default:
        goog.asserts.fail();
      }
    return 'Eq' === b ? !1 : 'NotEq' === b ? !0 : Sk.misceval.richCompareBool(c[f], a[f], b);
  };
  Sk.builtin.tuple.prototype.sq$concat = function (a) {
    return new Sk.builtin.tuple(this.v.concat(a.v));
  };
  Sk.builtin.tuple.prototype.nb$add = Sk.builtin.tuple.prototype.sq$concat;
  Sk.builtin.tuple.prototype.nb$inplace_add = Sk.builtin.tuple.prototype.sq$concat;
  Sk.builtin.tuple.prototype.sq$length = function () {
    return this.v.length;
  };
  Sk.builtin.tuple.prototype.index = new Sk.builtin.func(function (a, b) {
    for (var c = a.v.length, d = a.v, e = 0; e < c; ++e)
      if (Sk.misceval.richCompareBool(d[e], b, 'Eq'))
        return e;
    throw new Sk.builtin.ValueError('tuple.index(x): x not in tuple');
  });
  Sk.builtin.tuple.prototype.count = new Sk.builtin.func(function (a, b) {
    for (var c = a.v.length, d = a.v, e = 0, f = 0; f < c; ++f)
      Sk.misceval.richCompareBool(d[f], b, 'Eq') && (e += 1);
    return e;
  });
  goog.exportSymbol('Sk.builtin.tuple', Sk.builtin.tuple);
  Sk.builtin.dict = function (a) {
    if (!(this instanceof Sk.builtin.dict))
      return new Sk.builtin.dict(a);
    void 0 === a && (a = []);
    this.size = 0;
    if ('[object Array]' === Object.prototype.toString.apply(a))
      for (var b = 0; b < a.length; b += 2)
        this.mp$ass_subscript(a[b], a[b + 1]);
    else if (a instanceof Sk.builtin.dict)
      for (var c = a.tp$iter(), b = c.tp$iternext(); void 0 !== b; b = c.tp$iternext()) {
        var d = a.mp$subscript(b);
        void 0 === d && (d = null);
        this.mp$ass_subscript(b, d);
      }
    else if (a.tp$iter)
      for (c = a.tp$iter(), b = c.tp$iternext(); void 0 !== b; b = c.tp$iternext())
        if (b.mp$subscript)
          this.mp$ass_subscript(b.mp$subscript(0), b.mp$subscript(1));
        else
          throw new Sk.builtin.TypeError('element ' + this.size + ' is not a sequence');
    else
      throw new Sk.builtin.TypeError('object is not iterable');
    this.__class__ = Sk.builtin.dict;
    return this;
  };
  Sk.builtin.dict.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('dict', Sk.builtin.dict);
  var kf = Sk.builtin.hash;
  Sk.builtin.dict.prototype.key$lookup = function (a, b) {
    var c, d, e;
    for (e = 0; e < a.items.length; e++)
      if (c = a.items[e], d = Sk.misceval.richCompareBool(c.lhs, b, 'Eq'))
        return c;
    return null;
  };
  Sk.builtin.dict.prototype.key$pop = function (a, b) {
    var c, d, e;
    for (e = 0; e < a.items.length; e++)
      if (c = a.items[e], d = Sk.misceval.richCompareBool(c.lhs, b, 'Eq'))
        return a.items.splice(e, 1), this.size -= 1, c;
  };
  Sk.builtin.dict.prototype.mp$lookup = function (a) {
    var b = this[kf(a)];
    if (void 0 !== b && (a = this.key$lookup(b, a)))
      return a.rhs;
  };
  Sk.builtin.dict.prototype.mp$subscript = function (a) {
    var b = this.mp$lookup(a);
    if (void 0 !== b)
      return b;
    a = new Sk.builtin.str(a);
    throw new Sk.builtin.KeyError(a.v);
  };
  Sk.builtin.dict.prototype.sq$contains = function (a) {
    return void 0 !== this.mp$lookup(a);
  };
  Sk.builtin.dict.prototype.mp$ass_subscript = function (a, b) {
    var c = kf(a), d = this[c];
    void 0 === d ? (d = {
      $hash: c,
      items: [{
          lhs: a,
          rhs: b
        }]
    }, this[c] = d, this.size += 1) : (c = this.key$lookup(d, a)) ? c.rhs = b : (d.items.push({
      lhs: a,
      rhs: b
    }), this.size += 1);
  };
  Sk.builtin.dict.prototype.mp$del_subscript = function (a) {
    var b = this[kf(a)];
    if (void 0 !== b && (b = this.key$pop(b, a), void 0 !== b))
      return;
    a = new Sk.builtin.str(a);
    throw new Sk.builtin.KeyError(a.v);
  };
  Sk.builtin.dict.prototype.tp$iter = function () {
    var a = [], b;
    for (b in this)
      if (this.hasOwnProperty(b)) {
        var c = this[b];
        if (c && void 0 !== c.$hash)
          for (var d = 0; d < c.items.length; d++)
            a.push(c.items[d].lhs);
      }
    var e = {
        tp$iter: function () {
          return e;
        },
        $obj: this,
        $index: 0,
        $keys: a,
        tp$iternext: function () {
          return e.$index >= e.$keys.length ? void 0 : e.$keys[e.$index++];
        }
      };
    return e;
  };
  Sk.builtin.dict.prototype.__iter__ = new Sk.builtin.func(function (a) {
    Sk.builtin.pyCheckArgs('__iter__', arguments, 1, 1);
    return a.tp$iter();
  });
  Sk.builtin.dict.prototype.tp$repr = function () {
    for (var a = [], b = this.tp$iter(), c = b.tp$iternext(); void 0 !== c; c = b.tp$iternext()) {
      var d = this.mp$subscript(c);
      void 0 === d && (d = null);
      a.push(Sk.misceval.objectRepr(c).v + ': ' + Sk.misceval.objectRepr(d).v);
    }
    return new Sk.builtin.str('{' + a.join(', ') + '}');
  };
  Sk.builtin.dict.prototype.mp$length = function () {
    return this.size;
  };
  Sk.builtin.dict.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
  Sk.builtin.dict.prototype.tp$hash = Sk.builtin.object.prototype.HashNotImplemented;
  Sk.builtin.dict.prototype.tp$richcompare = function (a, b) {
    if (this === a && Sk.misceval.opAllowsEquality(b))
      return !0;
    switch (b) {
    case 'Lt':
      return;
    case 'LtE':
      return;
    case 'Eq':
      break;
    case 'NotEq':
      break;
    case 'Gt':
      return;
    case 'GtE':
      return;
    default:
      goog.asserts.fail();
    }
    if (!(a instanceof Sk.builtin.dict) || this.size !== a.size)
      return 'Eq' === b ? !1 : !0;
    for (var c = this.tp$iter(), d = c.tp$iternext(); void 0 !== d; d = c.tp$iternext()) {
      var e = this.mp$subscript(d), d = a.mp$subscript(d);
      if (!Sk.misceval.richCompareBool(e, d, 'Eq'))
        return 'Eq' === b ? !1 : !0;
    }
    return 'Eq' === b ? !0 : !1;
  };
  Sk.builtin.dict.prototype.get = new Sk.builtin.func(function (a, b, c) {
    void 0 === c && (c = null);
    a = a.mp$lookup(b);
    void 0 === a && (a = c);
    return a;
  });
  Sk.builtin.dict.prototype.has_key = new Sk.builtin.func(function (a, b) {
    return a.sq$contains(b);
  });
  Sk.builtin.dict.prototype.items = new Sk.builtin.func(function (a) {
    for (var b = [], c = a.tp$iter(), d = c.tp$iternext(); void 0 !== d; d = c.tp$iternext()) {
      var e = a.mp$subscript(d);
      void 0 === e && (e = null);
      b.push(new Sk.builtin.tuple([
        d,
        e
      ]));
    }
    return new Sk.builtin.list(b);
  });
  Sk.builtin.dict.prototype.keys = new Sk.builtin.func(function (a) {
    var b = [];
    a = a.tp$iter();
    for (var c = a.tp$iternext(); void 0 !== c; c = a.tp$iternext())
      b.push(c);
    return new Sk.builtin.list(b);
  });
  Sk.builtin.dict.prototype.values = new Sk.builtin.func(function (a) {
    for (var b = [], c = a.tp$iter(), d = c.tp$iternext(); void 0 !== d; d = c.tp$iternext())
      d = a.mp$subscript(d), void 0 === d && (d = null), b.push(d);
    return new Sk.builtin.list(b);
  });
  Sk.builtin.dict.prototype.tp$name = 'dict';
  goog.exportSymbol('Sk.builtin.dict', Sk.builtin.dict);
  Sk.builtin.biginteger = function (a, b, c) {
    null != a && ('number' == typeof a ? this.fromNumber(a, b, c) : null == b && 'string' != typeof a ? this.fromString(a, 256) : this.fromString(a, b));
  };
  Sk.builtin.biginteger.canary = 244837814094590;
  Sk.builtin.biginteger.j_lm = 15715070 == (Sk.builtin.biginteger.canary & 16777215);
  Sk.builtin.biginteger.nbi = function () {
    return new Sk.builtin.biginteger(null);
  };
  Sk.builtin.biginteger.prototype.am1 = function (a, b, c, d, e, f) {
    for (; 0 <= --f;) {
      var g = b * this[a++] + c[d] + e;
      e = Math.floor(g / 67108864);
      c[d++] = g & 67108863;
    }
    return e;
  };
  Sk.builtin.biginteger.prototype.am2 = function (a, b, c, d, e, f) {
    var g = b & 32767;
    for (b >>= 15; 0 <= --f;) {
      var h = this[a] & 32767, k = this[a++] >> 15, l = b * h + k * g, h = g * h + ((l & 32767) << 15) + c[d] + (e & 1073741823);
      e = (h >>> 30) + (l >>> 15) + b * k + (e >>> 30);
      c[d++] = h & 1073741823;
    }
    return e;
  };
  Sk.builtin.biginteger.prototype.am3 = function (a, b, c, d, e, f) {
    var g = b & 16383;
    for (b >>= 14; 0 <= --f;) {
      var h = this[a] & 16383, k = this[a++] >> 14, l = b * h + k * g, h = g * h + ((l & 16383) << 14) + c[d] + e;
      e = (h >> 28) + (l >> 14) + b * k;
      c[d++] = h & 268435455;
    }
    return e;
  };
  Sk.builtin.biginteger.prototype.am = Sk.builtin.biginteger.prototype.am3;
  Sk.builtin.biginteger.dbits = 28;
  Sk.builtin.biginteger.prototype.DB = Sk.builtin.biginteger.dbits;
  Sk.builtin.biginteger.prototype.DM = (1 << Sk.builtin.biginteger.dbits) - 1;
  Sk.builtin.biginteger.prototype.DV = 1 << Sk.builtin.biginteger.dbits;
  Sk.builtin.biginteger.BI_FP = 52;
  Sk.builtin.biginteger.prototype.FV = Math.pow(2, Sk.builtin.biginteger.BI_FP);
  Sk.builtin.biginteger.prototype.F1 = Sk.builtin.biginteger.BI_FP - Sk.builtin.biginteger.dbits;
  Sk.builtin.biginteger.prototype.F2 = 2 * Sk.builtin.biginteger.dbits - Sk.builtin.biginteger.BI_FP;
  Sk.builtin.biginteger.BI_RM = '0123456789abcdefghijklmnopqrstuvwxyz';
  Sk.builtin.biginteger.BI_RC = [];
  var rr, vv;
  rr = 48;
  for (vv = 0; 9 >= vv; ++vv)
    Sk.builtin.biginteger.BI_RC[rr++] = vv;
  rr = 97;
  for (vv = 10; 36 > vv; ++vv)
    Sk.builtin.biginteger.BI_RC[rr++] = vv;
  rr = 65;
  for (vv = 10; 36 > vv; ++vv)
    Sk.builtin.biginteger.BI_RC[rr++] = vv;
  Sk.builtin.biginteger.int2char = function (a) {
    return Sk.builtin.biginteger.BI_RM.charAt(a);
  };
  Sk.builtin.biginteger.intAt = function (a, b) {
    var c = Sk.builtin.biginteger.BI_RC[a.charCodeAt(b)];
    return null == c ? -1 : c;
  };
  Sk.builtin.biginteger.prototype.bnpCopyTo = function (a) {
    for (var b = this.t - 1; 0 <= b; --b)
      a[b] = this[b];
    a.t = this.t;
    a.s = this.s;
  };
  Sk.builtin.biginteger.prototype.bnpFromInt = function (a) {
    this.t = 1;
    this.s = 0 > a ? -1 : 0;
    0 < a ? this[0] = a : -1 > a ? this[0] = a + this.DV : this.t = 0;
  };
  Sk.builtin.biginteger.nbv = function (a) {
    var b = new Sk.builtin.biginteger(null);
    b.bnpFromInt(a);
    return b;
  };
  Sk.builtin.biginteger.prototype.bnpFromString = function (a, b) {
    var c;
    if (16 == b)
      c = 4;
    else if (8 == b)
      c = 3;
    else if (256 == b)
      c = 8;
    else if (2 == b)
      c = 1;
    else if (32 == b)
      c = 5;
    else if (4 == b)
      c = 2;
    else {
      this.fromRadix(a, b);
      return;
    }
    this.s = this.t = 0;
    for (var d = a.length, e = !1, f = 0; 0 <= --d;) {
      var g = 8 == c ? a[d] & 255 : Sk.builtin.biginteger.intAt(a, d);
      0 > g ? '-' == a.charAt(d) && (e = !0) : (e = !1, 0 == f ? this[this.t++] = g : f + c > this.DB ? (this[this.t - 1] |= (g & (1 << this.DB - f) - 1) << f, this[this.t++] = g >> this.DB - f) : this[this.t - 1] |= g << f, f += c, f >= this.DB && (f -= this.DB));
    }
    8 == c && 0 != (a[0] & 128) && (this.s = -1, 0 < f && (this[this.t - 1] |= (1 << this.DB - f) - 1 << f));
    this.clamp();
    e && Sk.builtin.biginteger.ZERO.subTo(this, this);
  };
  Sk.builtin.biginteger.prototype.bnpClamp = function () {
    for (var a = this.s & this.DM; 0 < this.t && this[this.t - 1] == a;)
      --this.t;
  };
  Sk.builtin.biginteger.prototype.bnToString = function (a) {
    if (0 > this.s)
      return '-' + this.negate().toString(a);
    if (16 == a)
      a = 4;
    else if (8 == a)
      a = 3;
    else if (2 == a)
      a = 1;
    else if (32 == a)
      a = 5;
    else if (4 == a)
      a = 2;
    else
      return this.toRadix(a);
    var b = (1 << a) - 1, c, d = !1, e = '', f = this.t, g = this.DB - f * this.DB % a;
    if (0 < f--)
      for (g < this.DB && 0 < (c = this[f] >> g) && (d = !0, e = Sk.builtin.biginteger.int2char(c)); 0 <= f;)
        g < a ? (c = (this[f] & (1 << g) - 1) << a - g, c |= this[--f] >> (g += this.DB - a)) : (c = this[f] >> (g -= a) & b, 0 >= g && (g += this.DB, --f)), 0 < c && (d = !0), d && (e += Sk.builtin.biginteger.int2char(c));
    return d ? e : '0';
  };
  Sk.builtin.biginteger.prototype.bnNegate = function () {
    var a = Sk.builtin.biginteger.nbi();
    Sk.builtin.biginteger.ZERO.subTo(this, a);
    return a;
  };
  Sk.builtin.biginteger.prototype.bnAbs = function () {
    return 0 > this.s ? this.negate() : this;
  };
  Sk.builtin.biginteger.prototype.bnCompareTo = function (a) {
    var b = this.s - a.s;
    if (0 != b)
      return b;
    var c = this.t, b = c - a.t;
    if (0 != b)
      return 0 > this.s ? -b : b;
    for (; 0 <= --c;)
      if (0 != (b = this[c] - a[c]))
        return b;
    return 0;
  };
  Sk.builtin.biginteger.nbits = function (a) {
    var b = 1, c;
    0 != (c = a >>> 16) && (a = c, b += 16);
    0 != (c = a >> 8) && (a = c, b += 8);
    0 != (c = a >> 4) && (a = c, b += 4);
    0 != (c = a >> 2) && (a = c, b += 2);
    0 != a >> 1 && (b += 1);
    return b;
  };
  Sk.builtin.biginteger.prototype.bnBitLength = function () {
    return 0 >= this.t ? 0 : this.DB * (this.t - 1) + Sk.builtin.biginteger.nbits(this[this.t - 1] ^ this.s & this.DM);
  };
  Sk.builtin.biginteger.prototype.bnpDLShiftTo = function (a, b) {
    var c;
    for (c = this.t - 1; 0 <= c; --c)
      b[c + a] = this[c];
    for (c = a - 1; 0 <= c; --c)
      b[c] = 0;
    b.t = this.t + a;
    b.s = this.s;
  };
  Sk.builtin.biginteger.prototype.bnpDRShiftTo = function (a, b) {
    for (var c = a; c < this.t; ++c)
      b[c - a] = this[c];
    b.t = Math.max(this.t - a, 0);
    b.s = this.s;
  };
  Sk.builtin.biginteger.prototype.bnpLShiftTo = function (a, b) {
    var c = a % this.DB, d = this.DB - c, e = (1 << d) - 1, f = Math.floor(a / this.DB), g = this.s << c & this.DM, h;
    for (h = this.t - 1; 0 <= h; --h)
      b[h + f + 1] = this[h] >> d | g, g = (this[h] & e) << c;
    for (h = f - 1; 0 <= h; --h)
      b[h] = 0;
    b[f] = g;
    b.t = this.t + f + 1;
    b.s = this.s;
    b.clamp();
  };
  Sk.builtin.biginteger.prototype.bnpRShiftTo = function (a, b) {
    b.s = this.s;
    var c = Math.floor(a / this.DB);
    if (c >= this.t)
      b.t = 0;
    else {
      var d = a % this.DB, e = this.DB - d, f = (1 << d) - 1;
      b[0] = this[c] >> d;
      for (var g = c + 1; g < this.t; ++g)
        b[g - c - 1] |= (this[g] & f) << e, b[g - c] = this[g] >> d;
      0 < d && (b[this.t - c - 1] |= (this.s & f) << e);
      b.t = this.t - c;
      b.clamp();
    }
  };
  Sk.builtin.biginteger.prototype.bnpSubTo = function (a, b) {
    for (var c = 0, d = 0, e = Math.min(a.t, this.t); c < e;)
      d += this[c] - a[c], b[c++] = d & this.DM, d >>= this.DB;
    if (a.t < this.t) {
      for (d -= a.s; c < this.t;)
        d += this[c], b[c++] = d & this.DM, d >>= this.DB;
      d += this.s;
    } else {
      for (d += this.s; c < a.t;)
        d -= a[c], b[c++] = d & this.DM, d >>= this.DB;
      d -= a.s;
    }
    b.s = 0 > d ? -1 : 0;
    -1 > d ? b[c++] = this.DV + d : 0 < d && (b[c++] = d);
    b.t = c;
    b.clamp();
  };
  Sk.builtin.biginteger.prototype.bnpMultiplyTo = function (a, b) {
    var c = this.abs(), d = a.abs(), e = c.t;
    for (b.t = e + d.t; 0 <= --e;)
      b[e] = 0;
    for (e = 0; e < d.t; ++e)
      b[e + c.t] = c.am(0, d[e], b, e, 0, c.t);
    b.s = 0;
    b.clamp();
    this.s != a.s && Sk.builtin.biginteger.ZERO.subTo(b, b);
  };
  Sk.builtin.biginteger.prototype.bnpSquareTo = function (a) {
    for (var b = this.abs(), c = a.t = 2 * b.t; 0 <= --c;)
      a[c] = 0;
    for (c = 0; c < b.t - 1; ++c) {
      var d = b.am(c, b[c], a, 2 * c, 0, 1);
      (a[c + b.t] += b.am(c + 1, 2 * b[c], a, 2 * c + 1, d, b.t - c - 1)) >= b.DV && (a[c + b.t] -= b.DV, a[c + b.t + 1] = 1);
    }
    0 < a.t && (a[a.t - 1] += b.am(c, b[c], a, 2 * c, 0, 1));
    a.s = 0;
    a.clamp();
  };
  Sk.builtin.biginteger.prototype.bnpDivRemTo = function (a, b, c) {
    var d = a.abs();
    if (!(0 >= d.t)) {
      var e = this.abs();
      if (e.t < d.t)
        null != b && b.fromInt(0), null != c && this.copyTo(c);
      else {
        null == c && (c = Sk.builtin.biginteger.nbi());
        var f = Sk.builtin.biginteger.nbi(), g = this.s;
        a = a.s;
        var h = this.DB - Sk.builtin.biginteger.nbits(d[d.t - 1]);
        0 < h ? (d.lShiftTo(h, f), e.lShiftTo(h, c)) : (d.copyTo(f), e.copyTo(c));
        d = f.t;
        e = f[d - 1];
        if (0 != e) {
          var k = e * (1 << this.F1) + (1 < d ? f[d - 2] >> this.F2 : 0), l = this.FV / k, k = (1 << this.F1) / k, m = 1 << this.F2, n = c.t, p = n - d, q = null == b ? Sk.builtin.biginteger.nbi() : b;
          f.dlShiftTo(p, q);
          0 <= c.compareTo(q) && (c[c.t++] = 1, c.subTo(q, c));
          Sk.builtin.biginteger.ONE.dlShiftTo(d, q);
          for (q.subTo(f, f); f.t < d;)
            f[f.t++] = 0;
          for (; 0 <= --p;) {
            var s = c[--n] == e ? this.DM : Math.floor(c[n] * l + (c[n - 1] + m) * k);
            if ((c[n] += f.am(0, s, c, p, 0, d)) < s)
              for (f.dlShiftTo(p, q), c.subTo(q, c); c[n] < --s;)
                c.subTo(q, c);
          }
          null != b && (c.drShiftTo(d, b), g != a && Sk.builtin.biginteger.ZERO.subTo(b, b));
          c.t = d;
          c.clamp();
          0 < h && c.rShiftTo(h, c);
          0 > g && Sk.builtin.biginteger.ZERO.subTo(c, c);
        }
      }
    }
  };
  Sk.builtin.biginteger.prototype.bnMod = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    this.abs().divRemTo(a, null, b);
    0 > this.s && 0 < b.compareTo(Sk.builtin.biginteger.ZERO) && a.subTo(b, b);
    return b;
  };
  Sk.builtin.biginteger.Classic = function (a) {
    this.m = a;
  };
  Sk.builtin.biginteger.prototype.cConvert = function (a) {
    return 0 > a.s || 0 <= a.compareTo(this.m) ? a.mod(this.m) : a;
  };
  Sk.builtin.biginteger.prototype.cRevert = function (a) {
    return a;
  };
  Sk.builtin.biginteger.prototype.cReduce = function (a) {
    a.divRemTo(this.m, null, a);
  };
  Sk.builtin.biginteger.prototype.cMulTo = function (a, b, c) {
    a.multiplyTo(b, c);
    this.reduce(c);
  };
  Sk.builtin.biginteger.prototype.cSqrTo = function (a, b) {
    a.squareTo(b);
    this.reduce(b);
  };
  Sk.builtin.biginteger.Classic.prototype.convert = Sk.builtin.biginteger.prototype.cConvert;
  Sk.builtin.biginteger.Classic.prototype.revert = Sk.builtin.biginteger.prototype.cRevert;
  Sk.builtin.biginteger.Classic.prototype.reduce = Sk.builtin.biginteger.prototype.cReduce;
  Sk.builtin.biginteger.Classic.prototype.mulTo = Sk.builtin.biginteger.prototype.cMulTo;
  Sk.builtin.biginteger.Classic.prototype.sqrTo = Sk.builtin.biginteger.prototype.cSqrTo;
  Sk.builtin.biginteger.prototype.bnpInvDigit = function () {
    if (1 > this.t)
      return 0;
    var a = this[0];
    if (0 == (a & 1))
      return 0;
    var b = a & 3, b = b * (2 - (a & 15) * b) & 15, b = b * (2 - (a & 255) * b) & 255, b = b * (2 - ((a & 65535) * b & 65535)) & 65535, b = b * (2 - a * b % this.DV) % this.DV;
    return 0 < b ? this.DV - b : -b;
  };
  Sk.builtin.biginteger.Montgomery = function (a) {
    this.m = a;
    this.mp = a.invDigit();
    this.mpl = this.mp & 32767;
    this.mph = this.mp >> 15;
    this.um = (1 << a.DB - 15) - 1;
    this.mt2 = 2 * a.t;
  };
  Sk.builtin.biginteger.prototype.montConvert = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    a.abs().dlShiftTo(this.m.t, b);
    b.divRemTo(this.m, null, b);
    0 > a.s && 0 < b.compareTo(Sk.builtin.biginteger.ZERO) && this.m.subTo(b, b);
    return b;
  };
  Sk.builtin.biginteger.prototype.montRevert = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    a.copyTo(b);
    this.reduce(b);
    return b;
  };
  Sk.builtin.biginteger.prototype.montReduce = function (a) {
    for (; a.t <= this.mt2;)
      a[a.t++] = 0;
    for (var b = 0; b < this.m.t; ++b) {
      var c = a[b] & 32767, d = c * this.mpl + ((c * this.mph + (a[b] >> 15) * this.mpl & this.um) << 15) & a.DM, c = b + this.m.t;
      for (a[c] += this.m.am(0, d, a, b, 0, this.m.t); a[c] >= a.DV;)
        a[c] -= a.DV, a[++c]++;
    }
    a.clamp();
    a.drShiftTo(this.m.t, a);
    0 <= a.compareTo(this.m) && a.subTo(this.m, a);
  };
  Sk.builtin.biginteger.prototype.montSqrTo = function (a, b) {
    a.squareTo(b);
    this.reduce(b);
  };
  Sk.builtin.biginteger.prototype.montMulTo = function (a, b, c) {
    a.multiplyTo(b, c);
    this.reduce(c);
  };
  Sk.builtin.biginteger.Montgomery.prototype.convert = Sk.builtin.biginteger.prototype.montConvert;
  Sk.builtin.biginteger.Montgomery.prototype.revert = Sk.builtin.biginteger.prototype.montRevert;
  Sk.builtin.biginteger.Montgomery.prototype.reduce = Sk.builtin.biginteger.prototype.montReduce;
  Sk.builtin.biginteger.Montgomery.prototype.mulTo = Sk.builtin.biginteger.prototype.montMulTo;
  Sk.builtin.biginteger.Montgomery.prototype.sqrTo = Sk.builtin.biginteger.prototype.montSqrTo;
  Sk.builtin.biginteger.prototype.bnpIsEven = function () {
    return 0 == (0 < this.t ? this[0] & 1 : this.s);
  };
  Sk.builtin.biginteger.prototype.bnpExp = function (a, b) {
    if (4294967295 < a || 1 > a)
      return Sk.builtin.biginteger.ONE;
    var c = Sk.builtin.biginteger.nbi(), d = Sk.builtin.biginteger.nbi(), e = b.convert(this), f = Sk.builtin.biginteger.nbits(a) - 1;
    for (e.copyTo(c); 0 <= --f;)
      if (b.sqrTo(c, d), 0 < (a & 1 << f))
        b.mulTo(d, e, c);
      else
        var g = c, c = d, d = g;
    return b.revert(c);
  };
  Sk.builtin.biginteger.prototype.bnModPowInt = function (a, b) {
    var c;
    c = 256 > a || b.isEven() ? new Sk.builtin.biginteger.Classic(b) : new Sk.builtin.biginteger.Montgomery(b);
    return this.exp(a, c);
  };
  Sk.builtin.biginteger.prototype.copyTo = Sk.builtin.biginteger.prototype.bnpCopyTo;
  Sk.builtin.biginteger.prototype.fromInt = Sk.builtin.biginteger.prototype.bnpFromInt;
  Sk.builtin.biginteger.prototype.fromString = Sk.builtin.biginteger.prototype.bnpFromString;
  Sk.builtin.biginteger.prototype.clamp = Sk.builtin.biginteger.prototype.bnpClamp;
  Sk.builtin.biginteger.prototype.dlShiftTo = Sk.builtin.biginteger.prototype.bnpDLShiftTo;
  Sk.builtin.biginteger.prototype.drShiftTo = Sk.builtin.biginteger.prototype.bnpDRShiftTo;
  Sk.builtin.biginteger.prototype.lShiftTo = Sk.builtin.biginteger.prototype.bnpLShiftTo;
  Sk.builtin.biginteger.prototype.rShiftTo = Sk.builtin.biginteger.prototype.bnpRShiftTo;
  Sk.builtin.biginteger.prototype.subTo = Sk.builtin.biginteger.prototype.bnpSubTo;
  Sk.builtin.biginteger.prototype.multiplyTo = Sk.builtin.biginteger.prototype.bnpMultiplyTo;
  Sk.builtin.biginteger.prototype.squareTo = Sk.builtin.biginteger.prototype.bnpSquareTo;
  Sk.builtin.biginteger.prototype.divRemTo = Sk.builtin.biginteger.prototype.bnpDivRemTo;
  Sk.builtin.biginteger.prototype.invDigit = Sk.builtin.biginteger.prototype.bnpInvDigit;
  Sk.builtin.biginteger.prototype.isEven = Sk.builtin.biginteger.prototype.bnpIsEven;
  Sk.builtin.biginteger.prototype.exp = Sk.builtin.biginteger.prototype.bnpExp;
  Sk.builtin.biginteger.prototype.toString = Sk.builtin.biginteger.prototype.bnToString;
  Sk.builtin.biginteger.prototype.negate = Sk.builtin.biginteger.prototype.bnNegate;
  Sk.builtin.biginteger.prototype.abs = Sk.builtin.biginteger.prototype.bnAbs;
  Sk.builtin.biginteger.prototype.compareTo = Sk.builtin.biginteger.prototype.bnCompareTo;
  Sk.builtin.biginteger.prototype.bitLength = Sk.builtin.biginteger.prototype.bnBitLength;
  Sk.builtin.biginteger.prototype.mod = Sk.builtin.biginteger.prototype.bnMod;
  Sk.builtin.biginteger.prototype.modPowInt = Sk.builtin.biginteger.prototype.bnModPowInt;
  Sk.builtin.biginteger.ZERO = Sk.builtin.biginteger.nbv(0);
  Sk.builtin.biginteger.ONE = Sk.builtin.biginteger.nbv(1);
  Sk.builtin.biginteger.prototype.bnClone = function () {
    var a = Sk.builtin.biginteger.nbi();
    this.copyTo(a);
    return a;
  };
  Sk.builtin.biginteger.prototype.bnIntValue = function () {
    if (0 > this.s) {
      if (1 == this.t)
        return this[0] - this.DV;
      if (0 == this.t)
        return -1;
    } else {
      if (1 == this.t)
        return this[0];
      if (0 == this.t)
        return 0;
    }
    return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
  };
  Sk.builtin.biginteger.prototype.bnByteValue = function () {
    return 0 == this.t ? this.s : this[0] << 24 >> 24;
  };
  Sk.builtin.biginteger.prototype.bnShortValue = function () {
    return 0 == this.t ? this.s : this[0] << 16 >> 16;
  };
  Sk.builtin.biginteger.prototype.bnpChunkSize = function (a) {
    return Math.floor(Math.LN2 * this.DB / Math.log(a));
  };
  Sk.builtin.biginteger.prototype.bnSigNum = function () {
    return 0 > this.s ? -1 : 0 >= this.t || 1 == this.t && 0 >= this[0] ? 0 : 1;
  };
  Sk.builtin.biginteger.prototype.bnpToRadix = function (a) {
    null == a && (a = 10);
    if (0 == this.signum() || 2 > a || 36 < a)
      return '0';
    var b = this.chunkSize(a), b = Math.pow(a, b), c = Sk.builtin.biginteger.nbv(b), d = Sk.builtin.biginteger.nbi(), e = Sk.builtin.biginteger.nbi(), f = '';
    for (this.divRemTo(c, d, e); 0 < d.signum();)
      f = (b + e.intValue()).toString(a).substr(1) + f, d.divRemTo(c, d, e);
    return e.intValue().toString(a) + f;
  };
  Sk.builtin.biginteger.prototype.bnpFromRadix = function (a, b) {
    this.fromInt(0);
    null == b && (b = 10);
    for (var c = this.chunkSize(b), d = Math.pow(b, c), e = !1, f = 0, g = 0, h = 0; h < a.length; ++h) {
      var k = Sk.builtin.biginteger.intAt(a, h);
      if (0 > k) {
        if ('-' == a.charAt(h) && 0 == this.signum() && (e = !0), '.' == a.charAt(h))
          break;
      } else
        g = b * g + k, ++f >= c && (this.dMultiply(d), this.dAddOffset(g, 0), g = f = 0);
    }
    0 < f && (this.dMultiply(Math.pow(b, f)), this.dAddOffset(g, 0));
    e && Sk.builtin.biginteger.ZERO.subTo(this, this);
  };
  Sk.builtin.biginteger.prototype.bnpFromNumber = function (a, b, c) {
    if ('number' == typeof b)
      if (2 > a)
        this.fromInt(1);
      else
        for (this.fromNumber(a, c), this.testBit(a - 1) || this.bitwiseTo(Sk.builtin.biginteger.ONE.shiftLeft(a - 1), Sk.builtin.biginteger.op_or, this), this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(b);)
          this.dAddOffset(2, 0), this.bitLength() > a && this.subTo(Sk.builtin.biginteger.ONE.shiftLeft(a - 1), this);
    this.fromString(a + '');
  };
  Sk.builtin.biginteger.prototype.bnToByteArray = function () {
    var a = this.t, b = [];
    b[0] = this.s;
    var c = this.DB - a * this.DB % 8, d, e = 0;
    if (0 < a--)
      for (c < this.DB && (d = this[a] >> c) != (this.s & this.DM) >> c && (b[e++] = d | this.s << this.DB - c); 0 <= a;)
        if (8 > c ? (d = (this[a] & (1 << c) - 1) << 8 - c, d |= this[--a] >> (c += this.DB - 8)) : (d = this[a] >> (c -= 8) & 255, 0 >= c && (c += this.DB, --a)), 0 != (d & 128) && (d |= -256), 0 == e && (this.s & 128) != (d & 128) && ++e, 0 < e || d != this.s)
          b[e++] = d;
    return b;
  };
  Sk.builtin.biginteger.prototype.bnEquals = function (a) {
    return 0 == this.compareTo(a);
  };
  Sk.builtin.biginteger.prototype.bnMin = function (a) {
    return 0 > this.compareTo(a) ? this : a;
  };
  Sk.builtin.biginteger.prototype.bnMax = function (a) {
    return 0 < this.compareTo(a) ? this : a;
  };
  Sk.builtin.biginteger.prototype.bnpBitwiseTo = function (a, b, c) {
    var d, e, f = Math.min(a.t, this.t);
    for (d = 0; d < f; ++d)
      c[d] = b(this[d], a[d]);
    if (a.t < this.t) {
      e = a.s & this.DM;
      for (d = f; d < this.t; ++d)
        c[d] = b(this[d], e);
      c.t = this.t;
    } else {
      e = this.s & this.DM;
      for (d = f; d < a.t; ++d)
        c[d] = b(e, a[d]);
      c.t = a.t;
    }
    c.s = b(this.s, a.s);
    c.clamp();
  };
  Sk.builtin.biginteger.op_and = function (a, b) {
    return a & b;
  };
  Sk.builtin.biginteger.prototype.bnAnd = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    this.bitwiseTo(a, Sk.builtin.biginteger.op_and, b);
    return b;
  };
  Sk.builtin.biginteger.op_or = function (a, b) {
    return a | b;
  };
  Sk.builtin.biginteger.prototype.bnOr = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    this.bitwiseTo(a, Sk.builtin.biginteger.op_or, b);
    return b;
  };
  Sk.builtin.biginteger.op_xor = function (a, b) {
    return a ^ b;
  };
  Sk.builtin.biginteger.prototype.bnXor = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    this.bitwiseTo(a, Sk.builtin.biginteger.op_xor, b);
    return b;
  };
  Sk.builtin.biginteger.op_andnot = function (a, b) {
    return a & ~b;
  };
  Sk.builtin.biginteger.prototype.bnAndNot = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    this.bitwiseTo(a, Sk.builtin.biginteger.op_andnot, b);
    return b;
  };
  Sk.builtin.biginteger.prototype.bnNot = function () {
    for (var a = Sk.builtin.biginteger.nbi(), b = 0; b < this.t; ++b)
      a[b] = this.DM & ~this[b];
    a.t = this.t;
    a.s = ~this.s;
    return a;
  };
  Sk.builtin.biginteger.prototype.bnShiftLeft = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    0 > a ? this.rShiftTo(-a, b) : this.lShiftTo(a, b);
    return b;
  };
  Sk.builtin.biginteger.prototype.bnShiftRight = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    0 > a ? this.lShiftTo(-a, b) : this.rShiftTo(a, b);
    return b;
  };
  Sk.builtin.biginteger.lbit = function (a) {
    if (0 == a)
      return -1;
    var b = 0;
    0 == (a & 65535) && (a >>= 16, b += 16);
    0 == (a & 255) && (a >>= 8, b += 8);
    0 == (a & 15) && (a >>= 4, b += 4);
    0 == (a & 3) && (a >>= 2, b += 2);
    0 == (a & 1) && ++b;
    return b;
  };
  Sk.builtin.biginteger.prototype.bnGetLowestSetBit = function () {
    for (var a = 0; a < this.t; ++a)
      if (0 != this[a])
        return a * this.DB + Sk.builtin.biginteger.lbit(this[a]);
    return 0 > this.s ? this.t * this.DB : -1;
  };
  Sk.builtin.biginteger.cbit = function (a) {
    for (var b = 0; 0 != a;)
      a &= a - 1, ++b;
    return b;
  };
  Sk.builtin.biginteger.prototype.bnBitCount = function () {
    for (var a = 0, b = this.s & this.DM, c = 0; c < this.t; ++c)
      a += Sk.builtin.biginteger.cbit(this[c] ^ b);
    return a;
  };
  Sk.builtin.biginteger.prototype.bnTestBit = function (a) {
    var b = Math.floor(a / this.DB);
    return b >= this.t ? 0 != this.s : 0 != (this[b] & 1 << a % this.DB);
  };
  Sk.builtin.biginteger.prototype.bnpChangeBit = function (a, b) {
    var c = Sk.builtin.biginteger.ONE.shiftLeft(a);
    this.bitwiseTo(c, b, c);
    return c;
  };
  Sk.builtin.biginteger.prototype.bnSetBit = function (a) {
    return this.changeBit(a, Sk.builtin.biginteger.op_or);
  };
  Sk.builtin.biginteger.prototype.bnClearBit = function (a) {
    return this.changeBit(a, Sk.builtin.biginteger.op_andnot);
  };
  Sk.builtin.biginteger.prototype.bnFlipBit = function (a) {
    return this.changeBit(a, Sk.builtin.biginteger.op_xor);
  };
  Sk.builtin.biginteger.prototype.bnpAddTo = function (a, b) {
    for (var c = 0, d = 0, e = Math.min(a.t, this.t); c < e;)
      d += this[c] + a[c], b[c++] = d & this.DM, d >>= this.DB;
    if (a.t < this.t) {
      for (d += a.s; c < this.t;)
        d += this[c], b[c++] = d & this.DM, d >>= this.DB;
      d += this.s;
    } else {
      for (d += this.s; c < a.t;)
        d += a[c], b[c++] = d & this.DM, d >>= this.DB;
      d += a.s;
    }
    b.s = 0 > d ? -1 : 0;
    0 < d ? b[c++] = d : -1 > d && (b[c++] = this.DV + d);
    b.t = c;
    b.clamp();
  };
  Sk.builtin.biginteger.prototype.bnAdd = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    this.addTo(a, b);
    return b;
  };
  Sk.builtin.biginteger.prototype.bnSubtract = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    this.subTo(a, b);
    return b;
  };
  Sk.builtin.biginteger.prototype.bnMultiply = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    this.multiplyTo(a, b);
    return b;
  };
  Sk.builtin.biginteger.prototype.bnDivide = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    this.divRemTo(a, b, null);
    return b;
  };
  Sk.builtin.biginteger.prototype.bnRemainder = function (a) {
    var b = Sk.builtin.biginteger.nbi();
    this.divRemTo(a, null, b);
    return b;
  };
  Sk.builtin.biginteger.prototype.bnDivideAndRemainder = function (a) {
    var b = Sk.builtin.biginteger.nbi(), c = Sk.builtin.biginteger.nbi();
    this.divRemTo(a, b, c);
    return [
      b,
      c
    ];
  };
  Sk.builtin.biginteger.prototype.bnpDMultiply = function (a) {
    this[this.t] = this.am(0, a - 1, this, 0, 0, this.t);
    ++this.t;
    this.clamp();
  };
  Sk.builtin.biginteger.prototype.bnpDAddOffset = function (a, b) {
    if (0 != a) {
      for (; this.t <= b;)
        this[this.t++] = 0;
      for (this[b] += a; this[b] >= this.DV;)
        this[b] -= this.DV, ++b >= this.t && (this[this.t++] = 0), ++this[b];
    }
  };
  Sk.builtin.biginteger.NullExp = function () {
  };
  Sk.builtin.biginteger.prototype.nNop = function (a) {
    return a;
  };
  Sk.builtin.biginteger.prototype.nMulTo = function (a, b, c) {
    a.multiplyTo(b, c);
  };
  Sk.builtin.biginteger.prototype.nSqrTo = function (a, b) {
    a.squareTo(b);
  };
  Sk.builtin.biginteger.NullExp.prototype.convert = Sk.builtin.biginteger.prototype.nNop;
  Sk.builtin.biginteger.NullExp.prototype.revert = Sk.builtin.biginteger.prototype.nNop;
  Sk.builtin.biginteger.NullExp.prototype.mulTo = Sk.builtin.biginteger.prototype.nMulTo;
  Sk.builtin.biginteger.NullExp.prototype.sqrTo = Sk.builtin.biginteger.prototype.nSqrTo;
  Sk.builtin.biginteger.prototype.bnPow = function (a) {
    return this.exp(a, new Sk.builtin.biginteger.NullExp());
  };
  Sk.builtin.biginteger.prototype.bnpMultiplyLowerTo = function (a, b, c) {
    var d = Math.min(this.t + a.t, b);
    c.s = 0;
    for (c.t = d; 0 < d;)
      c[--d] = 0;
    var e;
    for (e = c.t - this.t; d < e; ++d)
      c[d + this.t] = this.am(0, a[d], c, d, 0, this.t);
    for (e = Math.min(a.t, b); d < e; ++d)
      this.am(0, a[d], c, d, 0, b - d);
    c.clamp();
  };
  Sk.builtin.biginteger.prototype.bnpMultiplyUpperTo = function (a, b, c) {
    --b;
    var d = c.t = this.t + a.t - b;
    for (c.s = 0; 0 <= --d;)
      c[d] = 0;
    for (d = Math.max(b - this.t, 0); d < a.t; ++d)
      c[this.t + d - b] = this.am(b - d, a[d], c, 0, 0, this.t + d - b);
    c.clamp();
    c.drShiftTo(1, c);
  };
  Sk.builtin.biginteger.Barrett = function (a) {
    this.r2 = Sk.builtin.biginteger.nbi();
    this.q3 = Sk.builtin.biginteger.nbi();
    Sk.builtin.biginteger.ONE.dlShiftTo(2 * a.t, this.r2);
    this.mu = this.r2.divide(a);
    this.m = a;
  };
  Sk.builtin.biginteger.prototype.barrettConvert = function (a) {
    if (0 > a.s || a.t > 2 * this.m.t)
      return a.mod(this.m);
    if (0 > a.compareTo(this.m))
      return a;
    var b = Sk.builtin.biginteger.nbi();
    a.copyTo(b);
    this.reduce(b);
    return b;
  };
  Sk.builtin.biginteger.prototype.barrettRevert = function (a) {
    return a;
  };
  Sk.builtin.biginteger.prototype.barrettReduce = function (a) {
    a.drShiftTo(this.m.t - 1, this.r2);
    a.t > this.m.t + 1 && (a.t = this.m.t + 1, a.clamp());
    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
    for (this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); 0 > a.compareTo(this.r2);)
      a.dAddOffset(1, this.m.t + 1);
    for (a.subTo(this.r2, a); 0 <= a.compareTo(this.m);)
      a.subTo(this.m, a);
  };
  Sk.builtin.biginteger.prototype.barrettSqrTo = function (a, b) {
    a.squareTo(b);
    this.reduce(b);
  };
  Sk.builtin.biginteger.prototype.barrettMulTo = function (a, b, c) {
    a.multiplyTo(b, c);
    this.reduce(c);
  };
  Sk.builtin.biginteger.Barrett.prototype.convert = Sk.builtin.biginteger.prototype.barrettConvert;
  Sk.builtin.biginteger.Barrett.prototype.revert = Sk.builtin.biginteger.prototype.barrettRevert;
  Sk.builtin.biginteger.Barrett.prototype.reduce = Sk.builtin.biginteger.prototype.barrettReduce;
  Sk.builtin.biginteger.Barrett.prototype.mulTo = Sk.builtin.biginteger.prototype.barrettMulTo;
  Sk.builtin.biginteger.Barrett.prototype.sqrTo = Sk.builtin.biginteger.prototype.barrettSqrTo;
  Sk.builtin.biginteger.prototype.bnModPow = function (a, b) {
    var c = a.bitLength(), d, e = Sk.builtin.biginteger.nbv(1), f;
    if (0 >= c)
      return e;
    d = 18 > c ? 1 : 48 > c ? 3 : 144 > c ? 4 : 768 > c ? 5 : 6;
    f = 8 > c ? new Sk.builtin.biginteger.Classic(b) : b.isEven() ? new Sk.builtin.biginteger.Barrett(b) : new Sk.builtin.biginteger.Montgomery(b);
    var g = [], h = 3, k = d - 1, l = (1 << d) - 1;
    g[1] = f.convert(this);
    if (1 < d)
      for (c = Sk.builtin.biginteger.nbi(), f.sqrTo(g[1], c); h <= l;)
        g[h] = Sk.builtin.biginteger.nbi(), f.mulTo(c, g[h - 2], g[h]), h += 2;
    for (var m = a.t - 1, n, p = !0, q = Sk.builtin.biginteger.nbi(), c = Sk.builtin.biginteger.nbits(a[m]) - 1; 0 <= m;) {
      c >= k ? n = a[m] >> c - k & l : (n = (a[m] & (1 << c + 1) - 1) << k - c, 0 < m && (n |= a[m - 1] >> this.DB + c - k));
      for (h = d; 0 == (n & 1);)
        n >>= 1, --h;
      0 > (c -= h) && (c += this.DB, --m);
      if (p)
        g[n].copyTo(e), p = !1;
      else {
        for (; 1 < h;)
          f.sqrTo(e, q), f.sqrTo(q, e), h -= 2;
        0 < h ? f.sqrTo(e, q) : (h = e, e = q, q = h);
        f.mulTo(q, g[n], e);
      }
      for (; 0 <= m && 0 == (a[m] & 1 << c);)
        f.sqrTo(e, q), h = e, e = q, q = h, 0 > --c && (c = this.DB - 1, --m);
    }
    return f.revert(e);
  };
  Sk.builtin.biginteger.prototype.bnGCD = function (a) {
    var b = 0 > this.s ? this.negate() : this.clone();
    a = 0 > a.s ? a.negate() : a.clone();
    if (0 > b.compareTo(a)) {
      var c = b, b = a;
      a = c;
    }
    var c = b.getLowestSetBit(), d = a.getLowestSetBit();
    if (0 > d)
      return b;
    c < d && (d = c);
    0 < d && (b.rShiftTo(d, b), a.rShiftTo(d, a));
    for (; 0 < b.signum();)
      0 < (c = b.getLowestSetBit()) && b.rShiftTo(c, b), 0 < (c = a.getLowestSetBit()) && a.rShiftTo(c, a), 0 <= b.compareTo(a) ? (b.subTo(a, b), b.rShiftTo(1, b)) : (a.subTo(b, a), a.rShiftTo(1, a));
    0 < d && a.lShiftTo(d, a);
    return a;
  };
  Sk.builtin.biginteger.prototype.bnpModInt = function (a) {
    if (0 >= a)
      return 0;
    var b = this.DV % a, c = 0 > this.s ? a - 1 : 0;
    if (0 < this.t)
      if (0 == b)
        c = this[0] % a;
      else
        for (var d = this.t - 1; 0 <= d; --d)
          c = (b * c + this[d]) % a;
    return c;
  };
  Sk.builtin.biginteger.prototype.bnModInverse = function (a) {
    var b = a.isEven();
    if (this.isEven() && b || 0 == a.signum())
      return Sk.builtin.biginteger.ZERO;
    for (var c = a.clone(), d = this.clone(), e = Sk.builtin.biginteger.nbv(1), f = Sk.builtin.biginteger.nbv(0), g = Sk.builtin.biginteger.nbv(0), h = Sk.builtin.biginteger.nbv(1); 0 != c.signum();) {
      for (; c.isEven();)
        c.rShiftTo(1, c), b ? (e.isEven() && f.isEven() || (e.addTo(this, e), f.subTo(a, f)), e.rShiftTo(1, e)) : f.isEven() || f.subTo(a, f), f.rShiftTo(1, f);
      for (; d.isEven();)
        d.rShiftTo(1, d), b ? (g.isEven() && h.isEven() || (g.addTo(this, g), h.subTo(a, h)), g.rShiftTo(1, g)) : h.isEven() || h.subTo(a, h), h.rShiftTo(1, h);
      0 <= c.compareTo(d) ? (c.subTo(d, c), b && e.subTo(g, e), f.subTo(h, f)) : (d.subTo(c, d), b && g.subTo(e, g), h.subTo(f, h));
    }
    if (0 != d.compareTo(Sk.builtin.biginteger.ONE))
      return Sk.builtin.biginteger.ZERO;
    if (0 <= h.compareTo(a))
      return h.subtract(a);
    if (0 > h.signum())
      h.addTo(a, h);
    else
      return h;
    return 0 > h.signum() ? h.add(a) : h;
  };
  Sk.builtin.biginteger.lowprimes = [
    2,
    3,
    5,
    7,
    11,
    13,
    17,
    19,
    23,
    29,
    31,
    37,
    41,
    43,
    47,
    53,
    59,
    61,
    67,
    71,
    73,
    79,
    83,
    89,
    97,
    101,
    103,
    107,
    109,
    113,
    127,
    131,
    137,
    139,
    149,
    151,
    157,
    163,
    167,
    173,
    179,
    181,
    191,
    193,
    197,
    199,
    211,
    223,
    227,
    229,
    233,
    239,
    241,
    251,
    257,
    263,
    269,
    271,
    277,
    281,
    283,
    293,
    307,
    311,
    313,
    317,
    331,
    337,
    347,
    349,
    353,
    359,
    367,
    373,
    379,
    383,
    389,
    397,
    401,
    409,
    419,
    421,
    431,
    433,
    439,
    443,
    449,
    457,
    461,
    463,
    467,
    479,
    487,
    491,
    499,
    503,
    509
  ];
  Sk.builtin.biginteger.lplim = 67108864 / Sk.builtin.biginteger.lowprimes[Sk.builtin.biginteger.lowprimes.length - 1];
  Sk.builtin.biginteger.prototype.bnIsProbablePrime = function (a) {
    var b, c = this.abs();
    if (1 == c.t && c[0] <= Sk.builtin.biginteger.lowprimes[Sk.builtin.biginteger.lowprimes.length - 1]) {
      for (b = 0; b < Sk.builtin.biginteger.lowprimes.length; ++b)
        if (c[0] == Sk.builtin.biginteger.lowprimes[b])
          return !0;
      return !1;
    }
    if (c.isEven())
      return !1;
    for (b = 1; b < Sk.builtin.biginteger.lowprimes.length;) {
      for (var d = Sk.builtin.biginteger.lowprimes[b], e = b + 1; e < Sk.builtin.biginteger.lowprimes.length && d < Sk.builtin.biginteger.lplim;)
        d *= Sk.builtin.biginteger.lowprimes[e++];
      for (d = c.modInt(d); b < e;)
        if (0 == d % Sk.builtin.biginteger.lowprimes[b++])
          return !1;
    }
    return c.millerRabin(a);
  };
  Sk.builtin.biginteger.prototype.bnpMillerRabin = function (a) {
    var b = this.subtract(Sk.builtin.biginteger.ONE), c = b.getLowestSetBit();
    if (0 >= c)
      return !1;
    var d = b.shiftRight(c);
    a = a + 1 >> 1;
    a > Sk.builtin.biginteger.lowprimes.length && (a = Sk.builtin.biginteger.lowprimes.length);
    for (var e = Sk.builtin.biginteger.nbi(), f = 0; f < a; ++f) {
      e.fromInt(Sk.builtin.biginteger.lowprimes[f]);
      var g = e.modPow(d, this);
      if (0 != g.compareTo(Sk.builtin.biginteger.ONE) && 0 != g.compareTo(b)) {
        for (var h = 1; h++ < c && 0 != g.compareTo(b);)
          if (g = g.modPowInt(2, this), 0 == g.compareTo(Sk.builtin.biginteger.ONE))
            return !1;
        if (0 != g.compareTo(b))
          return !1;
      }
    }
    return !0;
  };
  Sk.builtin.biginteger.prototype.isnegative = function () {
    return 0 > this.s;
  };
  Sk.builtin.biginteger.prototype.ispositive = function () {
    return 0 <= this.s;
  };
  Sk.builtin.biginteger.prototype.trueCompare = function (a) {
    return 0 <= this.s && 0 > a.s ? 1 : 0 > this.s && 0 <= a.s ? -1 : this.compare(a);
  };
  Sk.builtin.biginteger.prototype.chunkSize = Sk.builtin.biginteger.prototype.bnpChunkSize;
  Sk.builtin.biginteger.prototype.toRadix = Sk.builtin.biginteger.prototype.bnpToRadix;
  Sk.builtin.biginteger.prototype.fromRadix = Sk.builtin.biginteger.prototype.bnpFromRadix;
  Sk.builtin.biginteger.prototype.fromNumber = Sk.builtin.biginteger.prototype.bnpFromNumber;
  Sk.builtin.biginteger.prototype.bitwiseTo = Sk.builtin.biginteger.prototype.bnpBitwiseTo;
  Sk.builtin.biginteger.prototype.changeBit = Sk.builtin.biginteger.prototype.bnpChangeBit;
  Sk.builtin.biginteger.prototype.addTo = Sk.builtin.biginteger.prototype.bnpAddTo;
  Sk.builtin.biginteger.prototype.dMultiply = Sk.builtin.biginteger.prototype.bnpDMultiply;
  Sk.builtin.biginteger.prototype.dAddOffset = Sk.builtin.biginteger.prototype.bnpDAddOffset;
  Sk.builtin.biginteger.prototype.multiplyLowerTo = Sk.builtin.biginteger.prototype.bnpMultiplyLowerTo;
  Sk.builtin.biginteger.prototype.multiplyUpperTo = Sk.builtin.biginteger.prototype.bnpMultiplyUpperTo;
  Sk.builtin.biginteger.prototype.modInt = Sk.builtin.biginteger.prototype.bnpModInt;
  Sk.builtin.biginteger.prototype.millerRabin = Sk.builtin.biginteger.prototype.bnpMillerRabin;
  Sk.builtin.biginteger.prototype.clone = Sk.builtin.biginteger.prototype.bnClone;
  Sk.builtin.biginteger.prototype.intValue = Sk.builtin.biginteger.prototype.bnIntValue;
  Sk.builtin.biginteger.prototype.byteValue = Sk.builtin.biginteger.prototype.bnByteValue;
  Sk.builtin.biginteger.prototype.shortValue = Sk.builtin.biginteger.prototype.bnShortValue;
  Sk.builtin.biginteger.prototype.signum = Sk.builtin.biginteger.prototype.bnSigNum;
  Sk.builtin.biginteger.prototype.toByteArray = Sk.builtin.biginteger.prototype.bnToByteArray;
  Sk.builtin.biginteger.prototype.equals = Sk.builtin.biginteger.prototype.bnEquals;
  Sk.builtin.biginteger.prototype.compare = Sk.builtin.biginteger.prototype.compareTo;
  Sk.builtin.biginteger.prototype.min = Sk.builtin.biginteger.prototype.bnMin;
  Sk.builtin.biginteger.prototype.max = Sk.builtin.biginteger.prototype.bnMax;
  Sk.builtin.biginteger.prototype.and = Sk.builtin.biginteger.prototype.bnAnd;
  Sk.builtin.biginteger.prototype.or = Sk.builtin.biginteger.prototype.bnOr;
  Sk.builtin.biginteger.prototype.xor = Sk.builtin.biginteger.prototype.bnXor;
  Sk.builtin.biginteger.prototype.andNot = Sk.builtin.biginteger.prototype.bnAndNot;
  Sk.builtin.biginteger.prototype.not = Sk.builtin.biginteger.prototype.bnNot;
  Sk.builtin.biginteger.prototype.shiftLeft = Sk.builtin.biginteger.prototype.bnShiftLeft;
  Sk.builtin.biginteger.prototype.shiftRight = Sk.builtin.biginteger.prototype.bnShiftRight;
  Sk.builtin.biginteger.prototype.getLowestSetBit = Sk.builtin.biginteger.prototype.bnGetLowestSetBit;
  Sk.builtin.biginteger.prototype.bitCount = Sk.builtin.biginteger.prototype.bnBitCount;
  Sk.builtin.biginteger.prototype.testBit = Sk.builtin.biginteger.prototype.bnTestBit;
  Sk.builtin.biginteger.prototype.setBit = Sk.builtin.biginteger.prototype.bnSetBit;
  Sk.builtin.biginteger.prototype.clearBit = Sk.builtin.biginteger.prototype.bnClearBit;
  Sk.builtin.biginteger.prototype.flipBit = Sk.builtin.biginteger.prototype.bnFlipBit;
  Sk.builtin.biginteger.prototype.add = Sk.builtin.biginteger.prototype.bnAdd;
  Sk.builtin.biginteger.prototype.subtract = Sk.builtin.biginteger.prototype.bnSubtract;
  Sk.builtin.biginteger.prototype.multiply = Sk.builtin.biginteger.prototype.bnMultiply;
  Sk.builtin.biginteger.prototype.divide = Sk.builtin.biginteger.prototype.bnDivide;
  Sk.builtin.biginteger.prototype.remainder = Sk.builtin.biginteger.prototype.bnRemainder;
  Sk.builtin.biginteger.prototype.divideAndRemainder = Sk.builtin.biginteger.prototype.bnDivideAndRemainder;
  Sk.builtin.biginteger.prototype.modPow = Sk.builtin.biginteger.prototype.bnModPow;
  Sk.builtin.biginteger.prototype.modInverse = Sk.builtin.biginteger.prototype.bnModInverse;
  Sk.builtin.biginteger.prototype.pow = Sk.builtin.biginteger.prototype.bnPow;
  Sk.builtin.biginteger.prototype.gcd = Sk.builtin.biginteger.prototype.bnGCD;
  Sk.builtin.biginteger.prototype.isProbablePrime = Sk.builtin.biginteger.prototype.bnIsProbablePrime;
  Sk.builtin.nmber = function (a, b) {
    if (!(this instanceof Sk.builtin.nmber))
      return new Sk.builtin.nmber(a, b);
    a instanceof Sk.builtin.str && (a = a.v);
    if (a instanceof Sk.builtin.nmber)
      this.v = a.v, this.skType = a.skType;
    else if ('number' === typeof a)
      if (this.v = a, void 0 === b)
        this.skType = a > Sk.builtin.nmber.threshold$ || a < -Sk.builtin.nmber.threshold$ || 0 != a % 1 ? Sk.builtin.nmber.float$ : Sk.builtin.nmber.int$;
      else {
        if (this.skType = b, b === Sk.builtin.nmber.int$ && (a > Sk.builtin.nmber.threshold$ || a < -Sk.builtin.nmber.threshold$))
          return new Sk.builtin.lng(a);
      }
    else {
      if ('string' === typeof a) {
        var c = Sk.numberFromStr(a);
        void 0 !== b && (c.skType = b);
        return b === Sk.builtin.nmber.int$ && (c.v > Sk.builtin.nmber.threshold$ || c.v < -Sk.builtin.nmber.threshold$) ? new Sk.builtin.lng(a) : c;
      }
      if (a instanceof Sk.builtin.lng)
        return Sk.numberFromStr(a.str$(10, !0));
      if (a instanceof Sk.builtin.biginteger) {
        if (c = Sk.numberFromStr(a.toString()), void 0 !== b && (c.skType = b), b === Sk.builtin.nmber.int$ && (c.v > Sk.builtin.nmber.threshold$ || c.v < -Sk.builtin.nmber.threshold$))
          return new Sk.builtin.lng(a);
      } else
        this.v = 0, this.skType = void 0 === b ? Sk.builtin.nmber.int$ : b;
    }
    return this;
  };
  Sk.builtin.nmber.prototype.tp$index = function () {
    return this.v;
  };
  Sk.builtin.nmber.prototype.tp$hash = function () {
    return this.v;
  };
  Sk.builtin.nmber.prototype.tp$name = 'number';
  Sk.builtin.nmber.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('number', Sk.builtin.nmber);
  Sk.builtin.nmber.threshold$ = Math.pow(2, 53);
  Sk.builtin.nmber.float$ = 'float';
  Sk.builtin.nmber.int$ = 'int';
  Sk.builtin.nmber.fromInt$ = function (a) {
    return new Sk.builtin.nmber(a, void 0);
  };
  Sk.numberFromStr = function (a) {
    if ('inf' == a)
      return new Sk.builtin.nmber(Infinity, void 0);
    if ('-inf' == a)
      return new Sk.builtin.nmber(-Infinity, void 0);
    var b = new Sk.builtin.nmber(0, void 0);
    if (-1 !== a.indexOf('.') || -1 !== a.indexOf('e') || -1 !== a.indexOf('E'))
      return b.v = parseFloat(a), b.skType = Sk.builtin.nmber.float$, b;
    var c = a;
    '-' === a.charAt(0) && (c = a.substr(1));
    a = '0' !== c.charAt(0) || 'x' !== c.charAt(1) && 'X' !== c.charAt(1) ? '0' !== c.charAt(0) || 'b' !== c.charAt(1) && 'B' !== c.charAt(1) ? '0' === c.charAt(0) ? parseInt(a, 8) : parseInt(a, 10) : parseInt(a, 2) : parseInt(a, 16);
    b.v = a;
    b.skType = Sk.builtin.nmber.int$;
    return b;
  };
  goog.exportSymbol('Sk.numberFromStr', Sk.numberFromStr);
  Sk.builtin.nmber.prototype.clone = function () {
    return new Sk.builtin.nmber(this, void 0);
  };
  Sk.builtin.nmber.prototype.toFixed = function (a) {
    a = Sk.builtin.asnum$(a);
    return this.v.toFixed(a);
  };
  Sk.builtin.nmber.prototype.nb$add = function (a) {
    var b;
    'number' === typeof a && (a = new Sk.builtin.nmber(a, void 0));
    if (a instanceof Sk.builtin.nmber) {
      b = new Sk.builtin.nmber(this.v + a.v, void 0);
      if (this.skType === Sk.builtin.nmber.float$ || a.skType === Sk.builtin.nmber.float$)
        b.skType = Sk.builtin.nmber.float$;
      else if (b.skType = Sk.builtin.nmber.int$, b.v > Sk.builtin.nmber.threshold$ || b.v < -Sk.builtin.nmber.threshold$)
        b = new Sk.builtin.lng(this.v).nb$add(a.v);
      return b;
    }
    if (a instanceof Sk.builtin.lng)
      return b = this.skType === Sk.builtin.nmber.float$ ? new Sk.builtin.nmber(this.v + parseFloat(a.str$(10, !0)), Sk.builtin.nmber.float$) : new Sk.builtin.lng(this.v).nb$add(a);
  };
  Sk.builtin.nmber.prototype.nb$subtract = function (a) {
    var b;
    'number' === typeof a && (a = new Sk.builtin.nmber(a, void 0));
    if (a instanceof Sk.builtin.nmber) {
      b = new Sk.builtin.nmber(this.v - a.v, void 0);
      if (this.skType === Sk.builtin.nmber.float$ || a.skType === Sk.builtin.nmber.float$)
        b.skType = Sk.builtin.nmber.float$;
      else if (b.skType = Sk.builtin.nmber.int$, b.v > Sk.builtin.nmber.threshold$ || b.v < -Sk.builtin.nmber.threshold$)
        b = new Sk.builtin.lng(this.v).nb$subtract(a.v);
      return b;
    }
    if (a instanceof Sk.builtin.lng)
      return b = this.skType === Sk.builtin.nmber.float$ ? new Sk.builtin.nmber(this.v - parseFloat(a.str$(10, !0)), Sk.builtin.nmber.float$) : new Sk.builtin.lng(this.v).nb$subtract(a);
  };
  Sk.builtin.nmber.prototype.nb$multiply = function (a) {
    var b;
    'number' === typeof a && (a = new Sk.builtin.nmber(a, void 0));
    if (a instanceof Sk.builtin.nmber) {
      b = new Sk.builtin.nmber(this.v * a.v, void 0);
      if (this.skType === Sk.builtin.nmber.float$ || a.skType === Sk.builtin.nmber.float$)
        b.skType = Sk.builtin.nmber.float$;
      else if (b.skType = Sk.builtin.nmber.int$, b.v > Sk.builtin.nmber.threshold$ || b.v < -Sk.builtin.nmber.threshold$)
        b = new Sk.builtin.lng(this.v).nb$multiply(a.v);
      return b;
    }
    if (a instanceof Sk.builtin.lng)
      return b = this.skType === Sk.builtin.nmber.float$ ? new Sk.builtin.nmber(this.v * parseFloat(a.str$(10, !0)), Sk.builtin.nmber.float$) : new Sk.builtin.lng(this.v).nb$multiply(a);
  };
  Sk.builtin.nmber.prototype.nb$divide = function (a) {
    var b;
    'number' === typeof a && (a = new Sk.builtin.nmber(a, void 0));
    if (a instanceof Sk.builtin.nmber) {
      if (0 == a.v)
        throw new Sk.builtin.ZeroDivisionError('integer division or modulo by zero');
      if (Infinity === this.v)
        return Infinity === a.v || -Infinity === a.v ? new Sk.builtin.nmber(NaN, Sk.builtin.nmber.float$) : a.nb$isnegative() ? new Sk.builtin.nmber(-Infinity, Sk.builtin.nmber.float$) : new Sk.builtin.nmber(Infinity, Sk.builtin.nmber.float$);
      if (-Infinity === this.v)
        return Infinity === a.v || -Infinity === a.v ? new Sk.builtin.nmber(NaN, Sk.builtin.nmber.float$) : a.nb$isnegative() ? new Sk.builtin.nmber(Infinity, Sk.builtin.nmber.float$) : new Sk.builtin.nmber(-Infinity, Sk.builtin.nmber.float$);
      b = new Sk.builtin.nmber(this.v / a.v, void 0);
      if (this.skType === Sk.builtin.nmber.float$ || a.skType === Sk.builtin.nmber.float$ || Sk.python3)
        b.skType = Sk.builtin.nmber.float$;
      else if (b.v = Math.floor(b.v), b.skType = Sk.builtin.nmber.int$, b.v > Sk.builtin.nmber.threshold$ || b.v < -Sk.builtin.nmber.threshold$)
        b = new Sk.builtin.lng(this.v).nb$divide(a.v);
      return b;
    }
    if (a instanceof Sk.builtin.lng) {
      if (0 == a.longCompare(Sk.builtin.biginteger.ZERO))
        throw new Sk.builtin.ZeroDivisionError('integer division or modulo by zero');
      return Infinity === this.v ? a.nb$isnegative() ? new Sk.builtin.nmber(-Infinity, Sk.builtin.nmber.float$) : new Sk.builtin.nmber(Infinity, Sk.builtin.nmber.float$) : -Infinity === this.v ? a.nb$isnegative() ? new Sk.builtin.nmber(Infinity, Sk.builtin.nmber.float$) : new Sk.builtin.nmber(-Infinity, Sk.builtin.nmber.float$) : b = this.skType === Sk.builtin.nmber.float$ ? new Sk.builtin.nmber(this.v / parseFloat(a.str$(10, !0)), Sk.builtin.nmber.float$) : new Sk.builtin.lng(this.v).nb$divide(a);
    }
  };
  Sk.builtin.nmber.prototype.nb$floor_divide = function (a) {
    var b;
    'number' === typeof a && (a = new Sk.builtin.nmber(a, void 0));
    if (Infinity === this.v || -Infinity === this.v)
      return new Sk.builtin.nmber(NaN, Sk.builtin.nmber.float$);
    if (a instanceof Sk.builtin.nmber) {
      if (0 == a.v)
        throw new Sk.builtin.ZeroDivisionError('integer division or modulo by zero');
      if (Infinity === a.v)
        return this.nb$isnegative() ? new Sk.builtin.nmber(-1, Sk.builtin.nmber.float$) : new Sk.builtin.nmber(0, Sk.builtin.nmber.float$);
      if (-Infinity === a.v)
        return this.nb$isnegative() || !this.nb$nonzero() ? new Sk.builtin.nmber(0, Sk.builtin.nmber.float$) : new Sk.builtin.nmber(-1, Sk.builtin.nmber.float$);
      b = new Sk.builtin.nmber(Math.floor(this.v / a.v), void 0);
      if (this.skType === Sk.builtin.nmber.float$ || a.skType === Sk.builtin.nmber.float$)
        b.skType = Sk.builtin.nmber.float$;
      else if (b.v = Math.floor(b.v), b.skType = Sk.builtin.nmber.int$, b.v > Sk.builtin.nmber.threshold$ || b.v < -Sk.builtin.nmber.threshold$)
        b = new Sk.builtin.lng(this.v).nb$floor_divide(a.v);
      return b;
    }
    if (a instanceof Sk.builtin.lng) {
      if (0 == a.longCompare(Sk.builtin.biginteger.ZERO))
        throw new Sk.builtin.ZeroDivisionError('integer division or modulo by zero');
      this.skType === Sk.builtin.nmber.float$ ? (b = Math.floor(this.v / parseFloat(a.str$(10, !0))), b = new Sk.builtin.nmber(b, Sk.builtin.nmber.float$)) : b = new Sk.builtin.lng(this.v).nb$floor_divide(a);
      return b;
    }
  };
  Sk.builtin.nmber.prototype.nb$remainder = function (a) {
    var b;
    'number' === typeof a && (a = new Sk.builtin.nmber(a, void 0));
    if (a instanceof Sk.builtin.nmber) {
      if (0 == a.v)
        throw new Sk.builtin.ZeroDivisionError('integer division or modulo by zero');
      if (0 == this.v)
        return this.skType == Sk.builtin.nmber.float$ || a.skType == Sk.builtin.nmber.float$ ? new Sk.builtin.nmber(0, Sk.builtin.nmber.float$) : new Sk.builtin.nmber(0, Sk.builtin.nmber.int$);
      if (Infinity === a.v)
        return Infinity === this.v || -Infinity === this.v ? new Sk.builtin.nmber(NaN, Sk.builtin.nmber.float$) : this.nb$ispositive() ? new Sk.builtin.nmber(this.v, Sk.builtin.nmber.float$) : new Sk.builtin.nmber(Infinity, Sk.builtin.nmber.float$);
      b = this.v % a.v;
      0 > this.v ? 0 < a.v && 0 > b && (b += a.v) : 0 > a.v && 0 != b && (b += a.v);
      if (this.skType === Sk.builtin.nmber.float$ || a.skType === Sk.builtin.nmber.float$)
        b = new Sk.builtin.nmber(b, Sk.builtin.nmber.float$);
      else if (b = new Sk.builtin.nmber(b, Sk.builtin.nmber.int$), b.v > Sk.builtin.nmber.threshold$ || b.v < -Sk.builtin.nmber.threshold$)
        b = new Sk.builtin.lng(this.v).nb$remainder(a.v);
      return b;
    }
    if (a instanceof Sk.builtin.lng) {
      if (0 == a.longCompare(Sk.builtin.biginteger.ZERO))
        throw new Sk.builtin.ZeroDivisionError('integer division or modulo by zero');
      if (0 == this.v)
        return this.skType === Sk.builtin.nmber.int$ ? new Sk.builtin.lng(0) : new Sk.builtin.nmber(0, this.skType);
      this.skType === Sk.builtin.nmber.float$ ? (a = parseFloat(a.str$(10, !0)), b = this.v % a, 0 > b ? 0 < a && 0 != b && (b += a) : 0 > a && 0 != b && (b += a), b = new Sk.builtin.nmber(b, Sk.builtin.nmber.float$)) : b = new Sk.builtin.lng(this.v).nb$remainder(a);
      return b;
    }
  };
  Sk.builtin.nmber.prototype.nb$power = function (a) {
    var b;
    'number' === typeof a && (a = new Sk.builtin.nmber(a, void 0));
    if (a instanceof Sk.builtin.nmber) {
      if (0 > this.v && 0 != a.v % 1)
        throw new Sk.builtin.NegativePowerError('cannot raise a negative number to a fractional power');
      if (0 == this.v && 0 > a.v)
        throw new Sk.builtin.NegativePowerError('cannot raise zero to a negative power');
      b = new Sk.builtin.nmber(Math.pow(this.v, a.v), void 0);
      if (this.skType === Sk.builtin.nmber.float$ || a.skType === Sk.builtin.nmber.float$ || 0 > a.v)
        b.skType = Sk.builtin.nmber.float$;
      else if (b.v = Math.floor(b.v), b.skType = Sk.builtin.nmber.int$, b.v > Sk.builtin.nmber.threshold$ || b.v < -Sk.builtin.nmber.threshold$)
        b = new Sk.builtin.lng(this.v).nb$power(a.v);
      if (Infinity === Math.abs(b.v) && Infinity !== Math.abs(this.v) && Infinity !== Math.abs(a.v))
        throw new Sk.builtin.OverflowError('Numerical result out of range');
      return b;
    }
    if (a instanceof Sk.builtin.lng) {
      if (0 == this.v && 0 > a.longCompare(Sk.builtin.biginteger.ZERO))
        throw new Sk.builtin.NegativePowerError('cannot raise zero to a negative power');
      return b = this.skType === Sk.builtin.nmber.float$ || a.nb$isnegative() ? new Sk.builtin.nmber(Math.pow(this.v, parseFloat(a.str$(10, !0))), Sk.builtin.nmber.float$) : new Sk.builtin.lng(this.v).nb$power(a);
    }
  };
  Sk.builtin.nmber.prototype.nb$and = function (a) {
    a = Sk.builtin.asnum$(a);
    a &= this.v;
    void 0 !== a && 0 > a && (a += 4294967296);
    if (void 0 !== a)
      return new Sk.builtin.nmber(a, void 0);
  };
  Sk.builtin.nmber.prototype.nb$or = function (a) {
    a = Sk.builtin.asnum$(a);
    a |= this.v;
    void 0 !== a && 0 > a && (a += 4294967296);
    if (void 0 !== a)
      return new Sk.builtin.nmber(a, void 0);
  };
  Sk.builtin.nmber.prototype.nb$xor = function (a) {
    a = Sk.builtin.asnum$(a);
    a ^= this.v;
    void 0 !== a && 0 > a && (a += 4294967296);
    if (void 0 !== a)
      return new Sk.builtin.nmber(a, void 0);
  };
  Sk.builtin.nmber.prototype.nb$lshift = function (a) {
    var b;
    a = Sk.builtin.asnum$(a);
    if (void 0 !== a) {
      if (0 > a)
        throw new Sk.builtin.ValueError('negative shift count');
      b = this.v << a;
      if (b <= this.v)
        return Sk.builtin.lng.fromInt$(this.v).nb$lshift(a);
    }
    if (void 0 !== b)
      return new Sk.builtin.nmber(b, this.skType);
  };
  Sk.builtin.nmber.prototype.nb$rshift = function (a) {
    var b;
    a = Sk.builtin.asnum$(a);
    if (void 0 !== a) {
      if (0 > a)
        throw new Sk.builtin.ValueError('negative shift count');
      b = this.v >> a;
      0 < this.v && 0 > b && (b &= Math.pow(2, 32 - a) - 1);
    }
    if (void 0 !== b)
      return new Sk.builtin.nmber(b, this.skType);
  };
  Sk.builtin.nmber.prototype.nb$inplace_add = Sk.builtin.nmber.prototype.nb$add;
  Sk.builtin.nmber.prototype.nb$inplace_subtract = Sk.builtin.nmber.prototype.nb$subtract;
  Sk.builtin.nmber.prototype.nb$inplace_multiply = Sk.builtin.nmber.prototype.nb$multiply;
  Sk.builtin.nmber.prototype.nb$inplace_divide = Sk.builtin.nmber.prototype.nb$divide;
  Sk.builtin.nmber.prototype.nb$inplace_remainder = Sk.builtin.nmber.prototype.nb$remainder;
  Sk.builtin.nmber.prototype.nb$inplace_floor_divide = Sk.builtin.nmber.prototype.nb$floor_divide;
  Sk.builtin.nmber.prototype.nb$inplace_power = Sk.builtin.nmber.prototype.nb$power;
  Sk.builtin.nmber.prototype.nb$inplace_and = Sk.builtin.nmber.prototype.nb$and;
  Sk.builtin.nmber.prototype.nb$inplace_or = Sk.builtin.nmber.prototype.nb$or;
  Sk.builtin.nmber.prototype.nb$inplace_xor = Sk.builtin.nmber.prototype.nb$xor;
  Sk.builtin.nmber.prototype.nb$inplace_lshift = Sk.builtin.nmber.prototype.nb$lshift;
  Sk.builtin.nmber.prototype.nb$inplace_rshift = Sk.builtin.nmber.prototype.nb$rshift;
  Sk.builtin.nmber.prototype.nb$negative = function () {
    return new Sk.builtin.nmber(-this.v, void 0);
  };
  Sk.builtin.nmber.prototype.nb$positive = function () {
    return this.clone();
  };
  Sk.builtin.nmber.prototype.nb$nonzero = function () {
    return 0 !== this.v ? Sk.builtin.bool.true$ : Sk.builtin.bool.false$;
  };
  Sk.builtin.nmber.prototype.nb$isnegative = function () {
    return 0 > this.v;
  };
  Sk.builtin.nmber.prototype.nb$ispositive = function () {
    return 0 <= this.v;
  };
  Sk.builtin.nmber.prototype.numberCompare = function (a) {
    a instanceof Sk.builtin.bool && (a = Sk.builtin.asnum$(a));
    a instanceof Sk.builtin.none && (a = 0);
    if ('number' === typeof a)
      return this.v - a;
    if (a instanceof Sk.builtin.nmber)
      return Infinity == this.v && Infinity == a.v || -Infinity == this.v && -Infinity == a.v ? 0 : this.v - a.v;
    if (a instanceof Sk.builtin.lng) {
      if (this.skType === Sk.builtin.nmber.int$ || 0 == this.v % 1)
        return new Sk.builtin.lng(this.v).longCompare(a);
      a = this.nb$subtract(a);
      if (a instanceof Sk.builtin.nmber)
        return a.v;
      if (a instanceof Sk.builtin.lng)
        return a.longCompare(Sk.builtin.biginteger.ZERO);
    }
  };
  Sk.builtin.nmber.prototype.__eq__ = function (a, b) {
    return 0 == a.numberCompare(b) && !(b instanceof Sk.builtin.none);
  };
  Sk.builtin.nmber.prototype.__ne__ = function (a, b) {
    return 0 != a.numberCompare(b) || b instanceof Sk.builtin.none;
  };
  Sk.builtin.nmber.prototype.__lt__ = function (a, b) {
    return 0 > a.numberCompare(b);
  };
  Sk.builtin.nmber.prototype.__le__ = function (a, b) {
    return 0 >= a.numberCompare(b);
  };
  Sk.builtin.nmber.prototype.__gt__ = function (a, b) {
    return 0 < a.numberCompare(b);
  };
  Sk.builtin.nmber.prototype.__ge__ = function (a, b) {
    return 0 <= a.numberCompare(b);
  };
  Sk.builtin.nmber.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
  Sk.builtin.nmber.prototype.tp$repr = function () {
    return new Sk.builtin.str(this.str$(10, !0));
  };
  Sk.builtin.nmber.prototype.tp$str = function () {
    return new Sk.builtin.str(this.str$(10, !0));
  };
  Sk.builtin.nmber.prototype.str$ = function (a, b) {
    if (isNaN(this.v))
      return 'nan';
    void 0 === b && (b = !0);
    if (Infinity == this.v)
      return 'inf';
    if (-Infinity == this.v && b)
      return '-inf';
    if (-Infinity == this.v && !b)
      return 'inf';
    var c = b ? this.v : Math.abs(this.v), d;
    if (void 0 === a || 10 === a)
      if (this.skType == Sk.builtin.nmber.float$) {
        d = c.toPrecision(12);
        var e = d.indexOf('.'), f = c.toString().slice(0, e), e = c.toString().slice(e);
        for (f.match(/^-?0$/) && e.slice(1).match(/^0{4,}/) && (d = 12 > d.length ? c.toExponential() : c.toExponential(11)); '0' == d.charAt(d.length - 1) && 0 > d.indexOf('e');)
          d = d.substring(0, d.length - 1);
        '.' == d.charAt(d.length - 1) && (d += '0');
        d = d.replace(/\.0+e/, 'e', 'i');
        d = d.replace(/(e[-+])([1-9])$/, '$10$2');
        d = d.replace(/0+(e.*)/, '$1');
      } else
        d = c.toString();
    else
      d = c.toString(a);
    if (this.skType !== Sk.builtin.nmber.float$)
      return d;
    0 > d.indexOf('.') && (0 > d.indexOf('E') && 0 > d.indexOf('e')) && (d += '.0');
    return d;
  };
  goog.exportSymbol('Sk.builtin.nmber', Sk.builtin.nmber);
  Sk.builtin.lng = function (a, b) {
    b = Sk.builtin.asnum$(b);
    if (!(this instanceof Sk.builtin.lng))
      return new Sk.builtin.lng(a, b);
    if (void 0 === a)
      this.biginteger = new Sk.builtin.biginteger(0);
    else if (a instanceof Sk.builtin.lng)
      this.biginteger = a.biginteger.clone();
    else if (a instanceof Sk.builtin.biginteger)
      this.biginteger = a;
    else {
      if (a instanceof String)
        return Sk.longFromStr(a, b);
      if (a instanceof Sk.builtin.str)
        return Sk.longFromStr(a.v, b);
      if (void 0 !== a && !Sk.builtin.checkString(a) && !Sk.builtin.checkNumber(a))
        if (!0 === a)
          a = 1;
        else if (!1 === a)
          a = 0;
        else
          throw new Sk.builtin.TypeError('long() argument must be a string or a number, not \'' + Sk.abstr.typeName(a) + '\'');
      a = Sk.builtin.asnum$nofloat(a);
      this.biginteger = new Sk.builtin.biginteger(a);
    }
    return this;
  };
  Sk.builtin.lng.prototype.tp$index = function () {
    return parseInt(this.str$(10, !0), 10);
  };
  Sk.builtin.lng.prototype.tp$hash = function () {
    return this.tp$index();
  };
  Sk.builtin.lng.prototype.tp$name = 'long';
  Sk.builtin.lng.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('long', Sk.builtin.lng);
  Sk.builtin.lng.threshold$ = Math.pow(2, 53);
  Sk.builtin.lng.MAX_INT$ = new Sk.builtin.lng(Sk.builtin.lng.threshold$);
  Sk.builtin.lng.MIN_INT$ = new Sk.builtin.lng(-Sk.builtin.lng.threshold$);
  Sk.builtin.lng.prototype.cantBeInt = function () {
    return 0 < this.longCompare(Sk.builtin.lng.MAX_INT$) || 0 > this.longCompare(Sk.builtin.lng.MIN_INT$);
  };
  Sk.builtin.lng.fromInt$ = function (a) {
    return new Sk.builtin.lng(a);
  };
  Sk.longFromStr = function (a, b) {
    var c = Sk.str2number(a, b, function (a, b) {
        return 10 == b ? new Sk.builtin.biginteger(a) : new Sk.builtin.biginteger(a, b);
      }, function (a) {
        return a.negate();
      }, 'long');
    return new Sk.builtin.lng(c);
  };
  goog.exportSymbol('Sk.longFromStr', Sk.longFromStr);
  Sk.builtin.lng.prototype.toInt$ = function () {
    return this.biginteger.intValue();
  };
  Sk.builtin.lng.prototype.clone = function () {
    return new Sk.builtin.lng(this);
  };
  Sk.builtin.lng.prototype.nb$add = function (a) {
    if (a instanceof Sk.builtin.nmber) {
      if (a.skType === Sk.builtin.nmber.float$)
        return new Sk.builtin.nmber(this.str$(10, !0), Sk.builtin.nmber.float$).nb$add(a);
      a = new Sk.builtin.lng(a.v);
    }
    return a instanceof Sk.builtin.lng ? new Sk.builtin.lng(this.biginteger.add(a.biginteger)) : a instanceof Sk.builtin.biginteger ? new Sk.builtin.lng(this.biginteger.add(a)) : new Sk.builtin.lng(this.biginteger.add(new Sk.builtin.biginteger(a)));
  };
  Sk.builtin.lng.prototype.nb$inplace_add = Sk.builtin.lng.prototype.nb$add;
  Sk.builtin.lng.prototype.nb$subtract = function (a) {
    if (a instanceof Sk.builtin.nmber) {
      if (a.skType === Sk.builtin.nmber.float$)
        return new Sk.builtin.nmber(this.str$(10, !0), Sk.builtin.nmber.float$).nb$subtract(a);
      a = new Sk.builtin.lng(a.v);
    }
    return a instanceof Sk.builtin.lng ? new Sk.builtin.lng(this.biginteger.subtract(a.biginteger)) : a instanceof Sk.builtin.biginteger ? new Sk.builtin.lng(this.biginteger.subtract(a)) : new Sk.builtin.lng(this.biginteger.subtract(new Sk.builtin.biginteger(a)));
  };
  Sk.builtin.lng.prototype.nb$inplace_subtract = Sk.builtin.lng.prototype.nb$subtract;
  Sk.builtin.lng.prototype.nb$multiply = function (a) {
    if (a instanceof Sk.builtin.nmber) {
      if (a.skType === Sk.builtin.nmber.float$)
        return new Sk.builtin.nmber(this.str$(10, !0), Sk.builtin.nmber.float$).nb$multiply(a);
      a = new Sk.builtin.lng(a.v);
    }
    return a instanceof Sk.builtin.lng ? new Sk.builtin.lng(this.biginteger.multiply(a.biginteger)) : a instanceof Sk.builtin.biginteger ? new Sk.builtin.lng(this.biginteger.multiply(a)) : new Sk.builtin.lng(this.biginteger.multiply(new Sk.builtin.biginteger(a)));
  };
  Sk.builtin.lng.prototype.nb$inplace_multiply = Sk.builtin.lng.prototype.nb$multiply;
  Sk.builtin.lng.prototype.nb$divide = function (a) {
    if (a instanceof Sk.builtin.nmber) {
      if (a.skType === Sk.builtin.nmber.float$)
        return new Sk.builtin.nmber(this.str$(10, !0), Sk.builtin.nmber.float$).nb$divide(a);
      a = new Sk.builtin.lng(a.v);
    }
    a instanceof Sk.builtin.lng || (a = new Sk.builtin.lng(a));
    var b = this.nb$isnegative(), c = a.nb$isnegative();
    if (b && !c || c && !b) {
      a = this.biginteger.divideAndRemainder(a.biginteger);
      if (0 == a[1].trueCompare(Sk.builtin.biginteger.ZERO))
        return new Sk.builtin.lng(a[0]);
      a = a[0].subtract(Sk.builtin.biginteger.ONE);
      return new Sk.builtin.lng(a);
    }
    return new Sk.builtin.lng(this.biginteger.divide(a.biginteger));
  };
  Sk.builtin.lng.prototype.nb$inplace_divide = Sk.builtin.lng.prototype.nb$divide;
  Sk.builtin.lng.prototype.nb$floor_divide = function (a) {
    return a instanceof Sk.builtin.nmber && a.skType === Sk.builtin.nmber.float$ ? new Sk.builtin.nmber(this.str$(10, !0), Sk.builtin.nmber.float$).nb$floor_divide(a) : this.nb$divide(a);
  };
  Sk.builtin.lng.prototype.nb$inplace_floor_divide = Sk.builtin.lng.prototype.nb$floor_divide;
  Sk.builtin.lng.prototype.nb$remainder = function (a) {
    if (0 === this.biginteger.trueCompare(Sk.builtin.biginteger.ZERO))
      return a instanceof Sk.builtin.nmber && a.skType === Sk.builtin.nmber.float$ ? new Sk.builtin.nmber(0, Sk.builtin.nmber.float$) : new Sk.builtin.lng(0);
    if (a instanceof Sk.builtin.nmber) {
      if (a.skType === Sk.builtin.nmber.float$)
        return new Sk.builtin.nmber(this.str$(10, !0), Sk.builtin.nmber.float$).nb$remainder(a);
      a = new Sk.builtin.lng(a.v);
    }
    a instanceof Sk.builtin.lng || (a = new Sk.builtin.lng(a));
    var b = new Sk.builtin.lng(this.biginteger.remainder(a.biginteger));
    this.nb$isnegative() ? a.nb$ispositive() && b.nb$nonzero() && (b = b.nb$add(a).nb$remainder(a)) : a.nb$isnegative() && b.nb$nonzero() && (b = b.nb$add(a));
    return b;
  };
  Sk.builtin.lng.prototype.nb$inplace_remainder = Sk.builtin.lng.prototype.nb$remainder;
  Sk.builtin.lng.prototype.nb$power = function (a, b) {
    if (void 0 !== b)
      return a = new Sk.builtin.biginteger(Sk.builtin.asnum$(a)), b = new Sk.builtin.biginteger(Sk.builtin.asnum$(b)), new Sk.builtin.lng(this.biginteger.modPowInt(a, b));
    if ('number' === typeof a) {
      if (0 > a) {
        var c = new Sk.builtin.nmber(this.str$(10, !0), Sk.builtin.nmber.float$);
        return c.nb$power(a);
      }
      return new Sk.builtin.lng(this.biginteger.pow(new Sk.builtin.biginteger(a)));
    }
    if (a instanceof Sk.builtin.nmber) {
      if (a.skType === Sk.builtin.nmber.float$ || 0 > a.v)
        return c = new Sk.builtin.nmber(this.str$(10, !0), Sk.builtin.nmber.float$), c.nb$power(a);
      a = new Sk.builtin.lng(a.v);
    }
    return a instanceof Sk.builtin.lng ? a.nb$isnegative() ? (c = new Sk.builtin.nmber(this.str$(10, !0), Sk.builtin.nmber.float$), c.nb$power(a)) : new Sk.builtin.lng(this.biginteger.pow(a.biginteger)) : a instanceof Sk.builtin.biginteger ? a.isnegative() ? (c = new Sk.builtin.nmber(this.str$(10, !0), Sk.builtin.nmber.float$), c.nb$power(a)) : new Sk.builtin.lng(this.biginteger.pow(a)) : new Sk.builtin.lng(this.biginteger.pow(new Sk.builtin.biginteger(a)));
  };
  Sk.builtin.lng.prototype.nb$inplace_power = Sk.builtin.lng.prototype.nb$power;
  Sk.builtin.lng.prototype.nb$lshift = function (a) {
    if (a instanceof Sk.builtin.lng) {
      if (0 > a.biginteger.signum())
        throw new Sk.builtin.ValueError('negative shift count');
      return new Sk.builtin.lng(this.biginteger.shiftLeft(a.biginteger));
    }
    if (a instanceof Sk.builtin.biginteger) {
      if (0 > a.signum())
        throw new Sk.builtin.ValueError('negative shift count');
      return new Sk.builtin.lng(this.biginteger.shiftLeft(a));
    }
    if (0 > a)
      throw new Sk.builtin.ValueError('negative shift count');
    a = Sk.builtin.asnum$(a);
    return new Sk.builtin.lng(this.biginteger.shiftLeft(new Sk.builtin.biginteger(a)));
  };
  Sk.builtin.lng.prototype.nb$inplace_lshift = Sk.builtin.lng.prototype.nb$lshift;
  Sk.builtin.lng.prototype.nb$rshift = function (a) {
    if (a instanceof Sk.builtin.lng) {
      if (0 > a.biginteger.signum())
        throw new Sk.builtin.ValueError('negative shift count');
      return new Sk.builtin.lng(this.biginteger.shiftRight(a.biginteger));
    }
    if (a instanceof Sk.builtin.biginteger) {
      if (0 > a.signum())
        throw new Sk.builtin.ValueError('negative shift count');
      return new Sk.builtin.lng(this.biginteger.shiftRight(a));
    }
    if (0 > a)
      throw new Sk.builtin.ValueError('negative shift count');
    a = Sk.builtin.asnum$(a);
    return new Sk.builtin.lng(this.biginteger.shiftRight(new Sk.builtin.biginteger(a)));
  };
  Sk.builtin.lng.prototype.nb$inplace_rshift = Sk.builtin.lng.prototype.nb$rshift;
  Sk.builtin.lng.prototype.nb$and = function (a) {
    if (a instanceof Sk.builtin.lng)
      return new Sk.builtin.lng(this.biginteger.and(a.biginteger));
    if (a instanceof Sk.builtin.biginteger)
      return new Sk.builtin.lng(this.biginteger.and(a));
    a = Sk.builtin.asnum$(a);
    return new Sk.builtin.lng(this.biginteger.and(new Sk.builtin.biginteger(a)));
  };
  Sk.builtin.lng.prototype.nb$inplace_and = Sk.builtin.lng.prototype.nb$and;
  Sk.builtin.lng.prototype.nb$or = function (a) {
    if (a instanceof Sk.builtin.lng)
      return new Sk.builtin.lng(this.biginteger.or(a.biginteger));
    if (a instanceof Sk.builtin.biginteger)
      return new Sk.builtin.lng(this.biginteger.or(a));
    a = Sk.builtin.asnum$(a);
    return new Sk.builtin.lng(this.biginteger.or(new Sk.builtin.biginteger(a)));
  };
  Sk.builtin.lng.prototype.nb$inplace_or = Sk.builtin.lng.prototype.nb$or;
  Sk.builtin.lng.prototype.nb$xor = function (a) {
    if (a instanceof Sk.builtin.lng)
      return new Sk.builtin.lng(this.biginteger.xor(a.biginteger));
    if (a instanceof Sk.builtin.biginteger)
      return new Sk.builtin.lng(this.biginteger.xor(a));
    a = Sk.builtin.asnum$(a);
    return new Sk.builtin.lng(this.biginteger.xor(new Sk.builtin.biginteger(a)));
  };
  Sk.builtin.lng.prototype.nb$inplace_xor = Sk.builtin.lng.prototype.nb$xor;
  Sk.builtin.lng.prototype.nb$negative = function () {
    return new Sk.builtin.lng(this.biginteger.negate());
  };
  Sk.builtin.lng.prototype.nb$positive = function () {
    return this.clone();
  };
  Sk.builtin.lng.prototype.nb$nonzero = function () {
    return 0 !== this.biginteger.trueCompare(Sk.builtin.biginteger.ZERO);
  };
  Sk.builtin.lng.prototype.nb$isnegative = function () {
    return this.biginteger.isnegative();
  };
  Sk.builtin.lng.prototype.nb$ispositive = function () {
    return !this.biginteger.isnegative();
  };
  Sk.builtin.lng.prototype.longCompare = function (a) {
    'boolean' === typeof a && (a = a ? 1 : 0);
    'number' === typeof a && (a = new Sk.builtin.lng(a));
    return a instanceof Sk.builtin.nmber ? a.skType === Sk.builtin.nmber.int$ || 0 == a.v % 1 ? (a = new Sk.builtin.lng(a.v), this.longCompare(a)) : new Sk.builtin.nmber(this, Sk.builtin.nmber.float$).numberCompare(a) : a instanceof Sk.builtin.lng ? this.biginteger.subtract(a.biginteger) : a instanceof Sk.builtin.biginteger ? this.biginteger.subtract(a) : this.biginteger.subtract(new Sk.builtin.biginteger(a));
  };
  Sk.builtin.lng.prototype.__eq__ = function (a, b) {
    return 0 == a.longCompare(b) && !(b instanceof Sk.builtin.none);
  };
  Sk.builtin.lng.prototype.__ne__ = function (a, b) {
    return 0 != a.longCompare(b) || b instanceof Sk.builtin.none;
  };
  Sk.builtin.lng.prototype.__lt__ = function (a, b) {
    return 0 > a.longCompare(b);
  };
  Sk.builtin.lng.prototype.__le__ = function (a, b) {
    return 0 >= a.longCompare(b);
  };
  Sk.builtin.lng.prototype.__gt__ = function (a, b) {
    return 0 < a.longCompare(b);
  };
  Sk.builtin.lng.prototype.__ge__ = function (a, b) {
    return 0 <= a.longCompare(b);
  };
  Sk.builtin.lng.prototype.tp$repr = function () {
    return new Sk.builtin.str(this.str$(10, !0) + 'L');
  };
  Sk.builtin.lng.prototype.tp$str = function () {
    return new Sk.builtin.str(this.str$(10, !0));
  };
  Sk.builtin.lng.prototype.str$ = function (a, b) {
    void 0 === b && (b = !0);
    var c = b ? this.biginteger : this.biginteger.abs();
    return void 0 === a || 10 === a ? c.toString() : c.toString(a);
  };
  Sk.str2number = function (a, b, c, d, e) {
    var f = a, g = !1;
    a = a.replace(/^\s+|\s+$/g, '');
    '-' == a.charAt(0) && (g = !0, a = a.substring(1));
    '+' == a.charAt(0) && (a = a.substring(1));
    void 0 === b && (b = 10);
    if ((2 > b || 36 < b) && 0 != b)
      throw new Sk.builtin.ValueError(e + '() base must be >= 2 and <= 36');
    if ('0x' == a.substring(0, 2).toLowerCase()) {
      if (16 != b && 0 != b)
        throw new Sk.builtin.ValueError('invalid literal for ' + e + '() with base ' + b + ': \'' + f + '\'');
      a = a.substring(2);
      b = 16;
    } else if ('0b' == a.substring(0, 2).toLowerCase()) {
      if (2 != b && 0 != b)
        throw new Sk.builtin.ValueError('invalid literal for ' + e + '() with base ' + b + ': \'' + f + '\'');
      a = a.substring(2);
      b = 2;
    } else if ('0o' == a.substring(0, 2).toLowerCase()) {
      if (8 != b && 0 != b)
        throw new Sk.builtin.ValueError('invalid literal for ' + e + '() with base ' + b + ': \'' + f + '\'');
      a = a.substring(2);
      b = 8;
    } else if ('0' == a.charAt(0)) {
      if ('0' == a)
        return 0;
      if (8 == b || 0 == b)
        b = 8;
    }
    0 == b && (b = 10);
    if (0 === a.length)
      throw new Sk.builtin.ValueError('invalid literal for ' + e + '() with base ' + b + ': \'' + f + '\'');
    var h, k, l;
    for (h = 0; h < a.length; h++)
      if (k = a.charCodeAt(h), l = b, 48 <= k && 57 >= k ? l = k - 48 : 65 <= k && 90 >= k ? l = k - 65 + 10 : 97 <= k && 122 >= k && (l = k - 97 + 10), l >= b)
        throw new Sk.builtin.ValueError('invalid literal for ' + e + '() with base ' + b + ': \'' + f + '\'');
    l = c(a, b);
    g && (l = d(l));
    return l;
  };
  Sk.builtin.int_ = function (a, b) {
    if (void 0 !== a && !Sk.builtin.checkString(a) && !Sk.builtin.checkNumber(a))
      if (a instanceof Sk.builtin.bool)
        a = Sk.builtin.asnum$(a);
      else
        throw new Sk.builtin.TypeError('int() argument must be a string or a number, not \'' + Sk.abstr.typeName(a) + '\'');
    if (a instanceof Sk.builtin.str) {
      b = Sk.builtin.asnum$(b);
      var c = Sk.str2number(a.v, b, parseInt, function (a) {
          return -a;
        }, 'int');
      return c > Sk.builtin.lng.threshold$ || c < -Sk.builtin.lng.threshold$ ? new Sk.builtin.lng(a, b) : new Sk.builtin.nmber(c, Sk.builtin.nmber.int$);
    }
    if (void 0 !== b)
      throw new Sk.builtin.TypeError('int() can\'t convert non-string with explicit base');
    if (a instanceof Sk.builtin.lng)
      return a.cantBeInt() ? new Sk.builtin.lng(a) : new Sk.builtin.nmber(a.toInt$(), Sk.builtin.nmber.int$);
    a = Sk.builtin.asnum$(a);
    return new Sk.builtin.nmber(a | 0, Sk.builtin.nmber.int$);
  };
  Sk.builtin.int_.prototype.tp$name = 'int';
  Sk.builtin.int_.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('int', Sk.builtin.int_);
  Sk.builtin.float_ = function (a) {
    if (void 0 === a)
      return new Sk.builtin.nmber(0, Sk.builtin.nmber.float$);
    if (a instanceof Sk.builtin.str) {
      if (a.v.match(/^-inf$/i))
        a = -Infinity;
      else if (a.v.match(/^[+]?inf$/i))
        a = Infinity;
      else if (a.v.match(/^[-+]?nan$/i))
        a = NaN;
      else {
        if (isNaN(a.v))
          throw new Sk.builtin.ValueError('float: Argument: ' + a.v + ' is not number');
        a = parseFloat(a.v);
      }
      return new Sk.builtin.nmber(a, Sk.builtin.nmber.float$);
    }
    if ('number' === typeof a || a instanceof Sk.builtin.nmber || a instanceof Sk.builtin.lng)
      return a = Sk.builtin.asnum$(a), new Sk.builtin.nmber(a, Sk.builtin.nmber.float$);
    if (a instanceof Sk.builtin.bool)
      return a = Sk.builtin.asnum$(a), new Sk.builtin.nmber(a, Sk.builtin.nmber.float$);
    throw new Sk.builtin.TypeError('float() argument must be a string or a number');
  };
  Sk.builtin.float_.prototype.tp$name = 'float';
  Sk.builtin.float_.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('float', Sk.builtin.float_);
  Sk.builtin.slice = function (a, b, c) {
    a = Sk.builtin.asnum$(a);
    b = Sk.builtin.asnum$(b);
    c = Sk.builtin.asnum$(c);
    if (!(this instanceof Sk.builtin.slice))
      return new Sk.builtin.slice(a, b, c);
    void 0 === b && void 0 === c && (b = a, a = null);
    a || (a = null);
    void 0 === b && (b = null);
    void 0 === c && (c = null);
    this.start = a;
    this.stop = b;
    this.step = c;
    if (null !== this.start && !Sk.builtin.checkInt(this.start) || null !== this.stop && !Sk.builtin.checkInt(this.stop) || null !== this.step && !Sk.builtin.checkInt(this.step))
      throw new Sk.builtin.TypeError('slice indices must be integers or None');
    return this;
  };
  Sk.builtin.slice.prototype.tp$str = function () {
    var a = Sk.builtin.repr(this.start).v, b = Sk.builtin.repr(this.stop).v, c = Sk.builtin.repr(this.step).v;
    return new Sk.builtin.str('slice(' + a + ', ' + b + ', ' + c + ')');
  };
  Sk.builtin.slice.prototype.indices = function (a) {
    a = Sk.builtin.asnum$(a);
    var b = this.start, c = this.stop, d = this.step;
    null === d && (d = 1);
    0 < d ? (null === b && (b = 0), null === c && (c = a), c > a && (c = a), 0 > b && (b = a + b, 0 > b && (b = 0)), 0 > c && (c = a + c)) : (null === b && (b = a - 1), b >= a && (b = a - 1), null === c ? c = -1 : 0 > c && (c = a + c, 0 > c && (c = -1)), 0 > b && (b = a + b));
    return [
      b,
      c,
      d
    ];
  };
  Sk.builtin.slice.prototype.sssiter$ = function (a, b) {
    var c = Sk.builtin.asnum$(a), d = this.indices('number' === typeof c ? c : a.v.length);
    if (0 < d[2]) {
      var e;
      for (e = d[0]; e < d[1] && !1 !== b(e, c); e += d[2]);
    } else
      for (e = d[0]; e > d[1] && !1 !== b(e, c); e += d[2]);
  };
  Sk.builtin.set = function (a) {
    if (!(this instanceof Sk.builtin.set))
      return new Sk.builtin.set(a);
    'undefined' === typeof a && (a = []);
    this.set_reset_();
    a = new Sk.builtin.list(a).tp$iter();
    for (var b = a.tp$iternext(); void 0 !== b; b = a.tp$iternext())
      Sk.builtin.set.prototype.add.func_code(this, b);
    this.__class__ = Sk.builtin.set;
    this.v = this.v;
    return this;
  };
  Sk.builtin.set.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('set', Sk.builtin.set);
  Sk.builtin.set.prototype.set_iter_ = function () {
    return Sk.builtin.dict.prototype.keys.func_code(this.v).tp$iter();
  };
  Sk.builtin.set.prototype.set_reset_ = function () {
    this.v = new Sk.builtin.dict([]);
  };
  Sk.builtin.set.prototype.tp$name = 'set';
  Sk.builtin.set.prototype.tp$repr = function () {
    for (var a = [], b = this.tp$iter(), c = b.tp$iternext(); void 0 !== c; c = b.tp$iternext())
      a.push(Sk.misceval.objectRepr(c).v);
    return new Sk.builtin.str('set([' + a.join(', ') + '])');
  };
  Sk.builtin.set.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
  Sk.builtin.set.prototype.tp$hash = Sk.builtin.object.prototype.HashNotImplemented;
  Sk.builtin.set.prototype.tp$richcompare = function (a, b) {
    if (this === a && Sk.misceval.opAllowsEquality(b))
      return !0;
    if (!a.__class__ || a.__class__ != Sk.builtin.set)
      return 'Eq' === b ? !1 : 'NotEq' === b ? !0 : !1;
    var c = this.sq$length(), d = a.sq$length();
    if (d !== c) {
      if ('Eq' === b)
        return !1;
      if ('NotEq' === b)
        return !0;
    }
    var e = !1, f = !1;
    switch (b) {
    case 'Lt':
    case 'LtE':
    case 'Eq':
    case 'NotEq':
      e = Sk.builtin.set.prototype.issubset.func_code(this, a);
      break;
    case 'Gt':
    case 'GtE':
      f = Sk.builtin.set.prototype.issuperset.func_code(this, a);
      break;
    default:
      goog.asserts.fail();
    }
    switch (b) {
    case 'Lt':
      return c < d && e;
    case 'LtE':
    case 'Eq':
      return e;
    case 'NotEq':
      return !e;
    case 'Gt':
      return c > d && f;
    case 'GtE':
      return f;
    }
  };
  Sk.builtin.set.prototype.tp$iter = Sk.builtin.set.prototype.set_iter_;
  Sk.builtin.set.prototype.sq$length = function () {
    return this.v.mp$length();
  };
  Sk.builtin.set.prototype.isdisjoint = new Sk.builtin.func(function (a, b) {
    for (var c = a.tp$iter(), d = c.tp$iternext(); void 0 !== d; d = c.tp$iternext())
      if (Sk.abstr.sequenceContains(b, d))
        return Sk.builtin.bool.false$;
    return Sk.builtin.bool(!0);
  });
  Sk.builtin.set.prototype.issubset = new Sk.builtin.func(function (a, b) {
    var c = a.sq$length(), d = b.sq$length();
    if (c > d)
      return Sk.builtin.bool.false$;
    c = a.tp$iter();
    for (d = c.tp$iternext(); void 0 !== d; d = c.tp$iternext())
      if (!Sk.abstr.sequenceContains(b, d))
        return Sk.builtin.bool.false$;
    return Sk.builtin.bool.true$;
  });
  Sk.builtin.set.prototype.issuperset = new Sk.builtin.func(function (a, b) {
    return Sk.builtin.set.prototype.issubset.func_code(b, a);
  });
  Sk.builtin.set.prototype.union = new Sk.builtin.func(function (a) {
    for (var b = new Sk.builtin.set(a), c = 1; c < arguments.length; c++)
      Sk.builtin.set.prototype.update.func_code(b, arguments[c]);
    return b;
  });
  Sk.builtin.set.prototype.intersection = new Sk.builtin.func(function (a) {
    var b = Sk.builtin.set.prototype.copy.func_code(a);
    arguments[0] = b;
    Sk.builtin.set.prototype.intersection_update.func_code.apply(null, arguments);
    return b;
  });
  Sk.builtin.set.prototype.difference = new Sk.builtin.func(function (a, b) {
    var c = Sk.builtin.set.prototype.copy.func_code(a);
    arguments[0] = c;
    Sk.builtin.set.prototype.difference_update.func_code.apply(null, arguments);
    return c;
  });
  Sk.builtin.set.prototype.symmetric_difference = new Sk.builtin.func(function (a, b) {
    for (var c = Sk.builtin.set.prototype.union.func_code(a, b), d = c.tp$iter(), e = d.tp$iternext(); void 0 !== e; e = d.tp$iternext())
      Sk.abstr.sequenceContains(a, e) && Sk.abstr.sequenceContains(b, e) && Sk.builtin.set.prototype.discard.func_code(c, e);
    return c;
  });
  Sk.builtin.set.prototype.copy = new Sk.builtin.func(function (a) {
    return new Sk.builtin.set(a);
  });
  Sk.builtin.set.prototype.update = new Sk.builtin.func(function (a, b) {
    for (var c = b.tp$iter(), d = c.tp$iternext(); void 0 !== d; d = c.tp$iternext())
      Sk.builtin.set.prototype.add.func_code(a, d);
    return null;
  });
  Sk.builtin.set.prototype.intersection_update = new Sk.builtin.func(function (a) {
    for (var b = a.tp$iter(), c = b.tp$iternext(); void 0 !== c; c = b.tp$iternext())
      for (var d = 1; d < arguments.length; d++)
        if (!Sk.abstr.sequenceContains(arguments[d], c)) {
          Sk.builtin.set.prototype.discard.func_code(a, c);
          break;
        }
    return null;
  });
  Sk.builtin.set.prototype.difference_update = new Sk.builtin.func(function (a, b) {
    for (var c = a.tp$iter(), d = c.tp$iternext(); void 0 !== d; d = c.tp$iternext())
      for (var e = 1; e < arguments.length; e++)
        if (Sk.abstr.sequenceContains(arguments[e], d)) {
          Sk.builtin.set.prototype.discard.func_code(a, d);
          break;
        }
    return null;
  });
  Sk.builtin.set.prototype.symmetric_difference_update = new Sk.builtin.func(function (a, b) {
    var c = Sk.builtin.set.prototype.symmetric_difference.func_code(a, b);
    a.set_reset_();
    Sk.builtin.set.prototype.update.func_code(a, c);
    return null;
  });
  Sk.builtin.set.prototype.add = new Sk.builtin.func(function (a, b) {
    a.v.mp$ass_subscript(b, !0);
    return null;
  });
  Sk.builtin.set.prototype.discard = new Sk.builtin.func(function (a, b) {
    if (void 0 !== a.v.mp$lookup(b)) {
      var c = Sk.builtin.hash, c = c(b);
      void 0 !== a.v[c] && (a.v.size -= 1, delete a.v[c]);
    }
    return null;
  });
  Sk.builtin.set.prototype.pop = new Sk.builtin.func(function (a) {
    if (0 === a.sq$length())
      throw new Sk.builtin.KeyError('pop from an empty set');
    var b = a.tp$iter().tp$iternext();
    Sk.builtin.set.prototype.discard.func_code(a, b);
    return b;
  });
  Sk.builtin.set.prototype.remove = new Sk.builtin.func(function (a, b) {
    a.v.mp$del_subscript(b);
    return null;
  });
  goog.exportSymbol('Sk.builtin.set', Sk.builtin.set);
  Sk.builtin.module = function () {
  };
  goog.exportSymbol('Sk.builtin.module', Sk.builtin.module);
  Sk.builtin.module.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('module', Sk.builtin.module);
  Sk.builtin.module.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
  Sk.builtin.module.prototype.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;
  Sk.builtin.generator = function (a, b, c, d, e) {
    if (a) {
      this.func_code = a;
      this.func_globals = b || null;
      this.gi$running = !1;
      this.gi$resumeat = 0;
      this.gi$sentvalue = void 0;
      this.gi$locals = {};
      if (0 < c.length)
        for (b = 0; b < a.co_varnames.length; ++b)
          this.gi$locals[a.co_varnames[b]] = c[b];
      if (void 0 !== e)
        for (var f in e)
          d[f] = e[f];
      this.func_closure = d;
      return this;
    }
  };
  goog.exportSymbol('Sk.builtin.generator', Sk.builtin.generator);
  Sk.builtin.generator.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
  Sk.builtin.generator.prototype.tp$iter = function () {
    return this;
  };
  Sk.builtin.generator.prototype.tp$iternext = function (a) {
    this.gi$running = !0;
    void 0 === a && (a = null);
    this.gi$sentvalue = a;
    a = [this];
    this.func_closure && a.push(this.func_closure);
    a = this.func_code.apply(this.func_globals, a);
    this.gi$running = !1;
    goog.asserts.assert(void 0 !== a);
    if (null !== a)
      return this.gi$resumeat = a[0], a = a[1];
  };
  Sk.builtin.generator.prototype.next = new Sk.builtin.func(function (a) {
    return a.tp$iternext();
  });
  Sk.builtin.generator.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('generator', Sk.builtin.generator);
  Sk.builtin.generator.prototype.tp$repr = function () {
    return new Sk.builtin.str('<generator object ' + this.func_code.co_name.v + '>');
  };
  Sk.builtin.generator.prototype.send = new Sk.builtin.func(function (a, b) {
    return a.tp$iternext(b);
  });
  Sk.builtin.makeGenerator = function (a, b) {
    var c = new Sk.builtin.generator(null, null, null);
    c.tp$iternext = a;
    for (var d in b)
      b.hasOwnProperty(d) && (c[d] = b[d]);
    return c;
  };
  goog.exportSymbol('Sk.builtin.makeGenerator', Sk.builtin.makeGenerator);
  Sk.builtin.file = function (a, b, c) {
    this.mode = b;
    this.name = a;
    this.closed = !1;
    if (Sk.inBrowser) {
      b = document.getElementById(a.v);
      if (null == b)
        throw new Sk.builtin.IOError('[Errno 2] No such file or directory: \'' + a.v + '\'');
      'textarea' == b.nodeName.toLowerCase() ? this.data$ = b.value : this.data$ = b.textContent;
    } else
      this.data$ = Sk.read(a.v);
    this.lineList = this.data$.split('\n');
    this.lineList = this.lineList.slice(0, -1);
    for (var d in this.lineList)
      this.lineList[d] += '\n';
    this.pos$ = this.currentLine = 0;
    this.__class__ = Sk.builtin.file;
    return this;
  };
  Sk.builtin.file.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('file', Sk.builtin.file);
  Sk.builtin.file.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
  Sk.builtin.file.prototype.tp$repr = function () {
    return new Sk.builtin.str('<' + (this.closed ? 'closed' : 'open') + 'file \'' + this.name + '\', mode \'' + this.mode + '\'>');
  };
  Sk.builtin.file.prototype.tp$iter = function () {
    var a = {
        tp$iter: function () {
          return a;
        },
        $obj: this,
        $index: 0,
        $lines: this.lineList,
        tp$iternext: function () {
          return a.$index >= a.$lines.length ? void 0 : new Sk.builtin.str(a.$lines[a.$index++]);
        }
      };
    return a;
  };
  Sk.builtin.file.prototype.close = new Sk.builtin.func(function (a) {
    a.closed = !0;
  });
  Sk.builtin.file.prototype.flush = new Sk.builtin.func(function (a) {
  });
  Sk.builtin.file.prototype.fileno = new Sk.builtin.func(function (a) {
    return 10;
  });
  Sk.builtin.file.prototype.isatty = new Sk.builtin.func(function (a) {
    return !1;
  });
  Sk.builtin.file.prototype.read = new Sk.builtin.func(function (a, b) {
    if (a.closed)
      throw new Sk.builtin.ValueError('I/O operation on closed file');
    var c = a.data$.length;
    void 0 === b && (b = c);
    var d = new Sk.builtin.str(a.data$.substr(a.pos$, b));
    a.pos$ += b;
    a.pos$ >= c && (a.pos$ = c);
    return d;
  });
  Sk.builtin.file.prototype.readline = new Sk.builtin.func(function (a, b) {
    var c = '';
    a.currentLine < a.lineList.length && (c = a.lineList[a.currentLine], a.currentLine++);
    return new Sk.builtin.str(c);
  });
  Sk.builtin.file.prototype.readlines = new Sk.builtin.func(function (a, b) {
    for (var c = [], d = a.currentLine; d < a.lineList.length; d++)
      c.push(new Sk.builtin.str(a.lineList[d]));
    return new Sk.builtin.list(c);
  });
  Sk.builtin.file.prototype.seek = new Sk.builtin.func(function (a, b, c) {
    void 0 === c && (c = 1);
    a.pos$ = 1 == c ? b : a.data$ + b;
  });
  Sk.builtin.file.prototype.tell = new Sk.builtin.func(function (a) {
    return a.pos$;
  });
  Sk.builtin.file.prototype.truncate = new Sk.builtin.func(function (a, b) {
    goog.asserts.fail();
  });
  Sk.builtin.file.prototype.write = new Sk.builtin.func(function (a, b) {
    goog.asserts.fail();
  });
  goog.exportSymbol('Sk.builtin.file', Sk.builtin.file);
  Sk.ffi = Sk.ffi || {};
  goog.exportSymbol('Sk.ffi.AssertionError', Sk.ffi.AssertionError);
  Sk.ffi.assertionError = function (a) {
    return new Sk.builtin.AssertionError(a);
  };
  goog.exportSymbol('Sk.ffi.assertionError', Sk.ffi.assertionError);
  goog.exportSymbol('Sk.ffi.AttributeError', Sk.ffi.AttributeError);
  Sk.ffi.attributeError = function (a) {
    return new Sk.builtin.AttributeError(a);
  };
  goog.exportSymbol('Sk.ffi.attributeError', Sk.ffi.attributeError);
  goog.exportSymbol('Sk.ffi.NotImplementedError', Sk.ffi.NotImplementedError);
  Sk.ffi.notImplementedError = function (a) {
    return new Sk.builtin.NotImplementedError(a);
  };
  goog.exportSymbol('Sk.ffi.notImplementedError', Sk.ffi.notImplementedError);
  goog.exportSymbol('Sk.ffi.TypeError', Sk.ffi.TypeError);
  Sk.ffi.typeError = function (a) {
    return new Sk.builtin.TypeError(a);
  };
  goog.exportSymbol('Sk.ffi.typeError', Sk.ffi.typeError);
  Sk.ffi.JsType = {
    UNDEFINED: 'undefined',
    OBJECT: 'object',
    STRING: 'string',
    NUMBER: 'number',
    BOOLEAN: 'boolean',
    FUNCTION: 'function'
  };
  Sk.ffi.bool = {
    True: Sk.builtin.bool.true$,
    False: Sk.builtin.bool.false$
  };
  goog.exportSymbol('Sk.ffi.bool', Sk.ffi.bool);
  Sk.ffi.none = { None: Sk.builtin.none.none$ };
  goog.exportSymbol('Sk.ffi.none', Sk.ffi.none);
  Sk.ffi.booleanToPy = function (a, b) {
    var c = typeof a;
    if (c === Sk.ffi.JsType.BOOLEAN)
      return a ? Sk.ffi.bool.True : Sk.ffi.bool.False;
    if (c === Sk.ffi.JsType.OBJECT && null === a)
      return Sk.ffi.none.None;
    if (c === Sk.ffi.JsType.UNDEFINED) {
      c = typeof b;
      if (c === Sk.ffi.JsType.BOOLEAN)
        return Sk.ffi.booleanToPy(Boolean(b));
      if (c === Sk.ffi.JsType.UNDEFINED)
        return;
      if (c === Sk.ffi.JsType.OBJECT && null === b)
        return Sk.ffi.none.None;
      throw Sk.ffi.err.argument('defaultJs').inFunction('Sk.ffi.booleanToPy').mustHaveType([
        Sk.ffi.JsType.BOOLEAN,
        'null',
        Sk.ffi.JsType.UNDEFINED
      ].join(' or '));
    }
    throw Sk.ffi.err.argument('valueJs').inFunction('Sk.ffi.booleanToPy').mustHaveType([
      Sk.ffi.JsType.BOOLEAN,
      'null',
      Sk.ffi.JsType.UNDEFINED
    ].join(' or '));
  };
  goog.exportSymbol('Sk.ffi.booleanToPy', Sk.ffi.booleanToPy);
  Sk.ffi.numberToPy = function (a, b) {
    switch (b) {
    case Sk.ffi.PyType.FLOAT:
      return new Sk.builtin.nmber(a, Sk.builtin.nmber.float$);
    case Sk.ffi.PyType.INT:
      return new Sk.builtin.nmber(a, Sk.builtin.nmber.int$);
    default:
      throw Sk.ffi.assertionError('ead77baa-30b2-470a-bb18-9db949965e45, kind => ' + b);
    }
  };
  goog.exportSymbol('Sk.ffi.numberToPy', Sk.ffi.numberToPy);
  Sk.ffi.numberToFloatPy = function (a, b) {
    var c = typeof a;
    if (c === Sk.ffi.JsType.NUMBER)
      return new Sk.builtin.nmber(a, Sk.builtin.nmber.float$);
    if (c === Sk.ffi.JsType.OBJECT && null === a)
      return Sk.ffi.none.None;
    if (c === Sk.ffi.JsType.UNDEFINED) {
      c = typeof b;
      if (c === Sk.ffi.JsType.NUMBER)
        return Sk.ffi.numberToFloatPy(Number(b));
      if (c === Sk.ffi.JsType.UNDEFINED)
        return;
      if (c === Sk.ffi.JsType.OBJECT && null === b)
        return Sk.ffi.none.None;
      throw Sk.ffi.err.argument('defaultJs').inFunction('Sk.ffi.numberToFloatPy').mustHaveType([
        Sk.ffi.JsType.NUMBER,
        'null',
        Sk.ffi.JsType.UNDEFINED
      ].join(' or '));
    }
    throw Sk.ffi.err.argument('valueJs').inFunction('Sk.ffi.numberToFloatPy').mustHaveType([
      Sk.ffi.JsType.NUMBER,
      'null',
      Sk.ffi.JsType.UNDEFINED
    ].join(' or '));
  };
  goog.exportSymbol('Sk.ffi.numberToFloatPy', Sk.ffi.numberToFloatPy);
  Sk.ffi.numberToIntPy = function (a, b) {
    var c = typeof a;
    if (c === Sk.ffi.JsType.NUMBER)
      return new Sk.builtin.nmber(a, Sk.builtin.nmber.int$);
    if (c === Sk.ffi.JsType.OBJECT && null === a)
      return Sk.ffi.none.None;
    if (c === Sk.ffi.JsType.UNDEFINED) {
      c = typeof b;
      if (c === Sk.ffi.JsType.NUMBER)
        return Sk.ffi.numberToIntPy(Number(b));
      if (c === Sk.ffi.JsType.UNDEFINED)
        return;
      if (c === Sk.ffi.JsType.OBJECT && null === b)
        return Sk.ffi.none.None;
      throw Sk.ffi.err.argument('defaultJs').inFunction('Sk.ffi.numberToIntPy').mustHaveType([
        Sk.ffi.JsType.NUMBER,
        'null',
        Sk.ffi.JsType.UNDEFINED
      ].join(' or '));
    }
    throw Sk.ffi.err.argument('valueJs').inFunction('Sk.ffi.numberToIntPy').mustHaveType([
      Sk.ffi.JsType.NUMBER,
      'null',
      Sk.ffi.JsType.UNDEFINED
    ].join(' or '));
  };
  goog.exportSymbol('Sk.ffi.numberToIntPy', Sk.ffi.numberToIntPy);
  Sk.ffi.stringToPy = function (a, b) {
    var c = typeof a;
    if (c === Sk.ffi.JsType.STRING)
      return 0 < a.length ? new Sk.builtin.str(a) : Sk.builtin.str.$emptystr;
    if (c === Sk.ffi.JsType.OBJECT && null === a)
      return Sk.ffi.none.None;
    if (c === Sk.ffi.JsType.UNDEFINED) {
      c = typeof b;
      if (c === Sk.ffi.JsType.STRING)
        return Sk.ffi.stringToPy(b.toString());
      if (c === Sk.ffi.JsType.UNDEFINED)
        return;
      if (c === Sk.ffi.JsType.OBJECT && null === b)
        return Sk.ffi.none.None;
      throw Sk.ffi.err.argument('defaultJs').inFunction('Sk.ffi.stringToPy').mustHaveType([
        Sk.ffi.JsType.STRING,
        Sk.ffi.JsType.UNDEFINED,
        'null'
      ].join(' or '));
    }
    throw Sk.ffi.err.argument('valueJs').inFunction('Sk.ffi.stringToPy').mustHaveType([
      Sk.ffi.JsType.STRING,
      'null',
      Sk.ffi.JsType.UNDEFINED
    ].join(' or '));
  };
  goog.exportSymbol('Sk.ffi.stringToPy', Sk.ffi.stringToPy);
  Sk.ffi.referenceToPy = function (a, b, c, d) {
    var e = typeof a;
    if (e === Sk.ffi.JsType.OBJECT || e === Sk.ffi.JsType.FUNCTION)
      if (typeof b === Sk.ffi.JsType.STRING)
        if (d)
          d.v = a, d.tp$name = b, d.custom = c;
        else
          return {
            v: a,
            tp$name: b,
            custom: c
          };
      else
        throw Sk.ffi.assertionError('9fad4b9e-4845-4a06-9bce-0aa7c68e1f03 [className is ' + b + ']');
    else
      throw Sk.ffi.assertionError('306f31df-f0a9-40a0-895b-d01308df8d6e typeof valueJs => ' + e);
  };
  goog.exportSymbol('Sk.ffi.referenceToPy', Sk.ffi.referenceToPy);
  Sk.ffi.functionPy = function (a) {
    return new Sk.builtin.func(a);
  };
  goog.exportSymbol('Sk.ffi.functionPy', Sk.ffi.functionPy);
  Sk.ffi.listPy = function (a) {
    return new Sk.builtin.list(a);
  };
  goog.exportSymbol('Sk.ffi.listPy', Sk.ffi.listPy);
  Sk.ffi.tuplePy = function (a) {
    return new Sk.builtin.tuple(a);
  };
  goog.exportSymbol('Sk.ffi.tuplePy', Sk.ffi.tuplePy);
  Sk.ffi.remapToPy = function (a, b, c) {
    var d = typeof a;
    if (d === Sk.ffi.JsType.OBJECT) {
      if ('[object Array]' === Object.prototype.toString.call(a)) {
        var e = [];
        for (b = 0; b < a.length; ++b)
          e.push(Sk.ffi.remapToPy(a[b]));
        return Sk.ffi.listPy(e);
      }
      if (typeof b === Sk.ffi.JsType.STRING)
        return Sk.ffi.referenceToPy(a, b.toString(), c);
      if (d === Sk.ffi.JsType.OBJECT && null === a)
        return Sk.ffi.none.None;
      b = [];
      for (e in a)
        b.push(Sk.ffi.remapToPy(e)), b.push(Sk.ffi.remapToPy(a[e]));
      return new Sk.builtin.dict(b);
    }
    if (d === Sk.ffi.JsType.STRING)
      return Sk.ffi.stringToPy(a);
    if (d === Sk.ffi.JsType.NUMBER)
      return Sk.ffi.numberToFloatPy(a);
    if (d === Sk.ffi.JsType.BOOLEAN)
      return Sk.ffi.booleanToPy(a);
    if (d === Sk.ffi.JsType.FUNCTION)
      return Sk.ffi.functionPy(a);
    if (d === Sk.ffi.JsType.UNDEFINED)
      return Sk.ffi.none.None;
    throw Sk.ffi.assertionError('d39f7c01-213e-4ded-9e5c-209a2dc94b4c, typeof valueJs => ' + d);
  };
  goog.exportSymbol('Sk.ffi.remapToPy', Sk.ffi.remapToPy);
  Sk.ffi.isBool = function (a) {
    return Sk.ffi.getType(a) === Sk.ffi.PyType.BOOL;
  };
  goog.exportSymbol('Sk.ffi.isBool', Sk.ffi.isBool);
  Sk.ffi.isInstance = function (a, b) {
    if (Sk.ffi.getType(a) === Sk.ffi.PyType.INSTANCE) {
      var c = typeof b;
      if (c === Sk.ffi.JsType.STRING)
        return Sk.ffi.typeName(a) === b;
      if (c === Sk.ffi.JsType.UNDEFINED)
        return !0;
      if ('[object Array]' === Object.prototype.toString.call(b)) {
        var d = Sk.ffi.typeName(a);
        return b.some(function (a) {
          return d === a;
        });
      }
      throw Sk.ffi.assertionError('caa41602-62da-4850-8f76-38d013f45a6c, typeof className => ' + c);
    }
    return !1;
  };
  goog.exportSymbol('Sk.ffi.isInstance', Sk.ffi.isInstance);
  Sk.ffi.isDefined = function (a) {
    return Sk.ffi.getType(a) !== Sk.ffi.PyType.UNDEFINED;
  };
  goog.exportSymbol('Sk.ffi.isDefined', Sk.ffi.isDefined);
  Sk.ffi.isDict = function (a) {
    return Sk.ffi.getType(a) === Sk.ffi.PyType.DICT;
  };
  goog.exportSymbol('Sk.ffi.isDict', Sk.ffi.isDict);
  Sk.ffi.isList = function (a) {
    return Sk.ffi.getType(a) === Sk.ffi.PyType.LIST;
  };
  goog.exportSymbol('Sk.ffi.isList', Sk.ffi.isList);
  Sk.ffi.isFloat = function (a) {
    return Sk.ffi.getType(a) === Sk.ffi.PyType.FLOAT;
  };
  goog.exportSymbol('Sk.ffi.isFloat', Sk.ffi.isFloat);
  Sk.ffi.isFunction = function (a) {
    return Sk.ffi.getType(a) === Sk.ffi.PyType.FUNCTION;
  };
  goog.exportSymbol('Sk.ffi.isFunction', Sk.ffi.isFunction);
  Sk.ffi.isFunctionRef = function (a) {
    return Sk.ffi.getType(a) === Sk.ffi.PyType.FUNREF;
  };
  goog.exportSymbol('Sk.ffi.isFunctionRef', Sk.ffi.isFunctionRef);
  Sk.ffi.isInt = function (a) {
    return Sk.ffi.getType(a) === Sk.ffi.PyType.INT;
  };
  goog.exportSymbol('Sk.ffi.isInt', Sk.ffi.isInt);
  Sk.ffi.isLong = function (a) {
    return Sk.ffi.getType(a) === Sk.ffi.PyType.LONG;
  };
  goog.exportSymbol('Sk.ffi.isLong', Sk.ffi.isLong);
  Sk.ffi.isNone = function (a) {
    return Sk.ffi.getType(a) === Sk.ffi.PyType.NONE;
  };
  goog.exportSymbol('Sk.ffi.isNone', Sk.ffi.isNone);
  Sk.ffi.isNum = function (a) {
    return Sk.builtin.checkNumber(a);
  };
  goog.exportSymbol('Sk.ffi.isNum', Sk.ffi.isNum);
  Sk.ffi.isStr = function (a) {
    return Sk.builtin.checkString(a);
  };
  goog.exportSymbol('Sk.ffi.isStr', Sk.ffi.isStr);
  Sk.ffi.isUndefined = function (a) {
    return Sk.ffi.getType(a) === Sk.ffi.PyType.UNDEFINED;
  };
  goog.exportSymbol('Sk.ffi.isUndefined', Sk.ffi.isUndefined);
  Sk.ffi.checkFunctionArgs = function (a, b, c, d, e, f) {
    b = b.length;
    var g = '';
    void 0 === d && (d = Infinity);
    e && (b -= 1);
    f && (b -= 1);
    if (b < c || b > d)
      throw g = (c === d ? a + '() takes exactly ' + c + ' arguments' : b < c ? a + '() takes at least ' + c + ' arguments' : a + '() takes at most ' + d + ' arguments') + (' (' + b + ' given)'), Sk.ffi.assertionError(g);
    return b;
  };
  goog.exportSymbol('Sk.ffi.checkFunctionArgs', Sk.ffi.checkFunctionArgs);
  Sk.ffi.checkMethodArgs = function (a, b, c, d, e, f) {
    return Sk.ffi.checkFunctionArgs(a, Array.prototype.slice.call(b, 1), c, d, e, f);
  };
  goog.exportSymbol('Sk.ffi.checkMethodArgs', Sk.ffi.checkMethodArgs);
  goog.exportSymbol('Sk.ffi.SimpleType', Sk.ffi.SimpleType);
  goog.exportSymbol('Sk.ffi.UnionType', Sk.ffi.UnionType);
  Sk.ffi.checkArgType = function (a, b, c, d) {
    if (!c)
      throw Sk.ffi.err.argument(a).mustHaveType(b);
  };
  goog.exportSymbol('Sk.ffi.checkArgType', Sk.ffi.checkArgType);
  Sk.ffi.checkLhsOperandType = function (a, b, c, d) {
    if (!c)
      throw Sk.ffi.err.operand('Left').toOperation(a).mustHaveType(b);
  };
  goog.exportSymbol('Sk.ffi.checkLhsOperandType', Sk.ffi.checkLhsOperandType);
  Sk.ffi.checkRhsOperandType = function (a, b, c, d) {
    if (!c)
      throw Sk.ffi.err.operand('Right').toOperation(a).mustHaveType(b);
  };
  goog.exportSymbol('Sk.ffi.checkRhsOperandType', Sk.ffi.checkRhsOperandType);
  Sk.ffi.PyType = {
    DICT: 1,
    LIST: 2,
    TUPLE: 3,
    BOOL: 4,
    FLOAT: 5,
    INT: 6,
    LONG: 7,
    STR: 8,
    NONE: 9,
    FUNCTION: 10,
    INSTANCE: 11,
    UNDEFINED: -1,
    FUNREF: -2
  };
  Sk.ffi.typeString = function (a, b) {
    function c(a) {
      return '<type \'' + a + '\'>';
    }
    function d(a) {
      switch (a) {
      case Sk.ffi.PyType.DICT:
        return c('dict');
      case Sk.ffi.PyType.LIST:
        return c('list');
      case Sk.ffi.PyType.TUPLE:
        return c('tuple');
      case Sk.ffi.PyType.BOOL:
        return c('bool');
      case Sk.ffi.PyType.FLOAT:
        return c('float');
      case Sk.ffi.PyType.LONG:
        return c('long');
      case Sk.ffi.PyType.INT:
        return c('int');
      case Sk.ffi.PyType.STR:
        return c('str');
      case Sk.ffi.PyType.NONE:
        return c('NoneType');
      case Sk.ffi.PyType.FUNCTION:
        return c('function');
      default:
        throw Sk.ffi.assertionError('fe2aed99-3b81-4a55-b3e8-61da7e734ac1, kind => ' + a);
      }
    }
    if (typeof a === Sk.ffi.JsType.STRING)
      return '<class \'' + String(a) + '\'>';
    if (typeof a === Sk.ffi.JsType.NUMBER)
      switch (a) {
      case Sk.ffi.PyType.DICT:
      case Sk.ffi.PyType.LIST:
      case Sk.ffi.PyType.TUPLE:
      case Sk.ffi.PyType.BOOL:
      case Sk.ffi.PyType.FLOAT:
      case Sk.ffi.PyType.LONG:
      case Sk.ffi.PyType.INT:
      case Sk.ffi.PyType.STR:
      case Sk.ffi.PyType.NONE:
      case Sk.ffi.PyType.FUNCTION:
        return d(a);
      case Sk.ffi.PyType.INSTANCE:
        return '<class \'' + String(b) + '\'>';
      default:
        throw Sk.ffi.assertionError('b15da19c-b080-4695-a157-cfcb740b265b, kind => ' + a);
      }
    else {
      if ('[object Array]' === Object.prototype.toString.call(a))
        return a.map(function (a) {
          return Sk.ffi.typeString(a);
        }).join(' or ');
      throw Sk.ffi.assertionError('c32e2f75-a391-49aa-b567-b376955b4b4c, typeof kind => ' + typeof a);
    }
  };
  goog.exportSymbol('Sk.ffi.typeString', Sk.ffi.typeString);
  Sk.ffi.getType = function (a) {
    if (typeof a === Sk.ffi.JsType.UNDEFINED)
      return Sk.ffi.PyType.UNDEFINED;
    if (a instanceof Sk.builtin.dict)
      return Sk.ffi.PyType.DICT;
    if (a instanceof Sk.builtin.list)
      return Sk.ffi.PyType.LIST;
    if (a instanceof Sk.builtin.tuple)
      return Sk.ffi.PyType.TUPLE;
    if (a instanceof Sk.builtin.nmber) {
      if (a.skType === Sk.builtin.nmber.float$)
        return Sk.ffi.PyType.FLOAT;
      if (a.skType === Sk.builtin.nmber.int$)
        return Sk.ffi.PyType.INT;
      throw Sk.ffi.assertionError('typeofPy(' + a + ') (Sk.builtin.nmber) skType=' + a.skType);
    }
    if (a instanceof Sk.builtin.lng)
      return Sk.ffi.PyType.LONG;
    if (a === Sk.builtin.bool.true$ || a === Sk.builtin.bool.false$)
      return Sk.ffi.PyType.BOOL;
    if (a === Sk.ffi.none.None)
      return Sk.ffi.PyType.NONE;
    var b = typeof a.v;
    if (b !== Sk.ffi.JsType.UNDEFINED) {
      if (b === Sk.ffi.JsType.STRING)
        return Sk.ffi.PyType.STR;
      if (b === Sk.ffi.JsType.OBJECT) {
        if (a.tp$name)
          return Sk.ffi.PyType.INSTANCE;
        throw Sk.ffi.assertionError('0a459acc-9540-466b-ba1a-333f8215b61e');
      }
      if (b === Sk.ffi.JsType.FUNCTION)
        return Sk.ffi.PyType.FUNREF;
      throw Sk.ffi.assertionError('bb971bb0-3751-49bb-ac24-8dab8a4bcd29 (x:\'' + b + '\')');
    }
    return Sk.ffi.PyType.FUNCTION;
  };
  goog.exportSymbol('Sk.ffi.getType', Sk.ffi.getType);
  Sk.ffi.typeName = function (a) {
    switch (Sk.ffi.getType(a)) {
    case Sk.ffi.PyType.INSTANCE:
    case Sk.ffi.PyType.BOOL:
    case Sk.ffi.PyType.FLOAT:
    case Sk.ffi.PyType.INT:
    case Sk.ffi.PyType.STR:
      return Sk.abstr.typeName(a);
    default:
      throw Sk.ffi.assertionError('0d35490f-ac78-45d7-ac5e-af6ef09278b1, Sk.ffi.getType(valuePy) => ' + Sk.ffi.getType(a));
    }
  };
  goog.exportSymbol('Sk.ffi.typeName', Sk.ffi.typeName);
  Sk.ffi.booleanToJs = function (a, b) {
    if (a === Sk.builtin.bool.true$)
      return !0;
    if (a === Sk.builtin.bool.false$)
      return !1;
    if (typeof b === Sk.ffi.JsType.STRING)
      throw Sk.ffi.typeError(String(b));
    throw Sk.ffi.err.attribute('value').mustHaveType(Sk.ffi.PyType.BOOL);
  };
  goog.exportSymbol('Sk.ffi.booleanToJs', Sk.ffi.booleanToJs);
  Sk.ffi.numberToJs = function (a, b) {
    if (a instanceof Sk.builtin.nmber)
      return Sk.builtin.asnum$(a);
    if (typeof b === Sk.ffi.JsType.STRING)
      throw Sk.ffi.typeError(String(b));
    throw Sk.ffi.err.attribute('value').mustHaveType([
      Sk.ffi.PyType.FLOAT,
      Sk.ffi.PyType.INT,
      Sk.ffi.PyType.LONG
    ]);
  };
  goog.exportSymbol('Sk.ffi.numberToJs', Sk.ffi.numberToJs);
  Sk.ffi.remapToJs = function (a) {
    Sk.ffi.checkFunctionArgs('Sk.ffi.remapToJs', arguments, 1, 1);
    switch (Sk.ffi.getType(a)) {
    case Sk.ffi.PyType.STR:
      return a.v;
    case Sk.ffi.PyType.DICT:
      for (var b = {}, c = a.tp$iter(), d = c.tp$iternext(); void 0 !== d; d = c.tp$iternext()) {
        var e = a.mp$subscript(d);
        void 0 === e && (e = null);
        d = Sk.ffi.remapToJs(d);
        b[d] = Sk.ffi.remapToJs(e);
      }
      return b;
    case Sk.ffi.PyType.LIST:
      b = [];
      for (c = 0; c < a.v.length; ++c)
        b.push(Sk.ffi.remapToJs(a.v[c]));
      return b;
    case Sk.ffi.PyType.TUPLE:
      b = [];
      for (c = 0; c < a.v.length; ++c)
        b.push(Sk.ffi.remapToJs(a.v[c]));
      return b;
    case Sk.ffi.PyType.BOOL:
      if (a === Sk.builtin.bool.true$)
        return !0;
      if (a === Sk.builtin.bool.false$)
        return !1;
      throw Sk.ffi.assertionError('5fd1f529-f9b2-4d0c-9775-36e782973986');
    case Sk.ffi.PyType.FLOAT:
    case Sk.ffi.PyType.INT:
    case Sk.ffi.PyType.LONG:
      return Sk.builtin.asnum$(a);
    case Sk.ffi.PyType.INSTANCE:
      return a.v;
    case Sk.ffi.PyType.FUNREF:
      return a.v;
    case Sk.ffi.PyType.UNDEFINED:
      break;
    case Sk.ffi.PyType.NONE:
      return null;
    case Sk.ffi.PyType.FUNCTION:
      return function () {
        for (var b = Array.prototype.slice.call(arguments, 0).map(function (a) {
              return Sk.ffi.remapToPy(a);
            }), c = b.length, d = !1; !d;) {
          for (var d = [], e = 0; e < c; e++)
            d.push(b[e]);
          try {
            return Sk.ffi.remapToJs(Sk.misceval.apply(a, void 0, void 0, void 0, d));
          } catch (l) {
            c -= 1, d = -1 == c;
          }
        }
      };
    default:
      throw Sk.ffi.assertionError('20be4da2-63e8-4fff-9359-7ab46eba4702 ' + Sk.ffi.getType(a));
    }
  };
  goog.exportSymbol('Sk.ffi.remapToJs', Sk.ffi.remapToJs);
  Sk.ffi.buildClass = function (a, b, c, d) {
    return Sk.misceval.buildClass(a, b, c, d);
  };
  goog.exportSymbol('Sk.ffi.buildClass', Sk.ffi.buildClass);
  Sk.ffi.callsim = function (a, b) {
    b = Array.prototype.slice.call(arguments, 1);
    return Sk.misceval.apply(a, void 0, void 0, void 0, b);
  };
  goog.exportSymbol('Sk.ffi.callsim', Sk.ffi.callsim);
  Sk.ffi.callableToPy = function (a, b, c) {
    return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, e) {
      e.__init__ = Sk.ffi.functionPy(function (a) {
        Sk.ffi.referenceToPy(null, b, null, a);
      });
      e.__call__ = Sk.ffi.functionPy(c);
      e.__str__ = Sk.ffi.functionPy(function (a) {
        return Sk.ffi.stringToPy(b);
      });
      e.__repr__ = Sk.ffi.functionPy(function (a) {
        return Sk.ffi.stringToPy(b);
      });
    }, b, []));
  };
  goog.exportSymbol('Sk.ffi.callableToPy', Sk.ffi.callableToPy);
  Sk.ffi.gattr = function (a, b) {
    return Sk.abstr.gattr(a, b);
  };
  goog.exportSymbol('Sk.ffi.gattr', Sk.ffi.gattr);
  Sk.ffi.sattr = function (a, b, c) {
    return Sk.abstr.sattr(a, b, c);
  };
  goog.exportSymbol('Sk.ffi.sattr', Sk.ffi.sattr);
  Sk.ffi.indexError = function (a) {
    return new Sk.builtin.IndexError(a);
  };
  goog.exportSymbol('Sk.ffi.indexError', Sk.ffi.indexError);
  Sk.ffi.valueError = function (a) {
    return new Sk.builtin.ValueError(a);
  };
  goog.exportSymbol('Sk.ffi.valueError', Sk.ffi.valueError);
  Sk.ffi.err = {
    attribute: function (a) {
      return {
        isNotGetableOnType: function (b) {
          return Sk.ffi.attributeError(a + ' is not an attribute of ' + Sk.ffi.typeString(b));
        },
        isNotSetableOnType: function (b) {
          return Sk.ffi.attributeError(a + ' is not an attribute of ' + Sk.ffi.typeString(b));
        }
      };
    },
    argument: function (a) {
      return {
        inFunction: function (b) {
          return {
            mustHaveType: function (c) {
              return Sk.ffi.typeError('Expecting argument \'' + a + '\' in function \'' + b + '\' to have type ' + Sk.ffi.typeString(c) + '.');
            }
          };
        },
        mustHaveType: function (b) {
          return Sk.ffi.typeError(a + ' must be a ' + Sk.ffi.typeString(b));
        }
      };
    },
    operand: function (a) {
      return {
        toOperation: function (b) {
          return {
            mustHaveType: function (c) {
              return Sk.ffi.typeError('Expecting operand \'' + a + '\' to operation \'' + b + '\' to have type ' + Sk.ffi.typeString(c) + '.');
            }
          };
        }
      };
    }
  };
  goog.exportSymbol('Sk.ffi.err', Sk.ffi.err);
  Sk.ffi.callback = function (a) {
    return Sk.ffi.remapToJs(a);
  };
  goog.exportSymbol('Sk.ffi.callback', Sk.ffi.callback);
  Sk.ffi.stdwrap = function (a, b) {
    var c = new a();
    c.v = b;
    return c;
  };
  goog.exportSymbol('Sk.ffi.stdwrap', Sk.ffi.stdwrap);
  Sk.ffi.basicwrap = function (a) {
    return Sk.ffi.remapToPy(a);
  };
  goog.exportSymbol('Sk.ffi.basicwrap', Sk.ffi.basicwrap);
  Sk.ffi.unwrapo = function (a) {
    return Sk.ffi.remapToJs(a);
  };
  goog.exportSymbol('Sk.ffi.unwrapo', Sk.ffi.unwrapo);
  Sk.ffi.unwrapn = function (a) {
    return Sk.ffi.remapToJs(a);
  };
  goog.exportSymbol('Sk.ffi.unwrapn', Sk.ffi.unwrapn);
  Sk.ffh = Sk.ffh || {};
  var SPECIAL_METHOD_ADD = '__add__', SPECIAL_METHOD_CLIFFORD_CONJUGATE = '__cliffordConjugate__', SPECIAL_METHOD_CONJUGATE = '__conjugate__', SPECIAL_METHOD_DIV = '__div__', SPECIAL_METHOD_EQ = '__eq__', SPECIAL_METHOD_COS = '__cos__', SPECIAL_METHOD_EXP = '__exp__', SPECIAL_METHOD_GETITEM = '__getitem__', SPECIAL_METHOD_INVERT = '__invert__', SPECIAL_METHOD_LSHIFT = '__lshift__', SPECIAL_METHOD_MUL = '__mul__', SPECIAL_METHOD_NEG = '__neg__', SPECIAL_METHOD_NONZERO = '__nonzero__', SPECIAL_METHOD_POS = '__pos__', SPECIAL_METHOD_REPR = '__repr__', SPECIAL_METHOD_RMUL = '__rmul__', SPECIAL_METHOD_RSHIFT = '__rshift__', SPECIAL_METHOD_SIN = '__sin__', SPECIAL_METHOD_SQRT = '__sqrt__', SPECIAL_METHOD_STR = '__str__', SPECIAL_METHOD_SUB = '__sub__', SPECIAL_METHOD_XOR = '__xor__';
  Sk.ffh.unaryExec = function (a, b, c) {
    if (b[a])
      return Sk.ffi.callsim(b[a], b);
    if ('undefined' !== typeof c && b[c])
      return b[c].call(b);
    throw Sk.ffi.notImplementedError(a);
  };
  goog.exportSymbol('Sk.ffh.unaryExec', Sk.ffh.unaryExec);
  Sk.ffh.binaryExec = function (a, b, c, d) {
    if (b[a])
      return Sk.ffi.callsim(b[a], b, c);
    if ('undefined' !== typeof d && b[d])
      return b[d].call(b, c);
    throw Sk.ffi.notImplementedError(a);
  };
  goog.exportSymbol('Sk.ffh.binaryExec', Sk.ffh.binaryExec);
  Sk.ffh.getitem = function (a, b) {
    if (a[SPECIAL_METHOD_GETITEM])
      return Sk.ffi.callsim(a[SPECIAL_METHOD_GETITEM], a, Sk.ffi.numberToIntPy(b));
    throw Sk.ffi.notImplementedError(SPECIAL_METHOD_GETITEM);
  };
  goog.exportSymbol('Sk.ffh.getitem', Sk.ffh.getitem);
  Sk.ffh.add = function (a, b) {
    if (a.__add__)
      return Sk.ffi.callsim(a.__add__, a, b);
    if (a.nb$add)
      return a.nb$add.call(a, b);
    throw Sk.ffi.notImplementedError('add');
  };
  goog.exportSymbol('Sk.ffh.add', Sk.ffh.add);
  Sk.ffh.subtract = function (a, b) {
    return Sk.ffh.binaryExec(SPECIAL_METHOD_SUB, a, b, 'nb$subtract');
  };
  goog.exportSymbol('Sk.ffh.subtract', Sk.ffh.subtract);
  Sk.ffh.multiply = function (a, b) {
    return Sk.ffh.binaryExec(SPECIAL_METHOD_MUL, a, b, 'nb$multiply');
  };
  goog.exportSymbol('Sk.ffh.multiply', Sk.ffh.multiply);
  Sk.ffh.rmultiply = function (a, b) {
    return Sk.ffh.binaryExec(SPECIAL_METHOD_RMUL, a, b, 'nb$multiply');
  };
  goog.exportSymbol('Sk.ffh.rmultiply', Sk.ffh.rmultiply);
  Sk.ffh.divide = function (a, b) {
    return Sk.ffh.binaryExec(SPECIAL_METHOD_DIV, a, b, 'nb$divide');
  };
  goog.exportSymbol('Sk.ffh.divide', Sk.ffh.divide);
  Sk.ffh.xor = function (a, b) {
    return Sk.ffh.binaryExec(SPECIAL_METHOD_XOR, a, b, 'nb$xor');
  };
  goog.exportSymbol('Sk.ffh.xor', Sk.ffh.xor);
  Sk.ffh.lshift = function (a, b) {
    return Sk.ffh.binaryExec(SPECIAL_METHOD_LSHIFT, a, b, 'nb$lshift');
  };
  goog.exportSymbol('Sk.ffh.lshift', Sk.ffh.lshift);
  Sk.ffh.rshift = function (a, b) {
    return Sk.ffh.binaryExec(SPECIAL_METHOD_RSHIFT, a, b, 'nb$rshift');
  };
  goog.exportSymbol('Sk.ffh.rshift', Sk.ffh.rshift);
  Sk.ffh.equal = function (a, b) {
    if (a[SPECIAL_METHOD_EQ])
      return Sk.ffi.callsim(a[SPECIAL_METHOD_EQ], a, b);
    throw Sk.ffi.notImplementedError('equal(' + Sk.ffh.repr(a) + ', ' + Sk.ffh.repr(b) + ')');
  };
  goog.exportSymbol('Sk.ffh.equal', Sk.ffh.equal);
  Sk.ffh.cliffordConjugate = function (a) {
    return Sk.ffh.unaryExec(SPECIAL_METHOD_CLIFFORD_CONJUGATE, a, 'nb$cliffordConjugate');
  };
  goog.exportSymbol('Sk.ffh.cliffordConjugate', Sk.ffh.cliffordConjugate);
  Sk.ffh.conjugate = function (a) {
    return Sk.ffi.isNum(a) ? a : Sk.ffh.unaryExec(SPECIAL_METHOD_CONJUGATE, a);
  };
  goog.exportSymbol('Sk.ffh.conjugate', Sk.ffh.conjugate);
  Sk.ffh.cos = function (a) {
    return Sk.ffh.unaryExec(SPECIAL_METHOD_COS, a, 'nb$cos');
  };
  goog.exportSymbol('Sk.ffh.cos', Sk.ffh.cos);
  Sk.ffh.sin = function (a) {
    return Sk.ffh.unaryExec(SPECIAL_METHOD_SIN, a, 'nb$sin');
  };
  goog.exportSymbol('Sk.ffh.sin', Sk.ffh.sin);
  Sk.ffh.exp = function (a) {
    return Sk.ffh.unaryExec(SPECIAL_METHOD_EXP, a, 'nb$exp');
  };
  goog.exportSymbol('Sk.ffh.exp', Sk.ffh.exp);
  Sk.ffh.positive = function (a) {
    return Sk.ffh.unaryExec(SPECIAL_METHOD_POS, a, 'nb$positive');
  };
  goog.exportSymbol('Sk.ffh.positive', Sk.ffh.positive);
  Sk.ffh.negative = function (a) {
    return Sk.ffh.unaryExec(SPECIAL_METHOD_NEG, a, 'nb$negative');
  };
  goog.exportSymbol('Sk.ffh.negative', Sk.ffh.negative);
  Sk.ffh.invert = function (a) {
    return Sk.ffh.unaryExec(SPECIAL_METHOD_INVERT, a, 'nb$invert');
  };
  goog.exportSymbol('Sk.ffh.invert', Sk.ffh.invert);
  Sk.ffh.nonzero = function (a) {
    return Sk.ffh.unaryExec(SPECIAL_METHOD_NONZERO, a, 'nb$nonzero');
  };
  goog.exportSymbol('Sk.ffh.nonzero', Sk.ffh.nonzero);
  Sk.ffh.sqrt = function (a) {
    return Sk.ffh.unaryExec(SPECIAL_METHOD_SQRT, a);
  };
  goog.exportSymbol('Sk.ffh.sqrt', Sk.ffh.sqrt);
  Sk.ffh.str = function (a) {
    if (a[SPECIAL_METHOD_STR])
      return Sk.ffi.callsim(a[SPECIAL_METHOD_STR], a);
    if (a.tp$str)
      return a.tp$str.call(a);
    if (a.tp$repr)
      return a.tp$repr.call(a);
    throw Sk.ffi.notImplementedError('str');
  };
  goog.exportSymbol('Sk.ffh.str', Sk.ffh.str);
  Sk.ffh.repr = function (a) {
    return Sk.ffh.unaryExec(SPECIAL_METHOD_REPR, a, 'tp$repr');
  };
  goog.exportSymbol('Sk.ffh.repr', Sk.ffh.repr);
  Sk.ffh.evaluate = function (a, b) {
    return Sk.ffi.isFloat(a) || Sk.ffi.isInt(a) || Sk.ffi.isLong(a) ? a : Sk.ffi.callsim(Sk.ffi.gattr(a, 'evaluate'), b);
  };
  goog.exportSymbol('Sk.ffh.evaluate', Sk.ffh.evaluate);
  Sk.builtin.enumerate = function (a, b) {
    if (!(this instanceof Sk.builtin.enumerate))
      return new Sk.builtin.enumerate(a, b);
    Sk.builtin.pyCheckArgs('enumerate', arguments, 1, 2);
    if (!Sk.builtin.checkIterable(a))
      throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(a) + '\' object is not iterable');
    if (void 0 !== b)
      if (Sk.misceval.isIndex(b))
        b = Sk.misceval.asIndex(b);
      else
        throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(b) + '\' object cannot be interpreted as an index');
    else
      b = 0;
    var c = a.tp$iter();
    this.tp$iter = function () {
      return this;
    };
    this.$index = b;
    this.tp$iternext = function () {
      var a = c.tp$iternext();
      return void 0 === a ? void 0 : new Sk.builtin.tuple([
        this.$index++,
        a
      ]);
    };
    this.__class__ = Sk.builtin.enumerate;
    return this;
  };
  Sk.builtin.enumerate.prototype.tp$name = 'enumerate';
  Sk.builtin.enumerate.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('enumerate', Sk.builtin.enumerate);
  Sk.builtin.enumerate.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
  Sk.builtin.enumerate.prototype.__iter__ = new Sk.builtin.func(function (a) {
    return a.tp$iter();
  });
  Sk.builtin.enumerate.prototype.next = new Sk.builtin.func(function (a) {
    return a.tp$iternext();
  });
  Sk.Tokenizer = function (a, b, c) {
    this.filename = a;
    this.callback = c;
    this.parenlev = this.lnum = 0;
    this.continued = !1;
    this.namechars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_';
    this.numchars = '0123456789';
    this.contstr = '';
    this.needcont = !1;
    this.contline = void 0;
    this.indents = [0];
    this.endprog = /.*/;
    this.strstart = [
      -1,
      -1
    ];
    this.interactive = b;
    this.doneFunc = function () {
      for (var a = 1; a < this.indents.length; ++a)
        if (this.callback(Sk.Tokenizer.Tokens.T_DEDENT, '', [
            this.lnum,
            0
          ], [
            this.lnum,
            0
          ], ''))
          return 'done';
      return this.callback(Sk.Tokenizer.Tokens.T_ENDMARKER, '', [
        this.lnum,
        0
      ], [
        this.lnum,
        0
      ], '') ? 'done' : 'failed';
    };
  };
  Sk.Tokenizer.Tokens = {
    T_ENDMARKER: 0,
    T_NAME: 1,
    T_NUMBER: 2,
    T_STRING: 3,
    T_NEWLINE: 4,
    T_INDENT: 5,
    T_DEDENT: 6,
    T_LPAR: 7,
    T_RPAR: 8,
    T_LSQB: 9,
    T_RSQB: 10,
    T_COLON: 11,
    T_COMMA: 12,
    T_SEMI: 13,
    T_PLUS: 14,
    T_MINUS: 15,
    T_STAR: 16,
    T_SLASH: 17,
    T_VBAR: 18,
    T_AMPER: 19,
    T_LESS: 20,
    T_GREATER: 21,
    T_EQUAL: 22,
    T_DOT: 23,
    T_PERCENT: 24,
    T_BACKQUOTE: 25,
    T_LBRACE: 26,
    T_RBRACE: 27,
    T_EQEQUAL: 28,
    T_NOTEQUAL: 29,
    T_LESSEQUAL: 30,
    T_GREATEREQUAL: 31,
    T_TILDE: 32,
    T_CIRCUMFLEX: 33,
    T_LEFTSHIFT: 34,
    T_RIGHTSHIFT: 35,
    T_DOUBLESTAR: 36,
    T_PLUSEQUAL: 37,
    T_MINEQUAL: 38,
    T_STAREQUAL: 39,
    T_SLASHEQUAL: 40,
    T_PERCENTEQUAL: 41,
    T_AMPEREQUAL: 42,
    T_VBAREQUAL: 43,
    T_CIRCUMFLEXEQUAL: 44,
    T_LEFTSHIFTEQUAL: 45,
    T_RIGHTSHIFTEQUAL: 46,
    T_DOUBLESTAREQUAL: 47,
    T_DOUBLESLASH: 48,
    T_DOUBLESLASHEQUAL: 49,
    T_AT: 50,
    T_OP: 51,
    T_COMMENT: 52,
    T_NL: 53,
    T_RARROW: 54,
    T_ERRORTOKEN: 55,
    T_N_TOKENS: 56,
    T_NT_OFFSET: 256
  };
  function group(a) {
    return '(' + Array.prototype.slice.call(arguments).join('|') + ')';
  }
  function any(a) {
    return group.apply(null, arguments) + '*';
  }
  function maybe(a) {
    return group.apply(null, arguments) + '?';
  }
  var Whitespace = '[ \\f\\t]*', Comment_ = '#[^\\r\\n]*', Ident = '[a-zA-Z_]\\w*', Binnumber = '0[bB][01]*', Hexnumber = '0[xX][\\da-fA-F]*[lL]?', Octnumber = '0[oO]?[0-7]*[lL]?', Decnumber = '[1-9]\\d*[lL]?', Intnumber = group(Binnumber, Hexnumber, Octnumber, Decnumber), Exponent = '[eE][-+]?\\d+', Pointfloat = group('\\d+\\.\\d*', '\\.\\d+') + maybe(Exponent), Expfloat = '\\d+' + Exponent, Floatnumber = group(Pointfloat, Expfloat), Imagnumber = group('\\d+[jJ]', Floatnumber + '[jJ]'), Number_ = group(Imagnumber, Floatnumber, Intnumber), Single = '^[^\'\\\\]*(?:\\\\.[^\'\\\\]*)*\'', Double_ = '^[^"\\\\]*(?:\\\\.[^"\\\\]*)*"', Single3 = '[^\'\\\\]*(?:(?:\\\\.|\'(?!\'\'))[^\'\\\\]*)*\'\'\'', Double3 = '[^"\\\\]*(?:(?:\\\\.|"(?!""))[^"\\\\]*)*"""', Triple = group('[ubUB]?[rR]?\'\'\'', '[ubUB]?[rR]?"""'), String_ = group('[uU]?[rR]?\'[^\\n\'\\\\]*(?:\\\\.[^\\n\'\\\\]*)*\'', '[uU]?[rR]?"[^\\n"\\\\]*(?:\\\\.[^\\n"\\\\]*)*"'), Operator = group('\\*\\*=?', '>>=?', '<<=?', '<>', '!=', '//=?', '->', '[+\\-*/%&|^=<>]=?', '~'), Bracket = '[\\][(){}]', Special = group('\\r?\\n', '[:;.,`@]'), Funny = group(Operator, Bracket, Special), ContStr = group('[uUbB]?[rR]?\'[^\\n\'\\\\]*(?:\\\\.[^\\n\'\\\\]*)*' + group('\'', '\\\\\\r?\\n'), '[uUbB]?[rR]?"[^\\n"\\\\]*(?:\\\\.[^\\n"\\\\]*)*' + group('"', '\\\\\\r?\\n')), PseudoExtras = group('\\\\\\r?\\n', Comment_, Triple), PseudoToken = '^' + group(PseudoExtras, Number_, Funny, ContStr, Ident), pseudoprog, single3prog, double3prog, endprogs = {}, triple_quoted = {
      '\'\'\'': !0,
      '"""': !0,
      'r\'\'\'': !0,
      'r"""': !0,
      'R\'\'\'': !0,
      'R"""': !0,
      'u\'\'\'': !0,
      'u"""': !0,
      'U\'\'\'': !0,
      'U"""': !0,
      'b\'\'\'': !0,
      'b"""': !0,
      'B\'\'\'': !0,
      'B"""': !0,
      'ur\'\'\'': !0,
      'ur"""': !0,
      'Ur\'\'\'': !0,
      'Ur"""': !0,
      'uR\'\'\'': !0,
      'uR"""': !0,
      'UR\'\'\'': !0,
      'UR"""': !0,
      'br\'\'\'': !0,
      'br"""': !0,
      'Br\'\'\'': !0,
      'Br"""': !0,
      'bR\'\'\'': !0,
      'bR"""': !0,
      'BR\'\'\'': !0,
      'BR"""': !0
    }, single_quoted = {
      '\'': !0,
      '"': !0,
      'r\'': !0,
      'r"': !0,
      'R\'': !0,
      'R"': !0,
      'u\'': !0,
      'u"': !0,
      'U\'': !0,
      'U"': !0,
      'b\'': !0,
      'b"': !0,
      'B\'': !0,
      'B"': !0,
      'ur\'': !0,
      'ur"': !0,
      'Ur\'': !0,
      'Ur"': !0,
      'uR\'': !0,
      'uR"': !0,
      'UR\'': !0,
      'UR"': !0,
      'br\'': !0,
      'br"': !0,
      'Br\'': !0,
      'Br"': !0,
      'bR\'': !0,
      'bR"': !0,
      'BR\'': !0,
      'BR"': !0
    };
  (function () {
    for (var a in triple_quoted);
    for (a in single_quoted);
  }());
  var tabsize = 8;
  function contains(a, b) {
    for (var c = a.length; c--;)
      if (a[c] === b)
        return !0;
    return !1;
  }
  function rstrip(a, b) {
    for (var c = a.length; 0 < c && -1 !== b.indexOf(a.charAt(c - 1)); --c);
    return a.substring(0, c);
  }
  Sk.Tokenizer.prototype.generateTokens = function (a) {
    var b, c, d, e, f, g = RegExp(PseudoToken);
    c = RegExp(Single3, 'g');
    f = RegExp(Double3, 'g');
    var h = {
        '\'': RegExp(Single, 'g'),
        '"': RegExp(Double_, 'g'),
        '\'\'\'': c,
        '"""': f,
        'r\'\'\'': c,
        'r"""': f,
        'u\'\'\'': c,
        'u"""': f,
        'b\'\'\'': c,
        'b"""': f,
        'ur\'\'\'': c,
        'ur"""': f,
        'br\'\'\'': c,
        'br"""': f,
        'R\'\'\'': c,
        'R"""': f,
        'U\'\'\'': c,
        'U"""': f,
        'B\'\'\'': c,
        'B"""': f,
        'uR\'\'\'': c,
        'uR"""': f,
        'Ur\'\'\'': c,
        'Ur"""': f,
        'UR\'\'\'': c,
        'UR"""': f,
        'bR\'\'\'': c,
        'bR"""': f,
        'Br\'\'\'': c,
        'Br"""': f,
        'BR\'\'\'': c,
        'BR"""': f,
        r: null,
        R: null,
        u: null,
        U: null,
        b: null,
        B: null
      };
    a || (a = '');
    this.lnum += 1;
    c = 0;
    f = a.length;
    if (0 < this.contstr.length) {
      if (!a)
        throw new Sk.builtin.TokenError('EOF in multi-line string', this.filename, this.strstart[0], this.strstart[1], this.contline);
      this.endprog.lastIndex = 0;
      if (b = this.endprog.test(a)) {
        c = e = this.endprog.lastIndex;
        if (this.callback(Sk.Tokenizer.Tokens.T_STRING, this.contstr + a.substring(0, e), this.strstart, [
            this.lnum,
            e
          ], this.contline + a))
          return 'done';
        this.contstr = '';
        this.needcont = !1;
        this.contline = void 0;
      } else {
        if (this.needcont && '\\\n' !== a.substring(a.length - 2) && '\\\r\n' !== a.substring(a.length - 3)) {
          if (this.callback(Sk.Tokenizer.Tokens.T_ERRORTOKEN, this.contstr + a, this.strstart, [
              this.lnum,
              a.length
            ], this.contline))
            return 'done';
          this.contstr = '';
          this.contline = void 0;
        } else
          this.contstr += a, this.contline += a;
        return !1;
      }
    } else if (0 !== this.parenlev || this.continued) {
      if (!a)
        throw new Sk.builtin.TokenError('EOF in multi-line statement', this.filename, this.lnum, 0, a);
      this.continued = !1;
    } else {
      if (!a)
        return this.doneFunc();
      for (d = 0; c < f;) {
        if (' ' === a.charAt(c))
          d += 1;
        else if ('\t' === a.charAt(c))
          d = (d / tabsize + 1) * tabsize;
        else if ('\f' === a.charAt(c))
          d = 0;
        else
          break;
        c += 1;
      }
      if (c === f)
        return this.doneFunc();
      if (-1 !== '#\r\n'.indexOf(a.charAt(c))) {
        if ('#' === a.charAt(c))
          return g = rstrip(a.substring(c), '\r\n'), f = c + g.length, this.callback(Sk.Tokenizer.Tokens.T_COMMENT, g, [
            this.lnum,
            c
          ], [
            this.lnum,
            c + g.length
          ], a) || this.callback(Sk.Tokenizer.Tokens.T_NL, a.substring(f), [
            this.lnum,
            f
          ], [
            this.lnum,
            a.length
          ], a) ? 'done' : !1;
        if (this.callback(Sk.Tokenizer.Tokens.T_NL, a.substring(c), [
            this.lnum,
            c
          ], [
            this.lnum,
            a.length
          ], a))
          return 'done';
        if (!this.interactive)
          return !1;
      }
      if (d > this.indents[this.indents.length - 1] && (this.indents.push(d), this.callback(Sk.Tokenizer.Tokens.T_INDENT, a.substring(0, c), [
          this.lnum,
          0
        ], [
          this.lnum,
          c
        ], a)))
        return 'done';
      for (; d < this.indents[this.indents.length - 1];) {
        if (!contains(this.indents, d))
          throw new Sk.builtin.IndentationError('unindent does not match any outer indentation level', this.filename, this.lnum, c, a);
        this.indents.splice(this.indents.length - 1, 1);
        if (this.callback(Sk.Tokenizer.Tokens.T_DEDENT, '', [
            this.lnum,
            c
          ], [
            this.lnum,
            c
          ], a))
          return 'done';
      }
    }
    for (; c < f;) {
      for (d = a.charAt(c); ' ' === d || '\f' === d || '\t' === d;)
        c += 1, d = a.charAt(c);
      g.lastIndex = 0;
      var k = g.exec(a.substring(c));
      if (k) {
        d = c;
        e = d + k[1].length;
        k = [
          this.lnum,
          d
        ];
        b = [
          this.lnum,
          e
        ];
        c = e;
        e = a.substring(d, e);
        var l = a.charAt(d);
        if (-1 !== this.numchars.indexOf(l) || '.' === l && '.' !== e) {
          if (this.callback(Sk.Tokenizer.Tokens.T_NUMBER, e, k, b, a))
            return 'done';
        } else if ('\r' === l || '\n' === l) {
          if (d = Sk.Tokenizer.Tokens.T_NEWLINE, 0 < this.parenlev && (d = Sk.Tokenizer.Tokens.T_NL), this.callback(d, e, k, b, a))
            return 'done';
        } else if ('#' === l) {
          if (this.callback(Sk.Tokenizer.Tokens.T_COMMENT, e, k, b, a))
            return 'done';
        } else if (triple_quoted.hasOwnProperty(e))
          if (this.endprog = h[e], this.endprog.lastIndex = 0, b = this.endprog.test(a.substring(c))) {
            if (c = this.endprog.lastIndex + c, e = a.substring(d, c), this.callback(Sk.Tokenizer.Tokens.T_STRING, e, k, [
                this.lnum,
                c
              ], a))
              return 'done';
          } else {
            this.strstart = [
              this.lnum,
              d
            ];
            this.contstr = a.substring(d);
            this.contline = a;
            break;
          }
        else if (single_quoted.hasOwnProperty(l) || single_quoted.hasOwnProperty(e.substring(0, 2)) || single_quoted.hasOwnProperty(e.substring(0, 3)))
          if ('\n' === e[e.length - 1]) {
            this.strstart = [
              this.lnum,
              d
            ];
            this.endprog = h[l] || h[e[1]] || h[e[2]];
            this.contstr = a.substring(d);
            this.needcont = !0;
            this.contline = a;
            break;
          } else {
            if (this.callback(Sk.Tokenizer.Tokens.T_STRING, e, k, b, a))
              return 'done';
          }
        else if (-1 !== this.namechars.indexOf(l)) {
          if (this.callback(Sk.Tokenizer.Tokens.T_NAME, e, k, b, a))
            return 'done';
        } else if ('\\' === l) {
          if (this.callback(Sk.Tokenizer.Tokens.T_NL, e, k, [
              this.lnum,
              c
            ], a))
            return 'done';
          this.continued = !0;
        } else if (-1 !== '([{'.indexOf(l) ? this.parenlev += 1 : -1 !== ')]}'.indexOf(l) && (this.parenlev -= 1), this.callback(Sk.Tokenizer.Tokens.T_OP, e, k, b, a))
          return 'done';
      } else {
        if (this.callback(Sk.Tokenizer.Tokens.T_ERRORTOKEN, a.charAt(c), [
            this.lnum,
            c
          ], [
            this.lnum,
            c + 1
          ], a))
          return 'done';
        c += 1;
      }
    }
    return !1;
  };
  Sk.Tokenizer.tokenNames = {
    0: 'T_ENDMARKER',
    1: 'T_NAME',
    2: 'T_NUMBER',
    3: 'T_STRING',
    4: 'T_NEWLINE',
    5: 'T_INDENT',
    6: 'T_DEDENT',
    7: 'T_LPAR',
    8: 'T_RPAR',
    9: 'T_LSQB',
    10: 'T_RSQB',
    11: 'T_COLON',
    12: 'T_COMMA',
    13: 'T_SEMI',
    14: 'T_PLUS',
    15: 'T_MINUS',
    16: 'T_STAR',
    17: 'T_SLASH',
    18: 'T_VBAR',
    19: 'T_AMPER',
    20: 'T_LESS',
    21: 'T_GREATER',
    22: 'T_EQUAL',
    23: 'T_DOT',
    24: 'T_PERCENT',
    25: 'T_BACKQUOTE',
    26: 'T_LBRACE',
    27: 'T_RBRACE',
    28: 'T_EQEQUAL',
    29: 'T_NOTEQUAL',
    30: 'T_LESSEQUAL',
    31: 'T_GREATEREQUAL',
    32: 'T_TILDE',
    33: 'T_CIRCUMFLEX',
    34: 'T_LEFTSHIFT',
    35: 'T_RIGHTSHIFT',
    36: 'T_DOUBLESTAR',
    37: 'T_PLUSEQUAL',
    38: 'T_MINEQUAL',
    39: 'T_STAREQUAL',
    40: 'T_SLASHEQUAL',
    41: 'T_PERCENTEQUAL',
    42: 'T_AMPEREQUAL',
    43: 'T_VBAREQUAL',
    44: 'T_CIRCUMFLEXEQUAL',
    45: 'T_LEFTSHIFTEQUAL',
    46: 'T_RIGHTSHIFTEQUAL',
    47: 'T_DOUBLESTAREQUAL',
    48: 'T_DOUBLESLASH',
    49: 'T_DOUBLESLASHEQUAL',
    50: 'T_AT',
    51: 'T_OP',
    52: 'T_COMMENT',
    53: 'T_NL',
    54: 'T_RARROW',
    55: 'T_ERRORTOKEN',
    56: 'T_N_TOKENS',
    256: 'T_NT_OFFSET'
  };
  goog.exportSymbol('Sk.Tokenizer', Sk.Tokenizer);
  goog.exportSymbol('Sk.Tokenizer.prototype.generateTokens', Sk.Tokenizer.prototype.generateTokens);
  goog.exportSymbol('Sk.Tokenizer.tokenNames', Sk.Tokenizer.tokenNames);
  Sk.OpMap = {
    '(': Sk.Tokenizer.Tokens.T_LPAR,
    ')': Sk.Tokenizer.Tokens.T_RPAR,
    '[': Sk.Tokenizer.Tokens.T_LSQB,
    ']': Sk.Tokenizer.Tokens.T_RSQB,
    ':': Sk.Tokenizer.Tokens.T_COLON,
    ',': Sk.Tokenizer.Tokens.T_COMMA,
    ';': Sk.Tokenizer.Tokens.T_SEMI,
    '+': Sk.Tokenizer.Tokens.T_PLUS,
    '-': Sk.Tokenizer.Tokens.T_MINUS,
    '*': Sk.Tokenizer.Tokens.T_STAR,
    '/': Sk.Tokenizer.Tokens.T_SLASH,
    '|': Sk.Tokenizer.Tokens.T_VBAR,
    '&': Sk.Tokenizer.Tokens.T_AMPER,
    '<': Sk.Tokenizer.Tokens.T_LESS,
    '>': Sk.Tokenizer.Tokens.T_GREATER,
    '=': Sk.Tokenizer.Tokens.T_EQUAL,
    '.': Sk.Tokenizer.Tokens.T_DOT,
    '%': Sk.Tokenizer.Tokens.T_PERCENT,
    '`': Sk.Tokenizer.Tokens.T_BACKQUOTE,
    '{': Sk.Tokenizer.Tokens.T_LBRACE,
    '}': Sk.Tokenizer.Tokens.T_RBRACE,
    '@': Sk.Tokenizer.Tokens.T_AT,
    '==': Sk.Tokenizer.Tokens.T_EQEQUAL,
    '!=': Sk.Tokenizer.Tokens.T_NOTEQUAL,
    '<>': Sk.Tokenizer.Tokens.T_NOTEQUAL,
    '<=': Sk.Tokenizer.Tokens.T_LESSEQUAL,
    '>=': Sk.Tokenizer.Tokens.T_GREATEREQUAL,
    '~': Sk.Tokenizer.Tokens.T_TILDE,
    '^': Sk.Tokenizer.Tokens.T_CIRCUMFLEX,
    '<<': Sk.Tokenizer.Tokens.T_LEFTSHIFT,
    '>>': Sk.Tokenizer.Tokens.T_RIGHTSHIFT,
    '**': Sk.Tokenizer.Tokens.T_DOUBLESTAR,
    '+=': Sk.Tokenizer.Tokens.T_PLUSEQUAL,
    '-=': Sk.Tokenizer.Tokens.T_MINEQUAL,
    '*=': Sk.Tokenizer.Tokens.T_STAREQUAL,
    '/=': Sk.Tokenizer.Tokens.T_SLASHEQUAL,
    '%=': Sk.Tokenizer.Tokens.T_PERCENTEQUAL,
    '&=': Sk.Tokenizer.Tokens.T_AMPEREQUAL,
    '|=': Sk.Tokenizer.Tokens.T_VBAREQUAL,
    '^=': Sk.Tokenizer.Tokens.T_CIRCUMFLEXEQUAL,
    '<<=': Sk.Tokenizer.Tokens.T_LEFTSHIFTEQUAL,
    '>>=': Sk.Tokenizer.Tokens.T_RIGHTSHIFTEQUAL,
    '**=': Sk.Tokenizer.Tokens.T_DOUBLESTAREQUAL,
    '//': Sk.Tokenizer.Tokens.T_DOUBLESLASH,
    '//=': Sk.Tokenizer.Tokens.T_DOUBLESLASHEQUAL,
    '->': Sk.Tokenizer.Tokens.T_RARROW
  };
  Sk.ParseTables = {
    sym: {
      and_expr: 257,
      and_test: 258,
      arglist: 259,
      argument: 260,
      arith_expr: 261,
      assert_stmt: 262,
      atom: 263,
      augassign: 264,
      break_stmt: 265,
      classdef: 266,
      comp_op: 267,
      comparison: 268,
      compound_stmt: 269,
      continue_stmt: 270,
      decorated: 271,
      decorator: 272,
      decorators: 273,
      del_stmt: 274,
      dictmaker: 275,
      dotted_as_name: 276,
      dotted_as_names: 277,
      dotted_name: 278,
      encoding_decl: 279,
      eval_input: 280,
      except_clause: 281,
      exec_stmt: 282,
      expr: 283,
      expr_stmt: 284,
      exprlist: 285,
      factor: 286,
      file_input: 287,
      flow_stmt: 288,
      for_stmt: 289,
      fpdef: 290,
      fplist: 291,
      funcdef: 292,
      gen_for: 293,
      gen_if: 294,
      gen_iter: 295,
      global_stmt: 296,
      if_stmt: 297,
      import_as_name: 298,
      import_as_names: 299,
      import_from: 300,
      import_name: 301,
      import_stmt: 302,
      lambdef: 303,
      list_for: 304,
      list_if: 305,
      list_iter: 306,
      listmaker: 307,
      not_test: 308,
      old_lambdef: 309,
      old_test: 310,
      or_test: 311,
      parameters: 312,
      pass_stmt: 313,
      power: 314,
      print_stmt: 315,
      raise_stmt: 316,
      return_stmt: 317,
      shift_expr: 318,
      simple_stmt: 319,
      single_input: 256,
      sliceop: 320,
      small_stmt: 321,
      stmt: 322,
      subscript: 323,
      subscriptlist: 324,
      suite: 325,
      term: 326,
      test: 327,
      testlist: 328,
      testlist1: 329,
      testlist_gexp: 330,
      testlist_safe: 331,
      trailer: 332,
      try_stmt: 333,
      varargslist: 334,
      while_stmt: 335,
      with_stmt: 336,
      with_var: 337,
      xor_expr: 338,
      yield_expr: 339,
      yield_stmt: 340
    },
    number2symbol: {
      256: 'single_input',
      257: 'and_expr',
      258: 'and_test',
      259: 'arglist',
      260: 'argument',
      261: 'arith_expr',
      262: 'assert_stmt',
      263: 'atom',
      264: 'augassign',
      265: 'break_stmt',
      266: 'classdef',
      267: 'comp_op',
      268: 'comparison',
      269: 'compound_stmt',
      270: 'continue_stmt',
      271: 'decorated',
      272: 'decorator',
      273: 'decorators',
      274: 'del_stmt',
      275: 'dictmaker',
      276: 'dotted_as_name',
      277: 'dotted_as_names',
      278: 'dotted_name',
      279: 'encoding_decl',
      280: 'eval_input',
      281: 'except_clause',
      282: 'exec_stmt',
      283: 'expr',
      284: 'expr_stmt',
      285: 'exprlist',
      286: 'factor',
      287: 'file_input',
      288: 'flow_stmt',
      289: 'for_stmt',
      290: 'fpdef',
      291: 'fplist',
      292: 'funcdef',
      293: 'gen_for',
      294: 'gen_if',
      295: 'gen_iter',
      296: 'global_stmt',
      297: 'if_stmt',
      298: 'import_as_name',
      299: 'import_as_names',
      300: 'import_from',
      301: 'import_name',
      302: 'import_stmt',
      303: 'lambdef',
      304: 'list_for',
      305: 'list_if',
      306: 'list_iter',
      307: 'listmaker',
      308: 'not_test',
      309: 'old_lambdef',
      310: 'old_test',
      311: 'or_test',
      312: 'parameters',
      313: 'pass_stmt',
      314: 'power',
      315: 'print_stmt',
      316: 'raise_stmt',
      317: 'return_stmt',
      318: 'shift_expr',
      319: 'simple_stmt',
      320: 'sliceop',
      321: 'small_stmt',
      322: 'stmt',
      323: 'subscript',
      324: 'subscriptlist',
      325: 'suite',
      326: 'term',
      327: 'test',
      328: 'testlist',
      329: 'testlist1',
      330: 'testlist_gexp',
      331: 'testlist_safe',
      332: 'trailer',
      333: 'try_stmt',
      334: 'varargslist',
      335: 'while_stmt',
      336: 'with_stmt',
      337: 'with_var',
      338: 'xor_expr',
      339: 'yield_expr',
      340: 'yield_stmt'
    },
    dfas: {
      256: [
        [
          [
            [
              1,
              1
            ],
            [
              2,
              1
            ],
            [
              3,
              2
            ]
          ],
          [[
              0,
              1
            ]],
          [[
              2,
              1
            ]]
        ],
        {
          2: 1,
          4: 1,
          5: 1,
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          10: 1,
          11: 1,
          12: 1,
          13: 1,
          14: 1,
          15: 1,
          16: 1,
          17: 1,
          18: 1,
          19: 1,
          20: 1,
          21: 1,
          22: 1,
          23: 1,
          24: 1,
          25: 1,
          26: 1,
          27: 1,
          28: 1,
          29: 1,
          30: 1,
          31: 1,
          32: 1,
          33: 1,
          34: 1,
          35: 1,
          36: 1
        }
      ],
      257: [
        [
          [[
              37,
              1
            ]],
          [
            [
              38,
              0
            ],
            [
              0,
              1
            ]
          ]
        ],
        {
          6: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1
        }
      ],
      258: [
        [
          [[
              39,
              1
            ]],
          [
            [
              40,
              0
            ],
            [
              0,
              1
            ]
          ]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1
        }
      ],
      259: [
        [
          [
            [
              41,
              1
            ],
            [
              42,
              2
            ],
            [
              43,
              3
            ]
          ],
          [[
              44,
              4
            ]],
          [
            [
              45,
              5
            ],
            [
              0,
              2
            ]
          ],
          [[
              44,
              6
            ]],
          [
            [
              45,
              7
            ],
            [
              0,
              4
            ]
          ],
          [
            [
              41,
              1
            ],
            [
              42,
              2
            ],
            [
              43,
              3
            ],
            [
              0,
              5
            ]
          ],
          [[
              0,
              6
            ]],
          [
            [
              42,
              4
            ],
            [
              43,
              3
            ]
          ]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1,
          41: 1,
          43: 1
        }
      ],
      260: [
        [
          [[
              44,
              1
            ]],
          [
            [
              46,
              2
            ],
            [
              47,
              3
            ],
            [
              0,
              1
            ]
          ],
          [[
              0,
              2
            ]],
          [[
              44,
              2
            ]]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1
        }
      ],
      261: [
        [
          [[
              48,
              1
            ]],
          [
            [
              24,
              0
            ],
            [
              35,
              0
            ],
            [
              0,
              1
            ]
          ]
        ],
        {
          6: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1
        }
      ],
      262: [
        [
          [[
              19,
              1
            ]],
          [[
              44,
              2
            ]],
          [
            [
              45,
              3
            ],
            [
              0,
              2
            ]
          ],
          [[
              44,
              4
            ]],
          [[
              0,
              4
            ]]
        ],
        { 19: 1 }
      ],
      263: [
        [
          [
            [
              17,
              1
            ],
            [
              8,
              2
            ],
            [
              9,
              5
            ],
            [
              28,
              4
            ],
            [
              11,
              3
            ],
            [
              13,
              6
            ],
            [
              20,
              2
            ]
          ],
          [
            [
              17,
              1
            ],
            [
              0,
              1
            ]
          ],
          [[
              0,
              2
            ]],
          [
            [
              49,
              7
            ],
            [
              50,
              2
            ]
          ],
          [
            [
              51,
              2
            ],
            [
              52,
              8
            ],
            [
              53,
              8
            ]
          ],
          [
            [
              54,
              9
            ],
            [
              55,
              2
            ]
          ],
          [[
              56,
              10
            ]],
          [[
              50,
              2
            ]],
          [[
              51,
              2
            ]],
          [[
              55,
              2
            ]],
          [[
              13,
              2
            ]]
        ],
        {
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          28: 1
        }
      ],
      264: [
        [
          [
            [
              57,
              1
            ],
            [
              58,
              1
            ],
            [
              59,
              1
            ],
            [
              60,
              1
            ],
            [
              61,
              1
            ],
            [
              62,
              1
            ],
            [
              63,
              1
            ],
            [
              64,
              1
            ],
            [
              65,
              1
            ],
            [
              66,
              1
            ],
            [
              67,
              1
            ],
            [
              68,
              1
            ]
          ],
          [[
              0,
              1
            ]]
        ],
        {
          57: 1,
          58: 1,
          59: 1,
          60: 1,
          61: 1,
          62: 1,
          63: 1,
          64: 1,
          65: 1,
          66: 1,
          67: 1,
          68: 1
        }
      ],
      265: [
        [
          [[
              31,
              1
            ]],
          [[
              0,
              1
            ]]
        ],
        { 31: 1 }
      ],
      266: [
        [
          [[
              10,
              1
            ]],
          [[
              20,
              2
            ]],
          [
            [
              69,
              3
            ],
            [
              28,
              4
            ]
          ],
          [[
              70,
              5
            ]],
          [
            [
              51,
              6
            ],
            [
              71,
              7
            ]
          ],
          [[
              0,
              5
            ]],
          [[
              69,
              3
            ]],
          [[
              51,
              6
            ]]
        ],
        { 10: 1 }
      ],
      267: [
        [
          [
            [
              72,
              1
            ],
            [
              73,
              1
            ],
            [
              7,
              2
            ],
            [
              74,
              1
            ],
            [
              72,
              1
            ],
            [
              75,
              1
            ],
            [
              76,
              1
            ],
            [
              77,
              3
            ],
            [
              78,
              1
            ],
            [
              79,
              1
            ]
          ],
          [[
              0,
              1
            ]],
          [[
              75,
              1
            ]],
          [
            [
              7,
              1
            ],
            [
              0,
              3
            ]
          ]
        ],
        {
          7: 1,
          72: 1,
          73: 1,
          74: 1,
          75: 1,
          76: 1,
          77: 1,
          78: 1,
          79: 1
        }
      ],
      268: [
        [
          [[
              80,
              1
            ]],
          [
            [
              81,
              0
            ],
            [
              0,
              1
            ]
          ]
        ],
        {
          6: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1
        }
      ],
      269: [
        [
          [
            [
              82,
              1
            ],
            [
              83,
              1
            ],
            [
              84,
              1
            ],
            [
              85,
              1
            ],
            [
              86,
              1
            ],
            [
              87,
              1
            ],
            [
              88,
              1
            ],
            [
              89,
              1
            ]
          ],
          [[
              0,
              1
            ]]
        ],
        {
          4: 1,
          10: 1,
          14: 1,
          16: 1,
          27: 1,
          30: 1,
          33: 1,
          34: 1
        }
      ],
      270: [
        [
          [[
              32,
              1
            ]],
          [[
              0,
              1
            ]]
        ],
        { 32: 1 }
      ],
      271: [
        [
          [[
              90,
              1
            ]],
          [
            [
              88,
              2
            ],
            [
              85,
              2
            ]
          ],
          [[
              0,
              2
            ]]
        ],
        { 33: 1 }
      ],
      272: [
        [
          [[
              33,
              1
            ]],
          [[
              91,
              2
            ]],
          [
            [
              28,
              4
            ],
            [
              2,
              3
            ]
          ],
          [[
              0,
              3
            ]],
          [
            [
              51,
              5
            ],
            [
              92,
              6
            ]
          ],
          [[
              2,
              3
            ]],
          [[
              51,
              5
            ]]
        ],
        { 33: 1 }
      ],
      273: [
        [
          [[
              93,
              1
            ]],
          [
            [
              93,
              1
            ],
            [
              0,
              1
            ]
          ]
        ],
        { 33: 1 }
      ],
      274: [
        [
          [[
              21,
              1
            ]],
          [[
              94,
              2
            ]],
          [[
              0,
              2
            ]]
        ],
        { 21: 1 }
      ],
      275: [
        [
          [[
              44,
              1
            ]],
          [[
              69,
              2
            ]],
          [[
              44,
              3
            ]],
          [
            [
              45,
              4
            ],
            [
              0,
              3
            ]
          ],
          [
            [
              44,
              1
            ],
            [
              0,
              4
            ]
          ]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1
        }
      ],
      276: [
        [
          [[
              91,
              1
            ]],
          [
            [
              95,
              2
            ],
            [
              0,
              1
            ]
          ],
          [[
              20,
              3
            ]],
          [[
              0,
              3
            ]]
        ],
        { 20: 1 }
      ],
      277: [
        [
          [[
              96,
              1
            ]],
          [
            [
              45,
              0
            ],
            [
              0,
              1
            ]
          ]
        ],
        { 20: 1 }
      ],
      278: [
        [
          [[
              20,
              1
            ]],
          [
            [
              97,
              0
            ],
            [
              0,
              1
            ]
          ]
        ],
        { 20: 1 }
      ],
      279: [
        [
          [[
              20,
              1
            ]],
          [[
              0,
              1
            ]]
        ],
        { 20: 1 }
      ],
      280: [
        [
          [[
              71,
              1
            ]],
          [
            [
              2,
              1
            ],
            [
              98,
              2
            ]
          ],
          [[
              0,
              2
            ]]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1
        }
      ],
      281: [
        [
          [[
              99,
              1
            ]],
          [
            [
              44,
              2
            ],
            [
              0,
              1
            ]
          ],
          [
            [
              95,
              3
            ],
            [
              45,
              3
            ],
            [
              0,
              2
            ]
          ],
          [[
              44,
              4
            ]],
          [[
              0,
              4
            ]]
        ],
        { 99: 1 }
      ],
      282: [
        [
          [[
              15,
              1
            ]],
          [[
              80,
              2
            ]],
          [
            [
              75,
              3
            ],
            [
              0,
              2
            ]
          ],
          [[
              44,
              4
            ]],
          [
            [
              45,
              5
            ],
            [
              0,
              4
            ]
          ],
          [[
              44,
              6
            ]],
          [[
              0,
              6
            ]]
        ],
        { 15: 1 }
      ],
      283: [
        [
          [[
              100,
              1
            ]],
          [
            [
              101,
              0
            ],
            [
              0,
              1
            ]
          ]
        ],
        {
          6: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1
        }
      ],
      284: [
        [
          [[
              71,
              1
            ]],
          [
            [
              102,
              2
            ],
            [
              47,
              3
            ],
            [
              0,
              1
            ]
          ],
          [
            [
              71,
              4
            ],
            [
              53,
              4
            ]
          ],
          [
            [
              71,
              5
            ],
            [
              53,
              5
            ]
          ],
          [[
              0,
              4
            ]],
          [
            [
              47,
              3
            ],
            [
              0,
              5
            ]
          ]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1
        }
      ],
      285: [
        [
          [[
              80,
              1
            ]],
          [
            [
              45,
              2
            ],
            [
              0,
              1
            ]
          ],
          [
            [
              80,
              1
            ],
            [
              0,
              2
            ]
          ]
        ],
        {
          6: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1
        }
      ],
      286: [
        [
          [
            [
              103,
              2
            ],
            [
              24,
              1
            ],
            [
              6,
              1
            ],
            [
              35,
              1
            ]
          ],
          [[
              104,
              2
            ]],
          [[
              0,
              2
            ]]
        ],
        {
          6: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1
        }
      ],
      287: [
        [
          [
            [
              2,
              0
            ],
            [
              98,
              1
            ],
            [
              105,
              0
            ]
          ],
          [[
              0,
              1
            ]]
        ],
        {
          2: 1,
          4: 1,
          5: 1,
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          10: 1,
          11: 1,
          12: 1,
          13: 1,
          14: 1,
          15: 1,
          16: 1,
          17: 1,
          18: 1,
          19: 1,
          20: 1,
          21: 1,
          22: 1,
          23: 1,
          24: 1,
          25: 1,
          26: 1,
          27: 1,
          28: 1,
          29: 1,
          30: 1,
          31: 1,
          32: 1,
          33: 1,
          34: 1,
          35: 1,
          36: 1,
          98: 1
        }
      ],
      288: [
        [
          [
            [
              106,
              1
            ],
            [
              107,
              1
            ],
            [
              108,
              1
            ],
            [
              109,
              1
            ],
            [
              110,
              1
            ]
          ],
          [[
              0,
              1
            ]]
        ],
        {
          5: 1,
          18: 1,
          25: 1,
          31: 1,
          32: 1
        }
      ],
      289: [
        [
          [[
              27,
              1
            ]],
          [[
              94,
              2
            ]],
          [[
              75,
              3
            ]],
          [[
              71,
              4
            ]],
          [[
              69,
              5
            ]],
          [[
              70,
              6
            ]],
          [
            [
              111,
              7
            ],
            [
              0,
              6
            ]
          ],
          [[
              69,
              8
            ]],
          [[
              70,
              9
            ]],
          [[
              0,
              9
            ]]
        ],
        { 27: 1 }
      ],
      290: [
        [
          [
            [
              28,
              1
            ],
            [
              20,
              2
            ]
          ],
          [[
              112,
              3
            ]],
          [[
              0,
              2
            ]],
          [[
              51,
              2
            ]]
        ],
        {
          20: 1,
          28: 1
        }
      ],
      291: [
        [
          [[
              113,
              1
            ]],
          [
            [
              45,
              2
            ],
            [
              0,
              1
            ]
          ],
          [
            [
              113,
              1
            ],
            [
              0,
              2
            ]
          ]
        ],
        {
          20: 1,
          28: 1
        }
      ],
      292: [
        [
          [[
              4,
              1
            ]],
          [[
              20,
              2
            ]],
          [[
              114,
              3
            ]],
          [[
              69,
              4
            ]],
          [[
              70,
              5
            ]],
          [[
              0,
              5
            ]]
        ],
        { 4: 1 }
      ],
      293: [
        [
          [[
              27,
              1
            ]],
          [[
              94,
              2
            ]],
          [[
              75,
              3
            ]],
          [[
              115,
              4
            ]],
          [
            [
              116,
              5
            ],
            [
              0,
              4
            ]
          ],
          [[
              0,
              5
            ]]
        ],
        { 27: 1 }
      ],
      294: [
        [
          [[
              30,
              1
            ]],
          [[
              117,
              2
            ]],
          [
            [
              116,
              3
            ],
            [
              0,
              2
            ]
          ],
          [[
              0,
              3
            ]]
        ],
        { 30: 1 }
      ],
      295: [
        [
          [
            [
              46,
              1
            ],
            [
              118,
              1
            ]
          ],
          [[
              0,
              1
            ]]
        ],
        {
          27: 1,
          30: 1
        }
      ],
      296: [
        [
          [[
              26,
              1
            ]],
          [[
              20,
              2
            ]],
          [
            [
              45,
              1
            ],
            [
              0,
              2
            ]
          ]
        ],
        { 26: 1 }
      ],
      297: [
        [
          [[
              30,
              1
            ]],
          [[
              44,
              2
            ]],
          [[
              69,
              3
            ]],
          [[
              70,
              4
            ]],
          [
            [
              111,
              5
            ],
            [
              119,
              1
            ],
            [
              0,
              4
            ]
          ],
          [[
              69,
              6
            ]],
          [[
              70,
              7
            ]],
          [[
              0,
              7
            ]]
        ],
        { 30: 1 }
      ],
      298: [
        [
          [[
              20,
              1
            ]],
          [
            [
              95,
              2
            ],
            [
              0,
              1
            ]
          ],
          [[
              20,
              3
            ]],
          [[
              0,
              3
            ]]
        ],
        { 20: 1 }
      ],
      299: [
        [
          [[
              120,
              1
            ]],
          [
            [
              45,
              2
            ],
            [
              0,
              1
            ]
          ],
          [
            [
              120,
              1
            ],
            [
              0,
              2
            ]
          ]
        ],
        { 20: 1 }
      ],
      300: [
        [
          [[
              29,
              1
            ]],
          [
            [
              91,
              2
            ],
            [
              97,
              3
            ]
          ],
          [[
              23,
              4
            ]],
          [
            [
              91,
              2
            ],
            [
              23,
              4
            ],
            [
              97,
              3
            ]
          ],
          [
            [
              121,
              5
            ],
            [
              41,
              5
            ],
            [
              28,
              6
            ]
          ],
          [[
              0,
              5
            ]],
          [[
              121,
              7
            ]],
          [[
              51,
              5
            ]]
        ],
        { 29: 1 }
      ],
      301: [
        [
          [[
              23,
              1
            ]],
          [[
              122,
              2
            ]],
          [[
              0,
              2
            ]]
        ],
        { 23: 1 }
      ],
      302: [
        [
          [
            [
              123,
              1
            ],
            [
              124,
              1
            ]
          ],
          [[
              0,
              1
            ]]
        ],
        {
          23: 1,
          29: 1
        }
      ],
      303: [
        [
          [[
              36,
              1
            ]],
          [
            [
              69,
              2
            ],
            [
              125,
              3
            ]
          ],
          [[
              44,
              4
            ]],
          [[
              69,
              2
            ]],
          [[
              0,
              4
            ]]
        ],
        { 36: 1 }
      ],
      304: [
        [
          [[
              27,
              1
            ]],
          [[
              94,
              2
            ]],
          [[
              75,
              3
            ]],
          [[
              126,
              4
            ]],
          [
            [
              127,
              5
            ],
            [
              0,
              4
            ]
          ],
          [[
              0,
              5
            ]]
        ],
        { 27: 1 }
      ],
      305: [
        [
          [[
              30,
              1
            ]],
          [[
              117,
              2
            ]],
          [
            [
              127,
              3
            ],
            [
              0,
              2
            ]
          ],
          [[
              0,
              3
            ]]
        ],
        { 30: 1 }
      ],
      306: [
        [
          [
            [
              128,
              1
            ],
            [
              129,
              1
            ]
          ],
          [[
              0,
              1
            ]]
        ],
        {
          27: 1,
          30: 1
        }
      ],
      307: [
        [
          [[
              44,
              1
            ]],
          [
            [
              128,
              2
            ],
            [
              45,
              3
            ],
            [
              0,
              1
            ]
          ],
          [[
              0,
              2
            ]],
          [
            [
              44,
              4
            ],
            [
              0,
              3
            ]
          ],
          [
            [
              45,
              3
            ],
            [
              0,
              4
            ]
          ]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1
        }
      ],
      308: [
        [
          [
            [
              7,
              1
            ],
            [
              130,
              2
            ]
          ],
          [[
              39,
              2
            ]],
          [[
              0,
              2
            ]]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1
        }
      ],
      309: [
        [
          [[
              36,
              1
            ]],
          [
            [
              69,
              2
            ],
            [
              125,
              3
            ]
          ],
          [[
              117,
              4
            ]],
          [[
              69,
              2
            ]],
          [[
              0,
              4
            ]]
        ],
        { 36: 1 }
      ],
      310: [
        [
          [
            [
              131,
              1
            ],
            [
              115,
              1
            ]
          ],
          [[
              0,
              1
            ]]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1
        }
      ],
      311: [
        [
          [[
              132,
              1
            ]],
          [
            [
              133,
              0
            ],
            [
              0,
              1
            ]
          ]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1
        }
      ],
      312: [
        [
          [[
              28,
              1
            ]],
          [
            [
              51,
              2
            ],
            [
              125,
              3
            ]
          ],
          [[
              0,
              2
            ]],
          [[
              51,
              2
            ]]
        ],
        { 28: 1 }
      ],
      313: [
        [
          [[
              22,
              1
            ]],
          [[
              0,
              1
            ]]
        ],
        { 22: 1 }
      ],
      314: [
        [
          [[
              134,
              1
            ]],
          [
            [
              135,
              1
            ],
            [
              43,
              2
            ],
            [
              0,
              1
            ]
          ],
          [[
              104,
              3
            ]],
          [[
              0,
              3
            ]]
        ],
        {
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          28: 1
        }
      ],
      315: [
        [
          [[
              12,
              1
            ]],
          [
            [
              44,
              2
            ],
            [
              136,
              3
            ],
            [
              0,
              1
            ]
          ],
          [
            [
              45,
              4
            ],
            [
              0,
              2
            ]
          ],
          [[
              44,
              5
            ]],
          [
            [
              44,
              2
            ],
            [
              0,
              4
            ]
          ],
          [
            [
              45,
              6
            ],
            [
              0,
              5
            ]
          ],
          [[
              44,
              7
            ]],
          [
            [
              45,
              8
            ],
            [
              0,
              7
            ]
          ],
          [
            [
              44,
              7
            ],
            [
              0,
              8
            ]
          ]
        ],
        { 12: 1 }
      ],
      316: [
        [
          [[
              5,
              1
            ]],
          [
            [
              44,
              2
            ],
            [
              0,
              1
            ]
          ],
          [
            [
              45,
              3
            ],
            [
              0,
              2
            ]
          ],
          [[
              44,
              4
            ]],
          [
            [
              45,
              5
            ],
            [
              0,
              4
            ]
          ],
          [[
              44,
              6
            ]],
          [[
              0,
              6
            ]]
        ],
        { 5: 1 }
      ],
      317: [
        [
          [[
              18,
              1
            ]],
          [
            [
              71,
              2
            ],
            [
              0,
              1
            ]
          ],
          [[
              0,
              2
            ]]
        ],
        { 18: 1 }
      ],
      318: [
        [
          [[
              137,
              1
            ]],
          [
            [
              136,
              0
            ],
            [
              138,
              0
            ],
            [
              0,
              1
            ]
          ]
        ],
        {
          6: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1
        }
      ],
      319: [
        [
          [[
              139,
              1
            ]],
          [
            [
              2,
              2
            ],
            [
              140,
              3
            ]
          ],
          [[
              0,
              2
            ]],
          [
            [
              139,
              1
            ],
            [
              2,
              2
            ]
          ]
        ],
        {
          5: 1,
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          12: 1,
          13: 1,
          15: 1,
          17: 1,
          18: 1,
          19: 1,
          20: 1,
          21: 1,
          22: 1,
          23: 1,
          24: 1,
          25: 1,
          26: 1,
          28: 1,
          29: 1,
          31: 1,
          32: 1,
          35: 1,
          36: 1
        }
      ],
      320: [
        [
          [[
              69,
              1
            ]],
          [
            [
              44,
              2
            ],
            [
              0,
              1
            ]
          ],
          [[
              0,
              2
            ]]
        ],
        { 69: 1 }
      ],
      321: [
        [
          [
            [
              141,
              1
            ],
            [
              142,
              1
            ],
            [
              143,
              1
            ],
            [
              144,
              1
            ],
            [
              145,
              1
            ],
            [
              146,
              1
            ],
            [
              147,
              1
            ],
            [
              148,
              1
            ],
            [
              149,
              1
            ]
          ],
          [[
              0,
              1
            ]]
        ],
        {
          5: 1,
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          12: 1,
          13: 1,
          15: 1,
          17: 1,
          18: 1,
          19: 1,
          20: 1,
          21: 1,
          22: 1,
          23: 1,
          24: 1,
          25: 1,
          26: 1,
          28: 1,
          29: 1,
          31: 1,
          32: 1,
          35: 1,
          36: 1
        }
      ],
      322: [
        [
          [
            [
              1,
              1
            ],
            [
              3,
              1
            ]
          ],
          [[
              0,
              1
            ]]
        ],
        {
          4: 1,
          5: 1,
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          10: 1,
          11: 1,
          12: 1,
          13: 1,
          14: 1,
          15: 1,
          16: 1,
          17: 1,
          18: 1,
          19: 1,
          20: 1,
          21: 1,
          22: 1,
          23: 1,
          24: 1,
          25: 1,
          26: 1,
          27: 1,
          28: 1,
          29: 1,
          30: 1,
          31: 1,
          32: 1,
          33: 1,
          34: 1,
          35: 1,
          36: 1
        }
      ],
      323: [
        [
          [
            [
              44,
              1
            ],
            [
              69,
              2
            ],
            [
              97,
              3
            ]
          ],
          [
            [
              69,
              2
            ],
            [
              0,
              1
            ]
          ],
          [
            [
              44,
              4
            ],
            [
              150,
              5
            ],
            [
              0,
              2
            ]
          ],
          [[
              97,
              6
            ]],
          [
            [
              150,
              5
            ],
            [
              0,
              4
            ]
          ],
          [[
              0,
              5
            ]],
          [[
              97,
              5
            ]]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1,
          69: 1,
          97: 1
        }
      ],
      324: [
        [
          [[
              151,
              1
            ]],
          [
            [
              45,
              2
            ],
            [
              0,
              1
            ]
          ],
          [
            [
              151,
              1
            ],
            [
              0,
              2
            ]
          ]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1,
          69: 1,
          97: 1
        }
      ],
      325: [
        [
          [
            [
              1,
              1
            ],
            [
              2,
              2
            ]
          ],
          [[
              0,
              1
            ]],
          [[
              152,
              3
            ]],
          [[
              105,
              4
            ]],
          [
            [
              153,
              1
            ],
            [
              105,
              4
            ]
          ]
        ],
        {
          2: 1,
          5: 1,
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          12: 1,
          13: 1,
          15: 1,
          17: 1,
          18: 1,
          19: 1,
          20: 1,
          21: 1,
          22: 1,
          23: 1,
          24: 1,
          25: 1,
          26: 1,
          28: 1,
          29: 1,
          31: 1,
          32: 1,
          35: 1,
          36: 1
        }
      ],
      326: [
        [
          [[
              104,
              1
            ]],
          [
            [
              154,
              0
            ],
            [
              41,
              0
            ],
            [
              155,
              0
            ],
            [
              156,
              0
            ],
            [
              0,
              1
            ]
          ]
        ],
        {
          6: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1
        }
      ],
      327: [
        [
          [
            [
              115,
              1
            ],
            [
              157,
              2
            ]
          ],
          [
            [
              30,
              3
            ],
            [
              0,
              1
            ]
          ],
          [[
              0,
              2
            ]],
          [[
              115,
              4
            ]],
          [[
              111,
              5
            ]],
          [[
              44,
              2
            ]]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1
        }
      ],
      328: [
        [
          [[
              44,
              1
            ]],
          [
            [
              45,
              2
            ],
            [
              0,
              1
            ]
          ],
          [
            [
              44,
              1
            ],
            [
              0,
              2
            ]
          ]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1
        }
      ],
      329: [
        [
          [[
              44,
              1
            ]],
          [
            [
              45,
              0
            ],
            [
              0,
              1
            ]
          ]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1
        }
      ],
      330: [
        [
          [[
              44,
              1
            ]],
          [
            [
              46,
              2
            ],
            [
              45,
              3
            ],
            [
              0,
              1
            ]
          ],
          [[
              0,
              2
            ]],
          [
            [
              44,
              4
            ],
            [
              0,
              3
            ]
          ],
          [
            [
              45,
              3
            ],
            [
              0,
              4
            ]
          ]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1
        }
      ],
      331: [
        [
          [[
              117,
              1
            ]],
          [
            [
              45,
              2
            ],
            [
              0,
              1
            ]
          ],
          [[
              117,
              3
            ]],
          [
            [
              45,
              4
            ],
            [
              0,
              3
            ]
          ],
          [
            [
              117,
              3
            ],
            [
              0,
              4
            ]
          ]
        ],
        {
          6: 1,
          7: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1,
          36: 1
        }
      ],
      332: [
        [
          [
            [
              28,
              1
            ],
            [
              97,
              2
            ],
            [
              11,
              3
            ]
          ],
          [
            [
              51,
              4
            ],
            [
              92,
              5
            ]
          ],
          [[
              20,
              4
            ]],
          [[
              158,
              6
            ]],
          [[
              0,
              4
            ]],
          [[
              51,
              4
            ]],
          [[
              50,
              4
            ]]
        ],
        {
          11: 1,
          28: 1,
          97: 1
        }
      ],
      333: [
        [
          [[
              14,
              1
            ]],
          [[
              69,
              2
            ]],
          [[
              70,
              3
            ]],
          [
            [
              159,
              4
            ],
            [
              160,
              5
            ]
          ],
          [[
              69,
              6
            ]],
          [[
              69,
              7
            ]],
          [[
              70,
              8
            ]],
          [[
              70,
              9
            ]],
          [
            [
              159,
              4
            ],
            [
              111,
              10
            ],
            [
              160,
              5
            ],
            [
              0,
              8
            ]
          ],
          [[
              0,
              9
            ]],
          [[
              69,
              11
            ]],
          [[
              70,
              12
            ]],
          [
            [
              160,
              5
            ],
            [
              0,
              12
            ]
          ]
        ],
        { 14: 1 }
      ],
      334: [
        [
          [
            [
              41,
              1
            ],
            [
              113,
              2
            ],
            [
              43,
              3
            ]
          ],
          [[
              20,
              4
            ]],
          [
            [
              47,
              5
            ],
            [
              45,
              6
            ],
            [
              0,
              2
            ]
          ],
          [[
              20,
              7
            ]],
          [
            [
              45,
              8
            ],
            [
              0,
              4
            ]
          ],
          [[
              44,
              9
            ]],
          [
            [
              41,
              1
            ],
            [
              113,
              2
            ],
            [
              43,
              3
            ],
            [
              0,
              6
            ]
          ],
          [[
              0,
              7
            ]],
          [[
              43,
              3
            ]],
          [
            [
              45,
              6
            ],
            [
              0,
              9
            ]
          ]
        ],
        {
          20: 1,
          28: 1,
          41: 1,
          43: 1
        }
      ],
      335: [
        [
          [[
              16,
              1
            ]],
          [[
              44,
              2
            ]],
          [[
              69,
              3
            ]],
          [[
              70,
              4
            ]],
          [
            [
              111,
              5
            ],
            [
              0,
              4
            ]
          ],
          [[
              69,
              6
            ]],
          [[
              70,
              7
            ]],
          [[
              0,
              7
            ]]
        ],
        { 16: 1 }
      ],
      336: [
        [
          [[
              34,
              1
            ]],
          [[
              44,
              2
            ]],
          [
            [
              69,
              3
            ],
            [
              161,
              4
            ]
          ],
          [[
              70,
              5
            ]],
          [[
              69,
              3
            ]],
          [[
              0,
              5
            ]]
        ],
        { 34: 1 }
      ],
      337: [
        [
          [[
              95,
              1
            ]],
          [[
              80,
              2
            ]],
          [[
              0,
              2
            ]]
        ],
        { 95: 1 }
      ],
      338: [
        [
          [[
              162,
              1
            ]],
          [
            [
              163,
              0
            ],
            [
              0,
              1
            ]
          ]
        ],
        {
          6: 1,
          8: 1,
          9: 1,
          11: 1,
          13: 1,
          17: 1,
          20: 1,
          24: 1,
          28: 1,
          35: 1
        }
      ],
      339: [
        [
          [[
              25,
              1
            ]],
          [
            [
              71,
              2
            ],
            [
              0,
              1
            ]
          ],
          [[
              0,
              2
            ]]
        ],
        { 25: 1 }
      ],
      340: [
        [
          [[
              53,
              1
            ]],
          [[
              0,
              1
            ]]
        ],
        { 25: 1 }
      ]
    },
    states: [
      [
        [
          [
            1,
            1
          ],
          [
            2,
            1
          ],
          [
            3,
            2
          ]
        ],
        [[
            0,
            1
          ]],
        [[
            2,
            1
          ]]
      ],
      [
        [[
            37,
            1
          ]],
        [
          [
            38,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [[
            39,
            1
          ]],
        [
          [
            40,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [
          [
            41,
            1
          ],
          [
            42,
            2
          ],
          [
            43,
            3
          ]
        ],
        [[
            44,
            4
          ]],
        [
          [
            45,
            5
          ],
          [
            0,
            2
          ]
        ],
        [[
            44,
            6
          ]],
        [
          [
            45,
            7
          ],
          [
            0,
            4
          ]
        ],
        [
          [
            41,
            1
          ],
          [
            42,
            2
          ],
          [
            43,
            3
          ],
          [
            0,
            5
          ]
        ],
        [[
            0,
            6
          ]],
        [
          [
            42,
            4
          ],
          [
            43,
            3
          ]
        ]
      ],
      [
        [[
            44,
            1
          ]],
        [
          [
            46,
            2
          ],
          [
            47,
            3
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]],
        [[
            44,
            2
          ]]
      ],
      [
        [[
            48,
            1
          ]],
        [
          [
            24,
            0
          ],
          [
            35,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [[
            19,
            1
          ]],
        [[
            44,
            2
          ]],
        [
          [
            45,
            3
          ],
          [
            0,
            2
          ]
        ],
        [[
            44,
            4
          ]],
        [[
            0,
            4
          ]]
      ],
      [
        [
          [
            17,
            1
          ],
          [
            8,
            2
          ],
          [
            9,
            5
          ],
          [
            28,
            4
          ],
          [
            11,
            3
          ],
          [
            13,
            6
          ],
          [
            20,
            2
          ]
        ],
        [
          [
            17,
            1
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]],
        [
          [
            49,
            7
          ],
          [
            50,
            2
          ]
        ],
        [
          [
            51,
            2
          ],
          [
            52,
            8
          ],
          [
            53,
            8
          ]
        ],
        [
          [
            54,
            9
          ],
          [
            55,
            2
          ]
        ],
        [[
            56,
            10
          ]],
        [[
            50,
            2
          ]],
        [[
            51,
            2
          ]],
        [[
            55,
            2
          ]],
        [[
            13,
            2
          ]]
      ],
      [
        [
          [
            57,
            1
          ],
          [
            58,
            1
          ],
          [
            59,
            1
          ],
          [
            60,
            1
          ],
          [
            61,
            1
          ],
          [
            62,
            1
          ],
          [
            63,
            1
          ],
          [
            64,
            1
          ],
          [
            65,
            1
          ],
          [
            66,
            1
          ],
          [
            67,
            1
          ],
          [
            68,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      [
        [[
            31,
            1
          ]],
        [[
            0,
            1
          ]]
      ],
      [
        [[
            10,
            1
          ]],
        [[
            20,
            2
          ]],
        [
          [
            69,
            3
          ],
          [
            28,
            4
          ]
        ],
        [[
            70,
            5
          ]],
        [
          [
            51,
            6
          ],
          [
            71,
            7
          ]
        ],
        [[
            0,
            5
          ]],
        [[
            69,
            3
          ]],
        [[
            51,
            6
          ]]
      ],
      [
        [
          [
            72,
            1
          ],
          [
            73,
            1
          ],
          [
            7,
            2
          ],
          [
            74,
            1
          ],
          [
            72,
            1
          ],
          [
            75,
            1
          ],
          [
            76,
            1
          ],
          [
            77,
            3
          ],
          [
            78,
            1
          ],
          [
            79,
            1
          ]
        ],
        [[
            0,
            1
          ]],
        [[
            75,
            1
          ]],
        [
          [
            7,
            1
          ],
          [
            0,
            3
          ]
        ]
      ],
      [
        [[
            80,
            1
          ]],
        [
          [
            81,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [
          [
            82,
            1
          ],
          [
            83,
            1
          ],
          [
            84,
            1
          ],
          [
            85,
            1
          ],
          [
            86,
            1
          ],
          [
            87,
            1
          ],
          [
            88,
            1
          ],
          [
            89,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      [
        [[
            32,
            1
          ]],
        [[
            0,
            1
          ]]
      ],
      [
        [[
            90,
            1
          ]],
        [
          [
            88,
            2
          ],
          [
            85,
            2
          ]
        ],
        [[
            0,
            2
          ]]
      ],
      [
        [[
            33,
            1
          ]],
        [[
            91,
            2
          ]],
        [
          [
            28,
            4
          ],
          [
            2,
            3
          ]
        ],
        [[
            0,
            3
          ]],
        [
          [
            51,
            5
          ],
          [
            92,
            6
          ]
        ],
        [[
            2,
            3
          ]],
        [[
            51,
            5
          ]]
      ],
      [
        [[
            93,
            1
          ]],
        [
          [
            93,
            1
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [[
            21,
            1
          ]],
        [[
            94,
            2
          ]],
        [[
            0,
            2
          ]]
      ],
      [
        [[
            44,
            1
          ]],
        [[
            69,
            2
          ]],
        [[
            44,
            3
          ]],
        [
          [
            45,
            4
          ],
          [
            0,
            3
          ]
        ],
        [
          [
            44,
            1
          ],
          [
            0,
            4
          ]
        ]
      ],
      [
        [[
            91,
            1
          ]],
        [
          [
            95,
            2
          ],
          [
            0,
            1
          ]
        ],
        [[
            20,
            3
          ]],
        [[
            0,
            3
          ]]
      ],
      [
        [[
            96,
            1
          ]],
        [
          [
            45,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [[
            20,
            1
          ]],
        [
          [
            97,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [[
            20,
            1
          ]],
        [[
            0,
            1
          ]]
      ],
      [
        [[
            71,
            1
          ]],
        [
          [
            2,
            1
          ],
          [
            98,
            2
          ]
        ],
        [[
            0,
            2
          ]]
      ],
      [
        [[
            99,
            1
          ]],
        [
          [
            44,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            95,
            3
          ],
          [
            45,
            3
          ],
          [
            0,
            2
          ]
        ],
        [[
            44,
            4
          ]],
        [[
            0,
            4
          ]]
      ],
      [
        [[
            15,
            1
          ]],
        [[
            80,
            2
          ]],
        [
          [
            75,
            3
          ],
          [
            0,
            2
          ]
        ],
        [[
            44,
            4
          ]],
        [
          [
            45,
            5
          ],
          [
            0,
            4
          ]
        ],
        [[
            44,
            6
          ]],
        [[
            0,
            6
          ]]
      ],
      [
        [[
            100,
            1
          ]],
        [
          [
            101,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [[
            71,
            1
          ]],
        [
          [
            102,
            2
          ],
          [
            47,
            3
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            71,
            4
          ],
          [
            53,
            4
          ]
        ],
        [
          [
            71,
            5
          ],
          [
            53,
            5
          ]
        ],
        [[
            0,
            4
          ]],
        [
          [
            47,
            3
          ],
          [
            0,
            5
          ]
        ]
      ],
      [
        [[
            80,
            1
          ]],
        [
          [
            45,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            80,
            1
          ],
          [
            0,
            2
          ]
        ]
      ],
      [
        [
          [
            103,
            2
          ],
          [
            24,
            1
          ],
          [
            6,
            1
          ],
          [
            35,
            1
          ]
        ],
        [[
            104,
            2
          ]],
        [[
            0,
            2
          ]]
      ],
      [
        [
          [
            2,
            0
          ],
          [
            98,
            1
          ],
          [
            105,
            0
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      [
        [
          [
            106,
            1
          ],
          [
            107,
            1
          ],
          [
            108,
            1
          ],
          [
            109,
            1
          ],
          [
            110,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      [
        [[
            27,
            1
          ]],
        [[
            94,
            2
          ]],
        [[
            75,
            3
          ]],
        [[
            71,
            4
          ]],
        [[
            69,
            5
          ]],
        [[
            70,
            6
          ]],
        [
          [
            111,
            7
          ],
          [
            0,
            6
          ]
        ],
        [[
            69,
            8
          ]],
        [[
            70,
            9
          ]],
        [[
            0,
            9
          ]]
      ],
      [
        [
          [
            28,
            1
          ],
          [
            20,
            2
          ]
        ],
        [[
            112,
            3
          ]],
        [[
            0,
            2
          ]],
        [[
            51,
            2
          ]]
      ],
      [
        [[
            113,
            1
          ]],
        [
          [
            45,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            113,
            1
          ],
          [
            0,
            2
          ]
        ]
      ],
      [
        [[
            4,
            1
          ]],
        [[
            20,
            2
          ]],
        [[
            114,
            3
          ]],
        [[
            69,
            4
          ]],
        [[
            70,
            5
          ]],
        [[
            0,
            5
          ]]
      ],
      [
        [[
            27,
            1
          ]],
        [[
            94,
            2
          ]],
        [[
            75,
            3
          ]],
        [[
            115,
            4
          ]],
        [
          [
            116,
            5
          ],
          [
            0,
            4
          ]
        ],
        [[
            0,
            5
          ]]
      ],
      [
        [[
            30,
            1
          ]],
        [[
            117,
            2
          ]],
        [
          [
            116,
            3
          ],
          [
            0,
            2
          ]
        ],
        [[
            0,
            3
          ]]
      ],
      [
        [
          [
            46,
            1
          ],
          [
            118,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      [
        [[
            26,
            1
          ]],
        [[
            20,
            2
          ]],
        [
          [
            45,
            1
          ],
          [
            0,
            2
          ]
        ]
      ],
      [
        [[
            30,
            1
          ]],
        [[
            44,
            2
          ]],
        [[
            69,
            3
          ]],
        [[
            70,
            4
          ]],
        [
          [
            111,
            5
          ],
          [
            119,
            1
          ],
          [
            0,
            4
          ]
        ],
        [[
            69,
            6
          ]],
        [[
            70,
            7
          ]],
        [[
            0,
            7
          ]]
      ],
      [
        [[
            20,
            1
          ]],
        [
          [
            95,
            2
          ],
          [
            0,
            1
          ]
        ],
        [[
            20,
            3
          ]],
        [[
            0,
            3
          ]]
      ],
      [
        [[
            120,
            1
          ]],
        [
          [
            45,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            120,
            1
          ],
          [
            0,
            2
          ]
        ]
      ],
      [
        [[
            29,
            1
          ]],
        [
          [
            91,
            2
          ],
          [
            97,
            3
          ]
        ],
        [[
            23,
            4
          ]],
        [
          [
            91,
            2
          ],
          [
            23,
            4
          ],
          [
            97,
            3
          ]
        ],
        [
          [
            121,
            5
          ],
          [
            41,
            5
          ],
          [
            28,
            6
          ]
        ],
        [[
            0,
            5
          ]],
        [[
            121,
            7
          ]],
        [[
            51,
            5
          ]]
      ],
      [
        [[
            23,
            1
          ]],
        [[
            122,
            2
          ]],
        [[
            0,
            2
          ]]
      ],
      [
        [
          [
            123,
            1
          ],
          [
            124,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      [
        [[
            36,
            1
          ]],
        [
          [
            69,
            2
          ],
          [
            125,
            3
          ]
        ],
        [[
            44,
            4
          ]],
        [[
            69,
            2
          ]],
        [[
            0,
            4
          ]]
      ],
      [
        [[
            27,
            1
          ]],
        [[
            94,
            2
          ]],
        [[
            75,
            3
          ]],
        [[
            126,
            4
          ]],
        [
          [
            127,
            5
          ],
          [
            0,
            4
          ]
        ],
        [[
            0,
            5
          ]]
      ],
      [
        [[
            30,
            1
          ]],
        [[
            117,
            2
          ]],
        [
          [
            127,
            3
          ],
          [
            0,
            2
          ]
        ],
        [[
            0,
            3
          ]]
      ],
      [
        [
          [
            128,
            1
          ],
          [
            129,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      [
        [[
            44,
            1
          ]],
        [
          [
            128,
            2
          ],
          [
            45,
            3
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]],
        [
          [
            44,
            4
          ],
          [
            0,
            3
          ]
        ],
        [
          [
            45,
            3
          ],
          [
            0,
            4
          ]
        ]
      ],
      [
        [
          [
            7,
            1
          ],
          [
            130,
            2
          ]
        ],
        [[
            39,
            2
          ]],
        [[
            0,
            2
          ]]
      ],
      [
        [[
            36,
            1
          ]],
        [
          [
            69,
            2
          ],
          [
            125,
            3
          ]
        ],
        [[
            117,
            4
          ]],
        [[
            69,
            2
          ]],
        [[
            0,
            4
          ]]
      ],
      [
        [
          [
            131,
            1
          ],
          [
            115,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      [
        [[
            132,
            1
          ]],
        [
          [
            133,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [[
            28,
            1
          ]],
        [
          [
            51,
            2
          ],
          [
            125,
            3
          ]
        ],
        [[
            0,
            2
          ]],
        [[
            51,
            2
          ]]
      ],
      [
        [[
            22,
            1
          ]],
        [[
            0,
            1
          ]]
      ],
      [
        [[
            134,
            1
          ]],
        [
          [
            135,
            1
          ],
          [
            43,
            2
          ],
          [
            0,
            1
          ]
        ],
        [[
            104,
            3
          ]],
        [[
            0,
            3
          ]]
      ],
      [
        [[
            12,
            1
          ]],
        [
          [
            44,
            2
          ],
          [
            136,
            3
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            45,
            4
          ],
          [
            0,
            2
          ]
        ],
        [[
            44,
            5
          ]],
        [
          [
            44,
            2
          ],
          [
            0,
            4
          ]
        ],
        [
          [
            45,
            6
          ],
          [
            0,
            5
          ]
        ],
        [[
            44,
            7
          ]],
        [
          [
            45,
            8
          ],
          [
            0,
            7
          ]
        ],
        [
          [
            44,
            7
          ],
          [
            0,
            8
          ]
        ]
      ],
      [
        [[
            5,
            1
          ]],
        [
          [
            44,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            45,
            3
          ],
          [
            0,
            2
          ]
        ],
        [[
            44,
            4
          ]],
        [
          [
            45,
            5
          ],
          [
            0,
            4
          ]
        ],
        [[
            44,
            6
          ]],
        [[
            0,
            6
          ]]
      ],
      [
        [[
            18,
            1
          ]],
        [
          [
            71,
            2
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]]
      ],
      [
        [[
            137,
            1
          ]],
        [
          [
            136,
            0
          ],
          [
            138,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [[
            139,
            1
          ]],
        [
          [
            2,
            2
          ],
          [
            140,
            3
          ]
        ],
        [[
            0,
            2
          ]],
        [
          [
            139,
            1
          ],
          [
            2,
            2
          ]
        ]
      ],
      [
        [[
            69,
            1
          ]],
        [
          [
            44,
            2
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]]
      ],
      [
        [
          [
            141,
            1
          ],
          [
            142,
            1
          ],
          [
            143,
            1
          ],
          [
            144,
            1
          ],
          [
            145,
            1
          ],
          [
            146,
            1
          ],
          [
            147,
            1
          ],
          [
            148,
            1
          ],
          [
            149,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      [
        [
          [
            1,
            1
          ],
          [
            3,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      [
        [
          [
            44,
            1
          ],
          [
            69,
            2
          ],
          [
            97,
            3
          ]
        ],
        [
          [
            69,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            44,
            4
          ],
          [
            150,
            5
          ],
          [
            0,
            2
          ]
        ],
        [[
            97,
            6
          ]],
        [
          [
            150,
            5
          ],
          [
            0,
            4
          ]
        ],
        [[
            0,
            5
          ]],
        [[
            97,
            5
          ]]
      ],
      [
        [[
            151,
            1
          ]],
        [
          [
            45,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            151,
            1
          ],
          [
            0,
            2
          ]
        ]
      ],
      [
        [
          [
            1,
            1
          ],
          [
            2,
            2
          ]
        ],
        [[
            0,
            1
          ]],
        [[
            152,
            3
          ]],
        [[
            105,
            4
          ]],
        [
          [
            153,
            1
          ],
          [
            105,
            4
          ]
        ]
      ],
      [
        [[
            104,
            1
          ]],
        [
          [
            154,
            0
          ],
          [
            41,
            0
          ],
          [
            155,
            0
          ],
          [
            156,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [
          [
            115,
            1
          ],
          [
            157,
            2
          ]
        ],
        [
          [
            30,
            3
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]],
        [[
            115,
            4
          ]],
        [[
            111,
            5
          ]],
        [[
            44,
            2
          ]]
      ],
      [
        [[
            44,
            1
          ]],
        [
          [
            45,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            44,
            1
          ],
          [
            0,
            2
          ]
        ]
      ],
      [
        [[
            44,
            1
          ]],
        [
          [
            45,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [[
            44,
            1
          ]],
        [
          [
            46,
            2
          ],
          [
            45,
            3
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]],
        [
          [
            44,
            4
          ],
          [
            0,
            3
          ]
        ],
        [
          [
            45,
            3
          ],
          [
            0,
            4
          ]
        ]
      ],
      [
        [[
            117,
            1
          ]],
        [
          [
            45,
            2
          ],
          [
            0,
            1
          ]
        ],
        [[
            117,
            3
          ]],
        [
          [
            45,
            4
          ],
          [
            0,
            3
          ]
        ],
        [
          [
            117,
            3
          ],
          [
            0,
            4
          ]
        ]
      ],
      [
        [
          [
            28,
            1
          ],
          [
            97,
            2
          ],
          [
            11,
            3
          ]
        ],
        [
          [
            51,
            4
          ],
          [
            92,
            5
          ]
        ],
        [[
            20,
            4
          ]],
        [[
            158,
            6
          ]],
        [[
            0,
            4
          ]],
        [[
            51,
            4
          ]],
        [[
            50,
            4
          ]]
      ],
      [
        [[
            14,
            1
          ]],
        [[
            69,
            2
          ]],
        [[
            70,
            3
          ]],
        [
          [
            159,
            4
          ],
          [
            160,
            5
          ]
        ],
        [[
            69,
            6
          ]],
        [[
            69,
            7
          ]],
        [[
            70,
            8
          ]],
        [[
            70,
            9
          ]],
        [
          [
            159,
            4
          ],
          [
            111,
            10
          ],
          [
            160,
            5
          ],
          [
            0,
            8
          ]
        ],
        [[
            0,
            9
          ]],
        [[
            69,
            11
          ]],
        [[
            70,
            12
          ]],
        [
          [
            160,
            5
          ],
          [
            0,
            12
          ]
        ]
      ],
      [
        [
          [
            41,
            1
          ],
          [
            113,
            2
          ],
          [
            43,
            3
          ]
        ],
        [[
            20,
            4
          ]],
        [
          [
            47,
            5
          ],
          [
            45,
            6
          ],
          [
            0,
            2
          ]
        ],
        [[
            20,
            7
          ]],
        [
          [
            45,
            8
          ],
          [
            0,
            4
          ]
        ],
        [[
            44,
            9
          ]],
        [
          [
            41,
            1
          ],
          [
            113,
            2
          ],
          [
            43,
            3
          ],
          [
            0,
            6
          ]
        ],
        [[
            0,
            7
          ]],
        [[
            43,
            3
          ]],
        [
          [
            45,
            6
          ],
          [
            0,
            9
          ]
        ]
      ],
      [
        [[
            16,
            1
          ]],
        [[
            44,
            2
          ]],
        [[
            69,
            3
          ]],
        [[
            70,
            4
          ]],
        [
          [
            111,
            5
          ],
          [
            0,
            4
          ]
        ],
        [[
            69,
            6
          ]],
        [[
            70,
            7
          ]],
        [[
            0,
            7
          ]]
      ],
      [
        [[
            34,
            1
          ]],
        [[
            44,
            2
          ]],
        [
          [
            69,
            3
          ],
          [
            161,
            4
          ]
        ],
        [[
            70,
            5
          ]],
        [[
            69,
            3
          ]],
        [[
            0,
            5
          ]]
      ],
      [
        [[
            95,
            1
          ]],
        [[
            80,
            2
          ]],
        [[
            0,
            2
          ]]
      ],
      [
        [[
            162,
            1
          ]],
        [
          [
            163,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      [
        [[
            25,
            1
          ]],
        [
          [
            71,
            2
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]]
      ],
      [
        [[
            53,
            1
          ]],
        [[
            0,
            1
          ]]
      ]
    ],
    labels: [
      [
        0,
        'EMPTY'
      ],
      [
        319,
        null
      ],
      [
        4,
        null
      ],
      [
        269,
        null
      ],
      [
        1,
        'def'
      ],
      [
        1,
        'raise'
      ],
      [
        32,
        null
      ],
      [
        1,
        'not'
      ],
      [
        2,
        null
      ],
      [
        26,
        null
      ],
      [
        1,
        'class'
      ],
      [
        9,
        null
      ],
      [
        1,
        'print'
      ],
      [
        25,
        null
      ],
      [
        1,
        'try'
      ],
      [
        1,
        'exec'
      ],
      [
        1,
        'while'
      ],
      [
        3,
        null
      ],
      [
        1,
        'return'
      ],
      [
        1,
        'assert'
      ],
      [
        1,
        null
      ],
      [
        1,
        'del'
      ],
      [
        1,
        'pass'
      ],
      [
        1,
        'import'
      ],
      [
        15,
        null
      ],
      [
        1,
        'yield'
      ],
      [
        1,
        'global'
      ],
      [
        1,
        'for'
      ],
      [
        7,
        null
      ],
      [
        1,
        'from'
      ],
      [
        1,
        'if'
      ],
      [
        1,
        'break'
      ],
      [
        1,
        'continue'
      ],
      [
        50,
        null
      ],
      [
        1,
        'with'
      ],
      [
        14,
        null
      ],
      [
        1,
        'lambda'
      ],
      [
        318,
        null
      ],
      [
        19,
        null
      ],
      [
        308,
        null
      ],
      [
        1,
        'and'
      ],
      [
        16,
        null
      ],
      [
        260,
        null
      ],
      [
        36,
        null
      ],
      [
        327,
        null
      ],
      [
        12,
        null
      ],
      [
        293,
        null
      ],
      [
        22,
        null
      ],
      [
        326,
        null
      ],
      [
        307,
        null
      ],
      [
        10,
        null
      ],
      [
        8,
        null
      ],
      [
        330,
        null
      ],
      [
        339,
        null
      ],
      [
        275,
        null
      ],
      [
        27,
        null
      ],
      [
        329,
        null
      ],
      [
        46,
        null
      ],
      [
        39,
        null
      ],
      [
        41,
        null
      ],
      [
        47,
        null
      ],
      [
        42,
        null
      ],
      [
        43,
        null
      ],
      [
        37,
        null
      ],
      [
        44,
        null
      ],
      [
        49,
        null
      ],
      [
        40,
        null
      ],
      [
        38,
        null
      ],
      [
        45,
        null
      ],
      [
        11,
        null
      ],
      [
        325,
        null
      ],
      [
        328,
        null
      ],
      [
        29,
        null
      ],
      [
        21,
        null
      ],
      [
        28,
        null
      ],
      [
        1,
        'in'
      ],
      [
        30,
        null
      ],
      [
        1,
        'is'
      ],
      [
        31,
        null
      ],
      [
        20,
        null
      ],
      [
        283,
        null
      ],
      [
        267,
        null
      ],
      [
        333,
        null
      ],
      [
        297,
        null
      ],
      [
        289,
        null
      ],
      [
        266,
        null
      ],
      [
        336,
        null
      ],
      [
        335,
        null
      ],
      [
        292,
        null
      ],
      [
        271,
        null
      ],
      [
        273,
        null
      ],
      [
        278,
        null
      ],
      [
        259,
        null
      ],
      [
        272,
        null
      ],
      [
        285,
        null
      ],
      [
        1,
        'as'
      ],
      [
        276,
        null
      ],
      [
        23,
        null
      ],
      [
        0,
        null
      ],
      [
        1,
        'except'
      ],
      [
        338,
        null
      ],
      [
        18,
        null
      ],
      [
        264,
        null
      ],
      [
        314,
        null
      ],
      [
        286,
        null
      ],
      [
        322,
        null
      ],
      [
        265,
        null
      ],
      [
        270,
        null
      ],
      [
        316,
        null
      ],
      [
        317,
        null
      ],
      [
        340,
        null
      ],
      [
        1,
        'else'
      ],
      [
        291,
        null
      ],
      [
        290,
        null
      ],
      [
        312,
        null
      ],
      [
        311,
        null
      ],
      [
        295,
        null
      ],
      [
        310,
        null
      ],
      [
        294,
        null
      ],
      [
        1,
        'elif'
      ],
      [
        298,
        null
      ],
      [
        299,
        null
      ],
      [
        277,
        null
      ],
      [
        301,
        null
      ],
      [
        300,
        null
      ],
      [
        334,
        null
      ],
      [
        331,
        null
      ],
      [
        306,
        null
      ],
      [
        304,
        null
      ],
      [
        305,
        null
      ],
      [
        268,
        null
      ],
      [
        309,
        null
      ],
      [
        258,
        null
      ],
      [
        1,
        'or'
      ],
      [
        263,
        null
      ],
      [
        332,
        null
      ],
      [
        35,
        null
      ],
      [
        261,
        null
      ],
      [
        34,
        null
      ],
      [
        321,
        null
      ],
      [
        13,
        null
      ],
      [
        288,
        null
      ],
      [
        262,
        null
      ],
      [
        284,
        null
      ],
      [
        313,
        null
      ],
      [
        315,
        null
      ],
      [
        274,
        null
      ],
      [
        282,
        null
      ],
      [
        296,
        null
      ],
      [
        302,
        null
      ],
      [
        320,
        null
      ],
      [
        323,
        null
      ],
      [
        5,
        null
      ],
      [
        6,
        null
      ],
      [
        48,
        null
      ],
      [
        17,
        null
      ],
      [
        24,
        null
      ],
      [
        303,
        null
      ],
      [
        324,
        null
      ],
      [
        281,
        null
      ],
      [
        1,
        'finally'
      ],
      [
        337,
        null
      ],
      [
        257,
        null
      ],
      [
        33,
        null
      ]
    ],
    keywords: {
      and: 40,
      as: 95,
      assert: 19,
      'break': 31,
      'class': 10,
      'continue': 32,
      def: 4,
      del: 21,
      elif: 119,
      'else': 111,
      except: 99,
      exec: 15,
      'finally': 160,
      'for': 27,
      from: 29,
      global: 26,
      'if': 30,
      'import': 23,
      'in': 75,
      is: 77,
      lambda: 36,
      not: 7,
      or: 133,
      pass: 22,
      print: 12,
      raise: 5,
      'return': 18,
      'try': 14,
      'while': 16,
      'with': 34,
      yield: 25
    },
    tokens: {
      0: 98,
      1: 20,
      2: 8,
      3: 17,
      4: 2,
      5: 152,
      6: 153,
      7: 28,
      8: 51,
      9: 11,
      10: 50,
      11: 69,
      12: 45,
      13: 140,
      14: 35,
      15: 24,
      16: 41,
      17: 155,
      18: 101,
      19: 38,
      20: 79,
      21: 73,
      22: 47,
      23: 97,
      24: 156,
      25: 13,
      26: 9,
      27: 55,
      28: 74,
      29: 72,
      30: 76,
      31: 78,
      32: 6,
      33: 163,
      34: 138,
      35: 136,
      36: 43,
      37: 63,
      38: 67,
      39: 58,
      40: 66,
      41: 59,
      42: 61,
      43: 62,
      44: 64,
      45: 68,
      46: 57,
      47: 60,
      48: 154,
      49: 65,
      50: 33
    },
    start: 256
  };
  function Parser(a, b) {
    this.filename = a;
    this.grammar = b;
    return this;
  }
  Parser.prototype.setup = function (a) {
    a = a || this.grammar.start;
    this.stack = [{
        dfa: this.grammar.dfas[a],
        state: 0,
        node: {
          type: a,
          value: null,
          context: null,
          children: []
        }
      }];
    this.used_names = {};
  };
  function findInDfa(a, b) {
    for (var c = a.length; c--;)
      if (a[c][0] === b[0] && a[c][1] === b[1])
        return !0;
    return !1;
  }
  Parser.prototype.addtoken = function (a, b, c) {
    var d = this.classify(a, b, c);
    a:
      for (;;) {
        for (var e = this.stack[this.stack.length - 1], f = e.dfa[0], g = f[e.state], h = 0; h < g.length; ++h) {
          var k = g[h][0], l = g[h][1], m = this.grammar.labels[k][0];
          if (d === k) {
            goog.asserts.assert(256 > m);
            this.shift(a, b, l, c);
            for (a = l; 1 === f[a].length && 0 === f[a][0][0] && f[a][0][1] === a;) {
              this.pop();
              if (0 === this.stack.length)
                return !0;
              e = this.stack[this.stack.length - 1];
              a = e.state;
              f = e.dfa[0];
            }
            return !1;
          }
          if (256 <= m && this.grammar.dfas[m][1].hasOwnProperty(d)) {
            this.push(m, this.grammar.dfas[m], l, c);
            continue a;
          }
        }
        if (findInDfa(g, [
            0,
            e.state
          ])) {
          if (this.pop(), 0 === this.stack.length)
            throw new Sk.builtin.ParseError('too much input', this.filename);
        } else
          throw new Sk.builtin.ParseError('bad input', this.filename, c[0][0], c);
      }
  };
  Parser.prototype.classify = function (a, b, c) {
    if (a === Sk.Tokenizer.Tokens.T_NAME && (this.used_names[b] = !0, b = this.grammar.keywords.hasOwnProperty(b) && this.grammar.keywords[b]))
      return b;
    b = this.grammar.tokens.hasOwnProperty(a) && this.grammar.tokens[a];
    if (!b)
      throw new Sk.builtin.ParseError('bad token', this.filename, c[0][0], c);
    return b;
  };
  Parser.prototype.shift = function (a, b, c, d) {
    var e = this.stack[this.stack.length - 1].dfa, f = this.stack[this.stack.length - 1].node;
    f.children.push({
      type: a,
      value: b,
      lineno: d[0][0],
      col_offset: d[0][1],
      children: null
    });
    this.stack[this.stack.length - 1] = {
      dfa: e,
      state: c,
      node: f
    };
  };
  Parser.prototype.push = function (a, b, c, d) {
    a = {
      type: a,
      value: null,
      lineno: d[0][0],
      col_offset: d[0][1],
      children: []
    };
    this.stack[this.stack.length - 1] = {
      dfa: this.stack[this.stack.length - 1].dfa,
      state: c,
      node: this.stack[this.stack.length - 1].node
    };
    this.stack.push({
      dfa: b,
      state: 0,
      node: a
    });
  };
  Parser.prototype.pop = function () {
    var a = this.stack.pop().node;
    a && (0 !== this.stack.length ? this.stack[this.stack.length - 1].node.children.push(a) : (this.rootnode = a, this.rootnode.used_names = this.used_names));
  };
  function makeParser(a, b) {
    void 0 === b && (b = 'file_input');
    var c = new Parser(a, Sk.ParseTables);
    'file_input' === b ? c.setup(Sk.ParseTables.sym.file_input) : goog.asserts.fail('todo;');
    var d = Sk.Tokenizer.Tokens.T_COMMENT, e = Sk.Tokenizer.Tokens.T_NL, f = Sk.Tokenizer.Tokens.T_OP, g = new Sk.Tokenizer(a, 'single_input' === b, function (a, b, g, m, n) {
        if (a !== d && a !== e && (a === f && (a = Sk.OpMap[b]), c.addtoken(a, b, [
            g,
            m,
            n
          ])))
          return !0;
      });
    return function (a) {
      if (a = g.generateTokens(a)) {
        if ('done' !== a)
          throw new Sk.builtin.ParseError('incomplete input', this.filename);
        return c.rootnode;
      }
      return !1;
    };
  }
  Sk.parse = function (a, b) {
    var c = makeParser(a);
    '\n' !== b.substr(b.length - 1, 1) && (b += '\n');
    for (var d = b.split('\n'), e, f = 0; f < d.length; ++f)
      e = c(d[f] + (f === d.length - 1 ? '' : '\n'));
    return e;
  };
  Sk.parseTreeDump = function (a, b) {
    b = b || '';
    var c;
    c = '' + b;
    if (256 <= a.type) {
      c += Sk.ParseTables.number2symbol[a.type] + '\n';
      for (var d = 0; d < a.children.length; ++d)
        c += Sk.parseTreeDump(a.children[d], b + '  ');
    } else
      c += Sk.Tokenizer.tokenNames[a.type] + ': ' + new Sk.builtin.str(a.value).tp$repr().v + '\n';
    return c;
  };
  goog.exportSymbol('Sk.parse', Sk.parse);
  goog.exportSymbol('Sk.parseTreeDump', Sk.parseTreeDump);
  function Load() {
  }
  function Store() {
  }
  function Del() {
  }
  function AugLoad() {
  }
  function AugStore() {
  }
  function Param() {
  }
  function And() {
  }
  function Or() {
  }
  function Add() {
  }
  function Sub() {
  }
  function Mult() {
  }
  function Div() {
  }
  function Mod() {
  }
  function Pow() {
  }
  function LShift() {
  }
  function RShift() {
  }
  function BitOr() {
  }
  function BitXor() {
  }
  function BitAnd() {
  }
  function FloorDiv() {
  }
  function Invert() {
  }
  function Not() {
  }
  function UAdd() {
  }
  function USub() {
  }
  function Eq() {
  }
  function NotEq() {
  }
  function Lt() {
  }
  function LtE() {
  }
  function Gt() {
  }
  function GtE() {
  }
  function Is() {
  }
  function IsNot() {
  }
  function In_() {
  }
  function NotIn() {
  }
  function Module(a) {
    this.body = a;
    return this;
  }
  function Interactive(a) {
    this.body = a;
    return this;
  }
  function Expression(a) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.body = a;
    return this;
  }
  function Suite(a) {
    this.body = a;
    return this;
  }
  function FunctionDef(a, b, c, d, e, f) {
    goog.asserts.assert(null !== a && void 0 !== a);
    goog.asserts.assert(null !== b && void 0 !== b);
    this.name = a;
    this.args = b;
    this.body = c;
    this.decorator_list = d;
    this.lineno = e;
    this.col_offset = f;
    return this;
  }
  function ClassDef(a, b, c, d, e, f) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.name = a;
    this.bases = b;
    this.body = c;
    this.decorator_list = d;
    this.lineno = e;
    this.col_offset = f;
    return this;
  }
  function Return_(a, b, c) {
    this.value = a;
    this.lineno = b;
    this.col_offset = c;
    return this;
  }
  function Delete_(a, b, c) {
    this.targets = a;
    this.lineno = b;
    this.col_offset = c;
    return this;
  }
  function Assign(a, b, c, d) {
    goog.asserts.assert(null !== b && void 0 !== b);
    this.targets = a;
    this.value = b;
    this.lineno = c;
    this.col_offset = d;
    return this;
  }
  function AugAssign(a, b, c, d, e) {
    goog.asserts.assert(null !== a && void 0 !== a);
    goog.asserts.assert(null !== b && void 0 !== b);
    goog.asserts.assert(null !== c && void 0 !== c);
    this.target = a;
    this.op = b;
    this.value = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function Print(a, b, c, d, e) {
    this.dest = a;
    this.values = b;
    this.nl = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function For_(a, b, c, d, e, f) {
    goog.asserts.assert(null !== a && void 0 !== a);
    goog.asserts.assert(null !== b && void 0 !== b);
    this.target = a;
    this.iter = b;
    this.body = c;
    this.orelse = d;
    this.lineno = e;
    this.col_offset = f;
    return this;
  }
  function While_(a, b, c, d, e) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.test = a;
    this.body = b;
    this.orelse = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function If_(a, b, c, d, e) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.test = a;
    this.body = b;
    this.orelse = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function With_(a, b, c, d, e) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.context_expr = a;
    this.optional_vars = b;
    this.body = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function Raise(a, b, c, d, e) {
    this.type = a;
    this.inst = b;
    this.tback = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function TryExcept(a, b, c, d, e) {
    this.body = a;
    this.handlers = b;
    this.orelse = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function TryFinally(a, b, c, d) {
    this.body = a;
    this.finalbody = b;
    this.lineno = c;
    this.col_offset = d;
    return this;
  }
  function Assert(a, b, c, d) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.test = a;
    this.msg = b;
    this.lineno = c;
    this.col_offset = d;
    return this;
  }
  function Import_(a, b, c) {
    this.names = a;
    this.lineno = b;
    this.col_offset = c;
    return this;
  }
  function ImportFrom(a, b, c, d, e) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.module = a;
    this.names = b;
    this.level = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function Exec(a, b, c, d, e) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.body = a;
    this.globals = b;
    this.locals = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function Global(a, b, c) {
    this.names = a;
    this.lineno = b;
    this.col_offset = c;
    return this;
  }
  function Expr(a, b, c) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.value = a;
    this.lineno = b;
    this.col_offset = c;
    return this;
  }
  function Pass(a, b) {
    this.lineno = a;
    this.col_offset = b;
    return this;
  }
  function Break_(a, b) {
    this.lineno = a;
    this.col_offset = b;
    return this;
  }
  function Continue_(a, b) {
    this.lineno = a;
    this.col_offset = b;
    return this;
  }
  function BoolOp(a, b, c, d) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.op = a;
    this.values = b;
    this.lineno = c;
    this.col_offset = d;
    return this;
  }
  function BinOp(a, b, c, d, e) {
    goog.asserts.assert(null !== a && void 0 !== a);
    goog.asserts.assert(null !== b && void 0 !== b);
    goog.asserts.assert(null !== c && void 0 !== c);
    this.left = a;
    this.op = b;
    this.right = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function UnaryOp(a, b, c, d) {
    goog.asserts.assert(null !== a && void 0 !== a);
    goog.asserts.assert(null !== b && void 0 !== b);
    this.op = a;
    this.operand = b;
    this.lineno = c;
    this.col_offset = d;
    return this;
  }
  function Lambda(a, b, c, d) {
    goog.asserts.assert(null !== a && void 0 !== a);
    goog.asserts.assert(null !== b && void 0 !== b);
    this.args = a;
    this.body = b;
    this.lineno = c;
    this.col_offset = d;
    return this;
  }
  function IfExp(a, b, c, d, e) {
    goog.asserts.assert(null !== a && void 0 !== a);
    goog.asserts.assert(null !== b && void 0 !== b);
    goog.asserts.assert(null !== c && void 0 !== c);
    this.test = a;
    this.body = b;
    this.orelse = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function Dict(a, b, c, d) {
    this.keys = a;
    this.values = b;
    this.lineno = c;
    this.col_offset = d;
    return this;
  }
  function ListComp(a, b, c, d) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.elt = a;
    this.generators = b;
    this.lineno = c;
    this.col_offset = d;
    return this;
  }
  function GeneratorExp(a, b, c, d) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.elt = a;
    this.generators = b;
    this.lineno = c;
    this.col_offset = d;
    return this;
  }
  function Yield(a, b, c) {
    this.value = a;
    this.lineno = b;
    this.col_offset = c;
    return this;
  }
  function Compare(a, b, c, d, e) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.left = a;
    this.ops = b;
    this.comparators = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function Call(a, b, c, d, e, f, g) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.func = a;
    this.args = b;
    this.keywords = c;
    this.starargs = d;
    this.kwargs = e;
    this.lineno = f;
    this.col_offset = g;
    return this;
  }
  function Num(a, b, c) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.n = a;
    this.lineno = b;
    this.col_offset = c;
    return this;
  }
  function Str(a, b, c) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.s = a;
    this.lineno = b;
    this.col_offset = c;
    return this;
  }
  function Attribute(a, b, c, d, e) {
    goog.asserts.assert(null !== a && void 0 !== a);
    goog.asserts.assert(null !== b && void 0 !== b);
    goog.asserts.assert(null !== c && void 0 !== c);
    this.value = a;
    this.attr = b;
    this.ctx = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function Subscript(a, b, c, d, e) {
    goog.asserts.assert(null !== a && void 0 !== a);
    goog.asserts.assert(null !== b && void 0 !== b);
    goog.asserts.assert(null !== c && void 0 !== c);
    this.value = a;
    this.slice = b;
    this.ctx = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function Name(a, b, c, d) {
    goog.asserts.assert(null !== a && void 0 !== a);
    goog.asserts.assert(null !== b && void 0 !== b);
    this.id = a;
    this.ctx = b;
    this.lineno = c;
    this.col_offset = d;
    return this;
  }
  function List(a, b, c, d) {
    goog.asserts.assert(null !== b && void 0 !== b);
    this.elts = a;
    this.ctx = b;
    this.lineno = c;
    this.col_offset = d;
    return this;
  }
  function Tuple(a, b, c, d) {
    goog.asserts.assert(null !== b && void 0 !== b);
    this.elts = a;
    this.ctx = b;
    this.lineno = c;
    this.col_offset = d;
    return this;
  }
  function Ellipsis() {
    return this;
  }
  function Slice(a, b, c) {
    this.lower = a;
    this.upper = b;
    this.step = c;
    return this;
  }
  function ExtSlice(a) {
    this.dims = a;
    return this;
  }
  function Index(a) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.value = a;
    return this;
  }
  function comprehension(a, b, c) {
    goog.asserts.assert(null !== a && void 0 !== a);
    goog.asserts.assert(null !== b && void 0 !== b);
    this.target = a;
    this.iter = b;
    this.ifs = c;
    return this;
  }
  function ExceptHandler(a, b, c, d, e) {
    this.type = a;
    this.name = b;
    this.body = c;
    this.lineno = d;
    this.col_offset = e;
    return this;
  }
  function arguments_(a, b, c, d) {
    this.args = a;
    this.vararg = b;
    this.kwarg = c;
    this.defaults = d;
    return this;
  }
  function keyword(a, b) {
    goog.asserts.assert(null !== a && void 0 !== a);
    goog.asserts.assert(null !== b && void 0 !== b);
    this.arg = a;
    this.value = b;
    return this;
  }
  function alias(a, b) {
    goog.asserts.assert(null !== a && void 0 !== a);
    this.name = a;
    this.asname = b;
    return this;
  }
  Module.prototype._astname = 'Module';
  Module.prototype._fields = [
    'body',
    function (a) {
      return a.body;
    }
  ];
  Interactive.prototype._astname = 'Interactive';
  Interactive.prototype._fields = [
    'body',
    function (a) {
      return a.body;
    }
  ];
  Expression.prototype._astname = 'Expression';
  Expression.prototype._fields = [
    'body',
    function (a) {
      return a.body;
    }
  ];
  Suite.prototype._astname = 'Suite';
  Suite.prototype._fields = [
    'body',
    function (a) {
      return a.body;
    }
  ];
  FunctionDef.prototype._astname = 'FunctionDef';
  FunctionDef.prototype._fields = [
    'name',
    function (a) {
      return a.name;
    },
    'args',
    function (a) {
      return a.args;
    },
    'body',
    function (a) {
      return a.body;
    },
    'decorator_list',
    function (a) {
      return a.decorator_list;
    }
  ];
  ClassDef.prototype._astname = 'ClassDef';
  ClassDef.prototype._fields = [
    'name',
    function (a) {
      return a.name;
    },
    'bases',
    function (a) {
      return a.bases;
    },
    'body',
    function (a) {
      return a.body;
    },
    'decorator_list',
    function (a) {
      return a.decorator_list;
    }
  ];
  Return_.prototype._astname = 'Return';
  Return_.prototype._fields = [
    'value',
    function (a) {
      return a.value;
    }
  ];
  Delete_.prototype._astname = 'Delete';
  Delete_.prototype._fields = [
    'targets',
    function (a) {
      return a.targets;
    }
  ];
  Assign.prototype._astname = 'Assign';
  Assign.prototype._fields = [
    'targets',
    function (a) {
      return a.targets;
    },
    'value',
    function (a) {
      return a.value;
    }
  ];
  AugAssign.prototype._astname = 'AugAssign';
  AugAssign.prototype._fields = [
    'target',
    function (a) {
      return a.target;
    },
    'op',
    function (a) {
      return a.op;
    },
    'value',
    function (a) {
      return a.value;
    }
  ];
  Print.prototype._astname = 'Print';
  Print.prototype._fields = [
    'dest',
    function (a) {
      return a.dest;
    },
    'values',
    function (a) {
      return a.values;
    },
    'nl',
    function (a) {
      return a.nl;
    }
  ];
  For_.prototype._astname = 'For';
  For_.prototype._fields = [
    'target',
    function (a) {
      return a.target;
    },
    'iter',
    function (a) {
      return a.iter;
    },
    'body',
    function (a) {
      return a.body;
    },
    'orelse',
    function (a) {
      return a.orelse;
    }
  ];
  While_.prototype._astname = 'While';
  While_.prototype._fields = [
    'test',
    function (a) {
      return a.test;
    },
    'body',
    function (a) {
      return a.body;
    },
    'orelse',
    function (a) {
      return a.orelse;
    }
  ];
  If_.prototype._astname = 'If';
  If_.prototype._fields = [
    'test',
    function (a) {
      return a.test;
    },
    'body',
    function (a) {
      return a.body;
    },
    'orelse',
    function (a) {
      return a.orelse;
    }
  ];
  With_.prototype._astname = 'With';
  With_.prototype._fields = [
    'context_expr',
    function (a) {
      return a.context_expr;
    },
    'optional_vars',
    function (a) {
      return a.optional_vars;
    },
    'body',
    function (a) {
      return a.body;
    }
  ];
  Raise.prototype._astname = 'Raise';
  Raise.prototype._fields = [
    'type',
    function (a) {
      return a.type;
    },
    'inst',
    function (a) {
      return a.inst;
    },
    'tback',
    function (a) {
      return a.tback;
    }
  ];
  TryExcept.prototype._astname = 'TryExcept';
  TryExcept.prototype._fields = [
    'body',
    function (a) {
      return a.body;
    },
    'handlers',
    function (a) {
      return a.handlers;
    },
    'orelse',
    function (a) {
      return a.orelse;
    }
  ];
  TryFinally.prototype._astname = 'TryFinally';
  TryFinally.prototype._fields = [
    'body',
    function (a) {
      return a.body;
    },
    'finalbody',
    function (a) {
      return a.finalbody;
    }
  ];
  Assert.prototype._astname = 'Assert';
  Assert.prototype._fields = [
    'test',
    function (a) {
      return a.test;
    },
    'msg',
    function (a) {
      return a.msg;
    }
  ];
  Import_.prototype._astname = 'Import';
  Import_.prototype._fields = [
    'names',
    function (a) {
      return a.names;
    }
  ];
  ImportFrom.prototype._astname = 'ImportFrom';
  ImportFrom.prototype._fields = [
    'module',
    function (a) {
      return a.module;
    },
    'names',
    function (a) {
      return a.names;
    },
    'level',
    function (a) {
      return a.level;
    }
  ];
  Exec.prototype._astname = 'Exec';
  Exec.prototype._fields = [
    'body',
    function (a) {
      return a.body;
    },
    'globals',
    function (a) {
      return a.globals;
    },
    'locals',
    function (a) {
      return a.locals;
    }
  ];
  Global.prototype._astname = 'Global';
  Global.prototype._fields = [
    'names',
    function (a) {
      return a.names;
    }
  ];
  Expr.prototype._astname = 'Expr';
  Expr.prototype._fields = [
    'value',
    function (a) {
      return a.value;
    }
  ];
  Pass.prototype._astname = 'Pass';
  Pass.prototype._fields = [];
  Break_.prototype._astname = 'Break';
  Break_.prototype._fields = [];
  Continue_.prototype._astname = 'Continue';
  Continue_.prototype._fields = [];
  BoolOp.prototype._astname = 'BoolOp';
  BoolOp.prototype._fields = [
    'op',
    function (a) {
      return a.op;
    },
    'values',
    function (a) {
      return a.values;
    }
  ];
  BinOp.prototype._astname = 'BinOp';
  BinOp.prototype._fields = [
    'left',
    function (a) {
      return a.left;
    },
    'op',
    function (a) {
      return a.op;
    },
    'right',
    function (a) {
      return a.right;
    }
  ];
  UnaryOp.prototype._astname = 'UnaryOp';
  UnaryOp.prototype._fields = [
    'op',
    function (a) {
      return a.op;
    },
    'operand',
    function (a) {
      return a.operand;
    }
  ];
  Lambda.prototype._astname = 'Lambda';
  Lambda.prototype._fields = [
    'args',
    function (a) {
      return a.args;
    },
    'body',
    function (a) {
      return a.body;
    }
  ];
  IfExp.prototype._astname = 'IfExp';
  IfExp.prototype._fields = [
    'test',
    function (a) {
      return a.test;
    },
    'body',
    function (a) {
      return a.body;
    },
    'orelse',
    function (a) {
      return a.orelse;
    }
  ];
  Dict.prototype._astname = 'Dict';
  Dict.prototype._fields = [
    'keys',
    function (a) {
      return a.keys;
    },
    'values',
    function (a) {
      return a.values;
    }
  ];
  ListComp.prototype._astname = 'ListComp';
  ListComp.prototype._fields = [
    'elt',
    function (a) {
      return a.elt;
    },
    'generators',
    function (a) {
      return a.generators;
    }
  ];
  GeneratorExp.prototype._astname = 'GeneratorExp';
  GeneratorExp.prototype._fields = [
    'elt',
    function (a) {
      return a.elt;
    },
    'generators',
    function (a) {
      return a.generators;
    }
  ];
  Yield.prototype._astname = 'Yield';
  Yield.prototype._fields = [
    'value',
    function (a) {
      return a.value;
    }
  ];
  Compare.prototype._astname = 'Compare';
  Compare.prototype._fields = [
    'left',
    function (a) {
      return a.left;
    },
    'ops',
    function (a) {
      return a.ops;
    },
    'comparators',
    function (a) {
      return a.comparators;
    }
  ];
  Call.prototype._astname = 'Call';
  Call.prototype._fields = [
    'func',
    function (a) {
      return a.func;
    },
    'args',
    function (a) {
      return a.args;
    },
    'keywords',
    function (a) {
      return a.keywords;
    },
    'starargs',
    function (a) {
      return a.starargs;
    },
    'kwargs',
    function (a) {
      return a.kwargs;
    }
  ];
  Num.prototype._astname = 'Num';
  Num.prototype._fields = [
    'n',
    function (a) {
      return a.n;
    }
  ];
  Str.prototype._astname = 'Str';
  Str.prototype._fields = [
    's',
    function (a) {
      return a.s;
    }
  ];
  Attribute.prototype._astname = 'Attribute';
  Attribute.prototype._fields = [
    'value',
    function (a) {
      return a.value;
    },
    'attr',
    function (a) {
      return a.attr;
    },
    'ctx',
    function (a) {
      return a.ctx;
    }
  ];
  Subscript.prototype._astname = 'Subscript';
  Subscript.prototype._fields = [
    'value',
    function (a) {
      return a.value;
    },
    'slice',
    function (a) {
      return a.slice;
    },
    'ctx',
    function (a) {
      return a.ctx;
    }
  ];
  Name.prototype._astname = 'Name';
  Name.prototype._fields = [
    'id',
    function (a) {
      return a.id;
    },
    'ctx',
    function (a) {
      return a.ctx;
    }
  ];
  List.prototype._astname = 'List';
  List.prototype._fields = [
    'elts',
    function (a) {
      return a.elts;
    },
    'ctx',
    function (a) {
      return a.ctx;
    }
  ];
  Tuple.prototype._astname = 'Tuple';
  Tuple.prototype._fields = [
    'elts',
    function (a) {
      return a.elts;
    },
    'ctx',
    function (a) {
      return a.ctx;
    }
  ];
  Load.prototype._astname = 'Load';
  Load.prototype._isenum = !0;
  Store.prototype._astname = 'Store';
  Store.prototype._isenum = !0;
  Del.prototype._astname = 'Del';
  Del.prototype._isenum = !0;
  AugLoad.prototype._astname = 'AugLoad';
  AugLoad.prototype._isenum = !0;
  AugStore.prototype._astname = 'AugStore';
  AugStore.prototype._isenum = !0;
  Param.prototype._astname = 'Param';
  Param.prototype._isenum = !0;
  Ellipsis.prototype._astname = 'Ellipsis';
  Ellipsis.prototype._fields = [];
  Slice.prototype._astname = 'Slice';
  Slice.prototype._fields = [
    'lower',
    function (a) {
      return a.lower;
    },
    'upper',
    function (a) {
      return a.upper;
    },
    'step',
    function (a) {
      return a.step;
    }
  ];
  ExtSlice.prototype._astname = 'ExtSlice';
  ExtSlice.prototype._fields = [
    'dims',
    function (a) {
      return a.dims;
    }
  ];
  Index.prototype._astname = 'Index';
  Index.prototype._fields = [
    'value',
    function (a) {
      return a.value;
    }
  ];
  And.prototype._astname = 'And';
  And.prototype._isenum = !0;
  Or.prototype._astname = 'Or';
  Or.prototype._isenum = !0;
  Add.prototype._astname = 'Add';
  Add.prototype._isenum = !0;
  Sub.prototype._astname = 'Sub';
  Sub.prototype._isenum = !0;
  Mult.prototype._astname = 'Mult';
  Mult.prototype._isenum = !0;
  Div.prototype._astname = 'Div';
  Div.prototype._isenum = !0;
  Mod.prototype._astname = 'Mod';
  Mod.prototype._isenum = !0;
  Pow.prototype._astname = 'Pow';
  Pow.prototype._isenum = !0;
  LShift.prototype._astname = 'LShift';
  LShift.prototype._isenum = !0;
  RShift.prototype._astname = 'RShift';
  RShift.prototype._isenum = !0;
  BitOr.prototype._astname = 'BitOr';
  BitOr.prototype._isenum = !0;
  BitXor.prototype._astname = 'BitXor';
  BitXor.prototype._isenum = !0;
  BitAnd.prototype._astname = 'BitAnd';
  BitAnd.prototype._isenum = !0;
  FloorDiv.prototype._astname = 'FloorDiv';
  FloorDiv.prototype._isenum = !0;
  Invert.prototype._astname = 'Invert';
  Invert.prototype._isenum = !0;
  Not.prototype._astname = 'Not';
  Not.prototype._isenum = !0;
  UAdd.prototype._astname = 'UAdd';
  UAdd.prototype._isenum = !0;
  USub.prototype._astname = 'USub';
  USub.prototype._isenum = !0;
  Eq.prototype._astname = 'Eq';
  Eq.prototype._isenum = !0;
  NotEq.prototype._astname = 'NotEq';
  NotEq.prototype._isenum = !0;
  Lt.prototype._astname = 'Lt';
  Lt.prototype._isenum = !0;
  LtE.prototype._astname = 'LtE';
  LtE.prototype._isenum = !0;
  Gt.prototype._astname = 'Gt';
  Gt.prototype._isenum = !0;
  GtE.prototype._astname = 'GtE';
  GtE.prototype._isenum = !0;
  Is.prototype._astname = 'Is';
  Is.prototype._isenum = !0;
  IsNot.prototype._astname = 'IsNot';
  IsNot.prototype._isenum = !0;
  In_.prototype._astname = 'In';
  In_.prototype._isenum = !0;
  NotIn.prototype._astname = 'NotIn';
  NotIn.prototype._isenum = !0;
  comprehension.prototype._astname = 'comprehension';
  comprehension.prototype._fields = [
    'target',
    function (a) {
      return a.target;
    },
    'iter',
    function (a) {
      return a.iter;
    },
    'ifs',
    function (a) {
      return a.ifs;
    }
  ];
  ExceptHandler.prototype._astname = 'ExceptHandler';
  ExceptHandler.prototype._fields = [
    'type',
    function (a) {
      return a.type;
    },
    'name',
    function (a) {
      return a.name;
    },
    'body',
    function (a) {
      return a.body;
    }
  ];
  arguments_.prototype._astname = 'arguments';
  arguments_.prototype._fields = [
    'args',
    function (a) {
      return a.args;
    },
    'vararg',
    function (a) {
      return a.vararg;
    },
    'kwarg',
    function (a) {
      return a.kwarg;
    },
    'defaults',
    function (a) {
      return a.defaults;
    }
  ];
  keyword.prototype._astname = 'keyword';
  keyword.prototype._fields = [
    'arg',
    function (a) {
      return a.arg;
    },
    'value',
    function (a) {
      return a.value;
    }
  ];
  alias.prototype._astname = 'alias';
  alias.prototype._fields = [
    'name',
    function (a) {
      return a.name;
    },
    'asname',
    function (a) {
      return a.asname;
    }
  ];
  var SYM = Sk.ParseTables.sym, TOK = Sk.Tokenizer.Tokens;
  function Compiling(a, b) {
    this.c_encoding = a;
    this.c_filename = b;
  }
  function NCH(a) {
    goog.asserts.assert(void 0 !== a);
    return null === a.children ? 0 : a.children.length;
  }
  function CHILD(a, b) {
    goog.asserts.assert(void 0 !== a);
    goog.asserts.assert(void 0 !== b);
    return a.children[b];
  }
  function REQ(a, b) {
    goog.asserts.assert(a.type === b, 'node wasn\'t expected type');
  }
  function strobj(a) {
    goog.asserts.assert('string' === typeof a, 'expecting string, got ' + typeof a);
    return new Sk.builtin.str(a);
  }
  function numStmts(a) {
    switch (a.type) {
    case SYM.single_input:
      if (CHILD(a, 0).type === TOK.T_NEWLINE)
        break;
      else
        return numStmts(CHILD(a, 0));
    case SYM.file_input:
      for (var b = 0, c = 0; c < NCH(a); ++c) {
        var d = CHILD(a, c);
        d.type === SYM.stmt && (b += numStmts(d));
      }
      return b;
    case SYM.stmt:
      return numStmts(CHILD(a, 0));
    case SYM.compound_stmt:
      return 1;
    case SYM.simple_stmt:
      return Math.floor(NCH(a) / 2);
    case SYM.suite:
      if (1 === NCH(a))
        return numStmts(CHILD(a, 0));
      b = 0;
      for (c = 2; c < NCH(a) - 1; ++c)
        b += numStmts(CHILD(a, c));
      return b;
    default:
      goog.asserts.fail('Non-statement found');
    }
    return 0;
  }
  function forbiddenCheck(a, b, c, d) {
    if ('None' === c)
      throw new Sk.builtin.SyntaxError('assignment to None', a.c_filename, d);
    if ('True' === c || 'False' === c)
      throw new Sk.builtin.SyntaxError('assignment to True or False is forbidden', a.c_filename, d);
  }
  function setContext(a, b, c, d) {
    goog.asserts.assert(c !== AugStore && c !== AugLoad);
    var e = null, f = null;
    switch (b.constructor) {
    case Attribute:
    case Name:
      c === Store && forbiddenCheck(a, d, b.attr, d.lineno);
      b.ctx = c;
      break;
    case Subscript:
      b.ctx = c;
      break;
    case List:
      b.ctx = c;
      e = b.elts;
      break;
    case Tuple:
      if (0 === b.elts.length)
        throw new Sk.builtin.SyntaxError('can\'t assign to ()', a.c_filename, d.lineno);
      b.ctx = c;
      e = b.elts;
      break;
    case Lambda:
      f = 'lambda';
      break;
    case Call:
      f = 'function call';
      break;
    case BoolOp:
    case BinOp:
    case UnaryOp:
      f = 'operator';
      break;
    case GeneratorExp:
      f = 'generator expression';
      break;
    case Yield:
      f = 'yield expression';
      break;
    case ListComp:
      f = 'list comprehension';
      break;
    case Dict:
    case Num:
    case Str:
      f = 'literal';
      break;
    case Compare:
      f = 'comparison';
      break;
    case IfExp:
      f = 'conditional expression';
      break;
    default:
      goog.asserts.fail('unhandled expression in assignment');
    }
    if (f)
      throw new Sk.builtin.SyntaxError('can\'t ' + (c === Store ? 'assign to' : 'delete') + ' ' + f, a.c_filename, d.lineno);
    if (e)
      for (b = 0; b < e.length; ++b)
        setContext(a, e[b], c, d);
  }
  var operatorMap = {};
  (function () {
    operatorMap[TOK.T_VBAR] = BitOr;
    operatorMap[TOK.T_VBAR] = BitOr;
    operatorMap[TOK.T_CIRCUMFLEX] = BitXor;
    operatorMap[TOK.T_AMPER] = BitAnd;
    operatorMap[TOK.T_LEFTSHIFT] = LShift;
    operatorMap[TOK.T_RIGHTSHIFT] = RShift;
    operatorMap[TOK.T_PLUS] = Add;
    operatorMap[TOK.T_MINUS] = Sub;
    operatorMap[TOK.T_STAR] = Mult;
    operatorMap[TOK.T_SLASH] = Div;
    operatorMap[TOK.T_DOUBLESLASH] = FloorDiv;
    operatorMap[TOK.T_PERCENT] = Mod;
  }());
  function getOperator(a) {
    goog.asserts.assert(void 0 !== operatorMap[a.type]);
    return operatorMap[a.type];
  }
  function astForCompOp(a, b) {
    REQ(b, SYM.comp_op);
    if (1 === NCH(b))
      switch (b = CHILD(b, 0), b.type) {
      case TOK.T_LESS:
        return Lt;
      case TOK.T_GREATER:
        return Gt;
      case TOK.T_EQEQUAL:
        return Eq;
      case TOK.T_LESSEQUAL:
        return LtE;
      case TOK.T_GREATEREQUAL:
        return GtE;
      case TOK.T_NOTEQUAL:
        return NotEq;
      case TOK.T_NAME:
        if ('in' === b.value)
          return In_;
        if ('is' === b.value)
          return Is;
      }
    else if (2 === NCH(b) && CHILD(b, 0).type === TOK.T_NAME) {
      if ('in' === CHILD(b, 1).value)
        return NotIn;
      if ('is' === CHILD(b, 0).value)
        return IsNot;
    }
    goog.asserts.fail('invalid comp_op');
  }
  function seqForTestlist(a, b) {
    goog.asserts.assert(b.type === SYM.testlist || b.type === SYM.listmaker || b.type === SYM.testlist_gexp || b.type === SYM.testlist_safe || b.type === SYM.testlist1);
    for (var c = [], d = 0; d < NCH(b); d += 2)
      goog.asserts.assert(CHILD(b, d).type === SYM.test || CHILD(b, d).type === SYM.old_test), c[d / 2] = astForExpr(a, CHILD(b, d));
    return c;
  }
  function astForSuite(a, b) {
    REQ(b, SYM.suite);
    var c = [], d = 0, e;
    if (CHILD(b, 0).type === SYM.simple_stmt) {
      b = CHILD(b, 0);
      e = NCH(b) - 1;
      CHILD(b, e - 1).type === TOK.T_SEMI && (e -= 1);
      for (var f = 0; f < e; f += 2)
        c[d++] = astForStmt(a, CHILD(b, f));
    } else
      for (f = 2; f < NCH(b) - 1; ++f)
        if (e = CHILD(b, f), REQ(e, SYM.stmt), 1 === numStmts(e))
          c[d++] = astForStmt(a, e);
        else {
          e = CHILD(e, 0);
          REQ(e, SYM.simple_stmt);
          for (var g = 0; g < NCH(e); g += 2) {
            if (0 === NCH(CHILD(e, g))) {
              goog.asserts.assert(g + 1 === NCH(e));
              break;
            }
            c[d++] = astForStmt(a, CHILD(e, g));
          }
        }
    goog.asserts.assert(d === numStmts(b));
    return c;
  }
  function astForExceptClause(a, b, c) {
    REQ(b, SYM.except_clause);
    REQ(c, SYM.suite);
    if (1 === NCH(b))
      return new ExceptHandler(null, null, astForSuite(a, c), b.lineno, b.col_offset);
    if (2 === NCH(b))
      return new ExceptHandler(astForExpr(a, CHILD(b, 1)), null, astForSuite(a, c), b.lineno, b.col_offset);
    if (4 === NCH(b)) {
      var d = astForExpr(a, CHILD(b, 3));
      setContext(a, d, Store, CHILD(b, 3));
      return new ExceptHandler(astForExpr(a, CHILD(b, 1)), d, astForSuite(a, c), b.lineno, b.col_offset);
    }
    goog.asserts.fail('wrong number of children for except clause');
  }
  function astForTryStmt(a, b) {
    var c = NCH(b), d = (c - 3) / 3, e, f = [], g = null;
    REQ(b, SYM.try_stmt);
    e = astForSuite(a, CHILD(b, 2));
    if (CHILD(b, c - 3).type === TOK.T_NAME)
      'finally' === CHILD(b, c - 3).value ? (9 <= c && CHILD(b, c - 6).type === TOK.T_NAME && (f = astForSuite(a, CHILD(b, c - 4)), d--), g = astForSuite(a, CHILD(b, c - 1))) : f = astForSuite(a, CHILD(b, c - 1)), d--;
    else if (CHILD(b, c - 3).type !== SYM.except_clause)
      throw new Sk.builtin.SyntaxError('malformed \'try\' statement', a.c_filename, b.lineno);
    if (0 < d) {
      for (var c = [], h = 0; h < d; ++h)
        c[h] = astForExceptClause(a, CHILD(b, 3 + 3 * h), CHILD(b, 5 + 3 * h));
      d = new TryExcept(e, c, f, b.lineno, b.col_offset);
      if (!g)
        return d;
      e = [d];
    }
    goog.asserts.assert(null !== g);
    return new TryFinally(e, g, b.lineno, b.col_offset);
  }
  function astForDottedName(a, b) {
    REQ(b, SYM.dotted_name);
    for (var c = b.lineno, d = b.col_offset, e = strobj(CHILD(b, 0).value), f = new Name(e, Load, c, d), g = 2; g < NCH(b); g += 2)
      e = strobj(CHILD(b, g).value), f = new Attribute(f, e, Load, c, d);
    return f;
  }
  function astForDecorator(a, b) {
    REQ(b, SYM.decorator);
    REQ(CHILD(b, 0), TOK.T_AT);
    REQ(CHILD(b, NCH(b) - 1), TOK.T_NEWLINE);
    var c = astForDottedName(a, CHILD(b, 1));
    return 3 === NCH(b) ? c : 5 === NCH(b) ? new Call(c, [], [], null, null, b.lineno, b.col_offset) : astForCall(a, CHILD(b, 3), c);
  }
  function astForDecorators(a, b) {
    REQ(b, SYM.decorators);
    for (var c = [], d = 0; d < NCH(b); ++d)
      c[d] = astForDecorator(a, CHILD(b, d));
    return c;
  }
  function astForDecorated(a, b) {
    REQ(b, SYM.decorated);
    var c = astForDecorators(a, CHILD(b, 0));
    goog.asserts.assert(CHILD(b, 1).type === SYM.funcdef || CHILD(b, 1).type === SYM.classdef);
    var d = null;
    CHILD(b, 1).type === SYM.funcdef ? d = astForFuncdef(a, CHILD(b, 1), c) : CHILD(b, 1) === SYM.classdef && (d = astForClassdef(a, CHILD(b, 1), c));
    d && (d.lineno = b.lineno, d.col_offset = b.col_offset);
    return d;
  }
  function astForWithVar(a, b) {
    REQ(b, SYM.with_var);
    return astForExpr(a, CHILD(b, 1));
  }
  function astForWithStmt(a, b) {
    var c = 3;
    goog.asserts.assert(b.type === SYM.with_stmt);
    var d = astForExpr(a, CHILD(b, 1));
    if (CHILD(b, 2).type === SYM.with_var) {
      var e = astForWithVar(a, CHILD(b, 2));
      setContext(a, e, Store, b);
      c = 4;
    }
    return new With_(d, e, astForSuite(a, CHILD(b, c)), b.lineno, b.col_offset);
  }
  function astForExecStmt(a, b) {
    var c, d = null, e = null, f = NCH(b);
    goog.asserts.assert(2 === f || 4 === f || 6 === f);
    REQ(b, SYM.exec_stmt);
    c = astForExpr(a, CHILD(b, 1));
    4 <= f && (d = astForExpr(a, CHILD(b, 3)));
    6 === f && (e = astForExpr(a, CHILD(b, 5)));
    return new Exec(c, d, e, b.lineno, b.col_offset);
  }
  function astForIfStmt(a, b) {
    REQ(b, SYM.if_stmt);
    if (4 === NCH(b))
      return new If_(astForExpr(a, CHILD(b, 1)), astForSuite(a, CHILD(b, 3)), [], b.lineno, b.col_offset);
    var c = CHILD(b, 4).value.charAt(2);
    if ('s' === c)
      return new If_(astForExpr(a, CHILD(b, 1)), astForSuite(a, CHILD(b, 3)), astForSuite(a, CHILD(b, 6)), b.lineno, b.col_offset);
    if ('i' === c) {
      var c = NCH(b) - 4, d = !1, e = [];
      CHILD(b, c + 1).type === TOK.T_NAME && 's' === CHILD(b, c + 1).value.charAt(2) && (d = !0, c -= 3);
      c /= 4;
      d && (e = [new If_(astForExpr(a, CHILD(b, NCH(b) - 6)), astForSuite(a, CHILD(b, NCH(b) - 4)), astForSuite(a, CHILD(b, NCH(b) - 1)), CHILD(b, NCH(b) - 6).lineno, CHILD(b, NCH(b) - 6).col_offset)], c--);
      for (d = 0; d < c; ++d)
        var f = 5 + 4 * (c - d - 1), e = [new If_(astForExpr(a, CHILD(b, f)), astForSuite(a, CHILD(b, f + 2)), e, CHILD(b, f).lineno, CHILD(b, f).col_offset)];
      return new If_(astForExpr(a, CHILD(b, 1)), astForSuite(a, CHILD(b, 3)), e, b.lineno, b.col_offset);
    }
    goog.asserts.fail('unexpected token in \'if\' statement');
  }
  function astForExprlist(a, b, c) {
    REQ(b, SYM.exprlist);
    for (var d = [], e = 0; e < NCH(b); e += 2) {
      var f = astForExpr(a, CHILD(b, e));
      d[e / 2] = f;
      c && setContext(a, f, c, CHILD(b, e));
    }
    return d;
  }
  function astForDelStmt(a, b) {
    REQ(b, SYM.del_stmt);
    return new Delete_(astForExprlist(a, CHILD(b, 1), Del), b.lineno, b.col_offset);
  }
  function astForGlobalStmt(a, b) {
    REQ(b, SYM.global_stmt);
    for (var c = [], d = 1; d < NCH(b); d += 2)
      c[(d - 1) / 2] = strobj(CHILD(b, d).value);
    return new Global(c, b.lineno, b.col_offset);
  }
  function astForAssertStmt(a, b) {
    REQ(b, SYM.assert_stmt);
    if (2 === NCH(b))
      return new Assert(astForExpr(a, CHILD(b, 1)), null, b.lineno, b.col_offset);
    if (4 === NCH(b))
      return new Assert(astForExpr(a, CHILD(b, 1)), astForExpr(a, CHILD(b, 3)), b.lineno, b.col_offset);
    goog.asserts.fail('improper number of parts to assert stmt');
  }
  function aliasForImportName(a, b) {
    a:
      for (;;)
        switch (b.type) {
        case SYM.import_as_name:
          var c = null, d = strobj(CHILD(b, 0).value);
          3 === NCH(b) && (c = CHILD(b, 2).value);
          return new alias(d, null == c ? null : strobj(c));
        case SYM.dotted_as_name:
          if (1 === NCH(b)) {
            b = CHILD(b, 0);
            continue a;
          } else
            return c = aliasForImportName(a, CHILD(b, 0)), goog.asserts.assert(!c.asname), c.asname = strobj(CHILD(b, 2).value), c;
        case SYM.dotted_name:
          if (1 === NCH(b))
            return new alias(strobj(CHILD(b, 0).value), null);
          c = '';
          for (d = 0; d < NCH(b); d += 2)
            c += CHILD(b, d).value + '.';
          return new alias(strobj(c.substr(0, c.length - 1)), null);
        case TOK.T_STAR:
          return new alias(strobj('*'), null);
        default:
          throw new Sk.builtin.SyntaxError('unexpected import name', a.c_filename, b.lineno);
        }
  }
  function astForImportStmt(a, b) {
    REQ(b, SYM.import_stmt);
    var c = b.lineno, d = b.col_offset;
    b = CHILD(b, 0);
    if (b.type === SYM.import_name) {
      b = CHILD(b, 1);
      REQ(b, SYM.dotted_as_names);
      for (var e = [], f = 0; f < NCH(b); f += 2)
        e[f / 2] = aliasForImportName(a, CHILD(b, f));
      return new Import_(e, c, d);
    }
    if (b.type === SYM.import_from) {
      for (var g = null, h = 0, e = 1; e < NCH(b); ++e) {
        if (CHILD(b, e).type === SYM.dotted_name) {
          g = aliasForImportName(a, CHILD(b, e));
          e++;
          break;
        } else if (CHILD(b, e).type !== TOK.T_DOT)
          break;
        h++;
      }
      ++e;
      switch (CHILD(b, e).type) {
      case TOK.T_STAR:
        b = CHILD(b, e);
        break;
      case TOK.T_LPAR:
        b = CHILD(b, e + 1);
        NCH(b);
        break;
      case SYM.import_as_names:
        b = CHILD(b, e);
        e = NCH(b);
        if (0 === e % 2)
          throw new Sk.builtin.SyntaxError('trailing comma not allowed without surrounding parentheses', a.c_filename, b.lineno);
        break;
      default:
        throw new Sk.builtin.SyntaxError('Unexpected node-type in from-import', a.c_filename, b.lineno);
      }
      e = [];
      if (b.type === TOK.T_STAR)
        e[0] = aliasForImportName(a, b);
      else
        for (f = 0; f < NCH(b); f += 2)
          e[f / 2] = aliasForImportName(a, CHILD(b, f));
      return new ImportFrom(strobj(g ? g.name.v : ''), e, h, c, d);
    }
    throw new Sk.builtin.SyntaxError('unknown import statement', a.c_filename, b.lineno);
  }
  function astForTestlistGexp(a, b) {
    goog.asserts.assert(b.type === SYM.testlist_gexp || b.type === SYM.argument);
    return 1 < NCH(b) && CHILD(b, 1).type === SYM.gen_for ? astForGenexp(a, b) : astForTestlist(a, b);
  }
  function astForListcomp(a, b) {
    function c(a, b) {
      for (var c = 0;;) {
        REQ(b, SYM.list_iter);
        if (CHILD(b, 0).type === SYM.list_for)
          return c;
        b = CHILD(b, 0);
        REQ(b, SYM.list_if);
        c++;
        if (2 == NCH(b))
          return c;
        b = CHILD(b, 2);
      }
    }
    REQ(b, SYM.listmaker);
    goog.asserts.assert(1 < NCH(b));
    for (var d = astForExpr(a, CHILD(b, 0)), e = function (a, b) {
          var c = 0, d = CHILD(b, 1);
          a:
            for (;;) {
              c++;
              REQ(d, SYM.list_for);
              if (5 === NCH(d))
                d = CHILD(d, 4);
              else
                return c;
              b:
                for (;;) {
                  REQ(d, SYM.list_iter);
                  d = CHILD(d, 0);
                  if (d.type === SYM.list_for)
                    continue a;
                  else if (d.type === SYM.list_if)
                    if (3 === NCH(d)) {
                      d = CHILD(d, 2);
                      continue b;
                    } else
                      return c;
                  break;
                }
              break;
            }
        }(a, b), f = [], g = CHILD(b, 1), h = 0; h < e; ++h) {
      REQ(g, SYM.list_for);
      var k = CHILD(g, 1), l = astForExprlist(a, k, Store), m = astForTestlist(a, CHILD(g, 3)), k = 1 === NCH(k) ? new comprehension(l[0], m, []) : new comprehension(new Tuple(l, Store, g.lineno, g.col_offset), m, []);
      if (5 === NCH(g)) {
        for (var g = CHILD(g, 4), l = c(a, g), m = [], n = 0; n < l; ++n)
          REQ(g, SYM.list_iter), g = CHILD(g, 0), REQ(g, SYM.list_if), m[n] = astForExpr(a, CHILD(g, 1)), 3 === NCH(g) && (g = CHILD(g, 2));
        g.type === SYM.list_iter && (g = CHILD(g, 0));
        k.ifs = m;
      }
      f[h] = k;
    }
    return new ListComp(d, f, b.lineno, b.col_offset);
  }
  function astForFactor(a, b) {
    if (CHILD(b, 0).type === TOK.T_MINUS && 2 === NCH(b)) {
      var c = CHILD(b, 1);
      if (c.type === SYM.factor && 1 === NCH(c) && (c = CHILD(c, 0), c.type === SYM.power && 1 === NCH(c) && (c = CHILD(c, 0), c.type === SYM.atom))) {
        var d = CHILD(c, 0);
        if (d.type === TOK.T_NUMBER)
          return d.value = '-' + d.value, astForAtom(a, c);
      }
    }
    c = astForExpr(a, CHILD(b, 1));
    switch (CHILD(b, 0).type) {
    case TOK.T_PLUS:
      return new UnaryOp(UAdd, c, b.lineno, b.col_offset);
    case TOK.T_MINUS:
      return new UnaryOp(USub, c, b.lineno, b.col_offset);
    case TOK.T_TILDE:
      return new UnaryOp(Invert, c, b.lineno, b.col_offset);
    }
    goog.asserts.fail('unhandled factor');
  }
  function astForForStmt(a, b) {
    var c = [];
    REQ(b, SYM.for_stmt);
    9 === NCH(b) && (c = astForSuite(a, CHILD(b, 8)));
    var d = CHILD(b, 1), e = astForExprlist(a, d, Store), d = 1 === NCH(d) ? e[0] : new Tuple(e, Store, b.lineno, b.col_offset);
    return new For_(d, astForTestlist(a, CHILD(b, 3)), astForSuite(a, CHILD(b, 5)), c, b.lineno, b.col_offset);
  }
  function astForCall(a, b, c) {
    REQ(b, SYM.arglist);
    for (var d = 0, e = 0, f = 0, g = 0; g < NCH(b); ++g) {
      var h = CHILD(b, g);
      h.type === SYM.argument && (1 === NCH(h) ? d++ : CHILD(h, 1).type === SYM.gen_for ? f++ : e++);
    }
    if (1 < f || f && (d || e))
      throw new Sk.builtin.SyntaxError('Generator expression must be parenthesized if not sole argument', a.c_filename, b.lineno);
    if (255 < d + e + f)
      throw new Sk.builtin.SyntaxError('more than 255 arguments', a.c_filename, b.lineno);
    for (var f = [], k = [], e = d = 0, l = null, m = null, g = 0; g < NCH(b); ++g)
      if (h = CHILD(b, g), h.type === SYM.argument)
        if (1 === NCH(h)) {
          if (e)
            throw new Sk.builtin.SyntaxError('non-keyword arg after keyword arg', a.c_filename, b.lineno);
          if (l)
            throw new Sk.builtin.SyntaxError('only named arguments may follow *expression', a.c_filename, b.lineno);
          f[d++] = astForExpr(a, CHILD(h, 0));
        } else if (CHILD(h, 1).type === SYM.gen_for)
          f[d++] = astForGenexp(a, h);
        else {
          var n = astForExpr(a, CHILD(h, 0));
          if (n.constructor === Lambda)
            throw new Sk.builtin.SyntaxError('lambda cannot contain assignment', a.c_filename, b.lineno);
          if (n.constructor !== Name)
            throw new Sk.builtin.SyntaxError('keyword can\'t be an expression', a.c_filename, b.lineno);
          n = n.id;
          forbiddenCheck(a, CHILD(h, 0), n, b.lineno);
          for (var p = 0; p < e; ++p)
            if (k[p].arg === n)
              throw new Sk.builtin.SyntaxError('keyword argument repeated', a.c_filename, b.lineno);
          k[e++] = new keyword(n, astForExpr(a, CHILD(h, 2)));
        }
      else
        h.type === TOK.T_STAR ? l = astForExpr(a, CHILD(b, ++g)) : h.type === TOK.T_DOUBLESTAR && (m = astForExpr(a, CHILD(b, ++g)));
    return new Call(c, f, k, l, m, c.lineno, c.col_offset);
  }
  function astForTrailer(a, b, c) {
    REQ(b, SYM.trailer);
    if (CHILD(b, 0).type === TOK.T_LPAR)
      return 2 === NCH(b) ? new Call(c, [], [], null, null, b.lineno, b.col_offset) : astForCall(a, CHILD(b, 1), c);
    if (CHILD(b, 0).type === TOK.T_DOT)
      return new Attribute(c, strobj(CHILD(b, 1).value), Load, b.lineno, b.col_offset);
    REQ(CHILD(b, 0), TOK.T_LSQB);
    REQ(CHILD(b, 2), TOK.T_RSQB);
    b = CHILD(b, 1);
    if (1 === NCH(b))
      return new Subscript(c, astForSlice(a, CHILD(b, 0)), Load, b.lineno, b.col_offset);
    for (var d = !0, e = [], f = 0; f < NCH(b); f += 2) {
      var g = astForSlice(a, CHILD(b, f));
      g.constructor !== Index && (d = !1);
      e[f / 2] = g;
    }
    if (!d)
      return new Subscript(c, new ExtSlice(e), Load, b.lineno, b.col_offset);
    a = [];
    for (f = 0; f < e.length; ++f)
      g = e[f], goog.asserts.assert(g.constructor === Index && null !== g.value && void 0 !== g.value), a[f] = g.value;
    e = new Tuple(a, Load, b.lineno, b.col_offset);
    return new Subscript(c, new Index(e), Load, b.lineno, b.col_offset);
  }
  function astForFlowStmt(a, b) {
    var c;
    REQ(b, SYM.flow_stmt);
    c = CHILD(b, 0);
    switch (c.type) {
    case SYM.break_stmt:
      return new Break_(b.lineno, b.col_offset);
    case SYM.continue_stmt:
      return new Continue_(b.lineno, b.col_offset);
    case SYM.yield_stmt:
      return new Expr(astForExpr(a, CHILD(c, 0)), b.lineno, b.col_offset);
    case SYM.return_stmt:
      return 1 === NCH(c) ? new Return_(null, b.lineno, b.col_offset) : new Return_(astForTestlist(a, CHILD(c, 1)), b.lineno, b.col_offset);
    case SYM.raise_stmt:
      if (1 === NCH(c))
        return new Raise(null, null, null, b.lineno, b.col_offset);
      if (2 === NCH(c))
        return new Raise(astForExpr(a, CHILD(c, 1)), null, null, b.lineno, b.col_offset);
      if (4 === NCH(c))
        return new Raise(astForExpr(a, CHILD(c, 1)), astForExpr(a, CHILD(c, 3)), null, b.lineno, b.col_offset);
      if (6 === NCH(c))
        return new Raise(astForExpr(a, CHILD(c, 1)), astForExpr(a, CHILD(c, 3)), astForExpr(a, CHILD(c, 5)), b.lineno, b.col_offset);
    default:
      goog.asserts.fail('unexpected flow_stmt');
    }
    goog.asserts.fail('unhandled flow statement');
  }
  function astForArguments(a, b) {
    var c, d = null, e = null;
    if (b.type === SYM.parameters) {
      if (2 === NCH(b))
        return new arguments_([], null, null, []);
      b = CHILD(b, 1);
    }
    REQ(b, SYM.varargslist);
    for (var f = [], g = [], h = !1, k = 0, l = 0, m = 0; k < NCH(b);)
      switch (c = CHILD(b, k), c.type) {
      case SYM.fpdef:
        var n = 0;
        a:
          for (;;) {
            if (k + 1 < NCH(b) && CHILD(b, k + 1).type === TOK.T_EQUAL)
              g[l++] = astForExpr(a, CHILD(b, k + 2)), k += 2, h = !0;
            else if (h) {
              if (n)
                throw new Sk.builtin.SyntaxError('parenthesized arg with default', a.c_filename, b.lineno);
              throw new Sk.builtin.SyntaxError('non-default argument follows default argument', a.c_filename, b.lineno);
            }
            if (3 === NCH(c)) {
              c = CHILD(c, 1);
              if (1 !== NCH(c))
                throw new Sk.builtin.SyntaxError('tuple parameter unpacking has been removed', a.c_filename, b.lineno);
              n = !0;
              c = CHILD(c, 0);
              goog.asserts.assert(c.type === SYM.fpdef);
              continue a;
            }
            if (CHILD(c, 0).type === TOK.T_NAME) {
              forbiddenCheck(a, b, CHILD(c, 0).value, b.lineno);
              var p = strobj(CHILD(c, 0).value);
              f[m++] = new Name(p, Param, c.lineno, c.col_offset);
            }
            k += 2;
            if (n)
              throw new Sk.builtin.SyntaxError('parenthesized argument names are invalid', a.c_filename, b.lineno);
            break;
          }
        break;
      case TOK.T_STAR:
        forbiddenCheck(a, CHILD(b, k + 1), CHILD(b, k + 1).value, b.lineno);
        d = strobj(CHILD(b, k + 1).value);
        k += 3;
        break;
      case TOK.T_DOUBLESTAR:
        forbiddenCheck(a, CHILD(b, k + 1), CHILD(b, k + 1).value, b.lineno);
        e = strobj(CHILD(b, k + 1).value);
        k += 3;
        break;
      default:
        goog.asserts.fail('unexpected node in varargslist');
      }
    return new arguments_(f, d, e, g);
  }
  function astForFuncdef(a, b, c) {
    REQ(b, SYM.funcdef);
    var d = strobj(CHILD(b, 1).value);
    forbiddenCheck(a, CHILD(b, 1), CHILD(b, 1).value, b.lineno);
    var e = astForArguments(a, CHILD(b, 2));
    a = astForSuite(a, CHILD(b, 4));
    return new FunctionDef(d, e, a, c, b.lineno, b.col_offset);
  }
  function astForClassBases(a, b) {
    goog.asserts.assert(0 < NCH(b));
    REQ(b, SYM.testlist);
    return 1 === NCH(b) ? [astForExpr(a, CHILD(b, 0))] : seqForTestlist(a, b);
  }
  function astForClassdef(a, b, c) {
    REQ(b, SYM.classdef);
    forbiddenCheck(a, b, CHILD(b, 1).value, b.lineno);
    var d = strobj(CHILD(b, 1).value);
    if (4 === NCH(b))
      return new ClassDef(d, [], astForSuite(a, CHILD(b, 3)), c, b.lineno, b.col_offset);
    if (CHILD(b, 3).type === TOK.T_RPAR)
      return new ClassDef(d, [], astForSuite(a, CHILD(b, 5)), c, b.lineno, b.col_offset);
    var e = astForClassBases(a, CHILD(b, 3));
    a = astForSuite(a, CHILD(b, 6));
    return new ClassDef(d, e, a, c, b.lineno, b.col_offset);
  }
  function astForLambdef(a, b) {
    var c, d;
    3 === NCH(b) ? (c = new arguments_([], null, null, []), d = astForExpr(a, CHILD(b, 2))) : (c = astForArguments(a, CHILD(b, 1)), d = astForExpr(a, CHILD(b, 3)));
    return new Lambda(c, d, b.lineno, b.col_offset);
  }
  function astForGenexp(a, b) {
    function c(a, b) {
      for (var c = 0;;) {
        REQ(b, SYM.gen_iter);
        if (CHILD(b, 0).type === SYM.gen_for)
          return c;
        b = CHILD(b, 0);
        REQ(b, SYM.gen_if);
        c++;
        if (2 == NCH(b))
          return c;
        b = CHILD(b, 2);
      }
    }
    goog.asserts.assert(b.type === SYM.testlist_gexp || b.type === SYM.argument);
    goog.asserts.assert(1 < NCH(b));
    for (var d = astForExpr(a, CHILD(b, 0)), e = function (a, b) {
          var c = 0, d = CHILD(b, 1);
          a:
            for (;;) {
              c++;
              REQ(d, SYM.gen_for);
              if (5 === NCH(d))
                d = CHILD(d, 4);
              else
                return c;
              b:
                for (;;) {
                  REQ(d, SYM.gen_iter);
                  d = CHILD(d, 0);
                  if (d.type === SYM.gen_for)
                    continue a;
                  else if (d.type === SYM.gen_if)
                    if (3 === NCH(d)) {
                      d = CHILD(d, 2);
                      continue b;
                    } else
                      return c;
                  break;
                }
              break;
            }
          goog.asserts.fail('logic error in countGenFors');
        }(a, b), f = [], g = CHILD(b, 1), h = 0; h < e; ++h) {
      REQ(g, SYM.gen_for);
      var k = CHILD(g, 1), l = astForExprlist(a, k, Store), m = astForExpr(a, CHILD(g, 3)), k = 1 === NCH(k) ? new comprehension(l[0], m, []) : new comprehension(new Tuple(l, Store, g.lineno, g.col_offset), m, []);
      if (5 === NCH(g)) {
        for (var g = CHILD(g, 4), l = c(a, g), n = [], p = 0; p < l; ++p)
          REQ(g, SYM.gen_iter), g = CHILD(g, 0), REQ(g, SYM.gen_if), m = astForExpr(a, CHILD(g, 1)), n[p] = m, 3 === NCH(g) && (g = CHILD(g, 2));
        g.type === SYM.gen_iter && (g = CHILD(g, 0));
        k.ifs = n;
      }
      f[h] = k;
    }
    return new GeneratorExp(d, f, b.lineno, b.col_offset);
  }
  function astForWhileStmt(a, b) {
    REQ(b, SYM.while_stmt);
    if (4 === NCH(b))
      return new While_(astForExpr(a, CHILD(b, 1)), astForSuite(a, CHILD(b, 3)), [], b.lineno, b.col_offset);
    if (7 === NCH(b))
      return new While_(astForExpr(a, CHILD(b, 1)), astForSuite(a, CHILD(b, 3)), astForSuite(a, CHILD(b, 6)), b.lineno, b.col_offset);
    goog.asserts.fail('wrong number of tokens for \'while\' stmt');
  }
  function astForAugassign(a, b) {
    REQ(b, SYM.augassign);
    b = CHILD(b, 0);
    switch (b.value.charAt(0)) {
    case '+':
      return Add;
    case '-':
      return Sub;
    case '/':
      return '/' === b.value.charAt(1) ? FloorDiv : Div;
    case '%':
      return Mod;
    case '<':
      return LShift;
    case '>':
      return RShift;
    case '&':
      return BitAnd;
    case '^':
      return BitXor;
    case '|':
      return BitOr;
    case '*':
      return '*' === b.value.charAt(1) ? Pow : Mult;
    default:
      goog.asserts.fail('invalid augassign');
    }
  }
  function astForBinop(a, b) {
    for (var c = new BinOp(astForExpr(a, CHILD(b, 0)), getOperator(CHILD(b, 1)), astForExpr(a, CHILD(b, 2)), b.lineno, b.col_offset), d = (NCH(b) - 1) / 2, e = 1; e < d; ++e)
      var f = CHILD(b, 2 * e + 1), g = getOperator(f), h = astForExpr(a, CHILD(b, 2 * e + 2)), c = new BinOp(c, g, h, f.lineno, f.col_offset);
    return c;
  }
  function astForTestlist(a, b) {
    goog.asserts.assert(0 < NCH(b));
    b.type === SYM.testlist_gexp ? 1 < NCH(b) && goog.asserts.assert(CHILD(b, 1).type !== SYM.gen_for) : goog.asserts.assert(b.type === SYM.testlist || b.type === SYM.testlist_safe || b.type === SYM.testlist1);
    return 1 === NCH(b) ? astForExpr(a, CHILD(b, 0)) : new Tuple(seqForTestlist(a, b), Load, b.lineno, b.col_offset);
  }
  function astForExprStmt(a, b) {
    REQ(b, SYM.expr_stmt);
    if (1 === NCH(b))
      return new Expr(astForTestlist(a, CHILD(b, 0)), b.lineno, b.col_offset);
    if (CHILD(b, 1).type === SYM.augassign) {
      var c = CHILD(b, 0), d = astForTestlist(a, c);
      switch (d.constructor) {
      case GeneratorExp:
        throw new Sk.builtin.SyntaxError('augmented assignment to generator expression not possible', a.c_filename, b.lineno);
      case Yield:
        throw new Sk.builtin.SyntaxError('augmented assignment to yield expression not possible', a.c_filename, b.lineno);
      case Name:
        forbiddenCheck(a, c, d.id, b.lineno);
        break;
      case Attribute:
      case Subscript:
        break;
      default:
        throw new Sk.builtin.SyntaxError('illegal expression for augmented assignment', a.c_filename, b.lineno);
      }
      setContext(a, d, Store, c);
      c = CHILD(b, 2);
      c = c.type === SYM.testlist ? astForTestlist(a, c) : astForExpr(a, c);
      return new AugAssign(d, astForAugassign(a, CHILD(b, 1)), c, b.lineno, b.col_offset);
    }
    REQ(CHILD(b, 1), TOK.T_EQUAL);
    for (var d = [], e = 0; e < NCH(b) - 2; e += 2) {
      c = CHILD(b, e);
      if (c.type === SYM.yield_expr)
        throw new Sk.builtin.SyntaxError('assignment to yield expression not possible', a.c_filename, b.lineno);
      c = astForTestlist(a, c);
      setContext(a, c, Store, CHILD(b, e));
      d[e / 2] = c;
    }
    c = CHILD(b, NCH(b) - 1);
    c = c.type === SYM.testlist ? astForTestlist(a, c) : astForExpr(a, c);
    return new Assign(d, c, b.lineno, b.col_offset);
  }
  function astForIfexpr(a, b) {
    goog.asserts.assert(5 === NCH(b));
    return new IfExp(astForExpr(a, CHILD(b, 2)), astForExpr(a, CHILD(b, 0)), astForExpr(a, CHILD(b, 4)), b.lineno, b.col_offset);
  }
  function parsestr(a, b) {
    var c = b.charAt(0), d = !1;
    if ('u' === c || 'U' === c)
      b = b.substr(1), c = b.charAt(0);
    else if ('r' === c || 'R' === c)
      b = b.substr(1), c = b.charAt(0), d = !0;
    goog.asserts.assert('b' !== c && 'B' !== c, 'todo; haven\'t done b\'\' strings yet');
    goog.asserts.assert('\'' === c || '"' === c && b.charAt(b.length - 1) === c);
    b = b.substr(1, b.length - 2);
    4 <= b.length && (b.charAt(0) === c && b.charAt(1) === c) && (goog.asserts.assert(b.charAt(b.length - 1) === c && b.charAt(b.length - 2) === c), b = b.substr(2, b.length - 4));
    if (d || -1 === b.indexOf('\\'))
      c = strobj(decodeURIComponent(escape(b)));
    else {
      for (var c = strobj, d = b, e = d.length, f = '', g = 0; g < e; ++g) {
        var h = d.charAt(g);
        if ('\\' === h)
          if (++g, h = d.charAt(g), 'n' === h)
            f += '\n';
          else if ('\\' === h)
            f += '\\';
          else if ('t' === h)
            f += '\t';
          else if ('r' === h)
            f += '\r';
          else if ('b' === h)
            f += '\b';
          else if ('f' === h)
            f += '\f';
          else if ('v' === h)
            f += '\x0B';
          else if ('0' === h)
            f += '\0';
          else if ('"' === h)
            f += '"';
          else if ('\'' === h)
            f += '\'';
          else {
            if ('\n' !== h)
              if ('x' === h)
                var h = d.charAt(++g), k = d.charAt(++g), f = f + String.fromCharCode(parseInt(h + k, 16));
              else if ('u' === h || 'U' === h)
                var h = d.charAt(++g), k = d.charAt(++g), l = d.charAt(++g), m = d.charAt(++g), f = f + String.fromCharCode(parseInt(h + k, 16), parseInt(l + m, 16));
              else
                f += '\\' + h;
          }
        else
          f += h;
      }
      c = c(f);
    }
    return c;
  }
  function parsestrplus(a, b) {
    REQ(CHILD(b, 0), TOK.T_STRING);
    for (var c = new Sk.builtin.str(''), d = 0; d < NCH(b); ++d)
      try {
        c = c.sq$concat(parsestr(a, CHILD(b, d).value));
      } catch (e) {
        throw new Sk.builtin.SyntaxError('invalid string (possibly contains a unicode character)', a.c_filename, CHILD(b, d).lineno);
      }
    return c;
  }
  function parsenumber(a, b, c) {
    var d = b.charAt(b.length - 1);
    if ('j' === d || 'J' === d)
      throw new Sk.builtin.SyntaxError('complex numbers are currently unsupported', a.c_filename, c);
    if ('l' === d || 'L' === d)
      return Sk.longFromStr(b.substr(0, b.length - 1), 0);
    if (-1 !== b.indexOf('.'))
      return new Sk.builtin.nmber(parseFloat(b), Sk.builtin.nmber.float$);
    c = b;
    a = !1;
    '-' === b.charAt(0) && (c = b.substr(1), a = !0);
    if ('0' !== c.charAt(0) || 'x' !== c.charAt(1) && 'X' !== c.charAt(1)) {
      if (-1 !== b.indexOf('e') || -1 !== b.indexOf('E'))
        return new Sk.builtin.nmber(parseFloat(b), Sk.builtin.nmber.float$);
      if ('0' !== c.charAt(0) || 'b' !== c.charAt(1) && 'B' !== c.charAt(1))
        if ('0' === c.charAt(0))
          if ('0' === c)
            c = 0;
          else {
            c = c.substring(1);
            if ('o' === c.charAt(0) || 'O' === c.charAt(0))
              c = c.substring(1);
            c = parseInt(c, 8);
          }
        else
          c = parseInt(c, 10);
      else
        c = c.substring(2), c = parseInt(c, 2);
    } else
      c = c.substring(2), c = parseInt(c, 16);
    return c > Sk.builtin.lng.threshold$ && Math.floor(c) === c && -1 === b.indexOf('e') && -1 === b.indexOf('E') ? Sk.longFromStr(b, 0) : a ? new Sk.builtin.nmber(-c, Sk.builtin.int$) : new Sk.builtin.nmber(c, Sk.builtin.int$);
  }
  function astForSlice(a, b) {
    REQ(b, SYM.subscript);
    var c = CHILD(b, 0), d = null, e = null, f = null;
    if (c.type === TOK.T_DOT)
      return new Ellipsis();
    if (1 === NCH(b) && c.type === SYM.test)
      return new Index(astForExpr(a, c));
    c.type === SYM.test && (d = astForExpr(a, c));
    c.type === TOK.T_COLON ? 1 < NCH(b) && (c = CHILD(b, 1), c.type === SYM.test && (e = astForExpr(a, c))) : 2 < NCH(b) && (c = CHILD(b, 2), c.type === SYM.test && (e = astForExpr(a, c)));
    c = CHILD(b, NCH(b) - 1);
    c.type === SYM.sliceop && (1 === NCH(c) ? (c = CHILD(c, 0), f = new Name(strobj('None'), Load, c.lineno, c.col_offset)) : (c = CHILD(c, 1), c.type === SYM.test && (f = astForExpr(a, c))));
    return new Slice(d, e, f);
  }
  function astForAtom(a, b) {
    var c = CHILD(b, 0);
    switch (c.type) {
    case TOK.T_NAME:
      return new Name(strobj(c.value), Load, b.lineno, b.col_offset);
    case TOK.T_STRING:
      return new Str(parsestrplus(a, b), b.lineno, b.col_offset);
    case TOK.T_NUMBER:
      return new Num(parsenumber(a, c.value, b.lineno), b.lineno, b.col_offset);
    case TOK.T_LPAR:
      return c = CHILD(b, 1), c.type === TOK.T_RPAR ? new Tuple([], Load, b.lineno, b.col_offset) : c.type === SYM.yield_expr ? astForExpr(a, c) : 1 < NCH(c) && CHILD(c, 1).type === SYM.gen_for ? astForGenexp(a, c) : astForTestlistGexp(a, c);
    case TOK.T_LSQB:
      c = CHILD(b, 1);
      if (c.type === TOK.T_RSQB)
        return new List([], Load, b.lineno, b.col_offset);
      REQ(c, SYM.listmaker);
      return 1 === NCH(c) || CHILD(c, 1).type === TOK.T_COMMA ? new List(seqForTestlist(a, c), Load, b.lineno, b.col_offset) : astForListcomp(a, c);
    case TOK.T_LBRACE:
      c = CHILD(b, 1);
      NCH(c);
      for (var d = [], e = [], f = 0; f < NCH(c); f += 4)
        d[f / 4] = astForExpr(a, CHILD(c, f)), e[f / 4] = astForExpr(a, CHILD(c, f + 2));
      return new Dict(d, e, b.lineno, b.col_offset);
    case TOK.T_BACKQUOTE:
      throw new Sk.builtin.SyntaxError('backquote not supported, use repr()', a.c_filename, b.lineno);
    default:
      goog.asserts.fail('unhandled atom', c.type);
    }
  }
  function astForPower(a, b) {
    REQ(b, SYM.power);
    var c = astForAtom(a, CHILD(b, 0));
    if (1 === NCH(b))
      return c;
    for (var d = 1; d < NCH(b); ++d) {
      var e = CHILD(b, d);
      if (e.type !== SYM.trailer)
        break;
      e = astForTrailer(a, e, c);
      e.lineno = c.lineno;
      e.col_offset = c.col_offset;
      c = e;
    }
    CHILD(b, NCH(b) - 1).type === SYM.factor && (d = astForExpr(a, CHILD(b, NCH(b) - 1)), c = new BinOp(c, Pow, d, b.lineno, b.col_offset));
    return c;
  }
  function astForExpr(a, b) {
    a:
      for (;;) {
        switch (b.type) {
        case SYM.test:
        case SYM.old_test:
          if (CHILD(b, 0).type === SYM.lambdef || CHILD(b, 0).type === SYM.old_lambdef)
            return astForLambdef(a, CHILD(b, 0));
          if (1 < NCH(b))
            return astForIfexpr(a, b);
        case SYM.or_test:
        case SYM.and_test:
          if (1 === NCH(b)) {
            b = CHILD(b, 0);
            continue a;
          }
          for (var c = [], d = 0; d < NCH(b); d += 2)
            c[d / 2] = astForExpr(a, CHILD(b, d));
          if ('and' === CHILD(b, 1).value)
            return new BoolOp(And, c, b.lineno, b.col_offset);
          goog.asserts.assert('or' === CHILD(b, 1).value);
          return new BoolOp(Or, c, b.lineno, b.col_offset);
        case SYM.not_test:
          if (1 === NCH(b)) {
            b = CHILD(b, 0);
            continue a;
          } else
            return new UnaryOp(Not, astForExpr(a, CHILD(b, 1)), b.lineno, b.col_offset);
        case SYM.comparison:
          if (1 === NCH(b)) {
            b = CHILD(b, 0);
            continue a;
          } else {
            for (var c = [], e = [], d = 1; d < NCH(b); d += 2)
              c[(d - 1) / 2] = astForCompOp(a, CHILD(b, d)), e[(d - 1) / 2] = astForExpr(a, CHILD(b, d + 1));
            return new Compare(astForExpr(a, CHILD(b, 0)), c, e, b.lineno, b.col_offset);
          }
        case SYM.expr:
        case SYM.xor_expr:
        case SYM.and_expr:
        case SYM.shift_expr:
        case SYM.arith_expr:
        case SYM.term:
          if (1 === NCH(b)) {
            b = CHILD(b, 0);
            continue a;
          }
          return astForBinop(a, b);
        case SYM.yield_expr:
          return d = null, 2 === NCH(b) && (d = astForTestlist(a, CHILD(b, 1))), new Yield(d, b.lineno, b.col_offset);
        case SYM.factor:
          if (1 === NCH(b)) {
            b = CHILD(b, 0);
            continue a;
          }
          return astForFactor(a, b);
        case SYM.power:
          return astForPower(a, b);
        default:
          goog.asserts.fail('unhandled expr', 'n.type: %d', b.type);
        }
        break;
      }
  }
  function astForPrintStmt(a, b) {
    var c = 1, d = null;
    REQ(b, SYM.print_stmt);
    2 <= NCH(b) && CHILD(b, 1).type === TOK.T_RIGHTSHIFT && (d = astForExpr(a, CHILD(b, 2)), c = 4);
    for (var e = [], f = 0; c < NCH(b); c += 2, ++f)
      e[f] = astForExpr(a, CHILD(b, c));
    c = CHILD(b, NCH(b) - 1).type === TOK.T_COMMA ? !1 : !0;
    return new Print(d, e, c, b.lineno, b.col_offset);
  }
  function astForStmt(a, b) {
    b.type === SYM.stmt && (goog.asserts.assert(1 === NCH(b)), b = CHILD(b, 0));
    b.type === SYM.simple_stmt && (goog.asserts.assert(1 === numStmts(b)), b = CHILD(b, 0));
    if (b.type === SYM.small_stmt)
      switch (REQ(b, SYM.small_stmt), b = CHILD(b, 0), b.type) {
      case SYM.expr_stmt:
        return astForExprStmt(a, b);
      case SYM.print_stmt:
        return astForPrintStmt(a, b);
      case SYM.del_stmt:
        return astForDelStmt(a, b);
      case SYM.pass_stmt:
        return new Pass(b.lineno, b.col_offset);
      case SYM.flow_stmt:
        return astForFlowStmt(a, b);
      case SYM.import_stmt:
        return astForImportStmt(a, b);
      case SYM.global_stmt:
        return astForGlobalStmt(a, b);
      case SYM.exec_stmt:
        return astForExecStmt(a, b);
      case SYM.assert_stmt:
        return astForAssertStmt(a, b);
      default:
        goog.asserts.fail('unhandled small_stmt');
      }
    else {
      var c = CHILD(b, 0);
      REQ(b, SYM.compound_stmt);
      switch (c.type) {
      case SYM.if_stmt:
        return astForIfStmt(a, c);
      case SYM.while_stmt:
        return astForWhileStmt(a, c);
      case SYM.for_stmt:
        return astForForStmt(a, c);
      case SYM.try_stmt:
        return astForTryStmt(a, c);
      case SYM.with_stmt:
        return astForWithStmt(a, c);
      case SYM.funcdef:
        return astForFuncdef(a, c, []);
      case SYM.classdef:
        return astForClassdef(a, c, []);
      case SYM.decorated:
        return astForDecorated(a, c);
      default:
        goog.asserts.assert('unhandled compound_stmt');
      }
    }
  }
  Sk.astFromParse = function (a, b) {
    var c = new Compiling('utf-8', b), d = [], e, f = 0;
    switch (a.type) {
    case SYM.file_input:
      for (var g = 0; g < NCH(a) - 1; ++g)
        if (e = CHILD(a, g), a.type !== TOK.T_NEWLINE) {
          REQ(e, SYM.stmt);
          var h = numStmts(e);
          if (1 === h)
            d[f++] = astForStmt(c, e);
          else {
            e = CHILD(e, 0);
            REQ(e, SYM.simple_stmt);
            for (var k = 0; k < h; ++k)
              d[f++] = astForStmt(c, CHILD(e, 2 * k));
          }
        }
      return new Module(d);
    case SYM.eval_input:
      goog.asserts.fail('todo;');
    case SYM.single_input:
      goog.asserts.fail('todo;');
    default:
      goog.asserts.fail('todo;');
    }
  };
  Sk.astDump = function (a) {
    var b = function (a) {
        for (var b = '', c = 0; c < a; ++c)
          b += ' ';
        return b;
      }, c = function (a, e) {
        if (null === a)
          return e + 'None';
        if (a.prototype && void 0 !== a.prototype._astname && a.prototype._isenum)
          return e + a.prototype._astname + '()';
        if (void 0 !== a._astname) {
          for (var f = b(a._astname.length + 1), g = [], h = 0; h < a._fields.length; h += 2) {
            var k = a._fields[h], l = a._fields[h + 1](a), m = b(k.length + 1);
            g.push([
              k,
              c(l, e + f + m)
            ]);
          }
          k = [];
          for (h = 0; h < g.length; ++h)
            l = g[h], k.push(l[0] + '=' + l[1].replace(/^\s+/, ''));
          h = k.join(',\n' + e + f);
          return e + a._astname + '(' + h + ')';
        }
        if (goog.isArrayLike(a)) {
          f = [];
          for (h = 0; h < a.length; ++h)
            f.push(c(a[h], e + ' '));
          h = f.join(',\n');
          return e + '[' + h.replace(/^\s+/, '') + ']';
        }
        h = !0 === a ? 'True' : !1 === a ? 'False' : a instanceof Sk.builtin.lng ? a.tp$str().v : a instanceof Sk.builtin.str ? a.tp$repr().v : '' + a;
        return e + h;
      };
    return c(a, '');
  };
  goog.exportSymbol('Sk.astFromParse', Sk.astFromParse);
  goog.exportSymbol('Sk.astDump', Sk.astDump);
  var DEF_GLOBAL = 1, DEF_LOCAL = 2, DEF_PARAM = 4, USE = 8, DEF_STAR = 16, DEF_DOUBLESTAR = 32, DEF_INTUPLE = 64, DEF_FREE = 128, DEF_FREE_GLOBAL = 256, DEF_FREE_CLASS = 512, DEF_IMPORT = 1024, DEF_BOUND = DEF_LOCAL | DEF_PARAM | DEF_IMPORT, SCOPE_OFF = 11, SCOPE_MASK = 7, LOCAL = 1, GLOBAL_EXPLICIT = 2, GLOBAL_IMPLICIT = 3, FREE = 4, CELL = 5, OPT_IMPORT_STAR = 1, OPT_EXEC = 2, OPT_BARE_EXEC = 4, OPT_TOPLEVEL = 8, GENERATOR = 2, GENERATOR_EXPRESSION = 2, ModuleBlock = 'module', FunctionBlock = 'function', ClassBlock = 'class';
  function Symbol(a, b, c) {
    this.__name = a;
    this.__flags = b;
    this.__scope = b >> SCOPE_OFF & SCOPE_MASK;
    this.__namespaces = c || [];
  }
  Symbol.prototype.get_name = function () {
    return this.__name;
  };
  Symbol.prototype.is_referenced = function () {
    return !!(this.__flags & USE);
  };
  Symbol.prototype.is_parameter = function () {
    return !!(this.__flags & DEF_PARAM);
  };
  Symbol.prototype.is_global = function () {
    return this.__scope === GLOBAL_IMPLICIT || this.__scope == GLOBAL_EXPLICIT;
  };
  Symbol.prototype.is_declared_global = function () {
    return this.__scope == GLOBAL_EXPLICIT;
  };
  Symbol.prototype.is_local = function () {
    return !!(this.__flags & DEF_BOUND);
  };
  Symbol.prototype.is_free = function () {
    return this.__scope == FREE;
  };
  Symbol.prototype.is_imported = function () {
    return !!(this.__flags & DEF_IMPORT);
  };
  Symbol.prototype.is_assigned = function () {
    return !!(this.__flags & DEF_LOCAL);
  };
  Symbol.prototype.is_namespace = function () {
    return this.__namespaces && 0 < this.__namespaces.length;
  };
  Symbol.prototype.get_namespaces = function () {
    return this.__namespaces;
  };
  var astScopeCounter = 0;
  function SymbolTableScope(a, b, c, d, e) {
    this.symFlags = {};
    this.name = b;
    this.varnames = [];
    this.children = [];
    this.blockType = c;
    this.returnsValue = this.varkeywords = this.varargs = this.generator = this.childHasFree = this.hasFree = this.isNested = !1;
    this.lineno = e;
    this.table = a;
    a.cur && (a.cur.nested || a.cur.blockType === FunctionBlock) && (this.isNested = !0);
    d.scopeId = astScopeCounter++;
    a.stss[d.scopeId] = this;
    this.symbols = {};
  }
  SymbolTableScope.prototype.get_type = function () {
    return this.blockType;
  };
  SymbolTableScope.prototype.get_name = function () {
    return this.name;
  };
  SymbolTableScope.prototype.get_lineno = function () {
    return this.lineno;
  };
  SymbolTableScope.prototype.is_nested = function () {
    return this.isNested;
  };
  SymbolTableScope.prototype.has_children = function () {
    return 0 < this.children.length;
  };
  SymbolTableScope.prototype.get_identifiers = function () {
    return this._identsMatching(function (a) {
      return !0;
    });
  };
  SymbolTableScope.prototype.lookup = function (a) {
    if (this.symbols.hasOwnProperty(a))
      a = this.symbols[a];
    else {
      var b = this.symFlags[a], c = this.__check_children(a);
      a = this.symbols[a] = new Symbol(a, b, c);
    }
    return a;
  };
  SymbolTableScope.prototype.__check_children = function (a) {
    for (var b = [], c = 0; c < this.children.length; ++c) {
      var d = this.children[c];
      d.name === a && b.push(d);
    }
    return b;
  };
  SymbolTableScope.prototype._identsMatching = function (a) {
    var b = [], c;
    for (c in this.symFlags)
      this.symFlags.hasOwnProperty(c) && a(this.symFlags[c]) && b.push(c);
    b.sort();
    return b;
  };
  SymbolTableScope.prototype.get_parameters = function () {
    goog.asserts.assert('function' == this.get_type(), 'get_parameters only valid for function scopes');
    this._funcParams || (this._funcParams = this._identsMatching(function (a) {
      return a & DEF_PARAM;
    }));
    return this._funcParams;
  };
  SymbolTableScope.prototype.get_locals = function () {
    goog.asserts.assert('function' == this.get_type(), 'get_locals only valid for function scopes');
    this._funcLocals || (this._funcLocals = this._identsMatching(function (a) {
      return a & DEF_BOUND;
    }));
    return this._funcLocals;
  };
  SymbolTableScope.prototype.get_globals = function () {
    goog.asserts.assert('function' == this.get_type(), 'get_globals only valid for function scopes');
    this._funcGlobals || (this._funcGlobals = this._identsMatching(function (a) {
      a = a >> SCOPE_OFF & SCOPE_MASK;
      return a == GLOBAL_IMPLICIT || a == GLOBAL_EXPLICIT;
    }));
    return this._funcGlobals;
  };
  SymbolTableScope.prototype.get_frees = function () {
    goog.asserts.assert('function' == this.get_type(), 'get_frees only valid for function scopes');
    this._funcFrees || (this._funcFrees = this._identsMatching(function (a) {
      return (a >> SCOPE_OFF & SCOPE_MASK) == FREE;
    }));
    return this._funcFrees;
  };
  SymbolTableScope.prototype.get_methods = function () {
    goog.asserts.assert('class' == this.get_type(), 'get_methods only valid for class scopes');
    if (!this._classMethods) {
      for (var a = [], b = 0; b < this.children.length; ++b)
        a.push(this.children[b].name);
      a.sort();
      this._classMethods = a;
    }
    return this._classMethods;
  };
  SymbolTableScope.prototype.getScope = function (a) {
    a = this.symFlags[a];
    return void 0 === a ? 0 : a >> SCOPE_OFF & SCOPE_MASK;
  };
  function SymbolTable(a) {
    this.filename = a;
    this.top = this.cur = null;
    this.stack = [];
    this.curClass = this.global = null;
    this.tmpname = 0;
    this.stss = {};
  }
  SymbolTable.prototype.getStsForAst = function (a) {
    goog.asserts.assert(void 0 !== a.scopeId, 'ast wasn\'t added to st?');
    a = this.stss[a.scopeId];
    goog.asserts.assert(void 0 !== a, 'unknown sym tab entry');
    return a;
  };
  SymbolTable.prototype.SEQStmt = function (a) {
    goog.asserts.assert(goog.isArrayLike(a), 'SEQ: nodes isn\'t array? got %s', a);
    for (var b = a.length, c = 0; c < b; ++c) {
      var d = a[c];
      d && this.visitStmt(d);
    }
  };
  SymbolTable.prototype.SEQExpr = function (a) {
    goog.asserts.assert(goog.isArrayLike(a), 'SEQ: nodes isn\'t array? got %s', a);
    for (var b = a.length, c = 0; c < b; ++c) {
      var d = a[c];
      d && this.visitExpr(d);
    }
  };
  SymbolTable.prototype.enterBlock = function (a, b, c, d) {
    a = fixReservedNames(a);
    var e = null;
    this.cur && (e = this.cur, this.stack.push(this.cur));
    this.cur = new SymbolTableScope(this, a, b, c, d);
    'top' === a && (this.global = this.cur.symFlags);
    e && e.children.push(this.cur);
  };
  SymbolTable.prototype.exitBlock = function () {
    this.cur = null;
    0 < this.stack.length && (this.cur = this.stack.pop());
  };
  SymbolTable.prototype.visitParams = function (a, b) {
    for (var c = 0; c < a.length; ++c) {
      var d = a[c];
      if (d.constructor === Name)
        goog.asserts.assert(d.ctx === Param || d.ctx === Store && !b), this.addDef(d.id, DEF_PARAM, d.lineno);
      else
        throw new Sk.builtin.SyntaxError('invalid expression in parameter list', this.filename);
    }
  };
  SymbolTable.prototype.visitArguments = function (a, b) {
    a.args && this.visitParams(a.args, !0);
    a.vararg && (this.addDef(a.vararg, DEF_PARAM, b), this.cur.varargs = !0);
    a.kwarg && (this.addDef(a.kwarg, DEF_PARAM, b), this.cur.varkeywords = !0);
  };
  SymbolTable.prototype.newTmpname = function (a) {
    this.addDef(new Sk.builtin.str('_[' + ++this.tmpname + ']'), DEF_LOCAL, a);
  };
  SymbolTable.prototype.addDef = function (a, b, c) {
    var d = mangleName(this.curClass, new Sk.builtin.str(a)).v, d = fixReservedNames(d), e = this.cur.symFlags[d];
    if (void 0 !== e) {
      if (b & DEF_PARAM && e & DEF_PARAM)
        throw new Sk.builtin.SyntaxError('duplicate argument \'' + a.v + '\' in function definition', this.filename, c);
      e |= b;
    } else
      e = b;
    this.cur.symFlags[d] = e;
    b & DEF_PARAM ? this.cur.varnames.push(d) : b & DEF_GLOBAL && (e = b, a = this.global[d], void 0 !== a && (e |= a), this.global[d] = e);
  };
  SymbolTable.prototype.visitSlice = function (a) {
    switch (a.constructor) {
    case Slice:
      a.lower && this.visitExpr(a.lower);
      a.upper && this.visitExpr(a.upper);
      a.step && this.visitExpr(a.step);
      break;
    case ExtSlice:
      for (var b = 0; b < a.dims.length; ++b)
        this.visitSlice(a.dims[b]);
      break;
    case Index:
      this.visitExpr(a.value);
    }
  };
  SymbolTable.prototype.visitStmt = function (a) {
    goog.asserts.assert(void 0 !== a, 'visitStmt called with undefined');
    switch (a.constructor) {
    case FunctionDef:
      this.addDef(a.name, DEF_LOCAL, a.lineno);
      a.args.defaults && this.SEQExpr(a.args.defaults);
      a.decorator_list && this.SEQExpr(a.decorator_list);
      this.enterBlock(a.name.v, FunctionBlock, a, a.lineno);
      this.visitArguments(a.args, a.lineno);
      this.SEQStmt(a.body);
      this.exitBlock();
      break;
    case ClassDef:
      this.addDef(a.name, DEF_LOCAL, a.lineno);
      this.SEQExpr(a.bases);
      a.decorator_list && this.SEQExpr(a.decorator_list);
      this.enterBlock(a.name.v, ClassBlock, a, a.lineno);
      var b = this.curClass;
      this.curClass = a.name;
      this.SEQStmt(a.body);
      this.curCalss = b;
      this.exitBlock();
      break;
    case Return_:
      if (a.value && (this.visitExpr(a.value), this.cur.returnsValue = !0, this.cur.generator))
        throw new Sk.builtin.SyntaxError('\'return\' with argument inside generator', this.filename);
      break;
    case Delete_:
      this.SEQExpr(a.targets);
      break;
    case Assign:
      this.SEQExpr(a.targets);
      this.visitExpr(a.value);
      break;
    case AugAssign:
      this.visitExpr(a.target);
      this.visitExpr(a.value);
      break;
    case Print:
      a.dest && this.visitExpr(a.dest);
      this.SEQExpr(a.values);
      break;
    case For_:
      this.visitExpr(a.target);
      this.visitExpr(a.iter);
      this.SEQStmt(a.body);
      a.orelse && this.SEQStmt(a.orelse);
      break;
    case While_:
      this.visitExpr(a.test);
      this.SEQStmt(a.body);
      a.orelse && this.SEQStmt(a.orelse);
      break;
    case If_:
      this.visitExpr(a.test);
      this.SEQStmt(a.body);
      a.orelse && this.SEQStmt(a.orelse);
      break;
    case Raise:
      a.type && (this.visitExpr(a.type), a.inst && (this.visitExpr(a.inst), a.tback && this.visitExpr(a.tback)));
      break;
    case TryExcept:
      this.SEQStmt(a.body);
      this.SEQStmt(a.orelse);
      this.visitExcepthandlers(a.handlers);
      break;
    case TryFinally:
      this.SEQStmt(a.body);
      this.SEQStmt(a.finalbody);
      break;
    case Assert:
      this.visitExpr(a.test);
      a.msg && this.visitExpr(a.msg);
      break;
    case Import_:
    case ImportFrom:
      this.visitAlias(a.names, a.lineno);
      break;
    case Exec:
      this.visitExpr(a.body);
      a.globals && (this.visitExpr(a.globals), a.locals && this.visitExpr(a.locals));
      break;
    case Global:
      for (var b = a.names.length, c = 0; c < b; ++c) {
        var d = mangleName(this.curClass, a.names[c]).v, d = fixReservedNames(d), e = this.cur.symFlags[d];
        if (e & (DEF_LOCAL | USE)) {
          if (e & DEF_LOCAL)
            throw new Sk.builtin.SyntaxError('name \'' + d + '\' is assigned to before global declaration', this.filename, a.lineno);
          throw new Sk.builtin.SyntaxError('name \'' + d + '\' is used prior to global declaration', this.filename, a.lineno);
        }
        this.addDef(new Sk.builtin.str(d), DEF_GLOBAL, a.lineno);
      }
      break;
    case Expr:
      this.visitExpr(a.value);
      break;
    case Pass:
    case Break_:
    case Continue_:
      break;
    case With_:
      this.newTmpname(a.lineno);
      this.visitExpr(a.context_expr);
      a.optional_vars && (this.newTmpname(a.lineno), this.visitExpr(a.optional_vars));
      this.SEQStmt(a.body);
      break;
    default:
      goog.asserts.fail('Unhandled type ' + a.constructor.name + ' in visitStmt');
    }
  };
  SymbolTable.prototype.visitExpr = function (a) {
    goog.asserts.assert(void 0 !== a, 'visitExpr called with undefined');
    switch (a.constructor) {
    case BoolOp:
      this.SEQExpr(a.values);
      break;
    case BinOp:
      this.visitExpr(a.left);
      this.visitExpr(a.right);
      break;
    case UnaryOp:
      this.visitExpr(a.operand);
      break;
    case Lambda:
      this.addDef(new Sk.builtin.str('lambda'), DEF_LOCAL, a.lineno);
      a.args.defaults && this.SEQExpr(a.args.defaults);
      this.enterBlock('lambda', FunctionBlock, a, a.lineno);
      this.visitArguments(a.args, a.lineno);
      this.visitExpr(a.body);
      this.exitBlock();
      break;
    case IfExp:
      this.visitExpr(a.test);
      this.visitExpr(a.body);
      this.visitExpr(a.orelse);
      break;
    case Dict:
      this.SEQExpr(a.keys);
      this.SEQExpr(a.values);
      break;
    case ListComp:
      this.newTmpname(a.lineno);
      this.visitExpr(a.elt);
      this.visitComprehension(a.generators, 0);
      break;
    case GeneratorExp:
      this.visitGenexp(a);
      break;
    case Yield:
      a.value && this.visitExpr(a.value);
      this.cur.generator = !0;
      if (this.cur.returnsValue)
        throw new Sk.builtin.SyntaxError('\'return\' with argument inside generator', this.filename);
      break;
    case Compare:
      this.visitExpr(a.left);
      this.SEQExpr(a.comparators);
      break;
    case Call:
      this.visitExpr(a.func);
      this.SEQExpr(a.args);
      for (var b = 0; b < a.keywords.length; ++b)
        this.visitExpr(a.keywords[b].value);
      a.starargs && this.visitExpr(a.starargs);
      a.kwargs && this.visitExpr(a.kwargs);
      break;
    case Num:
    case Str:
      break;
    case Attribute:
      this.visitExpr(a.value);
      break;
    case Subscript:
      this.visitExpr(a.value);
      this.visitSlice(a.slice);
      break;
    case Name:
      this.addDef(a.id, a.ctx === Load ? USE : DEF_LOCAL, a.lineno);
      break;
    case List:
    case Tuple:
      this.SEQExpr(a.elts);
      break;
    default:
      goog.asserts.fail('Unhandled type ' + a.constructor.name + ' in visitExpr');
    }
  };
  SymbolTable.prototype.visitComprehension = function (a, b) {
    for (var c = a.length, d = b; d < c; ++d) {
      var e = a[d];
      this.visitExpr(e.target);
      this.visitExpr(e.iter);
      this.SEQExpr(e.ifs);
    }
  };
  SymbolTable.prototype.visitAlias = function (a, b) {
    for (var c = 0; c < a.length; ++c) {
      var d = a[c], e = d = null === d.asname ? d.name.v : d.asname.v, f = d.indexOf('.');
      -1 !== f && (e = d.substr(0, f));
      if ('*' !== d)
        this.addDef(new Sk.builtin.str(e), DEF_IMPORT, b);
      else if (this.cur.blockType !== ModuleBlock)
        throw new Sk.builtin.SyntaxError('import * only allowed at module level', this.filename);
    }
  };
  SymbolTable.prototype.visitGenexp = function (a) {
    var b = a.generators[0];
    this.visitExpr(b.iter);
    this.enterBlock('genexpr', FunctionBlock, a, a.lineno);
    this.cur.generator = !0;
    this.addDef(new Sk.builtin.str('.0'), DEF_PARAM, a.lineno);
    this.visitExpr(b.target);
    this.SEQExpr(b.ifs);
    this.visitComprehension(a.generators, 1);
    this.visitExpr(a.elt);
    this.exitBlock();
  };
  SymbolTable.prototype.visitExcepthandlers = function (a) {
    for (var b = 0, c; c = a[b]; ++b)
      c.type && this.visitExpr(c.type), c.name && this.visitExpr(c.name), this.SEQStmt(c.body);
  };
  function _dictUpdate(a, b) {
    for (var c in b)
      a[c] = b[c];
  }
  SymbolTable.prototype.analyzeBlock = function (a, b, c, d) {
    var e = {}, f = {}, g = {}, h = {}, k = {};
    a.blockType == ClassBlock && (_dictUpdate(g, d), b && _dictUpdate(h, b));
    for (var l in a.symFlags)
      this.analyzeName(a, f, l, a.symFlags[l], b, e, c, d);
    a.blockType !== ClassBlock && (a.blockType === FunctionBlock && _dictUpdate(h, e), b && _dictUpdate(h, b), _dictUpdate(g, d));
    d = {};
    e = a.children.length;
    for (l = 0; l < e; ++l) {
      var m = a.children[l];
      this.analyzeChildBlock(m, h, k, g, d);
      if (m.hasFree || m.childHasFree)
        a.childHasFree = !0;
    }
    _dictUpdate(k, d);
    a.blockType === FunctionBlock && this.analyzeCells(f, k);
    this.updateSymbols(a.symFlags, f, b, k, a.blockType === ClassBlock);
    _dictUpdate(c, k);
  };
  SymbolTable.prototype.analyzeChildBlock = function (a, b, c, d, e) {
    var f = {};
    _dictUpdate(f, b);
    b = {};
    _dictUpdate(b, c);
    c = {};
    _dictUpdate(c, d);
    this.analyzeBlock(a, f, b, c);
    _dictUpdate(e, b);
  };
  SymbolTable.prototype.analyzeCells = function (a, b) {
    for (var c in a)
      a[c] === LOCAL && void 0 !== b[c] && (a[c] = CELL, delete b[c]);
  };
  SymbolTable.prototype.updateSymbols = function (a, b, c, d, e) {
    for (var f in a) {
      var g = a[f], g = g | b[f] << SCOPE_OFF;
      a[f] = g;
    }
    b = FREE << SCOPE_OFF;
    for (f in d)
      d = a[f], void 0 !== d ? e && d & (DEF_BOUND | DEF_GLOBAL) && (a[f] = d | DEF_FREE_CLASS) : void 0 !== c[f] && (a[f] = b);
  };
  SymbolTable.prototype.analyzeName = function (a, b, c, d, e, f, g, h) {
    if (d & DEF_GLOBAL) {
      if (d & DEF_PARAM)
        throw new Sk.builtin.SyntaxError('name \'' + c + '\' is local and global', this.filename, a.lineno);
      b[c] = GLOBAL_EXPLICIT;
      h[c] = null;
      e && void 0 !== e[c] && delete e[c];
    } else
      d & DEF_BOUND ? (b[c] = LOCAL, f[c] = null, delete h[c]) : e && void 0 !== e[c] ? (b[c] = FREE, a.hasFree = !0, g[c] = null) : (h && void 0 !== h[c] || !a.isNested || (a.hasFree = !0), b[c] = GLOBAL_IMPLICIT);
  };
  SymbolTable.prototype.analyze = function () {
    this.analyzeBlock(this.top, null, {}, {});
  };
  Sk.symboltable = function (a, b) {
    var c = new SymbolTable(b);
    c.enterBlock('top', ModuleBlock, a, 0);
    c.top = c.cur;
    for (var d = 0; d < a.body.length; ++d)
      c.visitStmt(a.body[d]);
    c.exitBlock();
    c.analyze();
    return c;
  };
  Sk.dumpSymtab = function (a) {
    var b = function (a) {
        return a ? 'True' : 'False';
      }, c = function (a) {
        for (var b = [], c = 0; c < a.length; ++c)
          b.push(new Sk.builtin.str(a[c]).tp$repr().v);
        return '[' + b.join(', ') + ']';
      }, d = function (a, f) {
        void 0 === f && (f = '');
        var g;
        g = '' + (f + 'Sym_type: ' + a.get_type() + '\n');
        g += f + 'Sym_name: ' + a.get_name() + '\n';
        g += f + 'Sym_lineno: ' + a.get_lineno() + '\n';
        g += f + 'Sym_nested: ' + b(a.is_nested()) + '\n';
        g += f + 'Sym_haschildren: ' + b(a.has_children()) + '\n';
        'class' === a.get_type() ? g += f + 'Class_methods: ' + c(a.get_methods()) + '\n' : 'function' === a.get_type() && (g += f + 'Func_params: ' + c(a.get_parameters()) + '\n', g += f + 'Func_locals: ' + c(a.get_locals()) + '\n', g += f + 'Func_globals: ' + c(a.get_globals()) + '\n', g += f + 'Func_frees: ' + c(a.get_frees()) + '\n');
        g += f + '-- Identifiers --\n';
        for (var h = a.get_identifiers(), k = h.length, l = 0; l < k; ++l) {
          var m = a.lookup(h[l]);
          g += f + 'name: ' + m.get_name() + '\n';
          g += f + '  is_referenced: ' + b(m.is_referenced()) + '\n';
          g += f + '  is_imported: ' + b(m.is_imported()) + '\n';
          g += f + '  is_parameter: ' + b(m.is_parameter()) + '\n';
          g += f + '  is_global: ' + b(m.is_global()) + '\n';
          g += f + '  is_declared_global: ' + b(m.is_declared_global()) + '\n';
          g += f + '  is_local: ' + b(m.is_local()) + '\n';
          g += f + '  is_free: ' + b(m.is_free()) + '\n';
          g += f + '  is_assigned: ' + b(m.is_assigned()) + '\n';
          g += f + '  is_namespace: ' + b(m.is_namespace()) + '\n';
          var m = m.get_namespaces(), n = m.length;
          g += f + '  namespaces: [\n';
          for (var p = [], q = 0; q < n; ++q)
            p.push(d(m[q], f + '    '));
          g += p.join('\n');
          g += f + '  ]\n';
        }
        return g;
      };
    return d(a.top, '');
  };
  goog.exportSymbol('Sk.symboltable', Sk.symboltable);
  goog.exportSymbol('Sk.dumpSymtab', Sk.dumpSymtab);
  var out;
  Sk.gensymcount = 0;
  function Compiler(a, b, c, d) {
    this.filename = a;
    this.st = b;
    this.flags = c;
    this.interactive = !1;
    this.nestlevel = 0;
    this.u = null;
    this.stack = [];
    this.result = [];
    this.allUnits = [];
    this.source = d ? d.split('\n') : !1;
  }
  function CompilerUnit() {
    this.private_ = this.name = this.ste = null;
    this.lineno = this.firstlineno = 0;
    this.linenoSet = !1;
    this.localnames = [];
    this.blocknum = 0;
    this.blocks = [];
    this.curblock = 0;
    this.scopename = null;
    this.suffixCode = this.switchCode = this.varDeclsCode = this.prefixCode = '';
    this.breakBlocks = [];
    this.continueBlocks = [];
    this.exceptBlocks = [];
    this.finallyBlocks = [];
  }
  CompilerUnit.prototype.activateScope = function () {
    var a = this;
    out = function () {
      for (var b = a.blocks[a.curblock], c = 0; c < arguments.length; ++c)
        b.push(arguments[c]);
    };
  };
  Compiler.prototype.getSourceLine = function (a) {
    goog.asserts.assert(this.source);
    return this.source[a - 1];
  };
  Compiler.prototype.annotateSource = function (a) {
    if (this.source) {
      var b = a.lineno;
      a = a.col_offset;
      out('\n//\n// line ', b, ':\n// ', this.getSourceLine(b), '\n// ');
      for (var c = 0; c < a; ++c)
        out(' ');
      out('^\n//\n');
      out('\nSk.currLineNo = ', b, ';\nSk.currColNo = ', a, '\n\n');
      out('\nSk.currFilename = \'', this.filename, '\';\n\n');
    }
  };
  Compiler.prototype.gensym = function (a) {
    a = '$' + (a || '');
    return a += Sk.gensymcount++;
  };
  Compiler.prototype.niceName = function (a) {
    return this.gensym(a.replace('<', '').replace('>', '').replace(' ', '_'));
  };
  var reservedWords_ = {
      'abstract': !0,
      as: !0,
      'boolean': !0,
      'break': !0,
      'byte': !0,
      'case': !0,
      'catch': !0,
      'char': !0,
      'class': !0,
      'continue': !0,
      'const': !0,
      'debugger': !0,
      'default': !0,
      'delete': !0,
      'do': !0,
      'double': !0,
      'else': !0,
      'enum': !0,
      'export': !0,
      'extends': !0,
      'false': !0,
      'final': !0,
      'finally': !0,
      'float': !0,
      'for': !0,
      'function': !0,
      'goto': !0,
      'if': !0,
      'implements': !0,
      'import': !0,
      'in': !0,
      'instanceof': !0,
      'int': !0,
      'interface': !0,
      is: !0,
      'long': !0,
      namespace: !0,
      'native': !0,
      'new': !0,
      'null': !0,
      'package': !0,
      'private': !0,
      'protected': !0,
      'public': !0,
      'return': !0,
      'short': !0,
      'static': !0,
      'super': !1,
      'switch': !0,
      'synchronized': !0,
      'this': !0,
      'throw': !0,
      'throws': !0,
      'transient': !0,
      'true': !0,
      'try': !0,
      'typeof': !0,
      use: !0,
      'var': !0,
      'void': !0,
      'volatile': !0,
      'while': !0,
      'with': !0
    };
  function fixReservedWords(a) {
    return !0 !== reservedWords_[a] ? a : a + '_$rw$';
  }
  var reservedNames_ = {
      __defineGetter__: !0,
      __defineSetter__: !0,
      apply: !0,
      call: !0,
      eval: !0,
      hasOwnProperty: !0,
      isPrototypeOf: !0,
      __lookupGetter__: !0,
      __lookupSetter__: !0,
      __noSuchMethod__: !0,
      propertyIsEnumerable: !0,
      toSource: !0,
      toLocaleString: !0,
      toString: !0,
      unwatch: !0,
      valueOf: !0,
      watch: !0,
      length: !0
    };
  function fixReservedNames(a) {
    return reservedNames_[a] ? a + '_$rn$' : a;
  }
  Sk.mangleName = function (a) {
    return fixReservedNames(a);
  };
  goog.exportSymbol('Sk.mangleName', Sk.mangleName);
  function mangleName(a, b) {
    var c = b.v, d = null;
    if (null === a || (null === c || '_' !== c.charAt(0) || '_' !== c.charAt(1)) || '_' === c.charAt(c.length - 1) && '_' === c.charAt(c.length - 2))
      return b;
    d = a.v;
    d.replace(/_/g, '');
    if ('' === d)
      return b;
    d = a.v;
    d.replace(/^_*/, '');
    return d = new Sk.builtin.str('_' + d + c);
  }
  Compiler.prototype._gr = function (a, b) {
    var c = this.gensym(a);
    out('var ', c, '=');
    for (var d = 1; d < arguments.length; ++d)
      out(arguments[d]);
    out(';');
    return c;
  };
  Compiler.prototype._interruptTest = function () {
    out('if (Sk.execStart === undefined) {Sk.execStart=new Date()}');
    out('if (Sk.execLimit != null && new Date() - Sk.execStart > Sk.execLimit) {throw new Sk.builtin.TimeLimitError(Sk.timeoutMsg())}');
  };
  Compiler.prototype._jumpfalse = function (a, b) {
    var c = this._gr('jfalse', '(', a, '===false||!Sk.misceval.isTrue(', a, '))');
    this._interruptTest();
    out('if(', c, '){/*test failed */$blk=', b, ';continue;}');
  };
  Compiler.prototype._jumpundef = function (a, b) {
    this._interruptTest();
    out('if(', a, '===undefined){$blk=', b, ';continue;}');
  };
  Compiler.prototype._jumptrue = function (a, b) {
    var c = this._gr('jtrue', '(', a, '===true||Sk.misceval.isTrue(', a, '))');
    this._interruptTest();
    out('if(', c, '){/*test passed */$blk=', b, ';continue;}');
  };
  Compiler.prototype._jump = function (a) {
    this._interruptTest();
    out('$blk=', a, ';/* jump */continue;');
  };
  Compiler.prototype.ctupleorlist = function (a, b, c) {
    goog.asserts.assert('tuple' === c || 'list' === c);
    if (a.ctx === Store)
      for (var d = 0; d < a.elts.length; ++d)
        this.vexpr(a.elts[d], 'Sk.abstr.objectGetItem(' + b + ',' + d + ')');
    else if (a.ctx === Load) {
      b = [];
      for (d = 0; d < a.elts.length; ++d)
        b.push(this._gr('elem', this.vexpr(a.elts[d])));
      return this._gr('load' + c, 'new Sk.builtins[\'', c, '\']([', b, '])');
    }
  };
  Compiler.prototype.cdict = function (a) {
    goog.asserts.assert(a.values.length === a.keys.length);
    for (var b = [], c = 0; c < a.values.length; ++c) {
      var d = this.vexpr(a.values[c]);
      b.push(this.vexpr(a.keys[c]));
      b.push(d);
    }
    return this._gr('loaddict', 'new Sk.builtins[\'dict\']([', b, '])');
  };
  Compiler.prototype.clistcompgen = function (a, b, c, d) {
    var e = this.newBlock('list gen start'), f = this.newBlock('list gen skip'), g = this.newBlock('list gen anchor'), h = b[c], k = this.vexpr(h.iter), k = this._gr('iter', 'Sk.abstr.iter(', k, ')');
    this._jump(e);
    this.setBlock(e);
    k = this._gr('next', 'Sk.abstr.iternext(', k, ')');
    this._jumpundef(k, g);
    this.vexpr(h.target, k);
    for (var k = h.ifs.length, l = 0; l < k; ++l) {
      var m = this.vexpr(h.ifs[l]);
      this._jumpfalse(m, e);
    }
    ++c < b.length && this.clistcompgen(a, b, c, d);
    c >= b.length && (b = this.vexpr(d), out(a, '.v.push(', b, ');'), this._jump(f), this.setBlock(f));
    this._jump(e);
    this.setBlock(g);
    return a;
  };
  Compiler.prototype.clistcomp = function (a) {
    goog.asserts.assert(a instanceof ListComp);
    var b = this._gr('_compr', 'new Sk.builtins[\'list\']([])');
    return this.clistcompgen(b, a.generators, 0, a.elt);
  };
  Compiler.prototype.cyield = function (a) {
    if (this.u.ste.blockType !== FunctionBlock)
      throw new SyntaxError('\'yield\' outside function');
    var b = 'null';
    a.value && (b = this.vexpr(a.value));
    a = this.newBlock('after yield');
    out('return [/*resume*/', a, ',/*ret*/', b, '];');
    this.setBlock(a);
    return '$gen.gi$sentvalue';
  };
  Compiler.prototype.ccompare = function (a) {
    goog.asserts.assert(a.ops.length === a.comparators.length);
    for (var b = this.vexpr(a.left), c = a.ops.length, d = this.newBlock('done'), e = this._gr('compareres', 'null'), f = 0; f < c; ++f) {
      var g = this.vexpr(a.comparators[f]), b = this._gr('compare', 'Sk.builtin.bool(Sk.misceval.richCompareBool(', b, ',', g, ',\'', a.ops[f].prototype._astname, '\'))');
      out(e, '=', b, ';');
      this._jumpfalse(b, d);
      b = g;
    }
    this._jump(d);
    this.setBlock(d);
    return e;
  };
  Compiler.prototype.ccall = function (a) {
    var b = this.vexpr(a.func), c = this.vseqexpr(a.args);
    if (0 < a.keywords.length || a.starargs || a.kwargs) {
      for (var d = [], e = 0; e < a.keywords.length; ++e)
        d.push('\'' + a.keywords[e].arg.v + '\''), d.push(this.vexpr(a.keywords[e].value));
      var d = '[' + d.join(',') + ']', f = e = 'undefined';
      a.starargs && (e = this.vexpr(a.starargs));
      a.kwargs && (f = this.vexpr(a.kwargs));
      return this._gr('call', 'Sk.misceval.call(', b, ',', f, ',', e, ',', d, 0 < c.length ? ',' : '', c, ')');
    }
    return this._gr('call', 'Sk.misceval.callsim(', b, 0 < c.length ? ',' : '', c, ')');
  };
  Compiler.prototype.cslice = function (a) {
    goog.asserts.assert(a instanceof Slice);
    var b = a.lower ? this.vexpr(a.lower) : 'null', c = a.upper ? this.vexpr(a.upper) : 'null';
    a = a.step ? this.vexpr(a.step) : 'null';
    return this._gr('slice', 'new Sk.builtins[\'slice\'](', b, ',', c, ',', a, ')');
  };
  Compiler.prototype.vslicesub = function (a) {
    var b;
    switch (a.constructor) {
    case Number:
    case String:
      b = a;
      break;
    case Index:
      b = this.vexpr(a.value);
      break;
    case Slice:
      b = this.cslice(a);
      break;
    case Ellipsis:
    case ExtSlice:
      goog.asserts.fail('todo;');
      break;
    default:
      goog.asserts.fail('invalid subscript kind');
    }
    return b;
  };
  Compiler.prototype.vslice = function (a, b, c, d) {
    a = this.vslicesub(a);
    return this.chandlesubscr(b, c, a, d);
  };
  Compiler.prototype.chandlesubscr = function (a, b, c, d) {
    if (a === Load || a === AugLoad)
      return this._gr('lsubscr', 'Sk.abstr.objectGetItem(', b, ',', c, ')');
    a === Store || a === AugStore ? out('Sk.abstr.objectSetItem(', b, ',', c, ',', d, ');') : a === Del ? out('Sk.abstr.objectDelItem(', b, ',', c, ');') : goog.asserts.fail('handlesubscr fail');
  };
  Compiler.prototype.cboolop = function (a) {
    goog.asserts.assert(a instanceof BoolOp);
    var b;
    b = a.op === And ? this._jumpfalse : this._jumptrue;
    var c = this.newBlock('end of boolop');
    a = a.values;
    for (var d = a.length, e, f = 0; f < d; ++f) {
      var g = this.vexpr(a[f]);
      0 === f && (e = this._gr('boolopsucc', g));
      out(e, '=', g, ';');
      b.call(this, g, c);
    }
    this._jump(c);
    this.setBlock(c);
    return e;
  };
  Compiler.prototype.vexpr = function (a, b, c) {
    a.lineno > this.u.lineno && (this.u.lineno = a.lineno, this.u.linenoSet = !1);
    switch (a.constructor) {
    case BoolOp:
      return this.cboolop(a);
    case BinOp:
      return this._gr('binop', 'Sk.abstr.numberBinOp(', this.vexpr(a.left), ',', this.vexpr(a.right), ',\'', a.op.prototype._astname, '\')');
    case UnaryOp:
      return this._gr('unaryop', 'Sk.abstr.numberUnaryOp(', this.vexpr(a.operand), ',\'', a.op.prototype._astname, '\')');
    case Lambda:
      return this.clambda(a);
    case IfExp:
      return this.cifexp(a);
    case Dict:
      return this.cdict(a);
    case ListComp:
      return this.clistcomp(a);
    case GeneratorExp:
      return this.cgenexp(a);
    case Yield:
      return this.cyield(a);
    case Compare:
      return this.ccompare(a);
    case Call:
      return b = this.ccall(a), this.annotateSource(a), b;
    case Num:
      if ('number' === typeof a.n)
        return a.n;
      if (a.n instanceof Sk.builtin.nmber)
        return 'new Sk.builtin.nmber(' + a.n.v + ',\'' + a.n.skType + '\')';
      if (a.n instanceof Sk.builtin.lng)
        return 'Sk.longFromStr(\'' + a.n.tp$str().v + '\')';
      goog.asserts.fail('unhandled Num type');
    case Str:
      return this._gr('str', 'new Sk.builtins[\'str\'](', a.s.tp$repr().v, ')');
    case Attribute:
      var d;
      a.ctx !== AugStore && (d = this.vexpr(a.value));
      var e = a.attr.tp$repr().v, e = e.substring(1, e.length - 1), e = mangleName(this.u.private_, new Sk.builtin.str(e)).v, e = fixReservedWords(e), e = fixReservedNames(e);
      switch (a.ctx) {
      case AugLoad:
      case Load:
        return this._gr('lattr', 'Sk.abstr.gattr(', d, ',\'', e, '\')');
      case AugStore:
        out('if(', b, '!==undefined){');
        d = this.vexpr(c || null);
        out('Sk.abstr.sattr(', d, ',\'', e, '\',', b, ');');
        out('}');
        break;
      case Store:
        out('Sk.abstr.sattr(', d, ',\'', e, '\',', b, ');');
        break;
      case Del:
        goog.asserts.fail('todo;');
        break;
      default:
        goog.asserts.fail('invalid attribute expression');
      }
      break;
    case Subscript:
      switch (a.ctx) {
      case AugLoad:
      case Load:
      case Store:
      case Del:
        return this.vslice(a.slice, a.ctx, this.vexpr(a.value), b);
      case AugStore:
        out('if(', b, '!==undefined){');
        d = this.vexpr(c || null);
        this.vslice(a.slice, a.ctx, d, b);
        out('}');
        break;
      default:
        goog.asserts.fail('invalid subscript expression');
      }
      break;
    case Name:
      return this.nameop(a.id, a.ctx, b);
    case List:
      return this.ctupleorlist(a, b, 'list');
    case Tuple:
      return this.ctupleorlist(a, b, 'tuple');
    default:
      goog.asserts.fail('unhandled case in vexpr');
    }
  };
  Compiler.prototype.vseqexpr = function (a, b) {
    goog.asserts.assert(void 0 === b || a.length === b.length);
    for (var c = [], d = 0; d < a.length; ++d)
      c.push(this.vexpr(a[d], void 0 === b ? void 0 : b[d]));
    return c;
  };
  Compiler.prototype.caugassign = function (a) {
    goog.asserts.assert(a instanceof AugAssign);
    var b = a.target;
    switch (b.constructor) {
    case Attribute:
      var c = new Attribute(b.value, b.attr, AugLoad, b.lineno, b.col_offset), d = this.vexpr(c), e = this.vexpr(a.value);
      a = this._gr('inplbinopattr', 'Sk.abstr.numberInplaceBinOp(', d, ',', e, ',\'', a.op.prototype._astname, '\')');
      c.ctx = AugStore;
      return this.vexpr(c, a, b.value);
    case Subscript:
      return c = this.vslicesub(b.slice), c = new Subscript(b.value, c, AugLoad, b.lineno, b.col_offset), d = this.vexpr(c), e = this.vexpr(a.value), a = this._gr('inplbinopsubscr', 'Sk.abstr.numberInplaceBinOp(', d, ',', e, ',\'', a.op.prototype._astname, '\')'), c.ctx = AugStore, this.vexpr(c, a, b.value);
    case Name:
      return c = this.nameop(b.id, Load), e = this.vexpr(a.value), a = this._gr('inplbinop', 'Sk.abstr.numberInplaceBinOp(', c, ',', e, ',\'', a.op.prototype._astname, '\')'), this.nameop(b.id, Store, a);
    default:
      goog.asserts.fail('unhandled case in augassign');
    }
  };
  Compiler.prototype.exprConstant = function (a) {
    switch (a.constructor) {
    case Num:
      return Sk.misceval.isTrue(a.n);
    case Str:
      return Sk.misceval.isTrue(a.s);
    default:
      return -1;
    }
  };
  Compiler.prototype.newBlock = function (a) {
    var b = this.u.blocknum++;
    this.u.blocks[b] = [];
    this.u.blocks[b]._name = a || '<unnamed>';
    return b;
  };
  Compiler.prototype.setBlock = function (a) {
    goog.asserts.assert(0 <= a && a < this.u.blocknum);
    this.u.curblock = a;
  };
  Compiler.prototype.pushBreakBlock = function (a) {
    goog.asserts.assert(0 <= a && a < this.u.blocknum);
    this.u.breakBlocks.push(a);
  };
  Compiler.prototype.popBreakBlock = function () {
    this.u.breakBlocks.pop();
  };
  Compiler.prototype.pushContinueBlock = function (a) {
    goog.asserts.assert(0 <= a && a < this.u.blocknum);
    this.u.continueBlocks.push(a);
  };
  Compiler.prototype.popContinueBlock = function () {
    this.u.continueBlocks.pop();
  };
  Compiler.prototype.pushExceptBlock = function (a) {
    goog.asserts.assert(0 <= a && a < this.u.blocknum);
    this.u.exceptBlocks.push(a);
  };
  Compiler.prototype.popExceptBlock = function () {
    this.u.exceptBlocks.pop();
  };
  Compiler.prototype.pushFinallyBlock = function (a) {
    goog.asserts.assert(0 <= a && a < this.u.blocknum);
    this.u.finallyBlocks.push(a);
  };
  Compiler.prototype.popFinallyBlock = function () {
    this.u.finallyBlocks.pop();
  };
  Compiler.prototype.setupExcept = function (a) {
    out('$exc.push(', a, ');');
  };
  Compiler.prototype.endExcept = function () {
    out('$exc.pop();');
  };
  Compiler.prototype.outputLocals = function (a) {
    for (var b = {}, c = 0; a.argnames && c < a.argnames.length; ++c)
      b[a.argnames[c]] = !0;
    a.localnames.sort();
    for (var d = [], c = 0; c < a.localnames.length; ++c) {
      var e = a.localnames[c];
      void 0 === b[e] && (d.push(e), b[e] = !0);
    }
    return 0 < d.length ? 'var ' + d.join(',') + '; /* locals */' : '';
  };
  Compiler.prototype.outputAllUnits = function () {
    for (var a = '', b = 0; b < this.allUnits.length; ++b) {
      for (var c = this.allUnits[b], a = a + c.prefixCode, a = a + this.outputLocals(c), a = a + c.varDeclsCode, a = a + c.switchCode, d = c.blocks, e = 0; e < d.length; ++e)
        a += 'case ' + e + ': /* --- ' + d[e]._name + ' --- */', a += d[e].join(''), a += 'throw new Sk.builtin.SystemError(\'internal error: unterminated block\');';
      a += c.suffixCode;
    }
    return a;
  };
  Compiler.prototype.cif = function (a) {
    goog.asserts.assert(a instanceof If_);
    var b = this.exprConstant(a.test);
    if (0 === b)
      a.orelse && this.vseqstmt(a.orelse);
    else if (1 === b)
      this.vseqstmt(a.body);
    else {
      var c = this.newBlock('end of if'), b = this.newBlock('next branch of if'), d = this.vexpr(a.test);
      this._jumpfalse(d, b);
      this.vseqstmt(a.body);
      this._jump(c);
      this.setBlock(b);
      a.orelse && this.vseqstmt(a.orelse);
      this._jump(c);
    }
    this.setBlock(c);
  };
  Compiler.prototype.cwhile = function (a) {
    if (0 === this.exprConstant(a.test))
      a.orelse && this.vseqstmt(a.orelse);
    else {
      var b = this.newBlock('while test');
      this._jump(b);
      this.setBlock(b);
      var c = this.newBlock('after while'), d = 0 < a.orelse.length ? this.newBlock('while orelse') : null, e = this.newBlock('while body');
      this._jumpfalse(this.vexpr(a.test), d ? d : c);
      this._jump(e);
      this.pushBreakBlock(c);
      this.pushContinueBlock(b);
      this.setBlock(e);
      this.vseqstmt(a.body);
      this._jump(b);
      this.popContinueBlock();
      this.popBreakBlock();
      0 < a.orelse.length && (this.setBlock(d), this.vseqstmt(a.orelse), this._jump(c));
      this.setBlock(c);
    }
  };
  Compiler.prototype.cfor = function (a) {
    var b = this.newBlock('for start'), c = this.newBlock('for cleanup'), d = this.newBlock('for end');
    this.pushBreakBlock(d);
    this.pushContinueBlock(b);
    var e = this.vexpr(a.iter), f;
    this.u.ste.generator ? (f = '$loc.' + this.gensym('iter'), out(f, '=Sk.abstr.iter(', e, ');')) : f = this._gr('iter', 'Sk.abstr.iter(', e, ')');
    this._jump(b);
    this.setBlock(b);
    e = this._gr('next', 'Sk.abstr.iternext(', f, ')');
    this._jumpundef(e, c);
    this.vexpr(a.target, e);
    this.vseqstmt(a.body);
    this._jump(b);
    this.setBlock(c);
    this.popContinueBlock();
    this.popBreakBlock();
    this.vseqstmt(a.orelse);
    this._jump(d);
    this.setBlock(d);
  };
  Compiler.prototype.craise = function (a) {
    if (a && a.type && a.type.id && 'StopIteration' === a.type.id.v)
      out('return undefined;');
    else {
      var b = '';
      a.inst ? (b = this.vexpr(a.inst), out('throw ', this.vexpr(a.type), '(', b, ');')) : a.type ? a.type.func ? out('throw ', this.vexpr(a.type), ';') : out('throw ', this.vexpr(a.type), '(\'\');') : out('throw $err;');
    }
  };
  Compiler.prototype.ctryexcept = function (a) {
    for (var b = a.handlers.length, c = [], d = 0; d < b; ++d)
      c.push(this.newBlock('except_' + d + '_'));
    var e = this.newBlock('unhandled'), f = this.newBlock('orelse'), g = this.newBlock('end');
    this.setupExcept(c[0]);
    this.vseqstmt(a.body);
    this.endExcept();
    this._jump(f);
    for (d = 0; d < b; ++d) {
      this.setBlock(c[d]);
      var h = a.handlers[d];
      if (!h.type && d < b - 1)
        throw new SyntaxError('default \'except:\' must be last');
      if (h.type) {
        var k = this.vexpr(h.type), l = d == b - 1 ? e : c[d + 1], k = this._gr('instance', '$err instanceof ', k);
        this._jumpfalse(k, l);
      }
      h.name && this.vexpr(h.name, '$err');
      this.vseqstmt(h.body);
      this._jump(g);
    }
    this.setBlock(e);
    out('throw $err;');
    this.setBlock(f);
    this.vseqstmt(a.orelse);
    this._jump(g);
    this.setBlock(g);
  };
  Compiler.prototype.ctryfinally = function (a) {
    out('/*todo; tryfinally*/');
    this.ctryexcept(a.body[0]);
  };
  Compiler.prototype.cassert = function (a) {
    var b = this.vexpr(a.test), c = this.newBlock('end');
    this._jumptrue(b, c);
    out('throw new Sk.builtin.AssertionError(', a.msg ? this.vexpr(a.msg) : '', ');');
    this.setBlock(c);
  };
  Compiler.prototype.cimportas = function (a, b, c) {
    a = a.v;
    var d = a.indexOf('.');
    if (-1 !== d)
      for (a = a.substr(d + 1); -1 !== d;) {
        var d = a.indexOf('.'), e = -1 !== d ? a.substr(0, d) : a;
        c = this._gr('lattr', 'Sk.abstr.gattr(', c, ',\'', e, '\')');
        a = a.substr(d + 1);
      }
    return this.nameop(b, Store, c);
  };
  Compiler.prototype.cimport = function (a) {
    for (var b = a.names.length, c = 0; c < b; ++c) {
      var d = a.names[c], e = this._gr('module', 'Sk.builtin.__import__(', d.name.tp$repr().v, ',$gbl,$loc,[])');
      if (d.asname)
        this.cimportas(d.name, d.asname, e);
      else {
        var d = d.name, f = d.v.indexOf('.');
        -1 !== f && (d = new Sk.builtin.str(d.v.substr(0, f)));
        this.nameop(d, Store, e);
      }
    }
  };
  Compiler.prototype.cfromimport = function (a) {
    for (var b = a.names.length, c = [], d = 0; d < b; ++d)
      c[d] = a.names[d].name.tp$repr().v;
    c = this._gr('module', 'Sk.builtin.__import__(', a.module.tp$repr().v, ',$gbl,$loc,[', c, '])');
    for (d = 0; d < b; ++d) {
      var e = a.names[d];
      if (0 === d && '*' === e.name.v) {
        goog.asserts.assert(1 === b);
        out('Sk.importStar(', c, ',$loc, $gbl);');
        break;
      }
      var f = this._gr('item', 'Sk.abstr.gattr(', c, ',', e.name.tp$repr().v, ')'), g = e.name;
      e.asname && (g = e.asname);
      this.nameop(g, Store, f);
    }
  };
  Compiler.prototype.buildcodeobj = function (a, b, c, d, e) {
    var f = [], g = null, h = null;
    c && this.vseqexpr(c);
    d && d.defaults && (f = this.vseqexpr(d.defaults));
    d && d.vararg && (g = d.vararg);
    d && d.kwarg && (h = d.kwarg);
    a = this.enterScope(b, a, a.lineno);
    c = this.u.ste.generator;
    var k = this.u.ste.hasFree, l = this.u.ste.childHasFree, m = this.newBlock('codeobj entry');
    this.u.prefixCode = 'var ' + a + '=(function ' + this.niceName(b.v) + '$(';
    var n = [];
    if (c) {
      if (h)
        throw new SyntaxError(b.v + '(): keyword arguments in generators not supported');
      if (g)
        throw new SyntaxError(b.v + '(): variable number of arguments in generators not supported');
      n.push('$gen');
    } else {
      h && n.push('$kwa');
      for (var p = 0; d && p < d.args.length; ++p)
        n.push(this.nameop(d.args[p].id, Param));
    }
    k && n.push('$free');
    this.u.prefixCode += n.join(',');
    this.u.prefixCode += '){';
    c && (this.u.prefixCode += '\n// generator\n');
    k && (this.u.prefixCode += '\n// has free\n');
    l && (this.u.prefixCode += '\n// has cell\n');
    p = '{}';
    c && (m = '$gen.gi$resumeat', p = '$gen.gi$locals');
    var q = '';
    l && (q = ',$cell={}');
    this.u.varDeclsCode += 'var $blk=' + m + ',$exc=[],$loc=' + p + q + ',$gbl=this,$err=undefined;';
    for (p = 0; d && p < d.args.length; ++p)
      l = d.args[p].id, this.isCell(l) && (this.u.varDeclsCode += '$cell.' + l.v + '=' + l.v + ';');
    c || (this.u.varDeclsCode += 'Sk.builtin.pyCheckArgs("' + b.v + '", arguments, ' + (d ? d.args.length - f.length : 0) + ', ' + (g ? Infinity : d ? d.args.length : 0) + ', ' + (h ? !0 : !1) + ', ' + k + ');');
    if (0 < f.length)
      for (l = d.args.length - f.length, p = 0; p < f.length; ++p)
        m = this.nameop(d.args[p + l].id, Param), this.u.varDeclsCode += 'if(' + m + '===undefined)' + m + '=' + a + '.$defaults[' + p + '];';
    g && (this.u.varDeclsCode += g.v + '=new Sk.builtins[\'tuple\'](Array.prototype.slice.call(arguments,' + n.length + ')); /*vararg*/');
    h && (this.u.varDeclsCode += h.v + '=new Sk.builtins[\'dict\']($kwa);');
    this.u.switchCode = 'while(true){try{ switch($blk){';
    this.u.suffixCode = '} }catch(err){if ($exc.length>0) { $err = err; $blk=$exc.pop(); continue; } else { throw err; }} }});';
    e.call(this, a);
    var s;
    if (d && 0 < d.args.length) {
      e = [];
      for (p = 0; p < d.args.length; ++p)
        e.push(d.args[p].id.v);
      s = e.join('\', \'');
      this.u.argnames = e;
    }
    this.exitScope();
    0 < f.length && out(a, '.$defaults=[', f.join(','), '];');
    s && out(a, '.co_varnames=[\'', s, '\'];');
    h && out(a, '.co_kwargs=1;');
    h = '';
    k && (h = ',$cell', this.u.ste.hasFree && (h += ',$free'));
    return c ? d && 0 < d.args.length ? this._gr('gener', '(function(){var $origargs=Array.prototype.slice.call(arguments);Sk.builtin.pyCheckArgs("', b.v, '",arguments,', d.args.length - f.length, ',', d.args.length, ');return new Sk.builtins[\'generator\'](', a, ',$gbl,$origargs', h, ');})') : this._gr('gener', '(function(){Sk.builtin.pyCheckArgs("', b.v, '",arguments,0,0);return new Sk.builtins[\'generator\'](', a, ',$gbl,[]', h, ');})') : this._gr('funcobj', 'new Sk.builtins[\'function\'](', a, ',$gbl', h, ')');
  };
  Compiler.prototype.cfunction = function (a) {
    goog.asserts.assert(a instanceof FunctionDef);
    var b = this.buildcodeobj(a, a.name, a.decorator_list, a.args, function (b) {
        this.vseqstmt(a.body);
        out('return Sk.builtin.none.none$;');
      });
    this.nameop(a.name, Store, b);
  };
  Compiler.prototype.clambda = function (a) {
    goog.asserts.assert(a instanceof Lambda);
    return this.buildcodeobj(a, new Sk.builtin.str('<lambda>'), null, a.args, function (b) {
      b = this.vexpr(a.body);
      out('return ', b, ';');
    });
  };
  Compiler.prototype.cifexp = function (a) {
    var b = this.newBlock('next of ifexp'), c = this.newBlock('end of ifexp'), d = this._gr('res', 'null'), e = this.vexpr(a.test);
    this._jumpfalse(e, b);
    out(d, '=', this.vexpr(a.body), ';');
    this._jump(c);
    this.setBlock(b);
    out(d, '=', this.vexpr(a.orelse), ';');
    this._jump(c);
    this.setBlock(c);
    return d;
  };
  Compiler.prototype.cgenexpgen = function (a, b, c) {
    var d = this.newBlock('start for ' + b), e = this.newBlock('skip for ' + b);
    this.newBlock('if cleanup for ' + b);
    var f = this.newBlock('end for ' + b), g = a[b], h;
    if (0 === b)
      h = '$loc.$iter0';
    else {
      var k = this.vexpr(g.iter);
      h = '$loc.' + this.gensym('iter');
      out(h, '=', 'Sk.abstr.iter(', k, ');');
    }
    this._jump(d);
    this.setBlock(d);
    h = this._gr('next', 'Sk.abstr.iternext(', h, ')');
    this._jumpundef(h, f);
    this.vexpr(g.target, h);
    h = g.ifs.length;
    for (k = 0; k < h; ++k) {
      var l = this.vexpr(g.ifs[k]);
      this._jumpfalse(l, d);
    }
    ++b < a.length && this.cgenexpgen(a, b, c);
    b >= a.length && (a = this.vexpr(c), out('return [', e, '/*resume*/,', a, '/*ret*/];'), this.setBlock(e));
    this._jump(d);
    this.setBlock(f);
    1 === b && out('return null;');
  };
  Compiler.prototype.cgenexp = function (a) {
    var b = this.buildcodeobj(a, new Sk.builtin.str('<genexpr>'), null, null, function (b) {
        this.cgenexpgen(a.generators, 0, a.elt);
      }), b = this._gr('gener', b, '()');
    out(b, '.gi$locals.$iter0=Sk.abstr.iter(', this.vexpr(a.generators[0].iter), ');');
    return b;
  };
  Compiler.prototype.cclass = function (a) {
    goog.asserts.assert(a instanceof ClassDef);
    var b = this.vseqexpr(a.bases), c = this.enterScope(a.name, a, a.lineno), d = this.newBlock('class entry');
    this.u.prefixCode = 'var ' + c + '=(function $' + a.name.v + '$class_outer($globals,$locals,$rest){var $gbl=$globals,$loc=$locals;';
    this.u.switchCode += 'return(function ' + a.name.v + '(){';
    this.u.switchCode += 'var $blk=' + d + ',$exc=[];while(true){switch($blk){';
    this.u.suffixCode = '}break;}}).apply(null,$rest);});';
    this.u.private_ = a.name;
    this.cbody(a.body);
    out('break;');
    this.exitScope();
    b = this._gr('built', 'Sk.misceval.buildClass($gbl,', c, ',', a.name.tp$repr().v, ',[', b, '])');
    this.nameop(a.name, Store, b);
  };
  Compiler.prototype.ccontinue = function (a) {
    if (0 === this.u.continueBlocks.length)
      throw new SyntaxError('\'continue\' outside loop');
    this._jump(this.u.continueBlocks[this.u.continueBlocks.length - 1]);
  };
  Compiler.prototype.vstmt = function (a) {
    this.u.lineno = a.lineno;
    this.u.linenoSet = !1;
    this.annotateSource(a);
    switch (a.constructor) {
    case FunctionDef:
      this.cfunction(a);
      break;
    case ClassDef:
      this.cclass(a);
      break;
    case Return_:
      if (this.u.ste.blockType !== FunctionBlock)
        throw new SyntaxError('\'return\' outside function');
      a.value ? out('return ', this.vexpr(a.value), ';') : out('return null;');
      break;
    case Delete_:
      this.vseqexpr(a.targets);
      break;
    case Assign:
      for (var b = a.targets.length, c = this.vexpr(a.value), d = 0; d < b; ++d)
        this.vexpr(a.targets[d], c);
      break;
    case AugAssign:
      return this.caugassign(a);
    case Print:
      this.cprint(a);
      break;
    case For_:
      return this.cfor(a);
    case While_:
      return this.cwhile(a);
    case If_:
      return this.cif(a);
    case Raise:
      return this.craise(a);
    case TryExcept:
      return this.ctryexcept(a);
    case TryFinally:
      return this.ctryfinally(a);
    case Assert:
      return this.cassert(a);
    case Import_:
      return this.cimport(a);
    case ImportFrom:
      return this.cfromimport(a);
    case Global:
      break;
    case Expr:
      this.vexpr(a.value);
      break;
    case Pass:
      break;
    case Break_:
      if (0 === this.u.breakBlocks.length)
        throw new SyntaxError('\'break\' outside loop');
      this._jump(this.u.breakBlocks[this.u.breakBlocks.length - 1]);
      break;
    case Continue_:
      this.ccontinue(a);
      break;
    default:
      goog.asserts.fail('unhandled case in vstmt');
    }
  };
  Compiler.prototype.vseqstmt = function (a) {
    for (var b = 0; b < a.length; ++b)
      this.vstmt(a[b]);
  };
  var OP_FAST = 0, OP_GLOBAL = 1, OP_DEREF = 2, OP_NAME = 3, D_NAMES = 0, D_FREEVARS = 1, D_CELLVARS = 2;
  Compiler.prototype.isCell = function (a) {
    a = mangleName(this.u.private_, a).v;
    return this.u.ste.getScope(a) === CELL ? !0 : !1;
  };
  Compiler.prototype.nameop = function (a, b, c) {
    if ((b === Store || b === AugStore || b === Del) && '__debug__' === a.v)
      throw new Sk.builtin.SyntaxError('can not assign to __debug__');
    if ((b === Store || b === AugStore || b === Del) && 'None' === a.v)
      throw new Sk.builtin.SyntaxError('can not assign to None');
    if ('None' === a.v)
      return 'Sk.builtin.none.none$';
    if ('True' === a.v)
      return 'Sk.builtin.bool.true$';
    if ('False' === a.v)
      return 'Sk.builtin.bool.false$';
    var d = mangleName(this.u.private_, a).v, d = fixReservedNames(d), e = OP_NAME, f = this.u.ste.getScope(d), g = null;
    switch (f) {
    case FREE:
      g = '$free';
      e = OP_DEREF;
      break;
    case CELL:
      g = '$cell';
      e = OP_DEREF;
      break;
    case LOCAL:
      this.u.ste.blockType !== FunctionBlock || this.u.ste.generator || (e = OP_FAST);
      break;
    case GLOBAL_IMPLICIT:
      this.u.ste.blockType === FunctionBlock && (e = OP_GLOBAL);
      break;
    case GLOBAL_EXPLICIT:
      e = OP_GLOBAL;
    }
    d = fixReservedWords(d);
    goog.asserts.assert(f || '_' === a.v.charAt(1));
    a = d;
    this.u.ste.generator || this.u.ste.blockType !== FunctionBlock ? d = '$loc.' + d : e !== OP_FAST && e !== OP_NAME || this.u.localnames.push(d);
    switch (e) {
    case OP_FAST:
      switch (b) {
      case Load:
      case Param:
        return out('if (', d, ' === undefined) { throw new Error(\'local variable \\\'', d, '\\\' referenced before assignment\'); }\n'), d;
      case Store:
        out(d, '=', c, ';');
        break;
      case Del:
        out('delete ', d, ';');
        break;
      default:
        goog.asserts.fail('unhandled');
      }
      break;
    case OP_NAME:
      switch (b) {
      case Load:
        return b = this.gensym('loadname'), out('var ', b, '=', d, '!==undefined?', d, ':Sk.misceval.loadname(\'', a, '\',$gbl);'), b;
      case Store:
        out(d, '=', c, ';');
        break;
      case Del:
        out('delete ', d, ';');
        break;
      case Param:
        return d;
      default:
        goog.asserts.fail('unhandled');
      }
      break;
    case OP_GLOBAL:
      switch (b) {
      case Load:
        return this._gr('loadgbl', 'Sk.misceval.loadname(\'', a, '\',$gbl)');
      case Store:
        out('$gbl.', a, '=', c, ';');
        break;
      case Del:
        out('delete $gbl.', a);
        break;
      default:
        goog.asserts.fail('unhandled case in name op_global');
      }
      break;
    case OP_DEREF:
      switch (b) {
      case Load:
        return g + '.' + a;
      case Store:
        out(g, '.', a, '=', c, ';');
        break;
      case Param:
        return a;
      default:
        goog.asserts.fail('unhandled case in name op_deref');
      }
      break;
    default:
      goog.asserts.fail('unhandled case');
    }
  };
  Compiler.prototype.enterScope = function (a, b, c) {
    var d = new CompilerUnit();
    d.ste = this.st.getStsForAst(b);
    d.name = a;
    d.firstlineno = c;
    this.u && this.u.private_ && (d.private_ = this.u.private_);
    this.stack.push(this.u);
    this.allUnits.push(d);
    a = this.gensym('scope');
    d.scopename = a;
    this.u = d;
    this.u.activateScope();
    this.nestlevel++;
    return a;
  };
  Compiler.prototype.exitScope = function () {
    var a = this.u;
    this.nestlevel--;
    (this.u = 0 <= this.stack.length - 1 ? this.stack.pop() : null) && this.u.activateScope();
    if ('<module>' !== a.name.v) {
      var b = a.name.tp$repr().v, b = b.substring(1, b.length - 1), b = fixReservedWords(b), b = fixReservedNames(b);
      out(a.scopename, '.co_name=new Sk.builtins[\'str\'](\'', b, '\');');
    }
  };
  Compiler.prototype.cbody = function (a) {
    for (var b = 0; b < a.length; ++b)
      this.vstmt(a[b]);
  };
  Compiler.prototype.cprint = function (a) {
    goog.asserts.assert(a instanceof Print);
    a.dest && this.vexpr(a.dest);
    for (var b = a.values.length, c = 0; c < b; ++c)
      out('Sk.misceval.print_(', 'new Sk.builtins[\'str\'](', this.vexpr(a.values[c]), ').v);');
    a.nl && out('Sk.misceval.print_(', '"\\n");');
  };
  Compiler.prototype.cmod = function (a) {
    var b = this.enterScope(new Sk.builtin.str('<module>'), a, 0), c = this.newBlock('module entry');
    this.u.prefixCode = 'var ' + b + '=(function($modname){';
    this.u.varDeclsCode = 'var $blk=' + c + ',$exc=[],$gbl={},$loc=$gbl,$err=undefined;$gbl.__name__=$modname;Sk.globals=$gbl;';
    this.u.switchCode = 'try { while(true){try{ switch($blk){';
    this.u.suffixCode = '} }catch(err){if ($exc.length>0) { $err = err; $blk=$exc.pop(); continue; } else { throw err; }} } }catch(err){ if (err instanceof Sk.builtin.SystemExit && !Sk.throwSystemExit) { Sk.misceval.print_(err.toString() + \'\\n\'); return $loc; } else { throw err; } } });';
    switch (a.constructor) {
    case Module:
      this.cbody(a.body);
      out('return $loc;');
      break;
    default:
      goog.asserts.fail('todo; unhandled case in compilerMod');
    }
    this.exitScope();
    this.result.push(this.outputAllUnits());
    return b;
  };
  Sk.compile = function (a, b, c) {
    c = Sk.parse(b, a);
    c = Sk.astFromParse(c, b);
    var d = Sk.symboltable(c, b);
    a = new Compiler(b, d, 0, a);
    b = a.cmod(c);
    a = a.result.join('');
    return {
      funcname: b,
      code: a
    };
  };
  goog.exportSymbol('Sk.compile', Sk.compile);
  Sk.resetCompiler = function () {
    Sk.gensymcount = 0;
  };
  goog.exportSymbol('Sk.resetCompiler', Sk.resetCompiler);
  Sk.sysmodules = new Sk.builtin.dict([]);
  Sk.realsyspath = void 0;
  Sk.importSearchPathForName = function (a, b, c) {
    for (var d = Sk.realsyspath.tp$iter(), e = d.tp$iternext(); void 0 !== e; e = d.tp$iternext())
      for (var f = a.replace(/\./g, '/'), e = [
            e.v + '/' + f + b,
            e.v + '/' + f + '/__init__' + b
          ], f = 0; f < e.length; ++f) {
        var g = e[f];
        try {
          return Sk.read(g), g;
        } catch (h) {
        }
      }
    if (!c)
      throw new Sk.builtin.ImportError('No module named ' + a);
  };
  Sk.doOneTimeInitialization = function () {
    Sk.builtin.type.basesStr_ = new Sk.builtin.str('__bases__');
    Sk.builtin.type.mroStr_ = new Sk.builtin.str('__mro__');
    Sk.builtin.object.$d = new Sk.builtin.dict([]);
    Sk.builtin.object.$d.mp$ass_subscript(Sk.builtin.type.basesStr_, new Sk.builtin.tuple([]));
    Sk.builtin.object.$d.mp$ass_subscript(Sk.builtin.type.mroStr_, new Sk.builtin.tuple([Sk.builtin.object]));
  };
  Sk.importSetUpPath = function () {
    if (!Sk.realsyspath) {
      for (var a = [
            new Sk.builtin.str('src/builtin'),
            new Sk.builtin.str('src/lib'),
            new Sk.builtin.str('.')
          ], b = 0; b < Sk.syspath.length; ++b)
        a.push(new Sk.builtin.str(Sk.syspath[b]));
      Sk.realsyspath = new Sk.builtin.list(a);
      Sk.doOneTimeInitialization();
    }
  };
  if (COMPILED)
    var js_beautify = function (a) {
      return a;
    };
  Sk.importModuleInternal_ = function (a, b, c, d) {
    Sk.importSetUpPath();
    void 0 === c && (c = a);
    var e = null, f = c.split('.'), g;
    try {
      var h = Sk.sysmodules.mp$subscript(c);
      return 1 < f.length ? Sk.sysmodules.mp$subscript(f[0]) : h;
    } catch (k) {
    }
    1 < f.length && (g = f.slice(0, f.length - 1).join('.'), e = Sk.importModuleInternal_(g, b));
    h = new Sk.builtin.module();
    Sk.sysmodules.mp$ass_subscript(a, h);
    d ? a = Sk.compile(d, a + '.py', 'exec') : (d = Sk.importSearchPathForName(a, '.js', !0)) ? a = {
      funcname: '$builtinmodule',
      code: Sk.read(d)
    } : (a = Sk.importSearchPathForName(a, '.py'), a = Sk.compile(Sk.read(a), a, 'exec'));
    d = h.$js = a.code;
    null != Sk.dateSet && Sk.dateSet || (d = 'Sk.execStart = new Date();\n' + a.code, Sk.dateSet = !0);
    if (b) {
      b = js_beautify(a.code).split('\n');
      for (d = 1; d <= b.length; ++d) {
        for (var l = '', m = ('' + d).length; 5 > m; ++m)
          l += ' ';
        b[d - 1] = '/* ' + l + d + ' */ ' + b[d - 1];
      }
      d = b.join('\n');
      Sk.debugout(d);
    }
    d += '\n' + a.funcname + '(' + ('new Sk.builtin.str(\'' + c + '\')') + ');';
    b = goog.global.eval(d);
    b.__name__ || (b.__name__ = new Sk.builtin.str(c));
    h.$d = b;
    return e ? (Sk.sysmodules.mp$subscript(g).tp$setattr(f[f.length - 1], h), e) : h;
  };
  Sk.importModule = function (a, b) {
    return Sk.importModuleInternal_(a, b);
  };
  Sk.importMain = function (a, b) {
    Sk.dateSet = !1;
    Sk.filesLoaded = !1;
    Sk.sysmodules = new Sk.builtin.dict([]);
    Sk.realsyspath = void 0;
    Sk.resetCompiler();
    return Sk.importModuleInternal_(a, b, '__main__');
  };
  Sk.importMainWithBody = function (a, b, c) {
    Sk.dateSet = !1;
    Sk.filesLoaded = !1;
    Sk.sysmodules = new Sk.builtin.dict([]);
    Sk.realsyspath = void 0;
    Sk.resetCompiler();
    return Sk.importModuleInternal_(a, b, '__main__', c);
  };
  Sk.builtin.__import__ = function (a, b, c, d) {
    b = Sk.importModuleInternal_(a);
    if (!d || 0 === d.length)
      return b;
    b = Sk.sysmodules.mp$subscript(a);
    goog.asserts.assert(b);
    return b;
  };
  Sk.importStar = function (a, b) {
    var c = Object.getOwnPropertyNames(a.$d), d;
    for (d in c)
      b[c[d]] = a.$d[c[d]];
  };
  goog.exportSymbol('Sk.importMain', Sk.importMain);
  goog.exportSymbol('Sk.importMainWithBody', Sk.importMainWithBody);
  goog.exportSymbol('Sk.builtin.__import__', Sk.builtin.__import__);
  goog.exportSymbol('Sk.importStar', Sk.importStar);
  Sk.builtin.timSort = function (a, b) {
    this.list = new Sk.builtin.list(a.v);
    this.MIN_GALLOP = 7;
    this.listlength = b ? b : a.sq$length();
  };
  Sk.builtin.timSort.prototype.lt = function (a, b) {
    return Sk.misceval.richCompareBool(a, b, 'Lt');
  };
  Sk.builtin.timSort.prototype.le = function (a, b) {
    return !this.lt(b, a);
  };
  Sk.builtin.timSort.prototype.setitem = function (a, b) {
    this.list.v[a] = b;
  };
  Sk.builtin.timSort.prototype.binary_sort = function (a, b) {
    for (var c = a.base + b; c < a.base + a.len; c++) {
      for (var d = a.base, e = c, f = a.getitem(e); d < e;) {
        var g = d + (e - d >> 1);
        this.lt(f, a.getitem(g)) ? e = g : d = g + 1;
      }
      goog.asserts.assert(d === e);
      for (g = c; g > d; g--)
        a.setitem(g, a.getitem(g - 1));
      a.setitem(d, f);
    }
  };
  Sk.builtin.timSort.prototype.count_run = function (a) {
    var b;
    if (1 >= a.len) {
      var c = a.len;
      b = !1;
    } else if (c = 2, this.lt(a.getitem(a.base + 1), a.getitem(a.base))) {
      b = !0;
      for (var d = a.base + 2; d < a.base + a.len; d++)
        if (this.lt(a.getitem(d), a.getitem(d - 1)))
          c++;
        else
          break;
    } else
      for (b = !1, d = a.base + 2; d < a.base + a.len && !this.lt(a.getitem(d), a.getitem(d - 1)); d++)
        c++;
    return {
      run: new Sk.builtin.listSlice(a.list, a.base, c),
      descending: b
    };
  };
  Sk.builtin.timSort.prototype.sort = function () {
    var a = new Sk.builtin.listSlice(this.list, 0, this.listlength);
    if (!(2 > a.len)) {
      this.merge_init();
      for (var b = this.merge_compute_minrun(a.len); 0 < a.len;) {
        var c = this.count_run(a);
        c.descending && c.run.reverse();
        if (c.run.len < b) {
          var d = c.run.len;
          c.run.len = b < a.len ? b : a.len;
          this.binary_sort(c.run, d);
        }
        a.advance(c.run.len);
        this.pending.push(c.run);
        this.merge_collapse();
      }
      goog.asserts.assert(a.base == this.listlength);
      this.merge_force_collapse();
      goog.asserts.assert(1 == this.pending.length);
      goog.asserts.assert(0 == this.pending[0].base);
      goog.asserts.assert(this.pending[0].len == this.listlength);
    }
  };
  Sk.builtin.timSort.prototype.gallop = function (a, b, c, d) {
    goog.asserts.assert(0 <= c && c < b.len);
    var e = this;
    d = d ? function (a, b) {
      return e.le(a, b);
    } : function (a, b) {
      return e.lt(a, b);
    };
    var f = b.base + c, g = 0, h = 1, k;
    if (d(b.getitem(f), a)) {
      for (k = b.len - c; h < k;)
        if (d(b.getitem(f + h), a)) {
          g = h;
          try {
            h = (h << 1) + 1;
          } catch (l) {
            h = k;
          }
        } else
          break;
      h > k && (h = k);
      g += c;
      h += c;
    } else {
      for (k = c + 1; h < k && !d(b.getitem(f - h), a);) {
        g = h;
        try {
          h = (h << 1) + 1;
        } catch (m) {
          h = k;
        }
      }
      h > k && (h = k);
      f = c - g;
      g = c - h;
      h = f;
    }
    goog.asserts.assert(-1 <= g < h <= b.len);
    for (g += 1; g < h;)
      c = g + (h - g >> 1), d(b.getitem(b.base + c), a) ? g = c + 1 : h = c;
    goog.asserts.assert(g == h);
    return h;
  };
  Sk.builtin.timSort.prototype.merge_init = function () {
    this.min_gallop = this.MIN_GALLOP;
    this.pending = [];
  };
  Sk.builtin.timSort.prototype.merge_lo = function (a, b) {
    goog.asserts.assert(0 < a.len && 0 < b.len && a.base + a.len == b.base);
    var c = this.min_gallop, d = a.base;
    a = a.copyitems();
    try {
      if (this.setitem(d, b.popleft()), d++, 1 != a.len && 0 != b.len)
        for (var e, f;;) {
          for (f = e = 0;;)
            if (this.lt(b.getitem(b.base), a.getitem(a.base))) {
              this.setitem(d, b.popleft());
              d++;
              if (0 == b.len)
                return;
              f++;
              e = 0;
              if (f >= c)
                break;
            } else {
              this.setitem(d, a.popleft());
              d++;
              if (1 == a.len)
                return;
              e++;
              f = 0;
              if (e >= c)
                break;
            }
          for (c += 1;;) {
            this.min_gallop = c -= 1 < c;
            e = this.gallop(b.getitem(b.base), a, 0, !0);
            for (var g = a.base; g < a.base + e; g++)
              this.setitem(d, a.getitem(g)), d++;
            a.advance(e);
            if (1 >= a.len)
              return;
            this.setitem(d, b.popleft());
            d++;
            if (0 == b.len)
              return;
            f = this.gallop(a.getitem(a.base), b, 0, !1);
            for (g = b.base; g < b.base + f; g++)
              this.setitem(d, b.getitem(g)), d++;
            b.advance(f);
            if (0 == b.len)
              return;
            this.setitem(d, a.popleft());
            d++;
            if (1 == a.len)
              return;
            if (e < this.MIN_GALLOP && f < this.MIN_GALLOP)
              break;
            c++;
            this.min_gallop = c;
          }
        }
    } finally {
      goog.asserts.assert(0 <= a.len && 0 <= b.len);
      for (g = b.base; g < b.base + b.len; g++)
        this.setitem(d, b.getitem(g)), d++;
      for (g = a.base; g < a.base + a.len; g++)
        this.setitem(d, a.getitem(g)), d++;
    }
  };
  Sk.builtin.timSort.prototype.merge_hi = function (a, b) {
    goog.asserts.assert(0 < a.len && 0 < b.len && a.base + a.len == b.base);
    var c = this.min_gallop, d = b.base + b.len;
    b = b.copyitems();
    try {
      if (d--, this.setitem(d, a.popright()), 0 != a.len && 1 != b.len)
        for (var e, f, g, h;;) {
          for (f = e = 0;;)
            if (g = a.getitem(a.base + a.len - 1), h = b.getitem(b.base + b.len - 1), this.lt(h, g)) {
              d--;
              this.setitem(d, g);
              a.len--;
              if (0 == a.len)
                return;
              e++;
              f = 0;
              if (e >= c)
                break;
            } else {
              d--;
              this.setitem(d, h);
              b.len--;
              if (1 == b.len)
                return;
              f++;
              e = 0;
              if (f >= c)
                break;
            }
          for (c += 1;;) {
            this.min_gallop = c -= 1 < c;
            h = b.getitem(b.base + b.len - 1);
            var k = this.gallop(h, a, a.len - 1, !0);
            e = a.len - k;
            for (var l = a.base + a.len - 1; l > a.base + k - 1; l--)
              d--, this.setitem(d, a.getitem(l));
            a.len -= e;
            if (0 == a.len)
              return;
            d--;
            this.setitem(d, b.popright());
            if (1 == b.len)
              return;
            g = a.getitem(a.base + a.len - 1);
            k = this.gallop(g, b, b.len - 1, !1);
            f = b.len - k;
            for (l = b.base + b.len - 1; l > b.base + k - 1; l--)
              d--, this.setitem(d, b.getitem(l));
            b.len -= f;
            if (1 >= b.len)
              return;
            d--;
            this.setitem(d, a.popright());
            if (0 == a.len)
              return;
            if (e < this.MIN_GALLOP && f < this.MIN_GALLOP)
              break;
            c++;
            this.min_gallop = c;
          }
        }
    } finally {
      goog.asserts.assert(0 <= a.len && 0 <= b.len);
      for (l = a.base + a.len - 1; l > a.base - 1; l--)
        d--, this.setitem(d, a.getitem(l));
      for (l = b.base + b.len - 1; l > b.base - 1; l--)
        d--, this.setitem(d, b.getitem(l));
    }
  };
  Sk.builtin.timSort.prototype.merge_at = function (a) {
    0 > a && (a = this.pending.length + a);
    var b = this.pending[a], c = this.pending[a + 1];
    goog.asserts.assert(0 < b.len && 0 < c.len);
    goog.asserts.assert(b.base + b.len == c.base);
    this.pending[a] = new Sk.builtin.listSlice(this.list, b.base, b.len + c.len);
    this.pending.splice(a + 1, 1);
    a = this.gallop(c.getitem(c.base), b, 0, !0);
    b.advance(a);
    0 != b.len && (c.len = this.gallop(b.getitem(b.base + b.len - 1), c, c.len - 1, !1), 0 != c.len && (b.len <= c.len ? this.merge_lo(b, c) : this.merge_hi(b, c)));
  };
  Sk.builtin.timSort.prototype.merge_collapse = function () {
    for (var a = this.pending; 1 < a.length;)
      if (3 <= a.length && a[a.length - 3].len <= a[a.length - 2].len + a[a.length - 1].len)
        a[a.length - 3].len < a[a.length - 1].len ? this.merge_at(-3) : this.merge_at(-2);
      else if (a[a.length - 2].len <= a[a.length - 1].len)
        this.merge_at(-2);
      else
        break;
  };
  Sk.builtin.timSort.prototype.merge_force_collapse = function () {
    for (var a = this.pending; 1 < a.length;)
      3 <= a.length && a[a.length - 3].len < a[a.length - 1].len ? this.merge_at(-3) : this.merge_at(-2);
  };
  Sk.builtin.timSort.prototype.merge_compute_minrun = function (a) {
    for (var b = 0; 64 <= a;)
      b |= a & 1, a >>= 1;
    return a + b;
  };
  Sk.builtin.listSlice = function (a, b, c) {
    this.list = a;
    this.base = b;
    this.len = c;
  };
  Sk.builtin.listSlice.prototype.copyitems = function () {
    var a = this.base, b = this.base + this.len;
    goog.asserts.assert(0 <= a <= b);
    return new Sk.builtin.listSlice(new Sk.builtin.list(this.list.v.slice(a, b)), 0, this.len);
  };
  Sk.builtin.listSlice.prototype.advance = function (a) {
    this.base += a;
    this.len -= a;
    goog.asserts.assert(this.base <= this.list.sq$length());
  };
  Sk.builtin.listSlice.prototype.getitem = function (a) {
    return this.list.v[a];
  };
  Sk.builtin.listSlice.prototype.setitem = function (a, b) {
    this.list.v[a] = b;
  };
  Sk.builtin.listSlice.prototype.popleft = function () {
    var a = this.list.v[this.base];
    this.base++;
    this.len--;
    return a;
  };
  Sk.builtin.listSlice.prototype.popright = function () {
    this.len--;
    return this.list.v[this.base + this.len];
  };
  Sk.builtin.listSlice.prototype.reverse = function () {
    for (var a = this.list, b = this.base, c = b + this.len - 1; b < c;) {
      var d = a.v[b];
      a.v[b] = a.v[c];
      a.v[c] = d;
      b++;
      c--;
    }
  };
  goog.exportSymbol('Sk.builtin.listSlice', Sk.builtin.listSlice);
  goog.exportSymbol('Sk.builtin.timSort', Sk.builtin.timSort);
  Sk.builtins = {
    range: Sk.builtin.range,
    round: Sk.builtin.round,
    len: Sk.builtin.len,
    min: Sk.builtin.min,
    max: Sk.builtin.max,
    sum: Sk.builtin.sum,
    zip: Sk.builtin.zip,
    abs: Sk.builtin.abs,
    fabs: Sk.builtin.abs,
    ord: Sk.builtin.ord,
    chr: Sk.builtin.chr,
    hex: Sk.builtin.hex,
    oct: Sk.builtin.oct,
    bin: Sk.builtin.bin,
    dir: Sk.builtin.dir,
    repr: Sk.builtin.repr,
    open: Sk.builtin.open,
    isinstance: Sk.builtin.isinstance,
    hash: Sk.builtin.hash,
    getattr: Sk.builtin.getattr,
    float_$rw$: Sk.builtin.float_,
    int_$rw$: Sk.builtin.int_,
    hasattr: Sk.builtin.hasattr,
    map: Sk.builtin.map,
    filter: Sk.builtin.filter,
    reduce: Sk.builtin.reduce,
    sorted: Sk.builtin.sorted,
    bool: Sk.builtin.bool,
    any: Sk.builtin.any,
    all: Sk.builtin.all,
    enumerate: Sk.builtin.enumerate,
    AttributeError: Sk.builtin.AttributeError,
    ValueError: Sk.builtin.ValueError,
    Exception: Sk.builtin.Exception,
    ZeroDivisionError: Sk.builtin.ZeroDivisionError,
    AssertionError: Sk.builtin.AssertionError,
    ImportError: Sk.builtin.ImportError,
    IndentationError: Sk.builtin.IndentationError,
    IndexError: Sk.builtin.IndexError,
    KeyError: Sk.builtin.KeyError,
    TypeError: Sk.builtin.TypeError,
    NameError: Sk.builtin.NameError,
    IOError: Sk.builtin.IOError,
    NotImplementedError: Sk.builtin.NotImplementedError,
    SystemExit: Sk.builtin.SystemExit,
    OverflowError: Sk.builtin.OverflowError,
    OperationError: Sk.builtin.OperationError,
    dict: Sk.builtin.dict,
    file: Sk.builtin.file,
    'function': Sk.builtin.func,
    generator: Sk.builtin.generator,
    list: Sk.builtin.list,
    long_$rw$: Sk.builtin.lng,
    method: Sk.builtin.method,
    object: Sk.builtin.object,
    slice: Sk.builtin.slice,
    str: Sk.builtin.str,
    set: Sk.builtin.set,
    tuple: Sk.builtin.tuple,
    type: Sk.builtin.type,
    input: Sk.builtin.input,
    raw_input: Sk.builtin.raw_input,
    jseval: Sk.builtin.jseval,
    jsmillis: Sk.builtin.jsmillis,
    quit: Sk.builtin.quit,
    exit: Sk.builtin.quit,
    bytearray: Sk.builtin.bytearray,
    callable: Sk.builtin.callable,
    complex: Sk.builtin.complex,
    delattr: Sk.builtin.delattr,
    divmod: Sk.builtin.divmod,
    eval_$rn$: Sk.builtin.eval_,
    execfile: Sk.builtin.execfile,
    format: Sk.builtin.format,
    frozenset: Sk.builtin.frozenset,
    globals: Sk.builtin.globals,
    help: Sk.builtin.help,
    issubclass: Sk.builtin.issubclass,
    iter: Sk.builtin.iter,
    locals: Sk.builtin.locals,
    memoryview: Sk.builtin.memoryview,
    next: Sk.builtin.next_,
    pow: Sk.builtin.pow,
    property: Sk.builtin.property,
    reload: Sk.builtin.reload,
    reversed: Sk.builtin.reversed,
    'super': Sk.builtin.superbi,
    unichr: Sk.builtin.unichr,
    vars: Sk.builtin.vars,
    xrange: Sk.builtin.xrange,
    apply_$rn$: Sk.builtin.apply_,
    buffer: Sk.builtin.buffer,
    coerce: Sk.builtin.coerce,
    intern: Sk.builtin.intern
  };
  goog.exportSymbol('Sk.builtins', Sk.builtins);
  Sk.stdlib = Sk.stdlib || {};
  Sk.stdlib.direction = function (a, b, c) {
    return a ? 0 : b ? 1 : 2;
  };
  goog.exportSymbol('Sk.stdlib.direction', Sk.stdlib.direction);
  Sk.stdlib.orientation = function (a, b, c) {
    return 0 < a ? 1 : 0 > a ? -1 : 0 < b ? 1 : 0 > b ? -1 : 0 < c ? 1 : 0 > c ? -1 : 2;
  };
  goog.exportSymbol('Sk.stdlib.orientation', Sk.stdlib.orientation);
  Sk.math = Sk.math || {};
  Sk.math.PI_TIMES_1_OVER_4 = Math.PI / 4;
  Sk.math.PI_TIMES_2_OVER_4 = Math.PI / 2;
  Sk.math.PI_TIMES_3_OVER_4 = 3 * Math.PI / 4;
  Sk.math.PI_TIMES_4_OVER_4 = Math.PI;
  Sk.math.PI_TIMES_5_OVER_4 = 5 * Math.PI / 4;
  Sk.math.PI_TIMES_6_OVER_4 = 3 * Math.PI / 2;
  Sk.math.PI_TIMES_7_OVER_4 = 7 * Math.PI / 4;
  Sk.math.PI_TIMES_8_OVER_4 = 2 * Math.PI;
  Sk.math.EPSILON = 1e-9;
  Sk.math.isCloseTo = function (a, b, c) {
    return Math.abs(a - b) < c;
  };
  Sk.math.cos = function (a) {
    return Sk.math.isCloseTo(Math.abs(a), 0, Sk.math.EPSILON) ? 1 : Sk.math.isCloseTo(Math.abs(a), Sk.math.PI_TIMES_1_OVER_4, Sk.math.EPSILON) ? +Math.SQRT1_2 : Sk.math.isCloseTo(Math.abs(a), Sk.math.PI_TIMES_2_OVER_4, Sk.math.EPSILON) ? 0 : Sk.math.isCloseTo(Math.abs(a), Sk.math.PI_TIMES_3_OVER_4, Sk.math.EPSILON) ? -Math.SQRT1_2 : Sk.math.isCloseTo(Math.abs(a), Sk.math.PI_TIMES_4_OVER_4, Sk.math.EPSILON) ? -1 : Sk.math.isCloseTo(Math.abs(a), Sk.math.PI_TIMES_5_OVER_4, Sk.math.EPSILON) ? -Math.SQRT1_2 : Sk.math.isCloseTo(Math.abs(a), Sk.math.PI_TIMES_6_OVER_4, Sk.math.EPSILON) ? 0 : Sk.math.isCloseTo(Math.abs(a), Sk.math.PI_TIMES_7_OVER_4, Sk.math.EPSILON) ? +Math.SQRT1_2 : Sk.math.isCloseTo(Math.abs(a), Sk.math.PI_TIMES_8_OVER_4, Sk.math.EPSILON) ? 1 : Math.cos(a);
  };
  Sk.math.sin = function (a) {
    return Sk.math.isCloseTo(a, 0, Sk.math.EPSILON) ? 0 : Sk.math.isCloseTo(a, +Sk.math.PI_TIMES_1_OVER_4, Sk.math.EPSILON) ? Math.SQRT1_2 : Sk.math.isCloseTo(a, +Sk.math.PI_TIMES_2_OVER_4, Sk.math.EPSILON) ? 1 : Sk.math.isCloseTo(a, +Sk.math.PI_TIMES_3_OVER_4, Sk.math.EPSILON) ? Math.SQRT1_2 : Sk.math.isCloseTo(a, +Sk.math.PI_TIMES_4_OVER_4, Sk.math.EPSILON) ? 0 : Sk.math.isCloseTo(a, +Sk.math.PI_TIMES_5_OVER_4, Sk.math.EPSILON) ? -Math.SQRT1_2 : Sk.math.isCloseTo(a, +Sk.math.PI_TIMES_6_OVER_4, Sk.math.EPSILON) ? -1 : Sk.math.isCloseTo(a, +Sk.math.PI_TIMES_7_OVER_4, Sk.math.EPSILON) ? -Math.SQRT1_2 : Sk.math.isCloseTo(a, +Sk.math.PI_TIMES_8_OVER_4, Sk.math.EPSILON) ? 0 : Sk.math.isCloseTo(a, -Sk.math.PI_TIMES_1_OVER_4, Sk.math.EPSILON) ? -Math.SQRT1_2 : Sk.math.isCloseTo(a, -Sk.math.PI_TIMES_2_OVER_4, Sk.math.EPSILON) ? -1 : Sk.math.isCloseTo(a, -Sk.math.PI_TIMES_3_OVER_4, Sk.math.EPSILON) ? -Math.SQRT1_2 : Sk.math.isCloseTo(a, -Sk.math.PI_TIMES_4_OVER_4, Sk.math.EPSILON) ? 0 : Sk.math.isCloseTo(a, -Sk.math.PI_TIMES_5_OVER_4, Sk.math.EPSILON) ? +Math.SQRT1_2 : Sk.math.isCloseTo(a, -Sk.math.PI_TIMES_6_OVER_4, Sk.math.EPSILON) ? 1 : Sk.math.isCloseTo(a, -Sk.math.PI_TIMES_7_OVER_4, Sk.math.EPSILON) ? +Math.SQRT1_2 : Sk.math.isCloseTo(a, -Sk.math.PI_TIMES_8_OVER_4, Sk.math.EPSILON) ? 0 : Math.sin(a);
  };
  (function () {
    Sk.builtin.defineMath = function (a) {
      Sk.ffi.checkFunctionArgs('defineMath', arguments, 1, 1);
      a.e = Sk.ffi.numberToFloatPy(Math.E);
      a.pi = Sk.ffi.numberToFloatPy(Math.PI);
      a.sqrt2 = Sk.ffi.numberToFloatPy(Math.SQRT2);
      a.sqrt1_2 = Sk.ffi.numberToFloatPy(Math.SQRT1_2);
      a.tao = Sk.ffi.numberToFloatPy(2 * Math.PI);
      a.cliffordConjugate = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('cliffordConjugate', arguments, 1, 1);
        return Sk.ffi.isNum(a) ? a : Sk.ffh.cliffordConjugate(a);
      });
      a.fabs = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('fabs', arguments, 1, 1);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        return new Sk.builtin.nmber(Math.abs(Sk.builtin.asnum$(a)), Sk.builtin.nmber.float$);
      });
      a.asin = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('asin', arguments, 1, 1);
        Sk.builtin.pyCheckType('rad', 'number', Sk.builtin.checkNumber(a));
        return new Sk.builtin.nmber(Math.asin(Sk.builtin.asnum$(a)), Sk.builtin.nmber.float$);
      });
      a.acos = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('acos', arguments, 1, 1);
        Sk.builtin.pyCheckType('rad', 'number', Sk.builtin.checkNumber(a));
        return new Sk.builtin.nmber(Math.acos(Sk.builtin.asnum$(a)), Sk.builtin.nmber.float$);
      });
      a.atan = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('atan', arguments, 1, 1);
        Sk.builtin.pyCheckType('rad', 'number', Sk.builtin.checkNumber(a));
        return new Sk.builtin.nmber(Math.atan(Sk.builtin.asnum$(a)), Sk.builtin.nmber.float$);
      });
      a.atan2 = Sk.ffi.functionPy(function (a, c) {
        Sk.ffi.checkFunctionArgs('atan2', arguments, 2, 2);
        Sk.builtin.pyCheckType('y', 'number', Sk.builtin.checkNumber(a));
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(c));
        return new Sk.builtin.nmber(Math.atan2(Sk.builtin.asnum$(a), Sk.builtin.asnum$(c)), Sk.builtin.nmber.float$);
      });
      a.exp = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('exp', arguments, 1, 1);
        return Sk.ffi.isNum(a) ? Sk.ffi.numberToFloatPy(Math.exp(Sk.ffi.remapToJs(a))) : Sk.ffh.exp(a);
      });
      a.cos = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('cos', arguments, 1, 1);
        return Sk.ffi.isNum(a) ? Sk.ffi.numberToFloatPy(Sk.math.cos(Sk.ffi.remapToJs(a))) : Sk.ffh.cos(a);
      });
      a.sin = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('sin', arguments, 1, 1);
        if (Sk.ffi.isNum(a))
          return Sk.ffi.numberToFloatPy(Sk.math.sin(Sk.ffi.remapToJs(a)));
        try {
          return Sk.ffh.sin(a);
        } catch (c) {
          throw Sk.ffi.err.argument('angle').inFunction('sin').mustHaveType('Number');
        }
      });
      a.tan = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('tan', arguments, 1, 1);
        Sk.builtin.pyCheckType('rad', 'number', Sk.builtin.checkNumber(a));
        return new Sk.builtin.nmber(Math.tan(Sk.builtin.asnum$(a)), Sk.builtin.nmber.float$);
      });
      a.asinh = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('asinh', arguments, 1, 1);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        a = Sk.builtin.asnum$(a);
        var c = a + Math.sqrt(a * a + 1);
        return new Sk.builtin.nmber(Math.log(c), Sk.builtin.nmber.float$);
      });
      a.acosh = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('acosh', arguments, 1, 1);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        a = Sk.builtin.asnum$(a);
        var c = a + Math.sqrt(a * a - 1);
        return new Sk.builtin.nmber(Math.log(c), Sk.builtin.nmber.float$);
      });
      a.atanh = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('atanh', arguments, 1, 1);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        a = Sk.builtin.asnum$(a);
        return new Sk.builtin.nmber(Math.log((1 + a) / (1 - a)) / 2, Sk.builtin.nmber.float$);
      });
      a.sinh = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('sinh', arguments, 1, 1);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        a = Sk.builtin.asnum$(a);
        var c = Math.pow(Math.E, a);
        return new Sk.builtin.nmber((c - 1 / c) / 2, Sk.builtin.nmber.float$);
      });
      a.cosh = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('cosh', arguments, 1, 1);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        a = Sk.builtin.asnum$(a);
        var c = Math.pow(Math.E, a);
        return new Sk.builtin.nmber((c + 1 / c) / 2, Sk.builtin.nmber.float$);
      });
      a.tanh = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('tanh', arguments, 1, 1);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        a = Sk.builtin.asnum$(a);
        var c = Math.pow(Math.E, a), d = 1 / c;
        return new Sk.builtin.nmber((c - d) / 2 / ((c + d) / 2), Sk.builtin.nmber.float$);
      });
      a.ceil = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('ceil', arguments, 1, 1);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        return new Sk.builtin.nmber(Math.ceil(Sk.builtin.asnum$(a)), Sk.builtin.nmber.float$);
      });
      a.floor = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('floor', arguments, 1, 1);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        return new Sk.builtin.nmber(Math.floor(Sk.builtin.asnum$(a)), Sk.builtin.nmber.float$);
      });
      a.sqrt = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('sqrt', arguments, 1, 1);
        return Sk.ffi.isNum(a) ? Sk.ffi.numberToFloatPy(Math.sqrt(Sk.ffi.remapToJs(a))) : Sk.ffh.sqrt(a);
      });
      a.trunc = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('trunc', arguments, 1, 1);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        return new Sk.builtin.nmber(Sk.builtin.asnum$(a) | 0, Sk.builtin.nmber.float$);
      });
      a.log = Sk.ffi.functionPy(function (a, c) {
        Sk.ffi.checkFunctionArgs('log', arguments, 1, 2);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        if (void 0 === c)
          return new Sk.builtin.nmber(Math.log(Sk.builtin.asnum$(a)), Sk.builtin.nmber.float$);
        Sk.builtin.pyCheckType('base', 'number', Sk.builtin.checkNumber(c));
        var d = Math.log(Sk.builtin.asnum$(a)) / Math.log(Sk.builtin.asnum$(c));
        return new Sk.builtin.nmber(d, Sk.builtin.nmber.float$);
      });
      a.log10 = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('log10', arguments, 1, 1);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        var c = Math.log(Sk.builtin.asnum$(a)) / Math.log(10);
        return new Sk.builtin.nmber(c, Sk.builtin.nmber.float$);
      });
      a.pow = Sk.ffi.functionPy(function (a, c) {
        Sk.ffi.checkFunctionArgs('pow', arguments, 2, 2);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        Sk.builtin.pyCheckType('y', 'number', Sk.builtin.checkNumber(c));
        return new Sk.builtin.nmber(Math.pow(Sk.builtin.asnum$(a), Sk.builtin.asnum$(c)), Sk.builtin.nmber.float$);
      });
      a.radians = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('radians', arguments, 1, 1);
        Sk.builtin.pyCheckType('deg', 'number', Sk.builtin.checkNumber(a));
        var c = Math.PI / 180 * Sk.builtin.asnum$(a);
        return new Sk.builtin.nmber(c, Sk.builtin.nmber.float$);
      });
      a.degrees = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('degrees', arguments, 1, 1);
        Sk.builtin.pyCheckType('rad', 'number', Sk.builtin.checkNumber(a));
        var c = 180 / Math.PI * Sk.builtin.asnum$(a);
        return new Sk.builtin.nmber(c, Sk.builtin.nmber.float$);
      });
      a.hypot = Sk.ffi.functionPy(function (a, c) {
        Sk.ffi.checkFunctionArgs('hypot', arguments, 2, 2);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        Sk.builtin.pyCheckType('y', 'number', Sk.builtin.checkNumber(c));
        a = Sk.builtin.asnum$(a);
        c = Sk.builtin.asnum$(c);
        return new Sk.builtin.nmber(Math.sqrt(a * a + c * c), Sk.builtin.nmber.float$);
      });
      a.factorial = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('factorial', arguments, 1, 1);
        Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(a));
        a = Math.floor(Sk.builtin.asnum$(a));
        for (var c = 1, d = 2; d <= a; d++)
          c *= d;
        return new Sk.builtin.nmber(c, Sk.builtin.nmber.int$);
      });
      a.conjugate = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('conjugate', arguments, 1, 1);
        return Sk.ffi.isNum(a) ? a : Sk.ffh.conjugate(a);
      });
    };
  }.call(this));
  Sk.matrix = Sk.matrix || {};
  Sk.matrix.MATRIX_2x1 = 'Matrix2x1';
  Sk.matrix.MATRIX_2x2 = 'Matrix2x2';
  Sk.matrix.MATRIX_1x2 = 'Matrix1x2';
  (function () {
    Sk.builtin.defineMatrix = function (a) {
      Sk.ffi.checkFunctionArgs('defineMatrix', arguments, 1, 1);
      a[Sk.matrix.MATRIX_2x1] = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs(Sk.matrix.MATRIX_2x1, arguments, 2, 2);
          Sk.ffi.referenceToPy({
            elements: [
              b,
              c
            ]
          }, Sk.matrix.MATRIX_2x1, void 0, a);
        });
        c.__add__ = Sk.ffi.functionPy(function (b, c) {
          var f = Sk.ffi.remapToJs(b).elements, g = Sk.ffi.remapToJs(c).elements, h = Sk.ffh.add(f[0], g[0]), f = Sk.ffh.add(f[1], g[1]);
          return Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x1], h, f);
        });
        c.__sub__ = Sk.ffi.functionPy(function (b, c) {
          var f = Sk.ffi.remapToJs(b).elements, g = Sk.ffi.remapToJs(c).elements, h = Sk.ffh.subtract(f[0], g[0]), f = Sk.ffh.subtract(f[1], g[1]);
          return Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x1], h, f);
        });
        c.__mul__ = Sk.ffi.functionPy(function (b, c) {
          if (Sk.ffi.isInstance(c, Sk.matrix.MATRIX_2x1))
            throw Sk.ffi.assertionError('multiplication with 2x1 is not supported.');
          var f = Sk.ffi.remapToJs(b).elements, g = Sk.ffh.multiply(f[0], c), f = Sk.ffh.multiply(f[1], c);
          return Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x1], g, f);
        });
        c.__rmul__ = Sk.ffi.functionPy(function (b, c) {
          var f = Sk.ffi.remapToJs(b).elements, g = Sk.ffh.multiply(c, f[0]), f = Sk.ffh.multiply(c, f[1]);
          return Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x1], g, f);
        });
        c.__div__ = Sk.ffi.functionPy(function (b, c) {
          var f = Sk.ffi.remapToJs(b).elements, g = Sk.ffh.divide(f[0], c), f = Sk.ffh.divide(f[1], c);
          return Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x1], g, f);
        });
        c.__conjugate__ = Sk.ffi.functionPy(function (b) {
          Sk.ffi.checkMethodArgs('conjugate', arguments, 0, 0);
          return Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x1], Sk.ffh.conjugate(Sk.ffh.getitem(b, 0)), Sk.ffh.conjugate(Sk.ffh.getitem(b, 1)));
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.remapToJs(b);
          switch (c) {
          case 'transpose':
            return Sk.ffi.callableToPy(a, c, function (f) {
              Sk.ffi.checkMethodArgs(c, arguments, 0, 0);
              return Sk.ffi.callsim(a[Sk.matrix.MATRIX_1x2], Sk.ffh.getitem(b, 0), Sk.ffh.getitem(b, 1));
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType(Sk.matrix.MATRIX_2x1);
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          switch (b) {
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType(Sk.matrix.MATRIX_2x1);
          }
        });
        c.__getitem__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkMethodArgs('[]', arguments, 1, 1);
          Sk.ffi.checkArgType('index', Sk.ffi.PyType.INT, Sk.ffi.isInt(b), b);
          var c = Sk.ffi.remapToJs(b), g = Sk.ffi.remapToJs(a).elements;
          switch (c) {
          case 0:
            return g[0];
          case 1:
            return g[1];
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a).elements;
          a = [
            a[0],
            a[1]
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.str(a));
          }).join(', ');
          return Sk.ffi.stringToPy('(' + a + ')');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a).elements;
          a = [
            a[0],
            a[1]
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(a));
          }).join(', ');
          return Sk.ffi.stringToPy(Sk.matrix.MATRIX_2x1 + '(' + a + ')');
        });
      }, Sk.matrix.MATRIX_2x1, []);
      a[Sk.matrix.MATRIX_1x2] = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs(Sk.matrix.MATRIX_1x2, arguments, 2, 2);
          Sk.ffi.referenceToPy({
            elements: [
              b,
              c
            ]
          }, Sk.matrix.MATRIX_1x2, void 0, a);
        });
        c.__add__ = Sk.ffi.functionPy(function (b, c) {
          var f = Sk.ffi.remapToJs(b).elements, g = Sk.ffi.remapToJs(c).elements, h = Sk.ffh.add(f[0], g[0]), f = Sk.ffh.add(f[1], g[1]);
          return Sk.ffi.callsim(a[Sk.matrix.MATRIX_1x2], h, f);
        });
        c.__sub__ = Sk.ffi.functionPy(function (b, c) {
          var f = Sk.ffi.remapToJs(b).elements, g = Sk.ffi.remapToJs(c).elements, h = Sk.ffh.subtract(f[0], g[0]), f = Sk.ffh.subtract(f[1], g[1]);
          return Sk.ffi.callsim(a[Sk.matrix.MATRIX_1x2], h, f);
        });
        c.__mul__ = Sk.ffi.functionPy(function (b, c) {
          if (Sk.ffi.isInstance(c, Sk.matrix.MATRIX_2x1))
            return Sk.ffh.add(Sk.ffh.multiply(Sk.ffh.getitem(b, 0), Sk.ffh.getitem(c, 0)), Sk.ffh.multiply(Sk.ffh.getitem(b, 1), Sk.ffh.getitem(c, 1)));
          if (Sk.ffi.isInstance(c, Sk.matrix.MATRIX_1x2))
            throw Sk.ffi.assertionError('multiplication with 2x1 is not supported.');
          var f = Sk.ffi.remapToJs(b).elements, g = Sk.ffh.multiply(f[0], c), f = Sk.ffh.multiply(f[1], c);
          return Sk.ffi.callsim(a[Sk.matrix.MATRIX_1x2], g, f);
        });
        c.__rmul__ = Sk.ffi.functionPy(function (b, c) {
          var f = Sk.ffi.remapToJs(b).elements, g = Sk.ffh.multiply(c, f[0]), f = Sk.ffh.multiply(c, f[1]);
          return Sk.ffi.callsim(a[Sk.matrix.MATRIX_1x2], g, f);
        });
        c.__div__ = Sk.ffi.functionPy(function (b, c) {
          var f = Sk.ffi.remapToJs(b).elements, g = Sk.ffh.divide(f[0], c), f = Sk.ffh.divide(f[1], c);
          return Sk.ffi.callsim(a[Sk.matrix.MATRIX_1x2], g, f);
        });
        c.__conjugate__ = Sk.ffi.functionPy(function (b) {
          Sk.ffi.checkMethodArgs('conjugate', arguments, 0, 0);
          return Sk.ffi.callsim(a[Sk.matrix.MATRIX_1x2], Sk.ffh.conjugate(Sk.ffh.getitem(b, 0)), Sk.ffh.conjugate(Sk.ffh.getitem(b, 1)));
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.remapToJs(b);
          switch (c) {
          case 'transpose':
            return Sk.ffi.callableToPy(a, c, function (f) {
              Sk.ffi.checkMethodArgs(c, arguments, 0, 0);
              return Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x1], Sk.ffh.getitem(b, 0), Sk.ffh.getitem(b, 1));
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType(Sk.matrix.MATRIX_1x2);
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          switch (b) {
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType(Sk.matrix.MATRIX_1x2);
          }
        });
        c.__getitem__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkMethodArgs('[]', arguments, 1, 1);
          Sk.ffi.checkArgType('index', Sk.ffi.PyType.INT, Sk.ffi.isInt(b), b);
          var c = Sk.ffi.remapToJs(b), g = Sk.ffi.remapToJs(a).elements;
          switch (c) {
          case 0:
            return g[0];
          case 1:
            return g[1];
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = [
            Sk.ffh.getitem(a, 0),
            Sk.ffh.getitem(a, 1)
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.str(a));
          }).join(' ');
          return Sk.ffi.stringToPy('[' + a + ']');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          a = [
            Sk.ffh.getitem(a, 0),
            Sk.ffh.getitem(a, 1)
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(a));
          }).join(', ');
          return Sk.ffi.stringToPy(Sk.matrix.MATRIX_1x2 + '(' + a + ')');
        });
      }, Sk.matrix.MATRIX_1x2, []);
      a[Sk.matrix.MATRIX_2x2] = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs(Sk.matrix.MATRIX_2x2, arguments, 2, 2);
          Sk.ffi.checkArgType('one', Sk.matrix.MATRIX_2x1, Sk.ffi.isInstance(b, Sk.matrix.MATRIX_2x1), b);
          Sk.ffi.checkArgType('two', Sk.matrix.MATRIX_2x1, Sk.ffi.isInstance(c, Sk.matrix.MATRIX_2x1), c);
          Sk.ffi.referenceToPy({
            elements: [
              b,
              c
            ]
          }, Sk.matrix.MATRIX_2x2, void 0, a);
        });
        c.__add__ = Sk.ffi.functionPy(function (b, c) {
          var f = Sk.ffi.remapToJs(b).elements, g = Sk.ffi.remapToJs(c).elements, h = Sk.ffh.add(f[0], g[0]), f = Sk.ffh.add(f[1], g[1]);
          return Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x2], h, f);
        });
        c.__sub__ = Sk.ffi.functionPy(function (b, c) {
          var f = Sk.ffi.remapToJs(b).elements, g = Sk.ffi.remapToJs(c).elements, h = Sk.ffh.subtract(f[0], g[0]), f = Sk.ffh.subtract(f[1], g[1]);
          return Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x2], h, f);
        });
        c.__mul__ = Sk.ffi.functionPy(function (b, c) {
          var f = Sk.ffh.getitem(Sk.ffh.getitem(b, 0), 0), g = Sk.ffh.getitem(Sk.ffh.getitem(b, 0), 1), h = Sk.ffh.getitem(Sk.ffh.getitem(b, 1), 0), k = Sk.ffh.getitem(Sk.ffh.getitem(b, 1), 1);
          if (Sk.ffi.isInstance(c, Sk.matrix.MATRIX_2x2)) {
            var l = Sk.ffh.getitem(Sk.ffh.getitem(c, 0), 0), m = Sk.ffh.getitem(Sk.ffh.getitem(c, 0), 1), n = Sk.ffh.getitem(Sk.ffh.getitem(c, 1), 0), p = Sk.ffh.getitem(Sk.ffh.getitem(c, 1), 1), q = Sk.ffh.add(Sk.ffh.multiply(f, l), Sk.ffh.multiply(h, m)), l = Sk.ffh.add(Sk.ffh.multiply(g, l), Sk.ffh.multiply(k, m)), f = Sk.ffh.add(Sk.ffh.multiply(f, n), Sk.ffh.multiply(h, p)), g = Sk.ffh.add(Sk.ffh.multiply(g, n), Sk.ffh.multiply(k, p)), h = Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x1], q, l), g = Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x1], f, g);
            return Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x2], h, g);
          }
          if (Sk.ffi.isInstance(c, Sk.matrix.MATRIX_2x1))
            return q = Sk.ffh.getitem(c, 0), n = Sk.ffh.getitem(c, 1), h = Sk.ffh.add(Sk.ffh.multiply(f, q), Sk.ffh.multiply(h, n)), g = Sk.ffh.add(Sk.ffh.multiply(g, q), Sk.ffh.multiply(k, n)), Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x1], h, g);
          q = Sk.ffh.multiply(f, c);
          l = Sk.ffh.multiply(g, c);
          f = Sk.ffh.multiply(h, c);
          g = Sk.ffh.multiply(k, c);
          h = Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x1], q, l);
          g = Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x1], f, g);
          return Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x2], h, g);
        });
        c.__rmul__ = Sk.ffi.functionPy(function (b, c) {
          var f = Sk.ffh.getitem(Sk.ffh.getitem(b, 0), 0), g = Sk.ffh.getitem(Sk.ffh.getitem(b, 0), 1), h = Sk.ffh.getitem(Sk.ffh.getitem(b, 1), 0), k = Sk.ffh.getitem(Sk.ffh.getitem(b, 1), 1);
          if (Sk.ffi.isInstance(c, Sk.matrix.MATRIX_1x2))
            var l = Sk.ffh.getitem(Sk.ffh.getitem(c, 0), 0), m = Sk.ffh.getitem(Sk.ffh.getitem(c, 0), 1), n = Sk.ffh.getitem(Sk.ffh.getitem(c, 1), 0), p = Sk.ffh.getitem(Sk.ffh.getitem(c, 1), 1), q = Sk.ffh.add(Sk.ffh.multiply(f, l), Sk.ffh.multiply(h, m)), l = Sk.ffh.add(Sk.ffh.multiply(g, l), Sk.ffh.multiply(k, m)), f = Sk.ffh.add(Sk.ffh.multiply(f, n), Sk.ffh.multiply(h, p)), g = Sk.ffh.add(Sk.ffh.multiply(g, n), Sk.ffh.multiply(k, p));
          else
            q = Sk.ffh.rmultiply(f, c), l = Sk.ffh.rmultiply(g, c), f = Sk.ffh.rmultiply(h, c), g = Sk.ffh.rmultiply(k, c);
          q = Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x1], q, l);
          g = Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x1], f, g);
          return Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x2], q, g);
        });
        c.__div__ = Sk.ffi.functionPy(function (b, c) {
          var f = Sk.ffi.remapToJs(b).elements, g = Sk.ffh.divide(f[0], c), f = Sk.ffh.divide(f[1], c);
          return Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x2], g, f);
        });
        c.__conjugate__ = Sk.ffi.functionPy(function (b) {
          Sk.ffi.checkMethodArgs('conjugate', arguments, 0, 0);
          return Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x2], Sk.ffh.conjugate(Sk.ffh.getitem(b, 0)), Sk.ffh.conjugate(Sk.ffh.getitem(b, 1)));
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.remapToJs(b);
          switch (c) {
          case 'transpose':
            return Sk.ffi.callableToPy(a, c, function (f) {
              Sk.ffi.checkMethodArgs(c, arguments, 0, 0);
              var g = Sk.ffh.getitem(b, 0), h = Sk.ffh.getitem(b, 1), k = Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x1], Sk.ffh.getitem(g, 0), Sk.ffh.getitem(h, 0)), g = Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x1], Sk.ffh.getitem(g, 1), Sk.ffh.getitem(h, 1));
              return Sk.ffi.callsim(a[Sk.matrix.MATRIX_2x2], k, g);
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType(Sk.matrix.MATRIX_2x2);
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          switch (b) {
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType(Sk.matrix.MATRIX_2x2);
          }
        });
        c.__getitem__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkMethodArgs('[]', arguments, 1, 1);
          Sk.ffi.checkArgType('index', Sk.ffi.PyType.INT, Sk.ffi.isInt(b), b);
          var c = Sk.ffi.remapToJs(b), g = Sk.ffi.remapToJs(a).elements;
          switch (c) {
          case 0:
            return g[0];
          case 1:
            return g[1];
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = [
            Sk.ffh.getitem(a, 0),
            Sk.ffh.getitem(a, 1)
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.str(a));
          }).join(' ');
          return Sk.ffi.stringToPy('[' + a + ']');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          a = [
            Sk.ffh.getitem(a, 0),
            Sk.ffh.getitem(a, 1)
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(a));
          }).join(', ');
          return Sk.ffi.stringToPy(Sk.matrix.MATRIX_2x2 + '(' + a + ')');
        });
      }, Sk.matrix.MATRIX_2x2, []);
    };
  }.call(this));
  (function () {
    Sk.builtin.defineComplex = function (a, b) {
      function c(a) {
        return Sk.ffi.isInstance(a, b);
      }
      function d(a, b) {
        return Math.sqrt(a * a + b * b);
      }
      function e(a, b, c) {
        var d, e, f, g, s;
        f = [];
        d = function (a, b) {
          var d;
          if (0 !== a) {
            0 <= a ? 0 < f.length && f.push('+') : f.push('-');
            d = Math.abs(a);
            if (1 === d)
              return f.push(b);
            f.push(d.toString());
            if ('1' !== b)
              return f.push(c), f.push(b);
          }
        };
        e = g = 0;
        for (s = a.length - 1; 0 <= s ? g <= s : g >= s; e = 0 <= s ? ++g : --g)
          d(a[e], b[e]);
        return 0 < f.length ? f.join('') : '0';
      }
      function f(c, d) {
        return Sk.ffi.callsim(a[b], Sk.ffi.numberToFloatPy(c), Sk.ffi.numberToFloatPy(d));
      }
      Sk.ffi.checkFunctionArgs('defineComplex', arguments, 2, 2);
      var g = [
          Sk.ffi.PyType.FLOAT,
          Sk.ffi.PyType.INT,
          Sk.ffi.PyType.LONG
        ];
      a[b] = Sk.ffi.buildClass(a, function (d, k) {
        k.__init__ = Sk.ffi.functionPy(function (a, c, d) {
          Sk.ffi.checkMethodArgs(b, arguments, 2, 2);
          Sk.ffi.checkArgType('real', g, Sk.ffi.isNum(c), c);
          Sk.ffi.checkArgType('imag', g, Sk.ffi.isNum(d), d);
          Sk.ffi.referenceToPy({
            x: Sk.ffi.remapToJs(c),
            y: Sk.ffi.remapToJs(d)
          }, b, void 0, a);
        });
        k.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'real':
            return Sk.ffi.numberToFloatPy(d.x);
          case 'imag':
            return Sk.ffi.numberToFloatPy(d.y);
          case 'abs':
            return Sk.ffi.callableToPy(a, c, function (a) {
              return Sk.ffi.numberToFloatPy(Math.sqrt(d.x * d.x + d.y * d.y));
            });
          case 'conjugate':
            return Sk.ffi.callableToPy(a, c, function (a) {
              return f(d.x, -d.y);
            });
          case 'exp':
            return Sk.ffi.callableToPy(a, c, function (a) {
              a = Math.exp(d.x);
              var b = Sk.math.cos(d.y), c = Sk.math.sin(d.y);
              return f(a * b, a * c);
            });
          }
        });
        k.__add__ = Sk.ffi.functionPy(function (a, d) {
          var e = Sk.ffi.remapToJs(a), g = Sk.ffi.remapToJs(d);
          if (c(d))
            return f(e.x + g.x, e.y + g.y);
          if (Sk.ffi.isNum(d))
            return f(e.x + g, e.y);
          throw Sk.ffi.err.argument('other').mustHaveType(b);
        });
        k.__radd__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkArgType('other', g, Sk.ffi.isNum(b), b);
          var c = Sk.ffi.remapToJs(b), d = Sk.ffi.remapToJs(a);
          return f(c + d.x, d.y);
        });
        k.__iadd__ = Sk.ffi.functionPy(function (a, d) {
          var e = Sk.ffi.remapToJs(a), f = Sk.ffi.remapToJs(d);
          if (Sk.ffi.isNum(d))
            e.x += f;
          else if (c(d))
            e.x += f.x, e.y += f.y;
          else
            throw Sk.ffi.err.argument('other').mustHaveType([
              b,
              g
            ]);
          return a;
        });
        k.__sub__ = Sk.ffi.functionPy(function (a, d) {
          var e = Sk.ffi.remapToJs(a), h = Sk.ffi.remapToJs(d);
          if (c(d))
            return f(e.x - h.x, e.y - h.y);
          if (Sk.ffi.isNum(d))
            return f(e.x - h, e.y);
          throw Sk.ffi.err.argument('other').mustHaveType([
            b,
            g
          ]);
        });
        k.__rsub__ = Sk.ffi.functionPy(function (a, b) {
          var c, d;
          c = Sk.ffi.remapToJs(b);
          d = Sk.ffi.remapToJs(a);
          if (Sk.ffi.isNum(b))
            return c -= d.x, d = -d.y, f(c, d);
          throw Sk.ffi.err.argument('other').mustHaveType(g);
        });
        k.__isub__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
          Sk.ffi.isNum(b) ? c.x -= d : (c.x -= d.x, c.y -= d.y);
          return a;
        });
        k.__mul__ = Sk.ffi.functionPy(function (a, b) {
          var d, e;
          e = Sk.ffi.remapToJs(a);
          var g = Sk.ffi.remapToJs(b);
          return c(b) ? (d = e.x * g.x - e.y * g.y, e = e.y * g.x + e.x * g.y, f(d, e)) : Sk.ffi.isNum(b) ? (d = e.x * g, e = e.y * g, f(d, e)) : Sk.ffh.rmultiply(b, a);
        });
        k.__rmul__ = Sk.ffi.functionPy(function (a, b) {
          var d, e;
          e = Sk.ffi.remapToJs(b);
          var h = Sk.ffi.remapToJs(a);
          if (c(b))
            return d = h.x * e.x - h.y * e.y, e = h.y * e.x + h.x * e.y, f(d, e);
          if (Sk.ffi.isNum(b))
            return d = e * h.x, e *= h.y, f(d, e);
          throw Sk.ffi.err.argument('other').mustHaveType(g);
        });
        k.__imul__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = c.x, e = c.y, f = Sk.ffi.remapToJs(b);
          Sk.ffi.isNum(b) ? (c.x *= f, c.y *= f) : (c.x = d * f.x - e * f.y, c.y = e * f.x + d * f.y);
          return a;
        });
        k.__div__ = Sk.ffi.functionPy(function (a, d) {
          var e = Sk.ffi.remapToJs(a), h = Sk.ffi.remapToJs(d);
          if (c(d)) {
            var k = h.x * h.x + h.y * h.y;
            return f((e.x * h.x + e.y * h.y) / k, (e.y * h.x - e.x * h.y) / k);
          }
          if (Sk.ffi.isNum(d))
            return f(e.x / h, e.y / h);
          Sk.ffi.checkArgType('other', [
            b,
            g
          ], !1, d);
        });
        k.__rdiv__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkArgType('other', g, Sk.ffi.isNum(b), b);
          var c = Sk.ffi.remapToJs(b), d = Sk.ffi.remapToJs(a);
          if (Sk.ffi.isNum(b)) {
            var e = d.x * d.x + d.y * d.y;
            return f(c * d.x / e, -c * d.y / e);
          }
          throw Sk.ffi.err.argument('other').mustHaveType(g);
        });
        k.__idiv__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = c.x, e = c.y, f = Sk.ffi.remapToJs(b);
          if (Sk.ffi.isNum(b))
            c.x /= f, c.y /= f;
          else {
            var g = f.x * f.x + f.y * f.y;
            c.x = (d * f.x + e * f.y) / g;
            c.y = (e * f.x - d * f.y) / g;
          }
          return a;
        });
        k.__abs__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.numberToFloatPy(Math.sqrt(a.x * a.x + a.y * a.y));
        });
        k.__conjugate__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return f(a.x, -a.y);
        });
        k.__cos__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = a.x, c = a.y;
          a = Sk.math.cos(b);
          var d = (Math.pow(Math.E, c) + Math.pow(Math.E, -c)) / 2, b = Sk.math.sin(b), c = (Math.pow(Math.E, c) - Math.pow(Math.E, -c)) / 2;
          return f(a * d, -b * c);
        });
        k.__sin__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = a.x, c = a.y;
          a = Sk.math.cos(b);
          var d = (Math.pow(Math.E, c) + Math.pow(Math.E, -c)) / 2, b = Sk.math.sin(b), c = (Math.pow(Math.E, c) - Math.pow(Math.E, -c)) / 2;
          return f(b * d, a * c);
        });
        k.__exp__ = Sk.ffi.functionPy(function (a) {
          var b = Sk.ffi.remapToJs(a);
          a = Math.exp(b.x);
          var c = Sk.math.cos(b.y), b = Sk.math.sin(b.y);
          return f(a * c, a * b);
        });
        k.__pos__ = Sk.ffi.functionPy(function (a) {
          return a;
        });
        k.__neg__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return f(-a.x, -a.y);
        });
        k.__invert__ = Sk.ffi.functionPy(function (a) {
          var b = f(1, 0);
          return Sk.ffi.callsim(a.__div__, b, a);
        });
        k.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy(e([
            a.x,
            a.y
          ], [
            '1',
            'i'
          ], ''));
        });
        k.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy(b + '(' + a.x + ', ' + a.y + ')');
        });
        k.__eq__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          return a.x === b.x && a.y === b.y;
        });
        k.__ne__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          return a.x !== b.x || a.y !== b.y;
        });
      }, b, []);
      a.phase = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('phase', arguments, 1, 1);
        if (c(a)) {
          var d = Sk.ffi.remapToJs(a);
          return Sk.ffi.numberToFloatPy(Math.atan2(d.y, d.x));
        }
        if (Sk.ffi.isNum(a))
          return Sk.ffi.numberToFloatPy(Math.atan2(0, Sk.ffi.remapToJs(a)));
        Sk.ffi.checkArgType('x', b, !1, a);
      });
      a.polar = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('polar', arguments, 1, 1);
        if (c(a)) {
          var e = Sk.ffi.remapToJs(a);
          return Sk.ffi.tuplePy([
            Sk.ffi.numberToFloatPy(d(e.x, e.y)),
            Sk.ffi.numberToFloatPy(Math.atan2(e.y, e.x))
          ]);
        }
        if (Sk.ffi.isNum(a))
          return Sk.ffi.tuplePy([
            Sk.ffi.numberToFloatPy(d(Sk.ffi.remapToJs(a), 0)),
            Sk.ffi.numberToFloatPy(0)
          ]);
        Sk.ffi.checkArgType('x', b, !1, a);
      });
    };
  }.call(this));
  (function () {
    Sk.builtin.defineQuaternion = function (a, b) {
      function c(a, b, c) {
        var d, k, l, m, n;
        l = [];
        d = function (a, b) {
          var d;
          if (0 !== a) {
            0 <= a ? 0 < l.length && l.push('+') : l.push('-');
            d = Math.abs(a);
            if (1 === d)
              return l.push(b);
            l.push(d.toString());
            if ('1' !== b)
              return l.push(c), l.push(b);
          }
        };
        k = m = 0;
        for (n = a.length - 1; 0 <= n ? m <= n : m >= n; k = 0 <= n ? ++m : --m)
          d(a[k], b[k]);
        return 0 < l.length ? l.join('') : '0';
      }
      function d(b, c, d, h) {
        return Sk.ffi.callsim(a.Quaternion, Sk.ffi.numberToFloatPy(c), Sk.ffi.numberToFloatPy(d), Sk.ffi.numberToFloatPy(h), Sk.ffi.numberToFloatPy(b));
      }
      Sk.ffi.checkFunctionArgs('defineQuaternion', arguments, 2, 2);
      a.Quaternion = Sk.ffi.buildClass(a, function (e, f) {
        f.__init__ = Sk.ffi.functionPy(function (a, c, d, e, f) {
          Sk.ffi.isInstance(c, 'Quaternion') ? Sk.ffi.referenceToPy(Sk.ffi.remapToJs(c), 'Quaternion', void 0, a) : (c = Sk.ffi.remapToJs(c), d = Sk.ffi.remapToJs(d), e = Sk.ffi.remapToJs(e), f = Sk.ffi.remapToJs(f), Sk.ffi.referenceToPy(new b.Quaternion(c, d, e, f), 'Quaternion', void 0, a));
        });
        f.__add__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          return Sk.ffi.isNum(b) ? d(c.w + e, c.x, c.y, c.z) : d(c.w + e.w, c.x + e.x, c.y + e.y, c.z + e.z);
        });
        f.__radd__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(a);
          if (Sk.ffi.isNum(b))
            return d(c + e.w, e.x, e.y, e.z);
          throw Sk.ffi.err.operand('other').toOperation('+').mustHaveType('Quaternion');
        });
        f.__iadd__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
          Sk.ffi.isNum(b) ? c.w += d : (c.w += d.w, c.x += d.x, c.y += d.y, c.z += d.z);
          return a;
        });
        f.__sub__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          return Sk.ffi.isNum(b) ? d(c.w - e, c.x, c.y, c.z) : d(c.w - e.w, c.x - e.x, c.y - e.y, c.z - e.z);
        });
        f.__rsub__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(a);
          if (Sk.ffi.isNum(b))
            return d(c - e.w, -e.x, -e.y, -e.z);
          throw Sk.ffi.err.operand('other').toOperation('-').mustHaveType('Quaternion');
        });
        f.__isub__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
          Sk.ffi.isNum(b) ? c.w -= d : (c.w -= d.w, c.x -= d.x, c.y -= d.y, c.z -= d.z);
          return a;
        });
        f.__mul__ = Sk.ffi.functionPy(function (c, e) {
          var f = Sk.ffi.remapToJs(c), l = Sk.ffi.remapToJs(e);
          if (Sk.ffi.isNum(e))
            return d(f.w * l, f.x * l, f.y * l, f.z * l);
          f = new b.Quaternion(0, 0, 0, 1).multiplyQuaternions(f, l);
          return Sk.ffi.callsim(a.Quaternion, Sk.ffi.referenceToPy(f, 'Quaternion'));
        });
        f.__rmul__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(a);
          if (Sk.ffi.isNum(b))
            return d(c * e.w, c * e.x, c * e.y, c * e.z);
          throw Sk.ffi.err.operand('other').toOperation('*').mustHaveType('Quaternion');
        });
        f.__imul__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
          Sk.ffi.isNum(b) ? (c.w *= d, c.x *= d, c.y *= d, c.z *= d) : c.multiply(d);
          return a;
        });
        f.nb$positive = function () {
          return this;
        };
        f.nb$negative = function () {
          var a = Sk.ffi.remapToJs(this);
          return d(-a.w, -a.x, -a.y, -a.z);
        };
        f.__eq__ = Sk.ffi.functionPy(function (a, b) {
          if (Sk.ffi.isInstance(b, 'Quaternion')) {
            var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
            return Sk.ffi.booleanToPy(c.w === d.w && c.x === d.x && c.y === d.y && c.z === d.z);
          }
          return Sk.ffi.bool.False;
        });
        f.__ne__ = Sk.ffi.functionPy(function (a, b) {
          if (Sk.ffi.isInstance(b, 'Quaternion')) {
            var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
            return Sk.ffi.booleanToPy(c.w !== d.w || c.x !== d.x || c.y !== d.y || c.z !== d.z);
          }
          return Sk.ffi.bool.True;
        });
        f.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var e = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'x':
            return Sk.ffi.numberToFloatPy(e.x);
          case 'y':
            return Sk.ffi.numberToFloatPy(e.y);
          case 'z':
            return Sk.ffi.numberToFloatPy(e.z);
          case 'w':
            return Sk.ffi.numberToFloatPy(e.w);
          case 'copy':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(null, 'copy', null, a);
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c) {
                Sk.ffi.checkMethodArgs('copy', arguments, 1, 1);
                Sk.ffi.checkArgType('q', 'Quaternion', Sk.ffi.isInstance(c, 'Quaternion'), c);
                var d = Sk.ffi.remapToJs(c);
                e.copy(d);
                return b;
              });
            }, 'copy', []));
          case 'setFromAxisAngle':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(null, 'setFromAxisAngle', null, a);
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c, d) {
                a = Sk.ffi.remapToJs(c);
                d = Sk.ffi.remapToJs(d);
                e.setFromAxisAngle(a, d);
                return b;
              });
            }, 'setFromAxisAngle', []));
          case 'setFromEuler':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(null, 'setFromEuler', null, a);
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c, d) {
                a = Sk.ffi.remapToJs(c);
                d = Sk.ffi.remapToJs(d);
                e.setFromEuler(a, d);
                return b;
              });
            }, 'setFromEuler', []));
          case 'set':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(null, 'set', null, a);
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c, d, f, h) {
                e.x = Sk.ffi.remapToJs(c);
                e.y = Sk.ffi.remapToJs(d);
                e.z = Sk.ffi.remapToJs(f);
                e.w = Sk.ffi.remapToJs(h);
                return b;
              });
            }, 'set', []));
          case 'clone':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(null, 'clone', null, a);
              });
              b.__call__ = Sk.ffi.functionPy(function (a) {
                return d(e.w, e.x, e.y, e.z);
              });
            }, 'clone', []));
          case 'conjugate':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(null, 'conjugate', null, a);
              });
              c.__call__ = Sk.ffi.functionPy(function (a) {
                e.conjugate();
                return b;
              });
            }, 'conjugate', []));
          case 'inverse':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(null, 'inverse', null, a);
              });
              c.__call__ = Sk.ffi.functionPy(function (a) {
                a = 1 / e.lengthSq();
                e.conjugate();
                e.w *= a;
                e.x *= a;
                e.y *= a;
                e.z *= a;
                return b;
              });
            }, 'inverse', []));
          case 'magnitude':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(null, 'magnitude', null, a);
              });
              b.__call__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.numberToFloatPy(e.length());
              });
            }, 'magnitude', []));
          case 'quadrance':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(null, 'quadrance', null, a);
              });
              b.__call__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.numberToFloatPy(e.lengthSq());
              });
            }, 'quadrance', []));
          case 'normalize':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(null, 'normalize', null, a);
              });
              c.__call__ = Sk.ffi.functionPy(function (a) {
                e.normalize();
                return b;
              });
            }, 'normalize', []));
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('Quaternion');
          }
        });
        f.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          c = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'x':
            a.x = c;
            break;
          case 'y':
            a.y = c;
            break;
          case 'z':
            a.z = c;
            break;
          case 'w':
            a.w = c;
            break;
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('Quaternion');
          }
        });
        f.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('Quaternion(' + [
            a.x,
            a.y,
            a.z,
            a.w
          ].join(', ') + ')');
        });
        f.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy(c([
            a.w,
            a.x,
            a.y,
            a.z
          ], [
            '1',
            'i',
            'j',
            'k'
          ]));
        });
      }, 'Quaternion', []);
    };
  }.call(this));
  Sk.builtin.buildDocumentClass = function (a) {
    var b = function (b) {
        return b ? Sk.ffi.callsim(a.Node, Sk.ffi.referenceToPy(b, 'Node')) : Sk.ffi.none.None;
      }, c = {};
    a.Document = Sk.misceval.buildClass(a, function (d, e) {
      e.__init__ = Sk.ffi.functionPy(function (a, b) {
        Sk.ffi.checkMethodArgs('Document', arguments, 1, 1);
        Sk.ffi.referenceToPy(Sk.ffi.remapToJs(b), 'Document', void 0, a);
      });
      e.__getattr__ = Sk.ffi.functionPy(function (d, e) {
        var h = Sk.ffi.remapToJs(d);
        switch (e) {
        case 'body':
          return b(h.body);
        case 'webkitHidden':
          return Sk.ffi.booleanToPy(h.webkitHidden);
        case 'addEventListener':
          return Sk.ffi.callsim(Sk.misceval.buildClass(a, function (b, d) {
            d.__init__ = Sk.ffi.functionPy(function (a) {
            });
            d.__call__ = Sk.ffi.functionPy(function (b, d, e, f) {
              b = Sk.ffi.remapToJs(d);
              d = function (b) {
                b = Sk.ffi.callsim(a.Event, Sk.ffi.referenceToPy(b, 'Event'));
                Sk.ffi.callsim(e, b);
              };
              c[b] = d;
              h.addEventListener(b, d, f);
            });
          }, 'addEventListener', []));
        case 'removeEventListener':
          return Sk.ffi.callsim(Sk.misceval.buildClass(a, function (a, b) {
            b.__init__ = Sk.ffi.functionPy(function (a) {
            });
            b.__call__ = Sk.ffi.functionPy(function (a, b, d, e) {
              a = Sk.ffi.remapToJs(b);
              d = c[a];
              delete c[a];
              h.removeEventListener(a, d, e);
            });
          }, 'removeEventListener', []));
        case 'createElement':
          return Sk.ffi.callableToPy(a, 'createElement', function (a, c, d) {
            Sk.ffi.checkMethodArgs('createElement', arguments, 1, 2);
            Sk.ffi.checkArgType('tagName', Sk.ffi.PyType.STR, Sk.ffi.isStr(c), c);
            var e = h.createElement(Sk.ffi.remapToJs(c));
            if (d instanceof Sk.builtin.dict)
              for (var f = d.tp$iter(), g = f.tp$iternext(); void 0 !== g; g = f.tp$iternext()) {
                var s = d.mp$subscript(g);
                void 0 === s && (s = null);
                g = Sk.ffi.remapToJs(g);
                s = Sk.ffi.remapToJs(s);
                e.setAttribute(g, s);
              }
            return b(e);
          });
        case 'getElementById':
          return Sk.ffi.callableToPy(a, 'getElementById', function (a, c) {
            Sk.ffi.checkMethodArgs('getElementById', arguments, 1, 1);
            Sk.ffi.checkArgType('id', Sk.ffi.PyType.STR, Sk.ffi.isStr(c), c);
            return b(h.getElementById(Sk.ffi.remapToJs(c)));
          });
        case 'getElementsByTagName':
          return Sk.ffi.callableToPy(a, 'getElementsByTagName', function (a, c) {
            Sk.ffi.checkMethodArgs('getElementsByTagName', arguments, 1, 1);
            Sk.ffi.checkArgType('tagName', Sk.ffi.PyType.STR, Sk.ffi.isStr(c), c);
            for (var d = h.getElementsByTagName(Sk.ffi.remapToJs(c)), e = [], f = d.length - 1; 0 <= f; f--)
              e.push(b(d[f]));
            return Sk.ffi.listPy(e);
          });
        case 'removeElementsByTagName':
          return Sk.ffi.callableToPy(a, 'removeElementsByTagName', function (a, c) {
            Sk.ffi.checkMethodArgs('removeElementsByTagName', arguments, 1, 1);
            Sk.ffi.checkArgType('tagName', Sk.ffi.PyType.STR, Sk.ffi.isStr(c), c);
            for (var d = h.getElementsByTagName(Sk.ffi.remapToJs(c)), e = [], f = d.length - 1; 0 <= f; f--) {
              var g = d[f];
              g.parentNode.removeChild(g);
              e.push(b(g));
            }
            return Sk.ffi.listPy(e);
          });
        case 'write':
          return Sk.ffi.callableToPy(a, 'write', function (a, b) {
            Sk.ffi.checkMethodArgs('write', arguments, 0, 1);
            Sk.ffi.checkArgType('exp1', Sk.ffi.PyType.STR, Sk.ffi.isStr(b), b);
            h.write(Sk.ffi.remapToJs(b));
          });
        default:
          throw Sk.ffi.err.attribute(e).isNotGetableOnType('Document');
        }
      });
      e.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
        a = Sk.ffi.remapToJs(a);
        switch (b) {
        case 'title':
          Sk.ffi.checkArgType(b, [Sk.ffi.PyType.STR], Sk.ffi.isStr(c), c);
          a[b] = Sk.ffi.remapToJs(c);
          break;
        default:
          throw Sk.ffi.err.attribute(b).isNotSetableOnType('Document');
        }
      });
      e.__str__ = Sk.ffi.functionPy(function (a) {
        return Sk.ffi.stringToPy('Document');
      });
      e.__repr__ = Sk.ffi.functionPy(function (a) {
        return Sk.ffi.stringToPy('Document');
      });
    }, 'Document', []);
    return a.Document;
  };
  (function () {
    Sk.builtin.defineEasel = function (a, b, c) {
      function d(b, c, d) {
        var e = Sk.ffi.remapToJs(b);
        switch (c) {
        case 'alpha':
          return Sk.ffi.numberToFloatPy(e.alpha);
        case 'graphics':
          return Sk.ffi.callsim(a.Graphics, Sk.ffi.referenceToPy(e.graphics, 'Graphics'));
        case 'name':
          return Sk.ffi.stringToPy(e.name);
        case 'x':
          return Sk.ffi.numberToFloatPy(e.x);
        case 'y':
          return Sk.ffi.numberToFloatPy(e.y);
        case 'rotation':
          return Sk.ffi.numberToFloatPy(e.rotation);
        case 'addEventListener':
          return Sk.builtin.addEventListener(a, e);
        case 'removeEventListener':
          return Sk.builtin.removeEventListener(a, e);
        case 'globalToLocal':
          return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
            c.__init__ = Sk.ffi.functionPy(function (a) {
              a.tp$name = 'globalToLocal';
              a.v = e.globalToLocal;
            });
            c.__call__ = Sk.ffi.functionPy(function (b, c, d) {
              b = e.globalToLocal(Sk.ffi.remapToJs(c), Sk.ffi.remapToJs(d));
              return Sk.ffi.callsim(a.Point, Sk.ffi.referenceToPy(b, 'Point'));
            });
          }, 'globalToLocal', []));
        case 'hitTest':
          return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
            b.__init__ = Sk.ffi.functionPy(function (a) {
              a.tp$name = 'hitTest';
              a.v = e.hitTest;
            });
            b.__call__ = Sk.ffi.functionPy(function (a, b, c) {
              return Sk.ffi.booleanToPy(e.hitTest(Sk.ffi.remapToJs(b), Sk.ffi.remapToJs(c)));
            });
          }, 'hitTest', []));
        case 'localToLocal':
          return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
            c.__init__ = Sk.ffi.functionPy(function (a) {
              a.tp$name = 'localToLocal';
              a.v = e.localToLocal;
            });
            c.__call__ = Sk.ffi.functionPy(function (b, c, d, f) {
              b = e.localToLocal(Sk.ffi.remapToJs(c), Sk.ffi.remapToJs(d), Sk.ffi.remapToJs(f));
              return Sk.ffi.callsim(a.Point, Sk.ffi.referenceToPy(b, 'Point'));
            });
          }, 'localToLocal', []));
        default:
          throw Sk.ffi.err.attribute(c).isNotGetableOnType(d);
        }
      }
      function e(a, b, c, d) {
        a = Sk.ffi.remapToJs(a);
        var e = Sk.ffi.remapToJs(c);
        switch (b) {
        case 'alpha':
          Sk.ffi.checkArgType('alpha', f, Sk.ffi.isNum(c), c);
          a.alpha = e;
          break;
        case 'name':
          Sk.ffi.checkArgType('name', Sk.ffi.PyType.STR, Sk.ffi.isStr(c), c);
          a.name = e;
          break;
        case 'x':
        case 'y':
          Sk.ffi.checkArgType(b, f, Sk.ffi.isNum(c), c);
          a[b] = e;
          break;
        case 'rotation':
          Sk.ffi.checkArgType('rotation', f, Sk.ffi.isNum(c), c);
          a.rotation = e;
          break;
        default:
          throw Sk.ffi.err.attribute(b).isNotSetableOnType(d);
        }
      }
      Sk.ffi.checkFunctionArgs('defineEasel', arguments, 3, 3);
      Sk.builtin.defineEuclidean2(a, c);
      Sk.builtin.defineEvent(a);
      var f = [
          Sk.ffi.PyType.FLOAT,
          Sk.ffi.PyType.INT,
          Sk.ffi.PyType.LONG
        ];
      a.Graphics = Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, c) {
          Sk.ffi.checkMethodArgs('Graphics', arguments, 0, 1);
          Sk.ffi.isDefined(c) ? Sk.ffi.referenceToPy(Sk.ffi.remapToJs(c), 'Graphics', void 0, a) : Sk.ffi.referenceToPy(new b.Graphics(), 'Graphics', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'beginFill':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(d.beginFill, 'beginFill', void 0, a);
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c) {
                c = Sk.ffi.remapToJs(c);
                d.beginFill(c);
                return b;
              });
            }, 'beginFill', []));
          case 'beginStroke':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                Sk.ffi.referenceToPy(d.beginStroke, 'beginStroke', void 0, a);
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c) {
                c = Sk.ffi.remapToJs(c);
                d.beginStroke(c);
                return b;
              });
            }, 'beginStroke', []));
          case 'drawCircle':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'drawCircle';
                a.v = d.drawCircle;
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c, e, f) {
                c = Sk.ffi.remapToJs(c);
                e = Sk.ffi.remapToJs(e);
                f = Sk.ffi.remapToJs(f);
                d.drawCircle(c, e, f);
                return b;
              });
            }, 'drawCircle', []));
          case 'drawRect':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'drawRect';
                a.v = d.drawRect;
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c, e, f, g) {
                c = Sk.ffi.remapToJs(c);
                e = Sk.ffi.remapToJs(e);
                f = Sk.ffi.remapToJs(f);
                g = Sk.ffi.remapToJs(g);
                d.drawRect(c, e, f, g);
                return b;
              });
            }, 'drawRect', []));
          case 'drawRoundRect':
            return Sk.ffi.callableToPy(a, c, function (a, c, e, g, h, l) {
              Sk.ffi.checkMethodArgs('drawRoundRect', arguments, 5, 5);
              Sk.ffi.checkArgType('x', f, Sk.ffi.isNum(c), c);
              Sk.ffi.checkArgType('y', f, Sk.ffi.isNum(e), e);
              Sk.ffi.checkArgType('width', f, Sk.ffi.isNum(g), g);
              Sk.ffi.checkArgType('height', f, Sk.ffi.isNum(h), h);
              Sk.ffi.checkArgType('radius', f, Sk.ffi.isNum(l), l);
              var A = Sk.ffi.remapToJs(c), z = Sk.ffi.remapToJs(e), D = Sk.ffi.remapToJs(g), v = Sk.ffi.remapToJs(h), C = Sk.ffi.remapToJs(l);
              d.drawRoundRect(A, z, D, v, C);
              return b;
            });
          case 'endFill':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'endFill';
                a.v = d.endFill;
              });
              c.__call__ = Sk.ffi.functionPy(function (a) {
                d.endFill();
                return b;
              });
            }, 'endFill', []));
          case 'endStroke':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'endStroke';
                a.v = d.endStroke;
              });
              c.__call__ = Sk.ffi.functionPy(function (a) {
                d.endStroke();
                return b;
              });
            }, 'endStroke', []));
          case 'lineTo':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'lineTo';
                a.v = d.lineTo;
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c, e) {
                c = Sk.ffi.remapToJs(c);
                e = Sk.ffi.remapToJs(e);
                d.lineTo(c, e);
                return b;
              });
            }, 'lineTo', []));
          case 'moveTo':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'moveTo';
                a.v = d.moveTo;
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c, e) {
                c = Sk.ffi.remapToJs(c);
                e = Sk.ffi.remapToJs(e);
                d.moveTo(c, e);
                return b;
              });
            }, 'moveTo', []));
          case 'setStrokeStyle':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'setStrokeStyle';
                a.v = d.setStrokeStyle;
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c, e, f, g, h) {
                c = Sk.ffi.remapToJs(c);
                e = Sk.ffi.remapToJs(e);
                f = Sk.ffi.remapToJs(f);
                g = Sk.ffi.remapToJs(g);
                h = Sk.ffi.remapToJs(h);
                d.setStrokeStyle(c, e, f, g, h);
                return b;
              });
            }, 'setStrokeStyle', []));
          }
        });
      }, 'Graphics', []);
      a.MovieClip = Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, c, d, e, f) {
          c = null !== c ? Sk.ffi.remapToJs(c) : null;
          d = Sk.ffi.remapToJs(d);
          e = Sk.ffi.remapToJs(e);
          f = Sk.ffi.remapToJs(f);
          Sk.ffi.referenceToPy(new b.MovieClip(c, d, e, f), 'MovieClip', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'timeline':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'timeline';
                a.v = d.timeline;
              });
              c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
                var d = Sk.ffi.remapToJs(b);
                switch (c) {
                case 'addTween':
                  return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                    b.__init__ = Sk.ffi.functionPy(function (a) {
                      a.tp$name = 'addTween';
                      a.v = d.addTween;
                    });
                    b.__call__ = Sk.ffi.functionPy(function (a, b) {
                      var c = Sk.ffi.remapToJs(b);
                      d.addTween(c);
                    });
                  }, 'addTween', []));
                }
              });
            }, 'timeline', []));
          case 'gotoAndPlay':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'gotoAndPlay';
                a.v = d.gotoAndPlay;
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b) {
                var c = Sk.ffi.remapToJs(b);
                d.gotoAndPlay(c);
              });
            }, 'gotoAndPlay', []));
          }
        });
      }, 'MovieClip', []);
      a.Shape = Sk.ffi.buildClass(a, function (a, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, c) {
          Sk.ffi.checkMethodArgs('Shape', arguments, 0, 1);
          if (Sk.ffi.isUndefined(c))
            Sk.ffi.referenceToPy(new b.Shape(), 'Shape', void 0, a);
          else
            switch (Sk.ffi.checkArgType('graphics', 'Graphics', Sk.ffi.isInstance(c), c), Sk.ffi.typeName(c)) {
            case 'Shape':
              Sk.ffi.referenceToPy(Sk.ffi.remapToJs(c), 'Shape', void 0, a);
              break;
            case 'Graphics':
              Sk.ffi.referenceToPy(new b.Shape(Sk.ffi.remapToJs(c)), 'Shape', void 0, a);
              break;
            default:
              Sk.ffi.checkArgType('graphics', 'Graphics', !1, c);
            }
        });
        c.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          return d(a, b, 'Shape');
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return e(a, b, c, 'Shape');
        });
      }, 'Shape', []);
      a.Stage = Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, c) {
          Sk.ffi.checkMethodArgs('Stage', arguments, 1, 1);
          Sk.ffi.checkArgType('canvas', 'Node', Sk.ffi.isInstance(c, 'Node'), c);
          var d = Sk.ffi.remapToJs(c);
          Sk.ffi.referenceToPy(new b.Stage(d), 'Stage', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'mouseInBounds':
            return Sk.ffi.booleanToPy(d.mouseInBounds);
          case 'mouseMoveOutside':
            return Sk.ffi.booleanToPy(d.mouseMoveOutside);
          case 'mouseX':
            return Sk.ffi.numberToIntPy(d.mouseX);
          case 'mouseY':
            return Sk.ffi.numberToIntPy(d.mouseY);
          case 'addChild':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'addChild';
                a.v = d.addChild;
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b) {
                d.addChild(Sk.ffi.remapToJs(b));
                return b;
              });
            }, 'addChild', []));
          case 'enableMouseOver':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'enableMouseOver';
                a.v = d.enableMouseOver;
              });
              b.__call__ = Sk.ffi.functionPy(function (a) {
                d.enableMouseOver();
              });
            }, 'enableMouseOver', []));
          case 'render':
          case 'update':
            return Sk.ffi.callableToPy(a, c, function (a) {
              d.update();
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('Stage');
          }
        });
        d.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          c = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'autoClear':
            a.autoClear = c;
            break;
          case 'mouseMoveOutside':
            a.mouseMoveOutside = c;
            break;
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('Stage');
          }
        });
      }, 'Stage', []);
      a.Text = Sk.ffi.buildClass(a, function (c, f) {
        f.__init__ = Sk.ffi.functionPy(function (a, c, d, e) {
          Sk.ffi.checkArgType('text', Sk.ffi.PyType.STR, Sk.ffi.isStr(c), c);
          Sk.ffi.checkArgType('font', Sk.ffi.PyType.STR, Sk.ffi.isStr(d), d);
          c = Sk.ffi.remapToJs(c);
          d = Sk.ffi.remapToJs(d);
          e = Sk.ffi.remapToJs(e);
          Sk.ffi.referenceToPy(new b.Text(c, d, e), 'Text', void 0, a);
        });
        f.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var e = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'text':
            return Sk.ffi.stringToPy(e.text);
          case 'textAlign':
            return Sk.ffi.stringToPy(e.textAlign);
          case 'getMeasuredWidth':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'getMeasuredWidth';
                a.v = e.getMeasuredWidth;
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b) {
                return Sk.builtin.assk$(e.getMeasuredWidth(), Sk.builtin.nmber.float$);
              });
            }, 'getMeasuredWidth', []));
          case 'getMeasuredHeight':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'getMeasuredHeight';
                a.v = e.getMeasuredHeight;
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b) {
                return Sk.builtin.assk$(e.getMeasuredHeight(), Sk.builtin.nmber.float$);
              });
            }, 'getMeasuredHeight', []));
          default:
            return d(b, c, 'Text');
          }
        });
        f.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          var d = Sk.ffi.remapToJs(a), f = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'hitArea':
            d.hitArea = f;
            break;
          case 'text':
            d.text = Sk.ffi.remapToJs(Sk.ffi.isStr(c) ? c : Sk.ffh.str(c));
            break;
          case 'textAlign':
            d.textAlign = f;
            break;
          default:
            return e(a, b, c, 'Text');
          }
        });
        f.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('Text(' + a.x + ', ' + a.y + ')');
        });
        f.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('[' + a.x + ', ' + a.y + ']');
        });
      }, 'Text', []);
      a.Ticker = Sk.ffi.callsim(Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a) {
          a.tp$name = 'Ticker';
          a.v = b.Ticker;
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'addEventListener':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'addEventListener';
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b, c, e) {
                a = Sk.ffi.remapToJs(b);
                b = Sk.ffi.remapToJs(c);
                'object' !== typeof b && (b = function (a) {
                  Sk.ffi.callsim(c);
                });
                d.addEventListener(a, b, e);
              });
            }, 'addEventListener', []));
          }
        });
      }, 'Ticker', []));
      a.Tween = Sk.ffi.callsim(Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a) {
          a.tp$name = 'Tween';
          a.v = b.Tween;
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'get':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'get';
              });
              c.__call__ = Sk.ffi.functionPy(function (b, c, e, f, g) {
                c = Sk.ffi.remapToJs(c);
                e = Sk.ffi.remapToJs(e);
                f = Sk.ffi.remapToJs(f);
                g = Sk.ffi.remapToJs(g);
                var h = d.get(c, e, f, g);
                return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
                  c.__init__ = Sk.ffi.functionPy(function (a) {
                    a.tp$name = 'Tween';
                    a.v = h;
                  });
                  c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
                    var d = Sk.ffi.remapToJs(b);
                    switch (c) {
                    case 'to':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
                        c.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'to';
                        });
                        c.__call__ = Sk.ffi.functionPy(function (a, c, e, f) {
                          c = Sk.ffi.remapToJs(c);
                          e = Sk.ffi.remapToJs(e);
                          f = Sk.ffi.remapToJs(f);
                          d.to(c, e, f);
                          return b;
                        });
                      }, 'to', []));
                    case 'onComplete':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
                        c.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'onComplete';
                        });
                        c.__call__ = Sk.ffi.functionPy(function (a, c, e) {
                          a = Sk.ffi.remapToJs(e);
                          d.call(function (a) {
                            Sk.ffi.callsim(c, Sk.ffi.remapToPy(a));
                          }, a);
                          return b;
                        });
                      }, 'onComplete', []));
                    case 'wait':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
                        c.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'wait';
                        });
                        c.__call__ = Sk.ffi.functionPy(function (a, c) {
                          c = Sk.ffi.remapToJs(c);
                          d.wait(c);
                          return b;
                        });
                      }, 'wait', []));
                    }
                  });
                }, 'Tween', []));
              });
            }, 'get', []));
          }
        });
      }, 'Tween', []));
      a.Container = Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, c) {
          Sk.ffi.isUndefined(c) ? Sk.ffi.referenceToPy(new b.Container(), 'Container', void 0, a) : Sk.ffi.referenceToPy(Sk.ffi.remapToJs(c), 'Container', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'name':
            return Sk.ffi.stringToPy(d.name);
          case 'x':
            return Sk.builtin.assk$(d.x, Sk.builtin.nmber.float$);
          case 'y':
            return Sk.builtin.assk$(d.y, Sk.builtin.nmber.float$);
          case 'rotation':
            return Sk.builtin.assk$(d.rotation, Sk.builtin.nmber.float$);
          case 'addChild':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'addChild';
                a.v = d.addChild;
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b) {
                d.addChild(Sk.ffi.remapToJs(b));
                return b;
              });
            }, 'addChild', []));
          case 'addEventListener':
            return Sk.builtin.addEventListener(a, d);
          case 'getChildAt':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'getChildAt';
                a.v = d.getChildAt;
              });
              c.__call__ = Sk.ffi.functionPy(function (b, c) {
                var e = d.getChildAt(Sk.ffi.remapToJs(c));
                return Sk.ffi.callsim(a.Shape, Sk.ffi.referenceToPy(e, 'Shape'));
              });
            }, 'getChildAt', []));
          case 'getNumChildren':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'getNumChildren';
                a.v = d.getNumChildren;
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b) {
                return Sk.builtin.assk$(d.getNumChildren(), Sk.builtin.nmber.int$);
              });
            }, 'getNumChildren', []));
          case 'removeEventListener':
            return Sk.builtin.removeEventListener(a, d);
          }
        });
        d.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          c = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'name':
            a.name = c;
            break;
          case 'x':
            a.x = c;
            break;
          case 'y':
            a.y = c;
            break;
          case 'rotation':
            a.rotation = c;
            break;
          default:
            throw new Sk.builtin.AttributeError(b + ' is not a writeable attribute of Container');
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('Container(' + a.x + ', ' + a.y + ')');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('[' + a.x + ', ' + a.y + ']');
        });
      }, 'Container', []);
      a.Ease = Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
        c.__init__ = Sk.ffi.functionPy(function (a) {
          a.tp$name = 'Ease';
          a.v = b.Ease;
        });
        c.__getattr__ = Sk.ffi.functionPy(function (a, c) {
          switch (c) {
          case 'bounceOut':
            return { v: b.Ease.bounceOut };
          }
        });
      }, 'Ease', []));
      a.Point = Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, c, d) {
          Sk.builtin.pyCheckArgs('Point', arguments, 1, 3);
          a.tp$name = 'Point';
          switch (arguments.length) {
          case 1:
            a.v = new b.Point();
            break;
          case 2:
            c = Sk.ffi.remapToJs(c);
            a.tp$name = 'Point';
            a.v = c;
            break;
          case 3:
            Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(c)), Sk.builtin.pyCheckType('y', 'number', Sk.builtin.checkNumber(d)), c = Sk.ffi.remapToJs(c), d = Sk.ffi.remapToJs(d), a.tp$name = 'Point', a.v = new b.Point(c, d);
          }
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'x':
            return Sk.ffi.numberToFloatPy(d.x);
          case 'y':
            return Sk.ffi.numberToFloatPy(d.y);
          case 'clone':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'clone';
              });
              c.__call__ = Sk.ffi.functionPy(function (b) {
                return Sk.ffi.callsim(a.Point, Sk.ffi.numberToFloatPy(d.x), Sk.ffi.numberToFloatPy(d.y));
              });
            }, 'clone', []));
          }
        });
        d.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          c = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'x':
            a.x = c;
            break;
          case 'y':
            a.y = c;
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('Point(' + a.x + ', ' + a.y + ')');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('[' + a.x + ', ' + a.y + ']');
        });
      }, 'Point', []);
      a.getHSL = Sk.ffi.functionPy(function (a, c, d, e) {
        a = Sk.ffi.remapToJs(a);
        c = Sk.ffi.remapToJs(c);
        d = Sk.ffi.remapToJs(d);
        e = Sk.ffi.remapToJs(e);
        return Sk.ffi.stringToPy(b.Graphics.getHSL(a, c, d, e));
      });
    };
  }.call(this));
  Sk.builtin.defineEvent = function (a) {
    a.Event = Sk.ffi.buildClass(a, function (b, c) {
      c.__init__ = Sk.ffi.functionPy(function (a, b) {
        Sk.ffi.referenceToPy(Sk.ffi.remapToJs(b), 'Event', void 0, a);
      });
      c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
        var f = Sk.ffi.remapToJs(b);
        switch (c) {
        case 'altKey':
          return Sk.ffi.booleanToPy(f.altKey);
        case 'bubbles':
          return Sk.ffi.booleanToPy(f.bubbles);
        case 'button':
          return Sk.ffi.numberToIntPy(f.button);
        case 'cancelable':
          return Sk.ffi.booleanToPy(f.cancelable);
        case 'clientX':
          return Sk.ffi.numberToIntPy(f.clientX);
        case 'clientY':
          return Sk.ffi.numberToIntPy(f.clientY);
        case 'ctrlKey':
          return Sk.ffi.booleanToPy(f.ctrlKey);
        case 'defaultPrevented':
          return Sk.ffi.booleanToPy(f.defaultPrevented);
        case 'keyCode':
          return Sk.ffi.numberToIntPy(f.keyCode);
        case 'screenX':
          return Sk.ffi.numberToIntPy(f.screenX);
        case 'screenY':
          return Sk.ffi.numberToIntPy(f.screenY);
        case 'shiftKey':
          return Sk.ffi.booleanToPy(f.shiftKey);
        case 'target':
          return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
            b.__init__ = Sk.ffi.functionPy(function (a) {
              Sk.ffi.referenceToPy(f.target, 'target', void 0, a);
            });
            b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
              return Sk.ffi.remapToPy(f.target[b], '');
            });
            b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
              f.target[b] = Sk.ffi.remapToJs(c);
            });
            b.__str__ = Sk.ffi.functionPy(function (a) {
              a = Sk.ffi.remapToJs(a);
              return Sk.ffi.stringToPy('' + a);
            });
            b.__repr__ = Sk.ffi.functionPy(function (a) {
              a = Sk.ffi.remapToJs(a);
              return Sk.ffi.stringToPy('' + a);
            });
          }, 'target', []));
        case 'type':
          return Sk.ffi.stringToPy(f.type);
        case 'addEventListener':
          return Sk.builtin.addEventListener(a, f);
        case 'preventDefault':
          return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
            b.__init__ = Sk.ffi.functionPy(function (a) {
              a.tp$name = 'preventDefault';
            });
            b.__call__ = Sk.ffi.functionPy(function (a) {
              f.preventDefault();
            });
            b.__str__ = Sk.ffi.functionPy(function (a) {
              return Sk.ffi.stringToPy('preventDefault');
            });
            b.__repr__ = Sk.ffi.functionPy(function (a) {
              return Sk.ffi.stringToPy('preventDefault');
            });
          }, 'preventDefault', []));
        case 'stopImmediatePropagation':
          return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
            b.__init__ = Sk.ffi.functionPy(function (a) {
              a.tp$name = 'stopImmediatePropagation';
            });
            b.__call__ = Sk.ffi.functionPy(function (a) {
              f.stopImmediatePropagation();
            });
            b.__str__ = Sk.ffi.functionPy(function (a) {
              return Sk.ffi.stringToPy('stopImmediatePropagation');
            });
            b.__repr__ = Sk.ffi.functionPy(function (a) {
              return Sk.ffi.stringToPy('stopImmediatePropagation');
            });
          }, 'stopImmediatePropagation', []));
        case 'stopPropagation':
          return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
            b.__init__ = Sk.ffi.functionPy(function (a) {
              a.tp$name = 'stopPropagation';
            });
            b.__call__ = Sk.ffi.functionPy(function (a) {
              f.stopPropagation();
            });
            b.__str__ = Sk.ffi.functionPy(function (a) {
              return Sk.ffi.stringToPy('stopPropagation');
            });
            b.__repr__ = Sk.ffi.functionPy(function (a) {
              return Sk.ffi.stringToPy('stopPropagation');
            });
          }, 'stopPropagation', []));
        default:
          return Sk.ffi.remapToPy(f[c], '');
        }
      });
      c.__str__ = Sk.ffi.functionPy(function (a) {
        a = Sk.ffi.remapToJs(a);
        return Sk.ffi.stringToPy('' + a);
      });
      c.__repr__ = Sk.ffi.functionPy(function (a) {
        a = Sk.ffi.remapToJs(a);
        return Sk.ffi.stringToPy('' + a);
      });
    }, 'Event', []);
  };
  Sk.builtin.addEventListener = function (a, b) {
    return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (c, d) {
      d.__init__ = Sk.ffi.functionPy(function (a) {
        Sk.ffi.referenceToPy(b.addEventListener, 'addEventListener', void 0, a);
      });
      d.__call__ = Sk.ffi.functionPy(function (c, d, g, h) {
        c = Sk.ffi.remapToJs(d);
        h = Sk.ffi.remapToJs(h);
        b.addEventListener(c, function (b) {
          b = Sk.ffi.callsim(a.Event, Sk.ffi.referenceToPy(b, 'Event'));
          Sk.ffi.callsim(g, b);
        }, h);
      });
    }, 'addEventListener', []));
  };
  Sk.builtin.removeEventListener = function (a, b) {
    return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (c, d) {
      d.__init__ = Sk.ffi.functionPy(function (a) {
        Sk.ffi.referenceToPy(b.removeEventListener, 'removeEventListener', void 0, a);
      });
      d.__call__ = Sk.ffi.functionPy(function (c, d, g, h) {
        c = Sk.ffi.remapToJs(d);
        h = Sk.ffi.remapToJs(h);
        b.removeEventListener(c, function (b) {
          b = Sk.ffi.callsim(a.Event, Sk.ffi.referenceToPy(b, 'Event'));
          Sk.ffi.callsim(g, b);
        }, h);
      });
    }, 'removeEventListener', []));
  };
  Sk.geometry = Sk.geometry || {};
  Sk.geometry.ARROW_BUILDER = 'ArrowBuilder';
  Sk.geometry.CYLINDER_BUILDER = 'CylinderBuilder';
  Sk.geometry.VORTEX_BUILDER = 'VortexBuilder';
  Sk.geometry.VOLUME_BUILDER = 'VolumeBuilder';
  Sk.geometry.VOLUME = 'Volume';
  (function () {
    Sk.builtin.defineGeometry = function (a, b, c) {
      function d(b) {
        var c = Sk.ffi.remapToJs(b);
        return Sk.ffi.callableToPy(a, 'name', function (a, d) {
          Sk.ffi.checkMethodArgs('name', arguments, 1, 1);
          Sk.ffi.checkArgType('name', Sk.ffi.PyType.STR, Sk.ffi.isStr(d), d);
          c.name = Sk.ffi.remapToJs(d);
          return b;
        });
      }
      function e(b) {
        if (b.material)
          return b.material;
        var c = {};
        c.color = 'undefined' !== typeof b.color ? b.color : 16777215;
        'undefined' !== typeof b.wireframeLinewidth && (c.wireframeLinewidth = b.wireframeLinewidth);
        if ('undefined' !== typeof b.wireframe)
          return (c.wireframe = b.wireframe) ? Sk.ffi.callsim(a.MeshBasicMaterial, Sk.ffi.remapToPy(c)) : Sk.ffi.callsim(a.MeshLambertMaterial, Sk.ffi.remapToPy(c));
        c.wireframe = !1;
        return Sk.ffi.callsim(a.MeshLambertMaterial, Sk.ffi.remapToPy(c));
      }
      function f(b, c) {
        function d(a) {
          var b = Sk.ffi.remapToJs(a);
          c.name && (b.name = c.name);
          return a;
        }
        if (c.material)
          return d(Sk.ffi.callsim(a.Mesh, b, c.material));
        var e = {};
        e.color = 'undefined' !== typeof c.color ? c.color : 16777215;
        'undefined' !== typeof c.wireframeLinewidth && (e.wireframeLinewidth = c.wireframeLinewidth);
        'undefined' !== typeof c.wireframe ? e = (e.wireframe = c.wireframe) ? Sk.ffi.callsim(a.MeshBasicMaterial, Sk.ffi.remapToPy(e)) : Sk.ffi.callsim(a.MeshLambertMaterial, Sk.ffi.remapToPy(e)) : (e.wireframe = !1, e = Sk.ffi.callsim(a.MeshLambertMaterial, Sk.ffi.remapToPy(e)));
        return d(Sk.ffi.callsim(a.Mesh, b, e));
      }
      function g(a) {
        a = [
          [
            +a,
            0,
            0
          ],
          [
            0,
            +a,
            0
          ],
          [
            0,
            0,
            +a
          ],
          [
            -a,
            0,
            0
          ],
          [
            0,
            -a,
            0
          ],
          [
            0,
            0,
            -a
          ]
        ].map(function (a) {
          var c = new b.Geometry();
          c.vertices.push(new b.Vector3(0, 0, 0));
          c.vertices.push(new b.Vector3(a[0], a[1], a[2]));
          return c;
        });
        var c = new b[Sk.three.OBJECT_3D]();
        c.add(new b.Line(a[0], new b.LineBasicMaterial({
          color: 16711680,
          opacity: 0.5,
          transparent: !0
        })));
        c.add(new b.Line(a[1], new b.LineBasicMaterial({
          color: 65280,
          opacity: 0.5,
          transparent: !0
        })));
        c.add(new b.Line(a[2], new b.LineBasicMaterial({
          color: 255,
          opacity: 0.5,
          transparent: !0
        })));
        c.add(new b.Line(a[3], new b.LineBasicMaterial({
          color: 16711680,
          opacity: 0.2,
          transparent: !0
        })));
        c.add(new b.Line(a[4], new b.LineBasicMaterial({
          color: 65280,
          opacity: 0.2,
          transparent: !0
        })));
        c.add(new b.Line(a[5], new b.LineBasicMaterial({
          color: 255,
          opacity: 0.2,
          transparent: !0
        })));
        return c;
      }
      function h(a, c, d, e, f) {
        var g = new b[Sk.three.OBJECT_3D](), h = a * c, l = d / c, p = a * d;
        a = f.x * p;
        d = f.y * p;
        f = f.z * p;
        for (p = -h; p <= h; p += 1)
          if (0 != p) {
            var k = p * l, q = new b.Geometry();
            q.vertices.push(new b.Vector3(e.x * k - a, e.y * k - d, e.z * k - f));
            q.vertices.push(new b.Vector3(e.x * k + a, e.y * k + d, e.z * k + f));
            k = new b.Line(q, 0 === p % c ? m : n);
            g.add(k);
          }
        return g;
      }
      function k(b, c, e) {
        var f = Sk.ffi.remapToJs(b);
        switch (c) {
        case 'attitude':
          return Sk.ffi.callableToPy(a, c, function (a, d) {
            Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
            Sk.ffi.checkArgType(c, 'Euclidean3', Sk.ffi.isInstance(d, 'Euclidean3'), d);
            f[c] = Sk.ffi.remapToJs(d);
            return b;
          });
        case 'color':
          return Sk.ffi.callableToPy(a, c, function (a, d) {
            Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
            Sk.ffi.checkArgType(c, l, Sk.ffi.isNum(d) || Sk.ffi.isStr(d) || Sk.ffi.isInstance(d, 'Color'), d);
            f[c] = Sk.ffi.remapToJs(d);
            return b;
          });
        case 'material':
          return Sk.ffi.callableToPy(a, 'material', function (a, c) {
            Sk.ffi.checkMethodArgs('material', arguments, 1, 1);
            Sk.ffi.checkArgType('material', Sk.three.MATERIAL, Sk.ffi.isInstance(c), c);
            f.material = c;
            return b;
          });
        case 'name':
          return d(b);
        case 'scale':
          return Sk.ffi.callableToPy(a, 'scale', function (a, c) {
            Sk.ffi.checkMethodArgs('scale', arguments, 1, 1);
            Sk.ffi.checkArgType('scale', [
              l,
              Sk.ffi.PyType.NONE
            ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
            f.scale = Sk.ffi.remapToJs(c);
            return b;
          });
        case 'volume':
          return Sk.ffi.callableToPy(a, 'volume', function (a, c) {
            Sk.ffi.checkMethodArgs('volume', arguments, 1, 1);
            Sk.ffi.checkArgType('volume', l, Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
            f.volume = Sk.ffi.remapToJs(c);
            return b;
          });
        case 'wireframe':
          return Sk.ffi.callableToPy(a, c, function (a, d) {
            Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
            Sk.ffi.checkArgType(c, Sk.ffi.PyType.BOOL, Sk.ffi.isBool(d), d);
            f[c] = Sk.ffi.remapToJs(d);
            return b;
          });
        case 'wireframeLinewidth':
          return Sk.ffi.callableToPy(a, c, function (a, d) {
            Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
            Sk.ffi.checkArgType(c, Sk.ffi.PyType.INT, Sk.ffi.isInt(d), d);
            f[c] = Sk.ffi.remapToJs(d);
            return b;
          });
        default:
          throw Sk.ffi.err.attribute(c).isNotGetableOnType(e);
        }
      }
      Sk.ffi.checkFunctionArgs('defineGeometry', arguments, 3, 3);
      var l = [
          Sk.ffi.PyType.FLOAT,
          Sk.ffi.PyType.INT,
          Sk.ffi.PyType.LONG
        ], m = new b.LineBasicMaterial({
          color: 6726098,
          opacity: 0.2,
          transparent: !0
        }), n = new b.LineBasicMaterial({
          color: 6726098,
          opacity: 0.02,
          transparent: !0
        }), p = new b.Vector3(1, 0, 0), q = new b.Vector3(0, 1, 0);
      new b.Vector3(0, 0, 1);
      var s = new b.Euclidean3(new b.Vector3(0, 0, 1), new b.Quaternion(0, 0, 0, 0), 0, !1), r = new b.Euclidean3(new b.Vector3(0, 0, 0), new b.Quaternion(0, 0, 0, 1), 0, !1);
      a.world = Sk.ffi.functionPy(function () {
        Sk.ffi.checkFunctionArgs('world', arguments, 0, 0);
        var c = Sk.ffi.callsim(a.Scene), d = Sk.ffi.remapToJs(c), e = new b.PointLight(16777215);
        e.position.set(5, 5, 5);
        d.add(e);
        d.add(new b.AmbientLight(2236962));
        return c;
      });
      a.CartesianSpace = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (b, c, d) {
          var e, f;
          Sk.ffi.checkMethodArgs('CartesianSpace', arguments, 0, 2);
          Sk.ffi.isDefined(c) ? Sk.ffi.checkArgType('scene', 'Scene', Sk.ffi.isInstance(c, 'Scene'), c) : c = Sk.ffi.callsim(a.world);
          e = Sk.ffi.remapToJs(c);
          Sk.ffi.isDefined(d) ? Sk.ffi.checkArgType('renderer', [
            'CanvasRenderer',
            'WebGLRenderer'
          ], Sk.ffi.isInstance(d, 'WebGLRenderer') || Sk.ffi.isInstance(d, 'CanvasRenderer'), d) : d = Sk.ffi.callsim(a.WebGLRenderer, Sk.ffi.remapToPy({ antialias: !0 }));
          f = Sk.ffi.remapToJs(d);
          var n = Sk.ffi.callsim(a.PerspectiveCamera, Sk.ffi.numberToFloatPy(45), Sk.ffi.numberToFloatPy(1), Sk.ffi.numberToFloatPy(0.1), Sk.ffi.numberToFloatPy(10000)), l = Sk.ffi.remapToJs(n);
          l.up.set(0, 0, 1);
          l.position.set(8, 4, 5);
          l.lookAt(e.position);
          f.setClearColor(526344, 1);
          e.add(g(1000));
          e.add(h(5, 10, 1, p, q));
          e.add(h(5, 10, 1, q, p));
          Sk.ffi.referenceToPy({
            scenePy: c,
            cameraPy: n,
            rendererPy: d
          }, 'CartesianSpace', void 0, b);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'camera':
            return d.cameraPy;
          case 'origin':
            return Sk.ffi.gattr(d.scenePy, 'position');
          case 'renderer':
            return d.rendererPy;
          case 'scene':
            return d.scenePy;
          case 'add':
            return Sk.ffi.gattr(d.scenePy, 'add');
          case 'render':
            return Sk.ffi.callableToPy(a, 'render', function (a) {
              a = Sk.ffi.gattr(d.rendererPy, 'render');
              return Sk.ffi.callsim(a, d.scenePy, d.cameraPy);
            });
          case 'viewSize':
            return Sk.ffi.callableToPy(a, 'render', function (a, b, c) {
              Sk.ffi.checkMethodArgs('viewSize', arguments, 2, 2);
              Sk.ffi.checkArgType('width', Sk.ffi.PyType.INT, Sk.ffi.isInt(b), b);
              Sk.ffi.checkArgType('height', Sk.ffi.PyType.INT, Sk.ffi.isInt(c), c);
              var e = Sk.ffi.remapToJs(b), f = Sk.ffi.remapToJs(c);
              Sk.ffi.remapToJs(d.rendererPy).setSize(e, f);
              var g = Sk.ffi.remapToJs(d.cameraPy);
              g.aspect = e / f;
              g.updateProjectionMatrix();
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('CartesianSpace');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('CartesianSpace');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('CartesianSpace');
        });
      }, 'CartesianSpace', []);
      Sk.geometry.ArrowBuilder = function () {
        this._innerPy = Sk.ffi.callsim(a[Sk.geometry.ARROW_BUILDER]);
      };
      Sk.geometry.ArrowBuilder.prototype = {
        constructor: Sk.geometry.ArrowBuilder,
        axis: function (b, c, d) {
          b = Sk.ffi.numberToFloatPy(b);
          c = Sk.ffi.numberToFloatPy(c);
          d = Sk.ffi.numberToFloatPy(d);
          d = Sk.ffi.callsim(a[Sk.e3ga.VECTOR_E3], b, c, d);
          Sk.ffi.callsim(Sk.ffi.gattr(this._innerPy, 'axis'), d);
          return this;
        },
        material: function (b) {
          b = Sk.ffi.callsim(a[Sk.three.MATERIAL], Sk.ffi.referenceToPy(b, Sk.three.MATERIAL));
          Sk.ffi.callsim(Sk.ffi.gattr(this._innerPy, 'material'), b);
          return this;
        },
        radius: function (a) {
          a = Sk.ffi.numberToFloatPy(a);
          Sk.ffi.callsim(Sk.ffi.gattr(this._innerPy, 'radius'), a);
          return this;
        },
        build: function () {
          return Sk.ffi.remapToJs(Sk.ffi.callsim(Sk.ffi.gattr(this._innerPy, 'build')));
        }
      };
      a[Sk.geometry.ARROW_BUILDER] = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs(Sk.geometry.ARROW_BUILDER, arguments, 0, 0);
          Sk.ffi.referenceToPy({}, Sk.geometry.ARROW_BUILDER, void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'magnitude':
            return Sk.ffi.callableToPy(a, 'magnitude', function (a, c) {
              Sk.ffi.checkMethodArgs('magnitude', arguments, 1, 1);
              Sk.ffi.checkArgType('magnitude', [
                l,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.magnitude = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'axis':
            return Sk.ffi.callableToPy(a, 'axis', function (a, c) {
              Sk.ffi.checkMethodArgs('axis', arguments, 1, 1);
              Sk.ffi.checkArgType('axis', [
                'Euclidean3',
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isInstance(c, 'Euclidean3') || Sk.ffi.isNone(c), c);
              d.axis = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'radius':
            return Sk.ffi.callableToPy(a, 'radius', function (a, c) {
              Sk.ffi.checkMethodArgs('radius', arguments, 1, 1);
              Sk.ffi.checkArgType('radius', [
                l,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.radius = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'segments':
            return Sk.ffi.callableToPy(a, 'segments', function (a, c) {
              Sk.ffi.checkMethodArgs('segments', arguments, 1, 1);
              Sk.ffi.checkArgType('segments', [
                Sk.ffi.PyType.INT,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isInt(c) || Sk.ffi.isNone(c), c);
              d.segments = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'build':
            return Sk.ffi.callableToPy(a, 'build', function (b) {
              Sk.ffi.checkMethodArgs('build', arguments, 0, 0);
              var c, e = {};
              e.attitude = d.attitude ? d.attitude : r;
              e.axis = d.axis ? d.axis : s;
              if (d.volume) {
                var g = (d.radius ? d.radius : 0.5) / (d.length ? d.length : 1);
                e.radius = Math.pow(3 * g * d.volume / Math.PI, 1 / 3);
                e.length = e.radius / g;
              } else
                e.scale = d.scale ? d.scale : 1, e.radius = d.radius ? d.radius : 0.5, e.length = d.length ? d.length : 1;
              c = e;
              var e = Sk.ffi.numberToFloatPy(c.scale), g = Sk.ffi.callsim(a.Euclidean3, Sk.ffi.referenceToPy(c.attitude, 'Euclidean3')), h = Sk.ffi.numberToIntPy(d.segments ? d.segments : 32), n = Sk.ffi.numberToFloatPy(c.magnitude);
              c = Sk.ffi.callsim(a.Euclidean3, Sk.ffi.referenceToPy(c.axis, 'Euclidean3'));
              e = Sk.ffi.callsim(a[Sk.three.ARROW_GEOMETRY], e, g, h, n, void 0, void 0, void 0, c);
              return f(e, d);
            });
          case 'normalize':
            return Sk.ffi.callableToPy(a, 'normalize', function (a) {
              Sk.ffi.checkMethodArgs('normalize', arguments, 0, 0);
              return b;
            });
          default:
            return k(b, c, Sk.geometry.ARROW_BUILDER);
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('' + a);
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy(Sk.geometry.ARROW_BUILDER + '()');
        });
      }, Sk.geometry.ARROW_BUILDER, []);
      a.ConeBuilder = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('ConeBuilder', arguments, 0, 0);
          Sk.ffi.referenceToPy({}, 'ConeBuilder', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'height':
            return Sk.ffi.callableToPy(a, 'height', function (a, c) {
              Sk.ffi.checkMethodArgs('height', arguments, 1, 1);
              Sk.ffi.checkArgType('height', [
                l,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.height = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'radius':
            return Sk.ffi.callableToPy(a, 'radius', function (a, c) {
              Sk.ffi.checkMethodArgs('radius', arguments, 1, 1);
              Sk.ffi.checkArgType('radius', [
                l,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.radius = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'segments':
            return Sk.ffi.callableToPy(a, 'segments', function (a, c) {
              Sk.ffi.checkMethodArgs('segments', arguments, 1, 1);
              Sk.ffi.checkArgType('segments', [
                Sk.ffi.PyType.INT,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isInt(c) || Sk.ffi.isNone(c), c);
              d.segments = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'build':
            return Sk.ffi.callableToPy(a, 'build', function (b) {
              Sk.ffi.checkMethodArgs('build', arguments, 0, 0);
              var c, e = {};
              if (d.volume) {
                var g = (d.radius ? d.radius : 0.5) / (d.height ? d.height : 1);
                e.radius = Math.pow(3 * g * d.volume / Math.PI, 1 / 3);
                e.height = e.radius / g;
              } else
                e.radius = d.radius ? d.radius : 0.5, e.height = d.height ? d.height : 1;
              c = e;
              e = Sk.ffi.numberToFloatPy(0);
              g = Sk.ffi.numberToFloatPy(c.radius);
              c = Sk.ffi.numberToFloatPy(c.height);
              var h = Sk.ffi.numberToIntPy(d.segments ? d.segments : 32), n = Sk.ffi.numberToIntPy(1), l = Sk.ffi.booleanToPy(!1), e = Sk.ffi.callsim(a.CylinderGeometry, e, g, c, h, n, l);
              return f(e, d);
            });
          case 'normalize':
            return Sk.ffi.callableToPy(a, 'normalize', function (a) {
              Sk.ffi.checkMethodArgs('normalize', arguments, 0, 0);
              return b;
            });
          default:
            return k(b, c, 'ConeBuilder');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('' + a);
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('ConeBuilder()');
        });
      }, 'ConeBuilder', []);
      a.CubeBuilder = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('CubeBuilder', arguments, 0, 0);
          Sk.ffi.referenceToPy({}, 'CubeBuilder', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'depth':
            return Sk.ffi.callableToPy(a, 'depth', function (a, c) {
              Sk.ffi.checkMethodArgs('depth', arguments, 1, 1);
              Sk.ffi.checkArgType('depth', [
                l,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.depth = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'height':
            return Sk.ffi.callableToPy(a, 'height', function (a, c) {
              Sk.ffi.checkMethodArgs('height', arguments, 1, 1);
              Sk.ffi.checkArgType('height', [
                l,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.height = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'width':
            return Sk.ffi.callableToPy(a, 'width', function (a, c) {
              Sk.ffi.checkMethodArgs('width', arguments, 1, 1);
              Sk.ffi.checkArgType('width', [
                l,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.width = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'segments':
            return Sk.ffi.callableToPy(a, 'segments', function (a, c) {
              Sk.ffi.checkMethodArgs('segments', arguments, 1, 1);
              Sk.ffi.checkArgType('segments', [
                Sk.ffi.PyType.INT,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isInt(c) || Sk.ffi.isNone(c), c);
              d.segments = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'build':
            return Sk.ffi.callableToPy(a, 'build', function (b) {
              Sk.ffi.checkMethodArgs('build', arguments, 0, 0);
              var c, e = {};
              if (d.volume) {
                var g = d.width ? d.width : 1;
                c = d.height ? d.height : 1;
                var h = d.depth ? d.depth : 1, n = Math.pow(d.volume / (g * c * h), 1 / 3);
                e.width = n * g;
                e.height = n * c;
                e.depth = n * h;
              } else
                e.width = d.width ? d.width : 1, e.height = d.height ? d.height : 1, e.depth = d.depth ? d.depth : 1;
              c = e;
              e = Sk.ffi.numberToFloatPy(c.width);
              g = Sk.ffi.numberToFloatPy(c.height);
              c = Sk.ffi.numberToFloatPy(c.depth);
              h = Sk.ffi.numberToIntPy(d.segments ? d.segments : 1);
              e = Sk.ffi.callsim(a.CubeGeometry, e, g, c, h, h, h);
              return f(e, d);
            });
          case 'normalize':
            return Sk.ffi.callableToPy(a, 'normalize', function (a) {
              Sk.ffi.checkMethodArgs('normalize', arguments, 0, 0);
              d.depth = 1;
              d.width = 1;
              d.height = 1;
              return b;
            });
          default:
            return k(b, c, 'CubeBuilder');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('' + a);
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('CubeBuilder()');
        });
      }, 'CubeBuilder', []);
      Sk.geometry.CylinderBuilder = function () {
        this._innerPy = Sk.ffi.callsim(a[Sk.geometry.CYLINDER_BUILDER]);
      };
      Sk.geometry.CylinderBuilder.prototype = {
        constructor: Sk.geometry.CylinderBuilder,
        axis: function (b, c, d) {
          b = Sk.ffi.numberToFloatPy(b);
          c = Sk.ffi.numberToFloatPy(c);
          d = Sk.ffi.numberToFloatPy(d);
          d = Sk.ffi.callsim(a[Sk.e3ga.VECTOR_E3], b, c, d);
          Sk.ffi.callsim(Sk.ffi.gattr(this._innerPy, 'axis'), d);
          return this;
        },
        material: function (b) {
          b = Sk.ffi.callsim(a[Sk.three.MATERIAL], Sk.ffi.referenceToPy(b, Sk.three.MATERIAL));
          Sk.ffi.callsim(Sk.ffi.gattr(this._innerPy, 'material'), b);
          return this;
        },
        radius: function (a) {
          a = Sk.ffi.numberToFloatPy(a);
          Sk.ffi.callsim(Sk.ffi.gattr(this._innerPy, 'radius'), a);
          return this;
        },
        build: function () {
          return Sk.ffi.remapToJs(Sk.ffi.callsim(Sk.ffi.gattr(this._innerPy, 'build')));
        }
      };
      a[Sk.geometry.CYLINDER_BUILDER] = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs(Sk.geometry.CYLINDER_BUILDER, arguments, 0, 0);
          Sk.ffi.referenceToPy({
            radiusTop: 0.5,
            radiusBottom: 0.5,
            height: 1
          }, Sk.geometry.CYLINDER_BUILDER, void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'axis':
            return Sk.ffi.callableToPy(a, 'axis', function (a, c) {
              Sk.ffi.checkMethodArgs('axis', arguments, 1, 1);
              Sk.ffi.checkArgType('axis', [
                'Euclidean3',
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isInstance(c, 'Euclidean3') || Sk.ffi.isNone(c), c);
              d.axis = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'height':
            return Sk.ffi.callableToPy(a, 'height', function (a, c) {
              Sk.ffi.checkMethodArgs('height', arguments, 1, 1);
              Sk.ffi.checkArgType('height', [
                l,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.height = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'radius':
            return Sk.ffi.callableToPy(a, 'radius', function (a, c) {
              Sk.ffi.checkMethodArgs('radius', arguments, 1, 1);
              Sk.ffi.checkArgType('radius', [
                l,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.radiusTop = Sk.ffi.remapToJs(c);
              d.radiusBottom = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'radiusTop':
            return Sk.ffi.callableToPy(a, 'radiusTop', function (a, c) {
              Sk.ffi.checkMethodArgs('radiusTop', arguments, 1, 1);
              Sk.ffi.checkArgType('radiusTop', [
                l,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.radiusTop = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'radiusBottom':
            return Sk.ffi.callableToPy(a, 'radiusBottom', function (a, c) {
              Sk.ffi.checkMethodArgs('radiusBottom', arguments, 1, 1);
              Sk.ffi.checkArgType('radiusBottom', [
                l,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.radiusBottom = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'segments':
            return Sk.ffi.callableToPy(a, 'segments', function (a, c) {
              Sk.ffi.checkMethodArgs('segments', arguments, 1, 1);
              Sk.ffi.checkArgType('segments', [
                Sk.ffi.PyType.INT,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isInt(c) || Sk.ffi.isNone(c), c);
              d.segments = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'build':
            return Sk.ffi.callableToPy(a, 'build', function (b) {
              Sk.ffi.checkMethodArgs('build', arguments, 0, 0);
              var c, e = {};
              e.axis = d.axis ? d.axis : s;
              if (d.volume) {
                var g = 'number' === typeof d.radiusTop ? d.radiusTop : 0.5, h = 'number' === typeof d.radiusBottom ? d.radiusBottom : 0.5, n = 'number' === typeof d.height ? d.height : 1, l = Math.pow(3 * d.volume / (h * (h + g) * n * Math.PI), 1 / 3);
                e.a = l * g;
                e.b = l * h;
                e.h = l * n;
              } else
                e.a = 'number' === typeof d.radiusTop ? d.radiusTop : 0.5, e.b = 'number' === typeof d.radiusBottom ? d.radiusBottom : 0.5, e.h = 'number' === typeof d.height ? d.height : 1;
              c = e;
              var e = Sk.ffi.numberToFloatPy(c.a), g = Sk.ffi.numberToFloatPy(c.b), h = Sk.ffi.numberToFloatPy(c.h), n = Sk.ffi.numberToIntPy(d.segments ? d.segments : 32), l = Sk.ffi.numberToIntPy(1), p = Sk.ffi.booleanToPy(!1);
              c = Sk.ffi.callsim(a.Euclidean3, Sk.ffi.referenceToPy(c.axis, 'Euclidean3'));
              e = Sk.ffi.callsim(a.CylinderGeometry, e, g, h, n, l, p, c);
              return f(e, d);
            });
          case 'normalize':
            return Sk.ffi.callableToPy(a, 'normalize', function (a) {
              Sk.ffi.checkMethodArgs('normalize', arguments, 0, 0);
              return b;
            });
          default:
            return k(b, c, Sk.geometry.CYLINDER_BUILDER);
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('' + a);
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy(Sk.geometry.CYLINDER_BUILDER + '()');
        });
      }, Sk.geometry.CYLINDER_BUILDER, []);
      a.PlaneBuilder = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('PlaneBuilder', arguments, 0, 0);
          Sk.ffi.referenceToPy({}, 'PlaneBuilder', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'height':
            return Sk.ffi.callableToPy(a, 'height', function (a, c) {
              Sk.ffi.checkMethodArgs('height', arguments, 1, 1);
              Sk.ffi.checkArgType('height', [
                l,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.height = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'width':
            return Sk.ffi.callableToPy(a, 'width', function (a, c) {
              Sk.ffi.checkMethodArgs('width', arguments, 1, 1);
              Sk.ffi.checkArgType('width', [
                l,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.width = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'segments':
            return Sk.ffi.callableToPy(a, 'segments', function (a, c) {
              Sk.ffi.checkMethodArgs('segments', arguments, 1, 1);
              Sk.ffi.checkArgType('segments', [
                Sk.ffi.PyType.INT,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isInt(c) || Sk.ffi.isNone(c), c);
              d.segments = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'build':
            return Sk.ffi.callableToPy(a, 'build', function (b) {
              Sk.ffi.checkMethodArgs('build', arguments, 0, 0);
              var c, e = {};
              if (d.volume) {
                c = d.width ? d.width : 1;
                var g = d.height ? d.height : 1, h = Math.pow(d.volume / (c * g), 0.5);
                e.width = h * c;
                e.height = h * g;
              } else
                e.width = d.width ? d.width : 1, e.height = d.height ? d.height : 1;
              c = e;
              e = Sk.ffi.numberToFloatPy(c.width);
              c = Sk.ffi.numberToFloatPy(c.height);
              g = Sk.ffi.numberToIntPy(d.segments ? d.segments : 1);
              e = Sk.ffi.callsim(a.PlaneGeometry, e, c, g, g);
              return f(e, d);
            });
          case 'normalize':
            return Sk.ffi.callableToPy(a, 'normalize', function (a) {
              Sk.ffi.checkMethodArgs('normalize', arguments, 0, 0);
              return b;
            });
          default:
            return k(b, c, 'PlaneBuilder');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('' + a);
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('PlaneBuilder()');
        });
      }, 'PlaneBuilder', []);
      a.SphereBuilder = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('SphereBuilder', arguments, 0, 0);
          Sk.ffi.referenceToPy({}, 'SphereBuilder', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'radius':
            return Sk.ffi.callableToPy(a, 'radius', function (a, c) {
              Sk.ffi.checkMethodArgs('radius', arguments, 1, 1);
              Sk.ffi.checkArgType('radius', [
                l,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.radius = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'segments':
            return Sk.ffi.callableToPy(a, 'segments', function (a, c) {
              Sk.ffi.checkMethodArgs('segments', arguments, 1, 1);
              Sk.ffi.checkArgType('segments', [
                Sk.ffi.PyType.INT,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isInt(c) || Sk.ffi.isNone(c), c);
              d.segments = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'build':
            return Sk.ffi.callableToPy(a, 'build', function (b) {
              Sk.ffi.checkMethodArgs('build', arguments, 0, 0);
              var c;
              c = d.volume ? Math.pow(3 * d.volume / (4 * Math.PI), 1 / 3) : d.radius ? d.radius : 0.5;
              c = Sk.ffi.numberToFloatPy(c);
              var e = Sk.ffi.numberToIntPy(d.segments ? d.segments : 24), g = Sk.ffi.numberToIntPy(d.segments ? d.segments : 18);
              c = Sk.ffi.callsim(a.SphereGeometry, c, e, g);
              return f(c, d);
            });
          case 'normalize':
            return Sk.ffi.callableToPy(a, 'normalize', function (a) {
              Sk.ffi.checkMethodArgs('normalize', arguments, 0, 0);
              d.radius = Math.pow(3 / (4 * Math.PI), 1 / 3);
              return b;
            });
          default:
            return k(b, c, 'SphereBuilder');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('' + a);
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('SphereBuilder()');
        });
      }, 'SphereBuilder', []);
      a[Sk.geometry.VOLUME_BUILDER] = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs(Sk.geometry.VOLUME_BUILDER, arguments, 0, 0);
          Sk.ffi.referenceToPy({}, Sk.geometry.VOLUME_BUILDER, void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'radius':
            return Sk.ffi.callableToPy(a, 'radius', function (a, c) {
              Sk.ffi.checkMethodArgs('radius', arguments, 1, 1);
              Sk.ffi.checkArgType('radius', [
                l,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.radius = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'segments':
            return Sk.ffi.callableToPy(a, 'segments', function (a, c) {
              Sk.ffi.checkMethodArgs('segments', arguments, 1, 1);
              Sk.ffi.checkArgType('segments', [
                Sk.ffi.PyType.INT,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isInt(c) || Sk.ffi.isNone(c), c);
              d.segments = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'build':
            return Sk.ffi.callableToPy(a, 'build', function (b) {
              Sk.ffi.checkMethodArgs('build', arguments, 0, 0);
              var c = {};
              if (d.volume) {
                var f = d.radius ? d.radius : 1, g = d.height ? d.height : 1, h = Math.pow(d.volume / (f * g), 0.5);
                c.width = h * f;
                c.height = h * g;
              } else
                c.radius = d.radius ? d.radius : 1, c.height = d.height ? d.height : 1;
              Sk.ffi.numberToFloatPy(c.radius);
              Sk.ffi.numberToFloatPy(0.08);
              Sk.ffi.numberToFloatPy(0.01);
              Sk.ffi.numberToFloatPy(0.2);
              Sk.ffi.numberToFloatPy(0.8);
              Sk.ffi.numberToIntPy(6);
              Sk.ffi.numberToIntPy(d.segments ? d.segments : 32);
              return Sk.ffi.callsim(a[Sk.geometry.VOLUME], e(d));
            });
          case 'normalize':
            return Sk.ffi.callableToPy(a, 'normalize', function (a) {
              Sk.ffi.checkMethodArgs('normalize', arguments, 0, 0);
              d.radius = Math.sqrt(1 / Math.PI);
              return b;
            });
          default:
            return k(b, c, Sk.geometry.VOLUME_BUILDER);
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('' + a);
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy(Sk.geometry.VOLUME_BUILDER + '()');
        });
      }, Sk.geometry.VOLUME_BUILDER, []);
      a[Sk.geometry.VOLUME] = Sk.ffi.buildClass(a, function (a, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, c) {
          Sk.ffi.checkMethodArgs(Sk.geometry.VOLUME, arguments, 1, 1);
          var d = new b[Sk.three.OBJECT_3D](), e, f = new Sk.geometry.CylinderBuilder();
          f.radius(0.01).material(Sk.ffi.remapToJs(c));
          f.axis(1, 0, 0);
          e = f.build();
          e.position.set(0, 0.5, 0.5);
          d.add(e);
          e = f.build();
          e.position.set(0, 0.5, -0.5);
          e.name = 'c1';
          d.add(e);
          e = f.build();
          e.position.set(0, -0.5, 0.5);
          d.add(e);
          f.axis(0, 1, 0);
          e = f.build();
          e.position.set(0.5, 0, 0.5);
          d.add(e);
          e = f.build();
          e.position.set(-0.5, 0, 0.5);
          d.add(e);
          e = f.build();
          e.position.set(-0.5, 0, -0.5);
          e.name = 'c2';
          d.add(e);
          f.axis(0, 0, 1);
          e = f.build();
          e.position.set(0.5, -0.5, 0);
          d.add(e);
          e = f.build();
          e.position.set(-0.5, 0.5, 0);
          d.add(e);
          e = f.build();
          e.position.set(-0.5, -0.5, 0);
          d.add(e);
          f = new Sk.geometry.ArrowBuilder();
          f.radius(0.01).material(Sk.ffi.remapToJs(c));
          f.axis(1, 0, 0);
          e = f.build();
          e.name = 'e1';
          e.position.set(0, -0.5, -0.5);
          d.add(e);
          f.axis(0, 1, 0);
          e = f.build();
          e.name = 'e2';
          e.position.set(0.5, 0, -0.5);
          d.add(e);
          f.axis(0, 0, 1);
          e = f.build();
          e.position.set(0.5, 0.5, 0);
          d.add(e);
          Sk.ffi.referenceToPy(d, Sk.geometry.VOLUME, void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.remapToJs(a);
          switch (b) {
          default:
            return Sk.three.object3DGetAttr(Sk.geometry.VOLUME, a, b);
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          var d = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'orientation':
            Sk.ffi.checkArgType(b, Sk.ffi.PyType.BOOL, Sk.ffi.isBool(c), c);
            a = Sk.ffi.remapToJs(c);
            b = d.getObjectByName('e1');
            c = d.getObjectByName('c1');
            var e = d.getObjectByName('e2'), d = d.getObjectByName('c2');
            a ? (b.position.set(0, -0.5, -0.5), c.position.set(0, 0.5, -0.5), e.position.set(0.5, 0, -0.5), d.position.set(-0.5, 0, -0.5)) : (b.position.set(0, 0.5, -0.5), c.position.set(0, -0.5, -0.5), e.position.set(-0.5, 0, -0.5), d.position.set(0.5, 0, -0.5));
            break;
          default:
            return Sk.three.object3DSetAttr(Sk.geometry.VOLUME, a, b, c);
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [].map(function (b) {
              return [
                b,
                Sk.ffi.remapToJs(Sk.ffh.str(Sk.ffi.gattr(a, b)))
              ].join('=');
            });
          return Sk.ffi.stringToPy(Sk.geometry.VOLUME + '(' + b.join(', ') + ')');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [].map(function (b) {
              return Sk.ffi.gattr(a, b);
            }).map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffh.repr(a));
            });
          return Sk.ffi.stringToPy(Sk.geometry.VOLUME + '(' + b.join(', ') + ')');
        });
      }, Sk.geometry.VOLUME, []);
      a[Sk.geometry.VORTEX_BUILDER] = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs(Sk.geometry.VORTEX_BUILDER, arguments, 0, 0);
          Sk.ffi.referenceToPy({}, Sk.geometry.VORTEX_BUILDER, void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'radius':
            return Sk.ffi.callableToPy(a, 'radius', function (a, c) {
              Sk.ffi.checkMethodArgs('radius', arguments, 1, 1);
              Sk.ffi.checkArgType('radius', [
                l,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(c) || Sk.ffi.isNone(c), c);
              d.radius = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'segments':
            return Sk.ffi.callableToPy(a, 'segments', function (a, c) {
              Sk.ffi.checkMethodArgs('segments', arguments, 1, 1);
              Sk.ffi.checkArgType('segments', [
                Sk.ffi.PyType.INT,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isInt(c) || Sk.ffi.isNone(c), c);
              d.segments = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'build':
            return Sk.ffi.callableToPy(a, 'build', function (b) {
              Sk.ffi.checkMethodArgs('build', arguments, 0, 0);
              var c = {};
              if (d.volume) {
                var e = d.radius ? d.radius : 1, g = d.height ? d.height : 1, h = Math.pow(d.volume / (e * g), 0.5);
                c.width = h * e;
                c.height = h * g;
              } else
                c.radius = d.radius ? d.radius : 1, c.height = d.height ? d.height : 1;
              var c = Sk.ffi.numberToFloatPy(c.radius), e = Sk.ffi.numberToFloatPy(0.08), g = Sk.ffi.numberToFloatPy(0.01), h = Sk.ffi.numberToFloatPy(0.2), n = Sk.ffi.numberToFloatPy(0.8), l = Sk.ffi.numberToIntPy(6), p = Sk.ffi.numberToIntPy(d.segments ? d.segments : 32), c = Sk.ffi.callsim(a[Sk.three.VORTEX_GEOMETRY], c, e, g, h, n, l, p);
              return f(c, d);
            });
          case 'normalize':
            return Sk.ffi.callableToPy(a, 'normalize', function (a) {
              Sk.ffi.checkMethodArgs('normalize', arguments, 0, 0);
              d.radius = Math.sqrt(1 / Math.PI);
              return b;
            });
          default:
            return k(b, c, Sk.geometry.VORTEX_BUILDER);
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('' + a);
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy(Sk.geometry.VORTEX_BUILDER + '()');
        });
      }, Sk.geometry.VORTEX_BUILDER, []);
    };
  }.call(this));
  (function () {
    Sk.builtin.defineNode = function (a) {
      Sk.ffi.checkFunctionArgs('defineNode', arguments, 1, 1);
      var b = function (b) {
        return b ? Sk.ffi.callsim(a.Node, Sk.ffi.referenceToPy(b, 'Node')) : Sk.ffi.none.None;
      };
      a.Node = Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkMethodArgs('Node', arguments, 1, 1);
          Sk.ffi.checkArgType('node', 'Node', Sk.ffi.isInstance(b, 'Node'), b);
          Sk.ffi.referenceToPy(Sk.ffi.remapToJs(b), 'Node', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (c, d) {
          var g = Sk.ffi.remapToJs(c);
          switch (d) {
          case 'clientHeight':
            return Sk.ffi.numberToFloatPy(g.clientHeight);
          case 'clientWidth':
            return Sk.ffi.numberToFloatPy(g.clientWidth);
          case 'dir':
            return Sk.ffi.stringToPy(g.dir);
          case 'firstChild':
            return b(g.firstChild);
          case 'lastChild':
            return b(g.lastChild);
          case 'nextSibling':
            return b(g.nextSibling);
          case 'offsetHeight':
            return Sk.ffi.numberToIntPy(g.offsetHeight);
          case 'offsetWidth':
            return Sk.ffi.numberToIntPy(g.offsetWidth);
          case 'parentNode':
            return b(g.parentNode);
          case 'previousSibling':
            return b(g.previousSibling);
          case 'height':
            return Sk.builtin.assk$(g.height, Sk.builtin.nmber.int$);
          case 'width':
            return Sk.builtin.assk$(g.width, Sk.builtin.nmber.int$);
          case 'style':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'style';
                a.v = g.style;
              });
              b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
                var c = Sk.ffi.remapToJs(a);
                switch (b) {
                case 'height':
                  return Sk.ffi.stringToPy(c.height);
                case 'left':
                  return Sk.ffi.stringToPy(c.left);
                case 'position':
                  return Sk.ffi.stringToPy(c.position);
                case 'top':
                  return Sk.ffi.stringToPy(c.top);
                case 'width':
                  return Sk.ffi.stringToPy(c.width);
                }
              });
              b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
                a = Sk.ffi.remapToJs(a);
                c = Sk.ffi.remapToJs(c);
                switch (b) {
                case 'height':
                  a.height = c;
                  break;
                case 'left':
                  a.left = c;
                  break;
                case 'position':
                  a.position = c;
                  break;
                case 'top':
                  a.top = c;
                  break;
                case 'width':
                  a.width = c;
                  break;
                default:
                  throw new Sk.builtin.AssertionError(b + ' is not a writeable attribute of style');
                }
              });
              b.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('style');
              });
              b.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('style');
              });
            }, 'style', []));
          case 'appendChild':
            return Sk.ffi.callableToPy(a, 'appendChild', function (a, c) {
              Sk.ffi.checkMethodArgs('appendChild', arguments, 1, 1);
              Sk.ffi.checkArgType('child', 'Node', Sk.ffi.isInstance(c, 'Node'), c);
              var d = Sk.ffi.remapToJs(c);
              return b(g.appendChild(d));
            });
          case 'getContext':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'getContext';
              });
              c.__call__ = Sk.ffi.functionPy(function (b, c, d) {
                b = Sk.ffi.remapToJs(c);
                d = Sk.ffi.remapToJs(d);
                var e = g.getContext(b, d);
                return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
                  c.__init__ = Sk.ffi.functionPy(function (a) {
                    a.tp$name = 'CanvasRenderingContext2D';
                    a.v = e;
                  });
                  c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
                    switch (c) {
                    case 'fillStyle':
                      return Sk.ffi.stringToPy(e.fillStyle);
                    case 'font':
                      return Sk.ffi.stringToPy(e.font);
                    case 'lineCap':
                      return Sk.ffi.stringToPy(e.lineCap);
                    case 'lineJoin':
                      return Sk.ffi.stringToPy(e.lineJoin);
                    case 'lineWidth':
                      return Sk.builtin.assk$(e.lineWidth, Sk.builtin.nmber.int$);
                    case 'shadowBlur':
                      return Sk.builtin.assk$(e.shadowBlur, Sk.builtin.nmber.int$);
                    case 'shadowColor':
                      return Sk.ffi.stringToPy(e.shadowColor);
                    case 'shadowOffsetX':
                      return Sk.builtin.assk$(e.shadowOffsetX, Sk.builtin.nmber.int$);
                    case 'shadowOffsetY':
                      return Sk.builtin.assk$(e.shadowOffsetY, Sk.builtin.nmber.int$);
                    case 'strokeStyle':
                      return Sk.ffi.stringToPy(e.strokeStyle);
                    case 'textAlign':
                      return Sk.ffi.stringToPy(e.textAlign);
                    case 'textBaseline':
                      return Sk.ffi.stringToPy(e.textBaseline);
                    case 'webkitBackingStorePixelRatio':
                      return Sk.builtin.assk$(e.webkitBackingStorePixelRatio, Sk.builtin.nmber.int$);
                    case 'arc':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'arc';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c, d, f, g, h) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          f = Sk.ffi.remapToJs(f);
                          g = Sk.ffi.remapToJs(g);
                          h = Sk.ffi.remapToJs(h);
                          e.arc(b, c, d, f, g, h);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('arc');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('arc');
                        });
                      }, 'arc', []));
                    case 'arcTo':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'arcTo';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c, d, f, g, h, n) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          f = Sk.ffi.remapToJs(f);
                          g = Sk.ffi.remapToJs(g);
                          h = Sk.ffi.remapToJs(h);
                          n = Sk.ffi.remapToJs(n);
                          e.arcTo(b, c, d, f, g, h, n);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('arcTo');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('arcTo');
                        });
                      }, 'arcTo', []));
                    case 'beginPath':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'beginPath';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a) {
                          e.beginPath();
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('beginPath');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('beginPath');
                        });
                      }, 'beginPath', []));
                    case 'bezierCurveTo':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'bezierCurveTo';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c, d, f, g, h) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          f = Sk.ffi.remapToJs(f);
                          g = Sk.ffi.remapToJs(g);
                          h = Sk.ffi.remapToJs(h);
                          e.bezierCurveTo(b, c, d, f, g, h);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('bezierCurveTo');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('bezierCurveTo');
                        });
                      }, 'bezierCurveTo', []));
                    case 'clearRect':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'clearRect';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c, d, f) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          f = Sk.ffi.remapToJs(f);
                          e.clearRect(b, c, d, f);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('clearRect');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('clearRect');
                        });
                      }, 'clearRect', []));
                    case 'clip':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'clip';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a) {
                          e.clip();
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('clip');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('clip');
                        });
                      }, 'clip', []));
                    case 'closePath':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'closePath';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a) {
                          e.closePath();
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('closePath');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('closePath');
                        });
                      }, 'closePath', []));
                    case 'createLinearGradient':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
                        c.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'createLinearGradient';
                        });
                        c.__call__ = Sk.ffi.functionPy(function (b, c, d, f, g) {
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          f = Sk.ffi.remapToJs(f);
                          g = Sk.ffi.remapToJs(g);
                          var h = e.createLinearGradient(c, d, f, g);
                          return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
                            c.__init__ = Sk.ffi.functionPy(function (a) {
                              a.tp$name = 'CanvasGradient';
                              a.v = h;
                            });
                            c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
                              switch (c) {
                              case 'addColorStop':
                                return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                                  b.__init__ = Sk.ffi.functionPy(function (a) {
                                    a.tp$name = 'addColorStop';
                                  });
                                  b.__call__ = Sk.ffi.functionPy(function (a, b, c) {
                                    b = Sk.ffi.remapToJs(b);
                                    c = Sk.ffi.remapToJs(c);
                                    h.addColorStop(b, c);
                                  });
                                  b.__str__ = Sk.ffi.functionPy(function (a) {
                                    return Sk.ffi.stringToPy('addColorStop');
                                  });
                                  b.__repr__ = Sk.ffi.functionPy(function (a) {
                                    return Sk.ffi.stringToPy('addColorStop');
                                  });
                                }, 'addColorStop', []));
                              }
                            });
                            c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
                              Sk.ffi.remapToJs(c);
                              switch (b) {
                              default:
                                throw new Sk.builtin.AssertionError(b + ' is not a writeable attribute of CanvasGradient');
                              }
                            });
                            c.__str__ = Sk.ffi.functionPy(function (a) {
                              return Sk.ffi.stringToPy('CanvasGradient');
                            });
                            c.__repr__ = Sk.ffi.functionPy(function (a) {
                              return Sk.ffi.stringToPy('CanvasGradient');
                            });
                          }, 'CanvasGradient', []));
                        });
                        c.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('createLinearGradient');
                        });
                        c.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('createLinearGradient');
                        });
                      }, 'createLinearGradient', []));
                    case 'fill':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'fill';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a) {
                          e.fill();
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('fill');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('fill');
                        });
                      }, 'fill', []));
                    case 'fillRect':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'fillRect';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c, d, f) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          f = Sk.ffi.remapToJs(f);
                          e.fillRect(b, c, d, f);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('fillRect');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('fillRect');
                        });
                      }, 'fillRect', []));
                    case 'fillText':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'fillText';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c, d, f) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          a = Sk.ffi.remapToJs(f);
                          if ('undefined' === typeof a)
                            e.fillText(b, c, d);
                          else if ('number' === typeof a)
                            e.fillText(b, c, d, a);
                          else
                            throw new Sk.builtin.TypeError('maxWidth');
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('fillText');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('fillText');
                        });
                      }, 'fillText', []));
                    case 'lineTo':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'lineTo';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          e.lineTo(b, c);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('lineTo');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('lineTo');
                        });
                      }, 'lineTo', []));
                    case 'moveTo':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'moveTo';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          e.moveTo(b, c);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('moveTo');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('moveTo');
                        });
                      }, 'moveTo', []));
                    case 'quadraticCurveTo':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'quadraticCurveTo';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c, d, f) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          f = Sk.ffi.remapToJs(f);
                          e.quadraticCurveTo(b, c, d, f);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('quadraticCurveTo');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('quadraticCurveTo');
                        });
                      }, 'quadraticCurveTo', []));
                    case 'rect':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'rect';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c, d, f) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          f = Sk.ffi.remapToJs(f);
                          e.rect(b, c, d, f);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('rect');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('rect');
                        });
                      }, 'rect', []));
                    case 'restore':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'restore';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a) {
                          e.restore();
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('restore');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('restore');
                        });
                      }, 'restore', []));
                    case 'rotate':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'rotate';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b) {
                          b = Sk.ffi.remapToJs(b);
                          e.rotate(b);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('rotate');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('rotate');
                        });
                      }, 'rotate', []));
                    case 'save':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'save';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a) {
                          e.save();
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('save');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('save');
                        });
                      }, 'save', []));
                    case 'scale':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'scale';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          e.scale(b, c);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('scale');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('scale');
                        });
                      }, 'scale', []));
                    case 'setTransform':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'setTransform';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c, d, f, g, h) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          f = Sk.ffi.remapToJs(f);
                          g = Sk.ffi.remapToJs(g);
                          h = Sk.ffi.remapToJs(h);
                          e.setTransform(b, c, d, f, g, h);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('setTransform');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('setTransform');
                        });
                      }, 'setTransform', []));
                    case 'stroke':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'stroke';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a) {
                          e.stroke();
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('stroke');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('stroke');
                        });
                      }, 'stroke', []));
                    case 'strokeRect':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'strokeRect';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c, d, f) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          f = Sk.ffi.remapToJs(f);
                          e.strokeRect(b, c, d, f);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('strokeRect');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('strokeRect');
                        });
                      }, 'strokeRect', []));
                    case 'strokeText':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'strokeText';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c, d, f) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          a = Sk.ffi.remapToJs(f);
                          if ('undefined' === typeof a)
                            e.strokeText(b, c, d);
                          else if ('number' === typeof a)
                            e.strokeText(b, c, d, a);
                          else
                            throw new Sk.builtin.TypeError('maxWidth');
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('strokeText');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('strokeText');
                        });
                      }, 'strokeText', []));
                    case 'transform':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'transform';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c, d, f, g, h) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          d = Sk.ffi.remapToJs(d);
                          f = Sk.ffi.remapToJs(f);
                          g = Sk.ffi.remapToJs(g);
                          h = Sk.ffi.remapToJs(h);
                          e.transform(b, c, d, f, g, h);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('transform');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('transform');
                        });
                      }, 'transform', []));
                    case 'translate':
                      return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
                        b.__init__ = Sk.ffi.functionPy(function (a) {
                          a.tp$name = 'translate';
                        });
                        b.__call__ = Sk.ffi.functionPy(function (a, b, c) {
                          b = Sk.ffi.remapToJs(b);
                          c = Sk.ffi.remapToJs(c);
                          e.translate(b, c);
                        });
                        b.__str__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('translate');
                        });
                        b.__repr__ = Sk.ffi.functionPy(function (a) {
                          return Sk.ffi.stringToPy('translate');
                        });
                      }, 'translate', []));
                    }
                  });
                  c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
                    a = Sk.ffi.remapToJs(a);
                    c = Sk.ffi.remapToJs(c);
                    switch (b) {
                    case 'fillStyle':
                      a.fillStyle = c;
                      break;
                    case 'font':
                      a.font = c;
                      break;
                    case 'lineCap':
                      a.lineCap = c;
                      break;
                    case 'lineJoin':
                      a.lineJoin = c;
                      break;
                    case 'lineWidth':
                      a.lineWidth = c;
                      break;
                    case 'shadowBlur':
                      a.shadowBlur = c;
                      break;
                    case 'shadowColor':
                      a.shadowColor = c;
                      break;
                    case 'shadowOffsetX':
                      a.shadowOffsetX = c;
                      break;
                    case 'shadowOffsetY':
                      a.shadowOffsetY = c;
                      break;
                    case 'strokeStyle':
                      a.strokeStyle = c;
                      break;
                    case 'textAlign':
                      a.textAlign = c;
                      break;
                    case 'textBaseline':
                      a.textBaseline = c;
                      break;
                    default:
                      throw new Sk.builtin.AssertionError(b + ' is not a writeable attribute of CanvasRenderingContext2D');
                    }
                  });
                  c.__str__ = Sk.ffi.functionPy(function (a) {
                    return Sk.ffi.stringToPy('CanvasRenderingContext2D');
                  });
                  c.__repr__ = Sk.ffi.functionPy(function (a) {
                    return Sk.ffi.stringToPy('CanvasRenderingContext2D');
                  });
                }, 'CanvasRenderingContext2D', []));
              });
              c.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('getContext');
              });
              c.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('getContext');
              });
            }, 'getContext', []));
          case 'insertBefore':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'insertBefore';
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c, d) {
                return b(g.insertBefore(Sk.ffi.remapToJs(c), Sk.ffi.remapToJs(d)));
              });
              c.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('insertBefore');
              });
              c.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('insertBefore');
              });
            }, 'insertBefore', []));
          case 'removeChild':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'removeChild';
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c) {
                return b(g.removeChild(Sk.ffi.remapToJs(c)));
              });
              c.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('removeChild');
              });
              c.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('removeChild');
              });
            }, 'removeChild', []));
          case 'setAttribute':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'setAttribute';
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b, c) {
                Sk.ffi.checkMethodArgs('setAttribute', arguments, 2, 2);
                Sk.ffi.checkArgType('name', Sk.ffi.PyType.STR, Sk.ffi.isStr(b), b);
                g.setAttribute(Sk.ffi.remapToJs(b), Sk.ffi.remapToJs(c));
              });
              b.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('setAttribute');
              });
              b.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('setAttribute');
              });
            }, 'setAttribute', []));
          default:
            throw Sk.ffi.err.attribute(d).isNotGetableOnType('Node');
          }
        });
        d.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          var d = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'dir':
            a.dir = d;
            break;
          case 'id':
            a.setAttribute(b, d);
            break;
          case 'height':
            a.height = d;
            break;
          case 'innerHTML':
            Sk.ffi.checkArgType('innerHTML', Sk.ffi.PyType.STR, Sk.ffi.isStr(c), c);
            a.innerHTML = Sk.ffi.remapToJs(c);
            break;
          case 'width':
            a.width = d;
            break;
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('Node');
          }
        });
        d.getCSS = Sk.ffi.functionPy(function (a, b) {
          return Sk.ffi.stringToPy(a.v.style[b.v]);
        });
        d.setCSS = Sk.ffi.functionPy(function (a, b, c) {
          a.v.style[b.v] = c.v;
        });
        d.getAttribute = Sk.ffi.functionPy(function (a, b) {
          var c = a.v.getAttribute(b.v);
          return c ? Sk.ffi.stringToPy(c) : null;
        });
        d.setAttribute = Sk.ffi.functionPy(function (a, b, c) {
          a.v.setAttribute(b.v, c.v);
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy(a.v.tagName);
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('Node');
        });
      }, 'Node', []);
    };
  }.call(this));
  (function () {
    Sk.builtin.defineNumPy = function (a) {
      Sk.ffi.checkFunctionArgs('defineNumPy', arguments, 1, 1);
      a.array = Sk.ffi.functionPy(function () {
        Sk.ffi.checkFunctionArgs('array', arguments, 1, 3);
      });
      a.empty = Sk.ffi.functionPy(function (a, c, d) {
        Sk.ffi.checkFunctionArgs('empty', arguments, 1, 3);
      });
      a.sqrt = Sk.ffi.functionPy(function () {
        Sk.ffi.checkFunctionArgs('sqrt', arguments, 1, 1);
      });
      a.zeros = Sk.ffi.functionPy(function () {
        Sk.ffi.checkFunctionArgs('zeros', arguments, 1, 2);
      });
    };
  }.call(this));
  (function () {
    Sk.builtin.defineProbeE3 = function (a, b) {
      Sk.ffi.checkFunctionArgs('defineProbeE3', arguments, 2, 2);
      var c = [
          Sk.ffi.PyType.FLOAT,
          Sk.ffi.PyType.INT,
          Sk.ffi.PyType.LONG
        ];
      a.ProbeE3 = Sk.ffi.buildClass(a, function (a, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e) {
          Sk.ffi.checkMethodArgs('ProbeE3', arguments, 4, 4);
          var m = {};
          m.grade0 = b;
          m.grade1 = c;
          m.grade2 = d;
          m.grade3 = e;
          m.quantity = Sk.ffi.none.None;
          Sk.ffi.referenceToPy(m, 'ProbeE3', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'grade0':
            return c.grade0;
          case 'grade1':
            return c.grade1;
          case 'grade2':
            return c.grade2;
          case 'grade3':
            return c.grade3;
          case 'position':
            return c.position;
          case 'quantity':
            return c.quantity;
          default:
            throw Sk.ffi.err.attribute(b).isNotGetableOnType('ProbeE3');
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, c, d) {
          a = Sk.ffi.remapToJs(a);
          switch (c) {
          case 'position':
            Sk.ffi.checkArgType('position', 'Euclidean3', Sk.ffi.isInstance(d, 'Euclidean3'), d);
            a.position = d;
            d = Sk.ffi.remapToJs(d).vector;
            var e = Sk.ffi.remapToJs(a.grade0);
            e.position = d;
            e = Sk.ffi.remapToJs(a.grade1);
            e.position = d;
            var l = Sk.ffi.remapToJs(a.grade2);
            l.position = d;
            var m = Sk.ffi.remapToJs(a.grade3);
            m.position = d;
            break;
          case 'quantity':
            Sk.ffi.checkArgType('quantity', 'Euclidean3', Sk.ffi.isInstance(d, 'Euclidean3'), d);
            m = function (a, c, d) {
              if (-1 !== d) {
                var e = 1 / Math.sqrt(2 * (1 + d));
                return new b.Quaternion(-(+e * c), -(-e * a), -0, e * (1 + d));
              }
              return new b.Quaternion(1, 0, 0, 0);
            };
            c = function (a, b) {
              a.scale.set(b, b, b);
              a.traverse(function (a) {
                a.visible = !0;
              });
            };
            var n = function (a) {
                a.traverse(function (a) {
                  a.visible = !1;
                });
                a.scale.set(1, 1, 1);
              }, p = Sk.ffi.remapToJs(d), q = p.w, l = p.x, s = p.y, r = p.z, w = p.xy, A = p.yz, z = p.zx, p = p.xyz, e = Sk.ffi.remapToJs(a.grade0), q = Math.abs(q);
            0 !== q ? c(e, q) : n(e);
            e = Sk.ffi.remapToJs(a.grade1);
            0 !== l || 0 !== s || 0 !== r ? (q = Math.sqrt(l * l + s * s + r * r), e.quaternion = m(l / q, s / q, r / q), c(e, q)) : n(e);
            l = Sk.ffi.remapToJs(a.grade2);
            0 !== w || 0 !== A || 0 !== z ? (s = Math.sqrt(w * w + A * A + z * z), r = Math.pow(s, 0.5), l.quaternion = m(A / s, z / s, w / s), c(l, r)) : n(l);
            m = Sk.ffi.remapToJs(a.grade3);
            if (0 !== p) {
              n = Math.pow(Math.abs(p), 1 / 3);
              try {
                Sk.ffi.sattr(a.grade3, 'orientation', Sk.ffi.booleanToPy(0 <= ('number' === typeof p ? p ? 0 > p ? -1 : 1 : isNaN(p) ? NaN : 0 : NaN)));
              } catch (D) {
              }
              c(m, n);
            } else
              n(m);
            a.quantity = d;
            break;
          case 'grade0':
            a.grade0 = d;
            break;
          case 'grade1':
            a.grade1 = d;
            break;
          case 'grade2':
            a.grade2 = d;
            break;
          case 'grade3':
            a.grade3 = d;
            break;
          default:
            throw Sk.ffi.err.attribute(c).isNotSetableOnType('ProbeE3');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('ProbeE3');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('ProbeE3');
        });
      }, 'ProbeE3', []);
      a.ProbeBuilderE3 = Sk.ffi.buildClass(a, function (b, e) {
        e.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('ProbeBuilderE3', arguments, 0, 0);
          Sk.ffi.referenceToPy({
            segments: 12,
            wireframe: !1
          }, 'ProbeBuilderE3', void 0, a);
        });
        e.__getattr__ = Sk.ffi.functionPy(function (b, d) {
          var e = Sk.ffi.remapToJs(b);
          switch (d) {
          case 'color':
            return Sk.ffi.callableToPy(a, d, function (a, l) {
              Sk.ffi.checkMethodArgs(d, arguments, 1, 1);
              Sk.ffi.checkArgType(d, [
                c,
                Sk.ffi.PyType.STR,
                'Color'
              ], Sk.ffi.isNum(l) || Sk.ffi.isStr(l) || Sk.ffi.isInstance(l, 'Color'), l);
              e.color = l;
              return b;
            });
          case 'segments':
            return Sk.ffi.callableToPy(a, d, function (a, c) {
              Sk.ffi.checkMethodArgs(d, arguments, 1, 1);
              Sk.ffi.checkArgType(d, Sk.ffi.PyType.INT, Sk.ffi.isInt(c), c);
              e.segments = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'wireframe':
            return Sk.ffi.callableToPy(a, d, function (a, c) {
              Sk.ffi.checkMethodArgs(d, arguments, 1, 1);
              Sk.ffi.checkArgType(d, Sk.ffi.PyType.BOOL, Sk.ffi.isBool(c), c);
              e.wireframe = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'build':
            return Sk.ffi.callableToPy(a, d, function (b) {
              b = [
                'SphereBuilder',
                Sk.geometry.ARROW_BUILDER,
                Sk.geometry.VORTEX_BUILDER,
                Sk.geometry.VOLUME_BUILDER
              ].map(function (b) {
                b = Sk.ffi.callsim(a[b]);
                e.color && Sk.ffi.callsim(Sk.ffi.gattr(b, 'color'), e.color);
                Sk.ffi.callsim(Sk.ffi.gattr(b, 'normalize'));
                Sk.ffi.callsim(Sk.ffi.gattr(b, 'segments'), Sk.ffi.numberToIntPy(e.segments));
                Sk.ffi.callsim(Sk.ffi.gattr(b, 'wireframe'), Sk.ffi.booleanToPy(e.wireframe));
                return Sk.ffi.callsim(Sk.ffi.gattr(b, 'build'));
              });
              return Sk.ffi.callsim(a.ProbeE3, b[0], b[1], b[2], b[3]);
            });
          default:
            throw Sk.ffi.err.attribute(d).isNotGetableOnType('ProbeBuilderE3');
          }
        });
        e.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.remapToJs(a);
          switch (b) {
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('ProbeBuilderE3');
          }
        });
        e.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('ProbeBuilderE3');
        });
        e.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('ProbeBuilderE3');
        });
      }, 'ProbeBuilderE3', []);
    };
  }.call(this));
  Sk.builtin.buildWindowClass = function (a) {
    function b(a, b, c, g) {
      var h = b[c];
      switch (typeof h) {
      case 'function':
        return Sk.ffi.callableToPy(a, c, function (g) {
          Sk.ffi.checkFunctionArgs(c, arguments, 1);
          for (var k = Array.prototype.slice.call(arguments, 1), n = [], p = 0; p < k.length; ++p)
            n.push(Sk.ffi.remapToJs(k[p]));
          if (1 < c.length && c[0] === c[0].toUpperCase())
            return k = Object.create(h.prototype), n = h.apply(k, n), Sk.ffi.callsim(a.JavaScriptWrapper, Sk.ffi.referenceToPy('object' === typeof n && n || k, c));
          n = h.apply(b, n);
          switch (typeof n) {
          case 'number':
            return Sk.ffi.numberToFloatPy(n);
          case 'boolean':
            return Sk.ffi.booleanToPy(n);
          case 'string':
            return Sk.ffi.stringToPy(n);
          case 'undefined':
            return Sk.ffi.none.None;
          case 'object':
            return Sk.ffi.callsim(a.JavaScriptWrapper, Sk.ffi.referenceToPy(n, 'JavaScriptWrapper'));
          default:
            throw Sk.ffi.err.attribute(typeof n).isNotGetableOnType(c);
          }
        });
      case 'object':
        if ('[object Array]' === Object.prototype.toString.apply(h)) {
          g = [];
          for (var k = 0; k < h.length; k++)
            g.push(Sk.ffi.remapToPy(h[k]));
          return Sk.ffi.listPy(g);
        }
        return Sk.ffi.callsim(a.JavaScriptWrapper, Sk.ffi.referenceToPy(h, 'JavaScriptWrapper'));
      case 'number':
        return Sk.ffi.numberToFloatPy(h);
      case 'boolean':
        return Sk.ffi.booleanToPy(h);
      case 'string':
        return Sk.ffi.stringToPy(h);
      case 'undefined':
        return Sk.ffi.none.None;
      default:
        throw Sk.ffi.err.attribute(typeof h).isNotGetableOnType(g);
      }
    }
    var c = {};
    a.JavaScriptWrapper = Sk.misceval.buildClass(a, function (c, e) {
      e.__init__ = Sk.ffi.functionPy(function (a, b) {
        Sk.ffi.checkMethodArgs('JavaScriptWrapper', arguments, 1, 1);
        Sk.ffi.referenceToPy(Sk.ffi.remapToJs(b), b.tp$name, void 0, a);
      });
      e.__add__ = Sk.ffi.functionPy(function (b, c) {
        var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c), d = d.add(e);
        return Sk.ffi.callsim(a.JavaScriptWrapper, Sk.ffi.referenceToPy(d, 'JavaScriptWrapper'));
      });
      e.__sub__ = Sk.ffi.functionPy(function (b, c) {
        var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c), d = d.sub(e);
        return Sk.ffi.callsim(a.JavaScriptWrapper, Sk.ffi.referenceToPy(d, 'JavaScriptWrapper'));
      });
      e.__mul__ = Sk.ffi.functionPy(function (b, c) {
        var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c), d = d.mul(e);
        return Sk.ffi.callsim(a.JavaScriptWrapper, Sk.ffi.referenceToPy(d, 'JavaScriptWrapper'));
      });
      e.__div__ = Sk.ffi.functionPy(function (b, c) {
        var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c), d = d.div(e);
        return Sk.ffi.callsim(a.JavaScriptWrapper, Sk.ffi.referenceToPy(d, 'JavaScriptWrapper'));
      });
      e.__getattr__ = Sk.ffi.functionPy(function (c, d) {
        return b(a, Sk.ffi.remapToJs(c), d, 'JavaScriptWrapper');
      });
      e.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
        a = Sk.ffi.remapToJs(a);
        var d = a[b];
        switch (b) {
        default:
          switch (typeof d) {
          case 'number':
            a[b] = Sk.ffi.remapToJs(c);
            break;
          default:
            throw Sk.ffi.err.attribute(typeof d).isNotSetableOnType('JavaScriptWrapper');
          }
        }
      });
      e.__str__ = Sk.ffi.functionPy(function (a) {
        a = Sk.ffi.remapToJs(a);
        return Sk.ffi.stringToPy(a.toString());
      });
      e.__repr__ = Sk.ffi.functionPy(function (a) {
        return Sk.ffi.stringToPy('JavaScriptWrapper');
      });
    }, 'JavaScriptWrapper', []);
    a.Window = Sk.misceval.buildClass(a, function (d, e) {
      e.__init__ = Sk.ffi.functionPy(function (a, b) {
        Sk.ffi.checkMethodArgs('Window', arguments, 1, 1);
        Sk.ffi.referenceToPy(Sk.ffi.remapToJs(b), 'Window', void 0, a);
      });
      e.__getattr__ = Sk.ffi.functionPy(function (d, e) {
        var h = Sk.ffi.remapToJs(d);
        switch (e) {
        case 'animationTime':
          return Sk.ffi.numberToFloatPy(h.animationTime);
        case 'document':
          return Sk.ffi.callsim(a.Document, Sk.ffi.referenceToPy(h.document, 'Document'));
        case 'innerHeight':
          return Sk.ffi.numberToIntPy(h.innerHeight);
        case 'innerWidth':
          return Sk.ffi.numberToIntPy(h.innerWidth);
        case 'devicePixelRatio':
          return Sk.ffi.numberToIntPy(h.devicePixelRatio);
        case 'addEventListener':
          return Sk.misceval.callsim(Sk.misceval.buildClass(a, function (b, d) {
            d.__init__ = Sk.ffi.functionPy(function (a) {
              a.tp$name = 'addEventListener';
            });
            d.__call__ = Sk.ffi.functionPy(function (b, d, e, f) {
              b = Sk.ffi.remapToJs(d);
              d = function (b) {
                b = Sk.misceval.callsim(a.Event, Sk.ffi.referenceToPy(b, 'Event'));
                Sk.misceval.callsim(e, b);
              };
              c[b] = d;
              h.addEventListener(b, d, f);
            });
          }, 'addEventListener', []));
        case 'alert':
          return Sk.ffi.callableToPy(a, 'alert', function (a, b) {
            Sk.ffi.checkMethodArgs('alert', arguments, 0, 1);
            h.alert(Sk.ffi.remapToJs(b));
          });
        case 'removeEventListener':
          return Sk.misceval.callsim(Sk.misceval.buildClass(a, function (a, b) {
            b.__init__ = Sk.ffi.functionPy(function (a) {
              a.tp$name = 'removeEventListener';
            });
            b.__call__ = Sk.ffi.functionPy(function (a, b, d, e) {
              a = Sk.ffi.remapToJs(b);
              d = c[a];
              delete c[a];
              h.removeEventListener(a, d, e);
            });
          }, 'removeEventListener', []));
        case 'cancelAnimationFrame':
          return Sk.misceval.callsim(Sk.misceval.buildClass(a, function (a, b) {
            b.__init__ = Sk.ffi.functionPy(function (a) {
              a.tp$name = 'cancelAnimationFrame';
            });
            b.__call__ = Sk.ffi.functionPy(function (a, b) {
              b && h.cancelAnimationFrame(Sk.ffi.remapToJs(b));
            });
          }, 'cancelAnimationFrame', []));
        case 'close':
          return Sk.ffi.callableToPy(a, 'close', function (a) {
            Sk.ffi.checkMethodArgs('close', arguments, 0, 0);
            h.close();
          });
        case 'confirm':
          return Sk.ffi.callableToPy(a, 'confirm', function (a, b) {
            Sk.ffi.checkMethodArgs('confirm', arguments, 0, 1);
            return Sk.ffi.booleanToPy(h.confirm(Sk.ffi.remapToJs(b)));
          });
        case 'open':
          return Sk.ffi.callableToPy(a, 'open', function (b, c, d, e, f) {
            Sk.ffi.checkMethodArgs('open', arguments, 0, 4);
            Sk.ffi.isDefined(c) && Sk.ffi.checkArgType('URL', Sk.ffi.PyType.STR, Sk.ffi.isStr(c), c);
            Sk.ffi.isDefined(d) && Sk.ffi.checkArgType('name', Sk.ffi.PyType.STR, Sk.ffi.isStr(d), d);
            Sk.ffi.isDefined(e) && Sk.ffi.checkArgType('specs', Sk.ffi.PyType.STR, Sk.ffi.isStr(e), e);
            Sk.ffi.isDefined(f) && Sk.ffi.checkArgType('replace', Sk.ffi.PyType.BOOL, Sk.ffi.isBool(f), f);
            var g = h.open(Sk.ffi.remapToJs(c), Sk.ffi.remapToJs(d), Sk.ffi.remapToJs(e), Sk.ffi.remapToJs(f));
            return Sk.ffi.callsim(a.Window, Sk.ffi.referenceToPy(g, 'Window'));
          });
        case 'prompt':
          return Sk.ffi.callableToPy(a, 'prompt', function (a, b, c) {
            Sk.ffi.checkMethodArgs('prompt', arguments, 0, 2);
            return Sk.ffi.stringToPy(h.prompt(Sk.ffi.remapToJs(b), Sk.ffi.remapToJs(c)));
          });
        case 'requestAnimationFrame':
          return Sk.misceval.callsim(Sk.misceval.buildClass(a, function (a, b) {
            b.__init__ = Sk.ffi.functionPy(function (a) {
              a.tp$name = 'requestAnimationFrame';
            });
            b.__call__ = Sk.ffi.functionPy(function (a, b) {
              var c = h.requestAnimationFrame(function (a) {
                  Sk.misceval.callsim(b, Sk.ffi.numberToFloatPy(a));
                });
              return Sk.ffi.numberToFloatPy(c);
            });
          }, 'requestAnimationFrame', []));
        case 'setTimeout':
          return Sk.misceval.callsim(Sk.misceval.buildClass(a, function (a, b) {
            b.__init__ = Sk.ffi.functionPy(function (a) {
              a.tp$name = 'setTimeout';
            });
            b.__call__ = Sk.ffi.functionPy(function (a, b, c, d) {
              a = Sk.ffi.remapToJs(c);
              d = Sk.ffi.remapToJs(d);
              d = h.setTimeout(function () {
                Sk.misceval.callsim(b);
              }, a, d);
              return Sk.ffi.numberToFloatPy(d);
            });
          }, 'setTimeout', []));
        default:
          return b(a, h, e, 'Window');
        }
      });
      e.__str__ = Sk.ffi.functionPy(function (a) {
        return Sk.ffi.stringToPy('Window');
      });
      e.__repr__ = Sk.ffi.functionPy(function (a, b) {
        return Sk.ffi.stringToPy('Window');
      });
    }, 'Window', []);
    return a.Window;
  };
  (function () {
    Sk.builtin.defineEuclidean2 = function (a, b) {
      function c(a) {
        return 'number' === typeof a;
      }
      function d(b, c, d, e) {
        return Sk.ffi.callsim(a.Euclidean2, Sk.ffi.numberToFloatPy(b), Sk.ffi.numberToFloatPy(c), Sk.ffi.numberToFloatPy(d), Sk.ffi.numberToFloatPy(e));
      }
      function e(a, b, c) {
        var d, e, f, g, h;
        f = [];
        d = function (a, b) {
          var d;
          if (0 !== a) {
            0 <= a ? 0 < f.length && f.push('+') : f.push('-');
            d = Math.abs(a);
            if (1 === d)
              return f.push(b);
            f.push(d.toString());
            if ('1' !== b)
              return f.push(c), f.push(b);
          }
        };
        e = g = 0;
        for (h = a.length - 1; 0 <= h ? g <= h : g >= h; e = 0 <= h ? ++g : --g)
          d(a[e], b[e]);
        return 0 < f.length ? f.join('') : '0';
      }
      function f(a, b, c, e, f, g, h, k, A) {
        var z = +f, D = +g, v = +h, C = -k, I = +(f * z + g * D + h * v - k * C), J = z * I + -0 * D + -0 * v - -0 * C, K = -0 * z + D * I - -0 * v + -0 * C, H = -0 * z + -0 * D + v * I - -0 * C, z = -0 * z + -0 * D - -0 * v + C * I;
        f = f * J + g * K + h * H - k * z;
        J /= f;
        K /= f;
        H /= f;
        k = z / f;
        f = a * J + b * K + c * H - e * k;
        g = a * K + b * J - c * k + e * H;
        h = a * H + b * k + c * J - e * K;
        a = a * k + b * H - c * K + e * J;
        if ('undefined' !== typeof A)
          A.w = f, A.x = g, A.y = h, A.xy = a;
        else
          return d(f, g, h, a);
      }
      Sk.ffi.checkFunctionArgs('defineEuclidean2', arguments, 2, 2);
      Sk.builtin.defineUnits(a, b);
      var g = [
          Sk.ffi.PyType.FLOAT,
          Sk.ffi.PyType.INT,
          Sk.ffi.PyType.LONG
        ], h = [
          'Euclidean2',
          g
        ], k = [
          'Euclidean2',
          'Unit'
        ];
      a.ScalarE2 = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('ScalarE2', arguments, 1, 1);
        Sk.ffi.checkArgType('w', g, Sk.ffi.isNum(a), a);
        return d(Sk.ffi.remapToJs(a), 0, 0, 0);
      });
      a.VectorE2 = Sk.ffi.functionPy(function (a, b) {
        Sk.ffi.checkFunctionArgs('VectorE2', arguments, 2, 2);
        Sk.ffi.checkArgType('x', g, Sk.ffi.isNum(a), a);
        Sk.ffi.checkArgType('y', g, Sk.ffi.isNum(b), b);
        return d(0, Sk.ffi.remapToJs(a), Sk.ffi.remapToJs(b), 0);
      });
      a.PseudoscalarE2 = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('PseudoscalarE2', arguments, 1, 1);
        Sk.ffi.checkArgType('xy', g, Sk.ffi.isNum(a), a);
        return d(0, 0, 0, Sk.ffi.remapToJs(a));
      });
      a.Euclidean2 = Sk.ffi.buildClass(a, function (l, m) {
        m.__init__ = Sk.ffi.functionPy(function (a, c, d, e, f) {
          Sk.ffi.checkMethodArgs('Euclidean2', arguments, 1, 4);
          switch (Sk.ffi.getType(c)) {
          case Sk.ffi.PyType.FLOAT:
          case Sk.ffi.PyType.INT:
          case Sk.ffi.PyType.LONG:
            Sk.ffi.checkMethodArgs('Euclidean2', arguments, 4, 4);
            Sk.ffi.checkArgType('w', g, Sk.ffi.isNum(c), c);
            Sk.ffi.checkArgType('x', g, Sk.ffi.isNum(d), d);
            Sk.ffi.checkArgType('y', g, Sk.ffi.isNum(e), e);
            Sk.ffi.checkArgType('xy', g, Sk.ffi.isNum(f), f);
            Sk.ffi.referenceToPy(new b.Euclidean2(Sk.ffi.remapToJs(c), Sk.ffi.remapToJs(d), Sk.ffi.remapToJs(e), Sk.ffi.remapToJs(f)), 'Euclidean2', void 0, a);
            break;
          case Sk.ffi.PyType.INSTANCE:
            Sk.ffi.checkMethodArgs('Euclidean2', arguments, 1, 1);
            Sk.ffi.checkArgType('w', g, Sk.ffi.isInstance(c, 'Euclidean2'), c);
            Sk.ffi.referenceToPy(Sk.ffi.remapToJs(c), 'Euclidean2', void 0, a);
            break;
          default:
            Sk.ffi.checkArgType('w', g, !1, c);
          }
        });
        m.__add__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          if (Sk.ffi.isNum(b))
            return d(c.w + e, c.x, c.y, c.xy);
          if (Sk.ffi.isInstance(b, 'Euclidean2'))
            return d(c.w + e.w, c.x + e.x, c.y + e.y, c.xy + e.xy);
          Sk.ffi.checkRhsOperandType('add', h, Sk.ffi.isNum(b), b);
        });
        m.__radd__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkLhsOperandType('add', h, Sk.ffi.isNum(b), b);
          var c = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(a);
          return d(c + e.w, e.x, e.y, e.xy);
        });
        m.__iadd__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
          if (Sk.ffi.isNum(b))
            return c.w += d, a;
          if (Sk.ffi.isInstance(b, 'Euclidean2'))
            return c.w += d.w, c.x += d.x, c.y += d.y, c.xy += d.xy, a;
          Sk.ffi.checkRhsOperandType('add', h, Sk.ffi.isNum(b), b);
        });
        m.__sub__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          if (Sk.ffi.isNum(b))
            return d(c.w - e, c.x, c.y, c.xy);
          if (Sk.ffi.isInstance(b, 'Euclidean2'))
            return d(c.w - e.w, c.x - e.x, c.y - e.y, c.xy - e.xy);
          Sk.ffi.checkRhsOperandType('subtract', h, Sk.ffi.isNum(b), b);
        });
        m.__rsub__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkLhsOperandType('add', h, Sk.ffi.isNum(b), b);
          var c = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(a);
          return d(c - e.w, -e.x, -e.y, -e.xy);
        });
        m.__isub__ = Sk.ffi.functionPy(function (a, b) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          c(e) ? d.w -= e : (d.w -= e.w, d.x -= e.x, d.y -= e.y, d.xy -= e.xy);
          return a;
        });
        m.__mul__ = Sk.ffi.functionPy(function (b, c) {
          switch (Sk.ffi.getType(c)) {
          case Sk.ffi.PyType.INSTANCE:
            switch (Sk.ffi.typeName(c)) {
            case 'Euclidean2':
              var e = Sk.ffi.remapToJs(b), f = Sk.ffi.remapToJs(c), g = e.w, h = e.x, l = e.y, e = e.xy, m = f.w, D = f.x, v = f.y, f = f.xy;
              return d(g * m + h * D + l * v - e * f, g * D + h * m - l * f + e * v, g * v + h * f + l * m - e * D, g * f + h * v - l * D + e * m);
            case 'Unit':
              return Sk.ffi.callsim(a.Measure, b, c);
            default:
              Sk.ffi.checkLhsOperandType('multiply', k, !1, c);
            }
          case Sk.ffi.PyType.FLOAT:
          case Sk.ffi.PyType.INT:
          case Sk.ffi.PyType.LONG:
            return e = Sk.ffi.remapToJs(b), f = Sk.ffi.remapToJs(c), d(e.w * f, e.x * f, e.y * f, e.xy * f);
          default:
            Sk.ffi.checkLhsOperandType('multiply', k, !1, c);
          }
        });
        m.__rmul__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (c(b))
            return d(b * a.w, b * a.x, b * a.y, b * a.xy);
          throw new Sk.builtin.AssertionError('' + JSON.stringify(b, null, 2) + ' * ' + JSON.stringify(a, null, 2));
        });
        m.__imul__ = Sk.ffi.functionPy(function (a, b) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          if (c(e))
            d.w *= e, d.x *= e, d.y *= e, d.xy *= e;
          else {
            var f = d.w, g = d.x, h = d.y, l = d.xy, k = e.w, m = e.x, C = e.y, e = e.xy;
            d.w = f * k + g * m + h * C - l * e;
            d.x = f * m + g * k - h * e + l * C;
            d.y = f * C + g * e + h * k - l * m;
            d.xy = f * e + g * C - h * m + l * k;
          }
          return a;
        });
        m.__div__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          return c(b) ? f(a.w, a.x, a.y, a.xy, b, 0, 0, 0, void 0) : f(a.w, a.x, a.y, a.xy, b.w, b.x, b.y, b.xy, void 0);
        });
        m.__rdiv__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (c(b))
            return f(b, 0, 0, 0, a.w, a.x, a.y, a.xy, void 0);
          throw new Sk.builtin.AssertionError('' + JSON.stringify(b, null, 2) + ' / ' + JSON.stringify(a, null, 2));
        });
        m.__idiv__ = Sk.ffi.functionPy(function (a, b) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          c(e) ? f(d.w, d.x, d.y, d.xy, e, 0, 0, 0, d) : f(d.w, d.x, d.y, d.xy, e.w, e.x, e.y, e.xy, d);
          return a;
        });
        m.__xor__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          if (c(b))
            return d(a.w * b, a.x * b, a.y * b, a.xy * b);
          var e = a.w, f = a.x, g = a.y, h = b.w, l = b.x, k = b.y;
          return d(e * h, e * l + f * h, e * k + g * h, e * b.xy + f * k - g * l + a.xy * h);
        });
        m.__rxor__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (c(b))
            return d(b * a.w, b * a.x, b * a.y, b * a.xy);
          throw new Sk.builtin.AssertionError('' + JSON.stringify(b, null, 2) + ' ^ ' + JSON.stringify(a, null, 2));
        });
        m.__ixor__ = Sk.ffi.functionPy(function (a, b) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          if (c(e))
            d.w *= e, d.x *= e, d.y *= e, d.xy *= e;
          else {
            var f = d.w, g = d.x, h = d.y, l = d.xy, k = e.w, m = e.x, C = e.y, e = e.xy;
            d.w = f * k;
            d.x = f * m + g * k;
            d.y = f * C + h * k;
            d.xy = f * e + g * C - h * m + l * k;
          }
          return a;
        });
        m.__lshift__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          if (c(b))
            return d(a.w * b, 0, 0, 0);
          var e = a.w, f = a.x, g = a.y, h = b.x, k = b.y, l = b.xy;
          return d(e * b.w + f * h + g * k - a.xy * l, e * h - g * l, e * k + f * l, e * l);
        });
        m.__rlshift__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (c(b))
            return d(b * a.w, b * a.x, b * a.y, b * a.xy);
          throw new Sk.builtin.AssertionError('' + JSON.stringify(b, null, 2) + ' << ' + JSON.stringify(a, null, 2));
        });
        m.__ilshift__ = Sk.ffi.functionPy(function (a, b) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          if (c(e))
            d.w *= e, d.x = 0, d.y = 0, d.xy = 0;
          else {
            var f = d.w, g = d.x, h = d.y, k = e.x, l = e.y, m = e.xy;
            d.w = f * e.w + g * k + h * l - d.xy * m;
            d.x = f * k - h * m;
            d.y = f * l + g * m;
            d.xy = f * m;
          }
          return a;
        });
        m.__rshift__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          if (c(b))
            return d(a.w * b, -a.x * b, -a.y * b, a.xy * b);
          var e = a.x, f = a.y, g = a.xy, h = b.w, k = b.x, l = b.y;
          return d(a.w * h + e * k + f * l - g * b.xy, +e * h + g * l, +f * h - g * k, g * h);
        });
        m.__rrshift__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (c(b))
            return d(b * a.w, 0, 0, 0);
          throw new Sk.builtin.AssertionError('' + JSON.stringify(b, null, 2) + ' >> ' + JSON.stringify(a, null, 2));
        });
        m.__irshift__ = Sk.ffi.functionPy(function (a, b) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          if (c(e)) {
            var f = d.w, g = d.x, h = d.y, k = d.xy, l = e, m = 0, C = 0, I = 0;
            d.w *= e;
            d.x *= -e;
            d.y *= -e;
            d.xy *= e;
          } else
            f = d.w, g = d.x, h = d.y, k = d.xy, l = e.w, m = e.x, C = e.y, I = e.xy, d.w = f * l + g * m + h * C - k * I, d.x = +g * l + k * C, d.y = +h * l - k * m, d.xy = k * l;
          return a;
        });
        m.nb$negative = function () {
          var a = Sk.ffi.remapToJs(this);
          return d(-a.w, -a.x, -a.y, -a.xy);
        };
        m.nb$positive = function () {
          return this;
        };
        m.nb$invert = function () {
          var a = Sk.ffi.remapToJs(this);
          return d(a.w, a.x, a.y, -a.xy);
        };
        m.__getitem__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          switch (b) {
          case 0:
            return d(a.w, 0, 0, 0);
          case 1:
            return d(0, a.x, a.y, 0);
          case 2:
            return d(0, 0, 0, a.xy);
          }
        });
        m.__abs__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.numberToFloatPy(Math.sqrt(a.w * a.w + a.x * a.x + a.y * a.y - a.xy * a.xy));
        });
        m.__cliffordConjugate__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('cliffordConjugate', arguments, 0, 0);
          var b = Sk.ffi.remapToJs(a);
          return d(b.w, -b.x, -b.y, -b.xy);
        });
        m.__cos__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('cos', arguments, 0, 0);
          var b = Sk.ffi.remapToJs(a), c = b.w, e = b.xy, b = Sk.math.cos(c), f = (Math.pow(Math.E, e) + Math.pow(Math.E, -e)) / 2, c = Sk.math.sin(c), e = (Math.pow(Math.E, e) - Math.pow(Math.E, -e)) / 2;
          return d(b * f, 0, 0, -c * e);
        });
        m.__sin__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('sin', arguments, 0, 0);
          var b = Sk.ffi.remapToJs(a), c = b.w, e = b.xy, b = Sk.math.cos(c), f = (Math.pow(Math.E, e) + Math.pow(Math.E, -e)) / 2, c = Sk.math.sin(c), e = (Math.pow(Math.E, e) - Math.pow(Math.E, -e)) / 2;
          return d(c * f, 0, 0, b * e);
        });
        m.__exp__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('exp', arguments, 0, 0);
          var b = Sk.ffi.remapToJs(a), c = b.xy, b = Math.exp(b.w), e = Sk.math.cos(c), c = Sk.math.sin(c);
          return d(b * e, 0, 0, b * c);
        });
        m.__sqrt__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('sqrt', arguments, 0, 0);
          var b = Sk.ffi.remapToJs(a);
          return d(Math.sqrt(b.w), 0, 0, 0);
        });
        m.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('Euclidean2(' + [
            a.w,
            a.x,
            a.y,
            a.xy
          ].map(function (a) {
            return String(a);
          }).join(', ') + ')');
        });
        m.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return a.isNaN() ? Sk.ffi.stringToPy('NaN') : Sk.ffi.stringToPy(e([
            a.w,
            a.x,
            a.y,
            a.xy
          ], [
            '1',
            'e1',
            'e2',
            'I'
          ], '*'));
        });
        m.__eq__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          return a.w === b.w && a.x === b.x && a.y === b.y && a.xy === b.xy;
        });
        m.__ne__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          return a.w !== b.w || a.x !== b.x || a.y !== b.y || a.xy !== b.xy;
        });
        m.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var e = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'w':
            return Sk.ffi.numberToFloatPy(e.w);
          case 'x':
            return Sk.ffi.numberToFloatPy(e.x);
          case 'y':
            return Sk.ffi.numberToFloatPy(e.y);
          case 'xy':
            return Sk.ffi.numberToFloatPy(e.xy);
          case 'clone':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
              });
              b.__call__ = Sk.ffi.functionPy(function (a) {
                return d(e.w, e.x, e.y, e.xy);
              });
            }, 'clone', []));
          case 'magnitude':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
              });
              b.__call__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.numberToFloatPy(Math.sqrt(e.w * e.w + e.x * e.x + e.y * e.y - e.xy * e.xy));
              });
            }, 'magnitude', []));
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('Euclidean2');
          }
        });
        m.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'w':
          case 'x':
          case 'y':
          case 'xy':
            Sk.ffi.checkArgType(b, [
              Sk.ffi.PyType.FLOAT,
              Sk.ffi.PyType.INT,
              Sk.ffi.PyType.LONG
            ], Sk.ffi.isNum(c), c);
            a[b] = Sk.ffi.remapToJs(c);
            break;
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('Euclidean2');
          }
        });
      }, 'Euclidean2', []);
    };
  }.call(this));
  Sk.e3ga = Sk.e3ga || {};
  Sk.e3ga.EUCLIDEAN_3 = 'Euclidean3';
  Sk.e3ga.SCALAR_E3 = 'ScalarE3';
  Sk.e3ga.VECTOR_E3 = 'VectorE3';
  Sk.e3ga.BIVECTOR_E3 = 'BivectorE3';
  Sk.e3ga.PSEUDOSCALAR_E3 = 'PseudoscalarE3';
  (function () {
    Sk.builtin.defineEuclidean3 = function (a, b, c) {
      function d(a) {
        return 'number' === typeof a;
      }
      function e(a) {
        return Sk.ffi.isInstance(a, Sk.e3ga.EUCLIDEAN_3);
      }
      function f(b, c, d, e, f, g, h, k, l) {
        b = Sk.ffi.numberToFloatPy(b);
        c = Sk.ffi.numberToFloatPy(c);
        d = Sk.ffi.numberToFloatPy(d);
        e = Sk.ffi.numberToFloatPy(e);
        f = Sk.ffi.numberToFloatPy(f);
        g = Sk.ffi.numberToFloatPy(g);
        h = Sk.ffi.numberToFloatPy(h);
        k = Sk.ffi.numberToFloatPy(k);
        l = Sk.ffi.booleanToPy(l);
        return Sk.ffi.callsim(a[Sk.e3ga.EUCLIDEAN_3], b, c, d, e, f, g, h, k, l);
      }
      function g(a, b) {
        var c, d, e, f, g;
        e = [];
        c = function (a, b) {
          var c;
          if (0 !== a) {
            0 <= a ? 0 < e.length && e.push('+') : e.push('-');
            c = Math.abs(a);
            if (1 === c)
              return e.push(b);
            e.push(c.toString());
            if ('1' !== b)
              return e.push('*'), e.push(b);
          }
        };
        d = f = 0;
        for (g = a.length - 1; 0 <= g ? f <= g : f >= g; d = 0 <= g ? ++f : --f)
          c(a[d], b[d]);
        return 0 < e.length ? e.join('') : '0';
      }
      function h(a, b, c, d, e, f, g, h, k, l, n, m, p, q, y, F, x) {
        a = +a;
        b = +b;
        c = +c;
        d = +d;
        e = +e;
        f = +f;
        g = +g;
        h = +h;
        k = +k;
        l = +l;
        n = +n;
        m = +m;
        p = +p;
        q = +q;
        y = +y;
        F = +F;
        var t = 0;
        switch (~~(x | 0)) {
        case 0:
          t = +(a * k + b * l + c * n + d * m - e * p - f * q - g * y - h * F);
          break;
        case 1:
          t = +(a * l + b * k - c * p + d * y + e * n - f * F - g * m - h * q);
          break;
        case 2:
          t = +(a * n + b * p + c * k - d * q - e * l + f * m - g * F - h * y);
          break;
        case 3:
          t = +(a * m - b * y + c * q + d * k - e * F - f * n + g * l - h * p);
          break;
        case 4:
          t = +(a * p + b * n - c * l + d * F + e * k - f * y + g * q + h * m);
          break;
        case 5:
          t = +(a * q + b * F + c * m - d * n + e * y + f * k - g * p + h * l);
          break;
        case 6:
          t = +(a * y - b * m + c * F + d * l - e * q + f * p + g * k + h * n);
          break;
        case 7:
          t = +(a * F + b * q + c * y + d * p + e * m + f * l + g * n + h * k);
        }
        return +t;
      }
      function k(a, b, c, d, e, f, g, h, k, l, n, m, p, q, y, F, x) {
        a = +a;
        b = +b;
        c = +c;
        d = +d;
        e = +e;
        f = +f;
        g = +g;
        k = +k;
        l = +l;
        n = +n;
        m = +m;
        p = +p;
        q = +q;
        y = +y;
        var t = 0;
        switch (~~(x | 0)) {
        case 0:
          t = +(a * k);
          break;
        case 1:
          t = +(a * l + b * k);
          break;
        case 2:
          t = +(a * n + c * k);
          break;
        case 3:
          t = +(a * m + d * k);
          break;
        case 4:
          t = +(a * p + b * n - c * l + e * k);
          break;
        case 5:
          t = +(a * q + c * m - d * n + f * k);
          break;
        case 6:
          t = +(a * y - b * m + d * l + g * k);
          break;
        case 7:
          t = +(a * +F + b * q + c * y + d * p + e * m + f * l + g * n + +h * k);
        }
        return +t;
      }
      function l(a, b, c, d, e, f, g, h, k, l, n, m, p, q, y, F, x) {
        a = +a;
        b = +b;
        c = +c;
        d = +d;
        e = +e;
        f = +f;
        g = +g;
        l = +l;
        n = +n;
        m = +m;
        p = +p;
        q = +q;
        y = +y;
        F = +F;
        var t = 0;
        switch (~~(x | 0)) {
        case 0:
          t = +(a * +k + b * l + c * n + d * m - e * p - f * q - g * y - +h * F);
          break;
        case 1:
          t = +(a * l - c * p + d * y - f * F);
          break;
        case 2:
          t = +(a * n + b * p - d * q - g * F);
          break;
        case 3:
          t = +(a * m - b * y + c * q - e * F);
          break;
        case 4:
          t = +(a * p + d * F);
          break;
        case 5:
          t = +(a * q + b * F);
          break;
        case 6:
          t = +(a * y + c * F);
          break;
        case 7:
          t = +(a * F);
        }
        return +t;
      }
      function m(a, b, c, d, e, f, g, h, k, l, n, m, p, q, y, F, x) {
        b = +b;
        c = +c;
        d = +d;
        e = +e;
        f = +f;
        g = +g;
        h = +h;
        k = +k;
        l = +l;
        n = +n;
        m = +m;
        p = +p;
        q = +q;
        y = +y;
        var t = 0;
        switch (~~(x | 0)) {
        case 0:
          t = +(+a * k + b * l + c * n + d * m - e * p - f * q - g * y - h * +F);
          break;
        case 1:
          t = +(+b * k + e * n - g * m - h * q);
          break;
        case 2:
          t = +(+c * k - e * l + f * m - h * y);
          break;
        case 3:
          t = +(+d * k - f * n + g * l - h * p);
          break;
        case 4:
          t = +(+e * k + h * m);
          break;
        case 5:
          t = +(+f * k + h * l);
          break;
        case 6:
          t = +(+g * k + h * n);
          break;
        case 7:
          t = +(+h * k);
        }
        return +t;
      }
      function n(a, b, c, d, e, g, k, l, n, m, p, q, G, L, y, F, x) {
        var t = +n, u = +m, E = +p, B = -q, M = +G, N = -L, O = -y, P = -F, T = h(n, m, p, G, q, y, -L, F, t, u, E, M, B, O, -N, P, 0), Q = h(n, m, p, G, q, y, -L, F, t, u, E, M, B, O, -N, P, 1), R = h(n, m, p, G, q, y, -L, F, t, u, E, M, B, O, -N, P, 2), S = h(n, m, p, G, q, y, -L, F, t, u, E, M, B, O, -N, P, 3), U = +T, V = -Q, W = -R, X = -S, Y = h(t, u, E, M, B, O, -N, P, U, V, W, X, -0, -0, 0, 0, 0), Z = h(t, u, E, M, B, O, -N, P, U, V, W, X, -0, -0, 0, 0, 1), $ = h(t, u, E, M, B, O, -N, P, U, V, W, X, -0, -0, 0, 0, 2), T = h(t, u, E, M, B, O, -N, P, U, V, W, X, -0, -0, 0, 0, 4), Q = h(t, u, E, M, B, O, -N, P, U, V, W, X, -0, -0, 0, 0, 3), R = -h(t, u, E, M, B, O, -N, P, U, V, W, X, -0, -0, 0, 0, 6), S = h(t, u, E, M, B, O, -N, P, U, V, W, X, -0, -0, 0, 0, 5), t = h(t, u, E, M, B, O, -N, P, U, V, W, X, -0, -0, 0, 0, 7);
        G = h(n, m, p, G, q, y, -L, F, Y, Z, $, Q, T, S, -R, t, 0);
        n = Y / G;
        m = Z / G;
        p = $ / G;
        q = T / G;
        Q /= G;
        R /= G;
        S /= G;
        E = t / G;
        G = h(a, b, c, e, d, k, -g, l, n, m, p, Q, q, S, -R, E, 0);
        L = h(a, b, c, e, d, k, -g, l, n, m, p, Q, q, S, -R, E, 1);
        y = h(a, b, c, e, d, k, -g, l, n, m, p, Q, q, S, -R, E, 2);
        F = h(a, b, c, e, d, k, -g, l, n, m, p, Q, q, S, -R, E, 4);
        T = h(a, b, c, e, d, k, -g, l, n, m, p, Q, q, S, -R, E, 3);
        u = -h(a, b, c, e, d, k, -g, l, n, m, p, Q, q, S, -R, E, 6);
        t = h(a, b, c, e, d, k, -g, l, n, m, p, Q, q, S, -R, E, 5);
        a = h(a, b, c, e, d, k, -g, l, n, m, p, Q, q, S, -R, E, 7);
        b = -u;
        if ('undefined' !== typeof x)
          x.w = G, x.x = L, x.y = y, x.z = T, x.xy = F, x.yz = t, x.zx = b, x.xyz = a;
        else
          return f(G, L, y, T, F, t, b, a);
      }
      function p(a, b) {
        switch (b) {
        case 0:
          return a.w;
        case 1:
          return a.x;
        case 2:
          return a.y;
        case 3:
          return a.z;
        case 4:
          return a.xy;
        case 5:
          return a.yz;
        case 6:
          return a.zx;
        case 7:
          return a.xyz;
        default:
          throw Sk.ffi.assertionError('' + b + ' is not a valid multivector coordinate index');
        }
      }
      function q(a, b, c, d, e) {
        var f, g, h, k, l, n, m, p, q, y, F, x, t, u, E, B, M, N, O, P;
        d = b.quaternion.w;
        f = b.vector.x;
        g = b.vector.y;
        h = b.vector.z;
        k = -b.quaternion.z;
        l = -b.quaternion.x;
        n = -b.quaternion.y;
        b = b.xyz;
        m = c.quaternion.w;
        p = c.vector.x;
        q = c.vector.y;
        y = c.vector.z;
        F = -c.quaternion.z;
        x = -c.quaternion.x;
        t = -c.quaternion.y;
        u = c.xyz;
        c = a(d, f, g, h, k, l, n, b, m, p, q, y, F, x, t, u, 0);
        E = a(d, f, g, h, k, l, n, b, m, p, q, y, F, x, t, u, 1);
        B = a(d, f, g, h, k, l, n, b, m, p, q, y, F, x, t, u, 2);
        M = a(d, f, g, h, k, l, n, b, m, p, q, y, F, x, t, u, 3);
        N = a(d, f, g, h, k, l, n, b, m, p, q, y, F, x, t, u, 4);
        O = a(d, f, g, h, k, l, n, b, m, p, q, y, F, x, t, u, 5);
        P = a(d, f, g, h, k, l, n, b, m, p, q, y, F, x, t, u, 6);
        a = a(d, f, g, h, k, l, n, b, m, p, q, y, F, x, t, u, 7);
        return e(c, E, B, M, N, O, P, a);
      }
      Sk.ffi.checkFunctionArgs('defineEuclidean3', arguments, 3, 3);
      Sk.builtin.defineVector3(a, b);
      Sk.builtin.defineQuaternion(a, b);
      Sk.builtin.defineUnits(a, c);
      b.Euclidean3 = function (a, b, c, d) {
        if ('object' !== typeof a)
          throw Error('43a75b65-8614-4836-9829-377eaeee7cfe');
        if ('object' !== typeof b)
          throw Error('89fb1d18-dc26-4149-913d-58f192c161d7');
        if ('number' !== typeof c)
          throw Error('09e5e46b-fdf4-4720-9262-5c2503c84dc6');
        this.vector = a;
        this.quaternion = b;
        this._pseudo = c;
        this._mutable = 'boolean' === typeof d ? d : !0;
      };
      b.Euclidean3.prototype = {
        constructor: b.Euclidean3,
        get w() {
          return this.quaternion.w;
        },
        set w(a) {
          this.checkMutable();
          this.quaternion.w = a;
        },
        get x() {
          return this.vector.x;
        },
        set x(a) {
          this.checkMutable();
          this.vector.x = a;
        },
        get y() {
          return this.vector.y;
        },
        set y(a) {
          this.checkMutable();
          this.vector.y = a;
        },
        get z() {
          return this.vector.z;
        },
        set z(a) {
          this.checkMutable();
          this.vector.z = a;
        },
        get xy() {
          return -this.quaternion.z;
        },
        set xy(a) {
          this.checkMutable();
          this.quaternion.z = -a;
        },
        get yz() {
          return -this.quaternion.x;
        },
        set yz(a) {
          this.checkMutable();
          this.quaternion.x = -a;
        },
        get zx() {
          return -this.quaternion.y;
        },
        set zx(a) {
          this.checkMutable();
          this.quaternion.y = -a;
        },
        get xyz() {
          return this._pseudo;
        },
        set xyz(a) {
          this.checkMutable();
          this._pseudo = a;
        },
        get mutable() {
          return this._mutable;
        },
        set mutable(a) {
          this._mutable = a;
        },
        checkMutable: function () {
          if (!this._mutable)
            throw Sk.ffi.assertionError('Quantity is not mutable');
        }
      };
      a[Sk.e3ga.SCALAR_E3] = Sk.ffi.functionPy(function (a, b) {
        Sk.ffi.checkFunctionArgs(Sk.e3ga.SCALAR_E3, arguments, 1, 2);
        Sk.ffi.checkArgType('w', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(a), a);
        Sk.ffi.isDefined(b) && Sk.ffi.checkArgType('mutable', Sk.ffi.PyType.BOOL, Sk.ffi.isBool(b), b);
        return f(Sk.ffi.numberToJs(a), 0, 0, 0, 0, 0, 0, 0, Sk.ffi.remapToJs(b));
      });
      a[Sk.e3ga.VECTOR_E3] = Sk.ffi.functionPy(function (a, b, c, d) {
        Sk.ffi.checkFunctionArgs(Sk.e3ga.VECTOR_E3, arguments, 3, 4);
        Sk.ffi.checkArgType('x', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(a), a);
        Sk.ffi.checkArgType('y', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(b), b);
        Sk.ffi.checkArgType('z', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(c), c);
        Sk.ffi.isDefined(d) && Sk.ffi.checkArgType('mutable', Sk.ffi.PyType.BOOL, Sk.ffi.isBool(d), d);
        var e = Sk.ffi.numberToJs(a), g = Sk.ffi.numberToJs(b), h = Sk.ffi.numberToJs(c);
        return f(0, e, g, h, 0, 0, 0, 0, Sk.ffi.remapToJs(d));
      });
      a[Sk.e3ga.BIVECTOR_E3] = Sk.ffi.functionPy(function (a, b, c, d) {
        Sk.ffi.checkFunctionArgs(Sk.e3ga.BIVECTOR_E3, arguments, 3, 4);
        Sk.ffi.checkArgType('xy', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(a), a);
        Sk.ffi.checkArgType('yz', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(b), b);
        Sk.ffi.checkArgType('zx', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(c), c);
        Sk.ffi.isDefined(d) && Sk.ffi.checkArgType('mutable', Sk.ffi.PyType.BOOL, Sk.ffi.isBool(d), d);
        a = Sk.ffi.numberToJs(a);
        b = Sk.ffi.numberToJs(b);
        c = Sk.ffi.numberToJs(c);
        return f(0, 0, 0, 0, a, b, c, 0, Sk.ffi.remapToJs(d));
      });
      a[Sk.e3ga.PSEUDOSCALAR_E3] = Sk.ffi.functionPy(function (a, b) {
        Sk.ffi.checkFunctionArgs(Sk.e3ga.PSEUDOSCALAR_E3, arguments, 1, 2);
        Sk.ffi.checkArgType('xyz', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(a), a);
        Sk.ffi.isDefined(b) && Sk.ffi.checkArgType('mutable', Sk.ffi.PyType.BOOL, Sk.ffi.isBool(b), b);
        a = Sk.ffi.numberToJs(a);
        return f(0, 0, 0, 0, 0, 0, 0, a, Sk.ffi.remapToJs(b));
      });
      a[Sk.e3ga.EUCLIDEAN_3] = Sk.ffi.buildClass(a, function (s, r) {
        r.__init__ = Sk.ffi.functionPy(function (a, c, d, e, f, g, h, k, l, n) {
          Sk.ffi.checkMethodArgs(Sk.e3ga.EUCLIDEAN_3, arguments, 1, 9);
          switch (Sk.ffi.getType(c)) {
          case Sk.ffi.PyType.FLOAT:
          case Sk.ffi.PyType.INT:
            Sk.ffi.checkMethodArgs(Sk.e3ga.EUCLIDEAN_3, arguments, 8, 9);
            Sk.ffi.checkArgType('w', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(c), c);
            Sk.ffi.checkArgType('x', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(d), d);
            Sk.ffi.checkArgType('y', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(e), e);
            Sk.ffi.checkArgType('z', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(f), f);
            Sk.ffi.checkArgType('xy', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(g), g);
            Sk.ffi.checkArgType('yz', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(h), h);
            Sk.ffi.checkArgType('zx', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(k), k);
            Sk.ffi.checkArgType('xyz', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(l), l);
            Sk.ffi.isDefined(n) && Sk.ffi.checkArgType('mutable', Sk.ffi.PyType.BOOL, Sk.ffi.isBool(n), n);
            c = Sk.ffi.remapToJs(c);
            d = Sk.ffi.remapToJs(d);
            e = Sk.ffi.remapToJs(e);
            f = Sk.ffi.remapToJs(f);
            g = Sk.ffi.remapToJs(g);
            h = Sk.ffi.remapToJs(h);
            k = Sk.ffi.remapToJs(k);
            l = Sk.ffi.remapToJs(l);
            var m = Sk.ffi.isDefined(n) ? Sk.ffi.remapToJs(n) : !0, p = new b.Vector3(d, e, f), q = new b.Quaternion(-h, -k, -g, c);
            Sk.ffi.referenceToPy(new b.Euclidean3(p, q, l, m), Sk.e3ga.EUCLIDEAN_3, void 0, a);
            break;
          case Sk.ffi.PyType.INSTANCE:
            Sk.ffi.checkMethodArgs(Sk.e3ga.EUCLIDEAN_3, arguments, 1, 1);
            Sk.ffi.referenceToPy(Sk.ffi.remapToJs(c), Sk.e3ga.EUCLIDEAN_3, void 0, a);
            break;
          default:
            throw new Sk.builtin.AssertionError('09eaed05-6d9d-4ded-a499-e4c480a9ed68, getType(w) => ' + Sk.ffi.getType(c));
          }
        });
        r.__add__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = c.vector, e = c.quaternion, g = Sk.ffi.remapToJs(b);
          if (Sk.ffi.isNum(b))
            return f(e.w + g, d.x, d.y, d.z, -e.z, -e.x, -e.y, c.xyz);
          if (Sk.ffi.isInstance(b, Sk.e3ga.EUCLIDEAN_3))
            return f(e.w + g.quaternion.w, d.x + g.vector.x, d.y + g.vector.y, d.z + g.vector.z, -(e.z + g.quaternion.z), -(e.x + g.quaternion.x), -(e.y + g.quaternion.y), c.xyz + g.xyz);
          throw Sk.ffi.err.operand('other').toOperation('add').mustHaveType([
            Sk.ffi.PyType.FLOAT,
            Sk.e3ga.EUCLIDEAN_3
          ]);
        });
        r.__radd__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(b), d = Sk.ffi.remapToJs(a), e = d.vector, g = d.quaternion;
          if (Sk.ffi.isNum(b))
            return f(c + g.w, e.x, e.y, e.z, -g.z, -g.x, -g.y, d.xyz);
          throw Sk.ffi.err.operand('other').toOperation('add').mustHaveType([
            Sk.ffi.PyType.FLOAT,
            Sk.e3ga.EUCLIDEAN_3
          ]);
        });
        r.__iadd__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = c.vector, f = c.quaternion, g = Sk.ffi.remapToJs(b);
          if (Sk.ffi.isNum(b))
            f.w += g;
          else if (e(b)) {
            var h = g.vector, k = g.quaternion;
            f.w += k.w;
            d.x += h.x;
            d.y += h.y;
            d.z += h.z;
            f.z += k.z;
            f.x += k.x;
            f.y += k.y;
            c.xyz += g.xyz;
          } else
            throw Sk.ffi.err.operand('other').toOperation('add').mustHaveType([
              Sk.ffi.PyType.FLOAT,
              Sk.e3ga.EUCLIDEAN_3
            ]);
          return a;
        });
        r.__sub__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = c.vector, e = c.quaternion, g = Sk.ffi.remapToJs(b);
          if (Sk.ffi.isNum(b))
            return f(e.w - g, d.x, d.y, d.z, -e.z, -e.x, -e.y, c.xyz);
          if (Sk.ffi.isInstance(b, Sk.e3ga.EUCLIDEAN_3)) {
            var h = g.vector, k = g.quaternion;
            return f(e.w - k.w, d.x - h.x, d.y - h.y, d.z - h.z, -(e.z - k.z), -(e.x - k.x), -(e.y - k.y), c.xyz - g.xyz);
          }
          throw Sk.ffi.err.operand('other').toOperation('subtract').mustHaveType([
            Sk.ffi.PyType.FLOAT,
            Sk.e3ga.EUCLIDEAN_3
          ]);
        });
        r.__rsub__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(b), d = Sk.ffi.remapToJs(a), e = d.vector, g = d.quaternion;
          if (Sk.ffi.isNum(b))
            return f(c - g.w, -e.x, -e.y, -e.z, g.z, g.x, g.y, -d.xyz);
          throw Sk.ffi.err.operand('other').toOperation('subtract').mustHaveType([
            Sk.ffi.PyType.FLOAT,
            Sk.e3ga.EUCLIDEAN_3
          ]);
        });
        r.__isub__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = c.vector, f = c.quaternion, g = Sk.ffi.remapToJs(b);
          if (Sk.ffi.isNum(b))
            f.w -= g;
          else if (e(b)) {
            var h = g.vector, k = g.quaternion;
            f.w -= k.w;
            d.x -= h.x;
            d.y -= h.y;
            d.z -= h.z;
            f.z -= k.z;
            f.x -= k.x;
            f.y -= k.y;
            c.xyz -= g.xyz;
          } else
            throw Sk.ffi.err.operand('other').toOperation('subtract').mustHaveType([
              Sk.ffi.PyType.FLOAT,
              Sk.e3ga.EUCLIDEAN_3
            ]);
          return a;
        });
        r.__mul__ = Sk.ffi.functionPy(function (b, c) {
          switch (Sk.ffi.getType(c)) {
          case Sk.ffi.PyType.INSTANCE:
            switch (Sk.ffi.typeName(c)) {
            case Sk.e3ga.EUCLIDEAN_3:
              var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c);
              return q(h, d, e, p, f);
            case 'Unit':
              return Sk.ffi.callsim(a.Measure, b, c);
            default:
              throw Sk.ffi.err.operand('other').toOperation('multiply').mustHaveType([
                Sk.ffi.PyType.FLOAT,
                Sk.e3ga.EUCLIDEAN_3,
                'Unit'
              ]);
            }
          case Sk.ffi.PyType.INT:
          case Sk.ffi.PyType.FLOAT:
            var d = Sk.ffi.remapToJs(b), e = d.vector, g = d.quaternion, k = Sk.ffi.remapToJs(c);
            return f(g.w * k, e.x * k, e.y * k, e.z * k, -g.z * k, -g.x * k, -g.y * k, d.xyz * k);
          default:
            throw Sk.ffi.err.operand('other').toOperation('multiply').mustHaveType([
              Sk.ffi.PyType.FLOAT,
              Sk.e3ga.EUCLIDEAN_3,
              'Unit'
            ]);
          }
        });
        r.__rmul__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = c.vector, e = c.quaternion;
          if (Sk.ffi.isNum(b)) {
            var g = Sk.ffi.remapToJs(b);
            return f(g * e.w, g * d.x, g * d.y, g * d.z, -g * e.z, -g * e.x, -g * e.y, g * c.xyz);
          }
          throw Sk.ffi.err.operand('other').toOperation('multiply').mustHaveType([
            Sk.ffi.PyType.FLOAT,
            Sk.e3ga.EUCLIDEAN_3,
            'Unit'
          ]);
        });
        r.__imul__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b), f = c.w, g = c.x, k = c.y, l = c.z, n = c.xy, m = c.yz, p = c.zx, q = c.xyz, s, r, x, t, u, E, B;
          d(e) ? (s = e, e = B = E = u = t = x = r = 0) : (s = e.w, r = e.x, x = e.y, t = e.z, u = e.xy, E = e.yz, B = e.zx, e = e.xyz);
          c.w = h(f, g, k, l, n, m, p, q, s, r, x, t, u, E, B, e, 0);
          c.x = h(f, g, k, l, n, m, p, q, s, r, x, t, u, E, B, e, 1);
          c.y = h(f, g, k, l, n, m, p, q, s, r, x, t, u, E, B, e, 2);
          c.z = h(f, g, k, l, n, m, p, q, s, r, x, t, u, E, B, e, 3);
          c.xy = h(f, g, k, l, n, m, p, q, s, r, x, t, u, E, B, e, 4);
          c.yz = h(f, g, k, l, n, m, p, q, s, r, x, t, u, E, B, e, 5);
          c.zx = h(f, g, k, l, n, m, p, q, s, r, x, t, u, E, B, e, 6);
          c.xyz = h(f, g, k, l, n, m, p, q, s, r, x, t, u, E, B, e, 7);
          return a;
        });
        r.__div__ = Sk.ffi.functionPy(function (b, d) {
          switch (Sk.ffi.getType(d)) {
          case Sk.ffi.PyType.INSTANCE:
            switch (Sk.ffi.typeName(d)) {
            case Sk.e3ga.EUCLIDEAN_3:
              var e = Sk.ffi.remapToJs(b), f = e.vector, g = e.quaternion, h = Sk.ffi.remapToJs(d), k = h.vector, l = h.quaternion;
              return n(g.w, f.x, f.y, -g.z, f.z, g.y, -g.x, e.xyz, l.w, k.x, k.y, -l.z, k.z, l.y, -l.x, h.xyz, void 0);
            case 'Unit':
              return e = Sk.ffi.remapToJs(d), f = new c.Rational(0, 1), f = new c.Unit(1, new c.Dimensions(f, f, f, f), e.labels), Sk.ffi.callsim(a.Measure, b, Sk.ffi.callsim(a.Unit, Sk.ffi.referenceToPy(f.div(e), 'Unit')));
            default:
              throw Sk.ffi.err.operand('other').toOperation('multiply').mustHaveType([
                Sk.ffi.PyType.FLOAT,
                Sk.e3ga.EUCLIDEAN_3,
                'Unit'
              ]);
            }
          case Sk.ffi.PyType.INT:
          case Sk.ffi.PyType.FLOAT:
            return e = Sk.ffi.remapToJs(b), f = e.vector, g = e.quaternion, h = Sk.ffi.remapToJs(d), n(g.w, f.x, f.y, -g.z, f.z, g.y, -g.x, e.xyz, h, 0, 0, 0, 0, 0, 0, 0, void 0);
          default:
            throw Sk.ffi.err.operand('other').toOperation('multiply').mustHaveType([
              Sk.ffi.PyType.FLOAT,
              Sk.e3ga.EUCLIDEAN_3,
              'Unit'
            ]);
          }
        });
        r.__rdiv__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (d(b))
            return n(b, 0, 0, 0, 0, 0, 0, 0, a.w, a.x, a.y, a.xy, a.z, -a.zx, a.yz, a.xyz, void 0);
          throw new Sk.builtin.AssertionError('' + JSON.stringify(b, null, 2) + ' / ' + JSON.stringify(a, null, 2));
        });
        r.__idiv__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          d(e) ? n(c.w, c.x, c.y, c.xy, c.z, -c.zx, c.yz, c.xyz, e, 0, 0, 0, 0, 0, 0, 0, c) : n(c.w, c.x, c.y, c.xy, c.z, -c.zx, c.yz, c.xyz, e.w, e.x, e.y, e.xy, e.z, -e.zx, e.yz, e.xyz, c);
          return a;
        });
        r.__mod__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
          return Sk.ffi.numberToFloatPy(c.x * d.x + c.y * d.y + c.z * d.z);
        });
        r.__xor__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          return d(b) ? f(a.w * b, a.x * b, a.y * b, a.z * b, a.xy * b, a.yz * b, a.zx * b, a.xyz * b) : q(k, a, b, p, f);
        });
        r.__rxor__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (d(b))
            return f(b * a.w, b * a.x, b * a.y, b * a.z, b * a.xy, b * a.yz, b * a.zx, b * a.xyz);
          throw new Sk.builtin.AssertionError();
        });
        r.__ixor__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b), f = c.w, g = c.x, h = c.y, l = c.z, n = c.xy, m = c.yz, p = c.zx, q = c.xyz, s, r, x, t, u, E, B;
          d(e) ? (s = e, e = B = E = u = t = x = r = 0) : (s = e.w, r = e.x, x = e.y, t = e.z, u = e.xy, E = e.yz, B = e.zx, e = e.xyz);
          c.w = k(f, g, h, l, n, m, p, q, s, r, x, t, u, E, B, e, 0);
          c.x = k(f, g, h, l, n, m, p, q, s, r, x, t, u, E, B, e, 1);
          c.y = k(f, g, h, l, n, m, p, q, s, r, x, t, u, E, B, e, 2);
          c.z = k(f, g, h, l, n, m, p, q, s, r, x, t, u, E, B, e, 3);
          c.xy = k(f, g, h, l, n, m, p, q, s, r, x, t, u, E, B, e, 4);
          c.yz = k(f, g, h, l, n, m, p, q, s, r, x, t, u, E, B, e, 5);
          c.zx = k(f, g, h, l, n, m, p, q, s, r, x, t, u, E, B, e, 6);
          c.xyz = k(f, g, h, l, n, m, p, q, s, r, x, t, u, E, B, e, 7);
          return a;
        });
        r.__lshift__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          return d(b) ? f(a.w * b, 0, 0, 0, 0, 0, 0, 0) : q(l, a, b, p, f);
        });
        r.__rlshift__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (d(b))
            return f(b * a.w, b * a.x, b * a.y, b * a.z, b * a.xy, b * a.yz, b * a.zx, b * a.xyz);
          throw new Sk.builtin.AssertionError();
        });
        r.__ilshift__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b), f = c.w, g = c.x, h = c.y, k = c.z, n = c.xy, m = c.yz, p = c.zx, q = c.xyz, s, r, x, t, u, E, B;
          d(e) ? (s = e, e = B = E = u = t = x = r = 0) : (s = e.w, r = e.x, x = e.y, t = e.z, u = e.xy, E = e.yz, B = e.zx, e = e.xyz);
          c.w = l(f, g, h, k, n, m, p, q, s, r, x, t, u, E, B, e, 0);
          c.x = l(f, g, h, k, n, m, p, q, s, r, x, t, u, E, B, e, 1);
          c.y = l(f, g, h, k, n, m, p, q, s, r, x, t, u, E, B, e, 2);
          c.z = l(f, g, h, k, n, m, p, q, s, r, x, t, u, E, B, e, 3);
          c.xy = l(f, g, h, k, n, m, p, q, s, r, x, t, u, E, B, e, 4);
          c.yz = l(f, g, h, k, n, m, p, q, s, r, x, t, u, E, B, e, 5);
          c.zx = l(f, g, h, k, n, m, p, q, s, r, x, t, u, E, B, e, 6);
          c.xyz = l(f, g, h, k, n, m, p, q, s, r, x, t, u, E, B, e, 7);
          return a;
        });
        r.__rshift__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          return d(b) ? f(a.w * b, a.x * b, a.y * b, a.z * b, a.xy * b, a.yz * b, a.zx * b, a.xyz * b) : q(m, a, b, p, f);
        });
        r.__rrshift__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (d(b))
            return f(b * a.w, 0, 0, 0, 0, 0, 0, 0);
          throw new Sk.builtin.AssertionError();
        });
        r.__irshift__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b), f = c.w, g = c.x, h = c.y, k = c.z, l = c.xy, n = c.yz, p = c.zx, q = c.xyz, s, r, x, t, u, E, B;
          d(e) ? (s = e, e = B = E = u = t = x = r = 0) : (s = e.w, r = e.x, x = e.y, t = e.z, u = e.xy, E = e.yz, B = e.zx, e = e.xyz);
          c.w = m(f, g, h, k, l, n, p, q, s, r, x, t, u, E, B, e, 0);
          c.x = m(f, g, h, k, l, n, p, q, s, r, x, t, u, E, B, e, 1);
          c.y = m(f, g, h, k, l, n, p, q, s, r, x, t, u, E, B, e, 2);
          c.z = m(f, g, h, k, l, n, p, q, s, r, x, t, u, E, B, e, 3);
          c.xy = m(f, g, h, k, l, n, p, q, s, r, x, t, u, E, B, e, 4);
          c.yz = m(f, g, h, k, l, n, p, q, s, r, x, t, u, E, B, e, 5);
          c.zx = m(f, g, h, k, l, n, p, q, s, r, x, t, u, E, B, e, 6);
          c.xyz = m(f, g, h, k, l, n, p, q, s, r, x, t, u, E, B, e, 7);
          return a;
        });
        r.__len__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.numberToFloatPy(8);
        });
        r.__pos__ = Sk.ffi.functionPy(function (a) {
          return a;
        });
        r.__neg__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = a.vector, c = a.quaternion;
          return f(-c.w, -b.x, -b.y, -b.z, c.z, c.x, c.y, -a.xyz);
        });
        r.__invert__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = a.vector, c = a.quaternion;
          return f(c.w, b.x, b.y, b.z, c.z, c.x, c.y, -a.xyz);
        });
        r.__eq__ = Sk.ffi.functionPy(function (a, b) {
          if (Sk.ffi.isInstance(b, Sk.e3ga.EUCLIDEAN_3)) {
            var c = Sk.ffi.remapToJs(a), d = c.vector, e = c.quaternion, f = Sk.ffi.remapToJs(b), g = f.quaternion;
            return d.equals(f.vector) && e.equals(g) && c.xyz === f.xyz;
          }
          return Sk.ffi.bool.False;
        });
        r.__ne__ = Sk.ffi.functionPy(function (a, b) {
          if (Sk.ffi.isInstance(b, Sk.e3ga.EUCLIDEAN_3)) {
            var c = Sk.ffi.remapToJs(a), d = c.vector, e = c.quaternion, f = Sk.ffi.remapToJs(b), g = f.quaternion;
            return !d.equals(f.vector) || !e.equals(g) || c.xyz !== f.xyz;
          }
          return Sk.ffi.bool.True;
        });
        r.__getitem__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkMethodArgs('[]', arguments, 1, 1);
          Sk.ffi.checkArgType('index', Sk.ffi.PyType.INT, Sk.ffi.isInt(b), b);
          var c = Sk.ffi.remapToJs(b), d = Sk.ffi.remapToJs(a), e = d.vector, g = d.quaternion;
          switch (c) {
          case 0:
            return f(g.w, 0, 0, 0, 0, 0, 0, 0);
          case 1:
            return f(0, e.x, e.y, e.z, 0, 0, 0, 0);
          case 2:
            return f(0, 0, 0, 0, -g.z, -g.x, -g.y, 0);
          case 3:
            return f(0, 0, 0, 0, 0, 0, 0, d.xyz);
          }
        });
        r.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b), e = d.vector, g = d.quaternion;
          switch (c) {
          case 'w':
            return Sk.ffi.numberToFloatPy(d.w);
          case 'x':
            return Sk.ffi.numberToFloatPy(d.x);
          case 'y':
            return Sk.ffi.numberToFloatPy(d.y);
          case 'z':
            return Sk.ffi.numberToFloatPy(d.z);
          case 'xy':
            return Sk.ffi.numberToFloatPy(d.xy);
          case 'yz':
            return Sk.ffi.numberToFloatPy(d.yz);
          case 'zx':
            return Sk.ffi.numberToFloatPy(d.zx);
          case 'xyz':
            return Sk.ffi.numberToFloatPy(d.xyz);
          case 'mutable':
            return Sk.ffi.booleanToPy(d.mutable);
          case 'vector':
            return Sk.ffi.callsim(a.Vector3, Sk.ffi.referenceToPy(d.vector, 'Vector3'));
          case 'quaternion':
            return Sk.ffi.callsim(a.Quaternion, Sk.ffi.referenceToPy(d.quaternion, 'Quaternion'));
          case 'add':
            return Sk.ffi.callableToPy(a, c, function (a, f) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('other', Sk.e3ga.EUCLIDEAN_3, Sk.ffi.isInstance(f, Sk.e3ga.EUCLIDEAN_3), f);
              var h = Sk.ffi.remapToJs(f);
              g.w += h.quaternion.w;
              e.x += h.vector.x;
              e.y += h.vector.y;
              e.z += h.vector.z;
              g.x += h.quaternion.x;
              g.y += h.quaternion.y;
              g.z += h.quaternion.z;
              d.xyz += h.xyz;
              return b;
            });
          case 'applyMatrix3':
            return Sk.ffi.callableToPy(a, c, function (a, d) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('m', Sk.three.MATRIX_3, Sk.ffi.isInstance(d, Sk.three.MATRIX_3), d);
              e[c](Sk.ffi.remapToJs(d));
              return b;
            });
          case 'applyMatrix4':
            return Sk.ffi.callableToPy(a, c, function (a, d) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('m', Sk.three.MATRIX_4, Sk.ffi.isInstance(d, Sk.three.MATRIX_4), d);
              e[c](Sk.ffi.remapToJs(d));
              return b;
            });
          case 'sub':
            return Sk.ffi.callableToPy(a, c, function (a, f) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('other', Sk.e3ga.EUCLIDEAN_3, Sk.ffi.isInstance(f, Sk.e3ga.EUCLIDEAN_3), f);
              var h = Sk.ffi.remapToJs(f);
              g.w -= h.quaternion.w;
              e.x -= h.vector.x;
              e.y -= h.vector.y;
              e.z -= h.vector.z;
              g.x -= h.quaternion.x;
              g.y -= h.quaternion.y;
              g.z -= h.quaternion.z;
              d.xyz -= h.xyz;
              return b;
            });
          case 'constantify':
            return Sk.ffi.callableToPy(a, 'constantify', function (a) {
              Sk.ffi.checkMethodArgs('constantify', arguments, 0, 0);
              d.mutable = !1;
              return b;
            });
          case 'copy':
            return Sk.ffi.callableToPy(a, c, function (a, f) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('other', Sk.e3ga.EUCLIDEAN_3, Sk.ffi.isInstance(f, Sk.e3ga.EUCLIDEAN_3), f);
              var h = Sk.ffi.remapToJs(f);
              g.w = h.quaternion.w;
              e.x = h.vector.x;
              e.y = h.vector.y;
              e.z = h.vector.z;
              g.x = h.quaternion.x;
              g.y = h.quaternion.y;
              g.z = h.quaternion.z;
              d.xyz = h.xyz;
              return b;
            });
          case 'cross':
            return Sk.ffi.callableToPy(a, 'cross', function (a, b) {
              Sk.ffi.checkMethodArgs('cross', arguments, 1, 1);
              Sk.ffi.checkArgType('other', Sk.e3ga.EUCLIDEAN_3, Sk.ffi.isInstance(b, Sk.e3ga.EUCLIDEAN_3), b);
              var c = Sk.ffi.remapToJs(b), e = d.x, g = d.y, h = d.z, k = c.x, l = c.y, c = c.z;
              return f(0, g * c - h * l, h * k - e * c, e * l - g * k, 0, 0, 0, 0);
            });
          case 'distanceTo':
            return Sk.ffi.callableToPy(a, c, function (a, b) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('other', Sk.e3ga.EUCLIDEAN_3, Sk.ffi.isInstance(b, Sk.e3ga.EUCLIDEAN_3), b);
              var d = Sk.ffi.remapToJs(b);
              return Sk.ffi.numberToFloatPy(e.distanceTo(d.vector));
            });
          case 'distanceToSquared':
            return Sk.ffi.callableToPy(a, c, function (a, b) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('other', Sk.e3ga.EUCLIDEAN_3, Sk.ffi.isInstance(b, Sk.e3ga.EUCLIDEAN_3), b);
              var d = Sk.ffi.remapToJs(b);
              return Sk.ffi.numberToFloatPy(e.distanceToSquared(d.vector));
            });
          case 'divideScalar':
            return Sk.ffi.callableToPy(a, c, function (a, f) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('s', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(f), f);
              var h = Sk.ffi.remapToJs(f);
              g.w /= h;
              e.x /= h;
              e.y /= h;
              e.z /= h;
              g.x /= h;
              g.y /= h;
              g.z /= h;
              d.xyz /= h;
              return b;
            });
          case 'dot':
            return Sk.ffi.callableToPy(a, c, function (a, b) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('other', Sk.e3ga.EUCLIDEAN_3, Sk.ffi.isInstance(b, Sk.e3ga.EUCLIDEAN_3), b);
              var d = Sk.ffi.remapToJs(b);
              return Sk.ffi.numberToFloatPy(e.dot(d.vector));
            });
          case 'multiplyScalar':
            return Sk.ffi.callableToPy(a, c, function (a, f) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('s', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(f), f);
              var h = Sk.ffi.remapToJs(f);
              g.w *= h;
              e.x *= h;
              e.y *= h;
              e.z *= h;
              g.x *= h;
              g.y *= h;
              g.z *= h;
              d.xyz *= h;
              return b;
            });
          case 'setX':
            return Sk.ffi.callableToPy(a, 'setX', function (a, c) {
              Sk.ffi.checkMethodArgs('setX', arguments, 1, 1);
              Sk.ffi.checkArgType('x', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(c), c);
              d.x = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'setY':
            return Sk.ffi.callableToPy(a, 'setY', function (a, c) {
              Sk.ffi.checkMethodArgs('setY', arguments, 1, 1);
              Sk.ffi.checkArgType('y', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(c), c);
              d.y = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'setZ':
            return Sk.ffi.callableToPy(a, 'setZ', function (a, c) {
              Sk.ffi.checkMethodArgs('setZ', arguments, 1, 1);
              Sk.ffi.checkArgType('z', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(c), c);
              d.z = Sk.ffi.remapToJs(c);
              return b;
            });
          case 'getComponent':
            return Sk.ffi.callableToPy(a, 'getComponent', function (a, b) {
              Sk.ffi.checkMethodArgs('getComponent', arguments, 1, 1);
              Sk.ffi.checkArgType('index', Sk.ffi.PyType.INT, Sk.ffi.isInt(b), b);
              var c = Sk.ffi.remapToJs(b);
              return Sk.ffi.numberToFloatPy(e.getComponent(c));
            });
          case 'setComponent':
            return Sk.ffi.callableToPy(a, 'setComponent', function (a, c, d) {
              Sk.ffi.checkMethodArgs('setComponent', arguments, 1, 1);
              Sk.ffi.checkArgType('index', Sk.ffi.PyType.INT, Sk.ffi.isInt(c), c);
              Sk.ffi.checkArgType('value', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(d), d);
              var f = Sk.ffi.remapToJs(c), g = Sk.ffi.remapToJs(d);
              e.setComponent(f, g);
              return b;
            });
          case 'set':
            return Sk.ffi.callableToPy(a, 'set', function (a, c, d, f) {
              Sk.ffi.checkMethodArgs('set', arguments, 3, 3);
              Sk.ffi.checkArgType('x', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(c), c);
              Sk.ffi.checkArgType('y', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(d), d);
              Sk.ffi.checkArgType('z', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(f), f);
              var g = Sk.ffi.remapToJs(c), h = Sk.ffi.remapToJs(d), k = Sk.ffi.remapToJs(f);
              e.set(g, h, k);
              return b;
            });
          case 'clone':
            return Sk.ffi.callableToPy(a, 'clone', function (a) {
              Sk.ffi.checkMethodArgs('clone', arguments, 0, 0);
              return f(g.w, e.x, e.y, e.z, -g.z, -g.x, -g.y, d.xyz);
            });
          case 'magnitude':
            return Sk.ffi.callableToPy(a, 'magnitude', function (a) {
              Sk.ffi.checkMethodArgs('magnitude', arguments, 0, 0);
              return Sk.ffi.numberToFloatPy(e.length());
            });
          case 'normalize':
            return Sk.ffi.callableToPy(a, 'normalize', function (a) {
              Sk.ffi.checkMethodArgs('normalize', arguments, 0, 0);
              e.normalize();
              return b;
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType(Sk.e3ga.EUCLIDEAN_3);
          }
        });
        r.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkArgType('self', Sk.e3ga.EUCLIDEAN_3, e(a), a);
          a = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'w':
          case 'x':
          case 'y':
          case 'z':
          case 'xy':
          case 'yz':
          case 'zx':
          case 'xyz':
            Sk.ffi.checkArgType(b, Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(c), c);
            try {
              a[b] = Sk.ffi.remapToJs(c);
            } catch (d) {
              throw Sk.ffi.assertionError(d.message);
            }
            break;
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType(Sk.e3ga.EUCLIDEAN_3);
          }
        });
        r.__cliffordConjugate__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('cliffordConjugate', arguments, 0, 0);
          var b = Sk.ffi.remapToJs(a);
          return f(b.w, -b.x, -b.y, -b.z, -b.xy, -b.yz, -b.zx, b.xyz);
        });
        r.__exp__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('exp', arguments, 0, 0);
          var b = Sk.ffi.remapToJs(a).quaternion, c = -b.z, d = -b.x, b = -b.y;
          if (0 === c && 0 === d) {
            var e = Sk.math.cos(b), g = Sk.math.sin(b);
            return f(e, 0, 0, 0, 0, 0, g, 0);
          }
          if (0 === d && 0 === b)
            return e = Sk.math.cos(c), g = Sk.math.sin(c), f(e, 0, 0, 0, g, 0, 0, 0);
          if (0 === b && 0 === c)
            return e = Sk.math.cos(d), g = Sk.math.sin(d), f(e, 0, 0, 0, 0, g, 0, 0);
          var h = Math.sqrt(c * c + d * d + b * b), e = Sk.math.cos(h), g = Sk.math.sin(h), g = g / h;
          return f(e, 0, 0, 0, g * c, g * d, g * b, 0);
        });
        r.__sqrt__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('sqrt', arguments, 0, 0);
          var b = Sk.ffi.remapToJs(a);
          return f(Math.sqrt(b.w), 0, 0, 0, 0, 0, 0, 0);
        });
        r.__repr__ = Sk.ffi.functionPy(function (a) {
          var b = Sk.ffi.remapToJs(a), c = b.vector, d = b.quaternion;
          a = d.w;
          var e = c.x, f = c.y, c = c.z, g = -d.z, h = -d.x, d = -d.y, b = b.xyz, k = 0 !== a, l = 0 !== e || 0 != f || 0 !== c, n = 0 !== g || 0 !== h || 0 !== d, m = 0 !== b;
          if (!k || l || n || m) {
            if (k || !l || n || m) {
              if (k || l || !n || m) {
                if (k || l || n || !m)
                  return a = [
                    a,
                    e,
                    f,
                    c,
                    g,
                    h,
                    d,
                    b
                  ], Sk.ffi.stringToPy(Sk.e3ga.EUCLIDEAN_3 + '(' + a.join(', ') + ')');
                a = [b];
                return Sk.ffi.stringToPy(Sk.e3ga.PSEUDOSCALAR_E3 + '(' + a.join(', ') + ')');
              }
              a = [
                g,
                h,
                d
              ];
              return Sk.ffi.stringToPy(Sk.e3ga.BIVECTOR_E3 + '(' + a.join(', ') + ')');
            }
            a = [
              e,
              f,
              c
            ];
            return Sk.ffi.stringToPy(Sk.e3ga.VECTOR_E3 + '(' + a.join(', ') + ')');
          }
          a = [a];
          return Sk.ffi.stringToPy(Sk.e3ga.SCALAR_E3 + '(' + a.join(', ') + ')');
        });
        r.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkFunctionArgs('str', arguments, 1, 1);
          Sk.ffi.checkArgType('self', Sk.e3ga.EUCLIDEAN_3, e(a), a);
          var b = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy(g([
            b.w,
            b.x,
            b.y,
            b.z,
            b.xy,
            b.yz,
            b.zx,
            b.xyz
          ], '1 e1 e2 e3 e12 e23 e31 I'.split(' ')));
        });
      }, Sk.e3ga.EUCLIDEAN_3, []);
    };
  }.call(this));
  (function () {
    Sk.builtin.defineLorentzian = function (a, b) {
      function c(a) {
        return 'number' === typeof a;
      }
      function d(b, c, d, e) {
        return Sk.ffi.callsim(a.Lorentzian, Sk.ffi.numberToFloatPy(b), Sk.ffi.numberToFloatPy(c), Sk.ffi.numberToFloatPy(d), Sk.ffi.numberToFloatPy(e));
      }
      function e(a, b, c) {
        var d, e, f, g, h;
        f = [];
        d = function (a, b) {
          var d;
          if (0 !== a) {
            0 <= a ? 0 < f.length && f.push('+') : f.push('-');
            d = Math.abs(a);
            if (1 === d)
              return f.push(b);
            f.push(d.toString());
            if ('1' !== b)
              return f.push(c), f.push(b);
          }
        };
        e = g = 0;
        for (h = a.length - 1; 0 <= h ? g <= h : g >= h; e = 0 <= h ? ++g : --g)
          d(a[e], b[e]);
        return 0 < f.length ? f.join('') : '0';
      }
      function f(a, b, c, e, f, g, h, k, A) {
        var z = +f, D = +g, v = +h, C = -k, I = +(f * z + g * D + h * v - k * C), J = z * I + -0 * D + -0 * v - -0 * C, K = -0 * z + D * I - -0 * v + -0 * C, H = -0 * z + -0 * D + v * I - -0 * C, z = -0 * z + -0 * D - -0 * v + C * I;
        f = f * J + g * K + h * H - k * z;
        J /= f;
        K /= f;
        H /= f;
        k = z / f;
        f = a * J + b * K + c * H - e * k;
        g = a * K + b * J - c * k + e * H;
        h = a * H + b * k + c * J - e * K;
        a = a * k + b * H - c * K + e * J;
        if ('undefined' !== typeof A)
          A.w = f, A.x = g, A.y = h, A.xy = a;
        else
          return d(f, g, h, a);
      }
      Sk.ffi.checkFunctionArgs('defineLorentzian', arguments, 2, 2);
      Sk.builtin.defineUnits(a, b);
      var g = [
          Sk.ffi.PyType.FLOAT,
          Sk.ffi.PyType.INT,
          Sk.ffi.PyType.LONG
        ], h = [
          'Lorentzian',
          g
        ], k = function (a) {
          return Sk.ffi.isInstance(a, 'Lorentzian');
        };
      a.ScalarL4 = Sk.ffi.functionPy(function (b) {
        Sk.ffi.checkFunctionArgs('ScalarL4', arguments, 1, 1);
        var c = Sk.ffi.numberToFloatPy(0);
        return Sk.ffi.callsim(a.Lorentzian, b, c, c, c, c, c, c, c, c, c, c, c, c, c, c, c);
      });
      a.VectorL4 = Sk.ffi.functionPy(function (b, c, d, e) {
        Sk.ffi.checkFunctionArgs('VectorL4', arguments, 4, 4);
        var f = Sk.ffi.numberToFloatPy(0);
        return Sk.ffi.callsim(a.Lorentzian, f, b, c, f, d, f, f, f, e, f, f, f, f, f, f, f);
      });
      a.PseudoscalarE2 = Sk.ffi.functionPy(function (a) {
        Sk.ffi.checkFunctionArgs('PseudoscalarE2', arguments, 1, 1);
        Sk.ffi.checkArgType('xy', g, Sk.ffi.isNum(a), a);
        return d(0, 0, 0, Sk.ffi.remapToJs(a));
      });
      a.Lorentzian = Sk.ffi.buildClass(a, function (b, g) {
        g.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e, f, g, h, l, m, C, I, J, K, H, G, L) {
          Sk.ffi.checkMethodArgs('Lorentzian', arguments, 1, 16);
          if (k(b))
            Sk.ffi.checkMethodArgs('Lorentzian', arguments, 1, 1), Sk.ffi.referenceToPy(Sk.ffi.remapToJs(b), 'Lorentzian', void 0, a);
          else {
            Sk.ffi.checkMethodArgs('Lorentzian', arguments, 16, 16);
            var y = {};
            y[0] = b;
            y[1] = c;
            y[2] = d;
            y[3] = e;
            y[4] = f;
            y[5] = g;
            y[6] = h;
            y[7] = l;
            y[8] = m;
            y[9] = C;
            y[10] = I;
            y[11] = J;
            y[12] = K;
            y[13] = H;
            y[14] = G;
            y[15] = L;
            Sk.ffi.referenceToPy(y, 'Lorentzian', void 0, a);
          }
        });
        g.__add__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c);
          if (k(c)) {
            var f = Sk.ffi.numberToFloatPy(0), g = Sk.ffh.add(d[0], e[0]), l = Sk.ffh.add(d[1], e[1]), m = Sk.ffh.add(d[2], e[2]), D = f, v = Sk.ffh.add(d[4], e[4]), C = f, I = f, J = f, d = Sk.ffh.add(d[8], e[8]);
            return Sk.ffi.callsim(a.Lorentzian, g, l, m, D, v, C, I, J, d, f, f, f, f, f, f, f);
          }
          if (Sk.ffi.isNum(c))
            return f = Sk.ffi.numberToFloatPy(0), g = Sk.ffh.add(d[0], e), l = d[1], m = d[2], v = d[4], d = d[8], Sk.ffi.callsim(a.Lorentzian, g, l, m, f, v, f, f, f, d, f, f, f, f, f, f, f);
          Sk.ffi.checkRhsOperandType('add', h, !1, c);
        });
        g.__radd__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkLhsOperandType('add', h, Sk.ffi.isNum(c), c);
          var d = Sk.ffi.remapToJs(c), e = Sk.ffi.remapToJs(b), f = Sk.ffi.numberToFloatPy(0), g;
          try {
            g = Sk.ffh.add(d, e[0]);
          } catch (k) {
            g = Sk.ffh.add(e[0], d);
          }
          return Sk.ffi.callsim(a.Lorentzian, g, e[1], e[2], f, e[4], f, f, f, e[8], f, f, f, f, f, f, f);
        });
        g.__iadd__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
          if (Sk.ffi.isNum(b))
            return c.w += d, a;
          if (k(b))
            return c.w += d.w, c.x += d.x, c.y += d.y, c.xy += d.xy, a;
          Sk.ffi.checkRhsOperandType('add', h, Sk.ffi.isNum(b), b);
        });
        g.__sub__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          if (Sk.ffi.isNum(b))
            return d(c.w - e, c.x, c.y, c.xy);
          if (k(b))
            return d(c.w - e.w, c.x - e.x, c.y - e.y, c.xy - e.xy);
          Sk.ffi.checkRhsOperandType('subtract', h, Sk.ffi.isNum(b), b);
        });
        g.__rsub__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkLhsOperandType('add', h, Sk.ffi.isNum(b), b);
          var c = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(a);
          return d(c - e.w, -e.x, -e.y, -e.xy);
        });
        g.__isub__ = Sk.ffi.functionPy(function (a, b) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          c(e) ? d.w -= e : (d.w -= e.w, d.x -= e.x, d.y -= e.y, d.xy -= e.xy);
          return a;
        });
        g.__mul__ = Sk.ffi.functionPy(function (b, c) {
          function d(a) {
            for (var b = Sk.ffi.numberToIntPy(0), c = 0; c < a.length; c++)
              b = Sk.ffh.add(b, a[c]);
            return b;
          }
          function e(a) {
            return a.map(function (a) {
              var b = a[0];
              a = Sk.ffh.multiply(f[a[1]], g[a[2]]);
              return 0 < b ? a : Sk.ffh.negative(a);
            });
          }
          var f = Sk.ffi.remapToJs(b), g = Sk.ffi.remapToJs(c);
          if (k(c)) {
            Sk.ffi.numberToFloatPy(0);
            var l = d(e([
                [
                  1,
                  0,
                  0
                ],
                [
                  1,
                  1,
                  1
                ],
                [
                  1,
                  2,
                  2
                ],
                [
                  -1,
                  3,
                  3
                ],
                [
                  1,
                  4,
                  4
                ],
                [
                  -1,
                  5,
                  5
                ],
                [
                  -1,
                  6,
                  6
                ],
                [
                  -1,
                  7,
                  7
                ],
                [
                  1,
                  8,
                  8
                ],
                [
                  -1,
                  9,
                  9
                ],
                [
                  -1,
                  10,
                  10
                ],
                [
                  1,
                  11,
                  11
                ],
                [
                  -1,
                  12,
                  12
                ],
                [
                  1,
                  13,
                  13
                ],
                [
                  1,
                  14,
                  14
                ],
                [
                  -1,
                  15,
                  15
                ]
              ])), m = d(e([
                [
                  1,
                  1,
                  0
                ],
                [
                  1,
                  0,
                  1
                ],
                [
                  1,
                  3,
                  2
                ],
                [
                  -1,
                  2,
                  3
                ],
                [
                  1,
                  5,
                  4
                ],
                [
                  -1,
                  4,
                  5
                ],
                [
                  -1,
                  7,
                  6
                ],
                [
                  -1,
                  6,
                  7
                ],
                [
                  -1,
                  9,
                  8
                ],
                [
                  1,
                  8,
                  9
                ],
                [
                  -1,
                  11,
                  10
                ]
              ])), D = d(e([
                [
                  1,
                  2,
                  0
                ],
                [
                  -1,
                  3,
                  1
                ],
                [
                  1,
                  0,
                  2
                ]
              ])), v = d(e([
                [
                  1,
                  3,
                  0
                ],
                [
                  -1,
                  2,
                  1
                ],
                [
                  1,
                  1,
                  2
                ],
                [
                  1,
                  0,
                  3
                ],
                [
                  1,
                  7,
                  4
                ],
                [
                  1,
                  6,
                  5
                ],
                [
                  -1,
                  5,
                  6
                ],
                [
                  1,
                  4,
                  7
                ],
                [
                  -1,
                  11,
                  8
                ],
                [
                  -1,
                  10,
                  9
                ],
                [
                  1,
                  9,
                  10
                ],
                [
                  -1,
                  8,
                  11
                ],
                [
                  -1,
                  15,
                  12
                ],
                [
                  -1,
                  14,
                  13
                ],
                [
                  1,
                  13,
                  14
                ],
                [
                  1,
                  12,
                  15
                ]
              ])), C = d(e([[
                  1,
                  4,
                  0
                ]])), I = d(e([[
                  1,
                  5,
                  0
                ]])), J = d(e([[
                  1,
                  6,
                  0
                ]])), K = d(e([[
                  1,
                  7,
                  0
                ]])), H = d(e([[
                  1,
                  8,
                  0
                ]])), G = d(e([[
                  1,
                  9,
                  0
                ]])), L = d(e([[
                  1,
                  10,
                  0
                ]])), y = d(e([[
                  1,
                  11,
                  0
                ]])), F = d(e([[
                  1,
                  12,
                  0
                ]])), x = d(e([[
                  1,
                  13,
                  0
                ]])), t = d(e([[
                  1,
                  14,
                  0
                ]])), u = d(e([[
                  1,
                  15,
                  0
                ]]));
            return Sk.ffi.callsim(a.Lorentzian, l, m, D, v, C, I, J, K, H, G, L, y, F, x, t, u);
          }
          if (Sk.ffi.isNum(c))
            return l = Sk.ffh.add(f[0], g), m = Sk.ffh.add(f[1], g), D = Sk.ffh.add(f[2], g), v = Sk.ffh.add(f[3], g), C = Sk.ffh.add(f[4], g), I = Sk.ffh.add(f[5], g), J = Sk.ffh.add(f[6], g), K = Sk.ffh.add(f[7], g), H = Sk.ffh.add(f[8], g), G = Sk.ffh.add(f[9], g), L = Sk.ffh.add(f[10], g), y = Sk.ffh.add(f[11], g), F = Sk.ffh.add(f[12], g), x = Sk.ffh.add(f[13], g), t = Sk.ffh.add(f[14], g), u = Sk.ffh.add(f[15], g), Sk.ffi.callsim(a.Lorentzian, l, m, D, v, C, I, J, K, H, G, L, y, F, x, t, u);
          Sk.ffi.checkRhsOperandType('multiply', h, !1, c);
        });
        g.__rmul__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (c(b))
            return d(b * a.w, b * a.x, b * a.y, b * a.xy);
          throw new Sk.builtin.AssertionError('' + JSON.stringify(b, null, 2) + ' * ' + JSON.stringify(a, null, 2));
        });
        g.__imul__ = Sk.ffi.functionPy(function (a, b) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          if (c(e))
            d.w *= e, d.x *= e, d.y *= e, d.xy *= e;
          else {
            var f = d.w, g = d.x, h = d.y, k = d.xy, l = e.w, m = e.x, C = e.y, e = e.xy;
            d.w = f * l + g * m + h * C - k * e;
            d.x = f * m + g * l - h * e + k * C;
            d.y = f * C + g * e + h * l - k * m;
            d.xy = f * e + g * C - h * m + k * l;
          }
          return a;
        });
        g.__div__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          return c(b) ? f(a.w, a.x, a.y, a.xy, b, 0, 0, 0, void 0) : f(a.w, a.x, a.y, a.xy, b.w, b.x, b.y, b.xy, void 0);
        });
        g.__rdiv__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (c(b))
            return f(b, 0, 0, 0, a.w, a.x, a.y, a.xy, void 0);
          throw new Sk.builtin.AssertionError('' + JSON.stringify(b, null, 2) + ' / ' + JSON.stringify(a, null, 2));
        });
        g.__idiv__ = Sk.ffi.functionPy(function (a, b) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          c(e) ? f(d.w, d.x, d.y, d.xy, e, 0, 0, 0, d) : f(d.w, d.x, d.y, d.xy, e.w, e.x, e.y, e.xy, d);
          return a;
        });
        g.__xor__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          if (c(b))
            return d(a.w * b, a.x * b, a.y * b, a.xy * b);
          var e = a.w, f = a.x, g = a.y, h = b.w, k = b.x, l = b.y;
          return d(e * h, e * k + f * h, e * l + g * h, e * b.xy + f * l - g * k + a.xy * h);
        });
        g.__rxor__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (c(b))
            return d(b * a.w, b * a.x, b * a.y, b * a.xy);
          throw new Sk.builtin.AssertionError('' + JSON.stringify(b, null, 2) + ' ^ ' + JSON.stringify(a, null, 2));
        });
        g.__ixor__ = Sk.ffi.functionPy(function (a, b) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          if (c(e))
            d.w *= e, d.x *= e, d.y *= e, d.xy *= e;
          else {
            var f = d.w, g = d.x, h = d.y, k = d.xy, l = e.w, m = e.x, C = e.y, e = e.xy;
            d.w = f * l;
            d.x = f * m + g * l;
            d.y = f * C + h * l;
            d.xy = f * e + g * C - h * m + k * l;
          }
          return a;
        });
        g.__lshift__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          if (c(b))
            return d(a.w * b, 0, 0, 0);
          var e = a.w, f = a.x, g = a.y, h = b.x, k = b.y, l = b.xy;
          return d(e * b.w + f * h + g * k - a.xy * l, e * h - g * l, e * k + f * l, e * l);
        });
        g.__rlshift__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (c(b))
            return d(b * a.w, b * a.x, b * a.y, b * a.xy);
          throw new Sk.builtin.AssertionError('' + JSON.stringify(b, null, 2) + ' << ' + JSON.stringify(a, null, 2));
        });
        g.__ilshift__ = Sk.ffi.functionPy(function (a, b) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          if (c(e))
            d.w *= e, d.x = 0, d.y = 0, d.xy = 0;
          else {
            var f = d.w, g = d.x, h = d.y, k = e.x, l = e.y, m = e.xy;
            d.w = f * e.w + g * k + h * l - d.xy * m;
            d.x = f * k - h * m;
            d.y = f * l + g * m;
            d.xy = f * m;
          }
          return a;
        });
        g.__rshift__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          if (c(b))
            return d(a.w * b, -a.x * b, -a.y * b, a.xy * b);
          var e = a.x, f = a.y, g = a.xy, h = b.w, k = b.x, l = b.y;
          return d(a.w * h + e * k + f * l - g * b.xy, +e * h + g * l, +f * h - g * k, g * h);
        });
        g.__rrshift__ = Sk.ffi.functionPy(function (a, b) {
          b = Sk.ffi.remapToJs(b);
          a = Sk.ffi.remapToJs(a);
          if (c(b))
            return d(b * a.w, 0, 0, 0);
          throw new Sk.builtin.AssertionError('' + JSON.stringify(b, null, 2) + ' >> ' + JSON.stringify(a, null, 2));
        });
        g.__irshift__ = Sk.ffi.functionPy(function (a, b) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
          if (c(e)) {
            var f = d.w, g = d.x, h = d.y, k = d.xy, l = e, m = 0, C = 0, I = 0;
            d.w *= e;
            d.x *= -e;
            d.y *= -e;
            d.xy *= e;
          } else
            f = d.w, g = d.x, h = d.y, k = d.xy, l = e.w, m = e.x, C = e.y, I = e.xy, d.w = f * l + g * m + h * C - k * I, d.x = +g * l + k * C, d.y = +h * l - k * m, d.xy = k * l;
          return a;
        });
        g.nb$negative = function () {
          var a = Sk.ffi.remapToJs(this);
          return d(-a.w, -a.x, -a.y, -a.xy);
        };
        g.nb$positive = function () {
          return this;
        };
        g.nb$invert = function () {
          var a = Sk.ffi.remapToJs(this);
          return d(a.w, a.x, a.y, -a.xy);
        };
        g.__getitem__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          switch (b) {
          case 0:
            return d(a.w, 0, 0, 0);
          case 1:
            return d(0, a.x, a.y, 0);
          case 2:
            return d(0, 0, 0, a.xy);
          }
        });
        g.__abs__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.numberToFloatPy(Math.sqrt(a.w * a.w + a.x * a.x + a.y * a.y - a.xy * a.xy));
        });
        g.__exp__ = Sk.ffi.functionPy(function (a) {
          var b = Sk.ffi.remapToJs(a);
          a = Math.exp(b.w);
          var c = Sk.math.cos(b.xy), b = Sk.math.sin(b.xy);
          return d(a * c, 0, 0, a * b);
        });
        g.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('Lorentzian(' + [
            a.w,
            a.x,
            a.y,
            a.xy
          ].map(function (a) {
            return String(a);
          }).join(', ') + ')');
        });
        g.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return a.isNaN() ? Sk.ffi.stringToPy('NaN') : Sk.ffi.stringToPy(e([
            a.w,
            a.x,
            a.y,
            a.xy
          ], [
            '1',
            'i',
            'j',
            'I'
          ], '*'));
        });
        g.__eq__ = Sk.ffi.functionPy(function (a, b) {
          return Sk.ffi.bool.True;
        });
        g.__ne__ = Sk.ffi.functionPy(function (a, b) {
          a = Sk.ffi.remapToJs(a);
          b = Sk.ffi.remapToJs(b);
          return a.w !== b.w || a.x !== b.x || a.y !== b.y || a.xy !== b.xy;
        });
        g.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var e = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'w':
            return e[0];
          case 'x':
            return e[1];
          case 'y':
            return e[2];
          case 'xy':
            return e[3];
          case 'yx':
            return Sk.ffh.negative(e[3]);
          case 'z':
            return e[4];
          case 'xz':
            return e[5];
          case 'zx':
            return Sk.ffh.negative(e[5]);
          case 'yz':
            return e[6];
          case 'zy':
            return Sk.ffh.negative(e[6]);
          case 'xyz':
            return e[7];
          case 't':
            return e[8];
          case 'xt':
            return e[9];
          case 'tx':
            return Sk.ffh.negative(e[9]);
          case 'yt':
            return e[10];
          case 'ty':
            return Sk.ffh.negative(e[10]);
          case 'xyt':
            return e[11];
          case 'zt':
            return e[12];
          case 'tz':
            return Sk.ffh.negative(e[12]);
          case 'xzt':
            return e[13];
          case 'zxt':
            return Sk.ffh.negative(e[13]);
          case 'yzt':
            return e[14];
          case 'xyzt':
            return e[15];
          case 'clone':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
              });
              b.__call__ = Sk.ffi.functionPy(function (a) {
                return d(e.w, e.x, e.y, e.xy);
              });
            }, 'clone', []));
          case 'magnitude':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
              });
              b.__call__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.numberToFloatPy(Math.sqrt(e.w * e.w + e.x * e.x + e.y * e.y - e.xy * e.xy));
              });
            }, 'magnitude', []));
          case 'quadrance':
            return Sk.ffi.callableToPy(a, c, function (a) {
              a = Sk.ffh.multiply(e[0], e[0]);
              a = Sk.ffh.add(a, Sk.ffh.multiply(e[1], e[1]));
              a = Sk.ffh.add(a, Sk.ffh.multiply(e[2], e[2]));
              a = Sk.ffh.add(a, Sk.ffh.multiply(e[4], e[4]));
              return a = Sk.ffh.subtract(a, Sk.ffh.multiply(e[8], e[8]));
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('Lorentzian');
          }
        });
        g.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'w':
          case 'x':
          case 'y':
          case 'xy':
            Sk.ffi.checkArgType(b, [
              Sk.ffi.PyType.FLOAT,
              Sk.ffi.PyType.INT,
              Sk.ffi.PyType.LONG
            ], Sk.ffi.isNum(c), c);
            a[b] = Sk.ffi.remapToJs(c);
            break;
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('Lorentzian');
          }
        });
      }, 'Lorentzian', []);
    };
  }.call(this));
  Sk.symbolic = Sk.symbolic || {};
  Sk.symbolic.VARIABLE = 'Variable';
  (function () {
    Sk.builtin.defineSymbolic = function (a, b) {
      Sk.ffi.checkFunctionArgs('defineSymbolic', arguments, 2, 2);
      Sk.symbolic.treeGetAttr = function (a, b, e) {
        b = Sk.ffi.remapToJs(b);
        switch (e) {
        case 'childAxis':
          return Sk.ffi.listPy(b[e]);
        case 'uuid':
          return Sk.ffi.stringToPy(b[e]);
        default:
          throw Sk.ffi.err.attribute(e).isNotGetableOnType(a);
        }
      };
      Sk.symbolic.treeSetAttr = function (a, b, e, f) {
        Sk.ffi.remapToJs(b);
        switch (e) {
        default:
          throw Sk.ffi.err.attribute(e).isNotSetableOnType(a);
        }
      };
      a.Environment = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs('Environment', arguments, 0, 2);
          var d = { bindings: {} };
          'undefined' === typeof b || Sk.ffi.isNone(b) || (Sk.ffi.checkArgType('parent', 'Environment', Sk.ffi.isInstance(b, 'Environment'), b), d.parent = b);
          if ('undefined' !== typeof c && !Sk.ffi.isNone(c)) {
            Sk.ffi.checkArgType('binding', 'Binding', Sk.ffi.isInstance(c, 'Binding'), c);
            var k = Sk.ffi.gattr(c, 'name');
            Sk.ffi.checkArgType('name', Sk.ffi.PyType.STR, Sk.ffi.isStr(k), k);
            var l = Sk.ffi.gattr(c, 'expr');
            d.bindings[Sk.ffi.remapToJs(k)] = l;
          }
          Sk.ffi.referenceToPy(d, 'Environment', void 0, a);
        });
        d.__add__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkMethodArgs('+', arguments, 1, 1);
          return Sk.ffi.callsim(a.Environment, b, c);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'lookup':
            return Sk.ffi.callableToPy(a, 'lookup', function (a, b) {
              Sk.ffi.checkMethodArgs('lookup', arguments, 1, 1);
              Sk.ffi.checkArgType('name', Sk.ffi.PyType.STR, Sk.ffi.isStr(b), b);
              var c = Sk.ffi.remapToJs(b);
              return 'undefined' !== typeof d.bindings[c] ? d.bindings[c] : 'undefined' !== typeof d.parent ? Sk.ffi.callsim(Sk.ffi.gattr(d.parent, 'lookup'), b) : Sk.ffi.none.None;
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('Environment');
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('Environment()');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('Environment');
        });
      }, 'Environment', []);
      a.Variable = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkMethodArgs('Variable', arguments, 1, 1);
          Sk.ffi.checkArgType('name', Sk.ffi.PyType.STR, Sk.ffi.isStr(b), b);
          var c = {};
          c.name = b;
          c.uuid = THREE.Math.generateUUID();
          c.childAxis = [];
          Sk.ffi.referenceToPy(c, 'Variable', void 0, a);
        });
        d.__add__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkMethodArgs('+', arguments, 1, 1);
          return Sk.ffi.callsim(a.Add, b, c);
        });
        d.__radd__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkMethodArgs('+', arguments, 1, 1);
          return Sk.ffi.callsim(a.Add, c, b);
        });
        d.__sub__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkMethodArgs('-', arguments, 1, 1);
          return Sk.ffi.callsim(a.Subtract, b, c);
        });
        d.__mul__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkMethodArgs('*', arguments, 1, 1);
          return Sk.ffi.callsim(a.Multiply, b, c);
        });
        d.__rmul__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkMethodArgs('*', arguments, 1, 1);
          return Sk.ffi.callsim(a.Multiply, c, b);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'evaluate':
            return Sk.ffi.callableToPy(a, 'evaluate', function (a, c) {
              Sk.ffi.checkMethodArgs('evaluate', arguments, 1, 1);
              Sk.ffi.checkArgType('env', 'Environment', Sk.ffi.isInstance(c, 'Environment'), c);
              var f = Sk.ffi.gattr(c, 'lookup'), f = Sk.ffi.callsim(f, d.name);
              return Sk.ffi.isNone(f) ? b : f;
            });
          default:
            return Sk.symbolic.treeGetAttr('Variable', b, c);
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('Variable("' + Sk.ffi.remapToJs(a.name) + '")');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.remapToJs(a).name;
        });
      }, 'Variable', []);
      a.TreeWalker = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkMethodArgs('TreeWalker', arguments, 1, 1);
          var c = { ancestorAxis: [] };
          c.contextNode = b;
          c.childAxis = Sk.ffi.gattr(c.contextNode, 'childAxis');
          Sk.ffi.referenceToPy(c, 'TreeWalker', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'ancestorAxis':
            return Sk.ffi.listPy(d[c]);
          case 'contextNode':
            return d[c];
          case 'moveToFirstChild':
            return Sk.ffi.callableToPy(a, c, function (a) {
              a = Sk.ffi.remapToJs(d.childAxis);
              return 0 < a.length ? (d.ancestorAxis.push(d.contextNode), d.contextNode = a[0], d.childAxis = Sk.ffi.gattr(d.contextNode, 'childAxis'), Sk.ffi.booleanToPy(!0)) : Sk.ffi.booleanToPy(!1);
            });
          case 'moveToLastChild':
            return Sk.ffi.callableToPy(a, c, function (a) {
              a = Sk.ffi.remapToJs(d.childAxis);
              return 0 < a.length ? (d.ancestorAxis.push(d.contextNode), d.contextNode = a[a.length - 1], d.childAxis = Sk.ffi.gattr(d.contextNode, 'childAxis'), Sk.ffi.booleanToPy(!0)) : Sk.ffi.booleanToPy(!1);
            });
          case 'moveToParent':
            return Sk.ffi.callableToPy(a, c, function (a) {
              Sk.ffi.remapToJs(d.childAxis);
              return 0 < d.ancestorAxis.length ? (a = d.ancestorAxis.pop(), d.contextNode = a, d.childAxis = Sk.ffi.gattr(d.contextNode, 'childAxis'), Sk.ffi.booleanToPy(!0)) : Sk.ffi.booleanToPy(!1);
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('TreeWalker');
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('TreeWalker()');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('TreeWalker');
        });
      }, 'TreeWalker', []);
      a.Binding = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs('Binding', arguments, 2, 2);
          Sk.ffi.checkArgType('name', Sk.ffi.PyType.STR, Sk.ffi.isStr(b), b);
          var d = {};
          d.name = b;
          d.expr = c;
          Sk.ffi.referenceToPy(d, 'Binding', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'name':
            return c.name;
          case 'expr':
            return c.expr;
          default:
            throw Sk.ffi.err.attribute(b).isNotGetableOnType('Binding');
          }
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            '"' + Sk.ffi.remapToJs(a.name) + '"',
            Sk.ffi.remapToJs(Sk.ffh.repr(a.expr))
          ].join(', ');
          return Sk.ffi.stringToPy('Binding(' + a + ')');
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            Sk.ffi.remapToJs(a.name),
            Sk.ffi.remapToJs(Sk.ffh.str(a.expr))
          ].join(' => ');
          return Sk.ffi.stringToPy(a);
        });
      }, 'Binding', []);
      a.Add = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs('Add', arguments, 2, 2);
          var d = {};
          d.lhs = b;
          d.rhs = c;
          d.uuid = THREE.Math.generateUUID();
          d.childAxis = [
            b,
            c
          ];
          Sk.ffi.referenceToPy(d, 'Add', void 0, a);
        });
        d.__add__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkMethodArgs('+', arguments, 1, 1);
          return Sk.ffi.callsim(a.Add, b, c);
        });
        d.__sub__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkMethodArgs('-', arguments, 1, 1);
          return Sk.ffi.callsim(a.Subtract, b, c);
        });
        d.__mul__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkMethodArgs('*', arguments, 1, 1);
          return Sk.ffi.callsim(a.Multiply, b, c);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'className':
            return Sk.ffi.stringToPy('Add');
          case 'lhs':
          case 'rhs':
            return d[c];
          case 'evaluate':
            return Sk.ffi.callableToPy(a, 'evaluate', function (a, b) {
              Sk.ffi.checkMethodArgs('evaluate', arguments, 1, 1);
              Sk.ffi.checkArgType('env', 'Environment', Sk.ffi.isInstance(b, 'Environment'), b);
              var c = Sk.ffh.evaluate(d.lhs, b), e = Sk.ffh.evaluate(d.rhs, b);
              return Sk.ffh.add(c, e);
            });
          default:
            return Sk.symbolic.treeGetAttr('Add', b, c);
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            a.lhs,
            a.rhs
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(a));
          }).join(', ');
          return Sk.ffi.stringToPy('Add(' + a + ')');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            a.lhs,
            a.rhs
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.str(a));
          }).join(' + ');
          return Sk.ffi.stringToPy('(' + a + ')');
        });
      }, 'Add', []);
      a.Subtract = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs('Subtract', arguments, 2, 2);
          var d = {};
          d.lhs = b;
          d.rhs = c;
          d.uuid = THREE.Math.generateUUID();
          d.childAxis = [
            b,
            c
          ];
          Sk.ffi.referenceToPy(d, 'Subtract', void 0, a);
        });
        d.__add__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkMethodArgs('+', arguments, 1, 1);
          return Sk.ffi.callsim(a.Add, b, c);
        });
        d.__mul__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkMethodArgs('*', arguments, 1, 1);
          return Sk.ffi.callsim(a.Multiply, b, c);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'evaluate':
            return Sk.ffi.callableToPy(a, 'evaluate', function (a, b) {
              Sk.ffi.checkMethodArgs('evaluate', arguments, 1, 1);
              Sk.ffi.checkArgType('env', 'Environment', Sk.ffi.isInstance(b, 'Environment'), b);
              var c = Sk.ffh.evaluate(d.lhs, b), e = Sk.ffh.evaluate(d.rhs, b);
              return Sk.ffh.subtract(c, e);
            });
          default:
            return Sk.symbolic.treeGetAttr('Subtract', b, c);
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            a.lhs,
            a.rhs
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(a));
          }).join(', ');
          return Sk.ffi.stringToPy('Subtract(' + a + ')');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            a.lhs,
            a.rhs
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.str(a));
          }).join(' - ');
          return Sk.ffi.stringToPy('(' + a + ')');
        });
      }, 'Subtract', []);
      a.Multiply = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs('Multiply', arguments, 2, 2);
          var d = {};
          d.lhs = b;
          d.rhs = c;
          d.uuid = THREE.Math.generateUUID();
          d.childAxis = [
            b,
            c
          ];
          Sk.ffi.referenceToPy(d, 'Multiply', void 0, a);
        });
        d.__add__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkMethodArgs('+', arguments, 1, 1);
          return Sk.ffi.callsim(a.Add, b, c);
        });
        d.__mul__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkMethodArgs('*', arguments, 1, 1);
          return Sk.ffi.callsim(a.Multiply, b, c);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'className':
            return Sk.ffi.stringToPy('Multiply');
          case 'lhs':
          case 'rhs':
            return d[c];
          case 'evaluate':
            return Sk.ffi.callableToPy(a, 'evaluate', function (a, b) {
              Sk.ffi.checkMethodArgs('evaluate', arguments, 1, 1);
              Sk.ffi.checkArgType('env', 'Environment', Sk.ffi.isInstance(b, 'Environment'), b);
              var c = Sk.ffh.evaluate(d.lhs, b), e = Sk.ffh.evaluate(d.rhs, b);
              return Sk.ffh.multiply(c, e);
            });
          default:
            return Sk.symbolic.treeGetAttr('Multiply', b, c);
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            a.lhs,
            a.rhs
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(a));
          }).join(', ');
          return Sk.ffi.stringToPy('Multiply(' + a + ')');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            a.lhs,
            a.rhs
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.str(a));
          }).join(' * ');
          return Sk.ffi.stringToPy('(' + a + ')');
        });
      }, 'Multiply', []);
      a.PointE2 = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs('PointE2', arguments, 2, 2);
          var d = {};
          d.x = b;
          d.y = c;
          Sk.ffi.referenceToPy(d, 'PointE2', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'evaluate':
            return Sk.ffi.callableToPy(a, 'evaluate', function (b, c) {
              Sk.ffi.checkMethodArgs('evaluate', arguments, 1, 1);
              Sk.ffi.checkArgType('env', 'Environment', Sk.ffi.isInstance(c, 'Environment'), c);
              var e = Sk.ffh.evaluate(d.x, c), f = Sk.ffh.evaluate(d.y, c);
              return Sk.ffi.callsim(a.PointE2, e, f);
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('PointE2');
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            a.x,
            a.y
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(a));
          }).join(', ');
          return Sk.ffi.stringToPy('PointE2(' + a + ')');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            a.x,
            a.y
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.str(a));
          }).join(', ');
          return Sk.ffi.stringToPy('[' + a + ']');
        });
      }, 'PointE2', []);
      a.Commute = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('Commute', arguments, 0, 0);
          Sk.ffi.referenceToPy({}, 'Commute', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.remapToJs(b);
          switch (c) {
          case 'execute':
            return Sk.ffi.callableToPy(a, 'evaluate', function (b, c) {
              var d = Sk.ffi.remapToJs(Sk.ffi.gattr(c, 'className')), e = Sk.ffi.gattr(c, 'lhs'), f = Sk.ffi.gattr(c, 'rhs');
              Sk.ffi.checkMethodArgs('evaluate', arguments, 1, 1);
              return Sk.ffi.callsim(a[d], f, e);
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('Commute');
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('Commute');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('Commute');
        });
      }, 'Commute', []);
      a.DistribL = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('DistribL', arguments, 0, 0);
          Sk.ffi.referenceToPy({}, 'DistribL', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.remapToJs(b);
          switch (c) {
          case 'execute':
            return Sk.ffi.callableToPy(a, 'evaluate', function (b, c) {
              Sk.ffi.checkMethodArgs('evaluate', arguments, 1, 1);
              var d = Sk.ffi.remapToJs(Sk.ffi.gattr(c, 'className')), e = Sk.ffi.gattr(c, 'lhs'), f = Sk.ffi.gattr(c, 'rhs'), n = Sk.ffi.remapToJs(Sk.ffi.gattr(f, 'className')), p = Sk.ffi.gattr(f, 'lhs'), f = Sk.ffi.gattr(f, 'rhs'), p = Sk.ffi.callsim(a[d], e, p), d = Sk.ffi.callsim(a[d], e, f);
              return Sk.ffi.callsim(a[n], p, d);
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('DistribL');
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('DistribL');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('DistribL');
        });
      }, 'DistribL', []);
      a.DistribR = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('DistribR', arguments, 0, 0);
          Sk.ffi.referenceToPy({}, 'DistribR', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.remapToJs(b);
          switch (c) {
          case 'execute':
            return Sk.ffi.callableToPy(a, 'evaluate', function (b, c) {
              Sk.ffi.checkMethodArgs('evaluate', arguments, 1, 1);
              var d = Sk.ffi.remapToJs(Sk.ffi.gattr(c, 'className')), e = Sk.ffi.gattr(c, 'lhs'), f = Sk.ffi.remapToJs(Sk.ffi.gattr(e, 'className')), n = Sk.ffi.gattr(e, 'lhs'), e = Sk.ffi.gattr(e, 'rhs'), p = Sk.ffi.gattr(c, 'rhs');
              return Sk.ffi.callsim(a[f], Sk.ffi.callsim(a[d], n, p), Sk.ffi.callsim(a[d], e, p));
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('DistribR');
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('DistribR');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('DistribR');
        });
      }, 'DistribR', []);
      a.FactorL = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('FactorL', arguments, 0, 0);
          Sk.ffi.referenceToPy({}, 'FactorL', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.remapToJs(b);
          switch (c) {
          case 'execute':
            return Sk.ffi.callableToPy(a, 'evaluate', function (b, c) {
              Sk.ffi.checkMethodArgs('evaluate', arguments, 1, 1);
              var d = Sk.ffi.remapToJs(Sk.ffi.gattr(c, 'className')), e = Sk.ffi.gattr(c, 'lhs'), f = Sk.ffi.gattr(c, 'rhs'), n = Sk.ffi.gattr(e, 'lhs'), p = Sk.ffi.gattr(e, 'rhs'), n = Sk.ffi.gattr(f, 'lhs'), q = Sk.ffi.gattr(f, 'rhs'), e = Sk.ffi.remapToJs(Sk.ffi.gattr(e, 'className'));
              Sk.ffi.remapToJs(Sk.ffi.gattr(f, 'className'));
              return Sk.ffi.callsim(a[e], n, Sk.ffi.callsim(a[d], p, q));
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('FactorL');
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('FactorL');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('FactorL');
        });
      }, 'FactorL', []);
      a.FactorR = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('FactorR', arguments, 0, 0);
          Sk.ffi.referenceToPy({}, 'FactorR', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.remapToJs(b);
          switch (c) {
          case 'execute':
            return Sk.ffi.callableToPy(a, 'evaluate', function (b, c) {
              Sk.ffi.checkMethodArgs('evaluate', arguments, 1, 1);
              var d = Sk.ffi.remapToJs(Sk.ffi.gattr(c, 'className')), e = Sk.ffi.gattr(c, 'lhs'), f = Sk.ffi.gattr(c, 'rhs'), n = Sk.ffi.gattr(e, 'lhs'), p = Sk.ffi.gattr(e, 'rhs'), q = Sk.ffi.gattr(f, 'lhs'), p = Sk.ffi.gattr(f, 'rhs'), e = Sk.ffi.remapToJs(Sk.ffi.gattr(e, 'className'));
              Sk.ffi.remapToJs(Sk.ffi.gattr(f, 'className'));
              return Sk.ffi.callsim(a[e], Sk.ffi.callsim(a[d], n, q), p);
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('FactorR');
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('FactorR');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('FactorR');
        });
      }, 'FactorR', []);
      a.AssocL = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('AssocL', arguments, 0, 0);
          Sk.ffi.referenceToPy({}, 'AssocL', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.remapToJs(b);
          switch (c) {
          case 'execute':
            return Sk.ffi.callableToPy(a, 'evaluate', function (b, c) {
              Sk.ffi.checkMethodArgs('evaluate', arguments, 1, 1);
              var d = Sk.ffi.remapToJs(Sk.ffi.gattr(c, 'className')), e = Sk.ffi.gattr(c, 'lhs'), f = Sk.ffi.gattr(c, 'rhs'), n = Sk.ffi.gattr(f, 'lhs'), f = Sk.ffi.gattr(f, 'rhs');
              return Sk.ffi.callsim(a[d], Sk.ffi.callsim(a[d], e, n), f);
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('AssocL');
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('AssocL');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('AssocL');
        });
      }, 'AssocL', []);
      a.AssocR = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('AssocR', arguments, 0, 0);
          Sk.ffi.referenceToPy({}, 'AssocR', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.remapToJs(b);
          switch (c) {
          case 'execute':
            return Sk.ffi.callableToPy(a, 'evaluate', function (b, c) {
              Sk.ffi.checkMethodArgs('evaluate', arguments, 1, 1);
              var d = Sk.ffi.remapToJs(Sk.ffi.gattr(c, 'className')), e = Sk.ffi.gattr(c, 'lhs'), f = Sk.ffi.gattr(e, 'lhs'), e = Sk.ffi.gattr(e, 'rhs'), n = Sk.ffi.gattr(c, 'rhs');
              return Sk.ffi.callsim(a[d], f, Sk.ffi.callsim(a[d], e, n));
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('AssocR');
          }
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('AssocR');
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('AssocR');
        });
      }, 'AssocR', []);
    };
  }.call(this));
  Sk.units = Sk.units || {};
  (function () {
    Sk.builtin.defineUnits = function (a, b) {
      Sk.ffi.checkFunctionArgs('defineUnits', arguments, 2, 2);
      a.yocto = Sk.ffi.numberToFloatPy(1e-24);
      a.zepto = Sk.ffi.numberToFloatPy(1e-21);
      a.atto = Sk.ffi.numberToFloatPy(1e-18);
      a.femto = Sk.ffi.numberToFloatPy(1e-15);
      a.pico = Sk.ffi.numberToFloatPy(1e-12);
      a.nano = Sk.ffi.numberToFloatPy(1e-9);
      a.micro = Sk.ffi.numberToFloatPy(0.000001);
      a.milli = Sk.ffi.numberToFloatPy(0.001);
      a.centi = Sk.ffi.numberToFloatPy(0.01);
      a.deci = Sk.ffi.numberToFloatPy(0.1);
      a.deka = Sk.ffi.numberToFloatPy(10);
      a.hecto = Sk.ffi.numberToFloatPy(100);
      a.kilo = Sk.ffi.numberToFloatPy(1000);
      a.mega = Sk.ffi.numberToFloatPy(1000000);
      a.giga = Sk.ffi.numberToFloatPy(1000000000);
      a.tera = Sk.ffi.numberToFloatPy(1000000000000);
      a.peta = Sk.ffi.numberToFloatPy(1000000000000000);
      a.exa = Sk.ffi.numberToFloatPy(1000000000000000000);
      a.zetta = Sk.ffi.numberToFloatPy(1e+21);
      a.yotta = Sk.ffi.numberToFloatPy(1e+24);
      var c = [
          Sk.ffi.PyType.FLOAT,
          Sk.ffi.PyType.INT,
          Sk.ffi.PyType.LONG
        ], d = [
          'kg',
          'm',
          's',
          'C'
        ], e = function (a) {
          return Sk.ffi.isInstance(a, 'Measure');
        };
      Sk.builtin.defineFractions(a, 'Rational', function (a, c) {
        return new b.Rational(a, c);
      });
      a.Dimensions = Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, c, d, e, f) {
          Sk.ffi.checkMethodArgs('Dimensions', arguments, 1, 4);
          Sk.ffi.checkArgType('M', 'Rational', Sk.ffi.isInstance(c, 'Rational') || Sk.ffi.isInstance(c, 'Dimensions'), c);
          switch (Sk.ffi.typeName(c)) {
          case 'Rational':
            Sk.ffi.checkMethodArgs('Dimensions', arguments, 4, 4);
            Sk.ffi.checkArgType('L', 'Rational', Sk.ffi.isInstance(d, 'Rational'), d);
            Sk.ffi.checkArgType('T', 'Rational', Sk.ffi.isInstance(e, 'Rational'), e);
            Sk.ffi.checkArgType('Q', 'Rational', Sk.ffi.isInstance(f, 'Rational'), f);
            Sk.ffi.referenceToPy(new b.Dimensions(Sk.ffi.remapToJs(c), Sk.ffi.remapToJs(d), Sk.ffi.remapToJs(e), Sk.ffi.remapToJs(f)), 'Dimensions', void 0, a);
            break;
          case 'Dimensions':
            Sk.ffi.checkMethodArgs('Dimensions', arguments, 1, 1);
            Sk.ffi.referenceToPy(Sk.ffi.remapToJs(c), 'Dimensions', void 0, a);
            break;
          default:
            throw Sk.ffi.err.argument('M').inFunction('Dimensions').mustHaveType([
              'Rational',
              'Dimensions'
            ]);
          }
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'M':
            return Sk.ffi.callsim(a.Rational, Sk.ffi.referenceToPy(d.M, 'Rational'));
          case 'L':
            return Sk.ffi.callsim(a.Rational, Sk.ffi.referenceToPy(d.L, 'Rational'));
          case 'T':
            return Sk.ffi.callsim(a.Rational, Sk.ffi.referenceToPy(d.T, 'Rational'));
          case 'Q':
            return Sk.ffi.callsim(a.Rational, Sk.ffi.referenceToPy(d.Q, 'Rational'));
          }
        });
        d.__mul__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkRhsOperandType('multiply', 'Dimensions', Sk.ffi.isInstance(c, 'Dimensions'), c);
          var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c), d = d.mul(e);
          return Sk.ffi.callsim(a.Dimensions, Sk.ffi.referenceToPy(d.M, 'Rational'), Sk.ffi.referenceToPy(d.L, 'Rational'), Sk.ffi.referenceToPy(d.T, 'Rational'), Sk.ffi.referenceToPy(d.Q, 'Rational'));
        });
        d.__div__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c), d = d.div(e);
          return Sk.ffi.callsim(a.Dimensions, Sk.ffi.referenceToPy(d.M, 'Rational'), Sk.ffi.referenceToPy(d.L, 'Rational'), Sk.ffi.referenceToPy(d.T, 'Rational', Sk.ffi.referenceToPy(d.Q, 'Rational')));
        });
        d.__pow__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkFunctionArgs('**', arguments, 2, 2);
          var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c), d = d.pow(e);
          return Sk.ffi.callsim(a.Dimensions, Sk.ffi.referenceToPy(d.M, 'Rational'), Sk.ffi.referenceToPy(d.L, 'Rational'), Sk.ffi.referenceToPy(d.T, 'Rational', Sk.ffi.referenceToPy(d.Q, 'Rational')));
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('' + a);
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          var b = [
              'M',
              'L',
              'T',
              'Q'
            ].map(function (b) {
              return Sk.ffi.gattr(a, b);
            }).map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffi.callsim(a.__repr__, a));
            });
          return Sk.ffi.stringToPy('Dimensions(' + b.join(' , ') + ')');
        });
      }, 'Dimensions', []);
      a.Unit = Sk.ffi.buildClass(a, function (d, e) {
        e.__init__ = Sk.ffi.functionPy(function (a, c, d, e) {
          Sk.ffi.checkMethodArgs('Unit', arguments, 1, 3);
          switch (Sk.ffi.getType(c)) {
          case Sk.ffi.PyType.FLOAT:
          case Sk.ffi.PyType.INT:
          case Sk.ffi.PyType.LONG:
            Sk.ffi.checkMethodArgs('Unit', arguments, 3, 3);
            var f = Sk.ffi.remapToJs(c), g = Sk.ffi.remapToJs(d), q = Sk.ffi.remapToJs(e);
            Sk.ffi.referenceToPy(new b.Unit(f, g, q), 'Unit', void 0, a);
            break;
          case Sk.ffi.PyType.INSTANCE:
            Sk.ffi.checkMethodArgs('Unit', arguments, 1, 1);
            Sk.ffi.referenceToPy(Sk.ffi.remapToJs(c), 'Unit', void 0, a);
            break;
          default:
            throw Error('Unit (__init__) ' + Sk.ffi.getType(c));
          }
        });
        e.__getattr__ = Sk.ffi.functionPy(function (c, d) {
          var e = Sk.ffi.remapToJs(c);
          switch (d) {
          case 'scale':
            return Sk.ffi.numberToFloatPy(e.scale);
          case 'dimensions':
            return Sk.ffi.callsim(a.Dimensions, Sk.ffi.referenceToPy(e.dimensions, 'Dimensions'));
          case 'labels':
            return Sk.ffi.remapToPy(e.labels);
          case 'compatible':
            return Sk.ffi.callableToPy(a, 'compatible', function (a, b) {
              Sk.ffi.checkMethodArgs('compatible', arguments, 1, 1);
              Sk.ffi.checkArgType('other', 'Unit', Sk.ffi.isInstance(b, 'Unit'), b);
              var d = Sk.ffi.remapToJs(b);
              try {
                e.compatible(d);
              } catch (f) {
                throw Sk.ffi.assertionError(f.message);
              }
              return c;
            });
          case 'cos':
            return Sk.ffi.callableToPy(a, 'cos', function (c) {
              Sk.ffi.checkMethodArgs('cos', arguments, 0, 0);
              var d = e.dimensions, f = e.labels, d = new b.Unit(Sk.math.cos(e.scale), d, f);
              return Sk.ffi.callsim(a.Unit, Sk.ffi.referenceToPy(d, 'Unit'));
            });
          case 'sin':
            return Sk.ffi.callableToPy(a, 'sin', function (c) {
              Sk.ffi.checkMethodArgs('sin', arguments, 0, 0);
              var d = e.dimensions, f = e.labels, d = new b.Unit(Sk.math.sin(e.scale), d, f);
              return Sk.ffi.callsim(a.Unit, Sk.ffi.referenceToPy(d, 'Unit'));
            });
          default:
            throw Sk.ffi.err.attribute(d).isNotGetableOnType('Unit');
          }
        });
        e.__add__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c);
          try {
            var f = d.add(e);
            return Sk.ffi.callsim(a.Unit, Sk.ffi.numberToFloatPy(f.scale), Sk.ffi.referenceToPy(f.dimensions, 'Dimensions'), Sk.ffi.remapToPy(f.labels));
          } catch (g) {
            throw Sk.ffi.assertionError(g.message);
          }
        });
        e.__sub__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c);
          try {
            var f = d.sub(e);
            return Sk.ffi.callsim(a.Unit, Sk.ffi.numberToFloatPy(f.scale), Sk.ffi.referenceToPy(f.dimensions, 'Dimensions'), Sk.ffi.remapToPy(f.labels));
          } catch (g) {
            throw Sk.ffi.assertionError(g.message);
          }
        });
        e.__mul__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkRhsOperandType('multiply', 'Unit', Sk.ffi.isInstance(c, 'Unit'), c);
          var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c), d = d.mul(e);
          return Sk.ffi.callsim(a.Unit, Sk.ffi.numberToFloatPy(d.scale), Sk.ffi.referenceToPy(d.dimensions, 'Dimensions'), Sk.ffi.remapToPy(d.labels));
        });
        e.__rmul__ = Sk.ffi.functionPy(function (b, d) {
          Sk.ffi.checkLhsOperandType('multiply', c, Sk.ffi.isNum(d), d);
          var e = Sk.ffi.remapToJs(d), f = Sk.ffi.remapToJs(b);
          return Sk.ffi.callsim(a.Unit, Sk.ffi.numberToFloatPy(e * f.scale), Sk.ffi.referenceToPy(f.dimensions, 'Dimensions'), Sk.ffi.remapToPy(f.labels));
        });
        e.__div__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c), d = d.div(e);
          return Sk.ffi.callsim(a.Unit, Sk.ffi.numberToFloatPy(d.scale), Sk.ffi.referenceToPy(d.dimensions, 'Dimensions'), Sk.ffi.remapToPy(d.labels));
        });
        e.__rdiv__ = Sk.ffi.functionPy(function (d, e) {
          Sk.ffi.checkLhsOperandType('multiply', c, Sk.ffi.isNum(e), e);
          var f = Sk.ffi.remapToJs(e), g = Sk.ffi.remapToJs(d), f = f / g.scale, n = new b.Rational(-g.dimensions.M.numer, g.dimensions.M.denom), p = new b.Rational(-g.dimensions.L.numer, g.dimensions.L.denom), q = new b.Rational(-g.dimensions.T.numer, g.dimensions.T.denom), s = new b.Rational(-g.dimensions.Q.numer, g.dimensions.Q.denom), n = new b.Dimensions(n, p, q, s), g = g.labels;
          return Sk.ffi.callsim(a.Unit, Sk.ffi.numberToFloatPy(f), Sk.ffi.referenceToPy(n, 'Dimensions'), Sk.ffi.remapToPy(g));
        });
        e.__pow__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c), d = d.pow(e);
          return Sk.ffi.callsim(a.Unit, Sk.ffi.numberToFloatPy(d.scale), Sk.ffi.referenceToPy(d.dimensions, 'Dimensions'), Sk.ffi.remapToPy(d.labels));
        });
        e.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('' + a);
        });
        e.__repr__ = Sk.ffi.functionPy(function (a) {
          var b = [{
                name: 'dimensions',
                kind: '__repr__'
              }].map(function (b) {
              return {
                value: Sk.ffi.gattr(a, b.name),
                prop: b
              };
            }).map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffi.callsim(a.value[a.prop.kind], a.value));
            }), c = Sk.ffi.remapToJs(a), d = '' + c.scale, b = b[0], c = '[' + c.labels.map(function (a) {
              return '\'' + a + '\'';
            }).join(' , ') + ']';
          return Sk.ffi.stringToPy('Unit(' + [
            d,
            b,
            c
          ].join(' , ') + ')');
        });
      }, 'Unit', []);
      a.Measure = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (b, c, d) {
          Sk.ffi.checkMethodArgs('Measure', arguments, 1, 2);
          Sk.ffi.checkArgType('quantity', 'Quantity', Sk.ffi.isInstance(c), c);
          if ('Measure' === Sk.ffi.typeName(c))
            Sk.ffi.referenceToPy(Sk.ffi.remapToJs(c), 'Measure', c.custom, b);
          else {
            var e = Sk.ffi.gattr(d, 'scale');
            if (1 === Sk.ffi.remapToJs(e)) {
              var f = {};
              f.qtyPy = c;
              f.uomPy = d;
            } else
              f = {}, f.qtyPy = Sk.ffh.multiply(c, e), f.uomPy = Sk.ffi.callsim(a.Unit, Sk.ffi.numberToFloatPy(1), Sk.ffi.gattr(d, 'dimensions'), Sk.ffi.gattr(d, 'labels'));
            Sk.ffi.referenceToPy(f, 'Measure', void 0, b);
          }
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'quantity':
            return d.qtyPy;
          case 'uom':
            return d.uomPy;
          case 'exp':
            return Sk.ffi.callableToPy(a, 'exp', function (b) {
              Sk.ffi.checkMethodArgs('exp', arguments, 0, 0);
              return Sk.ffi.callsim(a.Measure, Sk.ffi.callsim(Sk.ffi.gattr(d.qtyPy, 'exp')), d.uomPy);
            });
          case 'magnitude':
            return Sk.ffi.callableToPy(a, 'magnitude', function (b) {
              Sk.ffi.checkMethodArgs('magnitude', arguments, 0, 0);
              return Sk.ffi.callsim(a.Measure, Sk.ffi.callsim(Sk.ffi.gattr(d.qtyPy, 'magnitude')), d.uomPy);
            });
          }
        });
        d.__add__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkArgType('other', 'Measure', e(c), c);
          var d = Sk.ffi.remapToJs(b), f = Sk.ffi.remapToJs(c);
          return Sk.ffi.callsim(a.Measure, Sk.ffh.add(d.qtyPy, f.qtyPy), Sk.ffi.callsim(Sk.ffi.gattr(d.uomPy, 'compatible'), f.uomPy));
        });
        d.__sub__ = Sk.ffi.functionPy(function (b, c) {
          Sk.ffi.checkArgType('other', 'Measure', e(c), c);
          var d = Sk.ffi.remapToJs(b), f = Sk.ffi.remapToJs(c);
          return Sk.ffi.callsim(a.Measure, Sk.ffh.subtract(d.qtyPy, f.qtyPy), Sk.ffi.callsim(Sk.ffi.gattr(d.uomPy, 'compatible'), f.uomPy));
        });
        d.__mul__ = Sk.ffi.functionPy(function (b, d) {
          var f = Sk.ffi.remapToJs(b);
          if (e(d)) {
            var g = Sk.ffi.remapToJs(d);
            return Sk.ffi.callsim(a.Measure, Sk.ffh.multiply(f.qtyPy, g.qtyPy), Sk.ffh.multiply(f.uomPy, g.uomPy));
          }
          if (Sk.ffi.isNum(d))
            return Sk.ffi.callsim(a.Measure, Sk.ffh.multiply(f.qtyPy, d), f.uomPy);
          Sk.ffi.checkArgType('other', [
            'Measure',
            c
          ], !1, d);
        });
        d.__rmul__ = Sk.ffi.functionPy(function (b, d) {
          var e = Sk.ffi.remapToJs(b);
          Sk.ffi.checkArgType('other', c, Sk.ffi.isNum(d), d);
          return Sk.ffi.callsim(a.Measure, Sk.ffh.multiply(e.qtyPy, d), e.uomPy);
        });
        d.__div__ = Sk.ffi.functionPy(function (b, d) {
          var f = Sk.ffi.remapToJs(b);
          if (e(d)) {
            var g = Sk.ffi.remapToJs(d);
            return Sk.ffi.callsim(a.Measure, Sk.ffh.divide(f.qtyPy, g.qtyPy), Sk.ffh.divide(f.uomPy, g.uomPy));
          }
          if (Sk.ffi.isNum(d))
            return Sk.ffi.callsim(a.Measure, Sk.ffh.divide(f.qtyPy, d), f.uomPy);
          if (Sk.ffi.isInstance(d, 'Unit'))
            return Sk.ffi.callsim(a.Measure, f.qtyPy, Sk.ffh.divide(f.uomPy, d));
          Sk.ffi.checkArgType('other', [
            'Measure',
            c,
            'Unit'
          ], !1, d);
        });
        d.__xor__ = Sk.ffi.functionPy(function (b, d) {
          var f = Sk.ffi.remapToJs(b);
          if (e(d)) {
            var g = Sk.ffi.remapToJs(d);
            return Sk.ffi.callsim(a.Measure, Sk.ffh.xor(f.qtyPy, g.qtyPy), Sk.ffh.multiply(f.uomPy, g.uomPy));
          }
          if (Sk.ffi.isNum(d))
            return Sk.ffi.callsim(a.Measure, Sk.ffh.xor(f.qtyPy, d), f.uomPy);
          Sk.ffi.checkArgType('other', [
            'Measure',
            c
          ], !1, d);
        });
        d.__lshift__ = Sk.ffi.functionPy(function (b, d) {
          var f = Sk.ffi.remapToJs(b);
          if (e(d)) {
            var g = Sk.ffi.remapToJs(d);
            return Sk.ffi.callsim(a.Measure, Sk.ffh.lshift(f.qtyPy, g.qtyPy), Sk.ffh.multiply(f.uomPy, g.uomPy));
          }
          if (Sk.ffi.isNum(d))
            return Sk.ffi.callsim(a.Measure, Sk.ffh.lshift(f.qtyPy, d), f.uomPy);
          Sk.ffi.checkArgType('other', [
            'Measure',
            c
          ], !1, d);
        });
        d.__rshift__ = Sk.ffi.functionPy(function (b, d) {
          var f = Sk.ffi.remapToJs(b);
          if (e(d)) {
            var g = Sk.ffi.remapToJs(d);
            return Sk.ffi.callsim(a.Measure, Sk.ffh.rshift(f.qtyPy, g.qtyPy), Sk.ffh.multiply(f.uomPy, g.uomPy));
          }
          if (Sk.ffi.isNum(d))
            return Sk.ffi.callsim(a.Measure, Sk.ffh.rshift(f.qtyPy, d), f.uomPy);
          Sk.ffi.checkArgType('other', [
            'Measure',
            c
          ], !1, d);
        });
        d.__pos__ = Sk.ffi.functionPy(function (b) {
          var c = Sk.ffh.positive(Sk.ffi.gattr(b, 'quantity'));
          b = Sk.ffi.gattr(b, 'uom');
          return Sk.ffi.callsim(a.Measure, c, b);
        });
        d.__neg__ = Sk.ffi.functionPy(function (b) {
          var c = Sk.ffh.negative(Sk.ffi.gattr(b, 'quantity'));
          b = Sk.ffi.gattr(b, 'uom');
          return Sk.ffi.callsim(a.Measure, c, b);
        });
        d.__invert__ = Sk.ffi.functionPy(function (b) {
          var c = Sk.ffh.invert(Sk.ffi.gattr(b, 'quantity'));
          b = Sk.ffi.gattr(b, 'uom');
          return Sk.ffi.callsim(a.Measure, c, b);
        });
        d.__exp__ = Sk.ffi.functionPy(function (b) {
          var c = Sk.ffh.exp(Sk.ffi.gattr(b, 'quantity'));
          b = Sk.ffi.gattr(b, 'uom');
          return Sk.ffi.callsim(a.Measure, c, b);
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          var b = Sk.ffi.remapToJs(a);
          a = Sk.ffi.remapToJs(Sk.ffh.str(b.qtyPy));
          b = Sk.ffi.remapToJs(Sk.ffh.str(b.uomPy));
          return Sk.ffi.stringToPy('' + a + ' ' + b);
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          var b = Sk.ffi.remapToJs(a);
          a = Sk.ffi.remapToJs(Sk.ffh.repr(b.qtyPy));
          b = Sk.ffi.remapToJs(Sk.ffh.repr(b.uomPy));
          return Sk.ffi.stringToPy('Measure(' + a + ', ' + b + ')');
        });
      }, 'Measure', []);
      a.kilogram = Sk.ffi.callsim(a.Unit, Sk.ffi.numberToFloatPy(1), Sk.ffi.referenceToPy(new b.Dimensions(1, 0, 0, 0), 'Dimensions'), Sk.ffi.remapToPy(d));
      a.meter = Sk.ffi.callsim(a.Unit, Sk.ffi.numberToFloatPy(1), Sk.ffi.referenceToPy(new b.Dimensions(0, 1, 0, 0), 'Dimensions'), Sk.ffi.remapToPy(d));
      a.second = Sk.ffi.callsim(a.Unit, Sk.ffi.numberToFloatPy(1), Sk.ffi.referenceToPy(new b.Dimensions(0, 0, 1, 0), 'Dimensions'), Sk.ffi.remapToPy(d));
      a.coulomb = Sk.ffi.callsim(a.Unit, Sk.ffi.numberToFloatPy(1), Sk.ffi.referenceToPy(new b.Dimensions(0, 0, 0, 1), 'Dimensions'), Sk.ffi.remapToPy(d));
      a.gram = Sk.ffi.callsim(a.Unit, Sk.ffi.numberToFloatPy(0.001), Sk.ffi.referenceToPy(new b.Dimensions(1, 0, 0, 0), 'Dimensions'), Sk.ffi.remapToPy(d));
      a.cm = Sk.ffi.callsim(a.Unit, Sk.ffi.numberToFloatPy(0.01), Sk.ffi.referenceToPy(new b.Dimensions(0, 1, 0, 0), 'Dimensions'), Sk.ffi.remapToPy(d));
      a.newton = Sk.ffi.callsim(a.Unit, Sk.ffi.numberToFloatPy(1), Sk.ffi.referenceToPy(new b.Dimensions(1, 1, -2, 0), 'Dimensions'), Sk.ffi.remapToPy(d));
      a.joule = Sk.ffi.callsim(a.Unit, Sk.ffi.numberToFloatPy(1), Sk.ffi.referenceToPy(new b.Dimensions(1, 2, -2, 0), 'Dimensions'), Sk.ffi.remapToPy(d));
      a.watt = Sk.ffi.callsim(a.Unit, Sk.ffi.numberToFloatPy(1), Sk.ffi.referenceToPy(new b.Dimensions(1, 2, -3, 0), 'Dimensions'), Sk.ffi.remapToPy(d));
      a.ampere = Sk.ffi.callsim(a.Unit, Sk.ffi.numberToFloatPy(1), Sk.ffi.referenceToPy(new b.Dimensions(0, 0, -1, 1), 'Dimensions'), Sk.ffi.remapToPy(d));
      a.volt = Sk.ffi.callsim(a.Unit, Sk.ffi.numberToFloatPy(1), Sk.ffi.referenceToPy(new b.Dimensions(1, 2, -2, -1), 'Dimensions'), Sk.ffi.remapToPy(d));
      a.tesla = Sk.ffi.callsim(a.Unit, Sk.ffi.numberToFloatPy(1), Sk.ffi.referenceToPy(new b.Dimensions(1, 1, -2, -1), 'Dimensions'), Sk.ffi.remapToPy(d));
    };
  }.call(this));
  Sk.three = Sk.three || {};
  Sk.three.FACE_3 = 'Face3';
  Sk.three.MATERIAL = 'Material';
  Sk.three.MATRIX_3 = 'Matrix3';
  Sk.three.MATRIX_4 = 'Matrix4';
  Sk.three.MESH = 'Mesh';
  Sk.three.OBJECT_3D = 'Object3D';
  Sk.three.PARTICLE_SYSTEM = 'ParticleSystem';
  Sk.three.PARTICLE_SYSTEM_MATERIAL = 'ParticleSystemMaterial';
  Sk.three.ARROW_GEOMETRY = 'ArrowGeometry';
  Sk.three.VORTEX_GEOMETRY = 'VortexGeometry';
  Sk.three.cardinal = function (a, b, c) {
    function d(a) {
      return 'number' === typeof a ? a ? 0 > a ? -1 : 1 : isNaN(a) ? NaN : 0 : NaN;
    }
    var e = Math.abs(a), f = Math.abs(b), g = Math.abs(c);
    return e >= f ? e >= g ? new THREE.Vector3(d(a), 0, 0) : new THREE.Vector3(0, 0, d(c)) : f >= g ? new THREE.Vector3(0, d(b), 0) : new THREE.Vector3(0, 0, d(c));
  };
  goog.exportSymbol('Sk.three.cardinal', Sk.three.cardinal);
  Sk.three.vector3Cycle = function (a, b, c, d) {
    switch (d % 3) {
    case 0:
      return new THREE.Vector3(a, b, c);
    case 1:
      return new THREE.Vector3(c, a, b);
    case 2:
      return new THREE.Vector3(b, c, a);
    }
  };
  goog.exportSymbol('Sk.three.vector3Cycle', Sk.three.vector3Cycle);
  (function () {
    Sk.stdlib.defineThree = function (a, b) {
      function c(a) {
        return 'boolean' === typeof a;
      }
      function d(a) {
        return 'number' === typeof a;
      }
      function e(a) {
        return 'string' === typeof a;
      }
      function f(a) {
        return 'undefined' === typeof a;
      }
      function g(a) {
        return 'undefined' !== typeof a;
      }
      function h(a) {
        return 'object' === typeof a && null === a;
      }
      function k(a) {
        return Sk.ffi.isInstance(a, 'Euclidean3');
      }
      function l(b) {
        b = new THREE.Euclidean3(new THREE.Vector3(0, 0, 0), b, 0);
        return Sk.ffi.callsim(a.Euclidean3, Sk.ffi.referenceToPy(b, 'Euclidean3'));
      }
      function m(a, b, c, d, e) {
        Sk.ffi.checkArgType('target', a, Sk.ffi.isInstance(b, a), b);
        e = e || c;
        Sk.ffi.checkArgType(e, 'Euclidean3', k(d), d);
        a = Sk.ffi.gattr(d, 'quaternion');
        Sk.ffi.checkArgType(e, 'Quaternion', Sk.ffi.isInstance(a, 'Quaternion'), a);
        Sk.ffi.remapToJs(b)[c] = Sk.ffi.remapToJs(a);
      }
      function n(b) {
        b = new THREE.Euclidean3(b, new THREE.Quaternion(0, 0, 0, 0), 0);
        return Sk.ffi.callsim(a.Euclidean3, Sk.ffi.referenceToPy(b, 'Euclidean3'));
      }
      function p(a, b) {
        if (g(b)) {
          Sk.ffi.checkArgType(a, 'Euclidean3', k(b), b);
          var c = Sk.ffi.gattr(b, 'vector');
          Sk.ffi.checkArgType(a, 'Vector3', Sk.ffi.isInstance(c, 'Vector3'), c);
          return Sk.ffi.remapToJs(c);
        }
      }
      function q(a, b, c, d) {
        a[b] = p(d || b, c);
      }
      function s(b) {
        if ('object' !== typeof b)
          throw Sk.ffi.assertionError('target must be an object.');
        if ('function' !== typeof b.add)
          throw Sk.ffi.assertionError('target must have an \'add\' function.');
        return Sk.ffi.callableToPy(a, 'add', function (a, c) {
          var d = Sk.ffi.remapToJs(c);
          b.add(d);
        });
      }
      function r(b) {
        return Sk.ffi.callableToPy(a, 'lookAt', function (a, c) {
          Sk.ffi.checkMethodArgs('lookAt', arguments, 1, 1);
          Sk.ffi.checkArgType('vector', 'Euclidean3', k(c), c);
          var d = Sk.ffi.gattr(c, 'vector');
          Sk.ffi.checkArgType('vector', 'Vector3', Sk.ffi.isInstance(d, 'Vector3'), d);
          Sk.ffi.remapToJs(b).lookAt(Sk.ffi.remapToJs(d));
          return b;
        });
      }
      function w(b) {
        if ('object' !== typeof b)
          throw Sk.ffi.assertionError('target must be an object.');
        if ('function' !== typeof b.remove)
          throw Sk.ffi.assertionError('target must have a \'remove\' function.');
        return Sk.ffi.callableToPy(a, 'add', function (a, c) {
          var d = Sk.ffi.remapToJs(c);
          b.remove(d);
        });
      }
      function A(b) {
        return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (c, d) {
          d.__init__ = Sk.ffi.functionPy(function (c) {
            var d = {};
            d.append = Sk.ffi.callableToPy(a, 'append', function (a, c) {
              b.push(p('vector', c));
            });
            Sk.ffi.referenceToPy(b, 'vertices', d, c);
          });
          d.__getattr__ = Sk.ffi.functionPy(function (a, b) {
            Sk.ffi.remapToJs(a);
            switch (b) {
            case 'append':
              return a.custom.append;
            }
          });
          d.__getitem__ = Sk.ffi.functionPy(function (a, c) {
            var d = Sk.ffi.remapToJs(c);
            return n(b[d]);
          });
          d.mp$length = function () {
            return b.length;
          };
          d.__str__ = Sk.ffi.functionPy(function (a) {
            return Sk.ffh.str(Sk.ffi.listPy(b.map(function (a) {
              return n(a);
            })));
          });
          d.__repr__ = Sk.ffi.functionPy(function (a) {
            return Sk.ffi.stringToPy('vertices');
          });
        }, 'vertices', []));
      }
      function z(b) {
        return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (c, d) {
          d.__init__ = Sk.ffi.functionPy(function (a) {
            Sk.ffi.referenceToPy(b, 'faces', void 0, a);
          });
          d.__getattr__ = Sk.ffi.functionPy(function (c, d) {
            switch (d) {
            case 'append':
              return Sk.ffi.callableToPy(a, 'append', function (a, c) {
                b.push(Sk.ffi.remapToJs(c));
              });
            }
          });
          d.__getitem__ = Sk.ffi.functionPy(function (a, c) {
            var d = Sk.ffi.remapToJs(c);
            return D(b[d]);
          });
          d.mp$length = function () {
            return b.length;
          };
          d.__str__ = Sk.ffi.functionPy(function (a) {
            return Sk.ffh.str(Sk.ffi.listPy(b.map(function (a) {
              return D(a);
            })));
          });
          d.__repr__ = Sk.ffi.functionPy(function (a) {
            return Sk.ffi.stringToPy('faces');
          });
        }, 'faces', []));
      }
      function D(b) {
        return Sk.ffi.callsim(a[Sk.three.FACE_3], Sk.ffi.referenceToPy(b, Sk.three.FACE_3));
      }
      function v(b) {
        return Sk.ffi.callsim(a.Color, Sk.ffi.referenceToPy(b, 'Color'));
      }
      function C(b) {
        return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (c, d) {
          d.__init__ = Sk.ffi.functionPy(function (a) {
            Sk.ffi.referenceToPy(b, 'colors', void 0, a);
          });
          d.__getattr__ = Sk.ffi.functionPy(function (c, d) {
            switch (d) {
            case 'append':
              return Sk.ffi.callableToPy(a, 'append', function (a, c) {
                b.push(Sk.ffi.remapToJs(c));
              });
            }
          });
          d.__getitem__ = Sk.ffi.functionPy(function (a, c) {
            var d = Sk.ffi.remapToJs(c);
            return v(b[d]);
          });
          d.mp$length = function () {
            return b.length;
          };
          d.__str__ = Sk.ffi.functionPy(function (a) {
            return Sk.ffh.str(Sk.ffi.listPy(b.map(function (a) {
              return v(a);
            })));
          });
          d.__repr__ = Sk.ffi.functionPy(function (a) {
            return Sk.ffi.stringToPy('colors');
          });
        }, 'vertices', []));
      }
      function I(a, b, d, g) {
        if (f(b))
          throw Error('argName must be specified');
        if (f(d))
          throw Error('functionName must be specified');
        g = f(g) ? !0 : c(g) ? g : !0;
        if (f(a)) {
          if (g)
            return a;
          throw new Sk.builtin.TypeError(d + '.' + b + ' must be convertible to a number, but was Missing.');
        }
        if (h(a)) {
          if (g)
            return a;
          throw new Sk.builtin.TypeError(d + '.' + b + ' must be convertible to a number, but was None.');
        }
        if (c(a))
          throw new Sk.builtin.TypeError(d + '.' + b + ' must be convertible to a number, but was a Boolean.');
        if (a.skType)
          switch (a.skType) {
          case 'float':
            return a.v;
          case 'int':
            return a.v;
          default:
            throw new Sk.builtin.TypeError(d + '(' + b + ': ' + a.skType + ') must be convertible to a number.');
          }
        else {
          if (a.v && e(a.v))
            throw new Sk.builtin.TypeError(d + '.' + b + ' must be convertible to a number, but was a String.');
          throw new Sk.builtin.AssertionError(d + '.' + b + ' is unknown.');
        }
      }
      function J(b, c, d) {
        var e = Sk.ffi.remapToJs(b);
        switch (c) {
        case 'aspect':
          return Sk.ffi.numberToFloatPy(e.aspect);
        case 'position':
          return n(e.position);
        case 'quaternion':
          return Sk.ffi.callsim(a.Quaternion, Sk.ffi.referenceToPy(e.quaternion, 'Quaternion'));
        case 'rotation':
          return n(e.rotation);
        case 'eulerOrder':
          return Sk.ffi.stringToPy(e.eulerOrder);
        case 'scale':
          return n(e.scale);
        case 'up':
          return n(e.up);
        case 'useQuaternion':
          return e.useQuaternion;
        case 'lookAt':
          return r(b);
        case 'updateProjectionMatrix':
          return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
            b.__init__ = Sk.ffi.functionPy(function (a) {
              a.tp$name = 'updateProjectionMatrix';
            });
            b.__call__ = Sk.ffi.functionPy(function (a) {
              e[c]();
            });
            b.__str__ = Sk.ffi.functionPy(function (a) {
              return Sk.ffi.stringToPy('updateProjectionMatrix');
            });
            b.__repr__ = Sk.ffi.functionPy(function (a) {
              return Sk.ffi.stringToPy('updateProjectionMatrix');
            });
          }, 'updateProjectionMatrix', []));
        default:
          throw Sk.ffi.err.attribute(c).isNotSetableOnType(d);
        }
      }
      function K(a, b, c, d) {
        a = Sk.ffi.remapToJs(a);
        var f = Sk.ffi.remapToJs(c);
        switch (b) {
        case 'position':
        case 'rotation':
        case 'scale':
        case 'up':
          q(a, b, c);
          break;
        case 'quaternion':
          a.quaternion = f;
          break;
        case 'eulerOrder':
          if (e(f))
            a.eulerOrder = f;
          else
            throw Error(b + ' must be a string');
          break;
        case 'useQuaternion':
          a.useQuaternion = f;
          break;
        default:
          throw Sk.ffi.err.attribute(b).isNotSetableOnType(d);
        }
      }
      function H(b, c, d) {
        var e = Sk.ffi.remapToJs(c);
        switch (d) {
        case 'id':
          return Sk.ffi.numberToIntPy(e.id);
        case 'name':
          return Sk.ffi.stringToPy(e.name);
        case 'uuid':
          return Sk.ffi.stringToPy(e.uuid);
        case 'faces':
          return z(e.faces);
        case 'colors':
          return C(e.colors);
        case 'vertices':
          return A(e.vertices);
        case 'radius':
          return Sk.ffi.numberToFloatPy(e.radius);
        case 'width':
          return Sk.ffi.numberToFloatPy(e.width);
        case 'depth':
        case 'height':
          return Sk.ffi.numberToFloatPy(e.height);
        case 'applyMatrix':
          return Sk.ffi.callableToPy(a, d, function (a, b) {
            Sk.ffi.checkMethodArgs(d, arguments, 1, 1);
            Sk.ffi.checkArgType('matrix', Sk.three.MATRIX_4, Sk.ffi.isInstance(b, Sk.three.MATRIX_4), b);
            e.applyMatrix(Sk.ffi.remapToJs(b));
          });
        case 'computeCentroids':
          return Sk.ffi.callableToPy(a, d, function (a) {
            Sk.ffi.checkMethodArgs(d, arguments, 0, 0);
            e.computeCentroids();
          });
        case 'computeFaceNormals':
          return Sk.ffi.callableToPy(a, d, function (a) {
            Sk.ffi.checkMethodArgs(d, arguments, 0, 0);
            e.computeFaceNormals();
          });
        default:
          throw Sk.ffi.err.attribute(d).isNotGetableOnType(b);
        }
      }
      function G(a, b, c, d) {
        b = Sk.ffi.remapToJs(b);
        switch (c) {
        case 'name':
          Sk.ffi.checkArgType('name', Sk.ffi.PyType.STR, Sk.ffi.isStr(d), d);
          b.name = Sk.ffi.remapToJs(d);
          break;
        default:
          throw Sk.ffi.err.attribute(c).isNotSetableOnType(a);
        }
      }
      function L(b, c, d) {
        var e = Sk.ffi.remapToJs(c);
        switch (d) {
        case 'color':
          return Sk.ffi.callsim(a.Color, Sk.ffi.referenceToPy(e.color, 'Color'));
        default:
          return Sk.three.object3DGetAttr(b, c, d);
        }
      }
      function y(a, b, c, d) {
        var e = Sk.ffi.remapToJs(b), f = Sk.ffi.remapToJs(d);
        switch (c) {
        case 'color':
          e.color = new THREE.Color(f);
          break;
        default:
          return Sk.three.object3DSetAttr(a, b, c, d);
        }
      }
      function F(b, c, d) {
        c = Sk.ffi.remapToJs(c);
        switch (d) {
        case 'emissive':
        case 'color':
          return Sk.ffi.callsim(a.Color, Sk.ffi.referenceToPy(c[d], 'Color'));
        case 'id':
          return Sk.ffi.numberToIntPy(c.id);
        case 'opacity':
        case 'overdraw':
          return Sk.ffi.numberToFloatPy(c.opacity);
        case 'name':
        case 'uuid':
          return Sk.ffi.stringToPy(c[d]);
        case 'needsUpdate':
        case 'transparent':
        case 'visible':
          return Sk.ffi.booleanToPy(c[d]);
        default:
          throw Sk.ffi.err.attribute(d).isNotGetableOnType(b);
        }
      }
      function x(a, b, c, d) {
        b = Sk.ffi.remapToJs(b);
        switch (c) {
        case 'name':
          Sk.ffi.checkArgType(c, Sk.ffi.PyType.STR, Sk.ffi.isStr(d), d);
          b[c] = Sk.ffi.remapToJs(d);
          break;
        case 'overdraw':
          Sk.ffi.checkArgType(c, Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(d), d);
          b[c] = Sk.ffi.remapToJs(d);
          break;
        case 'needsUpdate':
        case 'transparent':
        case 'visible':
          Sk.ffi.checkArgType(c, Sk.ffi.PyType.BOOL, Sk.ffi.isBool(d), d);
          b[c] = Sk.ffi.remapToJs(d);
          break;
        default:
          throw Sk.ffi.err.attribute(c).isNotSetableOnType(a);
        }
      }
      Sk.ffi.checkFunctionArgs('defineThree', arguments, 2, 2);
      Sk.builtin.defineNode(a);
      var t = Sk.ffi.PyType.INT, u = [
          Sk.ffi.PyType.FLOAT,
          Sk.ffi.PyType.INT,
          Sk.ffi.PyType.LONG
        ];
      Sk.stdlib.CylinderGeometry = function (a, b, c, d, e, f, g) {
        THREE.Geometry.call(this);
        this.radiusTop = a = void 0 !== a ? a : 20;
        this.radiusBottom = b = void 0 !== b ? b : 20;
        this.height = c = void 0 !== c ? c : 100;
        this.radialSegments = d = d || 8;
        this.heightSegments = e = e || 1;
        this.openEnded = f = void 0 !== f ? f : !1;
        var h = c / 2, k = Sk.stdlib.direction(g.x, g.y, g.z);
        Sk.stdlib.orientation(g.x, g.y, g.z);
        var l, m = [], n = [];
        for (l = 0; l <= e; l++) {
          var p = [], q = [], r = l / e, s = -r * c + h, t = r * (b - a) + a;
          for (g = 0; g < d; g++) {
            var u = g / d, v = 2 * u * Math.PI, v = Sk.three.vector3Cycle(s, t * Sk.math.cos(v), t * Sk.math.sin(v), k);
            this.vertices.push(v);
            p.push(this.vertices.length - 1);
            q.push(new THREE.Vector2(u, 1 - r));
          }
          m.push(p);
          n.push(q);
        }
        c = (b - a) / c;
        for (g = 0; g < d; g++)
          for (r = (g + 0) % d, s = (g + 1) % d, 0 !== a ? (p = this.vertices[m[0][r]].clone(), q = this.vertices[m[0][s]].clone()) : (p = this.vertices[m[1][r]].clone(), q = this.vertices[m[1][s]].clone()), l = p.getComponent((k + 2) % 3), t = p.getComponent((k + 1) % 3), p.setComponent((k + 0) % 3, Math.sqrt(l * l + t * t) * c), p.normalize(), l = q.getComponent((k + 2) % 3), t = q.getComponent((k + 1) % 3), q.setComponent((k + 0) % 3, Math.sqrt(l * l + t * t) * c), q.normalize(), l = 0; l < e; l++) {
            var t = m[l][r], u = m[l + 1][r], v = m[l + 1][s], w = m[l][s], x = p.clone(), y = p.clone(), z = q.clone(), A = q.clone(), D = n[l][r].clone(), C = n[l + 1][r].clone(), F = n[l + 1][s].clone(), G = n[l][s].clone();
            this.faces.push(new THREE.Face3(t, u, w, [
              x,
              y,
              A
            ]));
            this.faceVertexUvs[0].push([
              D,
              C,
              G
            ]);
            this.faces.push(new THREE.Face3(u, v, w, [
              y,
              z,
              A
            ]));
            this.faceVertexUvs[0].push([
              C,
              F,
              G
            ]);
          }
        if (!1 === f && 0 < a)
          for (this.vertices.push(Sk.three.vector3Cycle(+h, 0, 0, k)), g = 0; g < d; g++)
            r = (g + 0) % d, s = (g + 1) % d, t = m[0][r], u = m[0][s], v = this.vertices.length - 1, x = Sk.three.vector3Cycle(1, 0, 0, k), y = Sk.three.vector3Cycle(1, 0, 0, k), z = Sk.three.vector3Cycle(1, 0, 0, k), D = n[0][r].clone(), C = n[0][s].clone(), F = new THREE.Vector2(C.u, 0), this.faces.push(new THREE.Face3(t, u, v, [
              x,
              y,
              z
            ])), this.faceVertexUvs[0].push([
              D,
              C,
              F
            ]);
        if (!1 === f && 0 < b)
          for (this.vertices.push(Sk.three.vector3Cycle(-h, 0, 0, k)), g = 0; g < d; g++)
            r = (g + 0) % d, s = (g + 1) % d, t = m[e][s], u = m[e][r], v = this.vertices.length - 1, x = Sk.three.vector3Cycle(-1, 0, 0, k), y = Sk.three.vector3Cycle(-1, 0, 0, k), z = Sk.three.vector3Cycle(-1, 0, 0, k), D = n[e][s].clone(), C = n[e][r].clone(), F = new THREE.Vector2(C.u, 1), this.faces.push(new THREE.Face3(t, u, v, [
              x,
              y,
              z
            ])), this.faceVertexUvs[0].push([
              D,
              C,
              F
            ]);
        this.computeCentroids();
        this.computeFaceNormals();
      };
      Sk.stdlib.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype);
      Sk.stdlib.PlaneGeometry = function (a, b, c, d) {
        THREE.Geometry.call(this);
        this.width = a;
        this.height = b;
        this.widthSegments = c || 1;
        this.heightSegments = d || 1;
        var e = a / 2, f = b / 2;
        c = this.widthSegments;
        d = this.heightSegments;
        var g = c + 1, h = d + 1, k = this.width / c, l = this.height / d, m = new THREE.Vector3(0, 0, 1);
        for (a = 0; a < h; a++)
          for (b = 0; b < g; b++)
            this.vertices.push(new THREE.Vector3(b * k - e, -(a * l - f), 0));
        for (a = 0; a < d; a++)
          for (b = 0; b < c; b++) {
            var n = b + g * a, e = b + g * (a + 1), f = b + 1 + g * (a + 1), h = b + 1 + g * a, k = new THREE.Vector2(b / c, 1 - a / d), l = new THREE.Vector2(b / c, 1 - (a + 1) / d), p = new THREE.Vector2((b + 1) / c, 1 - (a + 1) / d), q = new THREE.Vector2((b + 1) / c, 1 - a / d), n = new THREE.Face3(n, e, h);
            n.normal.copy(m);
            n.vertexNormals.push(m.clone(), m.clone(), m.clone());
            this.faces.push(n);
            this.faceVertexUvs[0].push([
              k,
              l,
              q
            ]);
            n = new THREE.Face3(e, f, h);
            n.normal.copy(m);
            n.vertexNormals.push(m.clone(), m.clone(), m.clone());
            this.faces.push(n);
            this.faceVertexUvs[0].push([
              l.clone(),
              p,
              q.clone()
            ]);
          }
        this.computeCentroids();
      };
      Sk.stdlib.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype);
      Sk.stdlib.RevolutionGeometry = function (a, b, c, d, e, f) {
        THREE.Geometry.call(this);
        c = c || 12;
        d = d || 0;
        e = e || 2 * Math.PI;
        var g = 0.0001 > Math.abs(2 * Math.PI - Math.abs(e - d)) ? c : c + 1, h = 1 / c, k = (e - d) * h;
        e = 0;
        for (var l = g; e < l; e++)
          for (var m = (d + e * k) / 2, n = Sk.math.cos(m), m = Sk.math.sin(m), p = new THREE.Quaternion(b.x * m, b.y * m, b.z * m, n), n = 0, m = a.length; n < m; n++) {
            var q = a[n], q = new THREE.Vector3(q.x, q.y, q.z);
            q.applyQuaternion(p);
            f && q.applyQuaternion(f);
            this.vertices.push(q);
          }
        b = 1 / (a.length - 1);
        d = a.length;
        g *= d;
        e = 0;
        for (l = c; e < l; e++)
          for (n = 0, m = a.length - 1; n < m; n++) {
            c = n + d * e;
            f = (c + d) % g;
            var k = (c + 1 + d) % g, p = (c + 1) % g, q = e * h, r = n * b, s = q + h, t = r + b;
            this.faces.push(new THREE.Face3(p, f, c % g));
            this.faceVertexUvs[0].push([
              new THREE.Vector2(q, r),
              new THREE.Vector2(s, r),
              new THREE.Vector2(q, t)
            ]);
            this.faces.push(new THREE.Face3(p, k, f));
            this.faceVertexUvs[0].push([
              new THREE.Vector2(s, r),
              new THREE.Vector2(s, t),
              new THREE.Vector2(q, t)
            ]);
          }
        this.computeCentroids();
        this.computeFaceNormals();
        this.computeVertexNormals();
      };
      Sk.stdlib.RevolutionGeometry.prototype = Object.create(THREE.Geometry.prototype);
      Sk.stdlib.TorusGeometry = function (a, b, c, d, e) {
        THREE.Geometry.call(this);
        this.radius = a || 100;
        this.tube = b || 40;
        this.radialSegments = c || 8;
        this.tubularSegments = d || 6;
        this.arc = e || 2 * Math.PI;
        e = new THREE.Vector3();
        a = [];
        b = [];
        for (c = 0; c <= this.radialSegments; c++)
          for (d = 0; d <= this.tubularSegments; d++) {
            var f = d / this.tubularSegments * this.arc, g = 2 * c / this.radialSegments * Math.PI;
            e.x = this.radius * Sk.math.cos(f);
            e.y = this.radius * Sk.math.sin(f);
            var h = new THREE.Vector3();
            h.x = (this.radius + this.tube * Sk.math.cos(g)) * Sk.math.cos(f);
            h.y = (this.radius + this.tube * Sk.math.cos(g)) * Sk.math.sin(f);
            h.z = this.tube * Sk.math.sin(g);
            this.vertices.push(h);
            a.push(new THREE.Vector2(d / this.tubularSegments, c / this.radialSegments));
            b.push(h.clone().sub(e).normalize());
          }
        for (c = 1; c <= this.radialSegments; c++)
          for (d = 1; d <= this.tubularSegments; d++) {
            e = (this.tubularSegments + 1) * c + d - 1;
            var f = (this.tubularSegments + 1) * (c - 1) + d - 1, g = (this.tubularSegments + 1) * (c - 1) + d, h = (this.tubularSegments + 1) * c + d, k = new THREE.Face3(e, f, h, [
                b[e],
                b[f],
                b[h]
              ]);
            k.normal.add(b[e]);
            k.normal.add(b[f]);
            k.normal.add(b[h]);
            k.normal.normalize();
            this.faces.push(k);
            this.faceVertexUvs[0].push([
              a[e].clone(),
              a[f].clone(),
              a[h].clone()
            ]);
            k = new THREE.Face3(f, g, h, [
              b[f],
              b[g],
              b[h]
            ]);
            k.normal.add(b[f]);
            k.normal.add(b[g]);
            k.normal.add(b[h]);
            k.normal.normalize();
            this.faces.push(k);
            this.faceVertexUvs[0].push([
              a[f].clone(),
              a[g].clone(),
              a[h].clone()
            ]);
          }
        this.computeCentroids();
      };
      Sk.stdlib.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype);
      Sk.stdlib.VortexGeometry = function (a, b, c, d, e, f, g) {
        function h(a, b) {
          var c = b % k;
          return c === k - 1 ? h(a, b - 1) : n * ((b - c) / k + c * p);
        }
        THREE.Geometry.call(this);
        var k = 9;
        this.radius = a || 1;
        this.radiusCone = b || 0.08;
        this.radiusShaft = c || 0.01;
        this.lengthCone = d || 0.2;
        this.lengthShaft = e || 0.8;
        f = f || 6;
        this.circleSegments = f * k;
        this.radialSegments = g || 8;
        g = 2 * Math.PI;
        var l = this.radius, m = new THREE.Vector3();
        a = [];
        d = [];
        var n = g / f, p = this.lengthShaft / (this.lengthCone + this.lengthShaft) / (k - 2);
        for (f = 0; f <= this.radialSegments; f++) {
          e = g * f / this.radialSegments;
          var q = Sk.math.cos(e), r = Sk.math.sin(e);
          for (e = 0; e <= this.circleSegments; e++) {
            var s = h(this.circleSegments, e), t = Sk.math.cos(s), s = Sk.math.sin(s);
            m.x = l * t;
            m.y = l * s;
            var u = new THREE.Vector3(), v = e % k === k - 1 ? b : c;
            u.x = (l + v * q) * t;
            u.y = (l + v * q) * s;
            u.z = v * r;
            this.vertices.push(u);
            a.push(new THREE.Vector2(e / this.circleSegments, f / this.radialSegments));
            d.push(u.clone().sub(m).normalize());
          }
        }
        for (f = 1; f <= this.radialSegments; f++)
          for (e = 1; e <= this.circleSegments; e++)
            b = (this.circleSegments + 1) * f + e - 1, c = (this.circleSegments + 1) * (f - 1) + e - 1, g = (this.circleSegments + 1) * (f - 1) + e, l = (this.circleSegments + 1) * f + e, m = new THREE.Face3(b, c, l, [
              d[b],
              d[c],
              d[l]
            ]), m.normal.add(d[b]), m.normal.add(d[c]), m.normal.add(d[l]), m.normal.normalize(), this.faces.push(m), this.faceVertexUvs[0].push([
              a[b].clone(),
              a[c].clone(),
              a[l].clone()
            ]), m = new THREE.Face3(c, g, l, [
              d[c],
              d[g],
              d[l]
            ]), m.normal.add(d[c]), m.normal.add(d[g]), m.normal.add(d[l]), m.normal.normalize(), this.faces.push(m), this.faceVertexUvs[0].push([
              a[c].clone(),
              a[g].clone(),
              a[l].clone()
            ]);
        this.computeCentroids();
      };
      Sk.stdlib.VortexGeometry.prototype = Object.create(THREE.Geometry.prototype);
      Sk.builtin.defineEuclidean3(a, THREE, b);
      a.Scene = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.isUndefined(b) ? (Sk.ffi.checkMethodArgs('Scene', arguments, 0, 0), Sk.ffi.referenceToPy(new THREE.Scene(), 'Scene', void 0, a)) : Sk.ffi.isInstance(b, 'Scene') ? Sk.ffi.referenceToPy(Sk.ffi.remapToJs(b), 'Scene', void 0, a) : Sk.ffi.checkMethodArgs('Scene', arguments, 0, 0);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'children':
            return Sk.ffi.listPy(d.children.map(function (b) {
              return Sk.ffi.callsim(a[Sk.three.OBJECT_3D], Sk.ffi.referenceToPy(b, Sk.three.OBJECT_3D));
            }));
          case 'position':
            return n(d.position);
          case 'quaternion':
            return Sk.ffi.callsim(a.Quaternion, Sk.ffi.referenceToPy(d.quaternion, 'Quaternion'));
          case 'rotation':
            return n(d.rotation);
          case 'eulerOrder':
            return Sk.ffi.stringToPy(d.eulerOrder);
          case 'scale':
            return n(d.scale);
          case 'up':
            return n(d.up);
          case 'useQuaternion':
            return d.useQuaternion;
          case 'lookAt':
            return r(b);
          case 'add':
            return s(d);
          case 'remove':
            return w(d);
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          var d = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'position':
          case 'rotation':
          case 'scale':
          case 'up':
            q(a, b, c);
            break;
          case 'quaternion':
            a.quaternion = d;
            break;
          case 'eulerOrder':
            if (e(d))
              a.eulerOrder = d;
            else
              throw Error(b + ' must be a string');
            break;
          case 'useQuaternion':
            a.useQuaternion = d;
            break;
          default:
            throw Error(b + ' is not a write attribute of Scene');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('Scene');
        });
      }, 'Scene', []);
      a.CanvasRenderer = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(b);
          Sk.ffi.referenceToPy(new THREE.CanvasRenderer(c), 'CanvasRenderer', void 0, a);
        });
        d.setSize = Sk.ffi.functionPy(function (a, b, c) {
          a.v.setSize(Sk.builtin.asnum$(b), Sk.builtin.asnum$(c));
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'autoClear':
            return d.autoClear;
          case 'gammaInput':
            return d.gammaInput;
          case 'gammaOutput':
            return d.gammaOutput;
          case 'sortObjects':
            return d.sortObjects;
          case 'canvas':
          case 'domElement':
            return Sk.ffi.callsim(a.Node, Sk.ffi.referenceToPy(d.domElement, 'Node'));
          case 'render':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'render';
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b, c) {
                b = Sk.ffi.remapToJs(b);
                c = Sk.ffi.remapToJs(c);
                d.render(b, c);
              });
              b.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('render');
              });
              b.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('render');
              });
            }, 'render', []));
          case 'getClearColor':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (b, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'getClearColor';
              });
              c.__call__ = Sk.ffi.functionPy(function (b) {
                return Sk.ffi.callsim(a.Color, Sk.ffi.referenceToPy(d.getClearColor(), 'Color'));
              });
              c.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('getClearColor');
              });
              c.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('getClearColor');
              });
            }, 'getClearColor', []));
          case 'setClearColor':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'setClearColor';
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b, c) {
                b = Sk.ffi.remapToJs(b);
                c = Sk.ffi.remapToJs(c);
                d.setClearColor(b, c);
              });
              b.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('setClearColor');
              });
              b.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('setClearColor');
              });
            }, 'setClearColor', []));
          case 'setSize':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'setSize';
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b, c, e) {
                b = Sk.ffi.remapToJs(b);
                c = Sk.ffi.remapToJs(c);
                e = Sk.ffi.remapToJs(e);
                d.setSize(b, c, e);
              });
              b.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('setSize');
              });
              b.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('setSize');
              });
            }, 'setSize', []));
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('CanvasRenderer');
          }
        });
        d.__setattr__ = Sk.ffi.functionPy(function (a, b, d) {
          a = Sk.ffi.remapToJs(a);
          d = Sk.ffi.remapToJs(d);
          switch (b) {
          case 'autoClear':
            if (c(d))
              a.autoClear = d;
            else
              throw new Sk.builtin.TypeError('\'autoClear\' attribute must be a <type \'bool\'>.');
            break;
          case 'gammaInput':
            if (c(d))
              a.gammaInput = d;
            else
              throw new Sk.builtin.TypeError('\'gammaInput\' attribute must be a <type \'bool\'>.');
            break;
          case 'gammaOutput':
            if (c(d))
              a.gammaOutput = d;
            else
              throw new Sk.builtin.TypeError('\'gammaOutput\' attribute must be a <type \'bool\'>.');
            break;
          case 'sortObjects':
            if (c(d))
              a.sortObjects = d;
            else
              throw new Sk.builtin.TypeError('\'sortObjects\' attribute must be a <type \'bool\'>.');
            break;
          case 'size':
            b = Sk.builtin.asnum$(d[0]);
            d = Sk.builtin.asnum$(d[1]);
            a.setSize(b, d);
            break;
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('CanvasRenderer');
          }
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          a = a.v;
          var b = {};
          b.autoClear = a.autoClear;
          b.gammaInput = a.gammaInput;
          b.gammaOutput = a.gammaOutput;
          return Sk.ffi.stringToPy('CanvasRenderer(' + JSON.stringify(b) + ')');
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('CanvasRenderer(' + [{ autoClear: a.v.autoClear }].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'CanvasRenderer', []);
      a.WebGLRenderer = Sk.ffi.buildClass(a, function (b, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, b) {
          0 < Sk.ffi.checkMethodArgs('WebGLRenderer', arguments, 0, 1) && Sk.ffi.checkArgType('parameters', Sk.ffi.PyType.DICT, Sk.ffi.isDict(b), b);
          var c = Sk.ffi.remapToJs(b);
          Sk.ffi.referenceToPy(new THREE.WebGLRenderer(c), 'WebGLRenderer', void 0, a);
        });
        d.setSize = Sk.ffi.functionPy(function (a, b, c) {
          a.v.setSize(Sk.builtin.asnum$(b), Sk.builtin.asnum$(c));
        });
        d.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'autoClear':
            return Sk.ffi.booleanToPy(d.autoClear);
          case 'autoClearColor':
            return Sk.ffi.booleanToPy(d.autoClearColor);
          case 'gammaInput':
            return Sk.ffi.booleanToPy(d.gammaInput);
          case 'gammaOutput':
            return Sk.ffi.booleanToPy(d.gammaOutput);
          case 'sortObjects':
            return d.sortObjects;
          case 'canvas':
          case 'domElement':
            return Sk.ffi.callsim(a.Node, Sk.ffi.referenceToPy(d.domElement, 'Node'));
          case 'render':
            return Sk.ffi.callableToPy(a, 'render', function (a, b, c) {
              Sk.ffi.checkMethodArgs('render', arguments, 2, 2);
              var e = Sk.ffi.remapToJs(b), f = Sk.ffi.remapToJs(c);
              return Sk.ffi.remapToPy(d.render(e, f));
            });
          case 'getClearColor':
            return Sk.ffi.callableToPy(a, 'getClearColor', function (b) {
              Sk.ffi.checkMethodArgs('getClearColor', arguments, 0, 0);
              return Sk.ffi.callsim(a.Color, Sk.ffi.referenceToPy(d.getClearColor(), 'Color'));
            });
          case 'setClearColor':
            return Sk.ffi.callableToPy(a, 'setClearColor', function (a, b, c) {
              Sk.ffi.checkMethodArgs('setClearColor', arguments, 2, 2);
              Sk.ffi.checkArgType('color', [
                'Color',
                Sk.ffi.PyType.INT
              ], Sk.ffi.isInstance(b, 'Color') || Sk.ffi.isInt(b), b);
              Sk.ffi.checkArgType('alpha', u, Sk.ffi.isNum(c), c);
              var e = Sk.ffi.remapToJs(b), f = Sk.ffi.remapToJs(c);
              return Sk.ffi.remapToPy(d.setClearColor(e, f));
            });
          case 'setSize':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'setSize';
              });
              b.__call__ = Sk.ffi.functionPy(function (a, b, c, e) {
                b = Sk.ffi.remapToJs(b);
                c = Sk.ffi.remapToJs(c);
                e = Sk.ffi.remapToJs(e);
                d.setSize(b, c, e);
              });
              b.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('setSize');
              });
              b.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('setSize');
              });
            }, 'setSize', []));
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('WebGLRenderer');
          }
        });
        d.__setattr__ = Sk.ffi.functionPy(function (a, b, d) {
          a = Sk.ffi.remapToJs(a);
          var e = Sk.ffi.remapToJs(d);
          switch (b) {
          case 'autoClear':
            if (c(e))
              a.autoClear = e;
            else
              throw new Sk.builtin.TypeError('\'autoClear\' attribute must be a <type \'bool\'>.');
            break;
          case 'autoClearColor':
            Sk.ffi.checkArgType('autoClearColor', Sk.ffi.PyType.BOOL, Sk.ffi.isBool(d), d);
            a.autoClearColor = Sk.ffi.remapToJs(d);
            break;
          case 'gammaInput':
            if (c(e))
              a.gammaInput = e;
            else
              throw new Sk.builtin.TypeError('\'gammaInput\' attribute must be a <type \'bool\'>.');
            break;
          case 'gammaOutput':
            if (c(e))
              a.gammaOutput = e;
            else
              throw new Sk.builtin.TypeError('\'gammaOutput\' attribute must be a <type \'bool\'>.');
            break;
          case 'sortObjects':
            if (c(e))
              a.sortObjects = e;
            else
              throw new Sk.builtin.TypeError('\'sortObjects\' attribute must be a <type \'bool\'>.');
            break;
          case 'size':
            b = Sk.builtin.asnum$(e[0]);
            d = Sk.builtin.asnum$(e[1]);
            a.setSize(b, d);
            break;
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('WebGLRenderer');
          }
        });
        d.__str__ = Sk.ffi.functionPy(function (a) {
          a = a.v;
          var b = {};
          b.autoClear = a.autoClear;
          b.gammaInput = a.gammaInput;
          b.gammaOutput = a.gammaOutput;
          return Sk.ffi.stringToPy('WebGLRenderer(' + JSON.stringify(b) + ')');
        });
        d.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('WebGLRenderer(' + [{ autoClear: a.v.autoClear }].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'WebGLRenderer', []);
      a.Color = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(b);
          Sk.ffi.isUndefined(b) ? Sk.ffi.referenceToPy(new THREE.Color(), 'Color', void 0, a) : Sk.ffi.isInt(b) || Sk.ffi.isStr(b) ? Sk.ffi.referenceToPy(new THREE.Color(c), 'Color', void 0, a) : Sk.ffi.isInstance(b, 'Color') ? Sk.ffi.referenceToPy(c, 'Color', void 0, a) : Sk.ffi.checkArgType('value', [
            Sk.ffi.PyType.INT,
            Sk.ffi.PyType.STR,
            'Color'
          ], !1, c);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'r':
            return Sk.ffi.numberToIntPy(d.r);
          case 'g':
            return Sk.ffi.numberToIntPy(d.g);
          case 'b':
            return Sk.ffi.numberToIntPy(d.b);
          case 'getHex':
            return Sk.ffi.callableToPy(a, c, function (a) {
              return Sk.ffi.numberToIntPy(d.getHex());
            });
          case 'getHexString':
            return Sk.ffi.callableToPy(a, 'getHexString', function (a) {
              return Sk.ffi.stringToPy(d.getHexString());
            });
          case 'setHex':
            return Sk.ffi.callableToPy(a, c, function (a, e) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('hex', Sk.ffi.PyType.INT, Sk.ffi.isInt(e), e);
              d.setHex(Sk.ffi.remapToJs(e));
              return b;
            });
          case 'setRGB':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'setRGB';
              });
              c.__call__ = Sk.ffi.functionPy(function (a, c, e, f) {
                a = Sk.ffi.remapToJs(c);
                e = Sk.ffi.remapToJs(e);
                f = Sk.ffi.remapToJs(f);
                d.setRGB(a, e, f);
                return b;
              });
              c.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('setRGB');
              });
              c.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('setRGB');
              });
            }, 'setRGB', []));
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('Color');
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'r':
          case 'g':
          case 'b':
            Sk.ffi.checkArgType(b, [
              Sk.ffi.PyType.FLOAT,
              Sk.ffi.PyType.INT
            ], Sk.ffi.isFloat(c) || Sk.ffi.isInt(c), c);
            a.r = Sk.ffi.remapToJs(c);
            break;
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('Color');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.r = a.r;
          b.g = a.g;
          b.b = a.b;
          return Sk.ffi.stringToPy('Color(' + JSON.stringify(b) + ')');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('Color(' + [
            a.r,
            a.g,
            a.b
          ].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'Color', []);
      a.PerspectiveCamera = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e) {
          Sk.ffi.checkMethodArgs('PerspectiveCamera', arguments, 0, 4);
          Sk.ffi.isDefined(b) && Sk.ffi.checkArgType('fov', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(b), b);
          Sk.ffi.isDefined(c) && Sk.ffi.checkArgType('aspect', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(c), c);
          Sk.ffi.isDefined(d) && Sk.ffi.checkArgType('near', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(d), d);
          Sk.ffi.isDefined(e) && Sk.ffi.checkArgType('far', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(e), e);
          var f = Sk.ffi.remapToJs(b), g = Sk.ffi.remapToJs(c), h = Sk.ffi.remapToJs(d), k = Sk.ffi.remapToJs(e);
          Sk.ffi.referenceToPy(new THREE.PerspectiveCamera(f, g, h, k), 'PerspectiveCamera', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'aspect':
            return Sk.ffi.numberToFloatPy(d.aspect);
          case 'position':
            return n(d.position);
          case 'quaternion':
            return Sk.ffi.callsim(a.Quaternion, Sk.ffi.referenceToPy(d.quaternion, 'Quaternion'));
          case 'rotation':
            return n(d.rotation);
          case 'eulerOrder':
            return Sk.ffi.stringToPy(d.eulerOrder);
          case 'scale':
            return n(d.scale);
          case 'up':
            return n(d.up);
          case 'useQuaternion':
            return d.useQuaternion;
          case 'lookAt':
            return r(b);
          case 'updateProjectionMatrix':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'updateProjectionMatrix';
              });
              b.__call__ = Sk.ffi.functionPy(function (a) {
                d[c]();
              });
              b.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('updateProjectionMatrix');
              });
              b.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('updateProjectionMatrix');
              });
            }, 'updateProjectionMatrix', []));
          default:
            return J(b, c, 'PerspectiveCamera');
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          var d = Sk.ffi.remapToJs(a), f = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'aspect':
            d.aspect = f;
            break;
          case 'position':
          case 'rotation':
          case 'scale':
          case 'up':
            q(d, b, c);
            break;
          case 'quaternion':
            d.quaternion = f;
            break;
          case 'eulerOrder':
            if (e(f))
              d.eulerOrder = f;
            else
              throw Error(b + ' must be a string');
            break;
          case 'useQuaternion':
            d.useQuaternion = f;
            break;
          default:
            return K(a, b, c, 'PerspectiveCamera');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.fov = a.fov;
          b.aspect = a.aspect;
          b.near = a.near;
          b.far = a.far;
          return Sk.ffi.stringToPy('PerspectiveCamera(' + JSON.stringify(b) + ')');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('PerspectiveCamera(' + [
            a.fov,
            a.aspect,
            a.near,
            a.far
          ].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'PerspectiveCamera', []);
      a.OrthographicCamera = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e, f, g) {
          Sk.ffi.checkMethodArgs('OrthographicCamera', arguments, 0, 6);
          Sk.ffi.isDefined(b) && Sk.ffi.checkArgType('left', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(b), b);
          Sk.ffi.isDefined(c) && Sk.ffi.checkArgType('right', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(c), c);
          Sk.ffi.isDefined(d) && Sk.ffi.checkArgType('top', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(d), d);
          Sk.ffi.isDefined(e) && Sk.ffi.checkArgType('bottom', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(e), e);
          Sk.ffi.isDefined(f) && Sk.ffi.checkArgType('near', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(f), f);
          Sk.ffi.isDefined(g) && Sk.ffi.checkArgType('far', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(g), g);
          var h = Sk.ffi.remapToJs(b), k = Sk.ffi.remapToJs(c), l = Sk.ffi.remapToJs(d), m = Sk.ffi.remapToJs(e), n = Sk.ffi.remapToJs(f), p = Sk.ffi.remapToJs(g);
          Sk.ffi.referenceToPy(new THREE.OrthographicCamera(h, k, l, m, n, p), 'OrthographicCamera', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'aspect':
            return Sk.ffi.numberToFloatPy(d.aspect);
          case 'position':
            return n(d.position);
          case 'quaternion':
            return Sk.ffi.callsim(a.Quaternion, Sk.ffi.referenceToPy(d.quaternion, 'Quaternion'));
          case 'rotation':
            return n(d.rotation);
          case 'eulerOrder':
            return Sk.ffi.stringToPy(d.eulerOrder);
          case 'scale':
            return n(d.scale);
          case 'up':
            return n(d.up);
          case 'useQuaternion':
            return d.useQuaternion;
          case 'lookAt':
            return r(b);
          case 'updateProjectionMatrix':
            return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'updateProjectionMatrix';
              });
              b.__call__ = Sk.ffi.functionPy(function (a) {
                d[c]();
              });
              b.__str__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('updateProjectionMatrix');
              });
              b.__repr__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.stringToPy('updateProjectionMatrix');
              });
            }, 'updateProjectionMatrix', []));
          default:
            return J(b, c, 'OrthographicCamera');
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          var d = Sk.ffi.remapToJs(a), f = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'left':
            d.left = f;
            break;
          case 'right':
            d.right = f;
            break;
          case 'top':
            d.top = f;
            break;
          case 'bottom':
            d.bottom = f;
            break;
          case 'position':
          case 'rotation':
          case 'scale':
          case 'up':
            q(d, b, c);
            break;
          case 'quaternion':
            d.quaternion = f;
            break;
          case 'eulerOrder':
            if (e(f))
              d.eulerOrder = f;
            else
              throw Error(b + ' must be a string');
            break;
          case 'useQuaternion':
            d.useQuaternion = f;
            break;
          default:
            return K(a, b, c, 'OrthographicCamera');
          }
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('OrthographicCamera(' + [
            a.left,
            a.right,
            a.top,
            a.bottom,
            a.near,
            a.far
          ].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('OrthographicCamera');
        });
      }, 'OrthographicCamera', []);
      a[Sk.three.ARROW_GEOMETRY] = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e, f, g, h, k) {
          Sk.ffi.checkMethodArgs(Sk.three.ARROW_GEOMETRY, arguments, 0, 8);
          var l, m, n, p;
          if (Sk.ffi.isDefined(b)) {
            if (Sk.ffi.isInstance(b, Sk.three.ARROW_GEOMETRY)) {
              Sk.ffi.checkMethodArgs(Sk.three.ARROW_GEOMETRY, arguments, 1, 1);
              Sk.ffi.referenceToPy(Sk.ffi.remapToJs(b), Sk.three.ARROW_GEOMETRY, void 0, a);
              return;
            }
            Sk.ffi.checkArgType('scale', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(b), b);
            l = Sk.ffi.remapToJs(b);
          } else
            l = 1;
          Sk.ffi.isDefined(c) ? (Sk.ffi.checkArgType('attitude', 'Euclidean3', Sk.ffi.isInstance(c, 'Euclidean3'), c), m = Sk.ffi.remapToJs(c).quaternion) : m = new THREE.Quaternion(0, 0, 0, 1);
          Sk.ffi.isDefined(d) && Sk.ffi.checkArgType('segments', t, Sk.ffi.isInt(d), d);
          Sk.ffi.isDefined(e) ? (Sk.ffi.checkArgType('length', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(e), e), n = Sk.ffi.remapToJs(e) * l) : n = l;
          Sk.ffi.isDefined(k) ? (Sk.ffi.checkArgType('axis', 'Euclidean3', Sk.ffi.isInstance(k, 'Euclidean3'), k), p = Sk.ffi.remapToJs(k).vector) : p = new THREE.Vector3(0, 0, 1);
          var q = Sk.ffi.remapToJs(d);
          f = (Sk.ffi.remapToJs(f) || 0.01) * l;
          g = (Sk.ffi.remapToJs(g) || 0.08) * l;
          h = (Sk.ffi.remapToJs(h) || 0.2) * l;
          var B = n - h, r = n / 2;
          l = function (a) {
            var b;
            b = a.x ? 2 : a.y ? 1 : 0;
            var c = 0 < a.x ? 1 : 0 > a.x ? -1 : 0 < a.y ? 1 : 0 > a.y ? -1 : 0 < a.z ? 1 : 0 > a.z ? -1 : 0, d = (b + 0) % 3, e = (b + 1) % 3, h = (b + 2) % 3;
            b = [
              [
                0,
                0,
                r * c
              ],
              [
                g,
                0,
                (B - r) * c
              ],
              [
                f,
                0,
                (B - r) * c
              ],
              [
                f,
                0,
                -r * c
              ],
              [
                0,
                0,
                -r * c
              ]
            ].map(function (a) {
              return new THREE.Vector3(a[d], a[e], a[h]);
            });
            a = new THREE.Quaternion(a.x, a.y, a.z, 0);
            return {
              points: b,
              generator: a
            };
          }(p);
          Sk.ffi.referenceToPy(new Sk.stdlib.RevolutionGeometry(l.points, l.generator, q, 0, 2 * Math.PI, m), Sk.three.ARROW_GEOMETRY, void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          return H(Sk.three.ARROW_GEOMETRY, a, b);
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return G(Sk.three.ARROW_GEOMETRY, a, b, c);
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [].map(function (b) {
              return [
                b,
                Sk.ffi.remapToJs(Sk.ffh.str(Sk.ffi.gattr(a, b)))
              ].join('=');
            });
          return Sk.ffi.stringToPy(Sk.three.ARROW_GEOMETRY + '(' + b.join(', ') + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy(Sk.three.ARROW_GEOMETRY + '(' + [].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, Sk.three.ARROW_GEOMETRY, []);
      a.CircleGeometry = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e) {
          Sk.ffi.checkMethodArgs('CircleGeometry', arguments, 0, 4);
          Sk.ffi.isDefined(b) && Sk.ffi.checkArgType('radius', u, Sk.ffi.isNum(b), b);
          Sk.ffi.isDefined(c) && Sk.ffi.checkArgType('segments', t, Sk.ffi.isInt(c), c);
          Sk.ffi.isDefined(d) && Sk.ffi.checkArgType('thetaStart', u, Sk.ffi.isNum(d), d);
          Sk.ffi.isDefined(e) && Sk.ffi.checkArgType('thetaLength', u, Sk.ffi.isNum(e), e);
          Sk.ffi.referenceToPy(new THREE.CircleGeometry(Sk.ffi.remapToJs(b), Sk.ffi.remapToJs(c), Sk.ffi.remapToJs(d), Sk.ffi.remapToJs(e)), 'CircleGeometry', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          return H('CircleGeometry', a, b);
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return G('CircleGeometry', a, b, c);
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('CircleGeometry(' + JSON.stringify({}) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('CircleGeometry(' + [].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'CircleGeometry', []);
      a.CubeGeometry = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e, f, g) {
          Sk.ffi.checkMethodArgs('CubeGeometry', arguments, 3, 6);
          Sk.ffi.checkArgType('width', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(b), b);
          Sk.ffi.checkArgType('height', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(c), c);
          Sk.ffi.checkArgType('depth', Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(d), d);
          Sk.ffi.isDefined(e) && Sk.ffi.checkArgType('widthSegments', t, Sk.ffi.isInt(e), e);
          Sk.ffi.isDefined(f) && Sk.ffi.checkArgType('heightSegments', t, Sk.ffi.isInt(f), f);
          Sk.ffi.isDefined(g) && Sk.ffi.checkArgType('depthSegments', t, Sk.ffi.isInt(g), g);
          var h = Sk.ffi.remapToJs(b), k = Sk.ffi.remapToJs(c), l = Sk.ffi.remapToJs(d), m = Sk.ffi.remapToJs(e), n = Sk.ffi.remapToJs(f), p = Sk.ffi.remapToJs(g);
          Sk.ffi.referenceToPy(new THREE.CubeGeometry(h, k, l, m, n, p), 'CubeGeometry', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'width':
          case 'height':
          case 'depth':
            return Sk.ffi.numberToFloatPy(c[b]);
          case 'widthSegments':
          case 'heightSegments':
          case 'depthSegments':
            return Sk.ffi.numberToIntPy(c[b]);
          default:
            return H('CubeGeometry', a, b);
          }
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return G('CubeGeometry', a, b, c);
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.width = a.width;
          b.height = a.height;
          b.depth = a.depth;
          return Sk.ffi.stringToPy('CubeGeometry(' + JSON.stringify(b) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('CubeGeometry(' + [
            a.width,
            a.height,
            a.depth,
            a.widthSegments,
            a.heightSegments,
            a.depthSegments
          ].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'CubeGeometry', []);
      a.CylinderGeometry = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e, f, g, h) {
          if (Sk.ffi.isInstance(b, 'CylinderGeometry'))
            Sk.ffi.referenceToPy(Sk.ffi.remapToJs(b), 'CylinderGeometry', void 0, a);
          else {
            Sk.ffi.checkMethodArgs('CylinderGeometry', arguments, 0, 7);
            Sk.ffi.checkArgType('radiusTop', u, Sk.ffi.isNum(b) || Sk.ffi.isUndefined(b), b);
            Sk.ffi.checkArgType('radiusBottom', u, Sk.ffi.isNum(c) || Sk.ffi.isUndefined(c), c);
            Sk.ffi.checkArgType('height', u, Sk.ffi.isNum(d) || Sk.ffi.isUndefined(d), d);
            Sk.ffi.checkArgType('radialSegments', Sk.ffi.PyType.INT, Sk.ffi.isInt(e) || Sk.ffi.isUndefined(e), e);
            Sk.ffi.checkArgType('heightSegments', Sk.ffi.PyType.INT, Sk.ffi.isInt(f) || Sk.ffi.isUndefined(f), f);
            Sk.ffi.checkArgType('openEnded', Sk.ffi.PyType.BOOL, Sk.ffi.isBool(g) || Sk.ffi.isUndefined(g), g);
            var k = Sk.ffi.remapToJs(b), l = Sk.ffi.remapToJs(c), m = Sk.ffi.remapToJs(d), n = Sk.ffi.remapToJs(e), p = Sk.ffi.remapToJs(f), q = Sk.ffi.remapToJs(g), B;
            Sk.ffi.isDefined(h) ? (Sk.ffi.checkArgType('axis', 'Euclidean3', Sk.ffi.isInstance(h, 'Euclidean3'), h), B = Sk.ffi.remapToJs(h).vector) : B = new THREE.Vector3(0, 0, 1);
            Sk.ffi.referenceToPy(new Sk.stdlib.CylinderGeometry(k, l, m, n, p, q, B), 'CylinderGeometry', void 0, a);
          }
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'radiusTop':
            return Sk.ffi.numberToFloatPy(c.radiusTop);
          case 'radiusBottom':
            return Sk.ffi.numberToFloatPy(c.radiusBottom);
          case 'height':
            return Sk.ffi.numberToFloatPy(c.height);
          case 'radialSegments':
            return Sk.ffi.numberToIntPy(c.radialSegments);
          case 'heightSegments':
            return Sk.ffi.numberToIntPy(c.heightSegments);
          case 'openEnded':
            return Sk.ffi.booleanToPy(c.openEnded);
          default:
            return H('CylinderGeometry', a, b);
          }
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return G('CylinderGeometry', a, b, c);
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.radiusTop = a.radiusTop;
          b.radiusBottom = a.radiusBottom;
          b.height = a.height;
          b.openEnded = a.openEnded;
          return Sk.ffi.stringToPy('CylinderGeometry(' + JSON.stringify(b) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('CylinderGeometry(' + [
            a.radiusTop,
            a.radiusBottom,
            a.height,
            a.radialSegments,
            a.heightSegments,
            a.openEnded
          ].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'CylinderGeometry', []);
      a.LatheGeometry = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e) {
          Sk.ffi.checkMethodArgs('LatheGeometry', arguments, 1, 4);
          var f = Sk.ffi.remapToJs(b).map(function (a) {
              return new THREE.Vector3(a.x, a.y, a.z);
            }), g = new THREE.Quaternion(0, 0, 1, 0);
          Sk.ffi.referenceToPy(new Sk.stdlib.RevolutionGeometry(f, g, Sk.ffi.remapToJs(c), Sk.ffi.remapToJs(d), Sk.ffi.remapToJs(e)), 'LatheGeometry', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          return H('LatheGeometry', a, b);
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return G('LatheGeometry', a, b, c);
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('LatheGeometry(' + JSON.stringify({}) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('LatheGeometry(' + [].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'LatheGeometry', []);
      a.IcosahedronGeometry = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs('IcosahedronGeometry', arguments, 0, 2);
          Sk.ffi.isDefined(b) && Sk.ffi.checkArgType('radius', u, Sk.ffi.isNum(b), b);
          Sk.ffi.isDefined(c) && Sk.ffi.checkArgType('detail', t, Sk.ffi.isInt(c), c);
          var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c);
          Sk.ffi.referenceToPy(new THREE.IcosahedronGeometry(d, e), 'IcosahedronGeometry', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'radius':
            return Sk.ffi.numberToFloatPy(c.radius);
          case 'detail':
            return Sk.ffi.numberToIntPy(c.detail);
          default:
            throw Sk.ffi.err.attribute(b).isNotGetableOnType('IcosahedronGeometry');
          }
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          switch (b) {
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('IcosahedronGeometry');
          }
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.radius = a.radius;
          b.detail = a.detail;
          return Sk.ffi.stringToPy('IcosahedronGeometry(' + JSON.stringify(b) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('IcosahedronGeometry(' + [
            a.radius,
            a.detail
          ].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'IcosahedronGeometry', []);
      a.OctahedronGeometry = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs('OctahedronGeometry', arguments, 0, 2);
          Sk.ffi.isDefined(b) && Sk.ffi.checkArgType('radius', u, Sk.ffi.isNum(b), b);
          Sk.ffi.isDefined(c) && Sk.ffi.checkArgType('detail', t, Sk.ffi.isInt(c), c);
          var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c), f = new THREE.OctahedronGeometry(d, e);
          f.radius = d;
          f.detail = e;
          Sk.ffi.referenceToPy(f, 'OctahedronGeometry', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'radius':
            return Sk.ffi.numberToFloatPy(c.radius);
          case 'detail':
            return Sk.ffi.numberToIntPy(c.detail);
          default:
            throw Sk.ffi.err.attribute(b).isNotGetableOnType('OctahedronGeometry');
          }
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          switch (b) {
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('OctahedronGeometry');
          }
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.radius = a.radius;
          b.detail = a.detail;
          return Sk.ffi.stringToPy('OctahedronGeometry(' + JSON.stringify(b) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('OctahedronGeometry(' + [
            a.radius,
            a.detail
          ].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'OctahedronGeometry', []);
      a.PlaneGeometry = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e) {
          Sk.ffi.checkMethodArgs('PlaneGeometry', arguments, 2, 4);
          Sk.ffi.checkArgType('width', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(b), b);
          Sk.ffi.checkArgType('depth', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(c), c);
          g(d) && Sk.ffi.checkArgType('widthSegments', Sk.ffi.PyType.INT, Sk.ffi.isInt(d), d);
          g(e) && Sk.ffi.checkArgType('heightSegments', Sk.ffi.PyType.INT, Sk.ffi.isInt(e), e);
          var f = Sk.ffi.remapToJs(b), h = Sk.ffi.remapToJs(c), k = Sk.ffi.remapToJs(d), l = Sk.ffi.remapToJs(e);
          Sk.ffi.referenceToPy(new Sk.stdlib.PlaneGeometry(f, h, k, l), 'PlaneGeometry', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          return H('PlaneGeometry', a, b);
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return G('PlaneGeometry', a, b, c);
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [
              'width',
              'height'
            ].map(function (b) {
              return [
                b,
                Sk.ffi.remapToJs(Sk.ffh.str(Sk.ffi.gattr(a, b)))
              ].join('=');
            });
          return Sk.ffi.stringToPy('PlaneGeometry(' + b.join(', ') + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [
              'width',
              'height'
            ].map(function (b) {
              return Sk.ffi.gattr(a, b);
            }).map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffh.repr(a));
            });
          return Sk.ffi.stringToPy('PlaneGeometry(' + b.join(', ') + ')');
        });
      }, 'PlaneGeometry', []);
      a.RevolutionGeometry = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e, f, g) {
          Sk.ffi.checkMethodArgs('RevolutionGeometry', arguments, 2, 5);
          Sk.ffi.checkArgType('points', Sk.ffi.PyType.LIST, Sk.ffi.isList(b), b);
          Sk.ffi.checkArgType('generator', 'Euclidean3', Sk.ffi.isInstance(c, 'Euclidean3'), c);
          Sk.ffi.isDefined(d) && Sk.ffi.checkArgType('segments', Sk.ffi.PyType.INT, Sk.ffi.isInt(d), d);
          Sk.ffi.isDefined(e) && Sk.ffi.checkArgType('phiStart', u, Sk.ffi.isNum(e), e);
          Sk.ffi.isDefined(f) && Sk.ffi.checkArgType('phiLength', u, Sk.ffi.isNum(f), f);
          Sk.ffi.isDefined(g) && Sk.ffi.checkArgType('attitude', 'Euclidean3', Sk.ffi.isInstance(g, 'Euclidean3'), g);
          var h = Sk.ffi.remapToJs(b).map(function (a) {
              return new THREE.Vector3(a.x, a.y, a.z);
            }), k = Sk.ffi.remapToJs(g), k = Sk.ffi.remapToJs(g) ? Sk.ffi.remapToJs(g).quaternion : void 0;
          Sk.ffi.referenceToPy(new Sk.stdlib.RevolutionGeometry(h, Sk.ffi.remapToJs(c).quaternion, Sk.ffi.remapToJs(d), Sk.ffi.remapToJs(e), Sk.ffi.remapToJs(f), k), 'RevolutionGeometry', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.remapToJs(a);
          switch (b) {
          default:
            return H('RevolutionGeometry', a, b);
          }
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.remapToJs(a);
          Sk.ffi.remapToJs(c);
          switch (b) {
          default:
            return G('RevolutionGeometry', a, b, c);
          }
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('RevolutionGeometry(' + JSON.stringify({}) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('RevolutionGeometry(' + [].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'RevolutionGeometry', []);
      a.SphereGeometry = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e, f, h, k) {
          if (Sk.ffi.isDefined(b)) {
            if (Sk.ffi.isInstance(b, 'SphereGeometry')) {
              Sk.ffi.checkMethodArgs('SphereGeometry', arguments, 1, 1);
              Sk.ffi.referenceToPy(Sk.ffi.remapToJs(b), 'SphereGeometry', void 0, a);
              return;
            }
            Sk.ffi.checkArgType('radius', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(b), b);
          }
          g(c) && Sk.ffi.checkArgType('widthSegments', Sk.ffi.PyType.INT, Sk.ffi.isInt(c), c);
          g(d) && Sk.ffi.checkArgType('heightSegments', Sk.ffi.PyType.INT, Sk.ffi.isInt(d), d);
          var l = Sk.ffi.remapToJs(b), m = Sk.ffi.remapToJs(c), n = Sk.ffi.remapToJs(d);
          e = I(e, 'phiStart', 'SphereGeometry');
          f = I(f, 'phiLength', 'SphereGeometry');
          h = I(h, 'thetaStart', 'SphereGeometry');
          k = I(k, 'thetaLength', 'SphereGeometry');
          Sk.ffi.referenceToPy(new THREE.SphereGeometry(l, m, n, e, f, h, k), 'SphereGeometry', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'radius':
            return Sk.ffi.numberToFloatPy(c.radius);
          case 'widthSegments':
            return Sk.ffi.numberToIntPy(c.widthSegments);
          case 'heightSegments':
            return Sk.ffi.numberToIntPy(c.heightSegments);
          case 'phiStart':
            return Sk.ffi.numberToFloatPy(c.phiStart);
          case 'phiLength':
            return Sk.ffi.numberToFloatPy(c.phiLength);
          case 'thetaStart':
            return Sk.ffi.numberToFloatPy(c.thetaStart);
          case 'thetaLength':
            return Sk.ffi.numberToFloatPy(c.thetaLength);
          default:
            return H('SphereGeometry', a, b);
          }
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          switch (b) {
          default:
            return G('SphereGeometry', a, b, c);
          }
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = 'radius widthSegments heightSegments phiStart phiLength thetaStart thetaLength'.split(' ').map(function (b) {
              return [
                b,
                Sk.ffi.remapToJs(Sk.ffh.str(Sk.ffi.gattr(a, b)))
              ].join('=');
            });
          return Sk.ffi.stringToPy('SphereGeometry(' + b.join(', ') + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('SphereGeometry(' + [
            a.radius,
            a.widthSegments,
            a.heightSegments,
            a.phiStart,
            a.phiLength,
            a.thetaStart,
            a.thetaLength
          ].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'SphereGeometry', []);
      a.TetrahedronGeometry = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs('TetrahedronGeometry', arguments, 2, 2);
          Sk.ffi.checkArgType('radius', u, Sk.ffi.isNum(b), b);
          Sk.ffi.checkArgType('detail', t, Sk.ffi.isInt(c), c);
          var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c), f = new THREE.TetrahedronGeometry(d, e);
          f.radius = d;
          f.detail = e;
          Sk.ffi.referenceToPy(f, 'TetrahedronGeometry', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'radius':
            return Sk.ffi.numberToFloatPy(c.radius);
          case 'detail':
            return Sk.ffi.numberToIntPy(c.detail);
          default:
            return H('TetrahedronGeometry', a, b);
          }
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return G('TetrahedronGeometry', a, b, c);
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.radius = a.radius;
          b.detail = a.detail;
          return Sk.ffi.stringToPy('TetrahedronGeometry(' + JSON.stringify(b) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('TetrahedronGeometry(' + [
            a.radius,
            a.detail
          ].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'TetrahedronGeometry', []);
      a.TextGeometry = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          b = Sk.ffi.remapToJs(b);
          c = Sk.ffi.remapToJs(c);
          a.v = new THREE.TextGeometry(b, c);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          return H('TextGeometry', a, b);
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return G('TextGeometry', a, b, c);
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('TextGeometry(' + JSON.stringify({}) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('TextGeometry(' + [].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'TextGeometry', []);
      a.TorusGeometry = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e, f) {
          Sk.ffi.checkMethodArgs('TorusGeometry', arguments, 0, 5);
          Sk.ffi.isDefined(b) && Sk.ffi.checkArgType('radius', u, Sk.ffi.isNum(b), b);
          Sk.ffi.isDefined(c) && Sk.ffi.checkArgType('tube', u, Sk.ffi.isNum(c), c);
          Sk.ffi.isDefined(d) && Sk.ffi.checkArgType('radialSegments', t, Sk.ffi.isInt(d), d);
          Sk.ffi.isDefined(e) && Sk.ffi.checkArgType('tubularSegments', t, Sk.ffi.isInt(e), e);
          Sk.ffi.isDefined(f) && Sk.ffi.checkArgType('arc', u, Sk.ffi.isNum(f), f);
          var g = Sk.ffi.remapToJs(b), h = Sk.ffi.remapToJs(c), k = Sk.ffi.remapToJs(d), l = Sk.ffi.remapToJs(e), m = Sk.ffi.remapToJs(f), g = new Sk.stdlib.TorusGeometry(g, h, k, l, m);
          Sk.ffi.referenceToPy(g, 'TorusGeometry', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'radius':
            return Sk.ffi.numberToFloatPy(c.radius);
          case 'tube':
            return Sk.ffi.numberToFloatPy(c.tube);
          case 'radialSegments':
            return Sk.ffi.numberToIntPy(c.radialSegments);
          case 'tubularSegments':
            return Sk.ffi.numberToIntPy(c.tubularSegments);
          case 'arc':
            return Sk.ffi.numberToFloatPy(c.arc);
          default:
            return H('TorusGeometry', a, b);
          }
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return G('TorusGeometry', a, b, c);
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [
              'radius',
              'tube',
              'radialSegments',
              'tubularSegments',
              'arc'
            ].map(function (b) {
              return [
                b,
                Sk.ffi.remapToJs(Sk.ffh.str(Sk.ffi.gattr(a, b)))
              ].join('=');
            });
          return Sk.ffi.stringToPy('TorusGeometry(' + b.join(', ') + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [
              'radius',
              'tube',
              'radialSegments',
              'tubularSegments',
              'arc'
            ].map(function (b) {
              return Sk.ffi.gattr(a, b);
            }).map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffh.repr(a));
            });
          return Sk.ffi.stringToPy('TorusGeometry(' + b.join(', ') + ')');
        });
      }, 'TorusGeometry', []);
      a[Sk.three.VORTEX_GEOMETRY] = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e, f, h, k) {
          Sk.ffi.checkMethodArgs(Sk.three.VORTEX_GEOMETRY, arguments, 7, 7);
          Sk.ffi.checkArgType('radius', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(b), b);
          Sk.ffi.checkArgType('radiusCone', u, Sk.ffi.isNum(c), c);
          Sk.ffi.checkArgType('radiusShaft', u, Sk.ffi.isNum(d), d);
          var l = Sk.ffi.remapToJs(b), m = Sk.ffi.remapToJs(c), n = Sk.ffi.remapToJs(d), p = Sk.ffi.remapToJs(e), q = Sk.ffi.remapToJs(f);
          g(h) && Sk.ffi.checkArgType('widthSegments', Sk.ffi.PyType.INT, Sk.ffi.isInt(h), h);
          g(k) && Sk.ffi.checkArgType('heightSegments', Sk.ffi.PyType.INT, Sk.ffi.isInt(k), k);
          var B = Sk.ffi.remapToJs(h), r = Sk.ffi.remapToJs(k), l = new Sk.stdlib.VortexGeometry(l, m, n, p, q, B, r);
          Sk.ffi.referenceToPy(l, Sk.three.VORTEX_GEOMETRY, void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'radius':
            return Sk.ffi.numberToFloatPy(c.radius);
          case 'radiusCone':
            return Sk.ffi.numberToFloatPy(c.radiusCone);
          case 'radiusShaft':
            return Sk.ffi.numberToFloatPy(c.radiusShaft);
          case 'widthSegments':
            return Sk.ffi.numberToIntPy(c.widthSegments);
          case 'depthSegments':
          case 'heightSegments':
            return Sk.ffi.numberToIntPy(c.heightSegments);
          default:
            return H(Sk.three.VORTEX_GEOMETRY, a, b);
          }
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return G(Sk.three.VORTEX_GEOMETRY, a, b, c);
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [
              'radius',
              'radiusCone',
              'radiusShaft'
            ].map(function (b) {
              return [
                b,
                Sk.ffi.remapToJs(Sk.ffh.str(Sk.ffi.gattr(a, b)))
              ].join('=');
            });
          return Sk.ffi.stringToPy(Sk.three.VORTEX_GEOMETRY + '(' + b.join(', ') + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [
              'radius',
              'radiusCone',
              'radiusShaft'
            ].map(function (b) {
              return Sk.ffi.gattr(a, b);
            }).map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffh.repr(a));
            });
          return Sk.ffi.stringToPy(Sk.three.VORTEX_GEOMETRY + '(' + b.join(', ') + ')');
        });
      }, Sk.three.VORTEX_GEOMETRY, []);
      a.Geometry = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b) {
          g(b) ? Sk.ffi.referenceToPy(Sk.ffi.remapToJs(b), 'Geometry', void 0, a) : Sk.ffi.referenceToPy(new THREE.Geometry(), 'Geometry', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          return H('Geometry', a, b);
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return G('Geometry', a, b, c);
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('Geometry(' + JSON.stringify({}) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('Geometry(' + [].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'Geometry', []);
      Sk.three.object3DGetAttr = function (b, c, d) {
        var e = Sk.ffi.remapToJs(c);
        switch (d) {
        case 'id':
          return Sk.ffi.numberToIntPy(e[d]);
        case 'name':
        case 'uuid':
        case 'eulerOrder':
          return Sk.ffi.stringToPy(e[d]);
        case 'attitude':
          return l(e.quaternion);
        case 'position':
        case 'rotation':
        case 'scale':
        case 'up':
          return n(e[d]);
        case 'matrixWorld':
          return Sk.ffi.callsim(a[Sk.three.MATRIX_4], Sk.ffi.referenceToPy(e[d], Sk.three.MATRIX_4));
        case 'quaternion':
          return Sk.ffi.callsim(a.Quaternion, Sk.ffi.referenceToPy(e.quaternion, 'Quaternion'));
        case 'useQuaternion':
        case 'visible':
          return Sk.ffi.booleanToPy(e[d]);
        case 'charge':
        case 'mass':
        case 'momentum':
        case 'velocity':
          var f = e[d];
          if (k(f))
            return f;
          throw Sk.ffi.err.attribute(d).isNotGetableOnType(b);
        case 'geometry':
          return Sk.ffi.callsim(a.Geometry, Sk.ffi.referenceToPy(e.geometry, 'Geometry'));
        case 'material':
          return Sk.ffi.callsim(a[Sk.three.MATERIAL], Sk.ffi.referenceToPy(e.material, Sk.three.MATERIAL));
        case 'add':
          return s(e);
        case 'remove':
          return w(e);
        case 'traverse':
          return Sk.ffi.callableToPy(a, d, function (b, f) {
            Sk.ffi.checkMethodArgs(d, arguments, 1, 1);
            Sk.ffi.checkArgType('callback', Sk.ffi.PyType.FUNCTION, Sk.ffi.isFunction(f), f);
            e[d](function (b) {
              b = Sk.ffi.callsim(a[Sk.three.OBJECT_3D], Sk.ffi.referenceToPy(b, Sk.three.OBJECT_3D));
              return Sk.ffi.remapToJs(Sk.ffi.callsim(f, b));
            });
            return c;
          });
        default:
          throw Sk.ffi.err.attribute(d).isNotGetableOnType(b);
        }
      };
      Sk.three.object3DSetAttr = function (a, b, c, d) {
        var e = Sk.ffi.remapToJs(b);
        switch (c) {
        case 'attitude':
          m(a, b, 'quaternion', d, c);
          break;
        case 'position':
        case 'rotation':
        case 'scale':
        case 'up':
          q(e, c, d);
          break;
        case 'quaternion':
          Sk.ffi.checkArgType(c, 'Quaternion', Sk.ffi.isInstance(d, 'Quaternion'), d);
          e[c] = Sk.ffi.remapToJs(d);
          break;
        case 'eulerOrder':
          Sk.ffi.checkArgType(c, Sk.ffi.PyType.STR, Sk.ffi.isStr(d), d);
          e[c] = Sk.ffi.remapToJs(d);
          break;
        case 'useQuaternion':
        case 'visible':
          Sk.ffi.checkArgType(c, Sk.ffi.PyType.BOOL, Sk.ffi.isBool(d), d);
          e[c] = Sk.ffi.remapToJs(d);
          break;
        case 'charge':
        case 'mass':
        case 'momentum':
        case 'velocity':
          Sk.ffi.checkArgType(c, 'Euclidean3', k(d), d);
          e[c] = d;
          break;
        default:
          throw Sk.ffi.err.attribute(c).isNotSetableOnType(a);
        }
      };
      a[Sk.three.OBJECT_3D] = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b) {
          var c = g(b) ? Sk.ffi.remapToJs(b) : new THREE[Sk.three.OBJECT_3D]();
          Sk.ffi.referenceToPy(c, Sk.three.OBJECT_3D, void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          return Sk.three.object3DGetAttr(Sk.three.OBJECT_3D, a, b);
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return Sk.three.object3DSetAttr(Sk.three.OBJECT_3D, a, b, c);
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy(Sk.three.OBJECT_3D + '(' + JSON.stringify({}) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy(Sk.three.OBJECT_3D + '(' + [].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, Sk.three.OBJECT_3D, []);
      a.AmbientLight = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(b);
          Sk.ffi.referenceToPy(new THREE.AmbientLight(c), 'AmbientLight', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          return L('AmbientLight', a, b);
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return y('AmbientLight', a, b, c);
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.color = a.color;
          return Sk.ffi.stringToPy('AmbientLight(' + JSON.stringify(b) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          a = [Sk.ffi.remapToJs(a).color];
          return Sk.ffi.stringToPy('AmbientLight(' + a.map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'AmbientLight', []);
      a.DirectionalLight = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs('DirectionalLight', arguments, 1, 2);
          Sk.ffi.checkArgType('intensity', u, Sk.ffi.isNum(c) || Sk.ffi.isUndefined(c), c);
          var d = Sk.ffi.remapToJs(b), e = Sk.ffi.remapToJs(c);
          Sk.ffi.referenceToPy(new THREE.DirectionalLight(d, e), 'DirectionalLight', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'intensity':
            return Sk.ffi.numberToFloatPy(c.intensity);
          default:
            return L('DirectionalLight', a, b);
          }
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'intensity':
            Sk.ffi.checkArgType('intensity', u, Sk.ffi.isNum(c), c);
            d.intensity = e;
            break;
          default:
            return y('DirectionalLight', a, b, c);
          }
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.color = a.color;
          b.intensity = a.intensity;
          b.distance = a.distance;
          return Sk.ffi.stringToPy('DirectionalLight(' + JSON.stringify(b) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('DirectionalLight(' + [
            a.color,
            a.intensity,
            a.distance
          ].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'DirectionalLight', []);
      a.PointLight = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c, d) {
          Sk.ffi.checkMethodArgs('PointLight', arguments, 1, 3);
          Sk.ffi.checkArgType('color', [
            'Color',
            Sk.ffi.PyType.INT
          ], Sk.ffi.isInstance(b, 'Color') || Sk.ffi.isInt(b), b);
          Sk.ffi.checkArgType('intensity', u, Sk.ffi.isNum(c) || Sk.ffi.isUndefined(c), c);
          Sk.ffi.checkArgType('distance', u, Sk.ffi.isNum(d) || Sk.ffi.isUndefined(d), d);
          var e = Sk.ffi.remapToJs(b), f = Sk.ffi.remapToJs(c), g = Sk.ffi.remapToJs(d);
          Sk.ffi.referenceToPy(new THREE.PointLight(e, f, g), 'PointLight', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          switch (b) {
          case 'distance':
            return Sk.ffi.numberToFloatPy(Sk.ffi.remapToJs(a).distance);
          case 'intensity':
            return Sk.ffi.numberToFloatPy(Sk.ffi.remapToJs(a).intensity);
          default:
            return L('PointLight', a, b);
          }
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          switch (b) {
          case 'distance':
            Sk.ffi.checkArgType('distance', u, Sk.ffi.isNum(c), c);
            Sk.ffi.remapToJs(a).distance = Sk.ffi.remapToJs(c);
            break;
          case 'intensity':
            Sk.ffi.checkArgType('intensity', u, Sk.ffi.isNum(c), c);
            Sk.ffi.remapToJs(a).intensity = Sk.ffi.remapToJs(c);
            break;
          default:
            return y('PointLight', a, b, c);
          }
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.color = a.color;
          b.intensity = a.intensity;
          b.distance = a.distance;
          return Sk.ffi.stringToPy('PointLight(' + JSON.stringify(b) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('PointLight(' + [
            a.color,
            a.intensity,
            a.distance
          ].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'PointLight', []);
      a.Line = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, b, c, d) {
          b = Sk.ffi.remapToJs(b);
          c = Sk.ffi.remapToJs(c);
          d = Sk.ffi.remapToJs(d);
          a.v = new THREE.Line(b, c, d);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'position':
            return n(d.position);
          case 'quaternion':
            return Sk.ffi.callsim(a.Quaternion, Sk.ffi.referenceToPy(d.quaternion, 'Quaternion'));
          case 'rotation':
            return n(d.rotation);
          case 'eulerOrder':
            return Sk.ffi.stringToPy(d.eulerOrder);
          case 'scale':
            return n(d.scale);
          case 'up':
            return n(d.up);
          case 'useQuaternion':
            return d.useQuaternion;
          case 'lookAt':
            return r(b);
          case 'type':
            return Sk.ffi.numberToIntPy(d.type);
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          c = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'type':
            if (d(c))
              a.type = c;
            else
              throw Error('type must be either LineStrip or LinePieces');
            break;
          default:
            throw Error(b + ' is not an attribute of Line');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('Line');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('Line');
        });
      }, 'Line', []);
      a.LineBasicMaterial = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, b) {
          a.tp$name = 'LineBasicMaterial';
          b = Sk.ffi.remapToJs(b);
          a.v = new THREE.LineBasicMaterial(b);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          b = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'color':
            return Sk.ffi.callsim(a.Color, Sk.ffi.referenceToPy(b.color, 'Color'));
          case 'opacity':
            return Sk.ffi.numberToFloatPy(b.opacity);
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          a = Sk.ffi.remapToJs(a);
          c = Sk.ffi.remapToJs(c);
          switch (b) {
          case 'color':
            b = c;
            b = g(b) ? b.hasOwnProperty('r') && b.hasOwnProperty('g') && b.hasOwnProperty('b') ? d(b.r) && d(b.g) && d(b.b) : !1 : !1;
            if (b)
              a.color = c;
            else
              throw new Sk.builtin.TypeError('\'opacity\' attribute must be a <type \'Color\'>.');
            break;
          case 'opacity':
            if (d(c))
              a.opacity = c;
            else
              throw new Sk.builtin.TypeError('\'opacity\' attribute must be a <type \'float\'>.');
            break;
          default:
            throw Error(b + ' is not an attribute of LineBasicMaterial');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.color = a.color;
          b.opacity = a.opacity;
          return Sk.ffi.stringToPy('LineBasicMaterial(' + JSON.stringify(b) + ')');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('LineBasicMaterial(' + [{}].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'LineBasicMaterial', []);
      Sk.three.meshGetAttr = function (b, c, d) {
        var e = Sk.ffi.remapToJs(c);
        switch (d) {
        case 'attitude':
          return l(e.quaternion);
        case 'id':
          return Sk.ffi.numberToIntPy(e.id);
        case 'geometry':
          return Sk.ffi.callsim(a.Geometry, Sk.ffi.referenceToPy(e.geometry, 'Geometry'));
        case 'material':
          return Sk.ffi.callsim(a[Sk.three.MATERIAL], Sk.ffi.referenceToPy(e.material, Sk.three.MATERIAL));
        case 'matrixAutoUpdate':
          return e.matrixAutoUpdate;
        case 'name':
          return Sk.ffi.stringToPy(e.name);
        case 'position':
          return n(e.position);
        case 'rotation':
          return n(e.rotation);
        case 'eulerOrder':
          return Sk.ffi.stringToPy(e.eulerOrder);
        case 'scale':
          return n(e.scale);
        case 'up':
          return n(e.up);
        case 'lookAt':
          return r(c);
        case 'rotateOnAxis':
          return Sk.ffi.callableToPy(a, 'rotateOnAxis', function (a, b, d) {
            Sk.ffi.checkMethodArgs('rotateOnAxis', arguments, 2, 2);
            Sk.ffi.checkArgType('axis', 'Vector3', Sk.ffi.isInstance(b, 'Vector3'), b);
            Sk.ffi.checkArgType('angle', u, Sk.ffi.isNum(d), d);
            e.rotateOnAxis(Sk.ffi.remapToJs(b), Sk.ffi.remapToJs(d));
            return c;
          });
        case 'rotateX':
        case 'rotateY':
        case 'rotateZ':
          return Sk.ffi.callableToPy(a, d, function (a, b) {
            Sk.ffi.checkMethodArgs(d, arguments, 1, 1);
            Sk.ffi.checkArgType('axis', u, Sk.ffi.isNum(b), b);
            e[d](Sk.ffi.remapToJs(b));
            return c;
          });
        case 'setGeometry':
          return Sk.ffi.callsim(Sk.ffi.buildClass(a, function (a, b) {
            b.__init__ = Sk.ffi.functionPy(function (a) {
              a.tp$name = 'setGeometry';
            });
            b.__call__ = Sk.ffi.functionPy(function (a, b) {
              var c = Sk.ffi.remapToJs(b);
              e.setGeometry(c);
            });
            b.__str__ = Sk.ffi.functionPy(function (a) {
              return Sk.ffi.stringToPy('setGeometry');
            });
            b.__repr__ = Sk.ffi.functionPy(function (a) {
              return Sk.ffi.stringToPy('setGeometry');
            });
          }, 'setGeometry', []));
        case 'translateOnAxis':
          return Sk.ffi.callableToPy(a, 'translateOnAxis', function (a, b, d) {
            Sk.ffi.checkMethodArgs('translateOnAxis', arguments, 2, 2);
            Sk.ffi.checkArgType('axis', 'Vector3', Sk.ffi.isInstance(b, 'Vector3'), b);
            Sk.ffi.checkArgType('distance', u, Sk.ffi.isNum(d), d);
            e.translateOnAxis(Sk.ffi.remapToJs(b), Sk.ffi.remapToJs(d));
            return c;
          });
        case 'translateX':
        case 'translateY':
        case 'translateZ':
          return Sk.ffi.callableToPy(a, d, function (a, b) {
            Sk.ffi.checkMethodArgs(d, arguments, 1, 1);
            Sk.ffi.checkArgType('distance', u, Sk.ffi.isNum(b), b);
            e[d](Sk.ffi.remapToJs(b));
            return c;
          });
        case 'updateMatrix':
          return Sk.ffi.callableToPy(a, 'updateMatrix', function (a) {
            Sk.ffi.checkMethodArgs('updateMatrix', arguments, 0, 0);
            e.updateMatrix();
          });
        default:
          return Sk.three.object3DGetAttr(b, c, d);
        }
      };
      Sk.three.meshSetAttr = function (a, b, c, d) {
        var f = Sk.ffi.remapToJs(b), g = Sk.ffi.remapToJs(d);
        switch (c) {
        case 'attitude':
          m(Sk.three.MESH, b, 'quaternion', d, c);
          break;
        case 'matrixAutoUpdate':
          Sk.ffi.checkArgType('matrixAutoUpdate', Sk.ffi.PyType.BOOL, Sk.ffi.isBool(d), d);
          a = Sk.ffi.remapToJs(d);
          f.matrixAutoUpdate = a;
          break;
        case 'name':
          Sk.ffi.checkArgType('name', Sk.ffi.PyType.STR, Sk.ffi.isStr(d), d);
          f.name = g;
          break;
        case 'position':
        case 'rotation':
        case 'scale':
        case 'up':
          q(f, c, d);
          break;
        case 'quaternion':
          f.quaternion = g;
          break;
        case 'eulerOrder':
          if (e(g))
            f.eulerOrder = g;
          else
            throw Error(c + ' must be a string');
          break;
        case 'useQuaternion':
          f.useQuaternion = g;
          break;
        default:
          return Sk.three.object3DSetAttr(a, b, c, d);
        }
      };
      a[Sk.three.MESH] = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs(Sk.three.MESH, arguments, 1, 2);
          Sk.ffi.checkArgType('geometry', 'Geometry', Sk.ffi.isInstance(b), b);
          Sk.ffi.checkArgType('material', Sk.three.MATERIAL, Sk.ffi.isInstance(c), c);
          Sk.ffi.referenceToPy(new THREE[Sk.three.MESH](Sk.ffi.remapToJs(b), Sk.ffi.remapToJs(c)), Sk.three.MESH, void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          return Sk.three.meshGetAttr(Sk.three.MESH, a, b);
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return Sk.three.meshSetAttr(Sk.three.MESH, a, b, c);
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.id = a.id;
          b.name = a.name;
          return Sk.ffi.stringToPy(Sk.three.MESH + '(' + JSON.stringify(b) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy(Sk.three.MESH + '(' + [].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, Sk.three.MESH, []);
      a[Sk.three.MATERIAL] = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkMethodArgs(Sk.three.MATERIAL, arguments, 0, 1);
          g(b) ? Sk.ffi.referenceToPy(Sk.ffi.remapToJs(b), Sk.three.MATERIAL, void 0, a) : Sk.ffi.referenceToPy(new THREE[Sk.three.MATERIAL](), Sk.three.MATERIAL, void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          switch (b) {
          default:
            return F(Sk.three.MATERIAL, a, b);
          }
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          switch (b) {
          default:
            return x(Sk.three.MATERIAL, a, b, c);
          }
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy(Sk.three.MATERIAL + '()');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy(Sk.three.MATERIAL + '()');
        });
      }, Sk.three.MATERIAL, []);
      a.MeshBasicMaterial = Sk.ffi.buildClass(a, function (b, f) {
        f.__init__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(b);
          Sk.ffi.referenceToPy(new THREE.MeshBasicMaterial(c), 'MeshBasicMaterial', void 0, a);
        });
        f.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'color':
            return Sk.ffi.callsim(a.Color, Sk.ffi.referenceToPy(d.color, 'Color'));
          case 'wireframe':
            return d.wireframe;
          case 'wireframeLinewidth':
            return Sk.ffi.numberToFloatPy(d.wireframeLinewidth);
          default:
            return F('MeshBasicMaterial', b, c);
          }
        });
        f.__setattr__ = Sk.ffi.functionPy(function (a, b, f) {
          var g = Sk.ffi.remapToJs(a), h = Sk.ffi.remapToJs(f);
          switch (b) {
          case 'color':
            g.color = new THREE.Color(h);
            break;
          case 'name':
            if (e(h))
              g.name = h;
            else
              throw Error(b + ' must be a string');
            break;
          case 'opacity':
            if (d(h))
              g.opacity = h;
            else
              throw new Sk.builtin.TypeError('\'opacity\' attribute must be a <type \'float\'>.');
            break;
          case 'wireframe':
            if (c(h))
              g.wireframe = h;
            else
              throw Error(b + ' must be Boolean');
            break;
          case 'wireframeLinewidth':
            if (d(h))
              g.wireframeLinewidth = h;
            else
              throw Error(b + ' must be a number');
            break;
          default:
            return x('MeshBasicMaterial', a, b, f);
          }
        });
        f.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.color = a.color;
          b.wireframe = a.wireframe;
          b.wireframeLinewidth = a.wireframeLinewidth;
          return Sk.ffi.stringToPy('MeshBasicMaterial(' + JSON.stringify(b) + ')');
        });
        f.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.color = a.color;
          b.wireframe = a.wireframe;
          b.wireframeLinewidth = a.wireframeLinewidth;
          return Sk.ffi.stringToPy('MeshBasicMaterial(' + [b].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'MeshBasicMaterial', []);
      a.MeshLambertMaterial = Sk.ffi.buildClass(a, function (b, f) {
        f.__init__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkMethodArgs('MeshLambertMaterial', arguments, 0, 1);
          var c = Sk.ffi.remapToJs(b);
          Sk.ffi.referenceToPy(new THREE.MeshLambertMaterial(c), 'MeshLambertMaterial', void 0, a);
        });
        f.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'id':
            return Sk.ffi.numberToIntPy(d.id);
          case 'color':
            return Sk.ffi.callsim(a.Color, Sk.ffi.referenceToPy(d.color, 'Color'));
          case 'name':
            return Sk.ffi.stringToPy(d.name);
          case 'opacity':
            return Sk.ffi.numberToFloatPy(d.opacity);
          default:
            return F('MeshLambertMaterial', b, c);
          }
        });
        f.__setattr__ = Sk.ffi.functionPy(function (a, b, f) {
          var g = Sk.ffi.remapToJs(a), h = Sk.ffi.remapToJs(f);
          switch (b) {
          case 'color':
            g.color = new THREE.Color(h);
            break;
          case 'name':
            if (e(h))
              g.name = h;
            else
              throw Error(b + ' must be a string');
            break;
          case 'opacity':
            if (d(h))
              g.opacity = h;
            else
              throw new Sk.builtin.TypeError('\'opacity\' attribute must be a <type \'float\'>.');
            break;
          case 'wireframe':
            if (c(h))
              g.wireframe = h;
            else
              throw Error(b + ' must be Boolean');
            break;
          case 'wireframeLinewidth':
            if (d(h))
              g.wireframeLinewidth = h;
            else
              throw Error(b + ' must be a number');
            break;
          default:
            return x('MeshLambertMaterial', a, b, f);
          }
        });
        f.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('MeshLambertMaterial(' + JSON.stringify({}) + ')');
        });
        f.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          var b = {};
          b.color = a.color;
          return Sk.ffi.stringToPy('MeshLambertMaterial(' + [b].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'MeshLambertMaterial', []);
      a.MeshNormalMaterial = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(b);
          Sk.ffi.referenceToPy(new THREE.MeshNormalMaterial(c), 'MeshNormalMaterial', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          return F('MeshNormalMaterial', a, b);
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return x('MeshNormalMaterial', a, b, c);
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('MeshNormalMaterial(' + JSON.stringify({}) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('MeshNormalMaterial(' + [{}].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'MeshNormalMaterial', []);
      a.MeshPhongMaterial = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(b);
          Sk.ffi.referenceToPy(new THREE.MeshPhongMaterial(c), 'MeshPhongMaterial', void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          return F('MeshPhongMaterial', a, b);
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          return x('MeshPhongMaterial', a, b, c);
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('MeshPhongMaterial(' + JSON.stringify({}) + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('MeshPhongMaterial(' + [{}].map(function (a) {
            return JSON.stringify(a);
          }).join(', ') + ')');
        });
      }, 'MeshPhongMaterial', []);
      a[Sk.three.PARTICLE_SYSTEM] = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs(Sk.three.PARTICLE_SYSTEM, arguments, 0, 2);
          Sk.ffi.checkArgType('geometry', 'Geometry', Sk.ffi.isInstance(b), b);
          Sk.ffi.checkArgType('material', Sk.three.MATERIAL, Sk.ffi.isInstance(c), c);
          Sk.ffi.referenceToPy(new THREE.ParticleSystem(Sk.ffi.remapToJs(b), Sk.ffi.remapToJs(c)), Sk.three.PARTICLE_SYSTEM, void 0, a);
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          switch (b) {
          default:
            return Sk.three.object3DGetAttr(Sk.three.PARTICLE_SYSTEM, a, b);
          }
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          switch (b) {
          default:
            return Sk.three.object3DSetAttr(Sk.three.PARTICLE_SYSTEM, a, b, c);
          }
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [].map(function (b) {
              return Sk.ffi.gattr(a, b);
            }).map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffh.str(a));
            });
          return Sk.ffi.stringToPy(Sk.three.PARTICLE_SYSTEM + '(' + b.join(', ') + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [].map(function (b) {
              return Sk.ffi.gattr(a, b);
            }).map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffh.repr(a));
            });
          return Sk.ffi.stringToPy(Sk.three.PARTICLE_SYSTEM + '(' + b.join(', ') + ')');
        });
      }, Sk.three.PARTICLE_SYSTEM, []);
      a[Sk.three.PARTICLE_SYSTEM_MATERIAL] = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkMethodArgs(Sk.three.PARTICLE_SYSTEM_MATERIAL, arguments, 0, 1);
          if (g(b) && !h(b) && Sk.ffi.isInstance(b, Sk.three.PARTICLE_SYSTEM_MATERIAL))
            Sk.ffi.referenceToPy(Sk.ffi.remapToJs(b), Sk.three.PARTICLE_SYSTEM_MATERIAL, void 0, a);
          else {
            var c = Sk.ffi.remapToJs(b);
            Sk.ffi.referenceToPy(new THREE[Sk.three.PARTICLE_SYSTEM_MATERIAL](c), Sk.three.PARTICLE_SYSTEM_MATERIAL, void 0, a);
          }
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'color':
            return v(c.color);
          case 'size':
            return Sk.ffi.numberToFloatPy(c.size);
          case 'sizeAttenuation':
            return Sk.ffi.booleanToPy(c.sizeAttenuation);
          case 'vertexColors':
            return Sk.ffi.booleanToPy(c.vertexColors);
          case 'fog':
            return Sk.ffi.booleanToPy(c.fog);
          default:
            return F(Sk.three.PARTICLE_SYSTEM_MATERIAL, a, b);
          }
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          var d = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'color':
            Sk.ffi.checkArgType(b, 'Color', Sk.ffi.isInstance(c, 'Color'), c);
            d.color = Sk.ffi.remapToJs(c);
            break;
          case 'size':
            Sk.ffi.checkArgType(b, Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(c), c);
            d.size = Sk.ffi.remapToJs(c);
            break;
          case 'sizeAttenuation':
            Sk.ffi.checkArgType(b, Sk.ffi.PyType.BOOL, Sk.ffi.isBool(c), c);
            d.sizeAttenuation = Sk.ffi.remapToJs(c);
            break;
          case 'vertexColors':
            Sk.ffi.checkArgType(b, Sk.ffi.PyType.BOOL, Sk.ffi.isBool(c), c);
            d.vertexColors = Sk.ffi.remapToJs(c);
            break;
          case 'fog':
            Sk.ffi.checkArgType(b, Sk.ffi.PyType.BOOL, Sk.ffi.isBool(c), c);
            d.fog = Sk.ffi.remapToJs(c);
            break;
          default:
            return x(Sk.three.PARTICLE_SYSTEM_MATERIAL, a, b, c);
          }
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [
              'color',
              'size',
              'sizeAttenuation',
              'vertexColors',
              'fog'
            ].map(function (b) {
              return [
                b,
                Sk.ffi.remapToJs(Sk.ffh.str(Sk.ffi.gattr(a, b)))
              ].join('=');
            });
          return Sk.ffi.stringToPy(Sk.three.PARTICLE_SYSTEM_MATERIAL + '(' + b.join(', ') + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [
              'color',
              'size',
              'sizeAttenuation',
              'vertexColors',
              'fog'
            ].map(function (b) {
              return Sk.ffi.gattr(a, b);
            }).map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffh.repr(a));
            });
          return Sk.ffi.stringToPy(Sk.three.PARTICLE_SYSTEM_MATERIAL + '(' + b.join(', ') + ')');
        });
      }, Sk.three.PARTICLE_SYSTEM_MATERIAL, []);
      a[Sk.three.MATRIX_3] = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e, f, h, k, l, m) {
          Sk.ffi.checkMethodArgs(Sk.three.MATRIX_3, arguments, 0, 9);
          if (g(b))
            if (Sk.ffi.isInstance(b, Sk.three.MATRIX_3))
              Sk.ffi.referenceToPy(Sk.ffi.remapToJs(b), Sk.three.MATRIX_3, void 0, a);
            else {
              Sk.ffi.checkMethodArgs(Sk.three.MATRIX_3, arguments, 9, 9);
              Sk.ffi.checkArgType('n11', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(b), b);
              Sk.ffi.checkArgType('n12', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(c), c);
              Sk.ffi.checkArgType('n13', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(d), d);
              Sk.ffi.checkArgType('n21', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(e), e);
              Sk.ffi.checkArgType('n22', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(f), f);
              Sk.ffi.checkArgType('n23', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(h), h);
              Sk.ffi.checkArgType('n31', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(k), k);
              Sk.ffi.checkArgType('n32', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(l), l);
              Sk.ffi.checkArgType('n33', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(m), m);
              var n = Sk.ffi.remapToJs(b), p = Sk.ffi.remapToJs(c), q = Sk.ffi.remapToJs(d), r = Sk.ffi.remapToJs(e), s = Sk.ffi.remapToJs(f), t = Sk.ffi.remapToJs(h), u = Sk.ffi.remapToJs(k), B = Sk.ffi.remapToJs(l), v = Sk.ffi.remapToJs(m);
              Sk.ffi.referenceToPy(new THREE.Matrix3(n, p, q, r, s, t, u, B, v), Sk.three.MATRIX_3, void 0, a);
            }
          else
            Sk.ffi.referenceToPy(new THREE.Matrix3(), Sk.three.MATRIX_3, void 0, a);
        });
        c.__mul__ = Sk.ffi.functionPy(function (b, c) {
          switch (Sk.ffi.getType(c)) {
          case Sk.ffi.PyType.INSTANCE:
            if (Sk.ffi.isInstance(c, Sk.three.MATRIX_3)) {
              var d = Sk.ffi.remapToJs(b).elements, e = d[0], f = d[3], g = d[6], h = d[1], k = d[4], l = d[7], m = d[2], n = d[5], p = d[8], d = Sk.ffi.remapToJs(c).elements, q = d[0], r = d[3], s = d[6], t = d[1], u = d[4], B = d[7], v = d[2], w = d[5], d = d[8], d = new THREE.Matrix3(e * q + f * t + g * v, e * r + f * u + g * w, e * s + f * B + g * d, h * q + k * t + l * v, h * r + k * u + l * w, h * s + k * B + l * d, m * q + n * t + p * v, m * r + n * u + p * w, m * s + n * B + p * d);
              return Sk.ffi.callsim(a[Sk.three.MATRIX_3], Sk.ffi.referenceToPy(d, Sk.three.MATRIX_3));
            }
            throw Sk.ffi.err.operand('other').toOperation('*').mustHaveType([
              Sk.ffi.PyType.FLOAT,
              Sk.three.MATRIX_3
            ]);
          case Sk.ffi.PyType.FLOAT:
            return d = Sk.ffi.remapToJs(b).elements, e = d[0], f = d[3], g = d[6], h = d[1], k = d[4], l = d[7], m = d[2], n = d[5], p = d[8], d = Sk.ffi.remapToJs(c), d = new THREE.Matrix3(e * d, f * d, g * d, h * d, k * d, l * d, m * d, n * d, p * d), Sk.ffi.callsim(a[Sk.three.MATRIX_3], Sk.ffi.referenceToPy(d, Sk.three.MATRIX_3));
          default:
            throw Sk.ffi.err.operand('other').toOperation('*').mustHaveType([
              Sk.ffi.PyType.FLOAT,
              Sk.three.MATRIX_3
            ]);
          }
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'clone':
            return Sk.ffi.callableToPy(a, c, function (b) {
              Sk.ffi.checkMethodArgs(c, arguments, 0, 0);
              return Sk.ffi.callsim(a[Sk.three.MATRIX_3], Sk.ffi.referenceToPy(d.clone(), Sk.three.MATRIX_3));
            });
          case 'copy':
            return Sk.ffi.callableToPy(a, c, function (a, e) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('matrix', Sk.three.MATRIX_3, Sk.ffi.isInstance(e, Sk.three.MATRIX_3), e);
              d.copy(Sk.ffi.remapToJs(e));
              return b;
            });
          case 'determinant':
            return Sk.ffi.callableToPy(a, c, function (a) {
              Sk.ffi.checkMethodArgs(c, arguments, 0, 0);
              return Sk.ffi.numberToFloatPy(d.determinant());
            });
          case 'getNormalMatrix':
            return Sk.ffi.callableToPy(a, c, function (a, e) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('m', Sk.three.MATRIX_4, Sk.ffi.isInstance(e, Sk.three.MATRIX_4), e);
              d.getNormalMatrix(Sk.ffi.remapToJs(e));
              return b;
            });
          case 'identity':
            return Sk.ffi.callableToPy(a, c, function (a) {
              Sk.ffi.checkMethodArgs(c, arguments, 0, 0);
              d.identity();
              return b;
            });
          case 'set':
            return Sk.ffi.callableToPy(a, c, function (a, e, f, g, h, k, l, m, n, p) {
              Sk.ffi.checkMethodArgs(c, arguments, 9, 9);
              Sk.ffi.checkArgType('n11', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(e), e);
              Sk.ffi.checkArgType('n12', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(f), f);
              Sk.ffi.checkArgType('n13', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(g), g);
              Sk.ffi.checkArgType('n21', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(h), h);
              Sk.ffi.checkArgType('n22', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(k), k);
              Sk.ffi.checkArgType('n23', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(l), l);
              Sk.ffi.checkArgType('n31', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(m), m);
              Sk.ffi.checkArgType('n32', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(n), n);
              Sk.ffi.checkArgType('n33', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(p), p);
              var q = Sk.ffi.remapToJs(e), r = Sk.ffi.remapToJs(f), s = Sk.ffi.remapToJs(g), t = Sk.ffi.remapToJs(h), u = Sk.ffi.remapToJs(k), B = Sk.ffi.remapToJs(l), v = Sk.ffi.remapToJs(m), w = Sk.ffi.remapToJs(n), x = Sk.ffi.remapToJs(p);
              d.set(q, r, s, t, u, B, v, w, x);
              return b;
            });
          case 'transpose':
            return Sk.ffi.callableToPy(a, c, function (a) {
              Sk.ffi.checkMethodArgs(c, arguments, 0, 0);
              d.transpose();
              return b;
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType(Sk.three.MATRIX_3);
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          switch (b) {
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType(Sk.three.MATRIX_3);
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a).elements;
          a = [
            [
              a[0],
              a[3],
              a[6]
            ],
            [
              a[1],
              a[4],
              a[7]
            ],
            [
              a[2],
              a[5],
              a[8]
            ]
          ].map(function (a) {
            return a.map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffh.str(Sk.ffi.numberToFloatPy(a)));
            }).join(' ');
          }).join('\n');
          return Sk.ffi.stringToPy(a);
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a).elements;
          a = [
            a[0],
            a[3],
            a[6],
            a[1],
            a[4],
            a[7],
            a[2],
            a[5],
            a[8]
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(Sk.ffi.numberToFloatPy(a)));
          }).join(', ');
          return Sk.ffi.stringToPy(Sk.three.MATRIX_3 + '(' + a + ')');
        });
      }, Sk.three.MATRIX_3, []);
      a[Sk.three.MATRIX_4] = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkMethodArgs(Sk.three.MATRIX_4, arguments, 0, 1);
          g(b) && Sk.ffi.isInstance(b, Sk.three.MATRIX_4) ? Sk.ffi.referenceToPy(Sk.ffi.remapToJs(b), Sk.three.MATRIX_4, void 0, a) : Sk.ffi.referenceToPy(new THREE.Matrix4(), Sk.three.MATRIX_4, void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'makeRotationX':
            return Sk.ffi.callableToPy(a, c, function (b, e) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('theta', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(e), e);
              var f = Sk.ffi.remapToJs(e);
              return Sk.ffi.callsim(a[Sk.three.MATRIX_4], Sk.ffi.referenceToPy(d.makeRotationX(f), Sk.three.MATRIX_4));
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType(Sk.three.MATRIX_4);
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          switch (b) {
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType(Sk.three.MATRIX_4);
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy(Sk.three.MATRIX_4 + '()');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy(Sk.three.MATRIX_4 + '()');
        });
      }, Sk.three.MATRIX_4, []);
      a[Sk.three.FACE_3] = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e, f, h) {
          if (g(b) && Sk.ffi.isInstance(b, Sk.three.FACE_3)) {
            Sk.ffi.checkMethodArgs(Sk.three.FACE_3, arguments, 1, 1);
            var k = Sk.ffi.remapToJs(b);
            Sk.ffi.checkArgType('a', '!?', g(k), b);
            Sk.ffi.checkArgType('a', '?!', k instanceof THREE.Face3, b);
          } else {
            Sk.ffi.checkMethodArgs(Sk.three.FACE_3, arguments, 3, 6);
            Sk.ffi.checkArgType('a', t, Sk.ffi.isInt(b), b);
            Sk.ffi.checkArgType('b', t, Sk.ffi.isInt(c), c);
            Sk.ffi.checkArgType('c', t, Sk.ffi.isInt(d), d);
            g(e) && Sk.ffi.checkArgType('normal', 'Euclidean3', Sk.ffi.isInstance(e, 'Euclidean3'), e);
            var k = Sk.ffi.remapToJs(b), l = Sk.ffi.remapToJs(c), m = Sk.ffi.remapToJs(d), n = p('normal', e), q = Sk.ffi.remapToJs(f), r = Sk.ffi.remapToJs(h), k = new THREE.Face3(k, l, m, n, q, r);
          }
          Sk.ffi.referenceToPy(k, Sk.three.FACE_3, void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'a':
            return Sk.ffi.numberToIntPy(d.a);
          case 'b':
            return Sk.ffi.numberToIntPy(d.b);
          case 'c':
            return Sk.ffi.numberToIntPy(d.c);
          case 'color':
            return Sk.ffi.callsim(a.Color, Sk.ffi.referenceToPy(d.color, 'Color'));
          case 'centroid':
            return n(d.centroid);
          case 'normal':
            return n(d.normal);
          case 'vertexNormals':
            return Sk.ffi.listPy(d.vertexNormals.map(function (a) {
              return n(a);
            }));
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType(Sk.three.FACE_3);
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.remapToJs(a);
          switch (b) {
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType(Sk.three.FACE_3);
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [
              'a',
              'b',
              'c',
              'normal'
            ].map(function (b) {
              return Sk.ffi.gattr(a, b);
            }).map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffh.str(a));
            });
          return Sk.ffi.stringToPy(Sk.three.FACE_3 + '(' + b.join(', ') + ')');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [
              'a',
              'b',
              'c',
              'normal'
            ].map(function (b) {
              return Sk.ffi.gattr(a, b);
            }).map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffh.repr(a));
            });
          return Sk.ffi.stringToPy(Sk.three.FACE_3 + '(' + b.join(', ') + ')');
        });
      }, Sk.three.FACE_3, []);
      a.Intersection = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, b, c, d) {
          switch (Sk.ffi.checkMethodArgs('Intersection', arguments, 1, 3)) {
          case 1:
            Sk.ffi.checkMethodArgs('Intersection', arguments, 1, 1);
            Sk.ffi.referenceToPy(Sk.ffi.remapToJs(b), 'Intersection', void 0, a);
            break;
          default:
            Sk.ffi.checkMethodArgs('Intersection', arguments, 3, 3);
            Sk.ffi.checkArgType('distance', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(b), b);
            Sk.ffi.checkArgType('point', 'Euclidean3', Sk.ffi.isInstance(c, 'Euclidean3'), c);
            Sk.ffi.checkArgType('face', Sk.three.FACE_3, Sk.ffi.isInstance(d, Sk.three.FACE_3), d);
            var e = {};
            e.distance = Sk.ffi.remapToJs(b);
            e.point = p('point', c);
            e.face = Sk.ffi.remapToJs(d);
            Sk.ffi.referenceToPy(e, 'Intersection', void 0, a);
          }
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'distance':
            return Sk.ffi.numberToFloatPy(d.distance);
          case 'point':
            return n(d.point);
          case 'face':
            var e = d.face;
            return g(e) && !h(e) ? Sk.ffi.callsim(a[Sk.three.FACE_3], Sk.ffi.referenceToPy(d.face, Sk.three.FACE_3)) : Sk.ffi.none.None;
          case 'object':
            return Sk.ffi.callsim(a[Sk.three.OBJECT_3D], Sk.ffi.referenceToPy(d.object, Sk.three.OBJECT_3D));
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('Intersection');
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.remapToJs(a);
          Sk.ffi.remapToJs(c);
          switch (b) {
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('Intersection');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [
              'distance',
              'point',
              'face'
            ].map(function (b) {
              return Sk.ffi.gattr(a, b);
            }).map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffh.str(a));
            });
          return Sk.ffi.stringToPy('Intersection(' + b.join(', ') + ')');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [
              'distance',
              'point',
              'face'
            ].map(function (b) {
              return Sk.ffi.gattr(a, b);
            }).map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffh.repr(a));
            });
          return Sk.ffi.stringToPy('Intersection(' + b.join(', ') + ')');
        });
      }, 'Intersection', []);
      a.Plane = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs('Plane', arguments, 0, 2);
          var d = p('normal', b);
          g(c) && Sk.ffi.checkArgType('offset', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(c), c);
          var e = Sk.ffi.remapToJs(c);
          Sk.ffi.referenceToPy(new THREE.Plane(d, e), 'Plane', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'normal':
            return n(d.normal);
          case 'offset':
          case 'constant':
            return Sk.ffi.numberToFloatPy(d.constant);
          case 'copy':
            return Sk.ffi.callableToPy(a, c, function (a, e) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('plane', 'Plane', Sk.ffi.isInstance(e, 'Plane'), e);
              d.copy(Sk.ffi.remapToJs(e));
              return b;
            });
          case 'distanceToPoint':
            return Sk.ffi.callableToPy(a, c, function (a, b) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              return Sk.ffi.numberToFloatPy(d.distanceToPoint(p('point', b)));
            });
          case 'distanceToSphere':
            return Sk.ffi.callableToPy(a, c, function (a, b) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('sphere', 'Sphere', Sk.ffi.isInstance(b, 'Sphere'), b);
              return Sk.ffi.numberToFloatPy(d.distanceToSphere(Sk.ffi.remapToJs(b)));
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('Plane');
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.remapToJs(a);
          Sk.ffi.remapToJs(c);
          switch (b) {
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('Plane');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            n(a.normal),
            Sk.ffi.numberToFloatPy(a.constant)
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.str(a));
          });
          return Sk.ffi.stringToPy('Plane(' + a.join(', ') + ')');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            n(a.normal),
            Sk.ffi.numberToFloatPy(a.constant)
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(a));
          });
          return Sk.ffi.stringToPy('Plane(' + a.join(', ') + ')');
        });
      }, 'Plane', []);
      a.Projector = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.checkMethodArgs('Projector', arguments, 0, 0);
          Sk.ffi.referenceToPy(new THREE.Projector(), 'Projector', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'pickingRay':
            return Sk.ffi.callableToPy(a, c, function (b, e, f) {
              Sk.ffi.checkMethodArgs(c, arguments, 2, 2);
              var g = d.pickingRay(p('vector', e), Sk.ffi.remapToJs(f));
              return Sk.ffi.callsim(a.Raycaster, Sk.ffi.referenceToPy(g, 'Raycaster'));
            });
          case 'projectVector':
            return Sk.ffi.callableToPy(a, c, function (a, b, e) {
              Sk.ffi.checkMethodArgs(c, arguments, 2, 2);
              return n(d.projectVector(p('vector', b), Sk.ffi.remapToJs(e)));
            });
          case 'unprojectVector':
            return Sk.ffi.callableToPy(a, c, function (a, b, e) {
              Sk.ffi.checkMethodArgs(c, arguments, 2, 2);
              return n(d.unprojectVector(p('vector', b), Sk.ffi.remapToJs(e)));
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('Projector');
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.remapToJs(a);
          Sk.ffi.remapToJs(c);
          switch (b) {
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('Projector');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('Projector');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          return Sk.ffi.stringToPy('Projector()');
        });
      }, 'Projector', []);
      a.Ray = Sk.ffi.buildClass(a, function (a, b) {
        b.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs('Ray', arguments, 1, 2);
          if (Sk.ffi.isInstance(b, 'Ray'))
            Sk.ffi.referenceToPy(Sk.ffi.remapToJs(b), 'Ray', void 0, a);
          else {
            Sk.ffi.checkMethodArgs('Ray', arguments, 2, 2);
            var d = p('origin', b), e = p('direction', c);
            Sk.ffi.referenceToPy(new THREE.Ray(d, e), 'Ray', void 0, a);
          }
        });
        b.__getattr__ = Sk.ffi.functionPy(function (a, b) {
          var c = Sk.ffi.remapToJs(a);
          switch (b) {
          case 'origin':
          case 'direction':
            return n(c[b]);
          default:
            throw Sk.ffi.err.attribute(b).isNotGetableOnType('Ray');
          }
        });
        b.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.remapToJs(a);
          Sk.ffi.remapToJs(c);
          switch (b) {
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('Ray');
          }
        });
        b.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [
              'origin',
              'direction'
            ].map(function (b) {
              return Sk.ffi.gattr(a, b);
            }).map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffh.str(a));
            });
          return Sk.ffi.stringToPy('Ray(' + b.join(', ') + ')');
        });
        b.__repr__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [
              'origin',
              'direction'
            ].map(function (b) {
              return Sk.ffi.gattr(a, b);
            }).map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffh.repr(a));
            });
          return Sk.ffi.stringToPy('Ray(' + b.join(', ') + ')');
        });
      }, 'Ray', []);
      a.Raycaster = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, b, c, d, e) {
          Sk.ffi.checkMethodArgs('Raycaster', arguments, 0, 4);
          if (g(b) && Sk.ffi.isInstance(b, 'Raycaster'))
            Sk.ffi.referenceToPy(Sk.ffi.remapToJs(b), 'Raycaster', void 0, a);
          else {
            var f = p('origin', b), h = p('direction', c);
            g(d) && Sk.ffi.checkArgType('near', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(d), d);
            g(e) && Sk.ffi.checkArgType('far', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(e), e);
            var k = Sk.ffi.remapToJs(d);
            Sk.ffi.remapToJs(e);
            Sk.ffi.referenceToPy(new THREE.Raycaster(f, h, k), 'Raycaster', void 0, a);
          }
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'ray':
            return Sk.ffi.callsim(a.Ray, Sk.ffi.referenceToPy(d.ray, 'Ray'));
          case 'near':
          case 'far':
            return Sk.ffi.numberToFloatPy(d[c]);
          case 'intersectObjects':
            return Sk.ffi.callableToPy(a, c, function (b, e, f) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 2);
              Sk.ffi.checkArgType('objects', Sk.ffi.PyType.LIST, Sk.ffi.isList(e), e);
              var g = d.intersectObjects(Sk.ffi.remapToJs(e), Sk.ffi.remapToJs(f));
              return Sk.ffi.listPy(g.map(function (b) {
                return Sk.ffi.callsim(a.Intersection, Sk.ffi.referenceToPy(b, 'Intersection'));
              }));
            });
          case 'set':
            return Sk.ffi.callableToPy(a, c, function (a, e, f) {
              Sk.ffi.checkMethodArgs(c, arguments, 2, 2);
              d.set(p('origin', e), p('direction', f));
              return b;
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('Raycaster');
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.remapToJs(a);
          Sk.ffi.remapToJs(c);
          switch (b) {
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('Raycaster');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [
              'ray',
              'near',
              'far'
            ].map(function (b) {
              return Sk.ffi.gattr(a, b);
            }).map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffh.str(a));
            });
          return Sk.ffi.stringToPy('Raycaster(' + b.join(', ') + ')');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          Sk.ffi.remapToJs(a);
          var b = [
              'ray',
              'near',
              'far'
            ].map(function (b) {
              return Sk.ffi.gattr(a, b);
            }).map(function (a) {
              return Sk.ffi.remapToJs(Sk.ffh.repr(a));
            });
          return Sk.ffi.stringToPy('Raycaster(' + b.join(', ') + ')');
        });
      }, 'Raycaster', []);
      a.Sphere = Sk.ffi.buildClass(a, function (b, c) {
        c.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs('Sphere', arguments, 0, 2);
          var d = p('center', b);
          g(c) && Sk.ffi.checkArgType('radius', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(c), c);
          var e = Sk.ffi.remapToJs(c);
          Sk.ffi.referenceToPy(new THREE.Sphere(d, e), 'Sphere', void 0, a);
        });
        c.__getattr__ = Sk.ffi.functionPy(function (b, c) {
          var d = Sk.ffi.remapToJs(b);
          switch (c) {
          case 'center':
            return n(d.center);
          case 'radius':
            return Sk.ffi.numberToFloatPy(d.radius);
          case 'copy':
            return Sk.ffi.callableToPy(a, c, function (a, e) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('sphere', 'Sphere', Sk.ffi.isInstance(e, 'Sphere'), e);
              d.copy(Sk.ffi.remapToJs(e));
              return b;
            });
          case 'containsPoint':
            return Sk.ffi.callableToPy(a, c, function (a, b) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              return Sk.ffi.booleanToPy(d.containsPoint(p('point', b)));
            });
          case 'distanceToPoint':
            return Sk.ffi.callableToPy(a, c, function (a, b) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              return Sk.ffi.numberToFloatPy(d.distanceToPoint(p('point', b)));
            });
          case 'intersectsSphere':
            return Sk.ffi.callableToPy(a, c, function (a, b) {
              Sk.ffi.checkMethodArgs(c, arguments, 1, 1);
              Sk.ffi.checkArgType('sphere', 'Sphere', Sk.ffi.isInstance(b, 'Sphere'), b);
              return Sk.ffi.booleanToPy(d.intersectsSphere(Sk.ffi.remapToJs(b)));
            });
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType('Sphere');
          }
        });
        c.__setattr__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.remapToJs(a);
          Sk.ffi.remapToJs(c);
          switch (b) {
          default:
            throw Sk.ffi.err.attribute(b).isNotSetableOnType('Sphere');
          }
        });
        c.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            n(a.center),
            Sk.ffi.numberToFloatPy(a.radius)
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.str(a));
          });
          return Sk.ffi.stringToPy('Sphere(' + a.join(', ') + ')');
        });
        c.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          a = [
            n(a.center),
            Sk.ffi.numberToFloatPy(a.radius)
          ].map(function (a) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(a));
          });
          return Sk.ffi.stringToPy('Sphere(' + a.join(', ') + ')');
        });
      }, 'Sphere', []);
      g(THREE) && (a.LineStrip = Sk.ffi.numberToIntPy(THREE.LineStrip), a.LinePieces = Sk.ffi.numberToIntPy(THREE.LinePieces), a.FlatShading = Sk.ffi.numberToIntPy(THREE.FlatShading), a.NoShading = Sk.ffi.numberToIntPy(THREE.NoShading), a.SmoothShading = Sk.ffi.numberToIntPy(THREE.SmoothShading), a.NoColors = Sk.ffi.numberToIntPy(THREE.NoColors), a.FaceColors = Sk.ffi.numberToIntPy(THREE.FaceColors), a.VertexColors = Sk.ffi.numberToIntPy(THREE.VertexColors), a.FrontSide = Sk.ffi.numberToIntPy(THREE.FrontSide), a.BackSide = Sk.ffi.numberToIntPy(THREE.BackSide), a.DoubleSide = Sk.ffi.numberToIntPy(THREE.DoubleSide));
    };
  }.call(this));
  (function () {
    var a = function (a, b) {
        var c, g, h, k, l;
        h = [];
        c = function (a, b) {
          var c;
          if (0 !== a) {
            0 <= a ? 0 < h.length && h.push('+') : h.push('-');
            c = Math.abs(a);
            if (1 === c)
              return h.push(b);
            h.push(c.toString());
            if ('1' !== b)
              return h.push('*'), h.push(b);
          }
        };
        g = k = 0;
        for (l = a.length - 1; 0 <= l ? k <= l : k >= l; g = 0 <= l ? ++k : --k)
          c(a[g], b[g]);
        return 0 < h.length ? h.join('') : '0';
      }, b = [
        Sk.ffi.PyType.FLOAT,
        Sk.ffi.PyType.INT,
        Sk.ffi.PyType.LONG
      ], c = Sk.ffi.PyType.INT;
    Sk.builtin.defineVector3 = function (d, e) {
      Sk.ffi.checkFunctionArgs('defineVector3', arguments, 2, 2);
      var f = function (a) {
          return Sk.ffi.isInstance(a, 'Vector3');
        }, g = function (a, b, c) {
          return Sk.ffi.callsim(d.Vector3, Sk.ffi.numberToFloatPy(a), Sk.ffi.numberToFloatPy(b), Sk.ffi.numberToFloatPy(c));
        };
      d.Vector3 = Sk.ffi.buildClass(d, function (h, k) {
        k.__init__ = Sk.ffi.functionPy(function (a, c, d, g) {
          Sk.ffi.checkMethodArgs('Vector3', arguments, 0, 4);
          if (Sk.ffi.isUndefined(c) && Sk.ffi.isUndefined(d) && Sk.ffi.isUndefined(g))
            Sk.ffi.referenceToPy(new e.Vector3(), 'Vector3', void 0, a);
          else
            switch (Sk.ffi.getType(c)) {
            case Sk.ffi.PyType.INSTANCE:
              Sk.ffi.checkMethodArgs('Vector3', arguments, 1, 1);
              Sk.ffi.checkArgType('x', 'Vector3', f(c), c);
              Sk.ffi.referenceToPy(Sk.ffi.remapToJs(c), 'Vector3', void 0, a);
              break;
            case Sk.ffi.PyType.FLOAT:
            case Sk.ffi.PyType.INT:
            case Sk.ffi.PyType.LONG:
              Sk.ffi.checkMethodArgs('Vector3', arguments, 3, 3);
              Sk.ffi.checkArgType('x', b, Sk.ffi.isNum(c), c);
              Sk.ffi.checkArgType('y', b, Sk.ffi.isNum(d), d);
              Sk.ffi.checkArgType('z', b, Sk.ffi.isNum(g), g);
              Sk.ffi.referenceToPy(new e.Vector3(Sk.ffi.remapToJs(c), Sk.ffi.remapToJs(d), Sk.ffi.remapToJs(g)), 'Vector3', void 0, a);
              break;
            default:
              Sk.ffi.checkArgType('x', [
                b,
                'Vector3'
              ], !1, c);
            }
        });
        k.__add__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkLhsOperandType('add', 'Vector3', f(a), a);
          Sk.ffi.checkRhsOperandType('add', 'Vector3', f(b), b);
          var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
          return g(c.x + d.x, c.y + d.y, c.z + d.z);
        });
        k.__iadd__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkLhsOperandType('add', 'Vector3', f(a), a);
          Sk.ffi.checkRhsOperandType('add', 'Vector3', f(b), b);
          var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
          c.x += d.x;
          c.y += d.y;
          c.z += d.z;
          return a;
        });
        k.__sub__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkLhsOperandType('subtract', 'Vector3', f(a), a);
          Sk.ffi.checkRhsOperandType('subtract', 'Vector3', f(b), b);
          var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
          return g(c.x - d.x, c.y - d.y, c.z - d.z);
        });
        k.__isub__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkLhsOperandType('add', 'Vector3', f(a), a);
          Sk.ffi.checkRhsOperandType('add', 'Vector3', f(b), b);
          var c = Sk.ffi.remapToJs(a), d = Sk.ffi.remapToJs(b);
          c.x -= d.x;
          c.y -= d.y;
          c.z -= d.z;
          return a;
        });
        k.__mul__ = Sk.ffi.functionPy(function (a, c) {
          Sk.ffi.checkLhsOperandType('multiply', 'Vector3', f(a), a);
          Sk.ffi.checkRhsOperandType('multiply', b, Sk.ffi.isNum(c), c);
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(c);
          return g(d.x * e, d.y * e, d.z * e);
        });
        k.__rmul__ = Sk.ffi.functionPy(function (a, c) {
          Sk.ffi.checkLhsOperandType('multiply', b, Sk.ffi.isNum(c), c);
          Sk.ffi.checkRhsOperandType('multiply', 'Vector3', f(a), a);
          var d = Sk.ffi.remapToJs(c), e = Sk.ffi.remapToJs(a);
          return g(d * e.x, d * e.y, d * e.z);
        });
        k.__div__ = Sk.ffi.functionPy(function (a, c) {
          Sk.ffi.checkLhsOperandType('divide', 'Vector3', f(a), a);
          Sk.ffi.checkRhsOperandType('divide', b, Sk.ffi.isNum(c), c);
          var d = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(c);
          return g(d.x / e, d.y / e, d.z / e);
        });
        k.__rdiv__ = Sk.ffi.functionPy(function (a, c) {
          Sk.ffi.checkLhsOperandType('divide', b, Sk.ffi.isNum(c), c);
          Sk.ffi.checkRhsOperandType('divide', 'Vector3', f(a), a);
          var d = Sk.ffi.remapToJs(c), e = Sk.ffi.remapToJs(a);
          return g(e.x / d, e.y / d, e.z / d);
        });
        k.__getattr__ = Sk.ffi.functionPy(function (a, e) {
          var f = Sk.ffi.remapToJs(a);
          switch (e) {
          case 'x':
          case 'y':
          case 'z':
            return Sk.ffi.numberToFloatPy(f[e]);
          case 'applyQuaternion':
            return Sk.ffi.callableToPy(d, 'applyQuaternion', function (b, c) {
              Sk.ffi.checkMethodArgs('applyQuaternion', arguments, 1, 1);
              Sk.ffi.checkArgType('q', 'Quaternion', Sk.ffi.isInstance(c, 'Quaternion'), c);
              f.applyQuaternion(Sk.ffi.remapToJs(c));
              return a;
            });
          case 'clone':
            return Sk.ffi.callsim(Sk.ffi.buildClass(d, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'clone';
              });
              b.__call__ = Sk.ffi.functionPy(function (a) {
                return g(f.x, f.y, f.z);
              });
            }, 'clone', []));
          case 'getComponent':
            return Sk.ffi.callableToPy(d, 'getComponent', function (a, b) {
              Sk.ffi.checkMethodArgs('getComponent', arguments, 1, 1);
              Sk.ffi.checkArgType('index', c, Sk.ffi.isNum(b), b);
              return Sk.ffi.numberToFloatPy(f.getComponent(Sk.ffi.remapToJs(b)));
            });
          case 'magnitude':
            return Sk.ffi.callsim(Sk.ffi.buildClass(d, function (a, b) {
              b.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'magnitude';
              });
              b.__call__ = Sk.ffi.functionPy(function (a) {
                return Sk.ffi.numberToFloatPy(f.length());
              });
            }, 'magnitude', []));
          case 'normalize':
            return Sk.ffi.callsim(Sk.ffi.buildClass(d, function (b, c) {
              c.__init__ = Sk.ffi.functionPy(function (a) {
                a.tp$name = 'normalize';
              });
              c.__call__ = Sk.ffi.functionPy(function (b) {
                Sk.ffi.checkMethodArgs('Vector3', arguments, 0, 0);
                f.normalize();
                return a;
              });
            }, 'normalize', []));
          case 'set':
            return Sk.ffi.callableToPy(d, 'set', function (c, d, e, g) {
              Sk.ffi.checkMethodArgs('set', arguments, 3, 3);
              Sk.ffi.checkArgType('x', b, Sk.ffi.isNum(d), d);
              Sk.ffi.checkArgType('y', b, Sk.ffi.isNum(e), e);
              Sk.ffi.checkArgType('z', b, Sk.ffi.isNum(g), g);
              d = Sk.ffi.remapToJs(d);
              e = Sk.ffi.remapToJs(e);
              g = Sk.ffi.remapToJs(g);
              f.set(d, e, g);
              return a;
            });
          case 'setComponent':
            return Sk.ffi.callableToPy(d, 'setComponent', function (d, e, g) {
              Sk.ffi.checkMethodArgs('setComponent', arguments, 2, 2);
              Sk.ffi.checkArgType('index', c, Sk.ffi.isInt(e), e);
              Sk.ffi.checkArgType('value', b, Sk.ffi.isNum(g), g);
              var h = Sk.ffi.remapToJs(e), k = Sk.ffi.remapToJs(g);
              f.setComponent(h, k);
              return a;
            });
          case 'setX':
          case 'setY':
          case 'setZ':
            return Sk.ffi.callableToPy(d, e, function (c, d) {
              Sk.ffi.checkMethodArgs(e, arguments, 1, 1);
              Sk.ffi.checkArgType('value', b, Sk.ffi.isNum(d), d);
              f[e](Sk.ffi.remapToJs(d));
              return a;
            });
          default:
            throw Sk.ffi.err.attribute(e).isNotGetableOnType('Vector3');
          }
        });
        k.__setattr__ = Sk.ffi.functionPy(function (a, c, d) {
          switch (c) {
          case 'x':
          case 'y':
          case 'z':
            Sk.ffi.checkArgType(c, b, Sk.ffi.isNum(d), d);
            Sk.ffi.remapToJs(a)[c] = Sk.ffi.remapToJs(d);
            break;
          default:
            throw Sk.ffi.err.attribute(c).isNotSetableOnType('Vector3');
          }
        });
        k.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('Vector3(' + [
            a.x,
            a.y,
            a.z
          ].join(', ') + ')');
        });
        k.__str__ = Sk.ffi.functionPy(function (b) {
          b = Sk.ffi.remapToJs(b);
          return Sk.ffi.stringToPy(a([
            b.x,
            b.y,
            b.z
          ], [
            'i',
            'j',
            'k'
          ]));
        });
      }, 'Vector3', []);
    };
  }.call(this));
  (function () {
    Sk.builtin.defineFractions = function (a, b, c) {
      Sk.ffi.checkFunctionArgs('defineFractions', arguments, 3, 3);
      var d = function (a) {
          return Sk.ffi.isInstance(a, b);
        }, e = [
          b,
          Sk.ffi.PyType.INT
        ];
      a[b] = Sk.ffi.buildClass(a, function (f, g) {
        g.__init__ = Sk.ffi.functionPy(function (a, e, f) {
          if (Sk.ffi.isUndefined(f))
            Sk.ffi.isUndefined(e) ? Sk.ffi.referenceToPy(c(0, 1), b, void 0, a) : d(e) ? (Sk.ffi.checkMethodArgs(b, arguments, 1, 1), Sk.ffi.referenceToPy(Sk.ffi.remapToJs(e), b, void 0, a)) : Sk.ffi.isNum(e) ? (Sk.ffi.checkArgType('numerator', Sk.ffi.PyType.INT, Sk.ffi.isInt(e), e), g = Sk.ffi.remapToJs(e), Sk.ffi.referenceToPy(c(g, 1), b, void 0, a)) : Sk.ffi.checkMethodArgs(b, arguments, 2, 2);
          else {
            Sk.ffi.checkMethodArgs(b, arguments, 2, 2);
            Sk.ffi.checkArgType('numerator', Sk.ffi.PyType.INT, Sk.ffi.isInt(e), e);
            Sk.ffi.checkArgType('denominator', Sk.ffi.PyType.INT, Sk.ffi.isInt(f), f);
            var g = Sk.ffi.remapToJs(e), n = Sk.ffi.remapToJs(f);
            if (0 != n)
              Sk.ffi.referenceToPy(c(g, n), b, void 0, a);
            else
              throw new Sk.builtin.ZeroDivisionError('denominator must not be zero');
          }
        });
        g.__getattr__ = Sk.ffi.functionPy(function (a, c) {
          var d = Sk.ffi.remapToJs(a);
          switch (c) {
          case 'numer':
          case 'numerator':
            return Sk.ffi.numberToIntPy(d.numer);
          case 'denom':
          case 'denominator':
            return Sk.ffi.numberToIntPy(d.denom);
          default:
            throw Sk.ffi.err.attribute(c).isNotGetableOnType(b);
          }
        });
        g.__add__ = Sk.ffi.functionPy(function (c, f) {
          Sk.ffi.checkRhsOperandType('add', e, d(f) || Sk.ffi.isInt(f), f);
          var g = Sk.ffi.remapToJs(c), m = Sk.ffi.remapToJs(f);
          return Sk.ffi.callsim(a[b], Sk.ffi.referenceToPy(g.add(m), b));
        });
        g.__radd__ = Sk.ffi.functionPy(function (d, f) {
          Sk.ffi.checkLhsOperandType('add', e, Sk.ffi.isInt(f), f);
          var g = Sk.ffi.remapToJs(d), m = c(Sk.ffi.remapToJs(f), 1);
          return Sk.ffi.callsim(a[b], Sk.ffi.referenceToPy(m.add(g), b));
        });
        g.__sub__ = Sk.ffi.functionPy(function (c, f) {
          Sk.ffi.checkRhsOperandType('subtract', e, d(f) || Sk.ffi.isInt(f), f);
          var g = Sk.ffi.remapToJs(c), m = Sk.ffi.remapToJs(f);
          return Sk.ffi.callsim(a[b], Sk.ffi.referenceToPy(g.sub(m), b));
        });
        g.__rsub__ = Sk.ffi.functionPy(function (d, f) {
          Sk.ffi.checkLhsOperandType('subtract', e, Sk.ffi.isInt(f), f);
          var g = Sk.ffi.remapToJs(d), m = c(Sk.ffi.remapToJs(f), 1);
          return Sk.ffi.callsim(a[b], Sk.ffi.referenceToPy(m.sub(g), b));
        });
        g.__mul__ = Sk.ffi.functionPy(function (c, f) {
          var g = Sk.ffi.remapToJs(c), m = Sk.ffi.remapToJs(f);
          if (Sk.ffi.isNum(f))
            return Sk.ffi.checkRhsOperandType('multiply', e, Sk.ffi.isInt(f), f), Sk.ffi.callsim(a[b], Sk.ffi.numberToIntPy(g.numer * m), Sk.ffi.numberToIntPy(g.denom));
          Sk.ffi.checkRhsOperandType('multiply', e, d(f), f);
          return Sk.ffi.callsim(a[b], Sk.ffi.referenceToPy(g.mul(m), b));
        });
        g.__rmul__ = Sk.ffi.functionPy(function (d, f) {
          Sk.ffi.checkLhsOperandType('multiply', e, Sk.ffi.isInt(f), f);
          var g = Sk.ffi.remapToJs(d), m = c(Sk.ffi.remapToJs(f), 1);
          return Sk.ffi.callsim(a[b], Sk.ffi.referenceToPy(m.mul(g), b));
        });
        g.__div__ = Sk.ffi.functionPy(function (c, f) {
          var g = Sk.ffi.remapToJs(c), m = Sk.ffi.remapToJs(f);
          if (Sk.ffi.isNum(f)) {
            if (Sk.ffi.checkRhsOperandType('divide', e, Sk.ffi.isInt(f), f), 0 != m)
              return Sk.ffi.callsim(a[b], Sk.ffi.numberToIntPy(g.numer), Sk.ffi.numberToIntPy(g.denom * m));
          } else if (Sk.ffi.checkRhsOperandType('divide', e, d(f), f), 0 != m.numer)
            return Sk.ffi.callsim(a[b], Sk.ffi.referenceToPy(g.div(m), b));
          throw new Sk.builtin.ZeroDivisionError('denominator must not be zero');
        });
        g.__rdiv__ = Sk.ffi.functionPy(function (d, f) {
          Sk.ffi.checkLhsOperandType('divide', e, Sk.ffi.isInt(f), f);
          var g = Sk.ffi.remapToJs(d), m = c(Sk.ffi.remapToJs(f), 1);
          if (0 != g.numer)
            return Sk.ffi.callsim(a[b], Sk.ffi.referenceToPy(m.div(g), b));
          throw new Sk.builtin.ZeroDivisionError('denominator must not be zero');
        });
        g.__eq__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkFunctionArgs('equal', arguments, 2, 2);
          if (d(a) && d(b)) {
            var c = Sk.ffi.remapToJs(a), e = Sk.ffi.remapToJs(b);
            return Sk.ffi.booleanToPy(c.equals(e));
          }
          return Sk.ffi.bool.False;
        });
        g.__repr__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy(b + '(' + a.numer + ',' + a.denom + ')');
        });
        g.__str__ = Sk.ffi.functionPy(function (a) {
          a = Sk.ffi.remapToJs(a);
          return Sk.ffi.stringToPy('' + a);
        });
      }, b, []);
    };
  }.call(this));
  (function () {
    Sk.builtin.defineWorkbench = function (a) {
      function b(a) {
        a = document.getElementsByTagName(a);
        for (var b = a.length - 1; 0 <= b; b--) {
          var e = a[b];
          e.parentNode.removeChild(e);
        }
      }
      Sk.ffi.checkFunctionArgs('defineWorkbench', arguments, 1, 1);
      a.Workbench2D = Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, b) {
          Sk.ffi.checkMethodArgs('Workbench2D', arguments, 1, 1);
          Sk.ffi.checkArgType('canvas', 'Element', Sk.ffi.isInstance(b), b);
          var c = Sk.ffi.remapToJs(b);
          Sk.ffi.referenceToPy({
            canvas: c,
            onWindowResize: function (a) {
              a = window.innerHeight;
              c.width = window.innerWidth;
              c.height = a;
            }
          }, 'Workbench2D', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (c, d) {
          var g = Sk.ffi.remapToJs(c);
          switch (d) {
          case 'setUp':
            return Sk.ffi.callableToPy(a, 'setUp', function (a) {
              Sk.ffi.checkMethodArgs('setUp', arguments, 0, 0);
              document.body.insertBefore(g.canvas, document.body.firstChild);
              window.addEventListener('resize', g.onWindowResize, !1);
              g.onWindowResize(null);
            });
          case 'tearDown':
            return Sk.ffi.callableToPy(a, 'tearDown', function (a) {
              window.removeEventListener('resize', g.onWindowResize, !1);
              b('canvas');
            });
          }
        });
      }, 'Workbench2D', []);
      a.Workbench3D = Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, b, c, d) {
          Sk.ffi.checkMethodArgs('Workbench3D', arguments, 3, 3);
          Sk.ffi.checkArgType('canvas', 'Element', Sk.ffi.isInstance(b), b);
          var k = Sk.ffi.remapToJs(b), l = Sk.ffi.remapToJs(c), m = Sk.ffi.remapToJs(d);
          Sk.ffi.referenceToPy({
            canvas: k,
            renderer: l,
            camera: m,
            onWindowResize: function (a) {
              a = window.innerWidth;
              var b = window.innerHeight;
              l.setSize(a, b);
              m.aspect = a / b;
              m.updateProjectionMatrix();
            }
          }, 'Workbench3D', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (c, d) {
          var g = Sk.ffi.remapToJs(c);
          switch (d) {
          case 'setUp':
            return Sk.ffi.callableToPy(a, 'setUp', function (a) {
              document.body.insertBefore(g.canvas, document.body.firstChild);
              window.addEventListener('resize', g.onWindowResize, !1);
              g.onWindowResize(null);
            });
          case 'tearDown':
            return Sk.ffi.callableToPy(a, 'tearDown', function (a) {
              window.removeEventListener('resize', g.onWindowResize, !1);
              b('canvas');
            });
          }
        });
      }, 'Workbench3D', []);
      a.Workbench = Sk.ffi.buildClass(a, function (c, d) {
        d.__init__ = Sk.ffi.functionPy(function (a, b, c) {
          Sk.ffi.checkMethodArgs('Workbench', arguments, 2, 2);
          var d = Sk.ffi.remapToJs(b), k = Sk.ffi.remapToJs(c);
          Sk.ffi.referenceToPy({
            renderer: d,
            camera: k,
            onWindowResize: function (a) {
              a = window.innerWidth;
              var b = window.innerHeight;
              d.setSize(a, b);
              k.aspect = a / b;
              k.updateProjectionMatrix();
            }
          }, 'Workbench', void 0, a);
        });
        d.__getattr__ = Sk.ffi.functionPy(function (c, d) {
          var g = Sk.ffi.remapToJs(c);
          switch (d) {
          case 'setUp':
            return Sk.ffi.callableToPy(a, 'setUp', function (a) {
              document.body.insertBefore(g.renderer.domElement, document.body.firstChild);
              window.addEventListener('resize', g.onWindowResize, !1);
              g.onWindowResize(null);
            });
          case 'tearDown':
            return Sk.ffi.callableToPy(a, 'tearDown', function (a) {
              window.removeEventListener('resize', g.onWindowResize, !1);
              b('canvas');
            });
          }
        });
      }, 'Workbench', []);
    };
  }.call(this));
  (function () {
    this.BLADE = this.BLADE || {};
  }.call(this));
  (function () {
    var a, b, c;
    a = this.BLADE = this.BLADE || {};
    c = function (a, b) {
      return 0 === a.numer ? null : 1 === a.denom ? 1 === a.numer ? '' + b : '' + b + ' ** ' + a.numer : '' + b + ' ** ' + a;
    };
    b = function () {
      function b(c, d, g, h) {
        if ('number' === typeof c)
          this.M = new a.Rational(c, 1);
        else if (c instanceof a.Rational)
          this.M = c;
        else
          throw Error('mass must be a Rational or number');
        this.L = 'number' === typeof d ? new a.Rational(d, 1) : d;
        this.T = 'number' === typeof g ? new a.Rational(g, 1) : g;
        if ('number' === typeof h)
          this.Q = new a.Rational(h, 1);
        else if (h instanceof a.Rational)
          this.Q = h;
        else
          throw {
            name: 'DimensionError',
            message: 'charge must be a Rational or number'
          };
      }
      b.prototype.compatible = function (a) {
        if (this.M.equals(a.M) && this.L.equals(a.L) && this.T.equals(a.T) && this.Q.equals(a.Q))
          return this;
        throw {
          name: 'DimensionError',
          message: 'Dimensions must be equal +(' + this + ', ' + a + ')'
        };
      };
      b.prototype.mul = function (b) {
        return new a.Dimensions(this.M.add(b.M), this.L.add(b.L), this.T.add(b.T), this.Q.add(b.Q));
      };
      b.prototype.div = function (b) {
        return new a.Dimensions(this.M.sub(b.M), this.L.sub(b.L), this.T.sub(b.T), this.Q.sub(b.Q));
      };
      b.prototype.pow = function (b) {
        return new a.Dimensions(this.M.mul(b), this.L.mul(b), this.T.mul(b), this.Q.mul(b));
      };
      b.prototype.dimensionless = function () {
        return this.M.isZero() && this.L.isZero() && this.T.isZero() && this.Q.isZero();
      };
      b.prototype.toString = function () {
        return [
          c(this.M, 'M'),
          c(this.L, 'L'),
          c(this.T, 'T'),
          c(this.Q, 'Q')
        ].filter(function (a) {
          return 'string' === typeof a;
        }).join(' * ');
      };
      return b;
    }();
    this.BLADE.Dimensions = b;
  }.call(this));
  (function () {
    var a, b, c;
    a = this.BLADE = this.BLADE || {};
    c = function (b, c, f, g, h, k, l, m, n) {
      var p, q, s, r, w, A, z, D;
      w = +h;
      A = +k;
      z = +l;
      D = -m;
      p = +(h * w + k * A + l * z - m * D);
      q = w * p + -0 * A + -0 * z - -0 * D;
      s = -0 * w + A * p - -0 * z + -0 * D;
      r = -0 * w + -0 * A + z * p - -0 * D;
      p = -0 * w + -0 * A - -0 * z + D * p;
      h = h * q + k * s + l * r - m * p;
      q /= h;
      s /= h;
      r /= h;
      m = p / h;
      h = b * q + c * s + f * r - g * m;
      k = b * s + c * q - f * m + g * r;
      l = b * r + c * m + f * q - g * s;
      b = b * m + c * r - f * s + g * q;
      return 'undefined' !== typeof n ? (n.w = h, n.x = k, n.y = l, n.xy = b) : new a.Euclidean2(h, k, l, b);
    };
    b = function () {
      function b(a, c, d, h) {
        this.w = a || 0;
        this.x = c;
        this.y = d;
        this.xy = h;
      }
      b.fromCartesian = function (b, c, d, h) {
        return new a.Euclidean2(b, c, d, h);
      };
      b.fromPolar = function (b, c, d, h) {
        return new a.Euclidean2(b, c * Math.cos(d), c * Math.sin(d), h);
      };
      b.prototype.coordinates = function () {
        return [
          this.w,
          this.x,
          this.y,
          this.xy
        ];
      };
      b.prototype.coordinate = function (a) {
        switch (a) {
        case 0:
          return this.w;
        case 1:
          return this.x;
        case 2:
          return this.y;
        case 3:
          return this.xy;
        default:
          throw Error('index must be in the range [0..3]');
        }
      };
      b.add = function (b, c) {
        var d, h, k, l, m, n, p, q, s, r, w;
        d = b[0];
        h = b[1];
        k = b[2];
        l = b[3];
        m = c[0];
        n = c[1];
        p = c[2];
        q = c[3];
        s = a.e2gaASM.add00(d, h, k, l, m, n, p, q);
        r = a.e2gaASM.add01(d, h, k, l, m, n, p, q);
        w = a.e2gaASM.add10(d, h, k, l, m, n, p, q);
        d = a.e2gaASM.add11(d, h, k, l, m, n, p, q);
        return [
          s,
          r,
          w,
          d
        ];
      };
      b.prototype.add = function (c) {
        c = b.add(this.coordinates(), c.coordinates());
        return new a.Euclidean2(c[0], c[1], c[2], c[3]);
      };
      b.sub = function (b, c) {
        var d, h, k, l, m, n, p, q, s, r, w;
        d = b[0];
        h = b[1];
        k = b[2];
        l = b[3];
        m = c[0];
        n = c[1];
        p = c[2];
        q = c[3];
        s = a.bladeASM.subE2(d, h, k, l, m, n, p, q, 0);
        r = a.bladeASM.subE2(d, h, k, l, m, n, p, q, 1);
        w = a.bladeASM.subE2(d, h, k, l, m, n, p, q, 2);
        d = a.bladeASM.subE2(d, h, k, l, m, n, p, q, 3);
        return [
          s,
          r,
          w,
          d
        ];
      };
      b.prototype.sub = function (c) {
        c = b.sub(this.coordinates(), c.coordinates());
        return new a.Euclidean2(c[0], c[1], c[2], c[3]);
      };
      b.mul = function (b, c) {
        var d, h, k, l, m, n, p, q, s, r, w;
        d = b[0];
        h = b[1];
        k = b[2];
        l = b[3];
        m = c[0];
        n = c[1];
        p = c[2];
        q = c[3];
        s = a.bladeASM.mulE2(d, h, k, l, m, n, p, q, 0);
        r = a.bladeASM.mulE2(d, h, k, l, m, n, p, q, 1);
        w = a.bladeASM.mulE2(d, h, k, l, m, n, p, q, 2);
        d = a.bladeASM.mulE2(d, h, k, l, m, n, p, q, 3);
        return [
          s,
          r,
          w,
          d
        ];
      };
      b.prototype.mul = function (c) {
        if ('number' === typeof c)
          return new a.Euclidean2(this.w * c, this.x * c, this.y * c, this.xy * c);
        c = b.mul(this.coordinates(), c.coordinates());
        return new a.Euclidean2(c[0], c[1], c[2], c[3]);
      };
      b.prototype.div = function (b) {
        return 'number' === typeof b ? new a.Euclidean2(this.w / b, this.x / b, this.y / b, this.xy / b) : c(this.w, this.x, this.y, this.xy, b.w, b.x, b.y, b.xy, void 0);
      };
      b.wedge = function (b, c) {
        var d, h, k, l, m, n, p, q, s, r, w;
        d = b[0];
        h = b[1];
        k = b[2];
        l = b[3];
        m = c[0];
        n = c[1];
        p = c[2];
        q = c[3];
        s = a.bladeASM.extE2(d, h, k, l, m, n, p, q, 0);
        r = a.bladeASM.extE2(d, h, k, l, m, n, p, q, 1);
        w = a.bladeASM.extE2(d, h, k, l, m, n, p, q, 2);
        d = a.bladeASM.extE2(d, h, k, l, m, n, p, q, 3);
        return [
          s,
          r,
          w,
          d
        ];
      };
      b.prototype.wedge = function (c) {
        c = b.wedge(this.coordinates(), c.coordinates());
        return new a.Euclidean2(c[0], c[1], c[2], c[3]);
      };
      b.lshift = function (b, c) {
        var d, h, k, l, m, n, p, q, s, r, w;
        d = b[0];
        h = b[1];
        k = b[2];
        l = b[3];
        m = c[0];
        n = c[1];
        p = c[2];
        q = c[3];
        s = a.bladeASM.lcoE2(d, h, k, l, m, n, p, q, 0);
        r = a.bladeASM.lcoE2(d, h, k, l, m, n, p, q, 1);
        w = a.bladeASM.lcoE2(d, h, k, l, m, n, p, q, 2);
        d = a.bladeASM.lcoE2(d, h, k, l, m, n, p, q, 3);
        return [
          s,
          r,
          w,
          d
        ];
      };
      b.prototype.lshift = function (c) {
        c = b.lshift(this.coordinates(), c.coordinates());
        return new a.Euclidean2(c[0], c[1], c[2], c[3]);
      };
      b.rshift = function (b, c) {
        var d, h, k, l, m, n, p, q, s, r, w;
        d = b[0];
        h = b[1];
        k = b[2];
        l = b[3];
        m = c[0];
        n = c[1];
        p = c[2];
        q = c[3];
        s = a.bladeASM.rcoE2(d, h, k, l, m, n, p, q, 0);
        r = a.bladeASM.rcoE2(d, h, k, l, m, n, p, q, 1);
        w = a.bladeASM.rcoE2(d, h, k, l, m, n, p, q, 2);
        d = a.bladeASM.rcoE2(d, h, k, l, m, n, p, q, 3);
        return [
          s,
          r,
          w,
          d
        ];
      };
      b.prototype.rshift = function (c) {
        c = b.rshift(this.coordinates(), c.coordinates());
        return new a.Euclidean2(c[0], c[1], c[2], c[3]);
      };
      b.prototype.grade = function (b) {
        switch (b) {
        case 0:
          return new a.Euclidean2(this.w, 0, 0, 0);
        case 1:
          return new a.Euclidean2(0, this.x, this.y, 0);
        case 2:
          return new a.Euclidean2(0, 0, 0, this.xy);
        default:
          return new a.Euclidean2(0, 0, 0, 0);
        }
      };
      b.prototype.quadrance = function () {
        var a, b, c, d;
        a = this.w;
        b = this.x;
        d = this.y;
        c = this.xy;
        return a * a + b * b + d * d + c * c;
      };
      b.prototype.isNaN = function () {
        return isNaN(this.w) || isNaN(this.x) || isNaN(this.y) || isNaN(this.xy);
      };
      b.prototype.toString = function () {
        return a.bladeSTR.stringFromCoordinates([
          this.w,
          this.x,
          this.y,
          this.xy
        ], [
          '1',
          'e1',
          'e2',
          'e12'
        ]);
      };
      b.prototype.toStringIJK = function () {
        return a.bladeSTR.stringFromCoordinates(this.coordinates(), [
          '1',
          'i',
          'j',
          'I'
        ]);
      };
      b.prototype.toStringLATEX = function () {
        return a.bladeSTR.stringFromCoordinates(this.coordinates(), [
          '1',
          'e_{1}',
          'e_{2}',
          'e_{12}'
        ]);
      };
      return b;
    }();
    this.BLADE.Euclidean2 = b;
  }.call(this));
  (function () {
    var a, b, c, d;
    a = this.BLADE = this.BLADE || {};
    d = function (a, b, c, d, k, l, m, n, p, q, s, r, w, A, z, D, v) {
      var C;
      a = +a;
      b = +b;
      c = +c;
      d = +d;
      k = +k;
      l = +l;
      m = +m;
      n = +n;
      p = +p;
      q = +q;
      s = +s;
      r = +r;
      w = +w;
      A = +A;
      z = +z;
      D = +D;
      C = 0;
      switch (~~(v | 0)) {
      case 0:
        C = +(a * p + b * q + c * s + d * r - k * w - l * A - m * z - n * D);
        break;
      case 1:
        C = +(a * q + b * p - c * w + d * z + k * s - l * D - m * r - n * A);
        break;
      case 2:
        C = +(a * s + b * w + c * p - d * A - k * q + l * r - m * D - n * z);
        break;
      case 3:
        C = +(a * r - b * z + c * A + d * p - k * D - l * s + m * q - n * w);
        break;
      case 4:
        C = +(a * w + b * s - c * q + d * D + k * p - l * z + m * A + n * r);
        break;
      case 5:
        C = +(a * A + b * D + c * r - d * s + k * z + l * p - m * w + n * q);
        break;
      case 6:
        C = +(a * z - b * r + c * D + d * q - k * A + l * w + m * p + n * s);
        break;
      case 7:
        C = +(a * D + b * A + c * z + d * w + k * r + l * q + m * s + n * p);
      }
      return +C;
    };
    c = function (b, c, g, h, k, l, m, n, p, q, s, r, w, A, z, D, v) {
      var C, I, J, K, H, G, L, y, F, x, t, u, E, B, M, N, O, P, T;
      x = +p;
      t = +q;
      y = +s;
      u = -r;
      E = +w;
      B = -A;
      M = -z;
      N = -D;
      F = d(p, q, s, w, r, z, -A, D, x, t, y, E, u, M, -B, N, 0);
      H = d(p, q, s, w, r, z, -A, D, x, t, y, E, u, M, -B, N, 1);
      G = d(p, q, s, w, r, z, -A, D, x, t, y, E, u, M, -B, N, 2);
      L = d(p, q, s, w, r, z, -A, D, x, t, y, E, u, M, -B, N, 3);
      C = +F;
      I = -H;
      J = -G;
      K = -L;
      O = d(x, t, y, E, u, M, -B, N, C, I, J, K, -0, -0, 0, 0, 0);
      P = d(x, t, y, E, u, M, -B, N, C, I, J, K, -0, -0, 0, 0, 1);
      T = d(x, t, y, E, u, M, -B, N, C, I, J, K, -0, -0, 0, 0, 2);
      F = d(x, t, y, E, u, M, -B, N, C, I, J, K, -0, -0, 0, 0, 4);
      H = d(x, t, y, E, u, M, -B, N, C, I, J, K, -0, -0, 0, 0, 3);
      G = -d(x, t, y, E, u, M, -B, N, C, I, J, K, -0, -0, 0, 0, 6);
      L = d(x, t, y, E, u, M, -B, N, C, I, J, K, -0, -0, 0, 0, 5);
      x = d(x, t, y, E, u, M, -B, N, C, I, J, K, -0, -0, 0, 0, 7);
      w = d(p, q, s, w, r, z, -A, D, O, P, T, H, F, L, -G, x, 0);
      p = O / w;
      q = P / w;
      s = T / w;
      r = F / w;
      H /= w;
      G /= w;
      L /= w;
      y = x / w;
      w = d(b, c, g, k, h, m, -l, n, p, q, s, H, r, L, -G, y, 0);
      A = d(b, c, g, k, h, m, -l, n, p, q, s, H, r, L, -G, y, 1);
      z = d(b, c, g, k, h, m, -l, n, p, q, s, H, r, L, -G, y, 2);
      D = d(b, c, g, k, h, m, -l, n, p, q, s, H, r, L, -G, y, 4);
      F = d(b, c, g, k, h, m, -l, n, p, q, s, H, r, L, -G, y, 3);
      t = -d(b, c, g, k, h, m, -l, n, p, q, s, H, r, L, -G, y, 6);
      x = d(b, c, g, k, h, m, -l, n, p, q, s, H, r, L, -G, y, 5);
      b = d(b, c, g, k, h, m, -l, n, p, q, s, H, r, L, -G, y, 7);
      c = -t;
      return 'undefined' !== typeof v ? (v.w = w, v.x = A, v.y = z, v.z = F, v.xy = D, v.yz = x, v.zx = c, v.xyz = b) : new a.Euclidean3(w, A, z, F, D, x, c, b);
    };
    b = function () {
      function b(a, c, d, e, l, m, n, p) {
        this.w = a || 0;
        this.x = c || 0;
        this.y = d || 0;
        this.z = e || 0;
        this.xy = l || 0;
        this.yz = m || 0;
        this.zx = n || 0;
        this.xyz = p || 0;
      }
      b.fromCartesian = function (b, c, d, e, l, m, n, p) {
        return new a.Euclidean3(b, c, d, e, l, m, n, p);
      };
      b.prototype.coordinates = function () {
        return [
          this.w,
          this.x,
          this.y,
          this.z,
          this.xy,
          this.yz,
          this.zx,
          this.xyz
        ];
      };
      b.prototype.coordinate = function (a) {
        switch (a) {
        case 0:
          return this.w;
        case 1:
          return this.x;
        case 2:
          return this.y;
        case 3:
          return this.z;
        case 4:
          return this.xy;
        case 5:
          return this.yz;
        case 6:
          return this.zx;
        case 7:
          return this.xyz;
        default:
          throw Error('index must be in the range [0..7]');
        }
      };
      b.compute = function (a, b, c, d, e) {
        var m, n, p, q, s, r, w, A, z, D, v, C, I, J, K, H, G, L, y, F;
        m = d(b, 0);
        n = d(b, 1);
        p = d(b, 2);
        q = d(b, 3);
        s = d(b, 4);
        r = d(b, 5);
        w = d(b, 6);
        b = d(b, 7);
        A = d(c, 0);
        z = d(c, 1);
        D = d(c, 2);
        v = d(c, 3);
        C = d(c, 4);
        I = d(c, 5);
        J = d(c, 6);
        K = d(c, 7);
        c = a(m, n, p, q, s, r, w, b, A, z, D, v, C, I, J, K, 0);
        d = a(m, n, p, q, s, r, w, b, A, z, D, v, C, I, J, K, 1);
        H = a(m, n, p, q, s, r, w, b, A, z, D, v, C, I, J, K, 2);
        G = a(m, n, p, q, s, r, w, b, A, z, D, v, C, I, J, K, 3);
        L = a(m, n, p, q, s, r, w, b, A, z, D, v, C, I, J, K, 4);
        y = a(m, n, p, q, s, r, w, b, A, z, D, v, C, I, J, K, 5);
        F = a(m, n, p, q, s, r, w, b, A, z, D, v, C, I, J, K, 6);
        a = a(m, n, p, q, s, r, w, b, A, z, D, v, C, I, J, K, 7);
        return e(c, d, H, G, L, y, F, a);
      };
      b.prototype.add = function (c) {
        return b.compute(a.bladeASM.addE3, [
          this.w,
          this.x,
          this.y,
          this.z,
          this.xy,
          this.yz,
          this.zx,
          this.xyz
        ], [
          c.w,
          c.x,
          c.y,
          c.z,
          c.xy,
          c.yz,
          c.zx,
          c.xyz
        ], function (a, b) {
          return a[b];
        }, function (a, c, d, f, m, n, p, q) {
          return b.fromCartesian(a, c, d, f, m, n, p, q);
        });
      };
      b.prototype.sub = function (c) {
        return b.compute(a.bladeASM.subE3, [
          this.w,
          this.x,
          this.y,
          this.z,
          this.xy,
          this.yz,
          this.zx,
          this.xyz
        ], [
          c.w,
          c.x,
          c.y,
          c.z,
          c.xy,
          c.yz,
          c.zx,
          c.xyz
        ], function (a, b) {
          return a[b];
        }, function (a, c, d, f, m, n, p, q) {
          return b.fromCartesian(a, c, d, f, m, n, p, q);
        });
      };
      b.prototype.mul = function (c) {
        return 'number' === typeof c ? new a.Euclidean3(this.w * c, this.x * c, this.y * c, this.z * c, this.xy * c, this.yz * c, this.zx * c, this.xyz * c) : b.compute(a.bladeASM.mulE3, [
          this.w,
          this.x,
          this.y,
          this.z,
          this.xy,
          this.yz,
          this.zx,
          this.xyz
        ], [
          c.w,
          c.x,
          c.y,
          c.z,
          c.xy,
          c.yz,
          c.zx,
          c.xyz
        ], function (a, b) {
          return a[b];
        }, function (a, c, d, f, m, n, p, q) {
          return b.fromCartesian(a, c, d, f, m, n, p, q);
        });
      };
      b.prototype.div = function (b) {
        return 'number' === typeof b ? new a.Euclidean3(this.w / b, this.x / b, this.y / b, this.z / b, this.xy / b, this.yz / b, this.zx / b, this.xyz / b) : c(this.w, this.x, this.y, this.xy, this.z, -this.zx, this.yz, this.xyz, b.w, b.x, b.y, b.xy, b.z, -b.zx, b.yz, b.xyz, void 0);
      };
      b.prototype.wedge = function (c) {
        return b.compute(a.bladeASM.extE3, [
          this.w,
          this.x,
          this.y,
          this.z,
          this.xy,
          this.yz,
          this.zx,
          this.xyz
        ], [
          c.w,
          c.x,
          c.y,
          c.z,
          c.xy,
          c.yz,
          c.zx,
          c.xyz
        ], function (a, b) {
          return a[b];
        }, function (a, c, d, f, m, n, p, q) {
          return b.fromCartesian(a, c, d, f, m, n, p, q);
        });
      };
      b.prototype.lshift = function (c) {
        return b.compute(a.bladeASM.lcoE3, [
          this.w,
          this.x,
          this.y,
          this.z,
          this.xy,
          this.yz,
          this.zx,
          this.xyz
        ], [
          c.w,
          c.x,
          c.y,
          c.z,
          c.xy,
          c.yz,
          c.zx,
          c.xyz
        ], function (a, b) {
          return a[b];
        }, function (a, c, d, f, m, n, p, q) {
          return b.fromCartesian(a, c, d, f, m, n, p, q);
        });
      };
      b.prototype.rshift = function (c) {
        return b.compute(a.bladeASM.rcoE3, [
          this.w,
          this.x,
          this.y,
          this.z,
          this.xy,
          this.yz,
          this.zx,
          this.xyz
        ], [
          c.w,
          c.x,
          c.y,
          c.z,
          c.xy,
          c.yz,
          c.zx,
          c.xyz
        ], function (a, b) {
          return a[b];
        }, function (a, c, d, f, m, n, p, q) {
          return b.fromCartesian(a, c, d, f, m, n, p, q);
        });
      };
      b.prototype.grade = function (a) {
        switch (a) {
        case 0:
          return b.fromCartesian(this.w, 0, 0, 0, 0, 0, 0, 0);
        case 1:
          return b.fromCartesian(0, this.x, this.y, this.z, 0, 0, 0, 0);
        case 2:
          return b.fromCartesian(0, 0, 0, 0, this.xy, this.yz, this.zx, 0);
        case 3:
          return b.fromCartesian(0, 0, 0, 0, 0, 0, 0, this.xyz);
        default:
          return b.fromCartesian(0, 0, 0, 0, 0, 0, 0, 0);
        }
      };
      b.prototype.dot = function (a) {
        return this.x * a.x + this.y * a.y + this.z * a.z;
      };
      b.prototype.cross = function (b) {
        var c, d, e, l, m;
        c = this.x;
        e = this.y;
        m = this.z;
        d = b.x;
        l = b.y;
        b = b.z;
        return new a.Euclidean3(0, e * b - m * l, m * d - c * b, c * l - e * d, 0, 0, 0, 0);
      };
      b.prototype.length = function () {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      };
      b.prototype.toString = function () {
        return a.bladeSTR.stringFromCoordinates([
          this.w,
          this.x,
          this.y,
          this.z,
          this.xy,
          this.yz,
          this.zx,
          this.xyz
        ], '1 e1 e2 e3 e12 e23 e31 e123'.split(' '));
      };
      b.prototype.toStringIJK = function () {
        return a.bladeSTR.stringFromCoordinates([
          this.w,
          this.x,
          this.y,
          this.z,
          this.xy,
          this.yz,
          this.zx,
          this.xyz
        ], '1 i j k ij jk ki I'.split(' '));
      };
      b.prototype.toStringLATEX = function () {
        return a.bladeSTR.stringFromCoordinates([
          this.w,
          this.x,
          this.y,
          this.z,
          this.xy,
          this.yz,
          this.zx,
          this.xyz
        ], '1 e_{1} e_{2} e_{3} e_{12} e_{23} e_{31} e_{123}'.split(' '));
      };
      return b;
    }();
    this.BLADE.Euclidean3 = b;
  }.call(this));
  (function () {
    var a, b;
    a = this.BLADE = this.BLADE || {};
    b = function () {
      function b(a, c, f) {
        this.a = a;
        this.b = c;
        this.c = f;
      }
      b.prototype.meetWithLine = function (b) {
        var c, f, g, h, k, l;
        c = this.a;
        g = this.b;
        k = this.c;
        f = b.a;
        h = b.b;
        b = b.c;
        l = c * h - f * g;
        return new a.Point2((g * b - h * k) / l, (f * k - c * b) / l);
      };
      b.prototype.passesThroughPoint = function (a, b) {
        return Math.abs(this.a * a.x + this.b * a.y + this.c) < b;
      };
      b.prototype.reflectPoint = function (b) {
        var c, f, g, h, k, l;
        c = this.a;
        f = c * c;
        g = this.b;
        h = g * g;
        k = this.c;
        l = f - h;
        f += h;
        h = b.x;
        b = b.y;
        return new a.Point2(-(2 * c * (g * b + k) + h * f) / l, (2 * g * (c * h + k) + b * f) / l);
      };
      return b;
    }();
    this.BLADE.Line2 = b;
  }.call(this));
  (function () {
    var a, b;
    a = this.BLADE = this.BLADE || {};
    b = function () {
      function b(c, e) {
        var f;
        f = e.scale;
        1 === f ? (this.quantity = c, this.uom = e) : (this.quantity = c.mul(f), this.uom = new a.Unit(1, e.dimensions, e.labels));
      }
      b.prototype.add = function (b) {
        if (b instanceof a.Measure)
          return new a.Measure(this.quantity.add(b.quantity), this.uom.compatible(b.uom));
        throw Error('Measure.add(rhs): rhs must be a Measure.');
      };
      b.prototype.sub = function (b) {
        if (b instanceof a.Measure)
          return new a.Measure(this.quantity.sub(b.quantity), this.uom.compatible(b.uom));
        throw Error('Measure.sub(rhs): rhs must be a Measure.');
      };
      b.prototype.mul = function (b) {
        if (b instanceof a.Measure)
          return new a.Measure(this.quantity.mul(b.quantity), this.uom.mul(b.uom));
        if (b instanceof a.Unit)
          return new a.Measure(this.quantity, this.uom.mul(b));
        if ('number' === typeof b)
          return new a.Measure(this.quantity.mul(b), this.uom);
        throw Error('Measure.mul(rhs): rhs must be a [Measure, Unit, number]');
      };
      b.prototype.div = function (b) {
        if (b instanceof a.Measure)
          return new a.Measure(this.quantity.div(b.quantity), this.uom.div(b.uom));
        if (b instanceof a.Unit)
          return new a.Measure(this.quantity, this.uom.div(b));
        if ('number' === typeof b)
          return new a.Measure(this.quantity.div(b), this.uom);
        throw Error('Measure.div(rhs): rhs must be a [Measure, Unit, number]');
      };
      b.prototype.wedge = function (b) {
        if (b instanceof a.Measure)
          return new a.Measure(this.quantity.wedge(b.quantity), this.uom.mul(b.uom));
        throw Error('Measure.wedge(rhs): rhs must be a Measure');
      };
      b.prototype.toString = function () {
        return '' + this.quantity + ' ' + this.uom;
      };
      return b;
    }();
    this.BLADE.Measure = b;
  }.call(this));
  (function () {
    var a, b;
    a = this.BLADE = this.BLADE || {};
    b = function () {
      function b(a, c) {
        this.x = a;
        this.y = c;
      }
      b.prototype.joinToPoint = function (b) {
        var c, f, g;
        c = this.x;
        g = this.y;
        f = b.x;
        b = b.y;
        return new a.Line2(g - b, f - c, c * b - f * g);
      };
      b.prototype.liesOnLine = function (a, b) {
        return Math.abs(a.a * this.x + a.b * this.y + a.c) < b;
      };
      b.prototype.quadrance = function (a) {
        var b, c, g;
        b = this.x;
        c = this.y;
        g = a.x;
        a = a.y;
        b = g - b;
        c = a - c;
        return b * b + c * c;
      };
      b.prototype.reflectAboutLine = function (b) {
        var c, f, g, h, k, l;
        c = b.a;
        f = c * c;
        g = b.b;
        h = g * g;
        b = b.c;
        k = f - h;
        f += h;
        h = this.x;
        l = this.y;
        return new a.Point2(-(2 * c * (g * l + b) + h * f) / k, (2 * g * (c * h + b) + l * f) / k);
      };
      b.prototype.signedArea = function (b, c) {
        var f, g;
        f = this.vectorTo(b);
        g = this.vectorTo(c);
        return f.wedge(g).mul(new a.Euclidean2(0.5, 0, 0, 0));
      };
      b.prototype.vectorTo = function (b) {
        return new a.Euclidean2(0, b.x - this.x, b.y - this.y, 0);
      };
      return b;
    }();
    this.BLADE.Point2 = b;
  }.call(this));
  (function () {
    var a, b, c;
    a = this.BLADE = this.BLADE || {};
    c = function (a, b) {
      var c;
      0 > a && (a = -a);
      0 > b && (b = -b);
      b > a && (c = a, a = b, b = c);
      for (;;) {
        a %= b;
        if (0 === a)
          return b;
        b %= a;
        if (0 === b)
          return a;
      }
    };
    b = function () {
      function b(a, d) {
        var g;
        if (0 === d)
          throw Error('denominator must not be zero');
        g = 0 === a ? 1 : c(Math.abs(a), Math.abs(d));
        0 > d && (a = -a, d = -d);
        this.numer = a / g;
        this.denom = d / g;
      }
      b.prototype.add = function (b) {
        return 'number' === typeof b ? new a.Rational(this.numer + this.denom * b, this.denom) : new a.Rational(this.numer * b.denom + this.denom * b.numer, this.denom * b.denom);
      };
      b.prototype.sub = function (b) {
        return 'number' === typeof b ? new a.Rational(this.numer - this.denom * b, this.denom) : new a.Rational(this.numer * b.denom - this.denom * b.numer, this.denom * b.denom);
      };
      b.prototype.mul = function (b) {
        return 'number' === typeof b ? new a.Rational(this.numer * b, this.denom) : new a.Rational(this.numer * b.numer, this.denom * b.denom);
      };
      b.prototype.div = function (b) {
        return new a.Rational(this.numer * b.denom, this.denom * b.numer);
      };
      b.prototype.isZero = function () {
        return 0 === this.numer;
      };
      b.prototype.equals = function (b) {
        return b instanceof a.Rational ? this.numer * b.denom === this.denom * b.numer : !1;
      };
      b.prototype.toString = function () {
        return '' + this.numer + '/' + this.denom;
      };
      return b;
    }();
    this.BLADE.Rational = b;
  }.call(this));
  (function () {
    var a, b, c;
    a = this.BLADE = this.BLADE || {};
    c = function (a, b) {
      return 0 === a.numer ? null : 1 === a.denom ? 1 === a.numer ? '' + b : '' + b + ' ** ' + a.numer : '' + b + ' ** ' + a;
    };
    b = function () {
      function b(a, c, d) {
        this.scale = a;
        this.dimensions = c;
        this.labels = d;
      }
      b.prototype.compatible = function (a) {
        if (a instanceof b)
          return this.dimensions.compatible(a.dimensions), this;
        throw Error('Illegal Argument for Unit.compatible: ' + a);
      };
      b.prototype.add = function (c) {
        if (c instanceof b)
          return new a.Unit(this.scale + c.scale, this.dimensions.compatible(c.dimensions), this.labels);
        throw Error('Illegal Argument for Unit.add: ' + c);
      };
      b.prototype.sub = function (c) {
        if (c instanceof b)
          return new a.Unit(this.scale - c.scale, this.dimensions.compatible(c.dimensions), this.labels);
        throw Error('Illegal Argument for Unit.sub: ' + c);
      };
      b.prototype.mul = function (c) {
        if ('number' === typeof c)
          return new a.Unit(this.scale * c, this.dimensions, this.labels);
        if (c instanceof b)
          return new a.Unit(this.scale * c.scale, this.dimensions.mul(c.dimensions), this.labels);
        throw Error('Illegal Argument for mul: ' + c);
      };
      b.prototype.div = function (c) {
        if ('number' === typeof c)
          return new a.Unit(this.scale / c, this.dimensions, this.labels);
        if (c instanceof b)
          return new a.Unit(this.scale / c.scale, this.dimensions.div(c.dimensions), this.labels);
        throw Error('Illegal Argument for div: ' + c);
      };
      b.prototype.pow = function (b) {
        if ('number' === typeof b)
          return new a.Unit(Math.pow(this.scale, b), this.dimensions.pow(b), this.labels);
        throw Error('Illegal Argument for div: ' + b);
      };
      b.prototype.toString = function () {
        var a, b, d;
        a = 1 === this.scale || this.dimensions.dimensionless() ? '' : ' ';
        b = 1 === this.scale ? '' : '' + this.scale;
        d = [
          c(this.dimensions.M, this.labels[0]),
          c(this.dimensions.L, this.labels[1]),
          c(this.dimensions.T, this.labels[2]),
          c(this.dimensions.Q, this.labels[3])
        ].filter(function (a) {
          return 'string' === typeof a;
        }).join(' ');
        return '' + b + a + d;
      };
      return b;
    }();
    this.BLADE.Unit = b;
  }.call(this));
  (function () {
    this.BLADE = this.BLADE || {};
    this.BLADE.bladeASM = function (a, b, c) {
      return {
        addE2: function (a, b, c, g, h, k, l, m, n) {
          var p = 0;
          switch (~~(n | 0)) {
          case 0:
            p = +(+a + +h);
            break;
          case 1:
            p = +(+b + +k);
            break;
          case 2:
            p = +(+c + +l);
            break;
          case 3:
            p = +(+g + +m);
          }
          return +p;
        },
        subE2: function (a, b, c, g, h, k, l, m, n) {
          var p = 0;
          switch (~~(n | 0)) {
          case 0:
            p = +(+a - +h);
            break;
          case 1:
            p = +(+b - +k);
            break;
          case 2:
            p = +(+c - +l);
            break;
          case 3:
            p = +(+g - +m);
          }
          return +p;
        },
        mulE2: function (a, b, c, g, h, k, l, m, n) {
          a = +a;
          b = +b;
          c = +c;
          g = +g;
          h = +h;
          k = +k;
          l = +l;
          m = +m;
          var p = 0;
          switch (~~(n | 0)) {
          case 0:
            p = +(a * h + b * k + c * l - g * m);
            break;
          case 1:
            p = +(a * k + b * h - c * m + g * l);
            break;
          case 2:
            p = +(a * l + b * m + c * h - g * k);
            break;
          case 3:
            p = +(a * m + b * l - c * k + g * h);
          }
          return +p;
        },
        extE2: function (a, b, c, g, h, k, l, m, n) {
          a = +a;
          b = +b;
          c = +c;
          h = +h;
          k = +k;
          l = +l;
          var p = 0;
          switch (~~(n | 0)) {
          case 0:
            p = +(a * h);
            break;
          case 1:
            p = +(a * k + b * h);
            break;
          case 2:
            p = +(a * l + c * h);
            break;
          case 3:
            p = +(a * +m + b * l - c * k + +g * h);
          }
          return +p;
        },
        lcoE2: function (a, b, c, g, h, k, l, m, n) {
          a = +a;
          b = +b;
          c = +c;
          k = +k;
          l = +l;
          m = +m;
          var p = 0;
          switch (~~(n | 0)) {
          case 0:
            p = +(a * +h + b * k + c * l - +g * m);
            break;
          case 1:
            p = +(a * k - c * m);
            break;
          case 2:
            p = +(a * l + b * m);
            break;
          case 3:
            p = +(a * m);
          }
          return +p;
        },
        rcoE2: function (a, b, c, g, h, k, l, m, n) {
          b = +b;
          c = +c;
          g = +g;
          h = +h;
          k = +k;
          l = +l;
          var p = 0;
          switch (~~(n | 0)) {
          case 0:
            p = +(+a * h + b * k + c * l - g * +m);
            break;
          case 1:
            p = +(-b * h - g * l);
            break;
          case 2:
            p = +(-c * h + g * k);
            break;
          case 3:
            p = +(g * h);
          }
          return +p;
        },
        addE3: function (a, b, c, g, h, k, l, m, n, p, q, s, r, w, A, z, D) {
          var v = 0;
          switch (~~(D | 0)) {
          case 0:
            v = +(+a + +n);
            break;
          case 1:
            v = +(+b + +p);
            break;
          case 2:
            v = +(+c + +q);
            break;
          case 3:
            v = +(+g + +s);
            break;
          case 4:
            v = +(+h + +r);
            break;
          case 5:
            v = +(+k + +w);
            break;
          case 6:
            v = +(+l + +A);
            break;
          case 7:
            v = +(+m + +z);
          }
          return +v;
        },
        subE3: function (a, b, c, g, h, k, l, m, n, p, q, s, r, w, A, z, D) {
          var v = 0;
          switch (~~(D | 0)) {
          case 0:
            v = +(+a - +n);
            break;
          case 1:
            v = +(+b - +p);
            break;
          case 2:
            v = +(+c - +q);
            break;
          case 3:
            v = +(+g - +s);
            break;
          case 4:
            v = +(+h - +r);
            break;
          case 5:
            v = +(+k - +w);
            break;
          case 6:
            v = +(+l - +A);
            break;
          case 7:
            v = +(+m - +z);
          }
          return +v;
        },
        mulE3: function (a, b, c, g, h, k, l, m, n, p, q, s, r, w, A, z, D) {
          a = +a;
          b = +b;
          c = +c;
          g = +g;
          h = +h;
          k = +k;
          l = +l;
          m = +m;
          n = +n;
          p = +p;
          q = +q;
          s = +s;
          r = +r;
          w = +w;
          A = +A;
          z = +z;
          var v = 0;
          switch (~~(D | 0)) {
          case 0:
            v = +(a * n + b * p + c * q + g * s - h * r - k * w - l * A - m * z);
            break;
          case 1:
            v = +(a * p + b * n - c * r + g * A + h * q - k * z - l * s - m * w);
            break;
          case 2:
            v = +(a * q + b * r + c * n - g * w - h * p + k * s - l * z - m * A);
            break;
          case 3:
            v = +(a * s - b * A + c * w + g * n - h * z - k * q + l * p - m * r);
            break;
          case 4:
            v = +(a * r + b * q - c * p + g * z + h * n - k * A + l * w + m * s);
            break;
          case 5:
            v = +(a * w + b * z + c * s - g * q + h * A + k * n - l * r + m * p);
            break;
          case 6:
            v = +(a * A - b * s + c * z + g * p - h * w + k * r + l * n + m * q);
            break;
          case 7:
            v = +(a * z + b * w + c * A + g * r + h * s + k * p + l * q + m * n);
          }
          return +v;
        },
        extE3: function (a, b, c, g, h, k, l, m, n, p, q, s, r, w, A, z, D) {
          a = +a;
          b = +b;
          c = +c;
          g = +g;
          h = +h;
          k = +k;
          l = +l;
          n = +n;
          p = +p;
          q = +q;
          s = +s;
          r = +r;
          w = +w;
          A = +A;
          var v = 0;
          switch (~~(D | 0)) {
          case 0:
            v = +(a * n);
            break;
          case 1:
            v = +(a * p + b * n);
            break;
          case 2:
            v = +(a * q + c * n);
            break;
          case 3:
            v = +(a * s + g * n);
            break;
          case 4:
            v = +(a * r + b * q - c * p + h * n);
            break;
          case 5:
            v = +(a * w + c * s - g * q + k * n);
            break;
          case 6:
            v = +(a * A - b * s + g * p + l * n);
            break;
          case 7:
            v = +(a * +z + b * w + c * A + g * r + h * s + k * p + l * q + +m * n);
          }
          return +v;
        },
        lcoE3: function (a, b, c, g, h, k, l, m, n, p, q, s, r, w, A, z, D) {
          a = +a;
          b = +b;
          c = +c;
          g = +g;
          h = +h;
          k = +k;
          l = +l;
          p = +p;
          q = +q;
          s = +s;
          r = +r;
          w = +w;
          A = +A;
          z = +z;
          var v = 0;
          switch (~~(D | 0)) {
          case 0:
            v = +(a * +n + b * p + c * q + g * s - h * r - k * w - l * A - +m * z);
            break;
          case 1:
            v = +(a * p - c * r + g * A - k * z);
            break;
          case 2:
            v = +(a * q + b * r - g * w - l * z);
            break;
          case 3:
            v = +(a * s - b * A + c * w - h * z);
            break;
          case 4:
            v = +(a * r + g * z);
            break;
          case 5:
            v = +(a * w + b * z);
            break;
          case 6:
            v = +(a * A + c * z);
            break;
          case 7:
            v = +(a * z);
          }
          return +v;
        },
        rcoE3: function (a, b, c, g, h, k, l, m, n, p, q, s, r, w, A, z, D) {
          b = +b;
          c = +c;
          g = +g;
          h = +h;
          k = +k;
          l = +l;
          m = +m;
          n = +n;
          p = +p;
          q = +q;
          s = +s;
          r = +r;
          w = +w;
          A = +A;
          var v = 0;
          switch (~~(D | 0)) {
          case 0:
            v = +(+a * n + b * p + c * q + g * s - h * r - k * w - l * A - m * +z);
            break;
          case 1:
            v = +(+b * n + h * q - l * s - m * w);
            break;
          case 2:
            v = +(+c * n - h * p + k * s - m * A);
            break;
          case 3:
            v = +(+g * n - k * q + l * p - m * r);
            break;
          case 4:
            v = +(+h * n + m * s);
            break;
          case 5:
            v = +(+k * n + m * p);
            break;
          case 6:
            v = +(+l * n + m * q);
            break;
          case 7:
            v = +(+m * n);
          }
          return +v;
        }
      };
    }('object' === typeof window ? window : void 0, {}, new ArrayBuffer(4096));
  }.call(this));
  (function () {
    this.BLADE = this.BLADE || {};
    this.BLADE.bladeSTR = function () {
      return {
        stringFromCoordinates: function (a, b) {
          var c, d, e, f, g;
          e = [];
          c = function (a, b) {
            var c;
            if (0 !== a) {
              0 <= a ? 0 < e.length && e.push('+') : e.push('-');
              c = Math.abs(a);
              if (1 === c)
                return e.push(b);
              e.push(c.toString());
              if ('1' !== b)
                return e.push('*'), e.push(b);
            }
          };
          d = f = 0;
          for (g = a.length - 1; 0 <= g ? f <= g : f >= g; d = 0 <= g ? ++f : --f)
            c(a[d], b[d]);
          return 0 < e.length ? e.join('') : '0';
        }
      };
    }();
  }.call(this));
  (function () {
    this.BLADE = this.BLADE || {};
    this.BLADE.e2gaASM = function (a, b, c) {
      return {
        add00: function (a, b, c, g, h, k, l, m) {
          return +(+a + +h);
        },
        add01: function (a, b, c, g, h, k, l, m) {
          return +(+b + +k);
        },
        add10: function (a, b, c, g, h, k, l, m) {
          return +(+c + +l);
        },
        add11: function (a, b, c, g, h, k, l, m) {
          return +(+g + +m);
        }
      };
    }('object' === typeof window ? window : void 0, {}, new ArrayBuffer(4096));
  }.call(this));
}());
Sk.builtinFiles = {
  'files': {
    'src/lib/pythonds/trees/binheap.py': '# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n\n# this heap takes key value pairs, we will assume that the keys are integers\nclass BinHeap:\n    def __init__(self):\n        self.heapList = [0]\n        self.currentSize = 0\n\n\n    def buildHeap(self,alist):\n        i = len(alist) // 2\n        self.currentSize = len(alist)\n        self.heapList = [0] + alist[:]\n        print(len(self.heapList), i)\n        while (i > 0):\n            print(self.heapList, i)\n            self.percDown(i)\n            i = i - 1\n        print(self.heapList,i)\n                        \n    def percDown(self,i):\n        while (i * 2) <= self.currentSize:\n            mc = self.minChild(i)\n            if self.heapList[i] > self.heapList[mc]:\n                tmp = self.heapList[i]\n                self.heapList[i] = self.heapList[mc]\n                self.heapList[mc] = tmp\n            i = mc\n                \n    def minChild(self,i):\n        if i * 2 + 1 > self.currentSize:\n            return i * 2\n        else:\n            if self.heapList[i * 2] < self.heapList[i * 2 + 1]:\n                return i * 2\n            else:\n                return i * 2 + 1\n\n    def percUp(self,i):\n        while i // 2 > 0:\n            if self.heapList[i] < self.heapList[i//2]:\n               tmp = self.heapList[i // 2]\n               self.heapList[i // 2] = self.heapList[i]\n               self.heapList[i] = tmp\n            i = i // 2\n \n    def insert(self,k):\n        self.heapList.append(k)\n        self.currentSize = self.currentSize + 1\n        self.percUp(self.currentSize)\n\n    def delMin(self):\n        retval = self.heapList[1]\n        self.heapList[1] = self.heapList[self.currentSize]\n        self.currentSize = self.currentSize - 1\n        self.heapList.pop()\n        self.percDown(1)\n        return retval\n        \n    def isEmpty(self):\n        if currentSize == 0:\n            return True\n        else:\n            return False\n',
    'src/lib/fractions/__init__.js': '/**\n * fractions - Rational numbers\n *\n * David Holmes (david.geo.holmes@gmail.com)\n */\nvar $builtinmodule = function(name) {\n\n  var mod = {};\n\n  var FRACTION = "Fraction";\n\n  Sk.builtin.defineFractions(mod, FRACTION, function(n, d) {return new BLADE.Rational(n, d)});\n\n  return mod;\n};',
    'src/lib/pythonds/basic/stack.py': '# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n#stack.py\r\n\r\nclass Stack:\r\n    def __init__(self):\r\n        self.items = []\r\n\r\n    def isEmpty(self):\r\n        return self.items == []\r\n\r\n    def push(self, item):\r\n        self.items.append(item)\r\n\r\n    def pop(self):\r\n        return self.items.pop()\r\n\r\n    def peek(self):\r\n        return self.items[len(self.items)-1]\r\n\r\n    def size(self):\r\n        return len(self.items)\r\n\r\n',
    'src/lib/pythonds/trees/bst.py': '#!/bin/env python3.1\n# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005, 2010\n# \n\nclass BinarySearchTree:\n    \'\'\'\n    Author:  Brad Miller\n    Date:  1/15/2005\n    Description:  Imlement a binary search tree with the following interface\n                  functions:  \n                  __contains__(y) <==> y in x\n                  __getitem__(y) <==> x[y]\n                  __init__()\n                  __len__() <==> len(x)\n                  __setitem__(k,v) <==> x[k] = v\n                  clear()\n                  get(k)\n                  items() \n                  keys() \n                  values()\n                  put(k,v)\n                  in\n                  del <==> \n    \'\'\'\n\n    def __init__(self):\n        self.root = None\n        self.size = 0\n    \n    def put(self,key,val):\n        if self.root:\n            self._put(key,val,self.root)\n        else:\n            self.root = TreeNode(key,val)\n        self.size = self.size + 1\n\n    def _put(self,key,val,currentNode):\n        if key < currentNode.key:\n            if currentNode.hasLeftChild():\n                self._put(key,val,currentNode.leftChild)\n            else:\n                currentNode.leftChild = TreeNode(key,val,parent=currentNode)\n        else:\n            if currentNode.hasRightChild():\n                self._put(key,val,currentNode.rightChild)\n            else:\n                currentNode.rightChild = TreeNode(key,val,parent=currentNode)\n            \n    def __setitem__(self,k,v):\n        self.put(k,v)\n\n    def get(self,key):\n        if self.root:\n            res = self._get(key,self.root)\n            if res:\n                return res.payload\n            else:\n                return None\n        else:\n            return None\n        \n    def _get(self,key,currentNode):\n        if not currentNode:\n            return None\n        elif currentNode.key == key:\n            return currentNode\n        elif key < currentNode.key:\n            return self._get(key,currentNode.leftChild)\n        else:\n            return self._get(key,currentNode.rightChild)\n            \n        \n    def __getitem__(self,key):\n        res = self.get(key)\n        if res:\n            return res\n        else:\n            raise KeyError(\'Error, key not in tree\')\n            \n\n    def __contains__(self,key):\n        if self._get(key,self.root):\n            return True\n        else:\n            return False\n        \n    def length(self):\n        return self.size\n\n    def __len__(self):\n        return self.size\n\n    def __iter__(self):\n        return self.root.__iter__()\n    \n    def delete(self,key):\n        if self.size > 1:\n            nodeToRemove = self._get(key,self.root)\n            if nodeToRemove:\n                self.remove(nodeToRemove)\n                self.size = self.size-1\n            else:\n                raise KeyError(\'Error, key not in tree\')\n        elif self.size == 1 and self.root.key == key:\n            self.root = None\n            self.size = self.size - 1\n        else:\n            raise KeyError(\'Error, key not in tree\')\n\n    def __delitem__(self,key):\n        self.delete(key)\n    \n    def remove(self,currentNode):\n        if currentNode.isLeaf(): #leaf\n            if currentNode == currentNode.parent.leftChild:\n                currentNode.parent.leftChild = None\n            else:\n                currentNode.parent.rightChild = None\n        elif currentNode.hasBothChildren(): #interior\n            succ = currentNode.findSuccessor()\n            succ.spliceOut()\n            currentNode.key = succ.key\n            currentNode.payload = succ.payload\n        else: # this node has one child\n            if currentNode.hasLeftChild():\n                if currentNode.isLeftChild():\n                    currentNode.leftChild.parent = currentNode.parent\n                    currentNode.parent.leftChild = currentNode.leftChild\n                elif currentNode.isRightChild():\n                    currentNode.leftChild.parent = currentNode.parent\n                    currentNode.parent.rightChild = currentNode.leftChild\n                else:\n                    currentNode.replaceNodeData(currentNode.leftChild.key,\n                                       currentNode.leftChild.payload,\n                                       currentNode.leftChild.leftChild,\n                                       currentNode.leftChild.rightChild)\n            else:\n                if currentNode.isLeftChild():\n                    currentNode.rightChild.parent = currentNode.parent\n                    currentNode.parent.leftChild = currentNode.rightChild\n                elif currentNode.isRightChild():\n                    currentNode.rightChild.parent = currentNode.parent\n                    currentNode.parent.rightChild = currentNode.rightChild\n                else:\n                    currentNode.replaceNodeData(currentNode.rightChild.key,\n                                       currentNode.rightChild.payload,\n                                       currentNode.rightChild.leftChild,\n                                       currentNode.rightChild.rightChild)\n\n    def inorder(self):\n        self._inorder(self.root)\n\n    def _inorder(self,tree):\n        if tree != None:\n            self._inorder(tree.leftChild)\n            print(tree.key)\n            self._inorder(tree.rightChild)\n\n    def postorder(self):\n        self._postorder(self.root)\n\n    def _postorder(self, tree):\n        if tree:\n            self._postorder(tree.rightChild)\n            self._postorder(tree.leftChild)\n            print(tree.key)            \n\n    def preorder(self):\n        self._preorder(self,self.root)\n\n    def _preorder(self,tree):\n        if tree:\n            print(tree.key)            \n            self._preorder(tree.leftChild)\n            self._preorder(tree.rightChild)\n\n                \nclass TreeNode:\n    def __init__(self,key,val,left=None,right=None,parent=None):\n        self.key = key\n        self.payload = val\n        self.leftChild = left\n        self.rightChild = right\n        self.parent = parent\n        self.balanceFactor = 0\n        \n    def hasLeftChild(self):\n        return self.leftChild\n\n    def hasRightChild(self):\n        return self.rightChild\n    \n    def isLeftChild(self):\n        return self.parent and self.parent.leftChild == self\n\n    def isRightChild(self):\n        return self.parent and self.parent.rightChild == self\n\n    def isRoot(self):\n        return not self.parent\n\n    def isLeaf(self):\n        return not (self.rightChild or self.leftChild)\n\n    def hasAnyChildren(self):\n        return self.rightChild or self.leftChild\n\n    def hasBothChildren(self):\n        return self.rightChild and self.leftChild\n    \n    def replaceNodeData(self,key,value,lc,rc):\n        self.key = key\n        self.payload = value\n        self.leftChild = lc\n        self.rightChild = rc\n        if self.hasLeftChild():\n            self.leftChild.parent = self\n        if self.hasRightChild():\n            self.rightChild.parent = self\n        \n    def findSuccessor(self):\n        succ = None\n        if self.hasRightChild():\n            succ = self.rightChild.findMin()\n        else:\n            if self.parent:\n                if self.isLeftChild():\n                    succ = self.parent\n                else:\n                    self.parent.rightChild = None\n                    succ = self.parent.findSuccessor()\n                    self.parent.rightChild = self\n        return succ\n\n\n    def spliceOut(self):\n        if self.isLeaf():\n            if self.isLeftChild():\n                self.parent.leftChild = None\n            else:\n                self.parent.rightChild = None\n        elif self.hasAnyChildren():\n            if self.hasLeftChild():\n                if self.isLeftChild():\n                    self.parent.leftChild = self.leftChild\n                else:\n                    self.parent.rightChild = self.leftChild\n                self.leftChild.parent = self.parent\n            else:\n                if self.isLeftChild():\n                    self.parent.leftChild = self.rightChild\n                else:\n                    self.parent.rightChild = self.rightChild\n                self.rightChild.parent = self.parent\n\n    def findMin(self):\n        current = self\n        while current.hasLeftChild():\n            current = current.leftChild\n        return current\n\n    def __iter__(self):\n        """The standard inorder traversal of a binary tree."""\n        if self:\n            if self.hasLeftChild():\n                for elem in self.leftChild:\n                    yield elem\n            yield self.key\n            if self.hasRightChild():\n                for elem in self.rightChild:\n                    yield elem\n\n            \n',
    'src/lib/time/__init__.js': '\n/*\n\tBarebones implementation of the Python time package.\n\n\tFor now, only the time() function is implemented.\n*/\n \nvar $builtinmodule = function(name)\n{\n    var mod = {};\n\n    mod.time = new Sk.builtin.func(function() {\n\t  return Sk.builtin.assk$(new Date().getTime() / 1000, undefined);\n    });\n\n    return mod;\n}\n',
    'src/lib/image/__init__.js': 'var ImageMod; // the single identifier needed in the global scope\n\nif (! ImageMod) {\n    ImageMod = { };\n    ImageMod.canvasLib = [];\n}\n\n//  todo create an empty image by reading image data from a blank canvas of the appropriate size\n\nvar $builtinmodule = function(name) {\n    var mod = {};\n\n    var image = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self,imageId) {\n            self.image = document.getElementById(imageId.v);\n            if (self.image == null) {\n                throw "There is no image on this page named: " + imageId.v;\n            }\n            self.width = self.image.width;\n            self.height = self.image.height;\n            self.canvas = document.createElement("canvas");\n            self.canvas.height = self.height;\n            self.canvas.width = self.width;\n            self.ctx = self.canvas.getContext("2d");\n            self.ctx.drawImage(self.image,0,0)\n            self.imagedata = self.ctx.getImageData(0,0,self.width,self.height);\n        });\n\n        $loc.getPixel = new Sk.builtin.func(function(self,x,y) {\n\t\t\tx = Sk.builtin.asnum$(x);\n\t\t\ty = Sk.builtin.asnum$(y);\n            var index = (y*4)*self.width+(x*4);\n            var red = self.imagedata.data[index]\n            var green = self.imagedata.data[index+1]\n            var blue = self.imagedata.data[index+2]\n            return Sk.misceval.callsim(mod.Pixel,red,green,blue);\n        });\n\n        $loc.setPixel = new Sk.builtin.func(function(self, x, y, pix) {\n\t\t\tx = Sk.builtin.asnum$(x);\n\t\t\ty = Sk.builtin.asnum$(y);\n            var index = (y*4)*self.width+(x*4);\n            self.imagedata.data[index] = Sk.misceval.callsim(pix.getRed,pix);\n            self.imagedata.data[index+1] = Sk.misceval.callsim(pix.getGreen,pix);\n            self.imagedata.data[index+2] = Sk.misceval.callsim(pix.getBlue,pix);\n            self.imagedata.data[index+3] = 255;\n        });\n\n        $loc.getHeight = new Sk.builtin.func(function(self) {\n            return self.image.height;\n        });\n\n        $loc.getWidth = new Sk.builtin.func(function(self,titlestring) {\n            return self.image.width;\n        });\n\n        $loc.draw = new Sk.builtin.func(function(self,win,ulx,uly) {\n\t\t\twin = Sk.builtin.asnum$(win);\n\t\t\tulx = Sk.builtin.asnum$(ulx);\n\t\t\tuly = Sk.builtin.asnum$(uly);\n            var can = Sk.misceval.callsim(win.getWin,win);\n            var ctx = can.getContext("2d");\n            //ctx.putImageData(self.imagedata,0,0,0,0,self.imagedata.width,self.imagedata.height);\n            if (! ulx) {\n                ulx = 0;\n                uly = 0;\n            }\n            ctx.putImageData(self.imagedata,ulx,uly);\n        });\n\n        // toList\n\n    }\n\n    mod.Image = Sk.misceval.buildClass(mod, image, \'Image\', []);\n\n    var eImage = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self,width,height) {\n            self.width = Sk.builtin.asnum$(width);\n            self.height = Sk.builtin.asnum$(height);\n            self.canvas = document.createElement("canvas");\n            self.ctx = self.canvas.getContext(\'2d\');\n            self.canvas.height = self.height;\n            self.canvas.width = self.width;\n            self.imagedata = self.ctx.getImageData(0,0,self.width,self.height);\n        });\n\n    }\n\n    mod.EmptyImage = Sk.misceval.buildClass(mod, eImage, \'EmptyImage\', [mod.Image]);\n\n    // create a ListImage object\n\n    \n    var pixel = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self,r,g,b) {\n            self.red = Sk.builtin.asnum$(r);\n            self.green = Sk.builtin.asnum$(g);\n            self.blue = Sk.builtin.asnum$(b);\n        });\n\n        $loc.getRed = new Sk.builtin.func(function(self) {\n           return self.red;\n        });\n\n        $loc.getGreen = new Sk.builtin.func(function(self) {\n           return self.green;\n        });\n\n        $loc.getBlue = new Sk.builtin.func(function(self) {\n           return self.blue;\n        });\n\n        $loc.setRed = new Sk.builtin.func(function(self,r) {\n           self.red = Sk.builtin.asnum$(r);\n        });\n\n        $loc.setGreen = new Sk.builtin.func(function(self,g) {\n           self.green = Sk.builtin.asnum$(g);\n        });\n\n        $loc.setBlue = new Sk.builtin.func(function(self,b) {\n           self.blue = Sk.builtin.asnum$(b);\n        });\n\n        $loc.__getitem__ = new Sk.builtin.func(function(self,k) {\n\t\t   k = Sk.builtin.asnum$(k);\n           if(k == 0) {\n               return self.red;\n           } else if (k == 1) {\n               return self.green;\n           } else if (k == 2) {\n               return self.blue;\n           }\n        });\n\n        $loc.__str__ = new Sk.builtin.func(function(self) {\n            return "[" + self.red + "," + self.green + "," + self.blue + "]"\n        });\n        \n        //getColorTuple\n        $loc.getColorTuple = new Sk.builtin.func(function(self,x,y) {\n\n        });\n\n        //setRange -- change from 0..255 to 0.0 .. 1.0\n        $loc.setRange = new Sk.builtin.func(function(self,mx) {\n            self.max = Sk.builtin.asnum$(mx);\n        });\n\n    }\n    mod.Pixel = Sk.misceval.buildClass(mod, pixel, \'Pixel\', []);\n\n\n\n    var screen = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self,width,height) {\n            var currentCanvas = ImageMod.canvasLib[Sk.canvas];\n            if (currentCanvas === undefined) {\n                self.theScreen = document.getElementById(Sk.canvas);\n                if (width !== undefined) {\n                    self.theScreen.height = height;\n                    self.theScreen.width = width;\n                }\n\n                ImageMod.canvasLib[Sk.canvas] = self.theScreen;\n            } else {\n                self.theScreen = currentCanvas;\n                self.theScreen.height = self.theScreen.height;\n            }\n            self.theScreen.style.display = "block";\n        });\n\n        $loc.getWin = new Sk.builtin.func(function(self) {\n           return self.theScreen;\n        });\n\n        // exitonclick\n        $loc.exitonclick = new Sk.builtin.func(function(self) {\n            var canvas_id = self.theScreen.id;\n            self.theScreen.onclick = function() {\n                document.getElementById(canvas_id).style.display = \'none\';\n                document.getElementById(canvas_id).onclick = null;\n                delete ImageMod.canvasLib[canvas_id];\n            }\n\n        });\n        //getMouse\n    }\n\n    mod.ImageWin = Sk.misceval.buildClass(mod, screen, \'ImageWin\', []);\n\n    return mod\n}\n',
    'src/lib/browser/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n\n  var DOCUMENT_CLASS           = \'Document\';\n  var EVENT                    = \'Event\';\n  var NODE                     = \'Node\';\n  var WINDOW_CLASS             = \'Window\';\n  var WINDOW_ANIMATION_RUNNER  = \'WindowAnimationRunner\';\n  var WORKBENCH                = \'Workbench\';\n  var METHOD_START             = \'start\';\n\n  Sk.builtin.defineEvent(mod);\n\n  Sk.builtin.defineNode(mod);\n\n  mod[\'window\'] = Sk.ffi.callsim(Sk.builtin.buildWindowClass(mod), Sk.ffi.referenceToPy(window, WINDOW_CLASS));\n\n  mod[\'document\'] = Sk.ffi.callsim(Sk.builtin.buildDocumentClass(mod), Sk.ffi.referenceToPy(document, DOCUMENT_CLASS));\n\n  mod[WINDOW_ANIMATION_RUNNER] = Sk.ffi.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = Sk.ffi.functionPy(function(selfPy, tickPy, terminatePy, setUpPy, tearDownPy) {\n      Sk.ffi.checkMethodArgs(WINDOW_ANIMATION_RUNNER, arguments, 4, 4);\n      Sk.ffi.checkArgType("tick",      Sk.ffi.PyType.FUNCTION, Sk.ffi.isFunction(tickPy));\n      Sk.ffi.checkArgType("terminate", Sk.ffi.PyType.FUNCTION, Sk.ffi.isFunction(terminatePy));\n      Sk.ffi.checkArgType("setUp",     Sk.ffi.PyType.FUNCTION, Sk.ffi.isFunction(setUpPy));\n      Sk.ffi.checkArgType("tearDown",  Sk.ffi.PyType.FUNCTION, Sk.ffi.isFunction(tearDownPy));\n      var onDocumentKeyDown = function(event) {\n        if (event.keyCode == 27) {\n          var war = Sk.ffi.remapToJs(selfPy);\n          war.escKeyPressed = true;\n          event.preventDefault();\n        }\n      };\n      var WindowAnimationRunner = function() {\n        this.tick      = Sk.ffi.remapToJs(tickPy);\n        this.terminate = Sk.ffi.remapToJs(terminatePy);\n        this.setUp     = Sk.ffi.remapToJs(setUpPy);\n        this.tearDown  = Sk.ffi.remapToJs(tearDownPy);\n        this.startTime = null;\n        this.elapsed   = null;\n        this.requestID = null;\n        this.escKeyPressed = false;\n      };\n      WindowAnimationRunner.prototype = {\n        constructor: WindowAnimationRunner,\n        start: function() {\n          var war = this;\n          war.setUp();\n          document.addEventListener(\'keydown\', onDocumentKeyDown, false);\n          var animate = function(timestamp) {\n            if (war.startTime) {\n              war.elapsed = timestamp - war.startTime;\n            }\n            else {\n              if (timestamp) {\n                war.startTime = timestamp;\n              }\n              else {\n                war.elapsed = 0;\n              }\n            }\n            if (war.escKeyPressed || war.terminate(war.elapsed / 1000)) {\n              window.cancelAnimationFrame(war.requestID);\n              document.removeEventListener(\'keydown\', onDocumentKeyDown, false);\n              war.tearDown();\n            }\n            else {\n              war.requestID = window.requestAnimationFrame(animate);\n              war.tick(war.elapsed / 1000);\n            }\n          };\n          animate(null);\n        },\n        toString: function() {\n          return WINDOW_ANIMATION_RUNNER;\n        }\n      };\n      Sk.ffi.referenceToPy(new WindowAnimationRunner(), WINDOW_ANIMATION_RUNNER, undefined, selfPy);\n    });\n    $loc.__getattr__ = Sk.ffi.functionPy(function(selfPy, name) {\n      var war = Sk.ffi.remapToJs(selfPy);\n      switch(name) {\n        case METHOD_START: {\n          return Sk.ffi.callableToPy(mod, METHOD_START, function(methodPy) {\n            Sk.ffi.checkMethodArgs(METHOD_START, arguments, 0, 0);\n            war.start();\n          });\n        }\n      }\n    });\n    $loc.__str__ = Sk.ffi.functionPy(function(selfPy) {\n      return Sk.ffi.stringToPy(WINDOW_ANIMATION_RUNNER);\n    });\n    $loc.__repr__ = Sk.ffi.functionPy(function(selfPy) {\n      return Sk.ffi.stringToPy(WINDOW_ANIMATION_RUNNER + "(" + ")");\n    });\n  }, WINDOW_ANIMATION_RUNNER, []);\n\n  return mod;\n}\n',
    'src/lib/units/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineUnits(mod, BLADE);\n  return mod;\n};',
    'src/lib/pythonds/basic/__init__.py': '\n#__all__ = ["stack"]\n\n\n#from .stack import Stack\n#from .queue import Queue\n\n\n\n',
    'src/lib/geometry/__init__.js': 'var $builtinmodule = function(moduleNamePy) {\n  var mod = {};\n  Sk.stdlib.defineThree(mod, BLADE);\n  Sk.builtin.defineGeometry(mod, THREE, Sk.ffi.remapToJs(moduleNamePy));\n  Sk.builtin.defineProbeE3(mod, THREE);\n  return mod;\n}\n',
    'src/lib/sprite/__init__.js': '//\n//\n// Sprite Graphics Module for DaVinci.\n//\n// Based on the turtle module by Brad Miller.\n//\n// Dependencies:\n//   jQuery\n//\n//\n\nvar SpriteGraphics; // the single identifier needed in the global scope\n\nif (! SpriteGraphics) {\n  SpriteGraphics = {};\n}\n\n\n(function () {\n\n  var Degree2Rad = Math.PI / 180.0; // conversion factor for degrees to radians.\n  var Rad2Degree = 180.0 / Math.PI; // conversion factor for radians to degrees.\n\n  function SpriteCanvas(options) {\n    this.canvasID = SpriteGraphics.defaults.canvasID;\n    if (options.canvasID) {\n      this.canvasID = options.canvasID;\n    }\n\n    this.canvas = document.getElementById(this.canvasID);\n    this.context = this.canvas.getContext(\'2d\');\n    $(this.canvas).fadeIn();\n\n    this.lineScale = 1.0;\n    this.xptscale = 1.0;\n    this.yptscale = 1.0;\n\n    this.llx = -this.canvas.width / 2;\n    this.lly = -this.canvas.height / 2;\n    this.urx = this.canvas.width / 2;\n    this.ury = this.canvas.height / 2;\n    this.setup(this.canvas.width,this.canvas.height);\n    SpriteGraphics.canvasInit = true;\n    this.tlist = []\n\n    this.timeFactor = 5;\n    if (SpriteGraphics.defaults.animate) {\n      this.delay = 5 * this.timeFactor;\n    }\n    else {\n      this.delay = 0;\n    }\n    this.segmentLength = 10;\n    this.renderCounter = 1;\n    this.clearPoint = 0;\n    SpriteGraphics.canvasLib[this.canvasID] = this;\n    //  This can be set to false AFTER the program completes to turn off the fade out on the canvas as a result of exitonclick\n    Sk.tg.fadeOnExit = true;\n  }\n\n  SpriteCanvas.prototype.setup = function(width, height) {\n    this.canvas.width = width;\n    this.canvas.height = height;\n    this.lineScale = 1.0;\n    this.xptscale = 1.0;\n    this.yptscale = 1.0;\n\n    this.llx = -this.canvas.width / 2;\n    this.lly = -this.canvas.height / 2;\n    this.urx = this.canvas.width / 2;\n    this.ury = this.canvas.height / 2;\n    this.renderCounter = 1;\n    this.clearPoint = 0;\n    this.timeFactor = 5;\n    if (SpriteGraphics.defaults.animate) {\n      this.delay = 5 * this.timeFactor;\n    }\n    else {\n      this.delay = 0;\n    }\n\n    if (SpriteGraphics.canvasInit == false) {\n      this.context.save();\n      this.context.translate(this.canvas.width / 2, this.canvas.height / 2); // move 0,0 to center.\n      this.context.scale(1, -1); // scaling like this flips the y axis the right way.\n      SpriteGraphics.canvasInit = true;\n      SpriteGraphics.eventCount = 0;\n      SpriteGraphics.renderClock = 0;\n      SpriteGraphics.renderTime = 0;\n    }\n    else {\n      this.context.restore();\n      this.context.translate(this.canvas.width / 2, this.canvas.height / 2); // move 0,0 to center.\n      this.context.scale(1, -1); // scaling like this flips the y axis the right way.\n      this.context.clearRect(-this.canvas.width / 2, -this.canvas.height / 2, this.canvas.width, this.canvas.height);\n    }\n  }\n\n  SpriteCanvas.prototype.addToCanvas = function(t) {\n    this.tlist.push(t);\n  }\n\n  SpriteCanvas.prototype.onCanvas = function(t) {\n    return (this.tlist.indexOf(t) >= 0);\n  }\n\n  SpriteCanvas.prototype.isAnimating = function() {\n    return (this.tlist.length > 0);\n  }\n\n  SpriteCanvas.prototype.startAnimating = function(t) {\n    if (! this.isAnimating()) {\n      this.intervalId = setTimeout(render, this.delay);\n    }\n    // Added in case startAnimating is called after it\'s already been added.\n    if (!this.onCanvas(t)) {\n      this.addToCanvas(t);\n    }\n    Sk.isSpriteProgram = true;\n  }\n\n  SpriteCanvas.prototype.doneAnimating = function(t) {\n    this.tlist.splice(0,this.tlist.length);\n    clearTimeout(this.intervalId);\n    $(Sk.runButton).removeAttr(\'disabled\');\n  }\n\n  SpriteCanvas.prototype.cancelAnimation = function() {\n    if (this.intervalId) {\n      clearTimeout(this.intervalId);\n    }\n\n    for (var t in this.tlist) {\n      this.tlist[t].aCount = this.tlist[t].drawingEvents.length - 1;\n    }\n    render();\n  }\n\n  SpriteCanvas.prototype.setSpeedDelay = function(s) {\n    var df = 10 - (s % 11) + 1;\n    this.delay = df * this.timeFactor;\n  }\n\n  SpriteCanvas.prototype.setDelay = function(d) {\n    this.delay = d;\n  }\n\n  SpriteCanvas.prototype.getDelay = function(s) {\n    return this.delay;\n  }\n\n  SpriteCanvas.prototype.setCounter = function(s) {\n    if (!s || s <= 0) {\n      s = 1;\n    }\n    this.renderCounter = s;\n  }\n\n  SpriteCanvas.prototype.getCounter = function() {\n    return this.renderCounter;\n  }\n\n  SpriteCanvas.prototype.setworldcoordinates = function(llx, lly, urx, ury) {\n    this.context.restore();\n    this.context.scale(this.canvas.width / (urx - llx), -this.canvas.height / (ury - lly));\n    if (lly == 0) {\n      this.context.translate(-llx, lly - (ury - lly));\n    }\n    else if (lly > 0) {\n      this.context.translate(-llx, -lly * 2);\n    }\n    else {\n      this.context.translate(-llx, -ury);\n    }\n\n    var xlinescale = (urx - llx) / this.canvas.width;\n    var ylinescale = (ury - lly) / this.canvas.height;\n    this.xptscale = xlinescale;\n    this.yptscale = ylinescale;\n    this.lineScale = Math.min(xlinescale,ylinescale);\n    this.context.save();\n\n    this.llx = llx;\n    this.lly = lly;\n    this.urx = urx;\n    this.ury = ury;\n\n  }\n\n  SpriteCanvas.prototype.window_width = function() {\n    return this.canvas.width;\n  }\n\n  SpriteCanvas.prototype.window_height = function() {\n    return this.canvas.height;\n  }\n\n  SpriteCanvas.prototype.bgcolor = function(c) {\n    this.background_color = c;\n    $(this.canvas).css("background-color",c.v);\n  }\n\n  SpriteCanvas.prototype.setSegmentLength = function(s) {\n    this.segmentLength = s;\n  }\n\n  SpriteCanvas.prototype.getSegmentLength = function() {\n    return this.segmentLength;\n  }\n\n  // todo: if animating, this should be deferred until the proper time\n  SpriteCanvas.prototype.exitonclick = function () {\n    var canvas_id = this.canvasID;\n    var theCanvas = this;\n    $(this.canvas).click(function() {\n      if (! theCanvas.isAnimating()) {\n        if (Sk.tg.fadeOnExit) {\n         $("#"+canvas_id).hide();\n       }\n       $("#"+canvas_id).unbind(\'click\');\n       Sk.tg.canvasInit = false;\n       delete Sk.tg.canvasLib[canvas_id];\n     }\n   });\n  }\n\n  SpriteCanvas.prototype.sprites = function() {\n    return SpriteGraphics.spriteList;\n  }\n\n /**\n  * New version NOT attached to a sprite (as per real sprite)\n  */\n  SpriteCanvas.prototype.tracer = function(t, d) {\n    this.setCounter(t);\n    if (t == 0) {\n      for (var i in this.spriteList) {\n        this.spriteList[i].animate = false;\n      }\n      this.cancelAnimation();\n    }\n    if (d !== undefined) {\n      this.setDelay(d);\n    }\n  }\n\n  // check if all sprites are done\n  allDone = function() {\n    var allDone = true;\n    for (var tix in SpriteGraphics.spriteList) {\n      var theT = SpriteGraphics.spriteList[tix];\n      allDone = allDone && (theT.aCount >= theT.drawingEvents.length);\n    }\n    return allDone;\n  }\n\n  //\n  //  This is the function that provides the animation\n  //\n  render = function () {\n    var context = document.getElementById(SpriteGraphics.defaults.canvasID).getContext(\'2d\');\n    with (context) {\n      with (SpriteGraphics.canvasLib[SpriteGraphics.defaults.canvasID]) {\n        clearRect(llx, lly, (urx - llx), (ury - lly));\n      }\n      var incr = SpriteGraphics.canvasLib[SpriteGraphics.defaults.canvasID].getCounter();\n      var lastCanvas = null;\n\n      SpriteGraphics.renderClock += incr;\n\n      for (var tix in SpriteGraphics.spriteList) {\n        var t = SpriteGraphics.spriteList[tix]\n        lastCanvas = t.spriteCanvas \n        if (t.aCount >= t.drawingEvents.length) {\n          t.aCount = t.drawingEvents.length - 1;\n        }\n        moveTo(0, 0);\n        var currentPos = new Vector(0,0,0);\n        var currentHead = new Vector(1,0,0);\n        lineWidth = t.get_pen_width();\n        lineCap = \'round\';\n        lineJoin = \'round\';\n        strokeStyle = \'black\';\n        var filling = false;\n        if (isNaN(t.spriteCanvas.delay)) {\n          t.spriteCanvas.delay = 0\n        }\n        for (var i = t.clearPoint; (i <= t.aCount || t.spriteCanvas.delay == 0) && i < t.drawingEvents.length; i++) {\n          if (i > t.aCount) {\n            // If se jump past aCount, jump it ahead\n            t.aCount = i\n          }\n          var oper = t.drawingEvents[i];\n          var ts = oper[oper.length-1];\n          if (ts <= SpriteGraphics.renderClock || t.spriteCanvas.delay == 0) {\n            if (ts > SpriteGraphics.renderClock) {\n              // If we go past the render clock, jump it ahead\n              SpriteGraphics.renderClock = ts\n            }\n            if (oper[0] == "LT") {  //  line to\n              if (! filling) {\n                beginPath();\n                moveTo(oper[1], oper[2]);\n              }\n              lineTo(oper[3], oper[4]);\n              strokeStyle = oper[5];\n              stroke();\n              currentPos = new Vector(oper[3],oper[4],0);\n              if (! filling)\n                closePath();\n            }\n            else if (oper[0] == "MT") {  // move to\n              moveTo(oper[3], oper[4]);\n              currentPos = new Vector(oper[3],oper[4],0);\n            }\n            else if (oper[0] == "BF") {  // begin fill\n              beginPath();\n              moveTo(oper[1], oper[2]);\n              filling = true;\n            }\n            else if (oper[0] == "EF") {  // end fill\n              fillStyle = oper[3];\n              stroke();\n              fill();\n              closePath();\n              filling = false;\n            }\n            else if (oper[0] == "FC") {  // fill color\n              fillStyle = oper[1];\n            }\n            else if (oper[0] == "TC") {  // sprite color\n              strokeStyle = oper[1];\n            }\n            else if (oper[0] == "PW") {  // Pen width\n              lineWidth = oper[1];\n            }\n            else if (oper[0] == "DT") {  // Dot\n              var col = fillStyle;\n              fillStyle = oper[2];\n              var size = oper[1];\n              fillRect(oper[3] - size / 2, oper[4] - size / 2, size, size);\n              fillStyle = col;\n            }\n            else if (oper[0] == "CI") {  // Circle\n              if (!filling)\n                beginPath();\n              arc(oper[1], oper[2], oper[3], oper[4], oper[5], oper[6]);\n              currentPos = new Vector(oper[1]+Sk.math.cos(oper[5])*oper[3],\n                oper[2]+Sk.math.sin(oper[5])*oper[3],0);\n              stroke();\n              if (! filling) {\n                closePath();\n              }\n            }\n            else if (oper[0] == "WT") { // write\n              if (font)\n                font = oper[2];\n              scale(1, -1);\n              fillText(oper[1], oper[3], -oper[4]);\n              scale(1, -1);\n            } else if (oper[0] == "ST") {  // stamp\n              t.drawSprite(oper[3], new Vector(oper[1], oper[2], 0));\n            } else if (oper[0] == "HT") { // hide sprite\n              t.visible = false;\n            } else if (oper[0] == "SH") { // show sprite\n              t.visible = true;\n            } else if (oper[0] == "TT") {\n              currentHead = oper[1];\n            } else if (oper[0] == "CL") { // RNL clear\n              clear_canvas(t.canvasID);\n              t.clearPoint = i; // Different from reset that calls clear because it leaves the sprites where they are\n            } else if (oper[0] == "DL") { // RNL delay\n              var df = oper[1];\n              t.spriteCanvas.delay = df\n            } else if (oper[0] == "SC") { // RNL speed change\n              var s = oper[1]\n              if (s < 0)\n                s = 0\n              if (s > 10)\n                s = 10\n              var df = (10 - (s % 11) + 1) * t.spriteCanvas.timeFactor  //  10\n              if (s == 0) {\n                df = 0\n              }\n              // t.spriteCanvas.intervalId = clearInterval(t.spriteCanvas.intervalId);\n              t.spriteCanvas.delay = df;\n              // t.spriteCanvas.intervalId = setInterval(render, t.spriteCanvas.delay)\n              if (oper[2]) {\n                t.spriteCanvas.setSegmentLength(oper[2]);\n              }\n            } else if (oper[0] == "NO") {\n              // RNL no op\n            } else {\n            } // end of oper[0] test\n          } // end of if ts < render clock\n        } // end of for\n        t.aCount += incr;\n        if (t.visible) {\n          // draw the sprite\n          t.drawSprite(currentHead.toAngle(), currentPos); // just use currentHead\n        }\n      }\n      // if (t.aCount >= t.drawingEvents.length) {\n      if (SpriteGraphics.renderClock > SpriteGraphics.eventCount ){ // && allDone() ){\n        // t.spriteCanvas.doneAnimating(t);\n        if (lastCanvas) lastCanvas.doneAnimating(t);\n      }\n      else {\n        // t.spriteCanvas.intervalId = setTimeout(render, t.spriteCanvas.delay)\n        if (lastCanvas) {\n          lastCanvas.intervalId = setTimeout(render, lastCanvas.delay)\n        }\n      }\n    }\n  }\n\n  // Constructor for Sprite objects\n  function Sprite() {\n    if (arguments.length >= 1) {\n      this.initialize(arguments[0]);\n    }\n    else {\n      this.initialize();\n    }\n    SpriteGraphics.spriteList.push(this);\n  }\n\n  Sprite.prototype.go_home = function () {\n    // Put sprite in initial state\n    // sprite is headed to the right\n    // with position 0,0,0 in the middle of the canvas.\n    // x grows to the right\n    // y grows towards the top of the canvas\n    with (this) {\n      position = home;\n      context.moveTo(home[0], home[1]);\n      heading = new Vector([1.0, 0.0, 0.0]); // to the right; in sprite space x+ direction\n      normal = new Vector([0.0, 0.0, -1.0]); // in z- direction\n    }\n  };\n\n  Sprite.prototype.initialize = function () {\n    // Initialize the sprite.\n    var options = { };\n\n    if (arguments.length >= 1) {\n      options = arguments[0];\n    }\n\n    this.canvasID = SpriteGraphics.defaults.canvasID;\n    if (options.canvasID) {\n      this.canvasID = options.canvasID;\n    }\n    this.context = document.getElementById(this.canvasID).getContext(\'2d\');\n\n    this.animate = SpriteGraphics.defaults.animate;\n\n    with (this.context) {\n      if (SpriteGraphics.canvasInit == false) {\n        save();\n        translate(canvas.width / 2, canvas.height / 2); // move 0,0 to center.\n        scale(1, -1); // scaling like this flips the y axis the right way.\n        if (! SpriteGraphics.canvasLib[this.canvasID]) {\n          SpriteGraphics.canvasLib[this.canvasID] = new SpriteCanvas(options);\n        }\n        SpriteGraphics.canvasInit = true;\n      }\n      else {\n        clear_canvas(this.canvasID);\n      }\n\n      this.spriteCanvas = SpriteGraphics.canvasLib[this.canvasID];\n      this.home = new Vector([0.0, 0.0, 0.0]);\n      this.visible = true;\n      this.shapeStore = {};\n      this.shapeStore[\'turtle\'] = turtleShapePoints();\n      this.shapeStore[\'arrow\'] = defaultShapePoints();\n      this.shapeStore[\'circle\'] = circleShapePoints();\n      this.shapeStore[\'classic\'] = classicShapePoints();\n      this.currentShape = \'classic\';\n      this.drawingEvents = [];\n\n      this.filling = false;\n      this.pen = true;\n      this.penStyle = \'black\';\n      this.penWidth = 2;\n      this.fillStyle = \'black\';\n      this.position = [ ];\n      this.heading = [ ];\n      this.normal = [ ];\n      this.go_home();\n      this.aCount = 0;\n      this.clearPoint = 0;\n    }\n  }\n\n  function turtleShapePoints() {\n    var pl = [\n    [0,16],\n    [-2,14],\n    [-1,10],\n    [-4,7],\n    [-7,9],\n    [-9,8],\n    [-6,5],\n    [-7,1],\n    [-5,-3],\n    [-8,-6],\n    [-6,-8],\n    [-4,-5],\n    [0,-7],\n    [4,-5],\n    [6,-8],\n    [8,-6],\n    [5,-3],\n    [7,1],\n    [6,5],\n    [9,8],\n    [7,9],\n    [4,7],\n    [1,10],\n    [2,14]\n    ];\n    res = [];\n    for (p in pl) {\n      res.push(new Vector(pl[p]));\n    }\n    return res;\n  }\n\n  function defaultShapePoints() {\n    var pl = [\n    [-10,0],\n    [10,0],\n    [0,10]\n    ];\n    res = [];\n    for (p in pl) {\n      res.push(new Vector(pl[p]));\n    }\n    return res;\n  }\n\n  function circleShapePoints() {\n    var pl = [\n    [10,0],\n    [9.51,3.09],\n    [8.09,5.88],\n    [5.88,8.09],\n    [3.09,9.51],\n    [0,10],\n    [-3.09,9.51],\n    [-5.88,8.09],\n    [-8.09,5.88],\n    [-9.51,3.09],\n    [-10,0],\n    [-9.51,-3.09],\n    [-8.09,-5.88],\n    [-5.88,-8.09],\n    [-3.09,-9.51],\n    [-0.00,-10.00],\n    [3.09,-9.51],\n    [5.88,-8.09],\n    [8.09,-5.88],\n    [9.51,-3.09]\n    ];\n    res = [];\n    for (p in pl) {\n      res.push(new Vector(pl[p]));\n    }\n    return res;\n  }\n\n  function classicShapePoints() {\n    var pl = [\n    [0,0],\n    [-5,-9],\n    [0,-7],\n    [5,-9]\n    ];\n    res = [];\n    for (p in pl) {\n      res.push(new Vector(pl[p]));\n    }\n    return res;\n  }\n\n  Sprite.prototype.clean = function () {\n    // Clean the canvas\n    // Optional second argument is color\n    with (this) {\n      if (arguments.length >= 1) {\n        clear_canvas(canvasID, arguments[0]);\n      }\n      else {\n        clear_canvas(canvasID);\n      }\n      initialize();\n    }\n  }\n\n  Sprite.prototype.addDrawingEvent = function(eventList) {\n    SpriteGraphics.eventCount += 1;\n    eventList.push(SpriteGraphics.eventCount);\n    this.drawingEvents.push(eventList);\n  }\n\n  //  \n  //  Drawing Functions\n  //\n\n    // break a line into segments\n    // sp:  Vector of starting position\n    // ep:  Vector of ending position\n    // sl:  int length of segments\n    segmentLine = function(sp, ep, sL, pen) {\n      var head = ep.sub(sp).normalize();\n      var numSegs = Math.floor(ep.sub(sp).len() / sL);\n      var res = [];\n      var oldp = sp;\n      var newp;\n      var op = ""\n      if (pen)\n        op = "LT"\n      else\n        op = "MT"\n      for (var i = 0; i < numSegs; i++) {\n        newp = oldp.linear(1, sL, head);\n        res.push([op,oldp[0],oldp[1],newp[0],newp[1]]);\n        oldp = newp;\n      }\n      if (! ((oldp[0] == ep[0]) && (oldp[1] == ep[1])))\n        res.push([op, oldp[0], oldp[1], ep[0], ep[1]]);\n      return res;\n    }\n\n    Sprite.prototype.draw_line = function(newposition) {\n      with (this) {\n        with (context) {\n          if (! animate) {\n            if (! filling) {\n              beginPath();\n              moveTo(position[0], position[1]);\n            }\n            lineCap = \'round\';\n            lineJoin = \'round\';\n            lineWidth = get_pen_width();\n            strokeStyle = penStyle;\n            lineTo(newposition[0], newposition[1]);\n            stroke();\n            if (! filling)\n              closePath();\n          } else {\n            var r = segmentLine(position, newposition, spriteCanvas.getSegmentLength(), pen);\n            for (var s in r) {\n              r[s].push(penStyle);\n              addDrawingEvent(r[s]);\n            }\n            if (! spriteCanvas.isAnimating()) {\n              spriteCanvas.startAnimating(this);\n            } else {\n              if (! spriteCanvas.onCanvas(this))\n                spriteCanvas.addToCanvas(this);\n            }\n          }\n        }\n      }\n    }\n\n    Sprite.prototype.forward = function (d) {\n      with (this) {\n        var newposition = position.linear(1, d, heading);\n        goto(newposition);\n      }\n    }\n\n    Sprite.prototype.backward = function(d) {\n      this.forward(-d);\n    }\n\n    // This is an internal function that sets the position without doing any drawing\n    Sprite.prototype.teleport_to = function(nx, ny) {\n      if (nx instanceof Vector)\n        var newposition = nx;\n      else\n        var newposition = new Vector([nx,ny,0]);\n      this.context.moveTo(newposition[0], newposition[1]);\n      this.position = newposition;\n    }\n\n    Sprite.prototype.goto = function(nx, ny) {\n      if (nx instanceof Vector)\n        var newposition = nx;\n      else\n        var newposition = new Vector([nx,ny,0]);\n      with (this) {\n        if (pen) {\n          draw_line(newposition);\n        } else {\n          if (! animate) {\n            context.moveTo(newposition[0], newposition[1]);\n          } else {\n            var r = segmentLine(position, newposition, spriteCanvas.getSegmentLength(), pen);\n            for (var s in r)\n              addDrawingEvent(r[s]);\n            if (! spriteCanvas.isAnimating()) {\n              spriteCanvas.startAnimating(this);\n            } else {\n              if (! spriteCanvas.onCanvas(this))\n                spriteCanvas.addToCanvas(this);\n            }\n          }\n        }\n        position = newposition;\n      }\n    }\n\n    Sprite.prototype.delay = function(d) {\n      if (d != null) {\n        if (d < 0) {\n          d = -d;\n        }\n        if (!this.animate) {\n          this.spriteCanvas.setDelay(d);\n        } \n        else {\n          this.spriteCanvas.setDelay(d);\n          this.addDrawingEvent(["DL", d]);\n          this.addDrawingEvent(["NO"]);\n        }\n      }\n      return this.spriteCanvas.getDelay();\n    }\n\n    Sprite.prototype.speed = function(s,t) {\n      if (s > 0 && !this.animate) {\n        this.animate = true;\n        this.spriteCanvas.setSpeedDelay(s);\n      }\n      else if (s == 0 && !this.animate) {\n        this.spriteCanvas.setSpeedDelay(s);\n      }\n      else {\n        // this.animate = false;\n        // this.spriteCanvas.cancelAnimation();\n        this.addDrawingEvent(["SC", s, t]);\n        this.addDrawingEvent(["NO"]);\n      }\n      if (t) {\n        this.spriteCanvas.setSegmentLength(t);\n        // set the number of units to divide a segment into\n      }\n      else {\n        this.spriteCanvas.setSegmentLength(10);\n      }\n    }\n\n    Sprite.prototype.tracer = function(t, d) {\n      this.spriteCanvas.setCounter(t);\n      if (t == 0) {\n       this.animate=false;\n       this.spriteCanvas.cancelAnimation();\n     }\n     if (d !== undefined)\n       this.spriteCanvas.setDelay(d);\n   }\n\n   Sprite.prototype.getRenderCounter = function() {\n    return this.spriteCanvas.getCounter();\n  }\n\n  Sprite.prototype.turn = function (phi) {\n    with (this) {\n      var alpha = phi * Degree2Rad;\n      var left = normal.cross(heading);\n      var newheading = heading.rotateNormal(left, normal, alpha);\n      heading = newheading;\n\n      if (animate) {\n        addDrawingEvent(["TT",heading]);\n      }\n    }\n  }\n\n  Sprite.prototype.right = Sprite.prototype.turn;\n\n  Sprite.prototype.left = function(phi) {\n    this.turn(-phi);\n  }\n\n  Sprite.prototype.get_heading = function () {\n    if (SpriteGraphics.defaults.degrees)\n      return this.heading.toAngle()\n    else\n      return this.heading\n  }\n\n  Sprite.prototype.get_position = function () {\n    return this.position;\n  }\n\n  Sprite.prototype.getx = function () {\n    return this.position[0];\n  }\n\n  Sprite.prototype.gety = function () {\n    return this.position[1];\n  }\n\n  Sprite.prototype.set_heading = function(newhead) {\n    if ((typeof(newhead)).toLowerCase() === \'number\') {\n      this.heading = Vector.angle2vec(newhead);\n    } else {\n      this.heading = newhead;\n    }\n  }\n\n  Sprite.prototype.towards = function(to, y) {\n    // set heading vector to point towards another point.\n    if ((typeof(to)).toLowerCase() === \'number\')\n      to = new Vector(to, y, 0);\n    else if (! (to instanceof Vector)) {\n      to = new Vector(to);\n    }\n    var res = to.sub(this.position);\n    res = res.normalize();\n    if (SpriteGraphics.defaults.degrees)\n      return res.toAngle();\n    else\n      return res;\n  }\n\n  Sprite.prototype.distance = function(to, y) {\n    if ((typeof(to)).toLowerCase() === \'number\')\n      to = new Vector(to, y, 0);\n    return this.position.sub(new Vector(to)).len();\n  }\n\n  Sprite.prototype.dot = function() {\n    var size = 2;\n    if (arguments.length >= 1) size = arguments[0];\n    size = size * this.spriteCanvas.lineScale;\n    with (this) {\n      with (context) {\n        var color = penStyle;\n        var nc = arguments[1] || color;\n        if (! animate) {\n          fillStyle = nc;\n          fillRect(position[0] - size / 2, position[1] - size / 2, size, size);\n          fillStyle = color;\n        } else {\n          addDrawingEvent(["DT", size, nc, position[0], position[1]]);\n        }\n      }\n    }\n  }\n\n  Sprite.prototype.circle = function(radius, extent) {\n    if (extent === undefined) {\n      extent = 360\n    }\n    if (this.animate) {\n     var arcLen = Math.abs(radius * Math.PI * 2.0  * extent / 360);\n     var segLen = this.spriteCanvas.getSegmentLength();\n     if (arcLen <= segLen)\n      this.arc(radius,extent);\n    else {\n        //  Break the arc into segments for animation\n        var extentPart = (segLen / arcLen) * extent;\n        var extentLeft = extent;\n        while (Math.abs(extentLeft) > Math.abs(extentPart)) {\n          this.arc(radius, extentPart);\n          extentLeft = extentLeft - extentPart;\n        }\n        if (Math.abs(extentLeft) > 0.01)\n          this.arc(radius, extentLeft);\n      }\n    } else {\n      this.arc(radius,extent);\n    }\n  }\n  \n  Sprite.prototype.arc = function(radius, extent) {\n    //  Figure out where the sprite is and which way it\'s facing\n    var spriteHeading = this.get_heading()\n    var tx = this.position[0]\n    var ty = this.position[1]\n\n    //  Figure out the circle center\n    var cx = tx + (radius * Sk.math.cos((spriteHeading + 90) * Degree2Rad));\n    var cy = ty + (radius * Sk.math.sin((spriteHeading + 90) * Degree2Rad));\n\n    //  Canvas arc angles go CLOCKWISE, not COUNTERCLOCKWISE like Sprite\n\n    //  Figure out our arc angles\n    var startAngleDeg;\n    if (radius >= 0)\n      startAngleDeg = spriteHeading - 90;\n    else\n      startAngleDeg = spriteHeading + 90;\n\n    var endAngleDeg;\n    if (extent) {\n      if (radius >= 0)\n        endAngleDeg = startAngleDeg + extent;\n      else\n        endAngleDeg = startAngleDeg - extent;\n    }\n    else {\n      if (radius >= 0)\n        endAngleDeg = startAngleDeg + 360;\n      else\n        endAngleDeg = startAngleDeg - 360;\n    }\n\n    //  Canvas angles are opposite\n    startAngleDeg = 360 - startAngleDeg\n    endAngleDeg   = 360 - endAngleDeg\n\n    //  Becuase the y axis has been flipped in HTML5 Canvas with a tanslation, we need to adjust the angles\n    startAngleDeg = -startAngleDeg\n    endAngleDeg   = -endAngleDeg\n\n    //  Convert to radians\n    var startAngle = startAngleDeg * Degree2Rad;\n    var endAngle   = endAngleDeg   * Degree2Rad;\n\n\n    //  Do the drawing\n    if (! this.animate) {\n      if (!this.filling)\n        this.context.beginPath();\n      this.context.arc(cx, cy, Math.abs(radius), startAngle, endAngle, (radius * extent <= 0));\n      this.context.stroke();\n      if (!this.filling)\n        this.context.closePath();\n    }\n    else {\n      this.addDrawingEvent(["CI", cx, cy, Math.abs(radius), startAngle, endAngle, (radius * extent <= 0)]);\n    }\n\n    //  Move the sprite only if we have to\n    if (extent && (extent % 360) != 0) {\n      var turtleArc;\n      if (radius >= 0)\n        turtleArc = extent;\n      else \n        turtleArc = -extent;\n      var newHeading = (spriteHeading + turtleArc) % 360;\n      if (newHeading < 0)\n        newHeading = newHeading + 360;\n\n      var nx = cx + (radius * Sk.math.cos((newHeading - 90) * Degree2Rad));\n      var ny = cy + (radius * Sk.math.sin((newHeading - 90) * Degree2Rad));  //  y coord is inverted in sprite\n\n      //  Move it internally\n      this.set_heading(newHeading);\n      this.teleport_to(nx,ny);\n\n      //  If we\'re animating the sprite, move it on the screen\n      if (this.animate) {\n        this.addDrawingEvent(["TT", this.heading]);\n      }\n    }\n  }\n\n  Sprite.prototype.write = function(theText, move, align, font) {\n    if (! this.animate) {\n      if (font)\n        this.context.font = font.v;\n      this.context.scale(1, -1);\n      this.context.fillText(theText, this.position[0], -this.position[1]);\n      this.context.scale(1, -1);\n    } else {\n      var fontspec;\n      if (font)\n        fontspec = font.v\n      this.addDrawingEvent(["WT", theText, fontspec, this.position[0], this.position[1]]);\n    }\n  }\n\n  Sprite.prototype.setworldcoordinates = function(llx, lly, urx, ury) {\n    this.spriteCanvas.setworldcoordinates(llx, lly, urx, ury);\n  }\n\n  //\n  // Pen and Style functions\n  //\n  Sprite.prototype.pen_down = function () {\n    this.pen = true;\n  }\n\n  Sprite.prototype.down = Sprite.prototype.pen_down;\n\n  Sprite.prototype.pen_up = function () {\n    this.pen = false;\n  }\n\n  Sprite.prototype.up = Sprite.prototype.pen_up;\n\n  Sprite.prototype.get_pen = function () {\n    return this.pen;\n  }\n\n  Sprite.prototype.set_pen_width = function (w) {\n    if (this.animate)\n      this.addDrawingEvent(["PW", w * this.spriteCanvas.lineScale]);\n    else\n      this.penWidth = w;\n  }\n\n  Sprite.prototype.get_pen_width = function() {\n    return this.penWidth * this.spriteCanvas.lineScale;\n  }\n\n  Sprite.prototype.set_pen_color = function (c, g, b) {\n    if (typeof(c) == "string") {\n      this.penStyle = c;\n    }\n    else {\n      var rs\n      var gs\n      var bs\n      if (typeof( c) == "object" && c.length == 3) {\n        var c0 = Sk.builtin.asnum$(c[0]);\n        var c1 = Sk.builtin.asnum$(c[1]);\n        var c2 = Sk.builtin.asnum$(c[2]);\n      }\n      else {\n        var c0 = Sk.builtin.asnum$(c);\n        var c1 = Sk.builtin.asnum$(g);\n        var c2 = Sk.builtin.asnum$(b);\n      }\n      rs = c0.toString(16);\n      gs = c1.toString(16);\n      bs = c2.toString(16);\n      while (rs.length < 2) rs = "0" + rs;\n      while (gs.length < 2) gs = "0" + gs;\n      while (bs.length < 2) bs = "0" + bs;\n      c = "#" + rs + gs + bs;\n      this.penStyle = c;\n    }\n\n    this.context.strokeStyle = c;\n    if (this.animate)\n      this.addDrawingEvent(["TC", c]);\n  }\n\n  Sprite.prototype.set_fill_color = function (c, g, b) {\n    if (typeof(c) == "string") {\n      this.fillStyle = c;\n    }\n    else {\n      var rs\n      var gs\n      var bs\n      if (typeof( c) == "object" && c.length == 3) {\n        var c0 = Sk.builtin.asnum$(c[0]);\n        var c1 = Sk.builtin.asnum$(c[1]);\n        var c2 = Sk.builtin.asnum$(c[2]);\n      } else {\n        var c0 = Sk.builtin.asnum$(c);\n        var c1 = Sk.builtin.asnum$(g);\n        var c2 = Sk.builtin.asnum$(b);\n      }\n      rs = c0.toString(16)\n      gs = c1.toString(16)\n      bs = c2.toString(16)\n      while (rs.length < 2) rs = "0" + rs;\n      while (gs.length < 2) gs = "0" + gs;\n      while (bs.length < 2) bs = "0" + bs;\n      c = "#" + rs + gs + bs;\n      this.fillStyle = c;\n    }\n\n    this.context.fillStyle = c;\n    if (this.animate)\n      this.addDrawingEvent(["FC", c]);\n  }\n\n  Sprite.prototype.begin_fill = function () {\n    if (! this.animate) {\n      this.filling = true;\n      this.context.beginPath();\n      this.context.moveTo(this.position[0], this.position[1]);\n    }\n    else {\n      this.addDrawingEvent(["BF", this.position[0], this.position[1]]);\n    }\n  }\n\n  Sprite.prototype.end_fill = function () {\n    if (! this.animate) {\n      this.context.stroke();\n      this.context.fill();\n      this.context.closePath();\n      this.filling = false;\n    } else\n    this.addDrawingEvent(["EF", this.position[0], this.position[1], this.fillStyle]);\n  }\n\n  Sprite.prototype.showturtle = function() {\n    if (this.animate) {\n      this.addDrawingEvent(["SH"]);\n    }\n    this.visible = true;\n  }\n\n  Sprite.prototype.hideturtle = function() {\n    if (this.animate) {\n      this.addDrawingEvent(["HT"]);\n    }\n    this.visible = false;\n  }\n\n  Sprite.prototype.isvisible = function() {\n    return this.visible;\n  }\n\n  // \n  // Appearance\n  //\n\n  Sprite.prototype.shape = function(s) {\n    if (this.shapeStore[s])\n      this.currentShape = s;\n    else {\n    }\n  }\n\n  Sprite.prototype.drawSprite = function(heading, position) {\n    var rtPoints = [];\n    var plist = this.shapeStore[this.currentShape];\n    var head;\n    if (! (heading === undefined))\n      head = heading - 90.0;\n    else\n      head = this.heading.toAngle() - 90.0;\n    if (! position)\n      position = this.position\n    for (p in plist) {\n      rtPoints.push(plist[p].scale(this.spriteCanvas.xptscale,this.spriteCanvas.yptscale).rotate(head).add(position));\n    }\n    this.context.beginPath();\n    this.context.moveTo(rtPoints[0][0], rtPoints[0][1]);\n    for (var i = 1; i < rtPoints.length; i++) {\n      this.context.lineTo(rtPoints[i][0], rtPoints[i][1]);\n    }\n    this.context.closePath();\n    this.context.stroke();\n    if (this.fillStyle) {\n      this.context.fill();\n    }\n  }\n\n  Sprite.prototype.stamp = function() {\n    // either call drawSprite or just add a DT with current position and heading to the drawingEvents list.\n    if (this.animate) {\n      this.addDrawingEvent(["ST",this.position[0],this.position[1],this.heading.toAngle()]);\n    } else\n    this.drawSprite();\n  }\n\n  Sprite.prototype.clear = function () {\n    if (this.animate) {\n      this.addDrawingEvent(["CL"])\n    }\n    else {\n      clear_canvas(this.canvasID);\n    }\n  }\n\n  function clear_canvas(canId) {\n    with (document.getElementById(canId).getContext(\'2d\')) {\n      if (arguments.length >= 2) {\n        // fillStyle = arguments[1];\n        // fillRect(0, 0, canvas.width, canvas.height);\n      }\n      clearRect(-canvas.width / 2, -canvas.height / 2, canvas.width, canvas.height);\n    }\n  }\n\n\n  // Create a 3d Vector class for manipulating sprite heading, and position.\n\n  function Vector(x, y, z) {\n    if ((typeof(x)).toLowerCase() === \'number\') {\n      Array.prototype.push.call(this, x);\n      Array.prototype.push.call(this, y);\n      Array.prototype.push.call(this, z);\n    }\n    else {\n      for (var i in x) {\n        Array.prototype.push.call(this, x[i]);\n      }\n    }\n  }\n\n\n  // Create a vector object given a direction as an angle.\n  Vector.angle2vec = function(phi) {\n    var res = new Vector([0.0,0.0,0.0]);\n    phi = phi * Degree2Rad;\n    res[0] = Sk.math.cos(phi);\n    res[1] = Sk.math.sin(phi);\n    return res.normalize();\n  }\n\n  // This trick allows you to access a Vector object like an array\n  // myVec[0] == x\n  // myVec[1] == y\n  // myVec[2] == z\n  // we really only need the z for the convenience of rotating!\n  // If we were using Geometric Algebra we wouldn\'t need it at all and could stay in the plane.\n  Vector.prototype.addItem = function(item) {\n    Array.prototype.push.call(this, item);\n  }\n\n  Vector.prototype.linear = function(a, b, v) {\n    var result = [ ];\n    for (var c = 0; c <= 2; ++c) {\n      result[c] = a * this[c] + b * v[c];\n    }\n    return new Vector(result);\n  }\n\n  Vector.prototype.cross = function(v) {\n    // Return cross product of this and v\n    var result = [ ];\n    for (var c = 0; c <= 2; ++c) {\n      result[c] = this[(c + 1) % 3] * v[(c + 2) % 3] - this[(c + 2) % 3] * v[(c + 1) % 3];\n    }\n    return new Vector(result);\n  }\n\n  Vector.prototype.rotate = function(angle) {\n    // Rotate this counter clockwise by angle.\n    var perp = new Vector(-this[1], this[0], 0);\n    angle = angle * Degree2Rad;\n    var c = Sk.math.cos(angle);\n    var s = Sk.math.sin(angle);\n    return new Vector(this[0] * c + perp[0] * s, this[1] * c + perp[1] * s, 0);\n  }\n\n  Vector.prototype.rotateNormal = function(v, w, alpha) {\n    // Return rotation of this in direction of v about w over alpha\n    // Requires: v, w are vectors; alpha is angle in radians\n    //   this, v, w are orthonormal\n    return this.linear(Sk.math.cos(alpha), Sk.math.sin(alpha), v);\n  }\n\n  Vector.prototype.normalize = function() {\n    var n = this.len();\n    var res = this.div(n);\n    return res;\n  }\n\n  Vector.prototype.toAngle = function() {\n    // workaround for values getting set to +/i xxx e -16 fooling the +/- checks below\n    if (Math.abs(this[1]) < 0.00001) this[1] = 0.0;\n    if (Math.abs(this[0]) < 0.00001) this[0] = 0.0;\n    var rads = Math.atan(Math.abs(this[1]) / Math.abs(this[0]));\n    var deg = rads * Rad2Degree;\n    if (this[0] < 0 && this[1] > 0) deg = 180 - deg;\n    else if (this[0] < 0 && this[1] <= 0) deg = 180.0 + deg;\n    else if (this[0] >= 0 && this[1] < 0) deg = 360 - deg;\n    return deg;\n  }\n\n  // divide all vector components by the same value\n  Vector.prototype.div = function(n) {\n    res = []\n    res[0] = this[0] / n;\n    res[1] = this[1] / n;\n    res[2] = this[2] / n;\n    return new Vector(res);\n  }\n\n  // subtract one vector from another\n  Vector.prototype.sub = function(v) {\n    res = new Vector(0, 0, 0);\n    res[0] = this[0] - v[0];\n    res[1] = this[1] - v[1];\n    res[2] = this[2] - v[2];\n    return res;\n  }\n\n  Vector.prototype.add = function(v) {\n    res = new Vector(0, 0, 0);\n    res[0] = this[0] + v[0];\n    res[1] = this[1] + v[1];\n    res[2] = this[2] + v[2];\n    return res;\n  }\n\n  Vector.prototype.smul = function(k) {  // scalar multiplication\n    res = new Vector(0, 0, 0);\n    res[0] = this[0] * k;\n    res[1] = this[1] * k;\n    res[2] = this[2] * k;\n    return res;\n  }\n\n  Vector.prototype.scale = function(xs,ys) {\n    res = new Vector(0,0,0);\n    res[0] =  this[0] * ys;\n    res[1] =  this[1] * xs;\n    res[2] = 1.0;\n    return res;\n  }\n\n  Vector.prototype.len = function() {\n    return Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);\n  }\n\n  SpriteGraphics.defaults = {canvasID: \'mycanvas\', degrees: true, animate: true};\n  SpriteGraphics.spriteList = [];\n  SpriteGraphics.Sprite = Sprite;\n  SpriteGraphics.SpriteCanvas = SpriteCanvas;\n  SpriteGraphics.canvasLib = {};\n  SpriteGraphics.clear_canvas = clear_canvas;\n  SpriteGraphics.Vector = Vector;\n  SpriteGraphics.canvasInit = false;\n  SpriteGraphics.eventCount = 0;\n  SpriteGraphics.renderClock = 0;\n  SpriteGraphics.renderTime  = 0;\n\n})();\n\nvar $builtinmodule = function(name) {\n\n  var mod = {};\n\n  Sk.builtin.defineEuclidean2(mod, BLADE);\n\n  // The exported name of the SPRITE class.\n  var SPRITE = "Sprite";\n\n  // First we create an object, this will end up being the class\n  Sk.tg = SpriteGraphics;\n\n  var checkArgs = function(expected, actual, func) {\n    if (actual != expected ) {\n      throw new Sk.builtin.TypeError(func + " takes exactly " + expected + " positional argument (" + actual + " given)");\n    }\n  }\n\n  var sprite = function($gbl, $loc) {\n\n    $loc.__init__ = new Sk.builtin.func(function(self, options) {\n      SpriteGraphics.defaults = {"canvasID": Sk.canvas, "animate": true, "degrees": true};\n      self.skType = SPRITE;\n      self.tp$name = SPRITE;\n      self.v = new SpriteGraphics.Sprite();\n      if (options instanceof Sk.builtin.dict) {\n        for (var iter = options.tp$iter(), k = iter.tp$iternext(); k !== undefined; k = iter.tp$iternext()) {\n          var v = options.mp$subscript(k);\n          if (v === undefined) {\n            v = null;\n          }\n          var kAsJs = Sk.ffi.remapToJs(k);\n          var vAsJs = Sk.ffi.remapToJs(v);\n          Sk.misceval.callsim(self[\'__setattr__\'], self, kAsJs, v);\n        }\n      }\n    });\n\n    $loc.__getattr__ = new Sk.builtin.func(function(self, key) {\n\n      var BACKWARD = "backward";\n      var BEGIN_FILL = "begin_fill";\n      // color is implemented as a callable attribute for compatibility.\n      var COLOR = "color";\n      var DOWN = "down";\n      var END_FILL = "end_fill";\n      // FILL_COLOR is implemented as a callable attribute for backwcompatibility.\n      var FILL_COLOR = "fillcolor";\n      var FORWARD = "forward";\n      var GOTO = "goto";\n      var LEFT = "left";\n      var POSITION = "position";\n      var RIGHT = "right";\n      // shape is implemented as a callable attribute for compatibility.\n      var SHAPE = "shape";\n      var STAMP = "stamp";\n      var UP = "up";\n      // Capture the target of the attribute operation.\n      var target = self.v;\n\n      switch(key) {\n        case BACKWARD: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = BACKWARD;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, distance) {\n              distance = Sk.builtin.asnum$(distance);\n              checkArgs(2, arguments.length, BACKWARD);\n              target.forward(-distance);\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(BACKWARD)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(BACKWARD)\n            })\n\n          }, BACKWARD, []));\n        }\n        case BEGIN_FILL: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = BEGIN_FILL;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              checkArgs(1, arguments.length, BEGIN_FILL);\n              target.begin_fill();\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(BEGIN_FILL)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(BEGIN_FILL)\n            })\n\n          }, BEGIN_FILL, []));\n        }\n        case COLOR: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = COLOR;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, color, green, blue) {\n              if(color) {\n                if (blue) {\n                  target.set_pen_color(color, green, blue);\n                  target.set_fill_color(color, green, blue);\n                }\n                else {\n                  color = color.v || target.context.fillStyle;\n                  target.set_pen_color(color);\n                  target.set_fill_color(color);\n                }\n              }\n              else {\n                return [target.penStyle, target.fillStyle];\n              }\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(COLOR)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(COLOR)\n            })\n\n          }, COLOR, []));\n        }\n        case DOWN: {\n          return Sk.ffi.callableToPy(mod, DOWN, function(methodPy) {\n            Sk.ffi.checkMethodArgs(DOWN, arguments, 0, 0);\n            target.pen_down();\n          });\n        }\n        case END_FILL: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = END_FILL;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              checkArgs(1, arguments.length, END_FILL);\n              target.end_fill();\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(END_FILL)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(END_FILL)\n            })\n\n          }, END_FILL, []));\n        }\n        case FILL_COLOR: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = FILL_COLOR;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, color, green, blue) {\n              if (color) {\n                if (blue) {\n                  target.set_fill_color(color, green, blue);\n                }\n                else {\n                  color = color.v || target.context.fillStyle;\n                  target.set_fill_color(color);\n                }\n              }\n              else {\n                return target.fillStyle;\n              }\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(FILL_COLOR)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(FILL_COLOR)\n            })\n\n          }, FILL_COLOR, []));\n        }\n        case FORWARD: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = FORWARD;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, distance) {\n              distance = Sk.builtin.asnum$(distance);\n              checkArgs(2, arguments.length, FORWARD);\n              target.forward(distance);\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(FORWARD)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(FORWARD)\n            })\n\n          }, FORWARD, []));\n        }\n        case GOTO: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = GOTO;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, nx, ny) {\n              nx = Sk.builtin.asnum$(nx);\n              ny = Sk.builtin.asnum$(ny);\n              checkArgs(3, arguments.length, GOTO);\n              target.goto(nx, ny);\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(GOTO)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(GOTO)\n            })\n\n          }, GOTO, []));\n        }\n        case LEFT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = LEFT;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, angle) {\n              angle = Sk.builtin.asnum$(angle);\n              checkArgs(2, arguments.length, LEFT);\n              target.turn(-angle);\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(LEFT)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(LEFT)\n            })\n\n          }, LEFT, []));\n        }\n        case POSITION: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = POSITION;\n              checkArgs(1, arguments.length, POSITION);\n            });\n\n            $loc.__getattr__ = new Sk.builtin.func(function(self, key) {\n              switch(key) {\n                case "x": {\n                  var position = target.get_position();\n                  return Sk.builtin.assk$(position[0], Sk.builtin.nmber.float$);\n                }\n                break;\n                case "y": {\n                  var position = target.get_position();\n                  return Sk.builtin.assk$(position[1], Sk.builtin.nmber.float$);\n                }\n                break;\n                default: {\n                  // do nothing.\n                }\n              }\n            });\n\n            $loc.__setattr__ = new Sk.builtin.func(function(self, key, value) {\n              switch(key) {\n                case "x": {\n                  var nx = Sk.builtin.asnum$(value);\n                  checkArgs(3, arguments.length, key);\n                  target.goto(nx, target.gety());\n                }\n                break;\n                case "y": {\n                  var ny = Sk.builtin.asnum$(value);\n                  checkArgs(3, arguments.length, key);\n                  target.goto(target.getx(), ny);\n                }\n                break;\n                default: {\n                  // do nothing.\n                }\n              }\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(POSITION)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(POSITION)\n            })\n\n          }, POSITION, []));\n        }\n        case RIGHT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = RIGHT;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, angle) {\n              angle = Sk.builtin.asnum$(angle);\n              checkArgs(2, arguments.length, RIGHT);\n              target.turn(angle);\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(RIGHT)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(RIGHT)\n            })\n\n          }, RIGHT, []));\n        }\n        case SHAPE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = SHAPE;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, shape) {\n              checkArgs(2, arguments.length, SHAPE);\n              target.shape(shape.v);\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(SHAPE)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(SHAPE)\n            })\n\n          }, SHAPE, []));\n        }\n        case STAMP: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = STAMP;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              checkArgs(1, arguments.length, STAMP);\n              target.stamp();\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(STAMP)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(STAMP)\n            })\n\n          }, STAMP, []));\n        }\n        case UP: {\n          return Sk.ffi.callableToPy(mod, UP, function(methodPy) {\n            Sk.ffi.checkMethodArgs(UP, arguments, 0, 0);\n            target.pen_up();\n          });\n        }\n        default: {\n          // Do nothing\n        }\n      }\n    });\n\n    $loc.__setattr__ = new Sk.builtin.func(function(selfPy, name, valuePy) {\n\n      var COLOR = "color";\n      var FILL_COLOR = "fillcolor";\n      var POSITION = "position";\n      var SHAPE = "shape";\n      var EUCLIDEAN_2 = "Euclidean2";\n\n      switch(name) {\n        case COLOR: {\n          if(valuePy) {\n            var color = valuePy.v || selfPy.v.context.fillStyle;\n            selfPy.v.set_pen_color(color);\n            selfPy.v.set_fill_color(color);\n          }\n        }\n        break;\n        case FILL_COLOR: {\n          if (valuePy) {\n            selfPy.v.set_fill_color(valuePy.v || selfPy.v.context.fillStyle);\n          }\n        }\n        break;\n        case POSITION: {\n          Sk.ffi.checkArgType("value", EUCLIDEAN_2, Sk.ffi.isInstance(valuePy) && Sk.ffi.typeName(valuePy) === EUCLIDEAN_2);\n          var xPy = Sk.ffi.gattr(valuePy, "x");\n          var yPy = Sk.ffi.gattr(valuePy, "y");\n          selfPy.v.goto(Sk.ffi.remapToJs(xPy), Sk.ffi.remapToJs(yPy));\n        }\n        break;\n        case SHAPE: {\n          if (valuePy) {\n            checkArgs(3, arguments.length, SHAPE);\n            selfPy.v.shape(valuePy.v);\n          }\n        }\n        break;\n        default: {\n//          throw new Sk.builtin.AttributeError("\'" + SPRITE + "\' object has no attribute setter \'" + name + "\'.");\n        }\n      }\n    });\n\n    $loc.setposition = new Sk.builtin.func(function(self,nx,ny) {\n      nx = Sk.builtin.asnum$(nx);\n      ny = Sk.builtin.asnum$(ny);\n      checkArgs(3,arguments.length,"setposition()");\n      self.v.up();\n      self.v.goto(nx,ny);\n      self.v.down();\n    });\n\n    $loc.setpos = $loc.setposition;\n\n    $loc.setheading = new Sk.builtin.func(function(self, newhead) {\n      newhead = Sk.builtin.asnum$(newhead);\n      checkArgs(2,arguments.length,"setheading()");\n      return self.v.set_heading(newhead);\n    });\n\n    $loc.seth = $loc.setheading;\n\n    $loc.home = new Sk.builtin.func(function(self) {\n      self.v.go_home();\n    });\n\n    $loc.dot = new Sk.builtin.func(function(self, /*opt*/ size, color) {\n      size = Sk.builtin.asnum$(size);\n      size = size || 1;\n      if (color) {\n        color = color.v || self.v.penStyle;\n      }\n      self.v.dot(size, color);\n    });\n\n    $loc.circle = new Sk.builtin.func(function(self, radius, extent) {\n      radius = Sk.builtin.asnum$(radius);\n      extent = Sk.builtin.asnum$(extent);\n      self.v.circle(radius, extent);\n    });\n\n    $loc.delay = new Sk.builtin.func(function(self, d) {\n      d = Sk.builtin.asnum$(d);\n      return self.v.delay(d);\n    });\n\n    $loc.speed = new Sk.builtin.func(function(self, s, t) {\n      s = Sk.builtin.asnum$(s);\n      t = Sk.builtin.asnum$(t);\n      self.v.speed(s,t);\n    });\n\n    $loc.tracer = new Sk.builtin.func(function(self, t, d) {\n      t = Sk.builtin.asnum$(t);\n      d = Sk.builtin.asnum$(d);\n      self.v.tracer(t, d);\n    });\n\n    $loc.update = new Sk.builtin.func(function(self) {\n      //  Dummy function to emulate update... when not animating, we don\'t save the drawing operations, so this is pointless for us\n    });\n\n    $loc.heading = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,"heading()");\n      return self.v.get_heading();\n    });\n\n    $loc.xcor = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,"xcor()");\n      var res = self.v.getx();\n      return res;\n    });\n\n    $loc.ycor = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,"ycor()");\n      var res = self.v.gety();\n      return res;\n    });\n\n    $loc.towards = new Sk.builtin.func(function(self, tx, ty) {\n      tx = Sk.builtin.asnum$(tx);\n      ty = Sk.builtin.asnum$(ty);\n      if ((typeof(tx)).toLowerCase() === \'number\')\n        tx = [tx, ty, 0];\n      return self.v.towards(tx);\n    });\n\n    // tx can be either a number or a vector position.\n    // tx can not be a sprite at this time as multiple sprites have not been implemented yet.\n    $loc.distance = new Sk.builtin.func(function(self, tx, ty) {\n      tx = Sk.builtin.asnum$(tx);\n      ty = Sk.builtin.asnum$(ty);\n      if ((typeof(tx)).toLowerCase() === \'number\') {\n        tx = [tx, ty, 0];\n      }\n      else {\n        tx = [tx.v.getx(), tx.v.gety(), 0];\n      }\n      return self.v.distance(tx);\n    });\n\n    //\n    // Setting and Measurement\n    //\n\n    $loc.width = new Sk.builtin.func(function(self, w) {\n     w = Sk.builtin.asnum$(w);\n     checkArgs(2,arguments.length,"width()");\n     self.v.set_pen_width(w);\n   });\n\n    $loc.pensize = $loc.width;\n\n    $loc.isdown = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,"isdown()");\n      return self.v.get_pen();\n    });\n\n    $loc.pencolor = new Sk.builtin.func(function(self, color, green, blue) {\n      if (color) {\n        if (blue) {\n          color = Sk.builtin.asnum$(color);\n          green = Sk.builtin.asnum$(green);\n          blue = Sk.builtin.asnum$(blue);\n          self.v.set_pen_color(color, green, blue);\n        }\n        else {\n          color = color.v || self.v.context.fillStyle;\n          self.v.set_pen_color(color);\n        }\n      }\n      else {\n        return self.v.penStyle;\n      }\n    });\n\n    $loc.color = new Sk.builtin.func(function(self, color, green, blue) {\n      if(color) {\n        if (blue) {\n          self.v.set_pen_color(color, green, blue);\n          self.v.set_fill_color(color, green, blue);\n        }\n        else {\n          color = color.v || self.v.context.fillStyle;\n          self.v.set_pen_color(color);\n          self.v.set_fill_color(color);\n        }\n      }\n      else {\n        return [self.v.penStyle, self.v.fillStyle];\n      }\n    });\n\n    $loc.fill = new Sk.builtin.func(function(self, fillt) {\n      if (fillt === undefined)\n        return self.v.filling;\n      if (fillt)\n        self.v.begin_fill();\n      else\n        self.v.end_fill();\n    });\n\n    //\n    // More drawing control\n    //\n\n    $loc.reset = new Sk.builtin.func(function(self) {\n      self.v.clean();\n    });\n\n    $loc.showturtle = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,"showturtle()");\n      self.v.showturtle();\n    });\n\n    $loc.st = $loc.showturtle;\n\n    $loc.hideturtle = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,"hideturtle()");\n      self.v.hideturtle();\n    });\n\n    $loc.ht = $loc.hideturtle;\n\n    $loc.isvisible = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,"isvisible()");\n      self.v.isvisible()\n    });\n\n    // todo the move, align, and font parameters should be kwargs...\n    $loc.write = new Sk.builtin.func(function(self, mystr, move, align, font) {\n      self.v.write(mystr.v, move, align, font);\n    });\n\n    // todo clean  -- again multiple sprites\n\n    $loc.setworldcoordinates = new Sk.builtin.func(function(self, llx, lly, urx, ury) {\n      llx = Sk.builtin.asnum$(llx);\n      lly = Sk.builtin.asnum$(lly);\n      urx = Sk.builtin.asnum$(urx);\n      ury = Sk.builtin.asnum$(ury);\n      self.v.setworldcoordinates(llx, lly, urx, ury);\n    });\n\n    $loc.clear = new Sk.builtin.func(function(self) {\n      self.v.clear()\n    });\n  }\n\n  mod[SPRITE] = Sk.misceval.buildClass(mod, sprite, SPRITE, []);\n\n  var screen = function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self) {\n      SpriteGraphics.defaults = {canvasID: Sk.canvas, animate: true, degrees: true};\n      var currentCanvas = SpriteGraphics.canvasLib[SpriteGraphics.defaults.canvasID];\n      if (currentCanvas === undefined) {\n        self.theScreen = new SpriteGraphics.SpriteCanvas(SpriteGraphics.defaults);\n      } else {\n        self.theScreen = currentCanvas;\n      }\n    });\n\n    $loc.bgcolor = new Sk.builtin.func(function(self, c) {\n      self.theScreen.bgcolor(c);\n    });\n\n    $loc.setworldcoordinates = new Sk.builtin.func(function(self, llx,lly,urx,ury) {\n     llx = Sk.builtin.asnum$(llx);\n     lly = Sk.builtin.asnum$(lly);\n     urx = Sk.builtin.asnum$(urx);\n     ury = Sk.builtin.asnum$(ury);\n     self.theScreen.setworldcoordinates(llx,lly,urx,ury);\n   });\n\n    $loc.exitonclick = new Sk.builtin.func(function(self) {\n      self.theScreen.exitonclick();\n    });\n\n    $loc.title = new Sk.builtin.func(function(self,titlestring) {\n      // no op....\n    });\n\n    $loc.window_width = new Sk.builtin.func(function(self) {\n      return self.theScreen.window_width();\n    });\n\n    $loc.window_height = new Sk.builtin.func(function(self) {\n      return self.theScreen.window_height();\n    });\n\n    $loc.sprites = new Sk.builtin.func(function(self) {\n      return self.theScreen.sprites();\n    });\n\n    $loc.colormode = new Sk.builtin.func(function(self) {\n      //  Empty function to emulate compatibility\n    });\n\n    var myfunc = function(self, width, height, startx, starty) {\n      width = Sk.builtin.asnum$(width);\n      height = Sk.builtin.asnum$(height);\n      self.theScreen.setup(width,height);\n    }\n    // this should allow for named parameters\n    myfunc.co_varnames = [\'self\',\'width\',\'height\',\'startx\',\'starty\'];\n    myfunc.$defaults = [null,500,500,0,0];\n    $loc.setup = new Sk.builtin.func(myfunc);\n  }\n\n  mod.Screen = Sk.misceval.buildClass(mod, screen, \'Screen\', []);\n\n  mod.tracer = new Sk.builtin.func(function(t, d) {\n    t = Sk.builtin.asnum$(t);\n    d = Sk.builtin.asnum$(d);\n    for (var i in Sk.tg.canvasLib) {\n      Sk.tg.canvasLib[i].tracer(t, d);\n    }\n  });\n\n  mod.update = new Sk.builtin.func(function(self) {\n    //  Dummy function to emulate update... when not animating, we don\'t save the drawing operations, so this is pointless for us\n  });\n\n  return mod\n}\n',
    'src/lib/unittestgui/__init__.py': '__author__ = \'bmiller\'\n\nimport document\n\n\nclass unittest:\n    def __init__(self):\n        self.numPassed = 0\n        self.numFailed = 0\n        self.divid = document.currentDiv()\n        self.mydiv = document.getElementById(self.divid)\n        res = document.getElementById(self.divid+\'_unit_results\')\n        if res:\n            self.resdiv = res\n            res.innerHTML = \'\'\n        else:\n            self.resdiv = document.createElement(\'div\')\n            self.resdiv.setAttribute(\'id\',self.divid+\'_unit_results\')\n            self.resdiv.setAttribute(\'class\',\'unittest-results\')\n        self.mydiv.appendChild(self.resdiv)\n\n        self.tlist = []\n        testNames = {}\n        for name in dir(self):\n            if name[:4] == \'test\' and name not in testNames:\n                self.tlist.append(getattr(self,name))\n                testNames[name]=True\n\n    def setup(self):\n        pass\n\n    def tearDown(self):\n        pass\n\n    def main(self):\n        l = document.createElement(\'ul\')\n        self.resdiv.appendChild(l)\n        self.resList = l\n\n        for func in self.tlist:\n            try:\n                self.setup()\n                func()\n                self.tearDown()\n            except:\n                self.appendResult(\'Error\')\n                self.numFailed += 1\n        self.showSummary()\n\n    def assertEqual(self, actual, expected, feedback=""):\n        res = actual==expected\n        self.appendResult(res,str(actual)+\' to be equal to \',expected, feedback)\n\n    def assertNotEqual(actual, expected, feedback=""):\n        res = actual != expected\n        self.appendResult(res,str(actual)+\' to not equal \',expected,feedback)\n\n    def assertTrue(self,x, feedback=""):\n        res = x\n        self.appendResult(res,str(x)+\' to be \',True,feedback)\n\n    def assertFalse(self,x, feedback=""):\n        res = not x\n        self.appendResult(res,str(x)+\' to be \',False,feedback)\n\n    def assertIs(self,a,b, feedback=""):\n        res = a is b\n        self.appendResult(res,str(a)+\' to be the same object as \',b,feedback)\n\n    def assertIsNot(self,a,b, feedback=""):\n        res = a is not b\n        self.appendResult(res,str(a)+\' to not be the same object as \',b,feedback)\n\n    def assertIsNone(self,x, feedback=""):\n        res = x is None\n        self.appendResult(res,x,None,feedback)\n\n    def assertIsNotNone(self,x, feedback=""):\n        res = x is not None\n        self.appendResult(res,str(x)+\' to not be \',None,feedback)\n\n    def assertIn(self,a,b, feedback=""):\n        res = a in b\n        self.appendResult(res,str(a)+\' to be in \',b,feedback)\n\n    def assertNotIn(self,a,b, feedback=""):\n        res = a not in b\n        self.appendResult(res,str(a)+\' to not be in \',b,feedback)\n\n    def assertIsInstance(self,a,b, feedback=""):\n        res = isinstance(a,b)\n        self.appendResult(res,str(a)+\' to be an instance of \',b,feedback)\n\n    def assertNotIsInstance(self,a,b, feedback=""):\n        res = not isinstance(a,b)\n        self.appendResult(res,str(a)+\' to not be an instance of \',b,feedback)\n\n    def assertAlmostEqual(self,a,b, feedback=""):\n        res = round(a-b,7) == 0\n        self.appendResult(res,str(a)+\' to equal \',b,feedback)\n\n    def assertNotAlmostEqual(self,a,b, feedback=""):\n        res = round(a-b,7) != 0\n        self.appendResult(res,str(a)+\' to not equal \',b,feedback)\n\n    def assertGreater(self,a,b, feedback=""):\n        res = a > b\n        self.appendResult(res,str(a)+\' to be greater than \',b,feedback)\n\n    def assertGreaterEqual(self,a,b, feedback=""):\n        res = a >= b\n        self.appendResult(res,str(a)+\' to be greater than or equal to \',b,feedback)\n\n    def assertLess(self,a,b, feedback=""):\n        res = a < b\n        self.appendResult(res,str(a)+\' to be less than \',b,feedback)\n\n    def assertLessEqual(self,a,b, feedback=""):\n        res = a <= b\n        self.appendResult(res,str(a)+\' to be less than or equal to \',b,feedback)\n\n    def appendResult(self,res,actual,expected,feedback):\n        if res == \'Error\':\n            msg = \'Error\'\n        elif res:\n            msg = \'Pass\'\n            self.numPassed += 1\n        else:\n            msg = \'Fail: expected %s  %s \' % (str(actual),str(expected)) + feedback\n            self.numFailed += 1\n\n        pTag = document.createElement(\'li\')\n        pTag.innerHTML = msg\n        self.resList.appendChild(pTag)\n\n    def showSummary(self):\n        pct = self.numPassed / (self.numPassed+self.numFailed) * 100\n        pTag = document.createElement(\'p\')\n        pTag.innerHTML = "You passed: " + str(pct) + "% of the tests"\n        self.resdiv.appendChild(pTag)\n        if pct < 90:\n            self.resdiv.setCSS(\'background-color\',\'#de8e96\')\n        else:\n            self.resdiv.setCSS(\'background-color\',\'#83d382\')\n\n\n\n',
    'src/lib/matrix/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineMatrix(mod);\n  return mod;\n};',
    'src/lib/webgl/matrix4.js': '// more from \'tdl\'\nvar $builtinmodule = function(name)\n{\n    var mod = {};\n\n    var temp0v3_ = new Float32Array(3);\n    var temp1v3_ = new Float32Array(3);\n    var temp2v3_ = new Float32Array(3);\n\n    var temp0v4_ = new Float32Array(4);\n    var temp1v4_ = new Float32Array(4);\n    var temp2v4_ = new Float32Array(4);\n\n    var temp0m4_ = new Float32Array(16);\n    var temp1m4_ = new Float32Array(16);\n    var temp2m4_ = new Float32Array(16);\n\n    var normalize = function(dst, a) {\n        var n = 0.0;\n        var aLength = a.length;\n        for (var i = 0; i < aLength; ++i)\n            n += a[i] * a[i];\n        n = Math.sqrt(n);\n        if (n > 0.00001) {\n            for (var i = 0; i < aLength; ++i)\n                dst[i] = a[i] / n;\n        } else {\n            for (var i = 0; i < aLength; ++i)\n                dst[i] = 0;\n        }\n        return dst;\n    };\n\n    var cross = function(dst, a, b) {\n        dst[0] = a[1] * b[2] - a[2] * b[1];\n        dst[1] = a[2] * b[0] - a[0] * b[2];\n        dst[2] = a[0] * b[1] - a[1] * b[0];\n        return dst;\n    };\n\n    var subVector = function(dst, a, b) {\n        var aLength = a.length;\n        for (var i = 0; i < aLength; ++i)\n            dst[i] = a[i] - b[i];\n        return dst;\n    };\n\n    var dot = function(a, b) {\n        return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]);\n    };\n\n    mod.lookAt = new Sk.builtin.func(function(view, eye, target, up)\n            {\n                var t0 = temp0v3_;\n                var t1 = temp1v3_;\n                var t2 = temp2v3_;\n\n                var vz = normalize(t0, subVector(t0, eye.v, target.v));\n                var vx = normalize(t1, cross(t1, up.v, vz));\n                var vy = cross(t2, vz, vx);\n\n                var dst = view.v;\n                dst[ 0] = vx[0];\n                dst[ 1] = vy[0];\n                dst[ 2] = vz[0];\n                dst[ 3] = 0;\n                dst[ 4] = vx[1];\n                dst[ 5] = vy[1];\n                dst[ 6] = vz[1];\n                dst[ 7] = 0;\n                dst[ 8] = vx[2];\n                dst[ 9] = vy[2];\n                dst[10] = vz[2];\n                dst[11] = 0;\n                dst[12] = -dot(vx, eye.v);\n                dst[13] = -dot(vy, eye.v);\n                dst[14] = -dot(vz, eye.v);\n                dst[15] = 1;\n\n                return view;\n            });\n\n    mod.perspective = new Sk.builtin.func(function(proj, angle, aspect, near, far)\n            {\n                var f = Math.tan(Math.PI * 0.5 - 0.5 * (angle * Math.PI / 180));\n                var rangeInv = 1.0 / (near - far);\n\n                var dst = proj.v;\n\n                dst[0]  = f / aspect;\n                dst[1]  = 0;\n                dst[2]  = 0;\n                dst[3]  = 0;\n\n                dst[4]  = 0;\n                dst[5]  = f;\n                dst[6]  = 0;\n                dst[7]  = 0;\n\n                dst[8]  = 0;\n                dst[9]  = 0;\n                dst[10] = (near + far) * rangeInv;\n                dst[11] = -1;\n\n                dst[12] = 0;\n                dst[13] = 0;\n                dst[14] = near * far * rangeInv * 2;\n                dst[15] = 0;\n\n                return proj;\n            });\n\n    // builds, not appending\n    mod.rotationY = new Sk.builtin.func(function(target, angle)\n            {\n                var dst = target.v;\n                var c = Sk.math.cos(angle * Math.PI / 180);\n                var s = Sk.math.sin(angle * Math.PI / 180);\n\n                dst[ 0] = c;\n                dst[ 1] = 0;\n                dst[ 2] = -s;\n                dst[ 3] = 0;\n                dst[ 4] = 0;\n                dst[ 5] = 1;\n                dst[ 6] = 0;\n                dst[ 7] = 0;\n                dst[ 8] = s;\n                dst[ 9] = 0;\n                dst[10] = c;\n                dst[11] = 0;\n                dst[12] = 0;\n                dst[13] = 0;\n                dst[14] = 0;\n                dst[15] = 1;\n\n                return target;\n            });\n\n    mod.identity = new Sk.builtin.func(function(target)\n            {\n                var dst = target.v;\n                dst[ 0] = 1;\n                dst[ 1] = 0;\n                dst[ 2] = 0;\n                dst[ 3] = 0;\n                dst[ 4] = 0;\n                dst[ 5] = 1;\n                dst[ 6] = 0;\n                dst[ 7] = 0;\n                dst[ 8] = 0;\n                dst[ 9] = 0;\n                dst[10] = 1;\n                dst[11] = 0;\n                dst[12] = 0;\n                dst[13] = 0;\n                dst[14] = 0;\n                dst[15] = 1;\n                return target;\n            });\n\n    // row major\n    mod.mul = new Sk.builtin.func(function(target, x, y)\n            {\n                var dst = target.v;\n                var a = x.v;\n                var b = y.v;\n                var a00 = a[0];\n                var a01 = a[1];\n                var a02 = a[2];\n                var a03 = a[3];\n                var a10 = a[ 4 + 0];\n                var a11 = a[ 4 + 1];\n                var a12 = a[ 4 + 2];\n                var a13 = a[ 4 + 3];\n                var a20 = a[ 8 + 0];\n                var a21 = a[ 8 + 1];\n                var a22 = a[ 8 + 2];\n                var a23 = a[ 8 + 3];\n                var a30 = a[12 + 0];\n                var a31 = a[12 + 1];\n                var a32 = a[12 + 2];\n                var a33 = a[12 + 3];\n                var b00 = b[0];\n                var b01 = b[1];\n                var b02 = b[2];\n                var b03 = b[3];\n                var b10 = b[ 4 + 0];\n                var b11 = b[ 4 + 1];\n                var b12 = b[ 4 + 2];\n                var b13 = b[ 4 + 3];\n                var b20 = b[ 8 + 0];\n                var b21 = b[ 8 + 1];\n                var b22 = b[ 8 + 2];\n                var b23 = b[ 8 + 3];\n                var b30 = b[12 + 0];\n                var b31 = b[12 + 1];\n                var b32 = b[12 + 2];\n                var b33 = b[12 + 3];\n                dst[ 0] = a00 * b00 + a01 * b10 + a02 * b20 + a03 * b30;\n                dst[ 1] = a00 * b01 + a01 * b11 + a02 * b21 + a03 * b31;\n                dst[ 2] = a00 * b02 + a01 * b12 + a02 * b22 + a03 * b32;\n                dst[ 3] = a00 * b03 + a01 * b13 + a02 * b23 + a03 * b33;\n                dst[ 4] = a10 * b00 + a11 * b10 + a12 * b20 + a13 * b30;\n                dst[ 5] = a10 * b01 + a11 * b11 + a12 * b21 + a13 * b31;\n                dst[ 6] = a10 * b02 + a11 * b12 + a12 * b22 + a13 * b32;\n                dst[ 7] = a10 * b03 + a11 * b13 + a12 * b23 + a13 * b33;\n                dst[ 8] = a20 * b00 + a21 * b10 + a22 * b20 + a23 * b30;\n                dst[ 9] = a20 * b01 + a21 * b11 + a22 * b21 + a23 * b31;\n                dst[10] = a20 * b02 + a21 * b12 + a22 * b22 + a23 * b32;\n                dst[11] = a20 * b03 + a21 * b13 + a22 * b23 + a23 * b33;\n                dst[12] = a30 * b00 + a31 * b10 + a32 * b20 + a33 * b30;\n                dst[13] = a30 * b01 + a31 * b11 + a32 * b21 + a33 * b31;\n                dst[14] = a30 * b02 + a31 * b12 + a32 * b22 + a33 * b32;\n                dst[15] = a30 * b03 + a31 * b13 + a32 * b23 + a33 * b33;\n                return target;\n            });\n\n    mod.invert = new Sk.builtin.func(function(target, mat)\n            {\n                var dst = target.v;\n                var m = mat.v;\n                var m00 = m[0 * 4 + 0];\n                var m01 = m[0 * 4 + 1];\n                var m02 = m[0 * 4 + 2];\n                var m03 = m[0 * 4 + 3];\n                var m10 = m[1 * 4 + 0];\n                var m11 = m[1 * 4 + 1];\n                var m12 = m[1 * 4 + 2];\n                var m13 = m[1 * 4 + 3];\n                var m20 = m[2 * 4 + 0];\n                var m21 = m[2 * 4 + 1];\n                var m22 = m[2 * 4 + 2];\n                var m23 = m[2 * 4 + 3];\n                var m30 = m[3 * 4 + 0];\n                var m31 = m[3 * 4 + 1];\n                var m32 = m[3 * 4 + 2];\n                var m33 = m[3 * 4 + 3];\n                var tmp_0  = m22 * m33;\n                var tmp_1  = m32 * m23;\n                var tmp_2  = m12 * m33;\n                var tmp_3  = m32 * m13;\n                var tmp_4  = m12 * m23;\n                var tmp_5  = m22 * m13;\n                var tmp_6  = m02 * m33;\n                var tmp_7  = m32 * m03;\n                var tmp_8  = m02 * m23;\n                var tmp_9  = m22 * m03;\n                var tmp_10 = m02 * m13;\n                var tmp_11 = m12 * m03;\n                var tmp_12 = m20 * m31;\n                var tmp_13 = m30 * m21;\n                var tmp_14 = m10 * m31;\n                var tmp_15 = m30 * m11;\n                var tmp_16 = m10 * m21;\n                var tmp_17 = m20 * m11;\n                var tmp_18 = m00 * m31;\n                var tmp_19 = m30 * m01;\n                var tmp_20 = m00 * m21;\n                var tmp_21 = m20 * m01;\n                var tmp_22 = m00 * m11;\n                var tmp_23 = m10 * m01;\n\n                var t0 = (tmp_0 * m11 + tmp_3 * m21 + tmp_4 * m31) -\n                    (tmp_1 * m11 + tmp_2 * m21 + tmp_5 * m31);\n                var t1 = (tmp_1 * m01 + tmp_6 * m21 + tmp_9 * m31) -\n                    (tmp_0 * m01 + tmp_7 * m21 + tmp_8 * m31);\n                var t2 = (tmp_2 * m01 + tmp_7 * m11 + tmp_10 * m31) -\n                    (tmp_3 * m01 + tmp_6 * m11 + tmp_11 * m31);\n                var t3 = (tmp_5 * m01 + tmp_8 * m11 + tmp_11 * m21) -\n                    (tmp_4 * m01 + tmp_9 * m11 + tmp_10 * m21);\n\n                var d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);\n\n                dst[ 0] = d * t0;\n                dst[ 1] = d * t1;\n                dst[ 2] = d * t2;\n                dst[ 3] = d * t3;\n                dst[ 4] = d * ((tmp_1 * m10 + tmp_2 * m20 + tmp_5 * m30) -\n                        (tmp_0 * m10 + tmp_3 * m20 + tmp_4 * m30));\n                dst[ 5] = d * ((tmp_0 * m00 + tmp_7 * m20 + tmp_8 * m30) -\n                        (tmp_1 * m00 + tmp_6 * m20 + tmp_9 * m30));\n                dst[ 6] = d * ((tmp_3 * m00 + tmp_6 * m10 + tmp_11 * m30) -\n                        (tmp_2 * m00 + tmp_7 * m10 + tmp_10 * m30));\n                dst[ 7] = d * ((tmp_4 * m00 + tmp_9 * m10 + tmp_10 * m20) -\n                        (tmp_5 * m00 + tmp_8 * m10 + tmp_11 * m20));\n                dst[ 8] = d * ((tmp_12 * m13 + tmp_15 * m23 + tmp_16 * m33) -\n                        (tmp_13 * m13 + tmp_14 * m23 + tmp_17 * m33));\n                dst[ 9] = d * ((tmp_13 * m03 + tmp_18 * m23 + tmp_21 * m33) -\n                        (tmp_12 * m03 + tmp_19 * m23 + tmp_20 * m33));\n                dst[10] = d * ((tmp_14 * m03 + tmp_19 * m13 + tmp_22 * m33) -\n                        (tmp_15 * m03 + tmp_18 * m13 + tmp_23 * m33));\n                dst[11] = d * ((tmp_17 * m03 + tmp_20 * m13 + tmp_23 * m23) -\n                        (tmp_16 * m03 + tmp_21 * m13 + tmp_22 * m23));\n                dst[12] = d * ((tmp_14 * m22 + tmp_17 * m32 + tmp_13 * m12) -\n                        (tmp_16 * m32 + tmp_12 * m12 + tmp_15 * m22));\n                dst[13] = d * ((tmp_20 * m32 + tmp_12 * m02 + tmp_19 * m22) -\n                        (tmp_18 * m22 + tmp_21 * m32 + tmp_13 * m02));\n                dst[14] = d * ((tmp_18 * m12 + tmp_23 * m32 + tmp_15 * m02) -\n                        (tmp_22 * m32 + tmp_14 * m02 + tmp_19 * m12));\n                dst[15] = d * ((tmp_22 * m22 + tmp_16 * m02 + tmp_21 * m12) -\n                        (tmp_20 * m12 + tmp_23 * m22 + tmp_17 * m02));\n                return target;\n            });\n\n    mod.transpose = new Sk.builtin.func(function(target, mat)\n            {\n                var dst = target.v;\n                var m = mat.v;\n                for (var j = 0; j < 4; ++j) {\n                    for (var i = 0; i < 4; ++i)\n                    dst[j * 4 + i] = m[i * 4 + j];\n                }\n                return dst;\n            });\n\n    return mod;\n};\n',
    'src/lib/webgl/__init__.js': 'var $builtinmodule = function(name)\n{\n  var mod = {};\n\n  var makeFailHTML = function(msg) {\n    return \'\' +\n      \'<table style="background-color: #8CE; width: 100%; height: 100%;"><tr>\' +\n      \'<td align="center">\' +\n      \'<div style="display: table-cell; vertical-align: middle;">\' +\n      \'<div style="">\' + msg + \'</div>\' +\n      \'</div>\' +\n      \'</td></tr></table>\';\n  };\n\n  var GET_A_WEBGL_BROWSER = \'\' +\n    \'This page requires a browser that supports WebGL.<br/>\' +\n    \'<a href="http://get.webgl.org">Click here to upgrade your browser.</a>\';\n\n  var NEED_HARDWARE = \'\' +\n    "It doesn\'t appear your computer can support WebGL.<br/>" +\n    \'<a href="http://get.webgl.org">Click here for more information.</a>\';\n  \n  var create3DContext = function(canvas) {\n    var names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];\n    var gl = null;\n    for (var ii = 0; ii < names.length; ++ii) {\n      try {\n        gl = canvas.getContext(names[ii]);\n      }\n      catch(e) {\n      }\n      if (gl) {\n          break;\n      }\n    }\n    if (gl) {\n      // Disallow selection by default. This keeps the cursor from changing to an\n      // I-beam when the user clicks and drags. It\'s easier on the eyes.\n      function returnFalse() {\n        return false;\n      }\n\n      canvas.onselectstart = returnFalse;\n      canvas.onmousedown = returnFalse;\n    }\n    return gl;\n  };\n\n  var setupWebGL = function(canvasContainerId, opt_canvas) {\n    var container = document.getElementById(canvasContainerId);\n    var context;\n    if (!opt_canvas) {\n      opt_canvas = container.getElementsByTagName("canvas")[0];\n    }\n    if (!opt_canvas) {\n        // this browser doesn\'t support the canvas tag at all. Not even 2d.\n      container.innerHTML = makeFailHTML(GET_A_WEBGL_BROWSER);\n      return;\n    }\n\n    var gl = create3DContext(opt_canvas);\n    if (!gl) {\n      // TODO(gman): fix to official way to detect that it\'s the user\'s machine, not the browser.\n      var browserStrings = navigator.userAgent.match(/(\\w+\\/.*? )/g);\n      var browsers = {};\n      try {\n        for (var b = 0; b < browserStrings.length; ++b) {\n          var parts = browserStrings[b].match(/(\\w+)/g);\n          var bb = [];\n          for (var ii = 1; ii < parts.length; ++ii) {\n            bb.push(parseInt(parts[ii]));\n          }\n          browsers[parts[0]] = bb;\n        }\n      }\n      catch (e) {\n      }\n      if (browsers.Chrome &&\n           (browsers.Chrome[0] > 7 ||\n                 (browsers.Chrome[0] == 7 && browsers.Chrome[1] > 0) ||\n                 (browsers.Chrome[0] == 7 && browsers.Chrome[1] == 0 && browsers.Chrome[2] >= 521))) {\n        container.innerHTML = makeFailHTML(NEED_HARDWARE);\n      }\n      else {\n        container.innerHTML = makeFailHTML(GET_A_WEBGL_BROWSER);\n      }\n    }\n    return gl;\n  };\n\n  /**\n   * The Context encapsulates the underlying WebGL native JavaScript API.\n   */\n  mod.Context = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(\n      function(self, canvasid) {\n        var canvas = document.getElementById(canvasid.v);\n        var gl = setupWebGL(canvasid.v, canvas)\n        if (!gl) {\n          throw new Error("Your browser does not appear to support WebGL.");\n        }\n\n        self.gl = gl;\n\n        // Copy symbolic constants and functions from native WebGL, encapsulating where necessary.       \n        for (var k in gl.__proto__) {\n          if (typeof gl.__proto__[k] === \'number\') {\n            Sk.abstr.objectSetItem(self[\'$d\'], new Sk.builtin.str(k), gl.__proto__[k]);\n          }\n          else if (typeof gl.__proto__[k] === "function") {\n            switch(k) {\n              case \'bufferData\': {\n              }\n              break;\n              case \'clearColor\': {\n              }\n              break;\n              case \'drawArrays\': {\n              }\n              break;\n              case \'getAttribLocation\': {\n              }\n              break;\n              case \'getUniformLocation\': {\n              }\n              break;\n              case \'shaderSource\': {\n              }\n              break;\n              case \'uniformMatrix4fv\': {\n              }\n              break;\n              case \'vertexAttribPointer\': {\n              }\n              break;\n              case \'viewport\': {\n              }\n              break;\n              default: {\n                (function(key) {\n                  Sk.abstr.objectSetItem(self[\'$d\'], new Sk.builtin.str(k), new Sk.builtin.func(function() {\n                    var f = gl.__proto__[key];\n                    return f.apply(gl, arguments);\n                  }));\n                 }(k));\n              }\n            }\n          }\n        }\n\n        gl.clearColor(100.0/255.0, 149.0/255.0, 237.0/255.0, 1.0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n      }\n    );\n\n    $loc.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;\n\n    $loc.bufferData = new Sk.builtin.func(\n      function(self, target, data, usage) {\n        self.gl.bufferData(target, data.v, usage);\n      }\n    );\n\n    $loc.clearColor = new Sk.builtin.func(\n      function(self, red, green, blue, alpha) {\n        self.gl.clearColor(Sk.builtin.asnum$(red), Sk.builtin.asnum$(green), Sk.builtin.asnum$(blue), Sk.builtin.asnum$(alpha));\n      }\n    );\n\n    $loc.getAttribLocation = new Sk.builtin.func(\n      function(self, program, name) {\n        return self.gl.getAttribLocation(program, name.v);\n      }\n    );\n\n    $loc.getUniformLocation = new Sk.builtin.func(\n      function(self, program, name) {\n        return self.gl.getUniformLocation(program, name.v);\n      }\n    );\n\n    $loc.shaderSource = new Sk.builtin.func(\n      function(self, shader, src) {\n        self.gl.shaderSource(shader, src.v);\n      }\n    );\n\n    $loc.drawArrays = new Sk.builtin.func(\n      function(self, mode, first, count) {\n        self.gl.drawArrays(Sk.builtin.asnum$(mode), Sk.builtin.asnum$(first), Sk.builtin.asnum$(count));\n      }\n    );\n\n    $loc.vertexAttribPointer = new Sk.builtin.func(\n      function(self, index, size, type, normalized, stride, dunno) {\n        self.gl.vertexAttribPointer(index, Sk.builtin.asnum$(size), Sk.builtin.asnum$(type), normalized, Sk.builtin.asnum$(stride), Sk.builtin.asnum$(dunno));\n      }\n    );\n\n    $loc.viewport = new Sk.builtin.func(\n      function(self, x, y, width, height) {\n        self.gl.viewport(Sk.builtin.asnum$(x), Sk.builtin.asnum$(y), Sk.builtin.asnum$(width), Sk.builtin.asnum$(height));\n      }\n    );\n\n    $loc.uniformMatrix4fv = new Sk.builtin.func(\n      function(self, location, transpose, values) {\n//        console.log("location  " + (typeof location));\n//        console.log("transpose " + (typeof transpose));\n//        console.log("values.v  " + (typeof values.v));\n        self.gl.uniformMatrix4fv(Sk.builtin.asnum$(location), transpose, values.v);\n      }\n    );\n\n    $loc.setDrawFunc = new Sk.builtin.func(function(self, func) {\n      var startTime = (new Date()).getTime();\n      var intervalId = setInterval(\n        function() {\n          Sk.misceval.callsim(func, self, (new Date()).getTime() - startTime);\n        }, 1000.0 / 60.0); // 60 fps\n    });\n\n  }, \'Context\', []);\n\n  mod.Float32Array = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, data) {\n      if (typeof data === "number") {\n        self.v = new Float32Array(data);\n      }\n      else {\n        self.v = new Float32Array(Sk.ffi.remapToJs(data));\n      }\n    });\n\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var copy = [];\n      for (var i = 0; i < self.v.length; ++i) {\n        copy.push(self.v[i]);\n      }\n      return new Sk.builtin.str("[" + copy.join(\', \') + "]");\n     });\n  }, \'Float32Array\', []);\n\n  /**\n   * A 4x4 (mutable) matrix suitable for OpenGL.\n   *\n   * Mutability is chosen for performance.\n   * The inderlying implementation is Float32Array.\n   * The indexing of the elements is\n   * 0 4  8 12\n   * 1 5  9 13\n   * 2 6 10 14\n   * 3 7 11 15\n   */\n  mod.Matrix4x4 = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, data) {\n      self.v = new Float32Array(Sk.ffi.remapToJs(data));\n    });\n\n    $loc.identity = new Sk.builtin.func(\n      function(self) {\n\n        var m = self.v;\n\n        m[0]  = 1;\n        m[1]  = 0;\n        m[2]  = 0;\n        m[3]  = 0;\n\n        m[4]  = 0;\n        m[5]  = 1;\n        m[6]  = 0;\n        m[7]  = 0;\n\n        m[8]  = 0;\n        m[9]  = 0;\n        m[10] = 1;\n        m[11] = 0;\n\n        m[12] = 0;\n        m[13] = 0;\n        m[14] = 0;\n        m[15] = 1;\n      }\n    );\n\n    $loc.perspective = new Sk.builtin.func(\n      function(self, fov, aspect, near, far) {\n        \n        var t = Math.tan(Math.PI * 0.5 - 0.5 * (Sk.builtin.asnum$(fov) * Math.PI / 180));\n        var a = Sk.builtin.asnum$(aspect)\n        var n = Sk.builtin.asnum$(near)\n        var f = Sk.builtin.asnum$(far)\n        var k = 1.0 / (n - f);\n\n        var m = self.v;\n\n        m[0]  = t / a;\n        m[1]  = 0;\n        m[2]  = 0;\n        m[3]  = 0;\n\n        m[4]  = 0;\n        m[5]  = t;\n        m[6]  = 0;\n        m[7]  = 0;\n\n        m[8]  = 0;\n        m[9]  = 0;\n        m[10] = (n + f) * k;\n        m[11] = -1;\n\n        m[12] = 0;\n        m[13] = 0;\n        m[14] = n * f * k * 2;\n        m[15] = 0;\n      }\n    );\n\n    $loc.translate = new Sk.builtin.func(\n      function(self, translation) {\n\n        var m = self.v;\n        var t = Sk.ffi.remapToJs(translation);\n\n        m[0]  = 1;\n        m[1]  = 0;\n        m[2]  = 0;\n        m[3]  = 0;\n\n        m[4]  = 0;\n        m[5]  = 1;\n        m[6]  = 0;\n        m[7]  = 0;\n\n        m[8]  = 0;\n        m[9]  = 0;\n        m[10] = 1;\n        m[11] = 0;\n\n        m[12] = t[0];\n        m[13] = t[1];\n        m[14] = t[2];\n        m[15] = 1;\n      }\n    );\n\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var copy = [];\n      for (var i = 0; i < self.v.length; ++i) {\n        copy.push(self.v[i]);\n      }\n      return new Sk.builtin.str("[" + copy.join(\', \') + "]");\n     });\n  }, \'Matrix4x4\', []);\n\n  return mod;\n};',
    'src/builtin/sys.js': 'var $builtinmodule = function(name)\n{\n    var sys = {};\n\n    var args = [];\n    var argv = Sk.getSysArgv();\n    for (var i = 0; i < argv.length; ++i)\n        args.push(new Sk.builtin.str(argv[i]));\n    sys.argv = new Sk.builtins[\'list\'](args);\n\n    sys.copyright = Sk.builtin[\'str\']("Copyright 2009-2010 Scott Graham.\\nAll Rights Reserved.\\n");\n\n    sys.modules = Sk.sysmodules;\n\n    sys.path = Sk.realsyspath;\n\n    sys.getExecutionLimit = new Sk.builtin.func(function() {\n        return Sk.execLimit\n    });\n\n    sys.setExecutionLimit = new Sk.builtin.func(function(t) {\n        if (t !==  undefined) {\n            Sk.execLimit = t\n        }\n    });\n\n    sys.resetTimeout = new Sk.builtin.func(function() {\n        Sk.execStart = new Date();\n    });\n\n    sys.debug = new Sk.builtin.func(function() {\n        debugger;\n    });\n\n    return sys;\n};\n',
    'src/lib/pythonds/trees/balance.py': '#!/bin/env python3.1\n# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005, 2010\n# \n\nfrom .bst import BinarySearchTree, TreeNode\n\nclass AVLTree(BinarySearchTree):\n    \'\'\'\n    Author:  Brad Miller\n    Date:  1/15/2005\n    Description:  Imlement a binary search tree with the following interface\n                  functions:  \n                  __contains__(y) <==> y in x\n                  __getitem__(y) <==> x[y]\n                  __init__()\n                  __len__() <==> len(x)\n                  __setitem__(k,v) <==> x[k] = v\n                  clear()\n                  get(k)\n                  has_key(k)\n                  items() \n                  keys() \n                  values()\n                  put(k,v)\n    \'\'\'\n\n\n    def _put(self,key,val,currentNode):\n        if key < currentNode.key:\n            if currentNode.hasLeftChild():\n                self._put(key,val,currentNode.leftChild)\n            else:\n                currentNode.leftChild = TreeNode(key,val,parent=currentNode)\n                self.updateBalance(currentNode.leftChild)\n        else:\n            if currentNode.hasRightChild():\n                self._put(key,val,currentNode.rightChild)\n            else:\n                currentNode.rightChild = TreeNode(key,val,parent=currentNode)\n                self.updateBalance(currentNode.rightChild)                \n\n    def updateBalance(self,node):\n        if node.balanceFactor > 1 or node.balanceFactor < -1:\n            self.rebalance(node)\n            return\n        if node.parent != None:\n            if node.isLeftChild():\n                node.parent.balanceFactor += 1\n            elif node.isRightChild():\n                node.parent.balanceFactor -= 1\n\n            if node.parent.balanceFactor != 0:\n                self.updateBalance(node.parent)\n\n    def rebalance(self,node):\n        if node.balanceFactor < 0:\n            if node.rightChild.balanceFactor > 0:\n                # Do an LR Rotation\n                self.rotateRight(node.rightChild)\n                self.rotateLeft(node)\n            else:\n                # single left\n                self.rotateLeft(node)\n        elif node.balanceFactor > 0:\n            if node.leftChild.balanceFactor < 0:\n                # Do an RL Rotation\n                self.rotateLeft(node.leftChild)\n                self.rotateRight(node)\n            else:\n                # single right\n                self.rotateRight(node)\n\n    def rotateLeft(self,rotRoot):\n        newRoot = rotRoot.rightChild\n        rotRoot.rightChild = newRoot.leftChild\n        if newRoot.leftChild != None:\n            newRoot.leftChild.parent = rotRoot\n        newRoot.parent = rotRoot.parent\n        if rotRoot.isRoot():\n            self.root = newRoot\n        else:\n            if rotRoot.isLeftChild():\n                rotRoot.parent.leftChild = newRoot\n            else:\n                rotRoot.parent.rightChild = newRoot\n        newRoot.leftChild = rotRoot\n        rotRoot.parent = newRoot\n        rotRoot.balanceFactor = rotRoot.balanceFactor + 1 - min(newRoot.balanceFactor, 0)\n        newRoot.balanceFactor = newRoot.balanceFactor + 1 + max(rotRoot.balanceFactor, 0)\n\n\n    def rotateRight(self,rotRoot):\n        newRoot = rotRoot.leftChild\n        rotRoot.leftChild = newRoot.rightChild\n        if newRoot.rightChild != None:\n            newRoot.rightChild.parent = rotRoot\n        newRoot.parent = rotRoot.parent\n        if rotRoot.isRoot():\n            self.root = newRoot\n        else:\n            if rotRoot.isRightChild():\n                rotRoot.parent.rightChild = newRoot\n            else:\n                rotRoot.parent.leftChild = newRoot\n        newRoot.rightChild = rotRoot\n        rotRoot.parent = newRoot\n        rotRoot.balanceFactor = rotRoot.balanceFactor - 1 - max(newRoot.balanceFactor, 0)\n        newRoot.balanceFactor = newRoot.balanceFactor - 1 + min(rotRoot.balanceFactor, 0)\n        \n',
    'src/lib/urllib/request/__init__.js': 'var $builtinmodule = function(name)\n{\n  var request = {};\n\n\n  //~ Classes .................................................................\n\n  // Response class\n  //\n  // Response objects are returned by the request, get, post, etc.\n  // methods, allowing the user to access the response text, status\n  // code, and other information.\n\n  // ------------------------------------------------------------\n  var response = function($gbl, $loc) {\n\n    // ------------------------------------------------------------\n    $loc.__init__ = new Sk.builtin.func(function(self, xhr) {\n      self.data$ = xhr.responseText;\n      self.lineList = self.data$.split("\\n");\n      self.lineList = self.lineList.slice(0,-1);\n      for(var i =0 ; i < self.lineList.length; i++) {\n        self.lineList[i] = self.lineList[i]+\'\\n\';\n      }\n      self.currentLine = 0;\n      self.pos$ = 0;\n    });\n\n\n    // ------------------------------------------------------------\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      return Sk.ffi.stringToPy(\'<Response>\');\n    });\n\n\n    // ------------------------------------------------------------\n    $loc.__iter__ = new Sk.builtin.func(function(self) {\n      var allLines = self.lineList;\n\n      return Sk.builtin.makeGenerator(function() {\n          if (this.$index >= this.$lines.length) return undefined;\n          return new Sk.builtin.str(this.$lines[this.$index++]);\n        }, {\n          $obj: self,\n          $index: 0,\n          $lines: allLines\n        });\n    });\n\n\n    // ------------------------------------------------------------\n    $loc.read = new Sk.builtin.func(function(self, size) {\n      if (self.closed) throw new Sk.builtin.ValueError("I/O operation on closed file");\n      var len = self.data$.length;\n      if (size === undefined) size = len;\n      var ret = new Sk.builtin.str(self.data$.substr(self.pos$, size));\n      self.pos$ += size;\n      if (self.pos$ >= len) self.pos$ = len;\n      return ret;\n    });\n\n\n    // ------------------------------------------------------------\n    $loc.readline = new Sk.builtin.func(function(self, size) {\n      var line = "";\n      if (self.currentLine < self.lineList.length) {\n        line = self.lineList[self.currentLine];\n        self.currentLine++;\n      }\n      return new Sk.builtin.str(line);\n    });\n\n\n    // ------------------------------------------------------------\n    $loc.readlines = new Sk.builtin.func(function(self, sizehint) {\n      var arr = [];\n      for(var i = self.currentLine; i < self.lineList.length; i++) {\n        arr.push(new Sk.builtin.str(self.lineList[i]));\n      }\n      return new Sk.builtin.list(arr);\n    });\n\n  };\n\n  request.Response =\n    Sk.misceval.buildClass(request, response, \'Response\', []);\n\n\n  //~ Module functions ........................................................\n\n  // ------------------------------------------------------------\n  /**\n   * Constructs and sends a Request. Returns Response object.\n   *\n   * http://docs.python-requests.org/en/latest/api/#requests.request\n   *\n   * For now, this implementation doesn\'t actually construct a Request\n   * object; it just makes the request through jQuery.ajax and then\n   * constructs a Response.\n   */\n  request.urlopen = new Sk.builtin.func(function(url, data, timeout) {\n    var xmlhttp = new XMLHttpRequest();\n    xmlhttp.open("GET",url.v,false);\n    xmlhttp.send(null);\n\n    return Sk.misceval.callsim(request.Response,xmlhttp)\n  });\n\n\n  return request;\n};\n',
    'src/lib/pythonds/basic/queue.py': '# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n#queue.py\r\n\r\nclass Queue:\r\n    def __init__(self):\r\n        self.items = []\r\n\r\n    def isEmpty(self):\r\n        return self.items == []\r\n\r\n    def enqueue(self, item):\r\n        self.items.insert(0,item)\r\n\r\n    def dequeue(self):\r\n        return self.items.pop()\r\n\r\n    def size(self):\r\n        return len(self.items)\r\n',
    'src/lib/three/__init__.js': 'var $builtinmodule = function(namePy) {\n  var mod = {};\n  Sk.stdlib.defineThree(mod, BLADE);\n  Sk.builtin.defineGeometry(mod, THREE, Sk.ffi.remapToJs(namePy));\n  return mod;\n}\n',
    'src/lib/numpy/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineNumPy(mod);\n  return mod;\n};\n',
    'src/lib/pythonds/graphs/adjGraph.py': '#\n#  adjGraph\n#\n#  Created by Brad Miller on 2005-02-24.\n#  Copyright (c) 2005 Brad Miller, David Ranum, Luther College. All rights reserved.\n#\n\nimport sys\nimport os\nimport unittest\n\nclass Graph:\n    def __init__(self):\n        self.vertices = {}\n        self.numVertices = 0\n        \n    def addVertex(self,key):\n        self.numVertices = self.numVertices + 1\n        newVertex = Vertex(key)\n        self.vertices[key] = newVertex\n        return newVertex\n    \n    def getVertex(self,n):\n        if n in self.vertices:\n            return self.vertices[n]\n        else:\n            return None\n\n    def __contains__(self,n):\n        return n in self.vertices\n    \n    def addEdge(self,f,t,cost=0):\n            if f not in self.vertices:\n                nv = self.addVertex(f)\n            if t not in self.vertices:\n                nv = self.addVertex(t)\n            self.vertices[f].addNeighbor(self.vertices[t],cost)\n    \n    def getVertices(self):\n        return list(self.vertices.keys())\n        \n    def __iter__(self):\n        return iter(self.vertices.values())\n                \nclass Vertex:\n    def __init__(self,num):\n        self.id = num\n        self.connectedTo = {}\n        self.color = \'white\'\n        self.dist = sys.maxsize\n        self.pred = None\n        self.disc = 0\n        self.fin = 0\n\n    # def __lt__(self,o):\n    #     return self.id < o.id\n    \n    def addNeighbor(self,nbr,weight=0):\n        self.connectedTo[nbr] = weight\n        \n    def setColor(self,color):\n        self.color = color\n        \n    def setDistance(self,d):\n        self.dist = d\n\n    def setPred(self,p):\n        self.pred = p\n\n    def setDiscovery(self,dtime):\n        self.disc = dtime\n        \n    def setFinish(self,ftime):\n        self.fin = ftime\n        \n    def getFinish(self):\n        return self.fin\n        \n    def getDiscovery(self):\n        return self.disc\n        \n    def getPred(self):\n        return self.pred\n        \n    def getDistance(self):\n        return self.dist\n        \n    def getColor(self):\n        return self.color\n    \n    def getConnections(self):\n        return self.connectedTo.keys()\n        \n    def getWeight(self,nbr):\n        return self.connectedTo[nbr]\n                \n    def __str__(self):\n        return str(self.id) + ":color " + self.color + ":disc " + str(self.disc) + ":fin " + str(self.fin) + ":dist " + str(self.dist) + ":pred \\n\\t[" + str(self.pred)+ "]\\n"\n    \n    def getId(self):\n        return self.id\n\nclass adjGraphTests(unittest.TestCase):\n    def setUp(self):\n        self.tGraph = Graph()\n        \n    def testMakeGraph(self):\n        gFile = open("test.dat")\n        for line in gFile:\n            fVertex, tVertex = line.split(\'|\')\n            fVertex = int(fVertex)\n            tVertex = int(tVertex)\n            self.tGraph.addEdge(fVertex,tVertex)\n        for i in self.tGraph:\n            adj = i.getAdj()\n            for k in adj:\n                print(i, k)\n\n        \nif __name__ == \'__main__\':\n    unittest.main()\n              \n',
    'src/lib/easel/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineEasel(mod, createjs, BLADE);\n  return mod;\n}\n',
    'src/lib/json/__init__.js': 'var $builtinmodule = function(name)\n{\n    var mod = {};\n\n    var FUNCTION_PARSE     = "parse";\n    var FUNCTION_STRINGIFY = "stringify";\n\n    mod[FUNCTION_PARSE] = Sk.ffi.functionPy(function(textPy, reviverPy) {\n        Sk.ffi.checkFunctionArgs(FUNCTION_PARSE, arguments, 1, 1);\n        Sk.ffi.checkArgType("text",    Sk.ffi.PyType.STR,   Sk.ffi.isStr(textPy));\n        Sk.ffi.checkArgType("reviver", Sk.ffi.PyType.FUNCTION, Sk.ffi.isUndefined(reviverPy) || isFunction(reviverPy));\n        var text = Sk.ffi.remapToJs(textPy);\n        var reviver = Sk.ffi.remapToJs(reviverPy);\n        return Sk.ffi.remapToPy(JSON.parse(text, reviver));\n    });\n\n    mod[FUNCTION_STRINGIFY] = Sk.ffi.functionPy(function(valuePy, replacerPy, spacePy) {\n        Sk.ffi.checkFunctionArgs(FUNCTION_STRINGIFY, arguments, 1, 3);\n        Sk.ffi.checkArgType("value", Sk.ffi.PyType.DICT, Sk.ffi.isDict(valuePy));\n        Sk.ffi.checkArgType("replacer", [Sk.ffi.PyType.FUNCTION, Sk.ffi.PyType.NONE, Sk.ffi.PyType.UNDEFINED], Sk.ffi.isUndefined(replacerPy) || Sk.ffi.isNone(replacerPy) || Sk.ffi.isFunction(replacerPy));\n        Sk.ffi.checkArgType("space", [Sk.ffi.PyType.INT, Sk.ffi.PyType.UNDEFINED], Sk.ffi.isUndefined(spacePy) || Sk.ffi.isInt(spacePy));\n        var value = Sk.ffi.remapToJs(valuePy);\n        var replacer = Sk.ffi.remapToJs(replacerPy);\n        var space = Sk.ffi.remapToJs(spacePy);\n        return Sk.ffi.stringToPy(JSON.stringify(value, replacer, space));\n    });\n\n    return mod;\n}',
    'src/lib/turtle/__init__.js': '//\n//\n// Turtle Graphics Module for Skulpt\n//\n// Brad Miller\n//\n//\n//\n\n\nvar TurtleGraphics; // the single identifier needed in the global scope\n\nif (! TurtleGraphics) {\n    TurtleGraphics = { };\n}\n\n\n(function () {\n\n    // Define private constants\n\n    var Degree2Rad = Math.PI / 180.0; // conversion factor for degrees to radians\n    var Rad2Degree = 180.0 / Math.PI\n\n    //\n    // Define TurtleCanvas\n    // \n\n    function TurtleCanvas(options) {\n        this.canvasID = TurtleGraphics.defaults.canvasID;\n        if (options.canvasID) {\n            this.canvasID = options.canvasID;\n        }\n\n        this.canvas = document.getElementById(this.canvasID);\n        this.context = this.canvas.getContext(\'2d\');\n        //this.canvas.style.display = \'block\';\n        $(this.canvas).fadeIn();\n\n        this.lineScale = 1.0;\n        this.xptscale = 1.0;\n        this.yptscale = 1.0\n\n        this.llx = -this.canvas.width / 2;\n        this.lly = -this.canvas.height / 2;\n        this.urx = this.canvas.width / 2;\n        this.ury = this.canvas.height / 2;\n        this.setup(this.canvas.width,this.canvas.height);\n        TurtleGraphics.canvasInit = true;\n        this.tlist = []\n\n\t\tthis.timeFactor = 5;\n        if (TurtleGraphics.defaults.animate) {\n            this.delay = 5 * this.timeFactor;\n        } else {\n            this.delay = 0;\n        }\n        this.segmentLength = 10;\n        this.renderCounter = 1;\n        this.clearPoint = 0;\n        TurtleGraphics.canvasLib[this.canvasID] = this;\n\t\tSk.tg.fadeOnExit = true;\t//\tThis can be set to false AFTER the program completes to turn off the fade out on the canvas as a result of exitonclick\n    }\n\n    TurtleCanvas.prototype.setup = function(width, height) {\n        this.canvas.width = width;\n        this.canvas.height = height;\n        this.lineScale = 1.0;\n        this.xptscale = 1.0;\n        this.yptscale = 1.0;\n\n        this.llx = -this.canvas.width / 2;\n        this.lly = -this.canvas.height / 2;\n        this.urx = this.canvas.width / 2;\n        this.ury = this.canvas.height / 2;\n        this.renderCounter = 1;\n        this.clearPoint = 0;\n\t\tthis.timeFactor = 5;\n        if (TurtleGraphics.defaults.animate ) {\n            this.delay = 5 * this.timeFactor;\n        } else {\n            this.delay = 0;\n        }\n\n        if (TurtleGraphics.canvasInit == false) {\n            this.context.save();\n            this.context.translate(this.canvas.width / 2, this.canvas.height / 2); // move 0,0 to center.\n            this.context.scale(1, -1); // scaling like this flips the y axis the right way.\n            TurtleGraphics.canvasInit = true;\n            TurtleGraphics.eventCount = 0;\n            TurtleGraphics.renderClock = 0;\n            TurtleGraphics.renderTime = 0;\t// RNL\n        } else {\n            this.context.restore();\n            this.context.translate(this.canvas.width / 2, this.canvas.height / 2); // move 0,0 to center.\n            this.context.scale(1, -1); // scaling like this flips the y axis the right way.\n            this.context.clearRect(-this.canvas.width / 2, -this.canvas.height / 2,\n                                    this.canvas.width, this.canvas.height);\n        }\n    }\n    TurtleCanvas.prototype.addToCanvas = function(t) {\n\t        this.tlist.push(t);\n    }\n\n    TurtleCanvas.prototype.onCanvas = function(t) {\n        return (this.tlist.indexOf(t) >= 0);\n    }\n\n    TurtleCanvas.prototype.isAnimating = function() {\n        return (this.tlist.length > 0)\n    }\n\n    TurtleCanvas.prototype.startAnimating = function(t) {\n\t\tif (! this.isAnimating()) {\n        \tthis.intervalId = setTimeout(render, this.delay);\t//\tsetInterval(render, this.delay);\n\t\t}\n    \tif (!this.onCanvas(t))\t//\tAdded by RNL in case startAnimating is called after it\'s already been added\n       \t\tthis.addToCanvas(t);\n        Sk.isTurtleProgram = true;\n    }\n\n    TurtleCanvas.prototype.doneAnimating = function(t) {\n        this.tlist.splice(0,this.tlist.length)\n        clearTimeout(this.intervalId)   \n        $(Sk.runButton).removeAttr(\'disabled\');\n    }\n\n    TurtleCanvas.prototype.cancelAnimation = function() {\n        if (this.intervalId) {\n            clearTimeout(this.intervalId)\t//\tclearInterval(this.intervalId);\n        }\n\n        for (var t in this.tlist) {\n            this.tlist[t].aCount = this.tlist[t].drawingEvents.length - 1;\n        }\n        render();\n    }\n\n    TurtleCanvas.prototype.setSpeedDelay = function(s) {\t// RNL\n        var df = 10 - (s % 11) + 1;\n        this.delay = df * this.timeFactor;\t//\tRNL was 10;\n    }\n\n    TurtleCanvas.prototype.setDelay = function(d) {\n        this.delay = d;\n    }\n\n    TurtleCanvas.prototype.getDelay = function(s) { // RNL\n        return this.delay;\n    }\n\n    TurtleCanvas.prototype.setCounter = function(s) {\n\t\tif (!s || s <= 0)\t//\tDon\'t let this be less than 1\n\t\t\ts = 1;\n        this.renderCounter = s;\n    }\n\n    TurtleCanvas.prototype.getCounter = function() {\n        return this.renderCounter;\n    }\n\n    TurtleCanvas.prototype.setworldcoordinates = function(llx, lly, urx, ury) {\n        this.context.restore();\n        this.context.scale(this.canvas.width / (urx - llx), -this.canvas.height / (ury - lly));\n        if (lly == 0)\n            this.context.translate(-llx, lly - (ury - lly));\n        else if (lly > 0)\n            this.context.translate(-llx, -lly * 2);\n        else\n            this.context.translate(-llx, -ury);\n\n        var xlinescale = (urx - llx) / this.canvas.width;\n        var ylinescale = (ury - lly) / this.canvas.height;\n        this.xptscale = xlinescale;\n        this.yptscale = ylinescale;\n        this.lineScale = Math.min(xlinescale,ylinescale)\n        this.context.save();\n\n        this.llx = llx;\n        this.lly = lly;\n        this.urx = urx;\n        this.ury = ury;\n\n    }\n\n    TurtleCanvas.prototype.window_width = function() {\n        return this.canvas.width;\n    }\n\n    TurtleCanvas.prototype.window_height = function() {\n        return this.canvas.height;\n    }\n\n    TurtleCanvas.prototype.bgcolor = function(c) {\n        this.background_color = c;\n        //this.canvas.style.setProperty("background-color", c.v);\n        $(this.canvas).css("background-color",c.v);\n    }\n\n    TurtleCanvas.prototype.setSegmentLength = function(s) {\n        this.segmentLength = s;\n    }\n\n    TurtleCanvas.prototype.getSegmentLength = function() {\n        return this.segmentLength;\n    }\n    \n    // todo: if animating, this should be deferred until the proper time\n    TurtleCanvas.prototype.exitonclick = function () {\n        var canvas_id = this.canvasID;\n        var theCanvas = this;\n        $(this.canvas).click(function() {\n            if (! theCanvas.isAnimating()) {\n\t\t\t\tif (Sk.tg.fadeOnExit)\t//\tLet\'s this be configurable\n                \t$("#"+canvas_id).hide();\n                $("#"+canvas_id).unbind(\'click\');\n                Sk.tg.canvasInit = false;\n                delete Sk.tg.canvasLib[canvas_id];\n            }\n        });\n    }\n\n    TurtleCanvas.prototype.turtles = function() {\n        return TurtleGraphics.turtleList;\n    }\n\n\tTurtleCanvas.prototype.tracer = function(t, d) {\t//\tNew version NOT attached to a turtle (as per real turtle)\n        this.setCounter(t);\n\t\tif (t == 0) {\n\t\t\tfor (var i in this.turtleList)\n\t\t\t\tthis.turtleList[i].animate = false;\n\t\t\tthis.cancelAnimation();\n\t\t}\n\t\tif (d !== undefined)\n\t\t\tthis.setDelay(d);\n\t}\n\n    // check if all turtles are done\n    allDone = function() {\n        var allDone = true;\n        for (var tix in TurtleGraphics.turtleList) {\n            var theT = TurtleGraphics.turtleList[tix];\n            allDone = allDone && (theT.aCount >= theT.drawingEvents.length);\n        }\n        return allDone;\n    }\n    //\n    //  This is the function that provides the animation\n    //\n    render = function () {\n        var context = document.getElementById(TurtleGraphics.defaults.canvasID).getContext(\'2d\');\n        with (context) {\n            with (TurtleGraphics.canvasLib[TurtleGraphics.defaults.canvasID]) {\n                clearRect(llx, lly, (urx - llx), (ury - lly));\n                //canvas.style.setProperty("background-color",TurtleGraphics.turtleCanvas.bgcolor.v);\n            }\n            var incr = TurtleGraphics.canvasLib[TurtleGraphics.defaults.canvasID].getCounter();\n            var lastCanvas = null\n\n            TurtleGraphics.renderClock += incr;\n\n            for (var tix in TurtleGraphics.turtleList) {\n                var t = TurtleGraphics.turtleList[tix]\n                lastCanvas = t.turtleCanvas \n                if (t.aCount >= t.drawingEvents.length)\n                    t.aCount = t.drawingEvents.length - 1;\n                moveTo(0, 0);\n                var currentPos = new Vector(0,0,0);\n                var currentHead = new Vector(1,0,0);\n                lineWidth = t.get_pen_width();\n                lineCap = \'round\';\n                lineJoin = \'round\';\n                strokeStyle = \'black\';\n                var filling = false;\n                if (isNaN(t.turtleCanvas.delay))\n                \tt.turtleCanvas.delay = 0\n//\t\t\t\tconsole.log(tix + " : " + t.clearPoint + " to " + t.aCount)\n                for (var i = t.clearPoint; (i <= t.aCount || t.turtleCanvas.delay == 0) && i < t.drawingEvents.length; i++) {\n                \tif (i > t.aCount)\t//\tIf se jump past aCount, jump it ahead\n                \t\tt.aCount = i\n                    var oper = t.drawingEvents[i];\n                    var ts = oper[oper.length-1];\n//\t\t\t\t\tconsole.log(i + "/" + ts + oper [0] + "{" + oper [1] + "}" + t.turtleCanvas.delay)\n                    if (ts <= TurtleGraphics.renderClock || t.turtleCanvas.delay == 0) {\n                    \tif (ts > TurtleGraphics.renderClock)\t//\tIf we go past the render clock, jump it ahead\n                    \t\tTurtleGraphics.renderClock = ts\n//\t\t\t\t\t\tconsole.log("<==")\n                        if (oper[0] == "LT") {  //  line to\n                            if (! filling) {\n                                beginPath();\n                                moveTo(oper[1], oper[2]);\n                            }\n                            lineTo(oper[3], oper[4]);\n                            strokeStyle = oper[5];\n                            stroke();\n                            currentPos = new Vector(oper[3],oper[4],0);\n                            if (! filling)\n                                closePath();\n                        }\n                        else if (oper[0] == "MT") {  // move to\n                            moveTo(oper[3], oper[4]);\n                            currentPos = new Vector(oper[3],oper[4],0);\n                        }\n                        else if (oper[0] == "BF") {  // begin fill\n                            beginPath();\n                            moveTo(oper[1], oper[2]);\n                            filling = true;\n                        }\n                        else if (oper[0] == "EF") {  // end fill\n                            fillStyle = oper[3];\n                            stroke();\n                            fill();\n                            closePath();\n                            filling = false;\n                        }\n                        else if (oper[0] == "FC") {  // fill color\n                            fillStyle = oper[1];\n                        }\n                        else if (oper[0] == "TC") {  // turtle color\n                            strokeStyle = oper[1];\n                        }\n                        else if (oper[0] == "PW") {  // Pen width\n                            lineWidth = oper[1];\n                        }\n                        else if (oper[0] == "DT") {  // Dot\n                            var col = fillStyle;\n                            fillStyle = oper[2];\n                            var size = oper[1];\n                            fillRect(oper[3] - size / 2, oper[4] - size / 2, size, size);\n                            fillStyle = col;\n                        }\n                        else if (oper[0] == "CI") {  // Circle\n                            if (!filling)\n\t\t\t\t\t\t\t\tbeginPath();\n                            arc(oper[1], oper[2], oper[3], oper[4], oper[5], oper[6]);\n                            currentPos = new Vector(oper[1]+Sk.math.cos(oper[5])*oper[3],\n                                oper[2]+Sk.math.sin(oper[5])*oper[3],0);\n                            stroke();\n                            if (! filling) {\n                                closePath();\n                            }\n                        }\n                        else if (oper[0] == "WT") { // write\n                            if (font)\n                                font = oper[2];\n                            scale(1, -1);\n                            fillText(oper[1], oper[3], -oper[4]);\n                            scale(1, -1);\n                        } else if (oper[0] == "ST") {  // stamp\n                            t.drawturtle(oper[3], new Vector(oper[1], oper[2], 0));\n                        } else if (oper[0] == "HT") { // hide turtle\n                            t.visible = false;\n                        } else if (oper[0] == "SH") { // show turtle\n                            t.visible = true;\n                        } else if (oper[0] == "TT") {\n                            currentHead = oper[1];\n                        } else if (oper[0] == "CL") { // RNL clear\n                        \tclear_canvas(t.canvasID);\n                        \tt.clearPoint = i;\t// Different from reset that calls clear because it leaves the turtles where they are\n                        } else if (oper[0] == "DL") { // RNL delay\n                        \tvar df = oper[1]\n//                      \tconsole.log("animated delay set " + df)\n                        \tt.turtleCanvas.delay = df\n                        } else if (oper[0] == "SC") { // RNL speed change\n                        \tvar s = oper[1]\n                        \tif (s < 0)\n                        \t\ts = 0\n                        \tif (s > 10)\n                        \t\ts = 10\n       \t\t\t\t\t\tvar df = (10 - (s % 11) + 1) * t.turtleCanvas.timeFactor\t//\t10\n       \t\t\t\t\t\tif (s == 0) {\n       \t\t\t\t\t\t\tdf = 0\n       \t\t\t\t\t\t}\n\t                        //\tt.turtleCanvas.intervalId = clearInterval(t.turtleCanvas.intervalId);\n\t       \t\t\t\t\tt.turtleCanvas.delay = df;\n\t       \t\t\t\t\t//\tt.turtleCanvas.intervalId = setInterval(render, t.turtleCanvas.delay)\n       \t\t\t\t\t\tif (oper[2]) {\n       \t\t\t\t\t\t\tt.turtleCanvas.setSegmentLength(oper[2]);\n       \t\t\t\t\t\t}\n       \t\t\t\t\t} else if (oper[0] == "NO") { // RNL no op                \t\n                        } else {\n\t\t\t\t\t\t\tconsole.log("unknown op: " + oper[0]);\n                        } // end of oper[0] test\n                    } // end of if ts < render clock\n                } // end of for\n//\t\t\t\tconsole.log(TurtleGraphics.renderClock + " / " + t.aCount)\n//\t\t\t\tconsole.log("------------------------------")\n                t.aCount += incr;\n                if (t.visible) {\n                    // draw the turtle\n                    t.drawturtle(currentHead.toAngle(), currentPos); // just use currentHead\n                }\n            }\n            //if (t.aCount >= t.drawingEvents.length) {\n            if (TurtleGraphics.renderClock > TurtleGraphics.eventCount ){ // && allDone() ){\n//              t.turtleCanvas.doneAnimating(t);\n//\t\t\t\tconsole.log("done animating")\n                if (lastCanvas) lastCanvas.doneAnimating(t);\n            } else {\n//    \t\t\tt.turtleCanvas.intervalId = setTimeout(render, t.turtleCanvas.delay)\n    \t\t\tif (lastCanvas) {\n    \t\t\t\tlastCanvas.intervalId = setTimeout(render, lastCanvas.delay)\n    \t\t\t}\n            }\n        }\n    }\n\n\n\n    // Constructor for Turtle objects\n    function Turtle() {\n        if (arguments.length >= 1) {\n            this.initialize(arguments[0]);\n        }\n        else {\n            this.initialize();\n        }\n        TurtleGraphics.turtleList.push(this);\n    }\n\n\n    Turtle.prototype.go_home = function () {\n        // Put turtle in initial state\n        // turtle is headed to the right\n        // with location 0,0,0 in the middle of the canvas.\n        // x grows to the right\n        // y grows towards the top of the canvas\n        with (this) {\n            position = home;\n            context.moveTo(home[0], home[1]);\n            heading = new Vector([1.0, 0.0, 0.0]); // to the right; in turtle space x+ direction\n            normal = new Vector([0.0, 0.0, -1.0]); // in z- direction\n        }\n    };\n\n    Turtle.prototype.initialize = function () {\n        // Initialize the turtle.\n        var options = { };\n\n        if (arguments.length >= 1) {\n            options = arguments[0];\n        }\n\n        this.canvasID = TurtleGraphics.defaults.canvasID;\n        if (options.canvasID) {\n            this.canvasID = options.canvasID;\n        }\n        this.context = document.getElementById(this.canvasID).getContext(\'2d\');\n\n        this.animate = TurtleGraphics.defaults.animate;\n\n        with (this.context) {\n            if (TurtleGraphics.canvasInit == false) {   // This is a workaround until I understand skulpt re-running better\n                // the downside is that this limits us to a single turtle...\n                save();\n                translate(canvas.width / 2, canvas.height / 2); // move 0,0 to center.\n                scale(1, -1); // scaling like this flips the y axis the right way.\n                if (! TurtleGraphics.canvasLib[this.canvasID]) {\n                    TurtleGraphics.canvasLib[this.canvasID] = new TurtleCanvas(options);\n                }\n                TurtleGraphics.canvasInit = true;\n            } else {\n                clear_canvas(this.canvasID);\n            }\n\n            this.turtleCanvas = TurtleGraphics.canvasLib[this.canvasID];\n            this.home = new Vector([0.0, 0.0, 0.0]);\n            this.visible = true;\n            this.shapeStore = {};\n            this.shapeStore[\'turtle\'] = turtleShapePoints();\n            this.shapeStore[\'arrow\'] = defaultShapePoints();\n            this.shapeStore[\'circle\'] = circleShapePoints();\n            this.shapeStore[\'square\'] = squareShapePoints();\n            this.shapeStore[\'triangle\'] = triangleShapePoints();\n            this.shapeStore[\'blank\'] = [new Vector(0,0)];\n            this.shapeStore[\'classic\'] = classicShapePoints();\n            this.currentShape = \'classic\';\n            this.drawingEvents = [];\n\n            this.filling = false;\n            this.pen = true;\n            this.penStyle = \'black\';\n            this.penWidth = 2;\n            this.fillStyle = \'black\';\n            this.position = [ ];\n            this.heading = [ ];\n            this.normal = [ ];\n            this.go_home();\n            this.aCount = 0;\n            this.clearPoint = 0;\t// RNL for clear/clearScreen\n        }\n    }\n    function turtleShapePoints() {\n        var pl = [\n            [0,16],\n            [-2,14],\n            [-1,10],\n            [-4,7],\n            [-7,9],\n            [-9,8],\n            [-6,5],\n            [-7,1],\n            [-5,-3],\n            [-8,-6],\n            [-6,-8],\n            [-4,-5],\n            [0,-7],\n            [4,-5],\n            [6,-8],\n            [8,-6],\n            [5,-3],\n            [7,1],\n            [6,5],\n            [9,8],\n            [7,9],\n            [4,7],\n            [1,10],\n            [2,14]\n        ];\n        res = [];\n        for (p in pl) {\n            res.push(new Vector(pl[p]));\n        }\n        return res;\n    }\n\n    function defaultShapePoints() {\n        var pl = [\n            [-10,0],\n            [10,0],\n            [0,10]\n        ];\n        res = [];\n        for (p in pl) {\n            res.push(new Vector(pl[p]));\n        }\n        return res;\n    }\n\n    function circleShapePoints() {\n        var pl = [\n            [10,0],\n            [9.51,3.09],\n            [8.09,5.88],\n            [5.88,8.09],\n            [3.09,9.51],\n            [0,10],\n            [-3.09,9.51],\n            [-5.88,8.09],\n            [-8.09,5.88],\n            [-9.51,3.09],\n            [-10,0],\n            [-9.51,-3.09],\n            [-8.09,-5.88],\n            [-5.88,-8.09],\n            [-3.09,-9.51],\n            [-0.00,-10.00],\n            [3.09,-9.51],\n            [5.88,-8.09],\n            [8.09,-5.88],\n            [9.51,-3.09]\n        ];\n        res = [];\n        for (p in pl) {\n            res.push(new Vector(pl[p]));\n        }\n        return res;\n    }\n\n    function triangleShapePoints() {\n        var pl = [\n            [10,-5.77],\n            [0,11.55],\n            [-10,-5.77]\n        ];\n\n        res = [];\n        for (p in pl) {\n            res.push(new Vector(pl[p]));\n        }\n        return res;\n\n    }\n\n    function squareShapePoints() {\n        var pl = [\n            [10,-10],\n            [10,10],\n            [-10,10],\n            [-10,-10]\n        ];\n\n        res = [];\n        for (p in pl) {\n            res.push(new Vector(pl[p]));\n        }\n        return res;\n\n    }\n\n    function classicShapePoints() {\n        var pl = [\n            [0,0],\n            [-5,-9],\n            [0,-7],\n            [5,-9]\n        ];\n\n        res = [];\n        for (p in pl) {\n            res.push(new Vector(pl[p]));\n        }\n        return res;\n\n    }\n\n    Turtle.prototype.clean = function () {\n        // Clean the canvas\n        // Optional second argument is color\n        with (this) {\n            if (arguments.length >= 1) {\n                clear_canvas(canvasID, arguments[0]);\n            }\n            else {\n                clear_canvas(canvasID);\n            }\n            initialize();\n        }\n    }\n\n    Turtle.prototype.addDrawingEvent = function(eventList) {\n        TurtleGraphics.eventCount += 1;\n        eventList.push(TurtleGraphics.eventCount);\n        this.drawingEvents.push(eventList);\n    }\n//  \n//  Drawing Functions\n//\n\n    // break a line into segments\n    // sp:  Vector of starting position\n    // ep:  Vector of ending position\n    // sl:  int length of segments\n    segmentLine = function(sp, ep, sL, pen) {\n        var head = ep.sub(sp).normalize();\n        var numSegs = Math.floor(ep.sub(sp).len() / sL);\n        var res = [];\n        var oldp = sp;\n        var newp;\n        var op = ""\n        if (pen)\n            op = "LT"\n        else\n            op = "MT"\n        for (var i = 0; i < numSegs; i++) {\n            newp = oldp.linear(1, sL, head);\n            res.push([op,oldp[0],oldp[1],newp[0],newp[1]]);\n            oldp = newp;\n        }\n        if (! ((oldp[0] == ep[0]) && (oldp[1] == ep[1])))\n            res.push([op, oldp[0], oldp[1], ep[0], ep[1]]);\n        return res;\n    }\n\n    Turtle.prototype.draw_line = function(newposition) {\n        with (this) {\n            with (context) {\n                if (! animate) {\n                    if (! filling) {\n                        beginPath();\n                        moveTo(position[0], position[1]);\n                    }\n                    lineCap = \'round\';\n                    lineJoin = \'round\';\n                    lineWidth = get_pen_width();\n                    strokeStyle = penStyle;\n                    lineTo(newposition[0], newposition[1]);\n                    stroke();\n                    if (! filling)\n                        closePath();\n                } else {\n                    var r = segmentLine(position, newposition, turtleCanvas.getSegmentLength(), pen);\n                    for (var s in r) {\n                        r[s].push(penStyle);\n                        addDrawingEvent(r[s]);\n                    }\n                    if (! turtleCanvas.isAnimating()) {\n                        turtleCanvas.startAnimating(this);\n                    } else {\n                        if (! turtleCanvas.onCanvas(this))\n                            turtleCanvas.addToCanvas(this);\n                    }\n                }\n            }\n        }\n\n    }\n\n\n    Turtle.prototype.forward = function (d) {\n        with (this) {\n            var newposition = position.linear(1, d, heading);\n            goto(newposition);\n        }\n    }\n\n    Turtle.prototype.backward = function(d) {\n        this.forward(-d);\n    }\n\n//\tThis is an internal function that sets the position without doing any drawing\n    Turtle.prototype.teleport_to = function(nx, ny) {\n        if (nx instanceof Vector)\n            var newposition = nx;\n        else\n            var newposition = new Vector([nx,ny,0]);\n        this.context.moveTo(newposition[0], newposition[1]);\n\t\tthis.position = newposition;\n\t}\n\n    Turtle.prototype.goto = function(nx, ny) {\n        if (nx instanceof Vector)\n            var newposition = nx;\n        else\n            var newposition = new Vector([nx,ny,0]);\n        with (this) {\n            if (pen) {\n                draw_line(newposition);\n            } else {\n                if (! animate) {\n                    context.moveTo(newposition[0], newposition[1]);\n                } else {\n                    var r = segmentLine(position, newposition, turtleCanvas.getSegmentLength(), pen);\n                    for (var s in r)\n                        addDrawingEvent(r[s]);\n                    if (! turtleCanvas.isAnimating()) {\n                        turtleCanvas.startAnimating(this);\n                    } else {\n                        if (! turtleCanvas.onCanvas(this))\n                            turtleCanvas.addToCanvas(this);\n                    }\n                }\n            }\n            position = newposition;\n\n        }\n    }\n\n    Turtle.prototype.delay = function(d) {\t// RNL\n    \tif (d != null) {\n    \t\tif (d < 0)\n    \t\t\td = -d\n    \t\tif (!this.animate) \n    \t\t\tthis.turtleCanvas.setDelay(d)\n    \t\telse {\n    \t\t\tthis.turtleCanvas.setDelay(d)\n\t    \t\tthis.addDrawingEvent(["DL", d])\n\t    \t\tthis.addDrawingEvent(["NO"])\n    \t\t}\n    \t}\n        return this.turtleCanvas.getDelay();\n    }\n\n    Turtle.prototype.speed = function(s,t) {\n        if (s > 0 && !this.animate) {\n            this.animate = true;\n            this.turtleCanvas.setSpeedDelay(s)\n        } else if (s == 0 && !this.animate) {\n        \tthis.turtleCanvas.setSpeedDelay(s)\n        } else {\n//          this.animate = false;\n//          this.turtleCanvas.cancelAnimation();\n\t\t\tthis.addDrawingEvent(["SC", s, t])\n\t\t\tthis.addDrawingEvent(["NO"])\n        }\n        if (t) {\n            this.turtleCanvas.setSegmentLength(t);\n            // set the number of units to divide a segment into\n        } else {\n            this.turtleCanvas.setSegmentLength(10);\n        }\n    }\n\n    Turtle.prototype.tracer = function(t, d) {\n        this.turtleCanvas.setCounter(t);\n\t\tif (t == 0) {\n\t\t\tthis.animate=false;\n\t\t\tthis.turtleCanvas.cancelAnimation();\n\t\t}\n\t\tif (d !== undefined)\n\t\t\tthis.turtleCanvas.setDelay(d);\n    }\n\n    Turtle.prototype.getRenderCounter = function() {\n        return this.turtleCanvas.getCounter();\n    }\n\n    Turtle.prototype.turn = function (phi) {\n        with (this) {\n            var alpha = phi * Degree2Rad;\n            var left = normal.cross(heading);\n            var newheading = heading.rotateNormal(left, normal, alpha);\n            heading = newheading;\n\n            if (animate) {\n                addDrawingEvent(["TT",heading]);\n            }\n        }\n    }\n\n    Turtle.prototype.right = Turtle.prototype.turn;\n\n    Turtle.prototype.left = function(phi) {\n        this.turn(-phi);\n    }\n\n    Turtle.prototype.get_heading = function () {\n        if (TurtleGraphics.defaults.degrees)\n            return this.heading.toAngle()\n        else\n            return this.heading\n    }\n\n    Turtle.prototype.get_position = function () {\n        return this.position;\n    }\n\n    Turtle.prototype.getx = function () {\n        return this.position[0];\n    }\n\n    Turtle.prototype.gety = function () {\n        return this.position[1];\n    }\n\n    Turtle.prototype.set_heading = function(newhead) {\n        if ((typeof(newhead)).toLowerCase() === \'number\') {\n            this.heading = Vector.angle2vec(newhead);\n        } else {\n            this.heading = newhead;\n        }\n    }\n\n    Turtle.prototype.towards = function(to, y) {\n        // set heading vector to point towards another point.\n        if ((typeof(to)).toLowerCase() === \'number\')\n            to = new Vector(to, y, 0);\n        else if (! (to instanceof Vector)) {\n            to = new Vector(to);\n        }\n        var res = to.sub(this.position);\n        res = res.normalize();\n        if (TurtleGraphics.defaults.degrees) {\n            return res.toAngle();\n        }\n        else {\n            return res;\n        }\n    }\n\n    Turtle.prototype.distance = function(to, y) {\n        if ((typeof(to)).toLowerCase() === \'number\')\n            to = new Vector(to, y, 0);\n        return this.position.sub(new Vector(to)).len();\n    }\n\n    Turtle.prototype.dot = function() {\n        var size = 2;\n        if (arguments.length >= 1) size = arguments[0];\n        size = size * this.turtleCanvas.lineScale;\n        with (this) {\n            with (context) {\n                var color = penStyle;\n                var nc = arguments[1] || color;\n                if (! animate) {\n                    fillStyle = nc;\n                    fillRect(position[0] - size / 2, position[1] - size / 2, size, size);\n                    fillStyle = color;\n                } else {\n                    addDrawingEvent(["DT", size, nc, position[0], position[1]]);\n                }\n            }\n        }\n\n    }\n\n    Turtle.prototype.circle = function(radius, extent) {\n        if (extent === undefined) {\n            extent = 360\n        }\n\t\tif (this.animate) {\n\t\t\tvar arcLen = Math.abs(radius * Math.PI * 2.0  * extent / 360);\n\t\t\tvar segLen = this.turtleCanvas.getSegmentLength();\n\t\t\tif (arcLen <= segLen)\n\t\t\t\tthis.arc(radius,extent);\n\t\t\telse {\n\t\t\t\t//\tBreak the arc into segments for animation\n\t\t\t\tvar extentPart = (segLen / arcLen) * extent;\n\t\t\t\tvar extentLeft = extent;\n\t\t\t\twhile (Math.abs(extentLeft) > Math.abs(extentPart)) {\n\t\t\t\t\tthis.arc(radius, extentPart);\n\t\t\t\t\textentLeft = extentLeft - extentPart;\n\t\t\t\t}\n\t\t\t\tif (Math.abs(extentLeft) > 0.01)\n\t\t\t\t\tthis.arc(radius, extentLeft);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.arc(radius,extent);\n\t\t}\n\t}\n\t\n    Turtle.prototype.arc = function(radius, extent) {\n\t\t//\tFigure out where the turtle is and which way it\'s facing\n\t\tvar turtleHeading = this.get_heading()\n\t\tvar tx = this.position[0]\n\t\tvar ty = this.position[1]\n\n\t\t//\tFigure out the circle center\n\t\tvar cx = tx + (radius * Sk.math.cos((turtleHeading + 90) * Degree2Rad));\n\t\tvar cy = ty + (radius * Sk.math.sin((turtleHeading + 90) * Degree2Rad));\n\n\t\t//\tCanvas arc angles go CLOCKWISE, not COUNTERCLOCKWISE like Turtle\n\n\t\t//\tFigure out our arc angles\n\t\tvar startAngleDeg;\n\t\tif (radius >= 0)\n\t\t\tstartAngleDeg = turtleHeading - 90;\n\t\telse\n\t\t\tstartAngleDeg = turtleHeading + 90;\n\n\t\tvar endAngleDeg;\n        if (extent) {\n\t\t\tif (radius >= 0)\n\t            endAngleDeg = startAngleDeg + extent;\n\t\t\telse\n\t            endAngleDeg = startAngleDeg - extent;\n        } else {\n\t\t\tif (radius >= 0)\n\t            endAngleDeg = startAngleDeg + 360;\n\t\t\telse\n\t\t\t\tendAngleDeg = startAngleDeg - 360;\n\t\t}\n\n\t\t//\tCanvas angles are opposite\n\t\tstartAngleDeg = 360 - startAngleDeg\n\t\tendAngleDeg   = 360 - endAngleDeg\n\n\t\t//\tBecuase the y axis has been flipped in HTML5 Canvas with a tanslation, we need to adjust the angles\n\t\tstartAngleDeg = -startAngleDeg\n\t\tendAngleDeg   = -endAngleDeg\n\n\t\t//\tConvert to radians\n\t\tvar startAngle = startAngleDeg * Degree2Rad;\n\t\tvar endAngle   = endAngleDeg   * Degree2Rad;\n\n\n\t\t//\tDo the drawing\n        if (! this.animate) {\n\t\t\tif (!this.filling)\n\t\t\t\tthis.context.beginPath();\n            this.context.arc(cx, cy, Math.abs(radius), startAngle, endAngle, (radius * extent <= 0));\n            this.context.stroke();\n\t\t\tif (!this.filling)\n\t\t\t\tthis.context.closePath();\n        } else {\n            this.addDrawingEvent(["CI", cx, cy, Math.abs(radius), startAngle, endAngle, (radius * extent <= 0)]);\n        }\n\n\t\t//\tMove the turtle only if we have to\n\t\tif (extent && (extent % 360) != 0) {\n\t\t\tvar turtleArc;\n\t\t\tif (radius >= 0)\n\t\t\t\tturtleArc = extent;\n\t\t\telse \n\t\t\t\tturtleArc = -extent;\n\t\t\tvar newTurtleHeading = (turtleHeading + turtleArc) % 360;\n\t\t\tif (newTurtleHeading < 0)\n\t\t\t\tnewTurtleHeading = newTurtleHeading + 360;\n\n\t\t\tvar nx = cx + (radius * Sk.math.cos((newTurtleHeading - 90) * Degree2Rad));\n\t\t\tvar ny = cy + (radius * Sk.math.sin((newTurtleHeading - 90) * Degree2Rad));\t//\ty coord is inverted in turtle\n\n\t\t\t//\tMove it internally\n\t\t\tthis.set_heading(newTurtleHeading);\n\t\t\tthis.teleport_to(nx,ny);\n\n\t\t\t//\tIf we\'re animating the turtle, move it on the screen\n\t\t\tif (this.animate) {\n\t\t\t\tthis.addDrawingEvent(["TT", this.heading]);\n\t\t\t}\n\t\t}\n\n    }\n\n    Turtle.prototype.write = function(theText, move, align, font) {\n        if (! this.animate) {\n            if (font)\n                this.context.font = font.v;\n            this.context.scale(1, -1);\n            this.context.fillText(theText, this.position[0], -this.position[1]);\n            this.context.scale(1, -1);\n        } else {\n            var fontspec;\n            if (font)\n                fontspec = font.v\n            this.addDrawingEvent(["WT", theText, fontspec, this.position[0], this.position[1]]);\n        }\n    }\n\n    Turtle.prototype.setworldcoordinates = function(llx, lly, urx, ury) {\n        this.turtleCanvas.setworldcoordinates(llx, lly, urx, ury);\n    }\n\n//\n// Pen and Style functions\n//\n    Turtle.prototype.pen_down = function () {\n        this.pen = true;\n    }\n\n    Turtle.prototype.down = Turtle.prototype.pen_down;\n\n    Turtle.prototype.pen_up = function () {\n        this.pen = false;\n    }\n\n    Turtle.prototype.up = Turtle.prototype.pen_up;\n\n    Turtle.prototype.get_pen = function () {\n        return this.pen;\n    }\n\n    Turtle.prototype.set_pen_width = function (w) {\n        if (this.animate)\n            this.addDrawingEvent(["PW", w * this.turtleCanvas.lineScale]);\n        else\n            this.penWidth = w;\n    }\n\n    Turtle.prototype.get_pen_width = function() {\n        return this.penWidth * this.turtleCanvas.lineScale;\n    }\n\n    Turtle.prototype.set_pen_color = function (c, g, b) {\n        if (typeof(c) == "string") {\n            this.penStyle = c;\n        } else {\n        \tvar rs\n        \tvar gs\n        \tvar bs\n        \tif (typeof( c) == "object" && c.length == 3) {\n\t\t\t\tvar c0 = Sk.builtin.asnum$(c[0]);\n\t\t\t\tvar c1 = Sk.builtin.asnum$(c[1]);\n\t\t\t\tvar c2 = Sk.builtin.asnum$(c[2]);\n        \t} else {\n                var c0 = Sk.builtin.asnum$(c);\n                var c1 = Sk.builtin.asnum$(g);\n                var c2 = Sk.builtin.asnum$(b);\n        \t}\n            rs = c0.toString(16);\n            gs = c1.toString(16);\n            bs = c2.toString(16);\n            while (rs.length < 2) rs = "0" + rs;\n            while (gs.length < 2) gs = "0" + gs;\n            while (bs.length < 2) bs = "0" + bs;\n            c = "#" + rs + gs + bs;\n            this.penStyle = c;\n        }\n\n        this.context.strokeStyle = c;\n        if (this.animate)\n            this.addDrawingEvent(["TC", c]);\n    }\n\n    Turtle.prototype.set_fill_color = function (c, g, b) {\n        if (typeof(c) == "string") {\n            this.fillStyle = c;\n        } else {\n        \tvar rs\n        \tvar gs\n        \tvar bs\n        \tif (typeof( c) == "object" && c.length == 3) {\n\t\t\t\tvar c0 = Sk.builtin.asnum$(c[0]);\n\t\t\t\tvar c1 = Sk.builtin.asnum$(c[1]);\n\t\t\t\tvar c2 = Sk.builtin.asnum$(c[2]);\n        \t} else {\n                var c0 = Sk.builtin.asnum$(c);\n                var c1 = Sk.builtin.asnum$(g);\n                var c2 = Sk.builtin.asnum$(b);\n        \t}\n            rs = c0.toString(16)\n            gs = c1.toString(16)\n            bs = c2.toString(16)\n            while (rs.length < 2) rs = "0" + rs;\n            while (gs.length < 2) gs = "0" + gs;\n            while (bs.length < 2) bs = "0" + bs;\n            c = "#" + rs + gs + bs;\n            this.fillStyle = c;\n        }\n\n        this.context.fillStyle = c;\n        if (this.animate)\n            this.addDrawingEvent(["FC", c]);\n    }\n\n    Turtle.prototype.begin_fill = function () {\n        if (! this.animate) {\n            this.filling = true;\n            this.context.beginPath();\n            this.context.moveTo(this.position[0], this.position[1]);\n        } else\n            this.addDrawingEvent(["BF", this.position[0], this.position[1]]);\n\n    }\n\n    Turtle.prototype.end_fill = function () {\n        if (! this.animate) {\n            this.context.stroke();\n            this.context.fill();\n            this.context.closePath();\n            this.filling = false;\n        } else\n            this.addDrawingEvent(["EF", this.position[0], this.position[1], this.fillStyle]);\n    }\n\n\n    Turtle.prototype.showturtle = function() {\n        if (this.animate) {\n            this.addDrawingEvent(["SH"]);\n        }\n        this.visible = true;\n    }\n\n    Turtle.prototype.hideturtle = function() {\n        if (this.animate) {\n            this.addDrawingEvent(["HT"]);\n        }\n        this.visible = false;\n    }\n\n    Turtle.prototype.isvisible = function() {\n        return this.visible;\n    }\n\n    // \n    // Appearance\n    //\n\n    Turtle.prototype.shape = function(s) {\n        if (this.shapeStore[s])\n            this.currentShape = s;\n        else {\n        }\n    }\n\n    Turtle.prototype.drawturtle = function(heading, position) {\n        var rtPoints = [];\n        var plist = this.shapeStore[this.currentShape];\n        var head;\n        if (! (heading === undefined))\n            head = heading - 90.0;\n        else\n            head = this.heading.toAngle() - 90.0;\n        if (! position)\n            position = this.position\n        for (p in plist) {\n            rtPoints.push(plist[p].scale(this.turtleCanvas.xptscale,this.turtleCanvas.yptscale).rotate(head).add(position));\n        }\n        this.context.beginPath();\n        this.context.moveTo(rtPoints[0][0], rtPoints[0][1]);\n        for (var i = 1; i < rtPoints.length; i++) {\n            this.context.lineTo(rtPoints[i][0], rtPoints[i][1]);\n        }\n        this.context.closePath();\n        this.context.stroke();\n        if (this.fillStyle) {\n            this.context.fill();\n        }\n    }\n\n    Turtle.prototype.stamp = function() {\n        // either call drawTurtle or just add a DT with current position and heading to the drawingEvents list.\n        if (this.animate) {\n            this.addDrawingEvent(["ST",this.position[0],this.position[1],this.heading.toAngle()]);\n        } else\n            this.drawturtle();\n    }\n    \n    Turtle.prototype.clear = function () {\n    \tif (this.animate) {\n    \t\tthis.addDrawingEvent(["CL"])\n    \t} else {\n    \t\tclear_canvas(this.canvasID);\n    \t}\n    }\n\n    function clear_canvas(canId) {\n        with (document.getElementById(canId).getContext(\'2d\')) {\n            if (arguments.length >= 2) {\n//\t\tfillStyle = arguments[1];\n//\t\tfillRect(0, 0, canvas.width, canvas.height);\n            }\n            clearRect(-canvas.width / 2, -canvas.height / 2, canvas.width, canvas.height);\n        }\n    }\n\n\n    // Create a 3d Vector class for manipulating turtle heading, and position.\n\n    function Vector(x, y, z) {\n        if ((typeof(x)).toLowerCase() === \'number\') {\n            Array.prototype.push.call(this, x);\n            Array.prototype.push.call(this, y);\n            Array.prototype.push.call(this, z);\n        }\n        else {\n            for (var i in x) {\n                Array.prototype.push.call(this, x[i]);\n            }\n        }\n    }\n\n\n    // Create a vector object given a direction as an angle.\n    Vector.angle2vec = function(phi) {\n        var res = new Vector([0.0,0.0,0.0]);\n        phi = phi * Degree2Rad;\n        res[0] = Sk.math.cos(phi);\n        res[1] = Sk.math.sin(phi);\n        return res.normalize();\n    }\n\n    // This trick allows you to access a Vector object like an array\n    // myVec[0] == x\n    // myVec[1] == y\n    // myVec[2] == z\n    // we really only need the z for the convenience of rotating\n    Vector.prototype.addItem = function(item) {\n        Array.prototype.push.call(this, item);\n    }\n\n    Vector.prototype.linear = function(a, b, v) {\n        var result = [ ];\n        for (var c = 0; c <= 2; ++c) {\n            result[c] = a * this[c] + b * v[c];\n        }\n        return new Vector(result);\n    }\n\n    Vector.prototype.cross = function(v) {\n        // Return cross product of this and v\n        var result = [ ];\n        for (var c = 0; c <= 2; ++c) {\n            result[c] = this[(c + 1) % 3] * v[(c + 2) % 3] - this[(c + 2) % 3] * v[(c + 1) % 3];\n        }\n        return new Vector(result);\n    }\n\n    Vector.prototype.rotate = function(angle) {\n        // Rotate this counter clockwise by angle.\n        var perp = new Vector(-this[1], this[0], 0);\n        angle = angle * Degree2Rad;\n        var c = Sk.math.cos(angle);\n        var s = Sk.math.sin(angle);\n        return new Vector(this[0] * c + perp[0] * s, this[1] * c + perp[1] * s, 0);\n    }\n\n    Vector.prototype.rotateNormal = function(v, w, alpha) {\n        // Return rotation of this in direction of v about w over alpha\n        // Requires: v, w are vectors; alpha is angle in radians\n        //   this, v, w are orthonormal\n        return this.linear(Sk.math.cos(alpha), Sk.math.sin(alpha), v);\n    }\n\n    Vector.prototype.normalize = function() {\n        var n = this.len();\n        var res = this.div(n);\n        return res;\n    }\n\n    Vector.prototype.toAngle = function() {\n        // workaround for values getting set to +/i xxx e -16 fooling the +/- checks below\n        if (Math.abs(this[1]) < 0.00001) this[1] = 0.0;\n        if (Math.abs(this[0]) < 0.00001) this[0] = 0.0;\n        var rads = Math.atan(Math.abs(this[1]) / Math.abs(this[0]));\n        var deg = rads * Rad2Degree;\n        if (this[0] < 0 && this[1] > 0) deg = 180 - deg;\n        else if (this[0] < 0 && this[1] <= 0) deg = 180.0 + deg;\n        else if (this[0] >= 0 && this[1] < 0) deg = 360 - deg;\n        return deg;\n    }\n\n    // divide all vector components by the same value\n    Vector.prototype.div = function(n) {\n        res = []\n        res[0] = this[0] / n;\n        res[1] = this[1] / n;\n        res[2] = this[2] / n;\n        return new Vector(res);\n    }\n\n    // subtract one vector from another\n    Vector.prototype.sub = function(v) {\n        res = new Vector(0, 0, 0);\n        res[0] = this[0] - v[0];\n        res[1] = this[1] - v[1];\n        res[2] = this[2] - v[2];\n        return res;\n    }\n\n    Vector.prototype.add = function(v) {\n        res = new Vector(0, 0, 0);\n        res[0] = this[0] + v[0];\n        res[1] = this[1] + v[1];\n        res[2] = this[2] + v[2];\n        return res;\n    }\n\n    Vector.prototype.smul = function(k) {  // scalar multiplication\n        res = new Vector(0, 0, 0);\n        res[0] = this[0] * k;\n        res[1] = this[1] * k;\n        res[2] = this[2] * k;\n        return res;\n    }\n\n    Vector.prototype.scale = function(xs,ys) {\n        res = new Vector(0,0,0);\n        res[0] =  this[0] * ys;\n        res[1] =  this[1] * xs;\n        res[2] = 1.0;\n        return res;\n    }\n\n    Vector.prototype.len = function() {\n        return Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);\n    }\n\n\n    TurtleGraphics.defaults = { canvasID: \'mycanvas\', degrees: true, animate: true }\n    TurtleGraphics.turtleList = [];\n    TurtleGraphics.Turtle = Turtle;\n    TurtleGraphics.TurtleCanvas = TurtleCanvas;\n    TurtleGraphics.canvasLib = {}\n    TurtleGraphics.clear_canvas = clear_canvas;\n    TurtleGraphics.Vector = Vector;\n    TurtleGraphics.canvasInit = false;\n    TurtleGraphics.eventCount = 0;\n    TurtleGraphics.renderClock = 0;\n    TurtleGraphics.renderTime  = 0; // RNL\n\n})();\n\n\n//\n// Wrapper around the Turtle Module starts here.\n//\n//\nvar $builtinmodule = function(name) {\n    var mod = {};\n    // First we create an object, this will end up being the class\n    // class\n    Sk.tg = TurtleGraphics;\n\n    var checkArgs = function(expected, actual, func) {\n        if (actual != expected ) {\n            throw new Sk.builtin.TypeError(func + " takes exactly " + expected +\n                    " positional argument (" + actual + " given)")\n        }\n    }\n\n    var turtle = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self) {\n            TurtleGraphics.defaults = {canvasID: Sk.canvas, animate: true, degrees: true};\n            self.theTurtle = new TurtleGraphics.Turtle();\n        });\n\n//\n// Turtle Motion\n//\n        //\n        // Move and Draw\n        //\n        $loc.forward = new Sk.builtin.func(function(self, dist) {\n\t\t\tdist = Sk.builtin.asnum$(dist);\n            checkArgs(2,arguments.length,"forward()");\n            self.theTurtle.forward(dist);\n        });\n\n        $loc.fd = $loc.forward;\n\n        $loc.backward = new Sk.builtin.func(function(self, dist) {\n\t\t\tdist = Sk.builtin.asnum$(dist);\n            checkArgs(2,arguments.length,"backward()");\n            self.theTurtle.forward(-dist);\n        });\n\n        $loc.back = $loc.backward;\n        $loc.bk = $loc.backward;\n\n        $loc.right = new Sk.builtin.func(function(self, angle) {\n\t\t\tangle = Sk.builtin.asnum$(angle);\n            checkArgs(2,arguments.length,"right()");\n            self.theTurtle.turn(angle);\n        });\n\n        $loc.rt = $loc.right;\n\n        $loc.left = new Sk.builtin.func(function(self, angle) {\n\t\t\tangle = Sk.builtin.asnum$(angle);\n            checkArgs(2,arguments.length,"left()");\n            self.theTurtle.turn(-angle);\n        });\n\n        $loc.lt = $loc.left;\n\n        $loc.goto_$rw$ = new Sk.builtin.func(function(self, nx, ny) {\n\t\t\tnx = Sk.builtin.asnum$(nx);\n\t\t\tny = Sk.builtin.asnum$(ny);\n            checkArgs(3,arguments.length,"goto()");\n            self.theTurtle.goto(nx, ny);\n        });\n\n        $loc.setposition = new Sk.builtin.func(function(self,nx,ny) {\n\t\t\tnx = Sk.builtin.asnum$(nx);\n\t\t\tny = Sk.builtin.asnum$(ny);\n            checkArgs(3,arguments.length,"setposition()");\n            self.theTurtle.up();\n            self.theTurtle.goto(nx,ny);\n            self.theTurtle.down();\n        });\n        $loc.setpos = $loc.setposition;\n\n        $loc.setx = new Sk.builtin.func(function(self, nx) {\n\t\t\tnx = Sk.builtin.asnum$(nx);\n            checkArgs(2,arguments.length,"setx()");\n            self.theTurtle.goto(nx, self.theTurtle.GetY());\n        });\n\n        $loc.sety = new Sk.builtin.func(function(self, ny) {\n\t\t\tny = Sk.builtin.asnum$(ny);\n            checkArgs(2,arguments.length,"sety()");\n            self.theTurtle.goto(self.theTurtle.GetX(), ny);\n        });\n\n        $loc.setheading = new Sk.builtin.func(function(self, newhead) {\n\t\t\tnewhead = Sk.builtin.asnum$(newhead);\n            checkArgs(2,arguments.length,"setheading()");\n            return self.theTurtle.set_heading(newhead);\n        });\n\n        $loc.seth = $loc.setheading;\n\n        $loc.home = new Sk.builtin.func(function(self) {\n            self.theTurtle.go_home();\n        });\n\n        $loc.dot = new Sk.builtin.func(function(self, /*opt*/ size, color) {\n\t\t\tsize = Sk.builtin.asnum$(size);\n            size = size || 1;\n            if (color) {\n                color = color.v || self.theTurtle.penStyle;\n            }\n            self.theTurtle.dot(size, color);\n        });\n\n        $loc.circle = new Sk.builtin.func(function(self, radius, extent) {\n\t\t\tradius = Sk.builtin.asnum$(radius);\n\t\t\textent = Sk.builtin.asnum$(extent);\n            self.theTurtle.circle(radius, extent);\n        });\n\n        $loc.delay = new Sk.builtin.func(function(self, d) {\n\t\t\td = Sk.builtin.asnum$(d);\n            return self.theTurtle.delay(d);\n        });\n\n        $loc.speed = new Sk.builtin.func(function(self, s, t) {\n\t\t\ts = Sk.builtin.asnum$(s);\n\t\t\tt = Sk.builtin.asnum$(t);\n            self.theTurtle.speed(s,t);\n        });\n\n        $loc.tracer = new Sk.builtin.func(function(self, t, d) {\n\t\t\tt = Sk.builtin.asnum$(t);\n\t\t\td = Sk.builtin.asnum$(d);\n            self.theTurtle.tracer(t, d);\n        });\n\n\t\t$loc.update = new Sk.builtin.func(function(self) {\n\t\t\t//\tDummy function to emulate update... when not animating, we don\'t save the drawing operations, so this is pointless for us\n\t\t});\n\n        // todo:  stamp, clearstamp, clearstamps, undo, speed\n\n        //\n        // Tell Turtle\'s state\n        //\n        $loc.heading = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"heading()");\n            return Sk.builtin.assk$(self.theTurtle.get_heading(),Sk.builtin.nmber.float$);\n        });\n\n        $loc.position = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"position()");\n            var res = self.theTurtle.get_position();\n            var x = new Sk.builtin.tuple([Sk.builtin.assk$(res[0],Sk.builtin.nmber.float$),\n                                          Sk.builtin.assk$(res[1],Sk.builtin.nmber.float$) ]);\n            return x;\n        });\n\n        $loc.pos = $loc.position;\n\n        $loc.xcor = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"xcor()");\n            var res = self.theTurtle.getx();\n            return Sk.builtin.assk$(res,Sk.builtin.nmber.float$);\n        });\n\n        $loc.ycor = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"ycor()");\n            var res = self.theTurtle.gety();\n            return Sk.builtin.assk$(res,Sk.builtin.nmber.float$);\n        });\n\n        $loc.towards = new Sk.builtin.func(function(self, tx, ty) {\n\t\t\ttx = Sk.builtin.asnum$(tx);\n\t\t\tty = Sk.builtin.asnum$(ty);\n            if ((typeof(tx)).toLowerCase() === \'number\') {\n                tx = [tx, ty, 0];\n            } else {\n                tx = [Sk.builtin.asnum$(tx.theTurtle.getx()),Sk.builtin.asnum$(tx.theTurtle.gety()),Sk.builtin.asnum$(0)]\n            }\n            return Sk.builtin.assk$(self.theTurtle.towards(tx),Sk.builtin.nmber.float$);\n        });\n\n        // tx can be either a number or a vector position.\n        // tx can not be a turtle at this time as multiple turtles have not been implemented yet.\n        $loc.distance = new Sk.builtin.func(function(self, tx, ty) {\n\t\t\ttx = Sk.builtin.asnum$(tx);\n\t\t\tty = Sk.builtin.asnum$(ty);\n            if ((typeof(tx)).toLowerCase() === \'number\') {\n                tx = [tx, ty, 0];\n            } else {\n                tx = [tx.theTurtle.getx(), tx.theTurtle.gety(), 0];\n            }\n            return Sk.builtin.assk$(self.theTurtle.distance(tx),Sk.builtin.nmber.float$);\n        });\n\n        //\n        // Setting and Measurement\n        //\n\n        // todo:  degrees and radians...\n\n//\n// Pen Control\n//\n\n        //\n        // Drawing State\n        //\n\n        $loc.up = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"up()");\n            self.theTurtle.pen_up();\n        });\n\n        $loc.penup = $loc.up;\n        $loc.pu = $loc.up;\n\n        $loc.down = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"down()");\n            self.theTurtle.pen_down();\n        });\n\n        $loc.pendown = $loc.down;\n        $loc.pd = $loc.down;\n\n        $loc.width = new Sk.builtin.func(function(self, w) {\n\t\t\tw = Sk.builtin.asnum$(w);\n            checkArgs(2,arguments.length,"width()");\n            self.theTurtle.set_pen_width(w);\n        });\n\n        $loc.pensize = $loc.width;\n\n        $loc.isdown = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"isdown()");\n            return self.theTurtle.get_pen();\n        });\n\n        // todo:  pen  -- return a dictionary full of pen stuff\n\n        //\n        // Color Control\n        //\n\n        $loc.fillcolor = new Sk.builtin.func(function(self, color, green, blue) {\n            if (color) {\n                if (blue) {\n                    self.theTurtle.set_fill_color(color, green, blue);\n                } else {\n                    color = color.v || self.theTurtle.context.fillStyle;\n                    self.theTurtle.set_fill_color(color);\n                }\n            } else\n                return self.theTurtle.fillStyle;\n        });\n\n        $loc.pencolor = new Sk.builtin.func(function(self, color, green, blue) {\n            if (color) {\n                if (blue) {\n\t\t\t\t\tcolor = Sk.builtin.asnum$(color);\n\t\t\t\t\tgreen = Sk.builtin.asnum$(green);\n\t\t\t\t\tblue = Sk.builtin.asnum$(blue);\n                    self.theTurtle.set_pen_color(color, green, blue);\n                } else {\n                    color = color.v || self.theTurtle.context.fillStyle;\n                    self.theTurtle.set_pen_color(color);\n                }\n            } else\n                return self.theTurtle.penStyle;\n        });\n\n        $loc.color = new Sk.builtin.func(function(self, color, green, blue) {\n            if(color) {\n                if (blue) {\n                    self.theTurtle.set_pen_color(color, green, blue);\n                    self.theTurtle.set_fill_color(color, green, blue);\n                } else {\n                    color = color.v || self.theTurtle.context.fillStyle;\n                    self.theTurtle.set_pen_color(color);\n                    self.theTurtle.set_fill_color(color);\n                }\n            } else \n                return [self.theTurtle.penStyle, self.theTurtle.fillStyle];            \n        });\n\n        //\n        //  Filling\n        //\n\n        $loc.begin_fill = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"begin_fill()");\n            self.theTurtle.begin_fill();\n        });\n\n        $loc.end_fill = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"end_fill()");\n            self.theTurtle.end_fill();\n        });\n\n        $loc.fill = new Sk.builtin.func(function(self, fillt) {\n\t\t\tif (fillt === undefined)\n\t\t\t\treturn self.theTurtle.filling;\n            if (fillt)\n                self.theTurtle.begin_fill();\n            else\n                self.theTurtle.end_fill();\n        });\n\n        //\n        // More drawing control\n        //\n\n        $loc.reset = new Sk.builtin.func(function(self) {\n            self.theTurtle.clean();\n        });\n\n        $loc.showturtle = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"showturtle()");\n            self.theTurtle.showturtle();\n        });\n        $loc.st = $loc.showturtle;\n\n        $loc.hideturtle = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"hideturtle()");\n            self.theTurtle.hideturtle();\n        });\n        $loc.ht = $loc.hideturtle;\n\n        $loc.isvisible = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"isvisible()");\n            self.theTurtle.isvisible()\n        });\n\n        $loc.stamp = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"stamp()");\n            self.theTurtle.stamp();\n        });\n\n        $loc.shape = new Sk.builtin.func(function(self, s) {\n            checkArgs(2,arguments.length,"shape()");\n            self.theTurtle.shape(s.v);\n        });\n\n\n        // todo the move, align, and font parameters should be kwargs...\n        $loc.write = new Sk.builtin.func(function(self, mystr, move, align, font) {\n            self.theTurtle.write(mystr.v, move, align, font);\n        });\n\n        // todo clean  -- again multiple turtles\n\n        $loc.setworldcoordinates = new Sk.builtin.func(function(self, llx, lly, urx, ury) {\n\t\t\tllx = Sk.builtin.asnum$(llx);\n\t\t\tlly = Sk.builtin.asnum$(lly);\n\t\t\turx = Sk.builtin.asnum$(urx);\n\t\t\tury = Sk.builtin.asnum$(ury);\n            self.theTurtle.setworldcoordinates(llx, lly, urx, ury);\n        });\n\n\t\t//\tAdded by RNL\n\n\t\t$loc.clear = new Sk.builtin.func(function(self) {\n\t\t\tself.theTurtle.clear()\n\t\t});\n\n    }\n\n    mod.Turtle = Sk.misceval.buildClass(mod, turtle, \'Turtle\', []);\n\n    var screen = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self) {\n            TurtleGraphics.defaults = {canvasID: Sk.canvas, animate: true, degrees: true};\n            var currentCanvas = TurtleGraphics.canvasLib[TurtleGraphics.defaults.canvasID];\n            if (currentCanvas === undefined) {\n                self.theScreen = new TurtleGraphics.TurtleCanvas(TurtleGraphics.defaults);\n            } else {\n                self.theScreen = currentCanvas;\n            }\n        });\n\n        $loc.bgcolor = new Sk.builtin.func(function(self, c) {\n            self.theScreen.bgcolor(c);\n        });\n\n        $loc.setworldcoordinates = new Sk.builtin.func(function(self, llx,lly,urx,ury) {\n\t\t\tllx = Sk.builtin.asnum$(llx);\n\t\t\tlly = Sk.builtin.asnum$(lly);\n\t\t\turx = Sk.builtin.asnum$(urx);\n\t\t\tury = Sk.builtin.asnum$(ury);\n            self.theScreen.setworldcoordinates(llx,lly,urx,ury);\n        });\n\n        $loc.exitonclick = new Sk.builtin.func(function(self) {\n            self.theScreen.exitonclick();\n        });\n\n        $loc.title = new Sk.builtin.func(function(self,titlestring) {\n            // no op....\n        });\n\n        $loc.window_width = new Sk.builtin.func(function(self) {\n            return self.theScreen.window_width();\n        });\n\n        $loc.window_height = new Sk.builtin.func(function(self) {\n            return self.theScreen.window_height();\n        });\n\n        $loc.turtles = new Sk.builtin.func(function(self) {\n            return self.theScreen.turtles();\n        });\n\n\t\t$loc.colormode = new Sk.builtin.func(function(self) {\n\t\t\t//\tEmpty function to emulate compatibility\n\t\t});\n        \n//        $loc.clear = new Sk.builtin.func(function(self) {\n//        \t\n//        });\n\n        var myfunc = function(self, width, height, startx, starty) {\n\t\t\twidth = Sk.builtin.asnum$(width);\n\t\t\theight = Sk.builtin.asnum$(height);\n            self.theScreen.setup(width,height);\n        }\n        // this should allow for named parameters\n        myfunc.co_varnames = [\'self\',\'width\',\'height\',\'startx\',\'starty\'];\n        myfunc.$defaults = [null,500,500,0,0];\n        $loc.setup = new Sk.builtin.func(myfunc);\n    }\n\n    mod.Screen = Sk.misceval.buildClass(mod, screen, \'Screen\', []);\n\n    mod.tracer = new Sk.builtin.func(function(t, d) {\n\t\tt = Sk.builtin.asnum$(t);\n\t\td = Sk.builtin.asnum$(d);\n\t\tfor (var i in Sk.tg.canvasLib)\n\t\t\tSk.tg.canvasLib[i].tracer(t, d);\n    });\n\n\tmod.update = new Sk.builtin.func(function(self) {\n\t\t//\tDummy function to emulate update... when not animating, we don\'t save the drawing operations, so this is pointless for us\n\t});\n\n\n    return mod\n}\n',
    'src/lib/webgl/math.js': 'var $builtinmodule = function(name)\n{\n    var mod = {};\n\n    // todo; should probably put this in a math package\n    mod.Mat44 = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self)\n                    {\n                        Sk.misceval.callsim($loc.loadIdentity, self);\n                        self.stack = [];\n                    });\n\n                $loc.push = new Sk.builtin.func(function(self)\n                    {\n                        self.stack.push(self.elements.slice(0));\n                    });\n\n                $loc.pop = new Sk.builtin.func(function(self)\n                    {\n                        self.elements = self.stack.pop();\n                    });\n\n                $loc.loadIdentity = new Sk.builtin.func(function(self)\n                    {\n                        self.elements = [1.0, 0.0, 0.0, 0.0,\n                                         0.0, 1.0, 0.0, 0.0,\n                                         0.0, 0.0, 1.0, 0.0,\n                                         0.0, 0.0, 0.0, 1.0];\n                    });\n\n                $loc.transform3 = new Sk.builtin.func(function(self, v)\n                    {\n                        var e = self.elements;\n                        return Sk.misceval.callsim(mod.Vec3,\n                            e[0] * v.x + e[4] * v.y + e[8] * v.z,\n                            e[1] * v.x + e[5] * v.y + e[9] * v.z,\n                            e[2] * v.x + e[6] * v.y + e[10] * v.z);\n                    });\n\n                $loc.scale = new Sk.builtin.func(function(self, sx, sy, sz)\n                        {\n                            self.elements[0*4+0] *= sx;\n                            self.elements[0*4+1] *= sx;\n                            self.elements[0*4+2] *= sx;\n                            self.elements[0*4+3] *= sx;\n\n                            self.elements[1*4+0] *= sy;\n                            self.elements[1*4+1] *= sy;\n                            self.elements[1*4+2] *= sy;\n                            self.elements[1*4+3] *= sy;\n\n                            self.elements[2*4+0] *= sz;\n                            self.elements[2*4+1] *= sz;\n                            self.elements[2*4+2] *= sz;\n                            self.elements[2*4+3] *= sz;\n\n                            return self;\n                        });\n\n                $loc.translate = new Sk.builtin.func(function(self, tx, ty, tz)\n                        {\n                            self.elements[3*4+0] += self.elements[0*4+0] * tx + self.elements[1*4+0] * ty + self.elements[2*4+0] * tz;\n                            self.elements[3*4+1] += self.elements[0*4+1] * tx + self.elements[1*4+1] * ty + self.elements[2*4+1] * tz;\n                            self.elements[3*4+2] += self.elements[0*4+2] * tx + self.elements[1*4+2] * ty + self.elements[2*4+2] * tz;\n                            self.elements[3*4+3] += self.elements[0*4+3] * tx + self.elements[1*4+3] * ty + self.elements[2*4+3] * tz;\n                            return self;\n                        });\n\n                $loc.rotate = new Sk.builtin.func(function(self, angle, x, y, z)\n                        {\n                            var mag = Math.sqrt(x*x + y*y + z*z);\n                            var sinAngle = Sk.math.sin(angle * Math.PI / 180.0);\n                            var cosAngle = Sk.math.cos(angle * Math.PI / 180.0);\n\n                            if (mag > 0)\n                            {\n                                var xx, yy, zz, xy, yz, zx, xs, ys, zs;\n                                var oneMinusCos;\n                                var rotMat;\n\n                                x /= mag;\n                                y /= mag;\n                                z /= mag;\n\n                                xx = x * x;\n                                yy = y * y;\n                                zz = z * z;\n                                xy = x * y;\n                                yz = y * z;\n                                zx = z * x;\n                                xs = x * sinAngle;\n                                ys = y * sinAngle;\n                                zs = z * sinAngle;\n                                oneMinusCos = 1.0 - cosAngle;\n\n                                rotMat = Sk.misceval.callsim(mod.Mat44);\n\n                                rotMat.elements[0*4+0] = (oneMinusCos * xx) + cosAngle;\n                                rotMat.elements[0*4+1] = (oneMinusCos * xy) - zs;\n                                rotMat.elements[0*4+2] = (oneMinusCos * zx) + ys;\n                                rotMat.elements[0*4+3] = 0.0;\n\n                                rotMat.elements[1*4+0] = (oneMinusCos * xy) + zs;\n                                rotMat.elements[1*4+1] = (oneMinusCos * yy) + cosAngle;\n                                rotMat.elements[1*4+2] = (oneMinusCos * yz) - xs;\n                                rotMat.elements[1*4+3] = 0.0;\n\n                                rotMat.elements[2*4+0] = (oneMinusCos * zx) - ys;\n                                rotMat.elements[2*4+1] = (oneMinusCos * yz) + xs;\n                                rotMat.elements[2*4+2] = (oneMinusCos * zz) + cosAngle;\n                                rotMat.elements[2*4+3] = 0.0;\n\n                                rotMat.elements[3*4+0] = 0.0;\n                                rotMat.elements[3*4+1] = 0.0;\n                                rotMat.elements[3*4+2] = 0.0;\n                                rotMat.elements[3*4+3] = 1.0;\n\n                                rotMat = rotMat.multiply(self);\n                                self.elements = rotMat.elements;\n                            }\n                            return self;\n                        });\n\n                $loc.multiply = new Sk.builtin.func(function(self, right)\n                        {\n                            var tmp = Sk.misceval.callsim(mod.Mat44);\n\n                            for (var i = 0; i < 4; i++)\n                            {\n                                tmp.elements[i*4+0] =\n                                (self.elements[i*4+0] * right.elements[0*4+0]) +\n                                (self.elements[i*4+1] * right.elements[1*4+0]) +\n                                (self.elements[i*4+2] * right.elements[2*4+0]) +\n                                (self.elements[i*4+3] * right.elements[3*4+0]) ;\n\n                                tmp.elements[i*4+1] =\n                                (self.elements[i*4+0] * right.elements[0*4+1]) +\n                                (self.elements[i*4+1] * right.elements[1*4+1]) +\n                                (self.elements[i*4+2] * right.elements[2*4+1]) +\n                                (self.elements[i*4+3] * right.elements[3*4+1]) ;\n\n                                tmp.elements[i*4+2] =\n                                (self.elements[i*4+0] * right.elements[0*4+2]) +\n                                (self.elements[i*4+1] * right.elements[1*4+2]) +\n                                (self.elements[i*4+2] * right.elements[2*4+2]) +\n                                (self.elements[i*4+3] * right.elements[3*4+2]) ;\n\n                                tmp.elements[i*4+3] =\n                                (self.elements[i*4+0] * right.elements[0*4+3]) +\n                                (self.elements[i*4+1] * right.elements[1*4+3]) +\n                                (self.elements[i*4+2] * right.elements[2*4+3]) +\n                                (self.elements[i*4+3] * right.elements[3*4+3]) ;\n                            }\n\n                            self.elements = tmp.elements;\n                            return self;\n                        });\n\n                /* Following gluLookAt implementation is adapted from\n                 * the Mesa 3D Graphics library. http://www.mesa3d.org\n                 */\n                // todo; rewrite this with proper vec/mat ops\n                $loc.lookAt = new Sk.builtin.func(function(self, eyeX, eyeY, eyeZ,\n                                                                 centerX, centerY, centerZ,\n                                                                 upX, upY, upZ)\n                        {\n                            /* Z vector */\n                            var z = [\n                                eyeX - centerX,\n                                eyeY - centerY,\n                                eyeZ - centerZ\n                            ];\n                            var mag = Math.sqrt(z[0] * z[0] + z[1] * z[1] + z[2] * z[2]);\n                            if (mag)\n                            {\n                                z[0] /= mag;\n                                z[1] /= mag;\n                                z[2] /= mag;\n                            }\n\n                            /* Y vector */\n                            var y = [ upX, upY, upZ ];\n\n                            /* X vector = Y cross Z */\n                            var x = [];\n                            x[0] = y[1] * z[2] - y[2] * z[1];\n                            x[1] = -y[0] * z[2] + y[2] * z[0];\n                            x[2] = y[0] * z[1] - y[1] * z[0];\n\n                            /* Recompute Y = Z cross X */\n                            y[0] = z[1] * x[2] - z[2] * x[1];\n                            y[1] = -z[0] * x[2] + z[2] * x[0];\n                            y[2] = z[0] * x[1] - z[1] * x[0];\n\n                            /* mpichler, 19950515 */\n                            /* cross product gives area of parallelogram, which is < 1.0 for\n                            * non-perpendicular unit-length vectors; so normalize x, y here\n                            */\n\n                            mag = Math.sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);\n                            if (mag) {\n                                x[0] /= mag;\n                                x[1] /= mag;\n                                x[2] /= mag;\n                            }\n\n                            mag = Math.sqrt(y[0] * y[0] + y[1] * y[1] + y[2] * y[2]);\n                            if (mag) {\n                                y[0] /= mag;\n                                y[1] /= mag;\n                                y[2] /= mag;\n                            }\n\n                            var lookAt = Sk.misceval.callsim(mod.Mat44);\n                            lookAt.elements[0 * 4 + 0] = x[0];\n                            lookAt.elements[1 * 4 + 0] = x[1];\n                            lookAt.elements[2 * 4 + 0] = x[2];\n                            lookAt.elements[3 * 4 + 0] = 0.;\n                            lookAt.elements[0 * 4 + 1] = y[0];\n                            lookAt.elements[1 * 4 + 1] = y[1];\n                            lookAt.elements[2 * 4 + 1] = y[2];\n                            lookAt.elements[3 * 4 + 1] = 0.;\n                            lookAt.elements[0 * 4 + 2] = z[0];\n                            lookAt.elements[1 * 4 + 2] = z[1];\n                            lookAt.elements[2 * 4 + 2] = z[2];\n                            lookAt.elements[3 * 4 + 2] = 0.;\n                            lookAt.elements[0 * 4 + 3] = 0.;\n                            lookAt.elements[1 * 4 + 3] = 0.;\n                            lookAt.elements[2 * 4 + 3] = 0.;\n                            lookAt.elements[3 * 4 + 3] = 1.;\n\n                            // log(lookAt.elements);\n\n                            lookAt = lookAt.multiply(self);\n                            self.elements = lookAt.elements;\n                            self.translate(-eyeX, -eyeY, -eyeZ);\n\n                            // log(this.elements);\n\n                            return self;\n                        });\n            },\n            \'Mat44\', []);\n\n    // todo; should probably put this in a math package\n    mod.Mat33 = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self)\n                    {\n                        Sk.misceval.callsim($loc.loadIdentity, self);\n                    });\n\n                $loc.loadIdentity = new Sk.builtin.func(function(self)\n                    {\n                        self.elements = [1.0, 0.0, 0.0,\n                                         0.0, 1.0, 0.0,\n                                         0.0, 0.0, 1.0];\n                    });\n            },\n            \'Mat33\', []);\n\n    mod.Vec3 = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self, x, y, z)\n                    {\n                        self.x = x;\n                        self.y = y;\n                        self.z = z;\n                    });\n                $loc.__sub__ = new Sk.builtin.func(function(self, other)\n                    {\n                        return Sk.misceval.callsim(mod.Vec3, self.x - other.x, self.y - other.y, self.z - other.z);\n                    });\n            },\n            \'Vec3\', []);\n    \n    mod.cross = new Sk.builtin.func(function(v1, v2)\n            {\n                goog.asserts.assert(v1 instanceof mod.Vec3 && v2 instanceof mod.Vec3);\n                return Sk.misceval.callsim(mod.Vec3,\n                    v1.y * v2.z - v1.z * v2.y,\n                    v1.z * v2.x - v1.x * v2.z,\n                    v1.x * v2.y - v1.y * v2.x);\n            });\n\n    return mod;\n};\n',
    'src/builtin/unittest.py': '#!/usr/bin/env python\n\'\'\'\nPython unit testing framework, based on Erich Gamma\'s JUnit and Kent Beck\'s\nSmalltalk testing framework.\n\nThis module contains the core framework classes that form the basis of\nspecific test cases and suites (TestCase, TestSuite etc.), and also a\ntext-based utility class for running the tests and reporting the results\n (TextTestRunner).\n\nSimple usage:\n\n    import unittest\n\n    class IntegerArithmenticTestCase(unittest.TestCase):\n        def testAdd(self):  ## test method names begin \'test*\'\n            self.assertEquals((1 + 2), 3)\n            self.assertEquals(0 + 1, 1)\n        def testMultiply(self):\n            self.assertEquals((0 * 10), 0)\n            self.assertEquals((5 * 8), 40)\n\n    if __name__ == \'__main__\':\n        unittest.main()\n\nFurther information is available in the bundled documentation, and from\n\n  http://docs.python.org/lib/module-unittest.html\n\nCopyright (c) 1999-2003 Steve Purcell\nThis module is free software, and you may redistribute it and/or modify\nit under the same terms as Python itself, so long as this copyright message\nand disclaimer are retained in their original form.\n\nIN NO EVENT SHALL THE AUTHOR BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,\nSPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OF\nTHIS CODE, EVEN IF THE AUTHOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\nDAMAGE.\n\nTHE AUTHOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE.  THE CODE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS,\nAND THERE IS NO OBLIGATION WHATSOEVER TO PROVIDE MAINTENANCE,\nSUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n\'\'\'\n\n__author__ = "Steve Purcell"\n__email__ = "stephen_purcell at yahoo dot com"\n__version__ = "#Revision: 1.63 $"[11:-2]\n\nimport time\nimport sys\nimport traceback\nimport os\nimport types\n\n##############################################################################\n# Exported classes and functions\n##############################################################################\n__all__ = [\'TestResult\', \'TestCase\', \'TestSuite\', \'TextTestRunner\',\n           \'TestLoader\', \'FunctionTestCase\', \'main\', \'defaultTestLoader\']\n\n# Expose obsolete functions for backwards compatibility\n__all__.extend([\'getTestCaseNames\', \'makeSuite\', \'findTestCases\'])\n\n\n##############################################################################\n# Backward compatibility\n##############################################################################\nif sys.version_info[:2] < (2, 2):\n    def isinstance(obj, clsinfo):\n        import __builtin__\n        if type(clsinfo) in (tuple, list):\n            for cls in clsinfo:\n                if cls is type: cls = types.ClassType\n                if __builtin__.isinstance(obj, cls):\n                    return 1\n            return 0\n        else: return __builtin__.isinstance(obj, clsinfo)\n\ndef _CmpToKey(mycmp):\n    \'Convert a cmp= function into a key= function\'\n    class K(object):\n        def __init__(self, obj):\n            self.obj = obj\n        def __lt__(self, other):\n            return mycmp(self.obj, other.obj) == -1\n    return K\n\n##############################################################################\n# Test framework core\n##############################################################################\n\n# All classes defined herein are \'new-style\' classes, allowing use of \'super()\'\n__metaclass__ = type\n\ndef _strclass(cls):\n    return "%s.%s" % (cls.__module__, cls.__name__)\n\n__unittest = 1\n\nclass TestResult:\n    """Holder for test result information.\n\n    Test results are automatically managed by the TestCase and TestSuite\n    classes, and do not need to be explicitly manipulated by writers of tests.\n\n    Each instance holds the total number of tests run, and collections of\n    failures and errors that occurred among those test runs. The collections\n    contain tuples of (testcase, exceptioninfo), where exceptioninfo is the\n    formatted traceback of the error that occurred.\n    """\n    def __init__(self):\n        self.failures = []\n        self.errors = []\n        self.testsRun = 0\n        self.shouldStop = False\n\n    def startTest(self, test):\n        "Called when the given test is about to be run"\n        self.testsRun = self.testsRun + 1\n\n    def stopTest(self, test):\n        "Called when the given test has been run"\n        pass\n\n    def addError(self, test, err):\n        """Called when an error has occurred. \'err\' is a tuple of values as\n        returned by sys.exc_info().\n        """\n        self.errors.append((test, self._exc_info_to_string(err, test)))\n\n    def addFailure(self, test, err):\n        """Called when an error has occurred. \'err\' is a tuple of values as\n        returned by sys.exc_info()."""\n        self.failures.append((test, self._exc_info_to_string(err, test)))\n\n    def addSuccess(self, test):\n        "Called when a test has completed successfully"\n        pass\n\n    def wasSuccessful(self):\n        "Tells whether or not this result was a success"\n        return len(self.failures) == len(self.errors) == 0\n\n    def stop(self):\n        "Indicates that the tests should be aborted"\n        self.shouldStop = True\n\n    def _exc_info_to_string(self, err, test):\n        """Converts a sys.exc_info()-style tuple of values into a string."""\n        exctype, value, tb = err\n        # Skip test runner traceback levels\n        while tb and self._is_relevant_tb_level(tb):\n            tb = tb.tb_next\n        if exctype is test.failureException:\n            # Skip assert*() traceback levels\n            length = self._count_relevant_tb_levels(tb)\n            return \'\'.join(traceback.format_exception(exctype, value, tb, length))\n        return \'\'.join(traceback.format_exception(exctype, value, tb))\n\n    def _is_relevant_tb_level(self, tb):\n        return \'__unittest\' in tb.tb_frame.f_globals\n\n    def _count_relevant_tb_levels(self, tb):\n        length = 0\n        while tb and not self._is_relevant_tb_level(tb):\n            length += 1\n            tb = tb.tb_next\n        return length\n\n    def __repr__(self):\n        return "<%s run=%i errors=%i failures=%i>" % \\\n               (_strclass(self.__class__), self.testsRun, len(self.errors),\n                len(self.failures))\n\nclass TestCase:\n    """A class whose instances are single test cases.\n\n    By default, the test code itself should be placed in a method named\n    \'runTest\'.\n\n    If the fixture may be used for many test cases, create as\n    many test methods as are needed. When instantiating such a TestCase\n    subclass, specify in the constructor arguments the name of the test method\n    that the instance is to execute.\n\n    Test authors should subclass TestCase for their own tests. Construction\n    and deconstruction of the test\'s environment (\'fixture\') can be\n    implemented by overriding the \'setUp\' and \'tearDown\' methods respectively.\n\n    If it is necessary to override the __init__ method, the base class\n    __init__ method must always be called. It is important that subclasses\n    should not change the signature of their __init__ method, since instances\n    of the classes are instantiated automatically by parts of the framework\n    in order to be run.\n    """\n\n    # This attribute determines which exception will be raised when\n    # the instance\'s assertion methods fail; test methods raising this\n    # exception will be deemed to have \'failed\' rather than \'errored\'\n\n    failureException = AssertionError\n\n    def __init__(self, methodName=\'runTest\'):\n        """Create an instance of the class that will use the named test\n           method when executed. Raises a ValueError if the instance does\n           not have a method with the specified name.\n        """\n        try:\n            self._testMethodName = methodName\n            testMethod = getattr(self, methodName)\n            self._testMethodDoc = testMethod.__doc__\n        except AttributeError:\n            raise ValueError, "no such test method in %s: %s" % \\\n                  (self.__class__, methodName)\n\n    def setUp(self):\n        "Hook method for setting up the test fixture before exercising it."\n        pass\n\n    def tearDown(self):\n        "Hook method for deconstructing the test fixture after testing it."\n        pass\n\n    def countTestCases(self):\n        return 1\n\n    def defaultTestResult(self):\n        return TestResult()\n\n    def shortDescription(self):\n        """Returns a one-line description of the test, or None if no\n        description has been provided.\n\n        The default implementation of this method returns the first line of\n        the specified test method\'s docstring.\n        """\n        doc = self._testMethodDoc\n        return doc and doc.split("\\n")[0].strip() or None\n\n    def id(self):\n        return "%s.%s" % (_strclass(self.__class__), self._testMethodName)\n\n    def __eq__(self, other):\n        if type(self) is not type(other):\n            return False\n\n        return self._testMethodName == other._testMethodName\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __hash__(self):\n        return hash((type(self), self._testMethodName))\n\n    def __str__(self):\n        return "%s (%s)" % (self._testMethodName, _strclass(self.__class__))\n\n    def __repr__(self):\n        return "<%s testMethod=%s>" % \\\n               (_strclass(self.__class__), self._testMethodName)\n\n    def run(self, result=None):\n        if result is None: result = self.defaultTestResult()\n        result.startTest(self)\n        testMethod = getattr(self, self._testMethodName)\n        try:\n            try:\n                self.setUp()\n            except KeyboardInterrupt:\n                raise\n            except:\n                result.addError(self, self._exc_info())\n                return\n\n            ok = False\n            try:\n                testMethod()\n                ok = True\n            except self.failureException:\n                result.addFailure(self, self._exc_info())\n            except KeyboardInterrupt:\n                raise\n            except:\n                result.addError(self, self._exc_info())\n\n            try:\n                self.tearDown()\n            except KeyboardInterrupt:\n                raise\n            except:\n                result.addError(self, self._exc_info())\n                ok = False\n            if ok: result.addSuccess(self)\n        finally:\n            result.stopTest(self)\n\n    def __call__(self, *args, **kwds):\n        return self.run(*args, **kwds)\n\n    def debug(self):\n        """Run the test without collecting errors in a TestResult"""\n        self.setUp()\n        getattr(self, self._testMethodName)()\n        self.tearDown()\n\n    def _exc_info(self):\n        """Return a version of sys.exc_info() with the traceback frame\n           minimised; usually the top level of the traceback frame is not\n           needed.\n        """\n        return sys.exc_info()\n\n    def fail(self, msg=None):\n        """Fail immediately, with the given message."""\n        raise self.failureException, msg\n\n    def failIf(self, expr, msg=None):\n        "Fail the test if the expression is true."\n        if expr: raise self.failureException, msg\n\n    def failUnless(self, expr, msg=None):\n        """Fail the test unless the expression is true."""\n        if not expr: raise self.failureException, msg\n\n    def failUnlessRaises(self, excClass, callableObj, *args, **kwargs):\n        """Fail unless an exception of class excClass is thrown\n           by callableObj when invoked with arguments args and keyword\n           arguments kwargs. If a different type of exception is\n           thrown, it will not be caught, and the test case will be\n           deemed to have suffered an error, exactly as for an\n           unexpected exception.\n        """\n        try:\n            callableObj(*args, **kwargs)\n        except excClass:\n            return\n        else:\n            if hasattr(excClass,\'__name__\'): excName = excClass.__name__\n            else: excName = str(excClass)\n            raise self.failureException, "%s not raised" % excName\n\n    def failUnlessEqual(self, first, second, msg=None):\n        """Fail if the two objects are unequal as determined by the \'==\'\n           operator.\n        """\n        if not first == second:\n            raise self.failureException, \\\n                  (msg or \'%r != %r\' % (first, second))\n\n    def failIfEqual(self, first, second, msg=None):\n        """Fail if the two objects are equal as determined by the \'==\'\n           operator.\n        """\n        if first == second:\n            raise self.failureException, \\\n                  (msg or \'%r == %r\' % (first, second))\n\n    def failUnlessAlmostEqual(self, first, second, places=7, msg=None):\n        """Fail if the two objects are unequal as determined by their\n           difference rounded to the given number of decimal places\n           (default 7) and comparing to zero.\n\n           Note that decimal places (from zero) are usually not the same\n           as significant digits (measured from the most signficant digit).\n        """\n        if round(abs(second-first), places) != 0:\n            raise self.failureException, \\\n                  (msg or \'%r != %r within %r places\' % (first, second, places))\n\n    def failIfAlmostEqual(self, first, second, places=7, msg=None):\n        """Fail if the two objects are equal as determined by their\n           difference rounded to the given number of decimal places\n           (default 7) and comparing to zero.\n\n           Note that decimal places (from zero) are usually not the same\n           as significant digits (measured from the most signficant digit).\n        """\n        if round(abs(second-first), places) == 0:\n            raise self.failureException, \\\n                  (msg or \'%r == %r within %r places\' % (first, second, places))\n\n    # Synonyms for assertion methods\n\n    assertEqual = assertEquals = failUnlessEqual\n\n    assertNotEqual = assertNotEquals = failIfEqual\n\n    assertAlmostEqual = assertAlmostEquals = failUnlessAlmostEqual\n\n    assertNotAlmostEqual = assertNotAlmostEquals = failIfAlmostEqual\n\n    assertRaises = failUnlessRaises\n\n    assert_ = assertTrue = failUnless\n\n    assertFalse = failIf\n\n\n\nclass TestSuite:\n    """A test suite is a composite test consisting of a number of TestCases.\n\n    For use, create an instance of TestSuite, then add test case instances.\n    When all tests have been added, the suite can be passed to a test\n    runner, such as TextTestRunner. It will run the individual test cases\n    in the order in which they were added, aggregating the results. When\n    subclassing, do not forget to call the base class constructor.\n    """\n    def __init__(self, tests=()):\n        self._tests = []\n        self.addTests(tests)\n\n    def __repr__(self):\n        return "<%s tests=%s>" % (_strclass(self.__class__), self._tests)\n\n    __str__ = __repr__\n\n    def __eq__(self, other):\n        if type(self) is not type(other):\n            return False\n        return self._tests == other._tests\n\n    def __ne__(self, other):\n        return not self == other\n\n    # Can\'t guarantee hash invariant, so flag as unhashable\n    __hash__ = None\n\n    def __iter__(self):\n        return iter(self._tests)\n\n    def countTestCases(self):\n        cases = 0\n        for test in self._tests:\n            cases += test.countTestCases()\n        return cases\n\n    def addTest(self, test):\n        # sanity checks\n        if not hasattr(test, \'__call__\'):\n            raise TypeError("the test to add must be callable")\n        if (isinstance(test, (type, types.ClassType)) and\n            issubclass(test, (TestCase, TestSuite))):\n            raise TypeError("TestCases and TestSuites must be instantiated "\n                            "before passing them to addTest()")\n        self._tests.append(test)\n\n    def addTests(self, tests):\n        if isinstance(tests, basestring):\n            raise TypeError("tests must be an iterable of tests, not a string")\n        for test in tests:\n            self.addTest(test)\n\n    def run(self, result):\n        for test in self._tests:\n            if result.shouldStop:\n                break\n            test(result)\n        return result\n\n    def __call__(self, *args, **kwds):\n        return self.run(*args, **kwds)\n\n    def debug(self):\n        """Run the tests without collecting errors in a TestResult"""\n        for test in self._tests: test.debug()\n\n\nclass FunctionTestCase(TestCase):\n    """A test case that wraps a test function.\n\n    This is useful for slipping pre-existing test functions into the\n    unittest framework. Optionally, set-up and tidy-up functions can be\n    supplied. As with TestCase, the tidy-up (\'tearDown\') function will\n    always be called if the set-up (\'setUp\') function ran successfully.\n    """\n\n    def __init__(self, testFunc, setUp=None, tearDown=None,\n                 description=None):\n        TestCase.__init__(self)\n        self.__setUpFunc = setUp\n        self.__tearDownFunc = tearDown\n        self.__testFunc = testFunc\n        self.__description = description\n\n    def setUp(self):\n        if self.__setUpFunc is not None:\n            self.__setUpFunc()\n\n    def tearDown(self):\n        if self.__tearDownFunc is not None:\n            self.__tearDownFunc()\n\n    def runTest(self):\n        self.__testFunc()\n\n    def id(self):\n        return self.__testFunc.__name__\n\n    def __eq__(self, other):\n        if type(self) is not type(other):\n            return False\n\n        return self.__setUpFunc == other.__setUpFunc and \\\n               self.__tearDownFunc == other.__tearDownFunc and \\\n               self.__testFunc == other.__testFunc and \\\n               self.__description == other.__description\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __hash__(self):\n        return hash((type(self), self.__setUpFunc, self.__tearDownFunc,\n                                           self.__testFunc, self.__description))\n\n    def __str__(self):\n        return "%s (%s)" % (_strclass(self.__class__), self.__testFunc.__name__)\n\n    def __repr__(self):\n        return "<%s testFunc=%s>" % (_strclass(self.__class__), self.__testFunc)\n\n    def shortDescription(self):\n        if self.__description is not None: return self.__description\n        doc = self.__testFunc.__doc__\n        return doc and doc.split("\\n")[0].strip() or None\n\n\n\n##############################################################################\n# Locating and loading tests\n##############################################################################\n\nclass TestLoader:\n    """This class is responsible for loading tests according to various\n    criteria and returning them wrapped in a TestSuite\n    """\n    testMethodPrefix = \'test\'\n    sortTestMethodsUsing = cmp\n    suiteClass = TestSuite\n\n    def loadTestsFromTestCase(self, testCaseClass):\n        """Return a suite of all tests cases contained in testCaseClass"""\n        if issubclass(testCaseClass, TestSuite):\n            raise TypeError("Test cases should not be derived from TestSuite. Maybe you meant to derive from TestCase?")\n        testCaseNames = self.getTestCaseNames(testCaseClass)\n        if not testCaseNames and hasattr(testCaseClass, \'runTest\'):\n            testCaseNames = [\'runTest\']\n        return self.suiteClass(map(testCaseClass, testCaseNames))\n\n    def loadTestsFromModule(self, module):\n        """Return a suite of all tests cases contained in the given module"""\n        tests = []\n        for name in dir(module):\n            obj = getattr(module, name)\n            if (isinstance(obj, (type, types.ClassType)) and\n                issubclass(obj, TestCase)):\n                tests.append(self.loadTestsFromTestCase(obj))\n        return self.suiteClass(tests)\n\n    def loadTestsFromName(self, name, module=None):\n        """Return a suite of all tests cases given a string specifier.\n\n        The name may resolve either to a module, a test case class, a\n        test method within a test case class, or a callable object which\n        returns a TestCase or TestSuite instance.\n\n        The method optionally resolves the names relative to a given module.\n        """\n        parts = name.split(\'.\')\n        if module is None:\n            parts_copy = parts[:]\n            while parts_copy:\n                try:\n                    module = __import__(\'.\'.join(parts_copy))\n                    break\n                except ImportError:\n                    del parts_copy[-1]\n                    if not parts_copy: raise\n            parts = parts[1:]\n        obj = module\n        for part in parts:\n            parent, obj = obj, getattr(obj, part)\n\n        if type(obj) == types.ModuleType:\n            return self.loadTestsFromModule(obj)\n        elif (isinstance(obj, (type, types.ClassType)) and\n              issubclass(obj, TestCase)):\n            return self.loadTestsFromTestCase(obj)\n        elif (type(obj) == types.UnboundMethodType and\n              isinstance(parent, (type, types.ClassType)) and\n              issubclass(parent, TestCase)):\n            return TestSuite([parent(obj.__name__)])\n        elif isinstance(obj, TestSuite):\n            return obj\n        elif hasattr(obj, \'__call__\'):\n            test = obj()\n            if isinstance(test, TestSuite):\n                return test\n            elif isinstance(test, TestCase):\n                return TestSuite([test])\n            else:\n                raise TypeError("calling %s returned %s, not a test" %\n                                (obj, test))\n        else:\n            raise TypeError("don\'t know how to make test from: %s" % obj)\n\n    def loadTestsFromNames(self, names, module=None):\n        """Return a suite of all tests cases found using the given sequence\n        of string specifiers. See \'loadTestsFromName()\'.\n        """\n        suites = [self.loadTestsFromName(name, module) for name in names]\n        return self.suiteClass(suites)\n\n    def getTestCaseNames(self, testCaseClass):\n        """Return a sorted sequence of method names found within testCaseClass\n        """\n        def isTestMethod(attrname, testCaseClass=testCaseClass, prefix=self.testMethodPrefix):\n            return attrname.startswith(prefix) and hasattr(getattr(testCaseClass, attrname), \'__call__\')\n        testFnNames = filter(isTestMethod, dir(testCaseClass))\n        if self.sortTestMethodsUsing:\n            testFnNames.sort(key=_CmpToKey(self.sortTestMethodsUsing))\n        return testFnNames\n\n\n\ndefaultTestLoader = TestLoader()\n\n\n##############################################################################\n# Patches for old functions: these functions should be considered obsolete\n##############################################################################\n\ndef _makeLoader(prefix, sortUsing, suiteClass=None):\n    loader = TestLoader()\n    loader.sortTestMethodsUsing = sortUsing\n    loader.testMethodPrefix = prefix\n    if suiteClass: loader.suiteClass = suiteClass\n    return loader\n\ndef getTestCaseNames(testCaseClass, prefix, sortUsing=cmp):\n    return _makeLoader(prefix, sortUsing).getTestCaseNames(testCaseClass)\n\ndef makeSuite(testCaseClass, prefix=\'test\', sortUsing=cmp, suiteClass=TestSuite):\n    return _makeLoader(prefix, sortUsing, suiteClass).loadTestsFromTestCase(testCaseClass)\n\ndef findTestCases(module, prefix=\'test\', sortUsing=cmp, suiteClass=TestSuite):\n    return _makeLoader(prefix, sortUsing, suiteClass).loadTestsFromModule(module)\n\n\n##############################################################################\n# Text UI\n##############################################################################\n\nclass _WritelnDecorator:\n    """Used to decorate file-like objects with a handy \'writeln\' method"""\n    def __init__(self,stream):\n        self.stream = stream\n\n    def __getattr__(self, attr):\n        return getattr(self.stream,attr)\n\n    def writeln(self, arg=None):\n        if arg: self.write(arg)\n        self.write(\'\\n\') # text-mode streams translate to \\r\\n if needed\n\n\nclass _TextTestResult(TestResult):\n    """A test result class that can print formatted text results to a stream.\n\n    Used by TextTestRunner.\n    """\n    separator1 = \'=\' * 70\n    separator2 = \'-\' * 70\n\n    def __init__(self, stream, descriptions, verbosity):\n        TestResult.__init__(self)\n        self.stream = stream\n        self.showAll = verbosity > 1\n        self.dots = verbosity == 1\n        self.descriptions = descriptions\n\n    def getDescription(self, test):\n        if self.descriptions:\n            return test.shortDescription() or str(test)\n        else:\n            return str(test)\n\n    def startTest(self, test):\n        TestResult.startTest(self, test)\n        if self.showAll:\n            self.stream.write(self.getDescription(test))\n            self.stream.write(" ... ")\n            self.stream.flush()\n\n    def addSuccess(self, test):\n        TestResult.addSuccess(self, test)\n        if self.showAll:\n            self.stream.writeln("ok")\n        elif self.dots:\n            self.stream.write(\'.\')\n            self.stream.flush()\n\n    def addError(self, test, err):\n        TestResult.addError(self, test, err)\n        if self.showAll:\n            self.stream.writeln("ERROR")\n        elif self.dots:\n            self.stream.write(\'E\')\n            self.stream.flush()\n\n    def addFailure(self, test, err):\n        TestResult.addFailure(self, test, err)\n        if self.showAll:\n            self.stream.writeln("FAIL")\n        elif self.dots:\n            self.stream.write(\'F\')\n            self.stream.flush()\n\n    def printErrors(self):\n        if self.dots or self.showAll:\n            self.stream.writeln()\n        self.printErrorList(\'ERROR\', self.errors)\n        self.printErrorList(\'FAIL\', self.failures)\n\n    def printErrorList(self, flavour, errors):\n        for test, err in errors:\n            self.stream.writeln(self.separator1)\n            self.stream.writeln("%s: %s" % (flavour,self.getDescription(test)))\n            self.stream.writeln(self.separator2)\n            self.stream.writeln("%s" % err)\n\n\nclass TextTestRunner:\n    """A test runner class that displays results in textual form.\n\n    It prints out the names of tests as they are run, errors as they\n    occur, and a summary of the results at the end of the test run.\n    """\n    def __init__(self, stream=sys.stderr, descriptions=1, verbosity=1):\n        self.stream = _WritelnDecorator(stream)\n        self.descriptions = descriptions\n        self.verbosity = verbosity\n\n    def _makeResult(self):\n        return _TextTestResult(self.stream, self.descriptions, self.verbosity)\n\n    def run(self, test):\n        "Run the given test case or test suite."\n        result = self._makeResult()\n        startTime = time.time()\n        test(result)\n        stopTime = time.time()\n        timeTaken = stopTime - startTime\n        result.printErrors()\n        self.stream.writeln(result.separator2)\n        run = result.testsRun\n        self.stream.writeln("Ran %d test%s in %.3fs" %\n                            (run, run != 1 and "s" or "", timeTaken))\n        self.stream.writeln()\n        if not result.wasSuccessful():\n            self.stream.write("FAILED (")\n            failed, errored = map(len, (result.failures, result.errors))\n            if failed:\n                self.stream.write("failures=%d" % failed)\n            if errored:\n                if failed: self.stream.write(", ")\n                self.stream.write("errors=%d" % errored)\n            self.stream.writeln(")")\n        else:\n            self.stream.writeln("OK")\n        return result\n\n\n\n##############################################################################\n# Facilities for running tests from the command line\n##############################################################################\n\nclass TestProgram:\n    """A command-line program that runs a set of tests; this is primarily\n       for making test modules conveniently executable.\n    """\n    USAGE = """\\\nUsage: %(progName)s [options] [test] [...]\n\nOptions:\n  -h, --help       Show this message\n  -v, --verbose    Verbose output\n  -q, --quiet      Minimal output\n\nExamples:\n  %(progName)s                               - run default set of tests\n  %(progName)s MyTestSuite                   - run suite \'MyTestSuite\'\n  %(progName)s MyTestCase.testSomething      - run MyTestCase.testSomething\n  %(progName)s MyTestCase                    - run all \'test*\' test methods\n                                               in MyTestCase\n"""\n    def __init__(self, module=\'__main__\', defaultTest=None,\n                 argv=None, testRunner=None,\n                 testLoader=defaultTestLoader):\n        if type(module) == type(\'\'):\n            self.module = __import__(module)\n            for part in module.split(\'.\')[1:]:\n                self.module = getattr(self.module, part)\n        else:\n            self.module = module\n        if argv is None:\n            argv = sys.argv\n        self.verbosity = 1\n        self.defaultTest = defaultTest\n        self.testRunner = testRunner\n        self.testLoader = testLoader\n        self.progName = os.path.basename(argv[0])\n        self.parseArgs(argv)\n        self.runTests()\n\n    def usageExit(self, msg=None):\n        if msg: print msg\n        print self.USAGE % self.__dict__\n        sys.exit(2)\n\n    def parseArgs(self, argv):\n        import getopt\n        try:\n            options, args = getopt.getopt(argv[1:], \'hHvq\',\n                                          [\'help\',\'verbose\',\'quiet\'])\n            for opt, value in options:\n                if opt in (\'-h\',\'-H\',\'--help\'):\n                    self.usageExit()\n                if opt in (\'-q\',\'--quiet\'):\n                    self.verbosity = 0\n                if opt in (\'-v\',\'--verbose\'):\n                    self.verbosity = 2\n            if len(args) == 0 and self.defaultTest is None:\n                self.test = self.testLoader.loadTestsFromModule(self.module)\n                return\n            if len(args) > 0:\n                self.testNames = args\n            else:\n                self.testNames = (self.defaultTest,)\n            self.createTests()\n        except getopt.error, msg:\n            self.usageExit(msg)\n\n    def createTests(self):\n        self.test = self.testLoader.loadTestsFromNames(self.testNames,\n                                                       self.module)\n\n    def runTests(self):\n        if self.testRunner is None:\n            self.testRunner = TextTestRunner\n\n        if isinstance(self.testRunner, (type, types.ClassType)):\n            try:\n                testRunner = self.testRunner(verbosity=self.verbosity)\n            except TypeError:\n                # didn\'t accept the verbosity argument\n                testRunner = self.testRunner()\n        else:\n            # it is assumed to be a TestRunner instance\n            testRunner = self.testRunner\n        result = testRunner.run(self.test)\n        sys.exit(not result.wasSuccessful())\n\nmain = TestProgram\n\n\n##############################################################################\n# Executing this module from the command line\n##############################################################################\n\nif __name__ == "__main__":\n    main(module=None)\n',
    'src/lib/pythonds/graphs/__init__.py': '\n\nfrom .adjGraph import Graph\nfrom .adjGraph import Vertex\nfrom .priorityQueue import PriorityQueue\n',
    'src/lib/workbench/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineWorkbench(mod);\n  return mod;\n}\n',
    'src/lib/pythonds/graphs/priorityQueue.py': '# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \nimport unittest\n\n# this implementation of binary heap takes key value pairs,\n# we will assume that the keys are all comparable\n\nclass PriorityQueue:\n    def __init__(self):\n        self.heapArray = [(0,0)]\n        self.currentSize = 0\n\n    def buildHeap(self,alist):\n        self.currentSize = len(alist)\n        self.heapArray = [(0,0)]\n        for i in alist:\n            self.heapArray.append(i)\n        i = len(alist) // 2            \n        while (i > 0):\n            self.percDown(i)\n            i = i - 1\n                        \n    def percDown(self,i):\n        while (i * 2) <= self.currentSize:\n            mc = self.minChild(i)\n            if self.heapArray[i][0] > self.heapArray[mc][0]:\n                tmp = self.heapArray[i]\n                self.heapArray[i] = self.heapArray[mc]\n                self.heapArray[mc] = tmp\n            i = mc\n                \n    def minChild(self,i):\n        if i*2 > self.currentSize:\n            return -1\n        else:\n            if i*2 + 1 > self.currentSize:\n                return i*2\n            else:\n                if self.heapArray[i*2][0] < self.heapArray[i*2+1][0]:\n                    return i*2\n                else:\n                    return i*2+1\n\n    def percUp(self,i):\n        while i // 2 > 0:\n            if self.heapArray[i][0] < self.heapArray[i//2][0]:\n               tmp = self.heapArray[i//2]\n               self.heapArray[i//2] = self.heapArray[i]\n               self.heapArray[i] = tmp\n            i = i//2\n \n    def add(self,k):\n        self.heapArray.append(k)\n        self.currentSize = self.currentSize + 1\n        self.percUp(self.currentSize)\n\n    def delMin(self):\n        retval = self.heapArray[1][1]\n        self.heapArray[1] = self.heapArray[self.currentSize]\n        self.currentSize = self.currentSize - 1\n        self.heapArray.pop()\n        self.percDown(1)\n        return retval\n        \n    def isEmpty(self):\n        if self.currentSize == 0:\n            return True\n        else:\n            return False\n\n    def decreaseKey(self,val,amt):\n        # this is a little wierd, but we need to find the heap thing to decrease by\n        # looking at its value\n        done = False\n        i = 1\n        myKey = 0\n        while not done and i <= self.currentSize:\n            if self.heapArray[i][1] == val:\n                done = True\n                myKey = i\n            else:\n                i = i + 1\n        if myKey > 0:\n            self.heapArray[myKey] = (amt,self.heapArray[myKey][1])\n            self.percUp(myKey)\n            \n    def __contains__(self,vtx):\n        for pair in self.heapArray:\n            if pair[1] == vtx:\n                return True\n        return False\n        \nclass TestBinHeap(unittest.TestCase):\n    def setUp(self):\n        self.theHeap = PriorityQueue()\n        self.theHeap.add((2,\'x\'))\n        self.theHeap.add((3,\'y\'))\n        self.theHeap.add((5,\'z\'))\n        self.theHeap.add((6,\'a\'))\n        self.theHeap.add((4,\'d\'))\n\n\n    def testInsert(self):\n        assert self.theHeap.currentSize == 5\n\n    def testDelmin(self):\n        assert self.theHeap.delMin() == \'x\'\n        assert self.theHeap.delMin() == \'y\'\n    \n    def testDecKey(self):\n        self.theHeap.decreaseKey(\'d\',1)\n        assert self.theHeap.delMin() == \'d\'\n        \nif __name__ == \'__main__\':\n    unittest.main()\n',
    'src/lib/pythonds/__init__.py': '',
    'src/lib/cmath/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineComplex(mod, "complex");\n  return mod;\n};\n',
    'src/lib/pythonds/basic/deque.py': '# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n#deque.py\r\n\r\n\r\nclass Deque:\r\n    def __init__(self):\r\n        self.items = []\r\n\r\n    def isEmpty(self):\r\n        return self.items == []\r\n\r\n    def addFront(self, item):\r\n        self.items.append(item)\r\n\r\n    def addRear(self, item):\r\n        self.items.insert(0,item)\r\n\r\n    def removeFront(self):\r\n        return self.items.pop()\r\n\r\n    def removeRear(self):\r\n        return self.items.pop(0)\r\n\r\n    def size(self):\r\n        return len(self.items)\r\n',
    'src/lib/lorentz/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineLorentzian(mod, BLADE);\n  return mod;\n}\n',
    'src/lib/processing/__init__.js': 'var $builtinmodule = function(name)\n{\n    var mod = {};\n    var imList = [];\n    var looping = true;\n\n    // We need this to store a reference to the actual processing object which is not created\n    // until the run function is called.  Even then the processing object is passed by the\n    // processing-js sytem as a parameter to the sketchProc function.  Why not set it to None here\n    //\n\n    // See:  http://processingjs.org/reference/\n\n    mod.processing = null\n    mod.p = null\n\n    mod.CENTER = Sk.builtin.assk$(3, Sk.builtin.nmber.int$);\n    mod.RADIUS = Sk.builtin.assk$(2, Sk.builtin.nmber.int$);\n    mod.CORNERS = Sk.builtin.assk$(1, Sk.builtin.nmber.int$);\n    mod.CORNER = Sk.builtin.assk$(0, Sk.builtin.nmber.int$);\n    mod.RGB = Sk.builtin.assk$(1, Sk.builtin.nmber.int$);\n    mod.HSB = Sk.builtin.assk$(3, Sk.builtin.nmber.int$);\n    mod.CMYK = Sk.builtin.assk$(5, Sk.builtin.nmber.int$);\n    mod.MITER = new Sk.builtin.str(\'miter\');\n    mod.BEVEL = new Sk.builtin.str(\'bevel\');\n    mod.ROUND = new Sk.builtin.str(\'round\');\n    mod.SQUARE = new Sk.builtin.str(\'butt\');\n    mod.PROJECT = new Sk.builtin.str(\'square\');\n\n// 2D - Primitives\n    mod.line = new Sk.builtin.func(function(x1, y1, x2, y2) {\n        mod.processing.line(x1.v, y1.v, x2.v, y2.v);\n    });\n    \n    mod.ellipse = new Sk.builtin.func(function(x,y,r1,r2) {\n        mod.processing.ellipse(x.v,y.v,r1.v,r2.v)\n        \n    });\n\n    mod.point = new Sk.builtin.func(function(x1,y1) {\n        mod.processing.point(x1.v,y1.v)\n    });\n        \n    mod.arc = new Sk.builtin.func(function(x, y, width, height, start, stop) {\n        mod.processing.arc(x.v, y.v, width.v, height.v, start.v, stop.v)\n    });\n\n    mod.quad = new Sk.builtin.func(function(x1, y1, x2, y2, x3, y3, x4, y4) {\n        mod.processing.quad(x1.v, y1.v, x2.v, y2.v, x3.v, y3.v, x4.v, y4.v)\n    });\n            \n    mod.rect = new Sk.builtin.func(function(x, y, width, height, radius) {\n        if (typeof(radius) == \'undefined\') {\n            var rad = 0\n        } else {\n            var rad = radius.v\n        }\n        mod.processing.rect(x.v, y.v, width.v, height.v, rad)\n    });\n    \n    mod.triangle = new Sk.builtin.func(function(x1, y1, x2, y2, x3, y3) {\n            mod.processing.triangle(x1.v, y1.v, x2.v, y2.v, x3.v, y3.v)\n        });\n            \n\n    // 3D Primitives\n\n    // todo:  box, sphere, sphereDetail\n\n    // Color\n    mod.background = new Sk.builtin.func(function(r,g,b) {\n\n        if (typeof(g) !== \'undefined\')\n            g = g.v\n        if (typeof(b) !== \'undefined\')\n            b = b.v\n\n        mod.processing.background(r.v,g,b)\n        \n    });\n\n    mod.fill = new Sk.builtin.func(function(r,g,b) {\n        // r will be either:\n        //      a number in which case the fill will be grayscale\n        //      a color object\n        // g, and b may be undefined.  If they hold values it will\n        // be assumed that we have an r,g,b color tuple\n        if (typeof(g) !== \'undefined\')\n            g = g.v\n        if (typeof(b) !== \'undefined\')\n            b = b.v\n    \n        mod.processing.fill(r.v,g,b)\n        \n    });\n\n\n    mod.stroke = new Sk.builtin.func(function(r,g,b) {\n\n        if (typeof(g) !== \'undefined\')\n            g = g.v\n        if (typeof(b) !== \'undefined\')\n            b = b.v\n\n        mod.processing.stroke(r.v,g,b)\n        \n    });\n\n    mod.noStroke = new Sk.builtin.func(function() {\n        mod.processing.noStroke()\n    });\n    \n\n    mod.colorMode = new Sk.builtin.func(function(model, maxV) {\n        if (typeof(maxV) === \'undefined\')\n            maxV = 255\n        else\n            maxV = maxV.v\n        mod.processing.colorMode(model.v, maxV)\n    });\n\n    mod.noFill = new Sk.builtin.func(function() {\n            mod.processing.noFill()\n        });\n            \n\n    // Environment\n\n    mod.loop = new Sk.builtin.func(function() {\n            if (mod.processing === null) {\n                throw new Sk.builtin.Exception("Loop should be called in setup")\n            }\n            looping = true;\n            mod.processing.loop()\n        });\n            \n    mod.noLoop = new Sk.builtin.func(function() {\n        if (mod.processing === null) {\n            throw new Sk.builtin.Exception("noLoop should be called in setup")\n        }\n        looping = false;\n        mod.processing.noLoop()\n    });\n    \n    mod.frameRate = new Sk.builtin.func(function(fr) {\n        mod.processing.frameRate(fr.v)\n        \n    });\n\n    mod.size = new Sk.builtin.func(function(h,w) {\n        mod.processing.size(h.v,w.v)\n        \n    });\n\n    mod.exitp = new Sk.builtin.func(function(h,w) {\n        mod.processing.exit()\n    });\n\n\n    mod.mouseX = new Sk.builtin.func(function() {\n        return Sk.builtin.assk$(mod.processing.mouseX, Sk.builtin.nmber.int$);\n        \n    });\n\n    mod.mouseY = new Sk.builtin.func(function() {\n        return Sk.builtin.assk$(mod.processing.mouseY, Sk.builtin.nmber.int$);\n        \n    });\n\n    // Attributes\n    mod.rectMode = new Sk.builtin.func(function(mode) {\n        mod.processing.rectMode(mode.v)\n    });\n\n    mod.strokeWeight = new Sk.builtin.func(function(wt) {\n        mod.processing.strokeWeight(wt.v)\n        \n    });\n\n    mod.smooth = new Sk.builtin.func(function() {\n        mod.processing.smooth()\n    });\n\n    mod.noSmooth = new Sk.builtin.func(function() {\n        mod.processing.noSmooth()\n        });\n            \n    mod.ellipseMode = new Sk.builtin.func(function(mode) {\n        mod.processing.ellipseMode(mode.v)\n        });\n\n    mod.strokeCap = new Sk.builtin.func(function(mode) {\n        mod.processing.strokeCap(mode.v)\n        });\n\n    mod.strokeJoin = new Sk.builtin.func(function(mode) {\n        mod.processing.strokeJoin(mode.v)\n    });\n    \n\n\n    // Transforms\n\n    mod.rotate = new Sk.builtin.func(function(rads) {\n        // rotation in radians\n        mod.processing.rotate(rads.v)\n        \n    });\n\n    mod.scale = new Sk.builtin.func(function(sx, sy, sz) {\n        if (typeof(sy) == \'undefined\') {\n            sy = 1.0\n        } else \n            sy = sy.v\n        if (typeof(sz) == \'undefined\') {\n            sz = 1.0\n        } else\n            sz = sz.v\n        mod.processing.scale(sx.v, sy, sz)\n    });\n\n    mod.translate = new Sk.builtin.func(function(sx, sy, sz) {\n        if (typeof(sy) == \'undefined\') {\n            sy = 1.0\n        } else \n            sy = sy.v\n        if (typeof(sz) == \'undefined\') {\n            sz = 1.0\n        } else\n            sz = sz.v\n        mod.processing.translate(sx.v, sy, sz)\n    });\n\n    // todo:  applyMatrix, popMatrix, printMatrix??, pushMatrix, resetMatrix, rotate{X,Y,Z}\n    \n\n    //  //////////////////////////////////////////////////////////////////////\n    //  Run\n    // \n    //  Create the processing context and setup of calls to setup, draw etc.\n    //\n    //\n    //  //////////////////////////////////////////////////////////////////////    \n    mod.run = new Sk.builtin.func(function() {\n        function sketchProc(processing) {\n            mod.processing = processing\n\n            // processing.setup = function() {\n            //     if Sk.globals[\'setup\']\n            //         Sk.misceval.callsim(Sk.globals[\'setup\'])\n            // }\n\n            \n            processing.draw = function() {\n                // if there are pending image loads then just use the natural looping calls to \n                // retry until all the images are loaded.  If noLoop was called in setup then make\n                // sure to revert to that after all the images in hand.\n                var wait = false\n                for (var i in imList) {\n                    if (imList[i].width == 0) {\n                        wait = true\n                    }\n                }\n                if (wait == true) {\n                    if (looping == true) \n                        return\n                    else {\n                        processing.loop()\n                        return\n                    }\n\n                } else {\n                    if (looping == false)\n                        processing.noLoop()\n                }\n\n                mod.frameCount = processing.frameCount  \n                if (Sk.globals[\'draw\'])\n                    Sk.misceval.callsim(Sk.globals[\'draw\'])\n            }\n            \n            var callBacks = [\'setup\', \'mouseMoved\',\'mouseClicked\', \'mouseDragged\', \'mouseMoved\', \'mouseOut\',\n             \'mouseOver\', \'mousePressed\', \'mouseReleased\', \'keyPressed\', \'keyReleased\', \'keyTyped\'\n             ];\n\n             for(var cb in callBacks) {\n                if (Sk.globals[callBacks[cb]]) {\n                    console.log(\'defining \' + callBacks[cb])                    \n                    processing[callBacks[cb]] = new Function("Sk.misceval.callsim(Sk.globals[\'"+callBacks[cb]+"\']);")\n                }\n            }\n        }\n        \n        var canvas = document.getElementById(Sk.canvas)\n        $(canvas).show()\n        mod.p = new Processing(canvas, sketchProc)\n\n        \n    });\n\n    var mouseClass = function($gbl, $loc) {\n\n        $loc.__getattr__ = new Sk.builtin.func(function(self,key) {\n            if (key == \'x\') \n                return mod.processing.mouseX;\n            else if (key == \'y\') \n                return mod.processing.mouseY;\n            else if (key == \'px\')\n                return mod.processing.pmouseX;\n            else if (key == \'py\')\n                return mod.processing.pmouseY;\n            else if (key == \'pressed\')\n                return mod.processing.mousePressed;\n            else if (key == \'button\')\n                return mod.processing.mouseButton\n        });\n\n\n    }\n\n\n    mod.Mouse = Sk.misceval.buildClass(mod, mouseClass, \'Mouse\', []);\n\n    mod.mouse = Sk.misceval.callsim(mod.Mouse)\n\n    var keyboardClass = function($gbl, $loc) {\n\n        $loc.__getattr__ = new Sk.builtin.func(function(self,key) {\n            if (key == \'key\') {\n                console.log(mod.processing.key)\n                return new Sk.builtin.str(mod.processing.key.toString())\n            }\n            else if (key == \'keyCode\') \n                return mod.processing.keyCode\n            else if (key == \'keyPressed\')\n                return new Sk.builtin.str(mod.processing.keyPressed) // todo bool\n        });\n\n\n    }\n\n    mod.Keyboard = Sk.misceval.buildClass(mod,keyboardClass,\'Keyboard\', [])\n\n    mod.keyboard = Sk.misceval.callsim(mod.Keyboard)\n\n\n\n    var environmentClass = function($gbl, $loc) {\n\n        $loc.__getattr__ = new Sk.builtin.func(function(self,key) {\n            if (key == \'frameCount\') \n                return mod.processing.frameCount\n            else if (key == \'frameRate\') \n                return mod.processing.frameRate\n            else if (key == \'height\')\n                return mod.processing.height\n            else if (key == \'width\')\n                return mod.processing.width\n            else if (key == \'online\')\n                return mod.processing.online\n            else if (key == \'focused\')\n                return mod.processing.focused\n        });\n\n\n    }\n\n    mod.Environment = Sk.misceval.buildClass(mod,environmentClass,\'Environment\', [])\n\n    mod.environment = Sk.misceval.callsim(mod.Environment)\n\n    var screenClass = function($gbl, $loc) {\n\n        $loc.__init__ = new Sk.builtin.func(function(self) {\n            self.pixels = null;\n        });\n\n        $loc.__getattr__ = new Sk.builtin.func(function(self,key) {\n            if (key == \'height\')\n                return mod.processing.height\n            else if (key == \'width\')\n                return mod.processing.width\n            else if (key == \'pixels\')\n                if (self.pixels == null) {\n                    self.pixels = new Sk.builtin.list(mod.processing.pixels.toArray())\n                }\n                return self.pixels\n        });\n\n    }\n\n    mod.Screen = Sk.misceval.buildClass(mod,screenClass,\'Screen\', [])\n\n    mod.screen = Sk.misceval.callsim(mod.Screen)\n\n    mod.loadPixels = new Sk.builtin.func(function() {\n        mod.processing.loadPixels()\n        console.log(mod.processing.pixels)\n    });\n    \n\n    var colorClass = function($gbl, $loc) {\n        /* images are loaded async.. so its best to preload them */\n        $loc.__init__ = new Sk.builtin.func(function(self, val1, val2, val3, alpha) {\n            if (typeof(val2) !== \'undefined\')\n                val2 = val2.v\n            if (typeof(val3) !== \'undefined\')\n                val3 = val3.v\n            if (typeof(alpha) !== \'undefined\')\n                alpha = alpha.v\n            self.v = mod.processing.color(val1.v, val2, val3, alpha)\n        })\n    \n    }\n\n    mod.color = Sk.misceval.buildClass(mod,colorClass,\'color\', [])\n\n    mod.red = new Sk.builtin.func(function(clr) {\n        return Sk.builtin.assk$(mod.processing.red(clr.v), Sk.builtin.nmber.int$);\n    });\n    \n    mod.green = new Sk.builtin.func(function(clr) {\n        return Sk.builtin.assk$(mod.processing.green(clr.v), Sk.builtin.nmber.int$);\n    });\n\n    mod.blue = new Sk.builtin.func(function(clr) {\n        return Sk.builtin.assk$(mod.processing.blue(clr.v), Sk.builtin.nmber.int$);\n    });\n\n    // Image class and functions\n    //\n    var imageClass = function($gbl, $loc) {\n        /* images are loaded async.. so its best to preload them */\n        $loc.__init__ = new Sk.builtin.func(function(self,im) {\n            self.v = im\n            self.width = Sk.builtin.assk$(im.width, Sk.builtin.nmber.int$);\n            self.height = Sk.builtin.assk$(im.height, Sk.builtin.nmber.int$);\n        })\n\n        $loc.__getattr__ = new Sk.builtin.func(function(self,key) {\n            if (key == \'width\') return self.v.width;\n            if (key == \'height\') return self.v.height;\n        });\n    \n    }\n\n    mod.PImage = Sk.misceval.buildClass(mod,imageClass,\'PImage\', [])\n\n    mod.loadImage = new Sk.builtin.func(function(imfile) {\n        var i = mod.processing.loadImage(imfile.v);\n        imList.push(i);\n        return Sk.misceval.callsim(mod.PImage,i);\n    });\n    \n\n    mod.image = new Sk.builtin.func(function(im,x,y) {\n        if (im.v.width > 0)\n            mod.processing.image(im.v,x.v,y.v,im.v.width,im.v.height)\n    });\n\n    mod.get = new Sk.builtin.func(function(x,y) {\n        var clr = mod.processing.get(x.v,y.v)\n        return Sk.misceval.callsim(mod.color,\n            Sk.builtin.assk$(mod.processing.red(clr), Sk.builtin.nmber.int$),\n            Sk.builtin.assk$(mod.processing.green(clr), Sk.builtin.nmber.int$),\n            Sk.builtin.assk$(mod.processing.blue(clr), Sk.builtin.nmber.int$));\n    });\n\n    mod.set = new Sk.builtin.func(function(x, y, color) {\n        mod.processing.set(x.v, y.v, color.v)\n    });\n    \n// todo  -- add a color class for creating color objects.\n\n\n    return mod;\n}\n',
    'src/lib/webgl/models.js': '// most of this file is from/based on \'tdl\'\n\nvar $builtinmodule = function(name)\n{\n    var mod = {};\n\n    var Buffer = function(array, opt_target) {\n        var target = opt_target || gl.ARRAY_BUFFER;\n        var buf = gl.createBuffer();\n        this.target = target;\n        this.buf = buf;\n        this.set(array);\n        this.numComponents_ = array.numComponents;\n        this.numElements_ = array.numElements;\n        this.totalComponents_ = this.numComponents_ * this.numElements_;\n        if (array.buffer instanceof Float32Array) {\n            this.type_ = gl.FLOAT;\n        } else if (array.buffer instanceof Uint8Array) {\n            this.type_ = gl.UNSIGNED_BYTE;\n        } else if (array.buffer instanceof Int8Array) {\n            this.type_ = gl._BYTE;\n        } else if (array.buffer instanceof Uint16Array) {\n            this.type_ = gl.UNSIGNED_SHORT;\n        } else if (array.buffer instanceof Int16Array) {\n            this.type_ = gl.SHORT;\n        } else {\n            throw("unhandled type:" + (typeof array.buffer));\n        }\n    };\n\n    Buffer.prototype.set = function(array) {\n        gl.bindBuffer(this.target, this.buf);\n        gl.bufferData(this.target, array.buffer, gl.STATIC_DRAW);\n    }\n\n    Buffer.prototype.type = function() {\n        return this.type_;\n    };\n\n    Buffer.prototype.numComponents = function() {\n        return this.numComponents_;\n    };\n\n    Buffer.prototype.numElements = function() {\n        return this.numElements_;\n    };\n\n    Buffer.prototype.totalComponents = function() {\n        return this.totalComponents_;\n    };\n\n    Buffer.prototype.buffer = function() {\n        return this.buf;\n    };\n\n    Buffer.prototype.stride = function() {\n        return 0;\n    };\n\n    Buffer.prototype.offset = function() {\n        return 0;\n    };\n\n\n\n    mod.Model = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self, shader, arrays, textures)\n                    {\n                        self.buffers = {};\n                        var setBuffer = function(name, array)\n                        {\n                            var target = (name == \'indices\') ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;\n                            b = self.buffers[name];\n                            if (!b)\n                                b = new Buffer(array, target);\n                            else\n                                b.set(array);\n                            self.buffers[name] = b;\n                        };\n                        for (name in arrays)\n                            setBuffer(name, arrays[name]);\n\n                        var textureUnits = {};\n                        var unit = 0;\n                        for (var texture in textures)\n                        {\n                            textureUnits[texture] = unit++;\n                        }\n\n                        self.mode = gl.TRIANGLES;\n                        self.textures = textures.v;\n                        self.textureUnits = textureUnits;\n                        self.shader = shader;\n                    });\n\n                /**\n                * Sets up the shared parts of drawing this model. Uses the\n                * program, binds the buffers, sets the textures.\n                *\n                * @param {!Object.<string, *>} uniforms An object of names to\n                *     values to set on this models uniforms.\n                */\n                $loc.drawPrep = new Sk.builtin.func(function(self, uniforms)\n                    {\n                        var shader = self.shader;\n                        var buffers = self.buffers;\n                        var textures = self.textures;\n\n                        uniforms = Sk.ffi.remapToJs(uniforms);\n\n                        Sk.misceval.callsim(shader.use, shader);\n\n                        for (var buffer in buffers) {\n                            var b = buffers[buffer];\n                            if (buffer == \'indices\') {\n                                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, b.buffer());\n                            } else {\n                                var attrib = shader.attrib[buffer];\n                                if (attrib) {\n                                    attrib(b);\n                                }\n                            }\n                        }\n\n                        for (var texture in textures) {\n                            var unit = self.textureUnits[texture];\n                            shader.setUniform$impl(shader, textuer, unit);\n                            textures[texture].bindToUnit(unit);\n                        }\n\n                        for (var uniform in uniforms) {\n                            shader.setUniform$impl(shader, uniform, uniforms[uniform]);\n                        }\n                    });\n\n                /**\n                * Draws this model.\n                *\n                * After calling tdl.models.Model.drawPrep you can call this\n                * function multiple times to draw this model.\n                *\n                * @param {!Object.<string, *>} uniforms An object of names to\n                *     values to set on this models uniforms.\n                */\n                $loc.draw = new Sk.builtin.func(function(self, uniforms, opt_textures)\n                    {\n                        var shader = self.shader;\n                        uniforms = Sk.ffi.remapToJs(uniforms);\n                        for (uniform in uniforms) {\n                            shader.setUniform$impl(shader, uniform, uniforms[uniform]);\n                        }\n\n                        if (opt_textures) {\n                            for (var texture in opt_textures) {\n                                var unit = self.textureUnits[texture];\n                                shader.setUniform$impl(shader, texture, unit);\n                                opt_textures[texture].bindToUnit(unit);\n                            }\n                        }\n\n                        var buffers = self.buffers;\n                        gl.drawElements(self.mode, buffers.indices.totalComponents(), gl.UNSIGNED_SHORT, 0);\n                    });\n            },\n            \'Model\', []);\n\n    return mod;\n};\n',
    'src/lib/pythonds/trees/__init__.py': '\n# from .binaryTree import BinaryTree\n# from .balance import AVLTree\n# from .bst import BinarySearchTree\n# from .binheap import BinHeap\n\n\n',
    'src/lib/pythonds/trees/binaryTree.py': '# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n\nclass BinaryTree:\n    """\n    A recursive implementation of Binary Tree\n    Using links and Nodes approach.\n    """    \n    def __init__(self,rootObj):\n        self.key = rootObj\n        self.leftChild = None\n        self.rightChild = None\n\n    def insertLeft(self,newNode):\n        if self.leftChild == None:\n            self.leftChild = BinaryTree(newNode)\n        else:\n            t = BinaryTree(newNode)\n            t.left = self.leftChild\n            self.leftChild = t\n    \n    def insertRight(self,newNode):\n        if self.rightChild == None:\n            self.rightChild = BinaryTree(newNode)\n        else:\n            t = BinaryTree(newNode)\n            t.right = self.rightChild\n            self.rightChild = t\n\n    def isLeaf(self):\n        return ((not self.leftChild) and (not self.rightChild))\n\n    def getRightChild(self):\n        return self.rightChild\n\n    def getLeftChild(self):\n        return self.leftChild\n\n    def setRootVal(self,obj):\n        self.key = obj\n\n    def getRootVal(self,):\n        return self.key\n\n    def inorder(self):\n        if self.leftChild:\n            self.leftChild.inorder()\n        print(self.key)\n        if self.rightChild:\n            self.rightChild.inorder()\n\n    def postorder(self):\n        if self.leftChild:\n            self.leftChild.postorder()\n        if self.rightChild:\n            self.rightChild.postorder()\n        print(self.key)\n\n\n    def preorder(self):\n        print(self.key)\n        if self.leftChild:\n            self.leftChild.preorder()\n        if self.rightChild:\n            self.rightChild.preorder()\n\n    def printexp(self):\n        if self.leftChild:\n            print(\'(\')\n            self.leftChild.printexp()\n        print(self.key)\n        if self.rightChild:\n            self.rightChild.printexp()\n            print(\')\')\n\n    def postordereval(self):\n        opers = {\'+\':operator.add, \'-\':operator.sub, \'*\':operator.mul, \'/\':operator.truediv}\n        res1 = None\n        res2 = None\n        if self.leftChild:\n            res1 = self.leftChild.postordereval()  #// \\label{peleft}\n        if self.rightChild:\n            res2 = self.rightChild.postordereval() #// \\label{peright}\n        if res1 and res2:\n            return opers[self.key](res1,res2) #// \\label{peeval}\n        else:\n            return self.key\n\ndef inorder(tree):\n    if tree != None:\n        inorder(tree.getLeftChild())\n        print(tree.getRootVal())\n        inorder(tree.getRightChild())\n\ndef printexp(tree):\n    if tree.leftChild:\n        print(\'(\')\n        printexp(tree.getLeftChild())\n    print(tree.getRootVal())\n    if tree.rightChild:\n        printexp(tree.getRightChild())\n        print(\')\') \n\ndef printexp(tree):\n    sVal = ""\n    if tree:\n        sVal = \'(\' + printexp(tree.getLeftChild())\n        sVal = sVal + str(tree.getRootVal())\n        sVal = sVal + printexp(tree.getRightChild()) + \')\'\n    return sVal\n\ndef postordereval(tree):\n    opers = {\'+\':operator.add, \'-\':operator.sub, \'*\':operator.mul, \'/\':operator.truediv}\n    res1 = None\n    res2 = None\n    if tree:\n        res1 = postordereval(tree.getLeftChild())  #// \\label{peleft}\n        res2 = postordereval(tree.getRightChild()) #// \\label{peright}\n        if res1 and res2:\n            return opers[tree.getRootVal()](res1,res2) #// \\label{peeval}\n        else:\n            return tree.getRootVal()\n\ndef height(tree):\n    if tree == None:\n        return -1\n    else:\n        return 1 + max(height(tree.leftChild),height(tree.rightChild))\n\n# t = BinaryTree(7)\n# t.insertLeft(3)\n# t.insertRight(9)\n# inorder(t)\n# import operator\n# x = BinaryTree(\'*\')\n# x.insertLeft(\'+\')\n# l = x.getLeftChild()\n# l.insertLeft(4)\n# l.insertRight(5)\n# x.insertRight(7)\n# print(printexp(x))\n# print(postordereval(x))\n# print(height(x))\n',
    'src/lib/math/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineMath(mod);\n  return mod;\n};',
    'src/lib/e3ga/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineEuclidean3(mod, THREE, BLADE);\n  return mod;\n}\n',
    'src/lib/webgl/primitives.js': '// most of this file is from \'tdl\'\n\nvar $builtinmodule = function(name)\n{\n    var mod = {};\n\n\n\n    /**\n     * AttribBuffer manages a TypedArray as an array of vectors.\n     *\n     * @param {number} numComponents Number of components per\n     *     vector.\n     * @param {number|!Array.<number>} numElements Number of vectors or the data.\n     * @param {string} opt_type The type of the TypedArray to\n     *     create. Default = \'Float32Array\'.\n     * @param {!Array.<number>} opt_data The data for the array.\n     */\n    var AttribBuffer = function(\n            numComponents, numElements, opt_type) {\n        opt_type = opt_type || \'Float32Array\';\n        var type = window[opt_type];\n        if (numElements.length) {\n            this.buffer = new type(numElements);\n            numElements = this.buffer.length / numComponents;\n            this.cursor = numElements;\n        } else {\n            this.buffer = new type(numComponents * numElements);\n            this.cursor = 0;\n        }\n        this.numComponents = numComponents;\n        this.numElements = numElements;\n        this.type = opt_type;\n    };\n\n    AttribBuffer.prototype.stride = function() {\n        return 0;\n    };\n\n    AttribBuffer.prototype.offset = function() {\n        return 0;\n    };\n\n    AttribBuffer.prototype.getElement = function(index) {\n        var offset = index * this.numComponents;\n        var value = [];\n        for (var ii = 0; ii < this.numComponents; ++ii) {\n            value.push(this.buffer[offset + ii]);\n        }\n        return value;\n    };\n\n    AttribBuffer.prototype.setElement = function(index, value) {\n        var offset = index * this.numComponents;\n        for (var ii = 0; ii < this.numComponents; ++ii) {\n            this.buffer[offset + ii] = value[ii];\n        }\n    };\n\n    AttribBuffer.prototype.clone = function() {\n        var copy = new AttribBuffer(\n                this.numComponents, this.numElements, this.type);\n        copy.pushArray(this);\n        return copy;\n    }\n\n    AttribBuffer.prototype.push = function(value) {\n        this.setElement(this.cursor++, value);\n    };\n\n    AttribBuffer.prototype.pushArray = function(array) {\n        //  this.buffer.set(array, this.cursor * this.numComponents);\n        //  this.cursor += array.numElements;\n        for (var ii = 0; ii < array.numElements; ++ii) {\n            this.push(array.getElement(ii));\n        }\n    };\n\n    AttribBuffer.prototype.pushArrayWithOffset =\n    function(array, offset) {\n        for (var ii = 0; ii < array.numElements; ++ii) {\n            var elem = array.getElement(ii);\n            for (var jj = 0; jj < offset.length; ++jj) {\n                elem[jj] += offset[jj];\n            }\n            this.push(elem);\n        }\n    };\n\n    /**\n    * Computes the extents\n    * @param {!AttribBuffer} positions The positions\n    * @return {!{min: !tdl.math.Vector3, max:!tdl.math.Vector3}}\n    *     The min and max extents.\n    */\n    AttribBuffer.prototype.computeExtents = function() {\n        var numElements = this.numElements;\n        var numComponents = this.numComponents;\n        var minExtent = this.getElement(0);\n        var maxExtent = this.getElement(0);\n        for (var ii = 1; ii < numElements; ++ii) {\n            var element = this.getElement(ii);\n            for (var jj = 0; jj < numComponents; ++jj) {\n                minExtent[jj] = Math.min(minExtent[jj], element[jj]);\n                maxExtent[jj] = Math.max(maxExtent[jj], element[jj]);\n            }\n        }\n        return {min: minExtent, max: maxExtent};\n    };\n\n\n    /**\n     * Creates the vertices and indices for a cube. The\n     * cube will be created around the origin. (-size / 2, size / 2)\n     *\n     * @param {number} size Width, height and depth of the cube.\n     * @return {!Object.<string, !tdl.primitives.AttribBuffer>} The\n     *         created plane vertices.\n     */\n    mod.createCube = new Sk.builtin.func(function(size)\n            {\n                var CUBE_FACE_INDICES_ = [\n                    [3, 7, 5, 1],\n                    [0, 4, 6, 2],\n                    [6, 7, 3, 2],\n                    [0, 1, 5, 4],\n                    [5, 7, 6, 4],\n                    [2, 3, 1, 0]\n                ];\n\n                var k = size / 2;\n\n                var cornerVertices = [\n                        [-k, -k, -k],\n                        [+k, -k, -k],\n                        [-k, +k, -k],\n                        [+k, +k, -k],\n                        [-k, -k, +k],\n                        [+k, -k, +k],\n                        [-k, +k, +k],\n                        [+k, +k, +k]\n                    ];\n\n                var faceNormals = [\n                        [+1, +0, +0],\n                        [-1, +0, +0],\n                        [+0, +1, +0],\n                        [+0, -1, +0],\n                        [+0, +0, +1],\n                        [+0, +0, -1]\n                    ];\n\n                var uvCoords = [\n                        [0, 0],\n                        [1, 0],\n                        [1, 1],\n                        [0, 1]\n                    ];\n\n                var numVertices = 6 * 4;\n                var positions = new AttribBuffer(3, numVertices);\n                var normals = new AttribBuffer(3, numVertices);\n                var texCoords = new AttribBuffer(2, numVertices);\n                var indices = new AttribBuffer(3, 6 * 2, \'Uint16Array\');\n\n                for (var f = 0; f < 6; ++f) {\n                    var faceIndices = CUBE_FACE_INDICES_[f];\n                    for (var v = 0; v < 4; ++v) {\n                        var position = cornerVertices[faceIndices[v]];\n                        var normal = faceNormals[f];\n                        var uv = uvCoords[v];\n\n                        // Each face needs all four vertices because the normals and texture\n                        // coordinates are not all the same.\n                        positions.push(position);\n                        normals.push(normal);\n                        texCoords.push(uv);\n\n                    }\n                    // Two triangles make a square face.\n                    var offset = 4 * f;\n                    indices.push([offset + 0, offset + 1, offset + 2]);\n                    indices.push([offset + 0, offset + 2, offset + 3]);\n                }\n\n                return {\n                        position: positions,\n                        normal: normals,\n                        texCoord: texCoords,\n                        indices: indices\n                };\n            });\n\n    return mod;\n};\n',
    'src/lib/document/__init__.js': 'var $builtinmodule = function(name) {\n    var mod = {};\n\n    mod.getElementById = new Sk.builtin.func(function(id) {\n        var result = document.getElementById(id.v);\n        if (result) {\n            return Sk.misceval.callsim(mod.Element,result);\n        }\n        return Sk.builtin.none.none$;\n    });\n\n    mod.createElement = new Sk.builtin.func(function(eName) {\n            var r = document.createElement(eName.v);\n            if (r) {\n                return Sk.misceval.callsim(mod.Element,r);\n            }\n        });\n\n\n    mod.getElementsByTagName = new Sk.builtin.func(function(tag) {\n        var r = document.getElementsByTagName(tag.v)\n        var reslist = [];\n        for (var i = r.length - 1; i >= 0; i--) {\n            reslist.push(Sk.misceval.callsim(mod.Element,r[i]))\n        }\n        return new Sk.builtin.list(reslist)\n    });\n\n    mod.getElementsByClassName = new Sk.builtin.func(function(cname) {\n        var r = document.getElementsByClassName(cname.v);\n        var reslist = [];\n        for (var i = 0; i < r.length; i++) {\n            reslist.push(Sk.misceval.callsim(mod.Element,r[i]));\n        };\n        return new Sk.builtin.list(reslist);\n    });\n    \n    mod.getElementsByName = new Sk.builtin.func(function(cname) {\n        var r = document.getElementsByName(cname.v);\n        var reslist = [];\n        for (var i = 0; i < r.length; i++) {\n            reslist.push(Sk.misceval.callsim(mod.Element,r[i]));\n        };\n        return new Sk.builtin.list(reslist);\n    });\n        \n    mod.currentDiv = new Sk.builtin.func(function() {\n        if (Sk.divid !== undefined) {\n            return new Sk.builtin.str(Sk.divid)\n        }\n        else {\n            throw new Sk.builtin.AttributeError("There is no value set for divid");\n        }\n    })\n    var elementClass = function($gbl, $loc) {\n        /*\n            Notes:  self[\'$d\'] is the dictionary used by the GenericGetAttr mechanism for an object.\n                    for various reasons  if you create a class in Javascript and have self.xxxx instance\n                    variables, you cannot say instance.xxx and get the value of the instance variable unless \n                    it is stored in the self[\'$d\'] object.  This seems like a duplication of storage to me\n                    but that is how it works right now  (5/2013)\n\n                    Writing your own __getattr__ is also an option but this gets very tricky when an attr is \n                    a method...\n        */\n        $loc.__init__ = new Sk.builtin.func(function(self,elem) {\n            self.v = elem\n            self.innerHTML = elem.innerHTML\n            self.innerText = elem.innerText\n            if (elem.value !== undefined) {\n                self.value = elem.value\n                Sk.abstr.objectSetItem(self[\'$d\'], new Sk.builtin.str(\'value\'), new Sk.builtin.str(self.value))                \n            }\n\n            if (elem.checked !== undefined) {\n                self.checked = elem.checked\n                Sk.abstr.objectSetItem(self[\'$d\'], new Sk.builtin.str(\'checked\'), new Sk.builtin.str(self.checked))                \n            }\n\n            Sk.abstr.objectSetItem(self[\'$d\'], new Sk.builtin.str(\'innerHTML\'), new Sk.builtin.str(self.innerHTML))\n            Sk.abstr.objectSetItem(self[\'$d\'], new Sk.builtin.str(\'innerText\'), new Sk.builtin.str(self.innerText))            \n\n        })\n\n        $loc.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;\n\n        $loc.__setattr__ = new Sk.builtin.func(function(self,key,value) {\n            if (key === \'innerHTML\') {\n                self.innerHTML = value\n                self.v.innerHTML = value.v\n                Sk.abstr.objectSetItem(self[\'$d\'], new Sk.builtin.str(\'innerHTML\'), value)                \n            }\n            if (key === \'innerText\') {\n                self.innerText = value\n                self.v.innerText = value.v\n                Sk.abstr.objectSetItem(self[\'$d\'], new Sk.builtin.str(\'innerText\'), value)            \n            }\n        });\n\n\n        $loc.appendChild = new Sk.builtin.func(function(self,ch) {\n            self.v.appendChild(ch.v);\n        });\n\n        $loc.removeChild = new Sk.builtin.func(function(self,node) {\n            self.v.removeChild(node.v)\n        })\n\n        // getCSS\n                    \n        $loc.getCSS = new Sk.builtin.func(function(self,key) {\n            return new Sk.builtin.str(self.v.style[key.v]);\n        });\n    \n\n        $loc.setCSS = new Sk.builtin.func(function(self,attr,value) {\n            self.v.style[attr.v] = value.v\n\n        })\n\n        $loc.getAttribute = new Sk.builtin.func(function(self,key) {\n            var res = self.v.getAttribute(key.v)\n            if (res) {\n                return new Sk.builtin.str(res)\n            } else {\n                return Sk.builtin.none.none$;\n            }\n        });\n\n        $loc.setAttribute = new Sk.builtin.func(function(self,attr,value) {\n                self.v.setAttribute(attr.v,value.v)\n        });\n            \n\n        $loc.__str__ = new Sk.builtin.func(function(self) {\n            console.log(self.v.tagName);\n            return new Sk.builtin.str(self.v.tagName)\n        })\n\n        $loc.__repr__ = new Sk.builtin.func(function(self) {\n            return new Sk.builtin.str(\'[DOM Element]\')\n        })\n\n    \n    };\n\n    mod.Element = Sk.misceval.buildClass(mod,elementClass,\'Element\', []);\n\n    return mod;\n\n}   ',
    'src/lib/re/__init__.js': 'var $builtinmodule = function(name)\n{\n    var mod = {};\n\n    // Constants (mostly unsupported)\n    mod.I = 2;\n    mod.IGNORECASE = 2;\n    // mod.L = 4;\n    // mod.LOCALE = 4;\n    mod.M = 8;\n    mod.MULTILINE = 8;\n    // mod.S = 16;\n    // mod.DOTALL = 16;\n    // mod.U = 32;\n    // mod.UNICODE = 32;\n    // mod.X = 64;\n    // mod.VERBOSE = 64;\n\n    var validGroups = ["(?:", "(?=", "(?!"];\n\n    var convert = function(pattern) {\n        var newpattern;\n        var match;\n        var i;\n\n        // Look for disallowed constructs\n        match = pattern.match(/\\(\\?./g);\n        if (match) {\n            for (i=0; i<match.length; i++) {\n                if (validGroups.indexOf(match[i]) == -1) {\n                    throw new Sk.builtin.ValueError("Disallowed group in pattern: \'"\n                                                    + match[i] + "\'");\n                };\n            };\n        };\n\n        newpattern = pattern.replace(\'/\\\\/g\', \'\\\\\\\\\');\n        newpattern = pattern.replace(/([^\\\\]){,(?![^\\[]*\\])/g, \'$1{0,\');\n\n        return newpattern;\n    };\n\n    var getFlags = function(flags) {\n        var jsflags = "g";\n        if ((flags & mod.IGNORECASE) == mod.IGNORECASE) {\n            jsflags += "i";\n        };\n        if ((flags & mod.MULTILINE) == mod.MULTILINE) {\n            jsflags += "m";\n        }; \n        return jsflags;\n    };\n\n    mod.split = Sk.nativejs.func(function split(pattern, string, maxsplit, flags) {\n        Sk.builtin.pyCheckArgs("split", arguments, 2, 4);\n        if (!Sk.builtin.checkString(pattern)) {\n            throw new Sk.builtin.TypeError("pattern must be a string");\n        };\n        if (!Sk.builtin.checkString(string)) {\n            throw new Sk.builtin.TypeError("string must be a string");\n        };\n        if (maxsplit === undefined) {\n            maxsplit = 0;\n        };\n        if (!Sk.builtin.checkNumber(maxsplit)) {\n            throw new Sk.builtin.TypeError("maxsplit must be a number");\n        };\n        if (flags === undefined) {\n            flags = 0;\n        };\n        if (!Sk.builtin.checkNumber(flags)) {\n            throw new Sk.builtin.TypeError("flags must be a number");\n        };\n\n\tmaxsplit = Sk.builtin.asnum$(maxsplit);\n        var pat = Sk.ffi.unwrapo(pattern);\n        var str = Sk.ffi.unwrapo(string);\n        \n        // Convert pat from Python to Javascript regex syntax\n        pat = convert(pat);\n        //print("Pat: " + pat);\n        //print("Str: " + str);\n\n        var captured = !(pat.match(/^\\(.*\\)$/) === null);\n        //print("Captured: ", captured);\n\n        var jsflags = getFlags(flags);\n        //print("Flags: ", jsflags);\n\n        var regex = new RegExp(pat, jsflags);\n\n        var result = [];\n        var match;\n        var index = 0;\n        var splits = 0;\n        while ((match = regex.exec(str)) != null) {\n            //print("Matched \'" + match[0] + "\' at position " + match.index + \n            //      "; next search at " + regex.lastIndex);\n            if (match.index === regex.lastIndex) {\n                // empty match\n                break;\n            };\n            result.push(new Sk.builtin.str(str.substring(index, match.index)));\n            if (captured) {\n                // Add matching pattern, too\n                result.push(new Sk.builtin.str(match[0]));\n            };\n            index = regex.lastIndex;\n            splits += 1;\n            if (maxsplit && (splits >= maxsplit)) {\n                break;\n            };\n        };\n        result.push(new Sk.builtin.str(str.substring(index)));\n\n        return new Sk.builtin.list(result);\n    });\n\n    mod.findall = Sk.nativejs.func(function findall(pattern, string, flags) {\n        Sk.builtin.pyCheckArgs("findall", arguments, 2, 3);\n        if (!Sk.builtin.checkString(pattern)) {\n            throw new Sk.builtin.TypeError("pattern must be a string");\n        };\n        if (!Sk.builtin.checkString(string)) {\n            throw new Sk.builtin.TypeError("string must be a string");\n        };\n        if (flags === undefined) {\n            flags = 0;\n        };\n        if (!Sk.builtin.checkNumber(flags)) {\n            throw new Sk.builtin.TypeError("flags must be a number");\n        };\n\n        var pat = Sk.ffi.unwrapo(pattern);\n        var str = Sk.ffi.unwrapo(string);\n        \n        // Convert pat from Python to Javascript regex syntax\n        pat = convert(pat);\n        //print("Pat: " + pat);\n        //print("Str: " + str);\n\n        var jsflags = getFlags(flags);\n        //print("Flags: ", jsflags);\n\n        var regex = new RegExp(pat, jsflags);\n\n\tvar newline_at_end = new RegExp(/\\n$/);\n\tif (str.match(newline_at_end)) {\n\t    str = str.slice(0,-1);\n\t}\n\n        var result = [];\n        var match;\n        while ((match = regex.exec(str)) != null) {\n            //print("Matched \'" + match[0] + "\' at position " + match.index + \n            //      "; next search at " + regex.lastIndex);\n            // print("match: " + JSON.stringify(match));\n            if (match.length < 2) {\n                result.push(new Sk.builtin.str(match[0]));\n            } else if (match.length == 2) {\n                result.push(new Sk.builtin.str(match[1]));\n            } else {\n                var groups = [];\n                for (var i=1; i<match.length; i++) {\n                    groups.push(new Sk.builtin.str(match[i]));  \n                };\n                result.push(new Sk.builtin.tuple(groups));\n            };\n            if (match.index === regex.lastIndex) {\n                regex.lastIndex += 1;\n            };\n        };\n\n        return new Sk.builtin.list(result);\n    });\n\n\n    var matchobj = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self,thematch, pattern, string) {\n            self.thematch = thematch;\n\t    self.re = pattern;\n\t    self.string = string;\n        });\n\n\t$loc.groups = new Sk.builtin.func(function(self) {\n\t    return new Sk.builtin.tuple(self.thematch.v.slice(1))\n\t});\n\n\t$loc.group = new Sk.builtin.func(function(self,grpnum) {\n\t    if (grpnum === undefined) {\n                grpnum = 0;\n            }\n            else {\n                grpnum = Sk.builtin.asnum$(grpnum);\n            }\n\t    if(grpnum >= self.thematch.v.length) {\n\t\tthrow new Sk.builtin.IndexError("Index out of range: " + grpnum);\n\t\t}\n\t    return self.thematch.v[grpnum]\n\t});\n\n    }\n\n    mod.MatchObject = Sk.misceval.buildClass(mod, matchobj, \'MatchObject\', []);\n\n    // Internal function to return a Python list of strings \n    // From a JS regular expression string\n    mod._findre = function(res, string) {\n\tres = res.replace(/([^\\\\]){,(?![^\\[]*\\])/g, \'$1{0,\');\n        var re = eval(res);\n\tvar patt = new RegExp(\'\\n$\');\n\tif (string.v.match(patt))\n\t    var matches = string.v.slice(0,-1).match(re);\n\telse\n            var matches = string.v.match(re);\n        retval = new Sk.builtin.list();\n        if ( matches == null ) return retval;\n        for (var i = 0; i < matches.length; ++i) {\n            var sitem = new Sk.builtin.str(matches[i]);\n            retval.v.push(sitem);\n        }\n        return retval;\n    }\n\n    mod.search = new Sk.builtin.func(function(pattern, string, flags) {\n\tSk.builtin.pyCheckArgs(\'search\', arguments, 2, 3);\n        if (!Sk.builtin.checkString(pattern)) {\n            throw new Sk.builtin.TypeError("pattern must be a string");\n        };\n        if (!Sk.builtin.checkString(string)) {\n            throw new Sk.builtin.TypeError("string must be a string");\n        };\n\tif (flags === undefined) {\n            flags = 0;\n        };\n        if (!Sk.builtin.checkNumber(flags)) {\n            throw new Sk.builtin.TypeError("flags must be a number");\n        };\n        var res = "/"+pattern.v.replace(/\\//g,"\\\\/")+"/";\n        lst = mod._findre(res,string);\n        if ( lst.v.length < 1 ) return Sk.builtin.none.none$;\n        var mob = Sk.misceval.callsim(mod.MatchObject, lst, pattern, string);\n        return mob;\n    });\n\n    mod.match = new Sk.builtin.func(function(pattern, string, flags) {\n\tSk.builtin.pyCheckArgs(\'match\', arguments, 2, 3);\n        if (!Sk.builtin.checkString(pattern)) {\n            throw new Sk.builtin.TypeError("pattern must be a string");\n        };\n        if (!Sk.builtin.checkString(string)) {\n            throw new Sk.builtin.TypeError("string must be a string");\n        };\n\tif (flags === undefined) {\n            flags = 0;\n        };\n        if (!Sk.builtin.checkNumber(flags)) {\n            throw new Sk.builtin.TypeError("flags must be a number");\n        };\n        var res = "/^"+pattern.v.replace(/\\//g,"\\\\/")+"/";\n        lst = mod._findre(res,string);\n        if ( lst.v.length < 1 ) return Sk.builtin.none.none$;\n        var mob = Sk.misceval.callsim(mod.MatchObject, lst, pattern, string);\n        return mob;\n    });\n\n    return mod;\n}\n',
    'src/lib/urllib/__init__.js': 'var $builtinmodule = function(name)\n{\n  var urllib = {};\n\n  return urllib;\n};\n',
    'src/lib/random/__init__.js': '\n/*\n  I\'ve wrapped Makoto Matsumoto and Takuji Nishimura\'s code in a namespace\n  so it\'s better encapsulated. Now you can have multiple random number generators\n  and they won\'t stomp all over eachother\'s state.\n  \n  If you want to use this as a substitute for Math.random(), use the random()\n  method like so:\n  \n  var m = new MersenneTwister();\n  var randomNumber = m.random();\n  \n  You can also call the other genrand_{foo}() methods on the instance.\n\n  If you want to use a specific seed in order to get a repeatable random\n  sequence, pass an integer into the constructor:\n\n  var m = new MersenneTwister(123);\n\n  and that will always produce the same random sequence.\n\n  Sean McCullough (banksean@gmail.com)\n*/\n\n/* \n   A C-program for MT19937, with initialization improved 2002/1/26.\n   Coded by Takuji Nishimura and Makoto Matsumoto.\n \n   Before using, initialize the state by using init_genrand(seed)  \n   or init_by_array(init_key, key_length).\n \n   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,\n   All rights reserved.                          \n \n   Redistribution and use in source and binary forms, with or without\n   modification, are permitted provided that the following conditions\n   are met:\n \n     1. Redistributions of source code must retain the above copyright\n        notice, this list of conditions and the following disclaimer.\n \n     2. Redistributions in binary form must reproduce the above copyright\n        notice, this list of conditions and the following disclaimer in the\n        documentation and/or other materials provided with the distribution.\n \n     3. The names of its contributors may not be used to endorse or promote \n        products derived from this software without specific prior written \n        permission.\n \n   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n \n \n   Any feedback is very welcome.\n   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html\n   email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)\n*/\n\nvar MersenneTwister = function(seed) {\n  if (seed == undefined) {\n    seed = new Date().getTime();\n  }\n  /* Period parameters */\n  this.N = 624;\n  this.M = 397;\n  this.MATRIX_A = 0x9908b0df;   /* constant vector a */\n  this.UPPER_MASK = 0x80000000; /* most significant w-r bits */\n  this.LOWER_MASK = 0x7fffffff; /* least significant r bits */\n \n  this.mt = new Array(this.N); /* the array for the state vector */\n  this.mti=this.N+1; /* mti==N+1 means mt[N] is not initialized */\n\n  this.init_genrand(seed);\n};\n \n/* initializes mt[N] with a seed */\nMersenneTwister.prototype.init_genrand = function(s) {\n  this.mt[0] = s >>> 0;\n  for (this.mti=1; this.mti<this.N; this.mti++) {\n      var s = this.mt[this.mti-1] ^ (this.mt[this.mti-1] >>> 30);\n   this.mt[this.mti] = (((((s & 0xffff0000) >>> 16) * 1812433253) << 16) + (s & 0x0000ffff) * 1812433253)\n  + this.mti;\n      /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */\n      /* In the previous versions, MSBs of the seed affect   */\n      /* only MSBs of the array mt[].                        */\n      /* 2002/01/09 modified by Makoto Matsumoto             */\n      this.mt[this.mti] >>>= 0;\n      /* for >32 bit machines */\n  }\n};\n\n/* initialize by an array with array-length */\n/* init_key is the array for initializing keys */\n/* key_length is its length */\n/* slight change for C++, 2004/2/26 */\nMersenneTwister.prototype.init_by_array = function(init_key, key_length) {\n  var i, j, k;\n  this.init_genrand(19650218);\n  i=1; j=0;\n  k = (this.N>key_length ? this.N : key_length);\n  for (; k; k--) {\n    var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30)\n    this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1664525) << 16) + ((s & 0x0000ffff) * 1664525)))\n      + init_key[j] + j; /* non linear */\n    this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */\n    i++; j++;\n    if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }\n    if (j>=key_length) j=0;\n  }\n  for (k=this.N-1; k; k--) {\n    var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30);\n    this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1566083941) << 16) + (s & 0x0000ffff) * 1566083941))\n      - i; /* non linear */\n    this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */\n    i++;\n    if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }\n  }\n\n  this.mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */ \n};\n\n/* generates a random number on [0,0xffffffff]-interval */\nMersenneTwister.prototype.genrand_int32 = function() {\n  var y;\n  var mag01 = new Array(0x0, this.MATRIX_A);\n  /* mag01[x] = x * MATRIX_A  for x=0,1 */\n\n  if (this.mti >= this.N) { /* generate N words at one time */\n    var kk;\n\n    if (this.mti == this.N+1)   /* if init_genrand() has not been called, */\n      this.init_genrand(5489); /* a default initial seed is used */\n\n    for (kk=0;kk<this.N-this.M;kk++) {\n      y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);\n      this.mt[kk] = this.mt[kk+this.M] ^ (y >>> 1) ^ mag01[y & 0x1];\n    }\n    for (;kk<this.N-1;kk++) {\n      y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);\n      this.mt[kk] = this.mt[kk+(this.M-this.N)] ^ (y >>> 1) ^ mag01[y & 0x1];\n    }\n    y = (this.mt[this.N-1]&this.UPPER_MASK)|(this.mt[0]&this.LOWER_MASK);\n    this.mt[this.N-1] = this.mt[this.M-1] ^ (y >>> 1) ^ mag01[y & 0x1];\n\n    this.mti = 0;\n  }\n\n  y = this.mt[this.mti++];\n\n  /* Tempering */\n  y ^= (y >>> 11);\n  y ^= (y << 7) & 0x9d2c5680;\n  y ^= (y << 15) & 0xefc60000;\n  y ^= (y >>> 18);\n\n  return y >>> 0;\n};\n\n/* generates a random number on [0,0x7fffffff]-interval */\nMersenneTwister.prototype.genrand_int31 = function() {\n  return (this.genrand_int32()>>>1);\n};\n\n/* generates a random number on [0,1]-real-interval */\nMersenneTwister.prototype.genrand_real1 = function() {\n  return this.genrand_int32()*(1.0/4294967295.0);\n  /* divided by 2^32-1 */\n};\n\n/* generates a random number on [0,1)-real-interval */\nMersenneTwister.prototype.random = function() {\n  return this.genrand_int32()*(1.0/4294967296.0); \n  /* divided by 2^32 */\n};\n\n/* generates a random number on (0,1)-real-interval */\nMersenneTwister.prototype.genrand_real3 = function() {\n  return (this.genrand_int32() + 0.5)*(1.0/4294967296.0);\n  /* divided by 2^32 */\n};\n\n/* generates a random number on [0,1) with 53-bit resolution*/\nMersenneTwister.prototype.genrand_res53 = function() {\n  var a=this.genrand_int32()>>>5, b=this.genrand_int32()>>>6;\n  return(a*67108864.0+b)*(1.0/9007199254740992.0);\n};\n\n/* These real versions are due to Isaku Wada, 2002/01/09 added */\n\nvar $builtinmodule = function(name) {\n\n  var mod = {};\n\n  var myGenerator = new MersenneTwister();\n\n  mod.seed = new Sk.builtin.func(function(x) {\n    Sk.builtin.pyCheckArgs("seed", arguments, 0, 1);\n    x = Sk.builtin.asnum$(x);\n\n    if (arguments.length > 0)\n      myGenerator = new MersenneTwister(x);\n    else\n      myGenerator = new MersenneTwister();\n    return Sk.builtin.none.none$;\n  });\n\n  mod.random = new Sk.builtin.func(function() {\n    Sk.builtin.pyCheckArgs("random", arguments, 0, 0);\n    return new Sk.builtin.nmber(myGenerator.genrand_res53(), Sk.builtin.nmber.float$);\n  });\n\n  var toInt = function(num) {\n    return num | 0;\n  };\n\n  var randrange = function(start, stop, step) {\n    // Ported from CPython 2.7\n    var width, n, ret;\n\n    if (!Sk.builtin.checkInt(start)) {\n      throw new Sk.builtin.ValueError("non-integer first argument for randrange()");\n    };\n\n    if (stop === undefined) {\n      // Random in [0, start)\n      return toInt(myGenerator.genrand_res53() * start);\n    };\n\n    if (!Sk.builtin.checkInt(stop)) {\n      throw new Sk.builtin.ValueError("non-integer stop for randrange()");\n    };\n\n    if (step === undefined) {\n      step = 1;\n    };\n\n    width = stop - start;\n\n    if ((step == 1) && (width > 0)) {\n      // Random in [start, stop), must use toInt on product for correct results with negative ranges\n      ret = start + toInt(myGenerator.genrand_res53() * width);\n      return new Sk.builtin.nmber(ret, Sk.builtin.nmber.int$);\n    };\n\n    if (step == 1) {\n      throw new Sk.builtin.ValueError("empty range for randrange() (" + start + ", " + stop + ", " + width + ")");\n    };\n\n    if (!Sk.builtin.checkInt(step)) {\n      throw new Sk.builtin.ValueError("non-integer step for randrange()");\n    };\n\n    if (step > 0) {\n      n = toInt((width + step - 1) / step);\n    } else if (step < 0) {\n      n = toInt((width + step + 1) / step);\n    } else {\n      throw new Sk.builtin.ValueError("zero step for randrange()");\n    };\n\n    if (n <= 0) {\n      throw new Sk.builtin.ValueError("empty range for randrange()");\n    };\n\n    // Random in range(start, stop, step)\n    ret = start + (step * toInt(myGenerator.genrand_res53() * n));\n    return new Sk.builtin.nmber(ret, Sk.builtin.nmber.int$);\n  };\n\n  mod.randint = new Sk.builtin.func(function(a, b) {\n    Sk.builtin.pyCheckArgs("randint", arguments, 2, 2);\n\n    a = Sk.builtin.asnum$(a);\n    b = Sk.builtin.asnum$(b);\n    return randrange(a, b+1);\n  });\n\n  mod.randrange = new Sk.builtin.func(function(start, stop, step) {\n    Sk.builtin.pyCheckArgs("randrange", arguments, 1, 3);\n\n    start = Sk.builtin.asnum$(start);\n    stop = Sk.builtin.asnum$(stop);\n    step = Sk.builtin.asnum$(step);\n    return randrange(start, stop, step);\n  });\n\n  mod.choice = new Sk.builtin.func(function(seq) {\n    Sk.builtin.pyCheckArgs("choice", arguments, 1, 1);\n    Sk.builtin.pyCheckType("seq", "sequence", Sk.builtin.checkSequence(seq));\n\n    if (seq.sq$length !== undefined) {\n      var r = toInt(myGenerator.genrand_res53() * seq.sq$length());\n      return seq.mp$subscript(r);\n    }\n    else {\n      throw new Sk.builtin.TypeError("object has no length");\n    }\n  });\n\n  mod.shuffle = new Sk.builtin.func(function(x) {\n    Sk.builtin.pyCheckArgs("shuffle", arguments, 1, 1);\n    Sk.builtin.pyCheckType("x", "sequence", Sk.builtin.checkSequence(x));\n\n    if (x.sq$length !== undefined) {\n      if (x.mp$ass_subscript !== undefined) {\n        for (var i = x.sq$length() - 1; i > 0; i -= 1) {\n            var r = toInt(myGenerator.genrand_res53() * (i + 1));\n            var tmp = x.mp$subscript(r);\n            x.mp$ass_subscript(r, x.mp$subscript(i));\n            x.mp$ass_subscript(i, tmp);\n        };\n      }\n      else {\n        throw new Sk.builtin.TypeError("object is immutable");\n      };\n    }\n    else {\n      throw new Sk.builtin.TypeError("object has no length");\n    }\n    return Sk.builtin.none.none$;\n  });\n\n  mod[\'uniform\'] = new Sk.builtin.func(function(minPy, maxPy) {\n    Sk.ffi.checkFunctionArgs("uniform", arguments, 2, 2);\n    Sk.ffi.checkArgType("min", [Sk.ffi.PyType.FLOAT], Sk.ffi.isNum(minPy), minPy);\n    Sk.ffi.checkArgType("max", [Sk.ffi.PyType.FLOAT], Sk.ffi.isNum(maxPy), maxPy);\n    var min = Sk.ffi.remapToJs(minPy);\n    var max = Sk.ffi.remapToJs(maxPy);\n    var x = myGenerator.genrand_res53();\n    var y = x * (max - min) + min;\n    return Sk.ffi.numberToFloatPy(y);\n  });\n\n  return mod;\n};',
    'src/lib/test/__init__.py': '__author__ = \'bmiller\'\n\ndef testEqual(actual, expected):\n    if type(expected) == type(1):\n        if actual == expected:\n            print(\'Pass\')\n            return True\n    elif type(expected) == type(1.11):\n        if abs(actual-expected) < 0.00001:\n            print(\'Pass\')\n            return True\n    else:\n        if actual == expected:\n            print(\'Pass\')\n            return True\n    print(\'Test Failed: expected \' + str(expected) + \' but got \' + str(actual))\n    return False\n\ndef testNotEqual(actual, expected):\n    pass\n\n',
    'src/lib/symbolic/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineSymbolic(mod, "symbolic");\n  return mod;\n};\n',
    'src/builtin/this.py': 's = """Gur Mra bs Clguba, ol Gvz Crgref\n\nOrnhgvshy vf orggre guna htyl.\nRkcyvpvg vf orggre guna vzcyvpvg.\nFvzcyr vf orggre guna pbzcyrk.\nPbzcyrk vf orggre guna pbzcyvpngrq.\nSyng vf orggre guna arfgrq.\nFcnefr vf orggre guna qrafr.\nErnqnovyvgl pbhagf.\nFcrpvny pnfrf nera\'g fcrpvny rabhtu gb oernx gur ehyrf.\nNygubhtu cenpgvpnyvgl orngf chevgl.\nReebef fubhyq arire cnff fvyragyl.\nHayrff rkcyvpvgyl fvyraprq.\nVa gur snpr bs nzovthvgl, ershfr gur grzcgngvba gb thrff.\nGurer fubhyq or bar-- naq cersrenoyl bayl bar --boivbhf jnl gb qb vg.\nNygubhtu gung jnl znl abg or boivbhf ng svefg hayrff lbh\'er Qhgpu.\nAbj vf orggre guna arire.\nNygubhtu arire vf bsgra orggre guna *evtug* abj.\nVs gur vzcyrzragngvba vf uneq gb rkcynva, vg\'f n onq vqrn.\nVs gur vzcyrzragngvba vf rnfl gb rkcynva, vg znl or n tbbq vqrn.\nAnzrfcnprf ner bar ubaxvat terng vqrn -- yrg\'f qb zber bs gubfr!"""\n\nd = {}\nfor c in (65, 97):\n    for i in range(26):\n        d[chr(i+c)] = chr((i+13) % 26 + c)\n\nprint "".join([d.get(c, c) for c in s])\n',
    'src/lib/e2ga/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineEuclidean2(mod, BLADE);\n  return mod;\n}\n'
  }
};
!function ($) {
  'use strict';
  var Carousel = function (element, options) {
    this.$element = $(element);
    this.$indicators = this.$element.find('.carousel-indicators');
    this.options = options;
    this.options.pause == 'hover' && this.$element.on('mouseenter', $.proxy(this.pause, this)).on('mouseleave', $.proxy(this.cycle, this));
  };
  Carousel.prototype = {
    cycle: function (e) {
      if (!e)
        this.paused = false;
      if (this.interval)
        clearInterval(this.interval);
      this.options.interval && !this.paused && (this.interval = setInterval($.proxy(this.next, this), this.options.interval));
      return this;
    },
    getActiveIndex: function () {
      this.$active = this.$element.find('.item.active');
      this.$items = this.$active.parent().children();
      return this.$items.index(this.$active);
    },
    to: function (pos) {
      var activeIndex = this.getActiveIndex(), that = this;
      if (pos > this.$items.length - 1 || pos < 0)
        return;
      if (this.sliding) {
        return this.$element.one('slid', function () {
          that.to(pos);
        });
      }
      if (activeIndex == pos) {
        return this.pause().cycle();
      }
      return this.slide(pos > activeIndex ? 'next' : 'prev', $(this.$items[pos]));
    },
    pause: function (e) {
      if (!e)
        this.paused = true;
      if (this.$element.find('.next, .prev').length && $.support.transition.end) {
        this.$element.trigger($.support.transition.end);
        this.cycle(true);
      }
      clearInterval(this.interval);
      this.interval = null;
      return this;
    },
    next: function () {
      if (this.sliding)
        return;
      return this.slide('next');
    },
    prev: function () {
      if (this.sliding)
        return;
      return this.slide('prev');
    },
    slide: function (type, next) {
      var $active = this.$element.find('.item.active'), $next = next || $active[type](), isCycling = this.interval, direction = type == 'next' ? 'left' : 'right', fallback = type == 'next' ? 'first' : 'last', that = this, e;
      this.sliding = true;
      isCycling && this.pause();
      $next = $next.length ? $next : this.$element.find('.item')[fallback]();
      e = $.Event('slide', {
        relatedTarget: $next[0],
        direction: direction
      });
      if ($next.hasClass('active'))
        return;
      if (this.$indicators.length) {
        this.$indicators.find('.active').removeClass('active');
        this.$element.one('slid', function () {
          var $nextIndicator = $(that.$indicators.children()[that.getActiveIndex()]);
          $nextIndicator && $nextIndicator.addClass('active');
        });
      }
      if ($.support.transition && this.$element.hasClass('slide')) {
        this.$element.trigger(e);
        if (e.isDefaultPrevented())
          return;
        $next.addClass(type);
        $next[0].offsetWidth;
        $active.addClass(direction);
        $next.addClass(direction);
        this.$element.one($.support.transition.end, function () {
          $next.removeClass([
            type,
            direction
          ].join(' ')).addClass('active');
          $active.removeClass([
            'active',
            direction
          ].join(' '));
          that.sliding = false;
          setTimeout(function () {
            that.$element.trigger('slid');
          }, 0);
        });
      } else {
        this.$element.trigger(e);
        if (e.isDefaultPrevented())
          return;
        $active.removeClass('active');
        $next.addClass('active');
        this.sliding = false;
        this.$element.trigger('slid');
      }
      isCycling && this.cycle();
      return this;
    }
  };
  var old = $.fn.carousel;
  $.fn.carousel = function (option) {
    return this.each(function () {
      var $this = $(this), data = $this.data('carousel'), options = $.extend({}, $.fn.carousel.defaults, typeof option == 'object' && option), action = typeof option == 'string' ? option : options.slide;
      if (!data)
        $this.data('carousel', data = new Carousel(this, options));
      if (typeof option == 'number')
        data.to(option);
      else if (action)
        data[action]();
      else if (options.interval)
        data.pause().cycle();
    });
  };
  $.fn.carousel.defaults = {
    interval: 5000,
    pause: 'hover'
  };
  $.fn.carousel.Constructor = Carousel;
  $.fn.carousel.noConflict = function () {
    $.fn.carousel = old;
    return this;
  };
  $(document).on('click.carousel.data-api', '[data-slide], [data-slide-to]', function (e) {
    var $this = $(this), href, $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')), options = $.extend({}, $target.data(), $this.data()), slideIndex;
    $target.carousel(options);
    if (slideIndex = $this.attr('data-slide-to')) {
      $target.data('carousel').pause().to(slideIndex).cycle();
    }
    e.preventDefault();
  });
}(window.jQuery);
!function ($) {
  'use strict';
  var Collapse = function (element, options) {
    this.$element = $(element);
    this.options = $.extend({}, $.fn.collapse.defaults, options);
    if (this.options.parent) {
      this.$parent = $(this.options.parent);
    }
    this.options.toggle && this.toggle();
  };
  Collapse.prototype = {
    constructor: Collapse,
    dimension: function () {
      var hasWidth = this.$element.hasClass('width');
      return hasWidth ? 'width' : 'height';
    },
    show: function () {
      var dimension, scroll, actives, hasData;
      if (this.transitioning || this.$element.hasClass('in'))
        return;
      dimension = this.dimension();
      scroll = $.camelCase([
        'scroll',
        dimension
      ].join('-'));
      actives = this.$parent && this.$parent.find('> .accordion-group > .in');
      if (actives && actives.length) {
        hasData = actives.data('collapse');
        if (hasData && hasData.transitioning)
          return;
        actives.collapse('hide');
        hasData || actives.data('collapse', null);
      }
      this.$element[dimension](0);
      this.transition('addClass', $.Event('show'), 'shown');
      $.support.transition && this.$element[dimension](this.$element[0][scroll]);
    },
    hide: function () {
      var dimension;
      if (this.transitioning || !this.$element.hasClass('in'))
        return;
      dimension = this.dimension();
      this.reset(this.$element[dimension]());
      this.transition('removeClass', $.Event('hide'), 'hidden');
      this.$element[dimension](0);
    },
    reset: function (size) {
      var dimension = this.dimension();
      this.$element.removeClass('collapse')[dimension](size || 'auto')[0].offsetWidth;
      this.$element[size !== null ? 'addClass' : 'removeClass']('collapse');
      return this;
    },
    transition: function (method, startEvent, completeEvent) {
      var that = this, complete = function () {
          if (startEvent.type == 'show')
            that.reset();
          that.transitioning = 0;
          that.$element.trigger(completeEvent);
        };
      this.$element.trigger(startEvent);
      if (startEvent.isDefaultPrevented())
        return;
      this.transitioning = 1;
      this.$element[method]('in');
      $.support.transition && this.$element.hasClass('collapse') ? this.$element.one($.support.transition.end, complete) : complete();
    },
    toggle: function () {
      this[this.$element.hasClass('in') ? 'hide' : 'show']();
    }
  };
  var old = $.fn.collapse;
  $.fn.collapse = function (option) {
    return this.each(function () {
      var $this = $(this), data = $this.data('collapse'), options = $.extend({}, $.fn.collapse.defaults, $this.data(), typeof option == 'object' && option);
      if (!data)
        $this.data('collapse', data = new Collapse(this, options));
      if (typeof option == 'string')
        data[option]();
    });
  };
  $.fn.collapse.defaults = { toggle: true };
  $.fn.collapse.Constructor = Collapse;
  $.fn.collapse.noConflict = function () {
    $.fn.collapse = old;
    return this;
  };
  $(document).on('click.collapse.data-api', '[data-toggle=collapse]', function (e) {
    var $this = $(this), href, target = $this.attr('data-target') || e.preventDefault() || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, ''), option = $(target).data('collapse') ? 'toggle' : $this.data();
    $this[$(target).hasClass('in') ? 'addClass' : 'removeClass']('collapsed');
    $(target).collapse(option);
  });
}(window.jQuery);
!function ($) {
  'use strict';
  var toggle = '[data-toggle=dropdown]', Dropdown = function (element) {
      var $el = $(element).on('click.dropdown.data-api', this.toggle);
      $('html').on('click.dropdown.data-api', function () {
        $el.parent().removeClass('open');
      });
    };
  Dropdown.prototype = {
    constructor: Dropdown,
    toggle: function (e) {
      var $this = $(this), $parent, isActive;
      if ($this.is('.disabled, :disabled'))
        return;
      $parent = getParent($this);
      isActive = $parent.hasClass('open');
      clearMenus();
      if (!isActive) {
        if ('ontouchstart' in document.documentElement) {
          $('<div class="dropdown-backdrop"/>').insertBefore($(this)).on('click', clearMenus);
        }
        $parent.toggleClass('open');
      }
      $this.focus();
      return false;
    },
    keydown: function (e) {
      var $this, $items, $active, $parent, isActive, index;
      if (!/(38|40|27)/.test(e.keyCode))
        return;
      $this = $(this);
      e.preventDefault();
      e.stopPropagation();
      if ($this.is('.disabled, :disabled'))
        return;
      $parent = getParent($this);
      isActive = $parent.hasClass('open');
      if (!isActive || isActive && e.keyCode == 27) {
        if (e.which == 27)
          $parent.find(toggle).focus();
        return $this.click();
      }
      $items = $('[role=menu] li:not(.divider):visible a', $parent);
      if (!$items.length)
        return;
      index = $items.index($items.filter(':focus'));
      if (e.keyCode == 38 && index > 0)
        index--;
      if (e.keyCode == 40 && index < $items.length - 1)
        index++;
      if (!~index)
        index = 0;
      $items.eq(index).focus();
    }
  };
  function clearMenus() {
    $('.dropdown-backdrop').remove();
    $(toggle).each(function () {
      getParent($(this)).removeClass('open');
    });
  }
  function getParent($this) {
    var selector = $this.attr('data-target'), $parent;
    if (!selector) {
      selector = $this.attr('href');
      selector = selector && /#/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '');
    }
    $parent = selector && $(selector);
    if (!$parent || !$parent.length)
      $parent = $this.parent();
    return $parent;
  }
  var old = $.fn.dropdown;
  $.fn.dropdown = function (option) {
    return this.each(function () {
      var $this = $(this), data = $this.data('dropdown');
      if (!data)
        $this.data('dropdown', data = new Dropdown(this));
      if (typeof option == 'string')
        data[option].call($this);
    });
  };
  $.fn.dropdown.Constructor = Dropdown;
  $.fn.dropdown.noConflict = function () {
    $.fn.dropdown = old;
    return this;
  };
  $(document).on('click.dropdown.data-api', clearMenus).on('click.dropdown.data-api', '.dropdown form', function (e) {
    e.stopPropagation();
  }).on('click.dropdown.data-api', toggle, Dropdown.prototype.toggle).on('keydown.dropdown.data-api', toggle + ', [role=menu]', Dropdown.prototype.keydown);
}(window.jQuery);
!function ($) {
  'use strict';
  var Modal = function (element, options) {
    this.options = options;
    this.$element = $(element).delegate('[data-dismiss="modal"]', 'click.dismiss.modal', $.proxy(this.hide, this));
    this.options.remote && this.$element.find('.modal-body').load(this.options.remote);
  };
  Modal.prototype = {
    constructor: Modal,
    toggle: function () {
      return this[!this.isShown ? 'show' : 'hide']();
    },
    show: function () {
      var that = this, e = $.Event('show');
      this.$element.trigger(e);
      if (this.isShown || e.isDefaultPrevented())
        return;
      this.isShown = true;
      this.escape();
      this.backdrop(function () {
        var transition = $.support.transition && that.$element.hasClass('fade');
        if (!that.$element.parent().length) {
          that.$element.appendTo(document.body);
        }
        that.$element.show();
        if (transition) {
          that.$element[0].offsetWidth;
        }
        that.$element.addClass('in').attr('aria-hidden', false);
        that.enforceFocus();
        transition ? that.$element.one($.support.transition.end, function () {
          that.$element.focus().trigger('shown');
        }) : that.$element.focus().trigger('shown');
      });
    },
    hide: function (e) {
      e && e.preventDefault();
      var that = this;
      e = $.Event('hide');
      this.$element.trigger(e);
      if (!this.isShown || e.isDefaultPrevented())
        return;
      this.isShown = false;
      this.escape();
      $(document).off('focusin.modal');
      this.$element.removeClass('in').attr('aria-hidden', true);
      $.support.transition && this.$element.hasClass('fade') ? this.hideWithTransition() : this.hideModal();
    },
    enforceFocus: function () {
      var that = this;
      $(document).on('focusin.modal', function (e) {
        if (that.$element[0] !== e.target && !that.$element.has(e.target).length) {
          that.$element.focus();
        }
      });
    },
    escape: function () {
      var that = this;
      if (this.isShown && this.options.keyboard) {
        this.$element.on('keyup.dismiss.modal', function (e) {
          e.which == 27 && that.hide();
        });
      } else if (!this.isShown) {
        this.$element.off('keyup.dismiss.modal');
      }
    },
    hideWithTransition: function () {
      var that = this, timeout = setTimeout(function () {
          that.$element.off($.support.transition.end);
          that.hideModal();
        }, 500);
      this.$element.one($.support.transition.end, function () {
        clearTimeout(timeout);
        that.hideModal();
      });
    },
    hideModal: function () {
      var that = this;
      this.$element.hide();
      this.backdrop(function () {
        that.removeBackdrop();
        that.$element.trigger('hidden');
      });
    },
    removeBackdrop: function () {
      this.$backdrop && this.$backdrop.remove();
      this.$backdrop = null;
    },
    backdrop: function (callback) {
      var that = this, animate = this.$element.hasClass('fade') ? 'fade' : '';
      if (this.isShown && this.options.backdrop) {
        var doAnimate = $.support.transition && animate;
        this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />').appendTo(document.body);
        this.$backdrop.click(this.options.backdrop == 'static' ? $.proxy(this.$element[0].focus, this.$element[0]) : $.proxy(this.hide, this));
        if (doAnimate)
          this.$backdrop[0].offsetWidth;
        this.$backdrop.addClass('in');
        if (!callback)
          return;
        doAnimate ? this.$backdrop.one($.support.transition.end, callback) : callback();
      } else if (!this.isShown && this.$backdrop) {
        this.$backdrop.removeClass('in');
        $.support.transition && this.$element.hasClass('fade') ? this.$backdrop.one($.support.transition.end, callback) : callback();
      } else if (callback) {
        callback();
      }
    }
  };
  var old = $.fn.modal;
  $.fn.modal = function (option) {
    return this.each(function () {
      var $this = $(this), data = $this.data('modal'), options = $.extend({}, $.fn.modal.defaults, $this.data(), typeof option == 'object' && option);
      if (!data)
        $this.data('modal', data = new Modal(this, options));
      if (typeof option == 'string')
        data[option]();
      else if (options.show)
        data.show();
    });
  };
  $.fn.modal.defaults = {
    backdrop: true,
    keyboard: true,
    show: true
  };
  $.fn.modal.Constructor = Modal;
  $.fn.modal.noConflict = function () {
    $.fn.modal = old;
    return this;
  };
  $(document).on('click.modal.data-api', '[data-toggle="modal"]', function (e) {
    var $this = $(this), href = $this.attr('href'), $target = $($this.attr('data-target') || href && href.replace(/.*(?=#[^\s]+$)/, '')), option = $target.data('modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data());
    e.preventDefault();
    $target.modal(option).one('hide', function () {
      $this.focus();
    });
  });
}(window.jQuery);
!function ($) {
  'use strict';
  var Tab = function (element) {
    this.element = $(element);
  };
  Tab.prototype = {
    constructor: Tab,
    show: function () {
      var $this = this.element, $ul = $this.closest('ul:not(.dropdown-menu)'), selector = $this.attr('data-target'), previous, $target, e;
      if (!selector) {
        selector = $this.attr('href');
        selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '');
      }
      if ($this.parent('li').hasClass('active'))
        return;
      previous = $ul.find('.active:last a')[0];
      e = $.Event('show', { relatedTarget: previous });
      $this.trigger(e);
      if (e.isDefaultPrevented())
        return;
      $target = $(selector);
      this.activate($this.parent('li'), $ul);
      this.activate($target, $target.parent(), function () {
        $this.trigger({
          type: 'shown',
          relatedTarget: previous
        });
      });
    },
    activate: function (element, container, callback) {
      var $active = container.find('> .active'), transition = callback && $.support.transition && $active.hasClass('fade');
      function next() {
        $active.removeClass('active').find('> .dropdown-menu > .active').removeClass('active');
        element.addClass('active');
        if (transition) {
          element[0].offsetWidth;
          element.addClass('in');
        } else {
          element.removeClass('fade');
        }
        if (element.parent('.dropdown-menu')) {
          element.closest('li.dropdown').addClass('active');
        }
        callback && callback();
      }
      transition ? $active.one($.support.transition.end, next) : next();
      $active.removeClass('in');
    }
  };
  var old = $.fn.tab;
  $.fn.tab = function (option) {
    return this.each(function () {
      var $this = $(this), data = $this.data('tab');
      if (!data)
        $this.data('tab', data = new Tab(this));
      if (typeof option == 'string')
        data[option]();
    });
  };
  $.fn.tab.Constructor = Tab;
  $.fn.tab.noConflict = function () {
    $.fn.tab = old;
    return this;
  };
  $(document).on('click.tab.data-api', '[data-toggle="tab"], [data-toggle="pill"]', function (e) {
    e.preventDefault();
    $(this).tab('show');
  });
}(window.jQuery);
!function ($) {
  'use strict';
  $(function () {
    $.support.transition = function () {
      var transitionEnd = function () {
          var el = document.createElement('bootstrap'), transEndEventNames = {
              'WebkitTransition': 'webkitTransitionEnd',
              'MozTransition': 'transitionend',
              'OTransition': 'oTransitionEnd otransitionend',
              'transition': 'transitionend'
            }, name;
          for (name in transEndEventNames) {
            if (el.style[name] !== undefined) {
              return transEndEventNames[name];
            }
          }
        }();
      return transitionEnd && { end: transitionEnd };
    }();
  });
}(window.jQuery);
(function (window, document, undefined) {
  'use strict';
  var lowercase = function (string) {
    return isString(string) ? string.toLowerCase() : string;
  };
  var uppercase = function (string) {
    return isString(string) ? string.toUpperCase() : string;
  };
  var manualLowercase = function (s) {
    return isString(s) ? s.replace(/[A-Z]/g, function (ch) {
      return String.fromCharCode(ch.charCodeAt(0) | 32);
    }) : s;
  };
  var manualUppercase = function (s) {
    return isString(s) ? s.replace(/[a-z]/g, function (ch) {
      return String.fromCharCode(ch.charCodeAt(0) & ~32);
    }) : s;
  };
  if ('i' !== 'I'.toLowerCase()) {
    lowercase = manualLowercase;
    uppercase = manualUppercase;
  }
  var msie = int((/msie (\d+)/.exec(lowercase(navigator.userAgent)) || [])[1]), jqLite, jQuery, slice = [].slice, push = [].push, toString = Object.prototype.toString, angular = window.angular || (window.angular = {}), angularModule, nodeName_, uid = [
      '0',
      '0',
      '0'
    ];
  function isArrayLike(obj) {
    if (!obj || typeof obj.length !== 'number')
      return false;
    if (typeof obj.hasOwnProperty != 'function' && typeof obj.constructor != 'function') {
      return true;
    } else {
      return obj instanceof JQLite || jQuery && obj instanceof jQuery || toString.call(obj) !== '[object Object]' || typeof obj.callee === 'function';
    }
  }
  function forEach(obj, iterator, context) {
    var key;
    if (obj) {
      if (isFunction(obj)) {
        for (key in obj) {
          if (key != 'prototype' && key != 'length' && key != 'name' && obj.hasOwnProperty(key)) {
            iterator.call(context, obj[key], key);
          }
        }
      } else if (obj.forEach && obj.forEach !== forEach) {
        obj.forEach(iterator, context);
      } else if (isArrayLike(obj)) {
        for (key = 0; key < obj.length; key++)
          iterator.call(context, obj[key], key);
      } else {
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            iterator.call(context, obj[key], key);
          }
        }
      }
    }
    return obj;
  }
  function sortedKeys(obj) {
    var keys = [];
    for (var key in obj) {
      if (obj.hasOwnProperty(key)) {
        keys.push(key);
      }
    }
    return keys.sort();
  }
  function forEachSorted(obj, iterator, context) {
    var keys = sortedKeys(obj);
    for (var i = 0; i < keys.length; i++) {
      iterator.call(context, obj[keys[i]], keys[i]);
    }
    return keys;
  }
  function reverseParams(iteratorFn) {
    return function (value, key) {
      iteratorFn(key, value);
    };
  }
  function nextUid() {
    var index = uid.length;
    var digit;
    while (index) {
      index--;
      digit = uid[index].charCodeAt(0);
      if (digit == 57) {
        uid[index] = 'A';
        return uid.join('');
      }
      if (digit == 90) {
        uid[index] = '0';
      } else {
        uid[index] = String.fromCharCode(digit + 1);
        return uid.join('');
      }
    }
    uid.unshift('0');
    return uid.join('');
  }
  function setHashKey(obj, h) {
    if (h) {
      obj.$$hashKey = h;
    } else {
      delete obj.$$hashKey;
    }
  }
  function extend(dst) {
    var h = dst.$$hashKey;
    forEach(arguments, function (obj) {
      if (obj !== dst) {
        forEach(obj, function (value, key) {
          dst[key] = value;
        });
      }
    });
    setHashKey(dst, h);
    return dst;
  }
  function int(str) {
    return parseInt(str, 10);
  }
  function inherit(parent, extra) {
    return extend(new (extend(function () {
    }, { prototype: parent }))(), extra);
  }
  function noop() {
  }
  noop.$inject = [];
  function identity($) {
    return $;
  }
  identity.$inject = [];
  function valueFn(value) {
    return function () {
      return value;
    };
  }
  function isUndefined(value) {
    return typeof value == 'undefined';
  }
  function isDefined(value) {
    return typeof value != 'undefined';
  }
  function isObject(value) {
    return value != null && typeof value == 'object';
  }
  function isString(value) {
    return typeof value == 'string';
  }
  function isNumber(value) {
    return typeof value == 'number';
  }
  function isDate(value) {
    return toString.apply(value) == '[object Date]';
  }
  function isArray(value) {
    return toString.apply(value) == '[object Array]';
  }
  function isFunction(value) {
    return typeof value == 'function';
  }
  function isWindow(obj) {
    return obj && obj.document && obj.location && obj.alert && obj.setInterval;
  }
  function isScope(obj) {
    return obj && obj.$evalAsync && obj.$watch;
  }
  function isFile(obj) {
    return toString.apply(obj) === '[object File]';
  }
  function isBoolean(value) {
    return typeof value == 'boolean';
  }
  function trim(value) {
    return isString(value) ? value.replace(/^\s*/, '').replace(/\s*$/, '') : value;
  }
  function isElement(node) {
    return node && (node.nodeName || node.bind && node.find);
  }
  function makeMap(str) {
    var obj = {}, items = str.split(','), i;
    for (i = 0; i < items.length; i++)
      obj[items[i]] = true;
    return obj;
  }
  if (msie < 9) {
    nodeName_ = function (element) {
      element = element.nodeName ? element : element[0];
      return element.scopeName && element.scopeName != 'HTML' ? uppercase(element.scopeName + ':' + element.nodeName) : element.nodeName;
    };
  } else {
    nodeName_ = function (element) {
      return element.nodeName ? element.nodeName : element[0].nodeName;
    };
  }
  function map(obj, iterator, context) {
    var results = [];
    forEach(obj, function (value, index, list) {
      results.push(iterator.call(context, value, index, list));
    });
    return results;
  }
  function size(obj, ownPropsOnly) {
    var size = 0, key;
    if (isArray(obj) || isString(obj)) {
      return obj.length;
    } else if (isObject(obj)) {
      for (key in obj)
        if (!ownPropsOnly || obj.hasOwnProperty(key))
          size++;
    }
    return size;
  }
  function includes(array, obj) {
    return indexOf(array, obj) != -1;
  }
  function indexOf(array, obj) {
    if (array.indexOf)
      return array.indexOf(obj);
    for (var i = 0; i < array.length; i++) {
      if (obj === array[i])
        return i;
    }
    return -1;
  }
  function arrayRemove(array, value) {
    var index = indexOf(array, value);
    if (index >= 0)
      array.splice(index, 1);
    return value;
  }
  function isLeafNode(node) {
    if (node) {
      switch (node.nodeName) {
      case 'OPTION':
      case 'PRE':
      case 'TITLE':
        return true;
      }
    }
    return false;
  }
  function copy(source, destination) {
    if (isWindow(source) || isScope(source))
      throw Error('Can\'t copy Window or Scope');
    if (!destination) {
      destination = source;
      if (source) {
        if (isArray(source)) {
          destination = copy(source, []);
        } else if (isDate(source)) {
          destination = new Date(source.getTime());
        } else if (isObject(source)) {
          destination = copy(source, {});
        }
      }
    } else {
      if (source === destination)
        throw Error('Can\'t copy equivalent objects or arrays');
      if (isArray(source)) {
        destination.length = 0;
        for (var i = 0; i < source.length; i++) {
          destination.push(copy(source[i]));
        }
      } else {
        var h = destination.$$hashKey;
        forEach(destination, function (value, key) {
          delete destination[key];
        });
        for (var key in source) {
          destination[key] = copy(source[key]);
        }
        setHashKey(destination, h);
      }
    }
    return destination;
  }
  function shallowCopy(src, dst) {
    dst = dst || {};
    for (var key in src) {
      if (src.hasOwnProperty(key) && key.substr(0, 2) !== '$$') {
        dst[key] = src[key];
      }
    }
    return dst;
  }
  function equals(o1, o2) {
    if (o1 === o2)
      return true;
    if (o1 === null || o2 === null)
      return false;
    if (o1 !== o1 && o2 !== o2)
      return true;
    var t1 = typeof o1, t2 = typeof o2, length, key, keySet;
    if (t1 == t2) {
      if (t1 == 'object') {
        if (isArray(o1)) {
          if ((length = o1.length) == o2.length) {
            for (key = 0; key < length; key++) {
              if (!equals(o1[key], o2[key]))
                return false;
            }
            return true;
          }
        } else if (isDate(o1)) {
          return isDate(o2) && o1.getTime() == o2.getTime();
        } else {
          if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2))
            return false;
          keySet = {};
          for (key in o1) {
            if (key.charAt(0) === '$' || isFunction(o1[key]))
              continue;
            if (!equals(o1[key], o2[key]))
              return false;
            keySet[key] = true;
          }
          for (key in o2) {
            if (!keySet[key] && key.charAt(0) !== '$' && o2[key] !== undefined && !isFunction(o2[key]))
              return false;
          }
          return true;
        }
      }
    }
    return false;
  }
  function concat(array1, array2, index) {
    return array1.concat(slice.call(array2, index));
  }
  function sliceArgs(args, startIndex) {
    return slice.call(args, startIndex || 0);
  }
  function bind(self, fn) {
    var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
    if (isFunction(fn) && !(fn instanceof RegExp)) {
      return curryArgs.length ? function () {
        return arguments.length ? fn.apply(self, curryArgs.concat(slice.call(arguments, 0))) : fn.apply(self, curryArgs);
      } : function () {
        return arguments.length ? fn.apply(self, arguments) : fn.call(self);
      };
    } else {
      return fn;
    }
  }
  function toJsonReplacer(key, value) {
    var val = value;
    if (/^\$+/.test(key)) {
      val = undefined;
    } else if (isWindow(value)) {
      val = '$WINDOW';
    } else if (value && document === value) {
      val = '$DOCUMENT';
    } else if (isScope(value)) {
      val = '$SCOPE';
    }
    return val;
  }
  function toJson(obj, pretty) {
    return JSON.stringify(obj, toJsonReplacer, pretty ? '  ' : null);
  }
  function fromJson(json) {
    return isString(json) ? JSON.parse(json) : json;
  }
  function toBoolean(value) {
    if (value && value.length !== 0) {
      var v = lowercase('' + value);
      value = !(v == 'f' || v == '0' || v == 'false' || v == 'no' || v == 'n' || v == '[]');
    } else {
      value = false;
    }
    return value;
  }
  function startingTag(element) {
    element = jqLite(element).clone();
    try {
      element.html('');
    } catch (e) {
    }
    var TEXT_NODE = 3;
    var elemHtml = jqLite('<div>').append(element).html();
    try {
      return element[0].nodeType === TEXT_NODE ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function (match, nodeName) {
        return '<' + lowercase(nodeName);
      });
    } catch (e) {
      return lowercase(elemHtml);
    }
  }
  function parseKeyValue(keyValue) {
    var obj = {}, key_value, key;
    forEach((keyValue || '').split('&'), function (keyValue) {
      if (keyValue) {
        key_value = keyValue.split('=');
        key = decodeURIComponent(key_value[0]);
        obj[key] = isDefined(key_value[1]) ? decodeURIComponent(key_value[1]) : true;
      }
    });
    return obj;
  }
  function toKeyValue(obj) {
    var parts = [];
    forEach(obj, function (value, key) {
      parts.push(encodeUriQuery(key, true) + (value === true ? '' : '=' + encodeUriQuery(value, true)));
    });
    return parts.length ? parts.join('&') : '';
  }
  function encodeUriSegment(val) {
    return encodeUriQuery(val, true).replace(/%26/gi, '&').replace(/%3D/gi, '=').replace(/%2B/gi, '+');
  }
  function encodeUriQuery(val, pctEncodeSpaces) {
    return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, pctEncodeSpaces ? '%20' : '+');
  }
  function angularInit(element, bootstrap) {
    var elements = [element], appElement, module, names = [
        'ng:app',
        'ng-app',
        'x-ng-app',
        'data-ng-app'
      ], NG_APP_CLASS_REGEXP = /\sng[:\-]app(:\s*([\w\d_]+);?)?\s/;
    function append(element) {
      element && elements.push(element);
    }
    forEach(names, function (name) {
      names[name] = true;
      append(document.getElementById(name));
      name = name.replace(':', '\\:');
      if (element.querySelectorAll) {
        forEach(element.querySelectorAll('.' + name), append);
        forEach(element.querySelectorAll('.' + name + '\\:'), append);
        forEach(element.querySelectorAll('[' + name + ']'), append);
      }
    });
    forEach(elements, function (element) {
      if (!appElement) {
        var className = ' ' + element.className + ' ';
        var match = NG_APP_CLASS_REGEXP.exec(className);
        if (match) {
          appElement = element;
          module = (match[2] || '').replace(/\s+/g, ',');
        } else {
          forEach(element.attributes, function (attr) {
            if (!appElement && names[attr.name]) {
              appElement = element;
              module = attr.value;
            }
          });
        }
      }
    });
    if (appElement) {
      bootstrap(appElement, module ? [module] : []);
    }
  }
  function bootstrap(element, modules) {
    var resumeBootstrapInternal = function () {
      element = jqLite(element);
      modules = modules || [];
      modules.unshift([
        '$provide',
        function ($provide) {
          $provide.value('$rootElement', element);
        }
      ]);
      modules.unshift('ng');
      var injector = createInjector(modules);
      injector.invoke([
        '$rootScope',
        '$rootElement',
        '$compile',
        '$injector',
        function (scope, element, compile, injector) {
          scope.$apply(function () {
            element.data('$injector', injector);
            compile(element)(scope);
          });
        }
      ]);
      return injector;
    };
    var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
    if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
      return resumeBootstrapInternal();
    }
    window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');
    angular.resumeBootstrap = function (extraModules) {
      forEach(extraModules, function (module) {
        modules.push(module);
      });
      resumeBootstrapInternal();
    };
  }
  var SNAKE_CASE_REGEXP = /[A-Z]/g;
  function snake_case(name, separator) {
    separator = separator || '_';
    return name.replace(SNAKE_CASE_REGEXP, function (letter, pos) {
      return (pos ? separator : '') + letter.toLowerCase();
    });
  }
  function bindJQuery() {
    jQuery = window.jQuery;
    if (jQuery) {
      jqLite = jQuery;
      extend(jQuery.fn, {
        scope: JQLitePrototype.scope,
        controller: JQLitePrototype.controller,
        injector: JQLitePrototype.injector,
        inheritedData: JQLitePrototype.inheritedData
      });
      JQLitePatchJQueryRemove('remove', true);
      JQLitePatchJQueryRemove('empty');
      JQLitePatchJQueryRemove('html');
    } else {
      jqLite = JQLite;
    }
    angular.element = jqLite;
  }
  function assertArg(arg, name, reason) {
    if (!arg) {
      throw new Error('Argument \'' + (name || '?') + '\' is ' + (reason || 'required'));
    }
    return arg;
  }
  function assertArgFn(arg, name, acceptArrayAnnotation) {
    if (acceptArrayAnnotation && isArray(arg)) {
      arg = arg[arg.length - 1];
    }
    assertArg(isFunction(arg), name, 'not a function, got ' + (arg && typeof arg == 'object' ? arg.constructor.name || 'Object' : typeof arg));
    return arg;
  }
  function setupModuleLoader(window) {
    function ensure(obj, name, factory) {
      return obj[name] || (obj[name] = factory());
    }
    return ensure(ensure(window, 'angular', Object), 'module', function () {
      var modules = {};
      return function module(name, requires, configFn) {
        if (requires && modules.hasOwnProperty(name)) {
          modules[name] = null;
        }
        return ensure(modules, name, function () {
          if (!requires) {
            throw Error('No module: ' + name);
          }
          var invokeQueue = [];
          var runBlocks = [];
          var config = invokeLater('$injector', 'invoke');
          var moduleInstance = {
              _invokeQueue: invokeQueue,
              _runBlocks: runBlocks,
              requires: requires,
              name: name,
              provider: invokeLater('$provide', 'provider'),
              factory: invokeLater('$provide', 'factory'),
              service: invokeLater('$provide', 'service'),
              value: invokeLater('$provide', 'value'),
              constant: invokeLater('$provide', 'constant', 'unshift'),
              filter: invokeLater('$filterProvider', 'register'),
              controller: invokeLater('$controllerProvider', 'register'),
              directive: invokeLater('$compileProvider', 'directive'),
              config: config,
              run: function (block) {
                runBlocks.push(block);
                return this;
              }
            };
          if (configFn) {
            config(configFn);
          }
          return moduleInstance;
          function invokeLater(provider, method, insertMethod) {
            return function () {
              invokeQueue[insertMethod || 'push']([
                provider,
                method,
                arguments
              ]);
              return moduleInstance;
            };
          }
        });
      };
    });
  }
  var version = {
      full: '1.0.7',
      major: 1,
      minor: 0,
      dot: 7,
      codeName: 'monochromatic-rainbow'
    };
  function publishExternalAPI(angular) {
    extend(angular, {
      'bootstrap': bootstrap,
      'copy': copy,
      'extend': extend,
      'equals': equals,
      'element': jqLite,
      'forEach': forEach,
      'injector': createInjector,
      'noop': noop,
      'bind': bind,
      'toJson': toJson,
      'fromJson': fromJson,
      'identity': identity,
      'isUndefined': isUndefined,
      'isDefined': isDefined,
      'isString': isString,
      'isFunction': isFunction,
      'isObject': isObject,
      'isNumber': isNumber,
      'isElement': isElement,
      'isArray': isArray,
      'version': version,
      'isDate': isDate,
      'lowercase': lowercase,
      'uppercase': uppercase,
      'callbacks': { counter: 0 }
    });
    angularModule = setupModuleLoader(window);
    try {
      angularModule('ngLocale');
    } catch (e) {
      angularModule('ngLocale', []).provider('$locale', $LocaleProvider);
    }
    angularModule('ng', ['ngLocale'], [
      '$provide',
      function ngModule($provide) {
        $provide.provider('$compile', $CompileProvider).directive({
          a: htmlAnchorDirective,
          input: inputDirective,
          textarea: inputDirective,
          form: formDirective,
          script: scriptDirective,
          select: selectDirective,
          style: styleDirective,
          option: optionDirective,
          ngBind: ngBindDirective,
          ngBindHtmlUnsafe: ngBindHtmlUnsafeDirective,
          ngBindTemplate: ngBindTemplateDirective,
          ngClass: ngClassDirective,
          ngClassEven: ngClassEvenDirective,
          ngClassOdd: ngClassOddDirective,
          ngCsp: ngCspDirective,
          ngCloak: ngCloakDirective,
          ngController: ngControllerDirective,
          ngForm: ngFormDirective,
          ngHide: ngHideDirective,
          ngInclude: ngIncludeDirective,
          ngInit: ngInitDirective,
          ngNonBindable: ngNonBindableDirective,
          ngPluralize: ngPluralizeDirective,
          ngRepeat: ngRepeatDirective,
          ngShow: ngShowDirective,
          ngSubmit: ngSubmitDirective,
          ngStyle: ngStyleDirective,
          ngSwitch: ngSwitchDirective,
          ngSwitchWhen: ngSwitchWhenDirective,
          ngSwitchDefault: ngSwitchDefaultDirective,
          ngOptions: ngOptionsDirective,
          ngView: ngViewDirective,
          ngTransclude: ngTranscludeDirective,
          ngModel: ngModelDirective,
          ngList: ngListDirective,
          ngChange: ngChangeDirective,
          required: requiredDirective,
          ngRequired: requiredDirective,
          ngValue: ngValueDirective
        }).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
        $provide.provider({
          $anchorScroll: $AnchorScrollProvider,
          $browser: $BrowserProvider,
          $cacheFactory: $CacheFactoryProvider,
          $controller: $ControllerProvider,
          $document: $DocumentProvider,
          $exceptionHandler: $ExceptionHandlerProvider,
          $filter: $FilterProvider,
          $interpolate: $InterpolateProvider,
          $http: $HttpProvider,
          $httpBackend: $HttpBackendProvider,
          $location: $LocationProvider,
          $log: $LogProvider,
          $parse: $ParseProvider,
          $route: $RouteProvider,
          $routeParams: $RouteParamsProvider,
          $rootScope: $RootScopeProvider,
          $q: $QProvider,
          $sniffer: $SnifferProvider,
          $templateCache: $TemplateCacheProvider,
          $timeout: $TimeoutProvider,
          $window: $WindowProvider
        });
      }
    ]);
  }
  var jqCache = JQLite.cache = {}, jqName = JQLite.expando = 'ng-' + new Date().getTime(), jqId = 1, addEventListenerFn = window.document.addEventListener ? function (element, type, fn) {
      element.addEventListener(type, fn, false);
    } : function (element, type, fn) {
      element.attachEvent('on' + type, fn);
    }, removeEventListenerFn = window.document.removeEventListener ? function (element, type, fn) {
      element.removeEventListener(type, fn, false);
    } : function (element, type, fn) {
      element.detachEvent('on' + type, fn);
    };
  function jqNextId() {
    return ++jqId;
  }
  var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
  var MOZ_HACK_REGEXP = /^moz([A-Z])/;
  function camelCase(name) {
    return name.replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {
      return offset ? letter.toUpperCase() : letter;
    }).replace(MOZ_HACK_REGEXP, 'Moz$1');
  }
  function JQLitePatchJQueryRemove(name, dispatchThis) {
    var originalJqFn = jQuery.fn[name];
    originalJqFn = originalJqFn.$original || originalJqFn;
    removePatch.$original = originalJqFn;
    jQuery.fn[name] = removePatch;
    function removePatch() {
      var list = [this], fireEvent = dispatchThis, set, setIndex, setLength, element, childIndex, childLength, children, fns, events;
      while (list.length) {
        set = list.shift();
        for (setIndex = 0, setLength = set.length; setIndex < setLength; setIndex++) {
          element = jqLite(set[setIndex]);
          if (fireEvent) {
            element.triggerHandler('$destroy');
          } else {
            fireEvent = !fireEvent;
          }
          for (childIndex = 0, childLength = (children = element.children()).length; childIndex < childLength; childIndex++) {
            list.push(jQuery(children[childIndex]));
          }
        }
      }
      return originalJqFn.apply(this, arguments);
    }
  }
  function JQLite(element) {
    if (element instanceof JQLite) {
      return element;
    }
    if (!(this instanceof JQLite)) {
      if (isString(element) && element.charAt(0) != '<') {
        throw Error('selectors not implemented');
      }
      return new JQLite(element);
    }
    if (isString(element)) {
      var div = document.createElement('div');
      div.innerHTML = '<div>&#160;</div>' + element;
      div.removeChild(div.firstChild);
      JQLiteAddNodes(this, div.childNodes);
      this.remove();
    } else {
      JQLiteAddNodes(this, element);
    }
  }
  function JQLiteClone(element) {
    return element.cloneNode(true);
  }
  function JQLiteDealoc(element) {
    JQLiteRemoveData(element);
    for (var i = 0, children = element.childNodes || []; i < children.length; i++) {
      JQLiteDealoc(children[i]);
    }
  }
  function JQLiteUnbind(element, type, fn) {
    var events = JQLiteExpandoStore(element, 'events'), handle = JQLiteExpandoStore(element, 'handle');
    if (!handle)
      return;
    if (isUndefined(type)) {
      forEach(events, function (eventHandler, type) {
        removeEventListenerFn(element, type, eventHandler);
        delete events[type];
      });
    } else {
      if (isUndefined(fn)) {
        removeEventListenerFn(element, type, events[type]);
        delete events[type];
      } else {
        arrayRemove(events[type], fn);
      }
    }
  }
  function JQLiteRemoveData(element) {
    var expandoId = element[jqName], expandoStore = jqCache[expandoId];
    if (expandoStore) {
      if (expandoStore.handle) {
        expandoStore.events.$destroy && expandoStore.handle({}, '$destroy');
        JQLiteUnbind(element);
      }
      delete jqCache[expandoId];
      element[jqName] = undefined;
    }
  }
  function JQLiteExpandoStore(element, key, value) {
    var expandoId = element[jqName], expandoStore = jqCache[expandoId || -1];
    if (isDefined(value)) {
      if (!expandoStore) {
        element[jqName] = expandoId = jqNextId();
        expandoStore = jqCache[expandoId] = {};
      }
      expandoStore[key] = value;
    } else {
      return expandoStore && expandoStore[key];
    }
  }
  function JQLiteData(element, key, value) {
    var data = JQLiteExpandoStore(element, 'data'), isSetter = isDefined(value), keyDefined = !isSetter && isDefined(key), isSimpleGetter = keyDefined && !isObject(key);
    if (!data && !isSimpleGetter) {
      JQLiteExpandoStore(element, 'data', data = {});
    }
    if (isSetter) {
      data[key] = value;
    } else {
      if (keyDefined) {
        if (isSimpleGetter) {
          return data && data[key];
        } else {
          extend(data, key);
        }
      } else {
        return data;
      }
    }
  }
  function JQLiteHasClass(element, selector) {
    return (' ' + element.className + ' ').replace(/[\n\t]/g, ' ').indexOf(' ' + selector + ' ') > -1;
  }
  function JQLiteRemoveClass(element, cssClasses) {
    if (cssClasses) {
      forEach(cssClasses.split(' '), function (cssClass) {
        element.className = trim((' ' + element.className + ' ').replace(/[\n\t]/g, ' ').replace(' ' + trim(cssClass) + ' ', ' '));
      });
    }
  }
  function JQLiteAddClass(element, cssClasses) {
    if (cssClasses) {
      forEach(cssClasses.split(' '), function (cssClass) {
        if (!JQLiteHasClass(element, cssClass)) {
          element.className = trim(element.className + ' ' + trim(cssClass));
        }
      });
    }
  }
  function JQLiteAddNodes(root, elements) {
    if (elements) {
      elements = !elements.nodeName && isDefined(elements.length) && !isWindow(elements) ? elements : [elements];
      for (var i = 0; i < elements.length; i++) {
        root.push(elements[i]);
      }
    }
  }
  function JQLiteController(element, name) {
    return JQLiteInheritedData(element, '$' + (name || 'ngController') + 'Controller');
  }
  function JQLiteInheritedData(element, name, value) {
    element = jqLite(element);
    if (element[0].nodeType == 9) {
      element = element.find('html');
    }
    while (element.length) {
      if (value = element.data(name))
        return value;
      element = element.parent();
    }
  }
  var JQLitePrototype = JQLite.prototype = {
      ready: function (fn) {
        var fired = false;
        function trigger() {
          if (fired)
            return;
          fired = true;
          fn();
        }
        this.bind('DOMContentLoaded', trigger);
        JQLite(window).bind('load', trigger);
      },
      toString: function () {
        var value = [];
        forEach(this, function (e) {
          value.push('' + e);
        });
        return '[' + value.join(', ') + ']';
      },
      eq: function (index) {
        return index >= 0 ? jqLite(this[index]) : jqLite(this[this.length + index]);
      },
      length: 0,
      push: push,
      sort: [].sort,
      splice: [].splice
    };
  var BOOLEAN_ATTR = {};
  forEach('multiple,selected,checked,disabled,readOnly,required'.split(','), function (value) {
    BOOLEAN_ATTR[lowercase(value)] = value;
  });
  var BOOLEAN_ELEMENTS = {};
  forEach('input,select,option,textarea,button,form'.split(','), function (value) {
    BOOLEAN_ELEMENTS[uppercase(value)] = true;
  });
  function getBooleanAttrName(element, name) {
    var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
    return booleanAttr && BOOLEAN_ELEMENTS[element.nodeName] && booleanAttr;
  }
  forEach({
    data: JQLiteData,
    inheritedData: JQLiteInheritedData,
    scope: function (element) {
      return JQLiteInheritedData(element, '$scope');
    },
    controller: JQLiteController,
    injector: function (element) {
      return JQLiteInheritedData(element, '$injector');
    },
    removeAttr: function (element, name) {
      element.removeAttribute(name);
    },
    hasClass: JQLiteHasClass,
    css: function (element, name, value) {
      name = camelCase(name);
      if (isDefined(value)) {
        element.style[name] = value;
      } else {
        var val;
        if (msie <= 8) {
          val = element.currentStyle && element.currentStyle[name];
          if (val === '')
            val = 'auto';
        }
        val = val || element.style[name];
        if (msie <= 8) {
          val = val === '' ? undefined : val;
        }
        return val;
      }
    },
    attr: function (element, name, value) {
      var lowercasedName = lowercase(name);
      if (BOOLEAN_ATTR[lowercasedName]) {
        if (isDefined(value)) {
          if (!!value) {
            element[name] = true;
            element.setAttribute(name, lowercasedName);
          } else {
            element[name] = false;
            element.removeAttribute(lowercasedName);
          }
        } else {
          return element[name] || (element.attributes.getNamedItem(name) || noop).specified ? lowercasedName : undefined;
        }
      } else if (isDefined(value)) {
        element.setAttribute(name, value);
      } else if (element.getAttribute) {
        var ret = element.getAttribute(name, 2);
        return ret === null ? undefined : ret;
      }
    },
    prop: function (element, name, value) {
      if (isDefined(value)) {
        element[name] = value;
      } else {
        return element[name];
      }
    },
    text: extend(msie < 9 ? function (element, value) {
      if (element.nodeType == 1) {
        if (isUndefined(value))
          return element.innerText;
        element.innerText = value;
      } else {
        if (isUndefined(value))
          return element.nodeValue;
        element.nodeValue = value;
      }
    } : function (element, value) {
      if (isUndefined(value)) {
        return element.textContent;
      }
      element.textContent = value;
    }, { $dv: '' }),
    val: function (element, value) {
      if (isUndefined(value)) {
        return element.value;
      }
      element.value = value;
    },
    html: function (element, value) {
      if (isUndefined(value)) {
        return element.innerHTML;
      }
      for (var i = 0, childNodes = element.childNodes; i < childNodes.length; i++) {
        JQLiteDealoc(childNodes[i]);
      }
      element.innerHTML = value;
    }
  }, function (fn, name) {
    JQLite.prototype[name] = function (arg1, arg2) {
      var i, key;
      if ((fn.length == 2 && (fn !== JQLiteHasClass && fn !== JQLiteController) ? arg1 : arg2) === undefined) {
        if (isObject(arg1)) {
          for (i = 0; i < this.length; i++) {
            if (fn === JQLiteData) {
              fn(this[i], arg1);
            } else {
              for (key in arg1) {
                fn(this[i], key, arg1[key]);
              }
            }
          }
          return this;
        } else {
          if (this.length)
            return fn(this[0], arg1, arg2);
        }
      } else {
        for (i = 0; i < this.length; i++) {
          fn(this[i], arg1, arg2);
        }
        return this;
      }
      return fn.$dv;
    };
  });
  function createEventHandler(element, events) {
    var eventHandler = function (event, type) {
      if (!event.preventDefault) {
        event.preventDefault = function () {
          event.returnValue = false;
        };
      }
      if (!event.stopPropagation) {
        event.stopPropagation = function () {
          event.cancelBubble = true;
        };
      }
      if (!event.target) {
        event.target = event.srcElement || document;
      }
      if (isUndefined(event.defaultPrevented)) {
        var prevent = event.preventDefault;
        event.preventDefault = function () {
          event.defaultPrevented = true;
          prevent.call(event);
        };
        event.defaultPrevented = false;
      }
      event.isDefaultPrevented = function () {
        return event.defaultPrevented;
      };
      forEach(events[type || event.type], function (fn) {
        fn.call(element, event);
      });
      if (msie <= 8) {
        event.preventDefault = null;
        event.stopPropagation = null;
        event.isDefaultPrevented = null;
      } else {
        delete event.preventDefault;
        delete event.stopPropagation;
        delete event.isDefaultPrevented;
      }
    };
    eventHandler.elem = element;
    return eventHandler;
  }
  forEach({
    removeData: JQLiteRemoveData,
    dealoc: JQLiteDealoc,
    bind: function bindFn(element, type, fn) {
      var events = JQLiteExpandoStore(element, 'events'), handle = JQLiteExpandoStore(element, 'handle');
      if (!events)
        JQLiteExpandoStore(element, 'events', events = {});
      if (!handle)
        JQLiteExpandoStore(element, 'handle', handle = createEventHandler(element, events));
      forEach(type.split(' '), function (type) {
        var eventFns = events[type];
        if (!eventFns) {
          if (type == 'mouseenter' || type == 'mouseleave') {
            var contains = document.body.contains || document.body.compareDocumentPosition ? function (a, b) {
                var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
                return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
              } : function (a, b) {
                if (b) {
                  while (b = b.parentNode) {
                    if (b === a) {
                      return true;
                    }
                  }
                }
                return false;
              };
            events[type] = [];
            var eventmap = {
                mouseleave: 'mouseout',
                mouseenter: 'mouseover'
              };
            bindFn(element, eventmap[type], function (event) {
              var ret, target = this, related = event.relatedTarget;
              if (!related || related !== target && !contains(target, related)) {
                handle(event, type);
              }
            });
          } else {
            addEventListenerFn(element, type, handle);
            events[type] = [];
          }
          eventFns = events[type];
        }
        eventFns.push(fn);
      });
    },
    unbind: JQLiteUnbind,
    replaceWith: function (element, replaceNode) {
      var index, parent = element.parentNode;
      JQLiteDealoc(element);
      forEach(new JQLite(replaceNode), function (node) {
        if (index) {
          parent.insertBefore(node, index.nextSibling);
        } else {
          parent.replaceChild(node, element);
        }
        index = node;
      });
    },
    children: function (element) {
      var children = [];
      forEach(element.childNodes, function (element) {
        if (element.nodeType === 1)
          children.push(element);
      });
      return children;
    },
    contents: function (element) {
      return element.childNodes || [];
    },
    append: function (element, node) {
      forEach(new JQLite(node), function (child) {
        if (element.nodeType === 1)
          element.appendChild(child);
      });
    },
    prepend: function (element, node) {
      if (element.nodeType === 1) {
        var index = element.firstChild;
        forEach(new JQLite(node), function (child) {
          if (index) {
            element.insertBefore(child, index);
          } else {
            element.appendChild(child);
            index = child;
          }
        });
      }
    },
    wrap: function (element, wrapNode) {
      wrapNode = jqLite(wrapNode)[0];
      var parent = element.parentNode;
      if (parent) {
        parent.replaceChild(wrapNode, element);
      }
      wrapNode.appendChild(element);
    },
    remove: function (element) {
      JQLiteDealoc(element);
      var parent = element.parentNode;
      if (parent)
        parent.removeChild(element);
    },
    after: function (element, newElement) {
      var index = element, parent = element.parentNode;
      forEach(new JQLite(newElement), function (node) {
        parent.insertBefore(node, index.nextSibling);
        index = node;
      });
    },
    addClass: JQLiteAddClass,
    removeClass: JQLiteRemoveClass,
    toggleClass: function (element, selector, condition) {
      if (isUndefined(condition)) {
        condition = !JQLiteHasClass(element, selector);
      }
      (condition ? JQLiteAddClass : JQLiteRemoveClass)(element, selector);
    },
    parent: function (element) {
      var parent = element.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    next: function (element) {
      if (element.nextElementSibling) {
        return element.nextElementSibling;
      }
      var elm = element.nextSibling;
      while (elm != null && elm.nodeType !== 1) {
        elm = elm.nextSibling;
      }
      return elm;
    },
    find: function (element, selector) {
      return element.getElementsByTagName(selector);
    },
    clone: JQLiteClone,
    triggerHandler: function (element, eventName) {
      var eventFns = (JQLiteExpandoStore(element, 'events') || {})[eventName];
      forEach(eventFns, function (fn) {
        fn.call(element, null);
      });
    }
  }, function (fn, name) {
    JQLite.prototype[name] = function (arg1, arg2) {
      var value;
      for (var i = 0; i < this.length; i++) {
        if (value == undefined) {
          value = fn(this[i], arg1, arg2);
          if (value !== undefined) {
            value = jqLite(value);
          }
        } else {
          JQLiteAddNodes(value, fn(this[i], arg1, arg2));
        }
      }
      return value == undefined ? this : value;
    };
  });
  function hashKey(obj) {
    var objType = typeof obj, key;
    if (objType == 'object' && obj !== null) {
      if (typeof (key = obj.$$hashKey) == 'function') {
        key = obj.$$hashKey();
      } else if (key === undefined) {
        key = obj.$$hashKey = nextUid();
      }
    } else {
      key = obj;
    }
    return objType + ':' + key;
  }
  function HashMap(array) {
    forEach(array, this.put, this);
  }
  HashMap.prototype = {
    put: function (key, value) {
      this[hashKey(key)] = value;
    },
    get: function (key) {
      return this[hashKey(key)];
    },
    remove: function (key) {
      var value = this[key = hashKey(key)];
      delete this[key];
      return value;
    }
  };
  function HashQueueMap() {
  }
  HashQueueMap.prototype = {
    push: function (key, value) {
      var array = this[key = hashKey(key)];
      if (!array) {
        this[key] = [value];
      } else {
        array.push(value);
      }
    },
    shift: function (key) {
      var array = this[key = hashKey(key)];
      if (array) {
        if (array.length == 1) {
          delete this[key];
          return array[0];
        } else {
          return array.shift();
        }
      }
    },
    peek: function (key) {
      var array = this[hashKey(key)];
      if (array) {
        return array[0];
      }
    }
  };
  var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;
  var FN_ARG_SPLIT = /,/;
  var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
  var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
  function annotate(fn) {
    var $inject, fnText, argDecl, last;
    if (typeof fn == 'function') {
      if (!($inject = fn.$inject)) {
        $inject = [];
        fnText = fn.toString().replace(STRIP_COMMENTS, '');
        argDecl = fnText.match(FN_ARGS);
        forEach(argDecl[1].split(FN_ARG_SPLIT), function (arg) {
          arg.replace(FN_ARG, function (all, underscore, name) {
            $inject.push(name);
          });
        });
        fn.$inject = $inject;
      }
    } else if (isArray(fn)) {
      last = fn.length - 1;
      assertArgFn(fn[last], 'fn');
      $inject = fn.slice(0, last);
    } else {
      assertArgFn(fn, 'fn', true);
    }
    return $inject;
  }
  function createInjector(modulesToLoad) {
    var INSTANTIATING = {}, providerSuffix = 'Provider', path = [], loadedModules = new HashMap(), providerCache = {
        $provide: {
          provider: supportObject(provider),
          factory: supportObject(factory),
          service: supportObject(service),
          value: supportObject(value),
          constant: supportObject(constant),
          decorator: decorator
        }
      }, providerInjector = createInternalInjector(providerCache, function () {
        throw Error('Unknown provider: ' + path.join(' <- '));
      }), instanceCache = {}, instanceInjector = instanceCache.$injector = createInternalInjector(instanceCache, function (servicename) {
        var provider = providerInjector.get(servicename + providerSuffix);
        return instanceInjector.invoke(provider.$get, provider);
      });
    forEach(loadModules(modulesToLoad), function (fn) {
      instanceInjector.invoke(fn || noop);
    });
    return instanceInjector;
    function supportObject(delegate) {
      return function (key, value) {
        if (isObject(key)) {
          forEach(key, reverseParams(delegate));
        } else {
          return delegate(key, value);
        }
      };
    }
    function provider(name, provider_) {
      if (isFunction(provider_) || isArray(provider_)) {
        provider_ = providerInjector.instantiate(provider_);
      }
      if (!provider_.$get) {
        throw Error('Provider ' + name + ' must define $get factory method.');
      }
      return providerCache[name + providerSuffix] = provider_;
    }
    function factory(name, factoryFn) {
      return provider(name, { $get: factoryFn });
    }
    function service(name, constructor) {
      return factory(name, [
        '$injector',
        function ($injector) {
          return $injector.instantiate(constructor);
        }
      ]);
    }
    function value(name, value) {
      return factory(name, valueFn(value));
    }
    function constant(name, value) {
      providerCache[name] = value;
      instanceCache[name] = value;
    }
    function decorator(serviceName, decorFn) {
      var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get;
      origProvider.$get = function () {
        var origInstance = instanceInjector.invoke(orig$get, origProvider);
        return instanceInjector.invoke(decorFn, null, { $delegate: origInstance });
      };
    }
    function loadModules(modulesToLoad) {
      var runBlocks = [];
      forEach(modulesToLoad, function (module) {
        if (loadedModules.get(module))
          return;
        loadedModules.put(module, true);
        if (isString(module)) {
          var moduleFn = angularModule(module);
          runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
          try {
            for (var invokeQueue = moduleFn._invokeQueue, i = 0, ii = invokeQueue.length; i < ii; i++) {
              var invokeArgs = invokeQueue[i], provider = invokeArgs[0] == '$injector' ? providerInjector : providerInjector.get(invokeArgs[0]);
              provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
            }
          } catch (e) {
            if (e.message)
              e.message += ' from ' + module;
            throw e;
          }
        } else if (isFunction(module)) {
          try {
            runBlocks.push(providerInjector.invoke(module));
          } catch (e) {
            if (e.message)
              e.message += ' from ' + module;
            throw e;
          }
        } else if (isArray(module)) {
          try {
            runBlocks.push(providerInjector.invoke(module));
          } catch (e) {
            if (e.message)
              e.message += ' from ' + String(module[module.length - 1]);
            throw e;
          }
        } else {
          assertArgFn(module, 'module');
        }
      });
      return runBlocks;
    }
    function createInternalInjector(cache, factory) {
      function getService(serviceName) {
        if (typeof serviceName !== 'string') {
          throw Error('Service name expected');
        }
        if (cache.hasOwnProperty(serviceName)) {
          if (cache[serviceName] === INSTANTIATING) {
            throw Error('Circular dependency: ' + path.join(' <- '));
          }
          return cache[serviceName];
        } else {
          try {
            path.unshift(serviceName);
            cache[serviceName] = INSTANTIATING;
            return cache[serviceName] = factory(serviceName);
          } finally {
            path.shift();
          }
        }
      }
      function invoke(fn, self, locals) {
        var args = [], $inject = annotate(fn), length, i, key;
        for (i = 0, length = $inject.length; i < length; i++) {
          key = $inject[i];
          args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key));
        }
        if (!fn.$inject) {
          fn = fn[length];
        }
        switch (self ? -1 : args.length) {
        case 0:
          return fn();
        case 1:
          return fn(args[0]);
        case 2:
          return fn(args[0], args[1]);
        case 3:
          return fn(args[0], args[1], args[2]);
        case 4:
          return fn(args[0], args[1], args[2], args[3]);
        case 5:
          return fn(args[0], args[1], args[2], args[3], args[4]);
        case 6:
          return fn(args[0], args[1], args[2], args[3], args[4], args[5]);
        case 7:
          return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        case 8:
          return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);
        case 9:
          return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]);
        case 10:
          return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]);
        default:
          return fn.apply(self, args);
        }
      }
      function instantiate(Type, locals) {
        var Constructor = function () {
          }, instance, returnedValue;
        Constructor.prototype = (isArray(Type) ? Type[Type.length - 1] : Type).prototype;
        instance = new Constructor();
        returnedValue = invoke(Type, instance, locals);
        return isObject(returnedValue) ? returnedValue : instance;
      }
      return {
        invoke: invoke,
        instantiate: instantiate,
        get: getService,
        annotate: annotate
      };
    }
  }
  function $AnchorScrollProvider() {
    var autoScrollingEnabled = true;
    this.disableAutoScrolling = function () {
      autoScrollingEnabled = false;
    };
    this.$get = [
      '$window',
      '$location',
      '$rootScope',
      function ($window, $location, $rootScope) {
        var document = $window.document;
        function getFirstAnchor(list) {
          var result = null;
          forEach(list, function (element) {
            if (!result && lowercase(element.nodeName) === 'a')
              result = element;
          });
          return result;
        }
        function scroll() {
          var hash = $location.hash(), elm;
          if (!hash)
            $window.scrollTo(0, 0);
          else if (elm = document.getElementById(hash))
            elm.scrollIntoView();
          else if (elm = getFirstAnchor(document.getElementsByName(hash)))
            elm.scrollIntoView();
          else if (hash === 'top')
            $window.scrollTo(0, 0);
        }
        if (autoScrollingEnabled) {
          $rootScope.$watch(function autoScrollWatch() {
            return $location.hash();
          }, function autoScrollWatchAction() {
            $rootScope.$evalAsync(scroll);
          });
        }
        return scroll;
      }
    ];
  }
  function Browser(window, document, $log, $sniffer) {
    var self = this, rawDocument = document[0], location = window.location, history = window.history, setTimeout = window.setTimeout, clearTimeout = window.clearTimeout, pendingDeferIds = {};
    self.isMock = false;
    var outstandingRequestCount = 0;
    var outstandingRequestCallbacks = [];
    self.$$completeOutstandingRequest = completeOutstandingRequest;
    self.$$incOutstandingRequestCount = function () {
      outstandingRequestCount++;
    };
    function completeOutstandingRequest(fn) {
      try {
        fn.apply(null, sliceArgs(arguments, 1));
      } finally {
        outstandingRequestCount--;
        if (outstandingRequestCount === 0) {
          while (outstandingRequestCallbacks.length) {
            try {
              outstandingRequestCallbacks.pop()();
            } catch (e) {
              $log.error(e);
            }
          }
        }
      }
    }
    self.notifyWhenNoOutstandingRequests = function (callback) {
      forEach(pollFns, function (pollFn) {
        pollFn();
      });
      if (outstandingRequestCount === 0) {
        callback();
      } else {
        outstandingRequestCallbacks.push(callback);
      }
    };
    var pollFns = [], pollTimeout;
    self.addPollFn = function (fn) {
      if (isUndefined(pollTimeout))
        startPoller(100, setTimeout);
      pollFns.push(fn);
      return fn;
    };
    function startPoller(interval, setTimeout) {
      (function check() {
        forEach(pollFns, function (pollFn) {
          pollFn();
        });
        pollTimeout = setTimeout(check, interval);
      }());
    }
    var lastBrowserUrl = location.href, baseElement = document.find('base');
    self.url = function (url, replace) {
      if (url) {
        if (lastBrowserUrl == url)
          return;
        lastBrowserUrl = url;
        if ($sniffer.history) {
          if (replace)
            history.replaceState(null, '', url);
          else {
            history.pushState(null, '', url);
            baseElement.attr('href', baseElement.attr('href'));
          }
        } else {
          if (replace)
            location.replace(url);
          else
            location.href = url;
        }
        return self;
      } else {
        return location.href.replace(/%27/g, '\'');
      }
    };
    var urlChangeListeners = [], urlChangeInit = false;
    function fireUrlChange() {
      if (lastBrowserUrl == self.url())
        return;
      lastBrowserUrl = self.url();
      forEach(urlChangeListeners, function (listener) {
        listener(self.url());
      });
    }
    self.onUrlChange = function (callback) {
      if (!urlChangeInit) {
        if ($sniffer.history)
          jqLite(window).bind('popstate', fireUrlChange);
        if ($sniffer.hashchange)
          jqLite(window).bind('hashchange', fireUrlChange);
        else
          self.addPollFn(fireUrlChange);
        urlChangeInit = true;
      }
      urlChangeListeners.push(callback);
      return callback;
    };
    self.baseHref = function () {
      var href = baseElement.attr('href');
      return href ? href.replace(/^https?\:\/\/[^\/]*/, '') : '';
    };
    var lastCookies = {};
    var lastCookieString = '';
    var cookiePath = self.baseHref();
    self.cookies = function (name, value) {
      var cookieLength, cookieArray, cookie, i, index;
      if (name) {
        if (value === undefined) {
          rawDocument.cookie = escape(name) + '=;path=' + cookiePath + ';expires=Thu, 01 Jan 1970 00:00:00 GMT';
        } else {
          if (isString(value)) {
            cookieLength = (rawDocument.cookie = escape(name) + '=' + escape(value) + ';path=' + cookiePath).length + 1;
            if (cookieLength > 4096) {
              $log.warn('Cookie \'' + name + '\' possibly not set or overflowed because it was too large (' + cookieLength + ' > 4096 bytes)!');
            }
          }
        }
      } else {
        if (rawDocument.cookie !== lastCookieString) {
          lastCookieString = rawDocument.cookie;
          cookieArray = lastCookieString.split('; ');
          lastCookies = {};
          for (i = 0; i < cookieArray.length; i++) {
            cookie = cookieArray[i];
            index = cookie.indexOf('=');
            if (index > 0) {
              var name = unescape(cookie.substring(0, index));
              if (lastCookies[name] === undefined) {
                lastCookies[name] = unescape(cookie.substring(index + 1));
              }
            }
          }
        }
        return lastCookies;
      }
    };
    self.defer = function (fn, delay) {
      var timeoutId;
      outstandingRequestCount++;
      timeoutId = setTimeout(function () {
        delete pendingDeferIds[timeoutId];
        completeOutstandingRequest(fn);
      }, delay || 0);
      pendingDeferIds[timeoutId] = true;
      return timeoutId;
    };
    self.defer.cancel = function (deferId) {
      if (pendingDeferIds[deferId]) {
        delete pendingDeferIds[deferId];
        clearTimeout(deferId);
        completeOutstandingRequest(noop);
        return true;
      }
      return false;
    };
  }
  function $BrowserProvider() {
    this.$get = [
      '$window',
      '$log',
      '$sniffer',
      '$document',
      function ($window, $log, $sniffer, $document) {
        return new Browser($window, $document, $log, $sniffer);
      }
    ];
  }
  function $CacheFactoryProvider() {
    this.$get = function () {
      var caches = {};
      function cacheFactory(cacheId, options) {
        if (cacheId in caches) {
          throw Error('cacheId ' + cacheId + ' taken');
        }
        var size = 0, stats = extend({}, options, { id: cacheId }), data = {}, capacity = options && options.capacity || Number.MAX_VALUE, lruHash = {}, freshEnd = null, staleEnd = null;
        return caches[cacheId] = {
          put: function (key, value) {
            var lruEntry = lruHash[key] || (lruHash[key] = { key: key });
            refresh(lruEntry);
            if (isUndefined(value))
              return;
            if (!(key in data))
              size++;
            data[key] = value;
            if (size > capacity) {
              this.remove(staleEnd.key);
            }
          },
          get: function (key) {
            var lruEntry = lruHash[key];
            if (!lruEntry)
              return;
            refresh(lruEntry);
            return data[key];
          },
          remove: function (key) {
            var lruEntry = lruHash[key];
            if (!lruEntry)
              return;
            if (lruEntry == freshEnd)
              freshEnd = lruEntry.p;
            if (lruEntry == staleEnd)
              staleEnd = lruEntry.n;
            link(lruEntry.n, lruEntry.p);
            delete lruHash[key];
            delete data[key];
            size--;
          },
          removeAll: function () {
            data = {};
            size = 0;
            lruHash = {};
            freshEnd = staleEnd = null;
          },
          destroy: function () {
            data = null;
            stats = null;
            lruHash = null;
            delete caches[cacheId];
          },
          info: function () {
            return extend({}, stats, { size: size });
          }
        };
        function refresh(entry) {
          if (entry != freshEnd) {
            if (!staleEnd) {
              staleEnd = entry;
            } else if (staleEnd == entry) {
              staleEnd = entry.n;
            }
            link(entry.n, entry.p);
            link(entry, freshEnd);
            freshEnd = entry;
            freshEnd.n = null;
          }
        }
        function link(nextEntry, prevEntry) {
          if (nextEntry != prevEntry) {
            if (nextEntry)
              nextEntry.p = prevEntry;
            if (prevEntry)
              prevEntry.n = nextEntry;
          }
        }
      }
      cacheFactory.info = function () {
        var info = {};
        forEach(caches, function (cache, cacheId) {
          info[cacheId] = cache.info();
        });
        return info;
      };
      cacheFactory.get = function (cacheId) {
        return caches[cacheId];
      };
      return cacheFactory;
    };
  }
  function $TemplateCacheProvider() {
    this.$get = [
      '$cacheFactory',
      function ($cacheFactory) {
        return $cacheFactory('templates');
      }
    ];
  }
  var NON_ASSIGNABLE_MODEL_EXPRESSION = 'Non-assignable model expression: ';
  $CompileProvider.$inject = ['$provide'];
  function $CompileProvider($provide) {
    var hasDirectives = {}, Suffix = 'Directive', COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\d\w\-_]+)\s+(.*)$/, CLASS_DIRECTIVE_REGEXP = /(([\d\w\-_]+)(?:\:([^;]+))?;?)/, MULTI_ROOT_TEMPLATE_ERROR = 'Template must have exactly one root element. was: ', urlSanitizationWhitelist = /^\s*(https?|ftp|mailto|file):/;
    this.directive = function registerDirective(name, directiveFactory) {
      if (isString(name)) {
        assertArg(directiveFactory, 'directive');
        if (!hasDirectives.hasOwnProperty(name)) {
          hasDirectives[name] = [];
          $provide.factory(name + Suffix, [
            '$injector',
            '$exceptionHandler',
            function ($injector, $exceptionHandler) {
              var directives = [];
              forEach(hasDirectives[name], function (directiveFactory) {
                try {
                  var directive = $injector.invoke(directiveFactory);
                  if (isFunction(directive)) {
                    directive = { compile: valueFn(directive) };
                  } else if (!directive.compile && directive.link) {
                    directive.compile = valueFn(directive.link);
                  }
                  directive.priority = directive.priority || 0;
                  directive.name = directive.name || name;
                  directive.require = directive.require || directive.controller && directive.name;
                  directive.restrict = directive.restrict || 'A';
                  directives.push(directive);
                } catch (e) {
                  $exceptionHandler(e);
                }
              });
              return directives;
            }
          ]);
        }
        hasDirectives[name].push(directiveFactory);
      } else {
        forEach(name, reverseParams(registerDirective));
      }
      return this;
    };
    this.urlSanitizationWhitelist = function (regexp) {
      if (isDefined(regexp)) {
        urlSanitizationWhitelist = regexp;
        return this;
      }
      return urlSanitizationWhitelist;
    };
    this.$get = [
      '$injector',
      '$interpolate',
      '$exceptionHandler',
      '$http',
      '$templateCache',
      '$parse',
      '$controller',
      '$rootScope',
      '$document',
      function ($injector, $interpolate, $exceptionHandler, $http, $templateCache, $parse, $controller, $rootScope, $document) {
        var Attributes = function (element, attr) {
          this.$$element = element;
          this.$attr = attr || {};
        };
        Attributes.prototype = {
          $normalize: directiveNormalize,
          $set: function (key, value, writeAttr, attrName) {
            var booleanKey = getBooleanAttrName(this.$$element[0], key), $$observers = this.$$observers, normalizedVal;
            if (booleanKey) {
              this.$$element.prop(key, value);
              attrName = booleanKey;
            }
            this[key] = value;
            if (attrName) {
              this.$attr[key] = attrName;
            } else {
              attrName = this.$attr[key];
              if (!attrName) {
                this.$attr[key] = attrName = snake_case(key, '-');
              }
            }
            if (nodeName_(this.$$element[0]) === 'A' && key === 'href') {
              urlSanitizationNode.setAttribute('href', value);
              normalizedVal = urlSanitizationNode.href;
              if (!normalizedVal.match(urlSanitizationWhitelist)) {
                this[key] = value = 'unsafe:' + normalizedVal;
              }
            }
            if (writeAttr !== false) {
              if (value === null || value === undefined) {
                this.$$element.removeAttr(attrName);
              } else {
                this.$$element.attr(attrName, value);
              }
            }
            $$observers && forEach($$observers[key], function (fn) {
              try {
                fn(value);
              } catch (e) {
                $exceptionHandler(e);
              }
            });
          },
          $observe: function (key, fn) {
            var attrs = this, $$observers = attrs.$$observers || (attrs.$$observers = {}), listeners = $$observers[key] || ($$observers[key] = []);
            listeners.push(fn);
            $rootScope.$evalAsync(function () {
              if (!listeners.$$inter) {
                fn(attrs[key]);
              }
            });
            return fn;
          }
        };
        var urlSanitizationNode = $document[0].createElement('a'), startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), denormalizeTemplate = startSymbol == '{{' || endSymbol == '}}' ? identity : function denormalizeTemplate(template) {
            return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
          };
        return compile;
        function compile($compileNodes, transcludeFn, maxPriority) {
          if (!($compileNodes instanceof jqLite)) {
            $compileNodes = jqLite($compileNodes);
          }
          forEach($compileNodes, function (node, index) {
            if (node.nodeType == 3 && node.nodeValue.match(/\S+/)) {
              $compileNodes[index] = jqLite(node).wrap('<span></span>').parent()[0];
            }
          });
          var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority);
          return function publicLinkFn(scope, cloneConnectFn) {
            assertArg(scope, 'scope');
            var $linkNode = cloneConnectFn ? JQLitePrototype.clone.call($compileNodes) : $compileNodes;
            for (var i = 0, ii = $linkNode.length; i < ii; i++) {
              var node = $linkNode[i];
              if (node.nodeType == 1 || node.nodeType == 9) {
                $linkNode.eq(i).data('$scope', scope);
              }
            }
            safeAddClass($linkNode, 'ng-scope');
            if (cloneConnectFn)
              cloneConnectFn($linkNode, scope);
            if (compositeLinkFn)
              compositeLinkFn(scope, $linkNode, $linkNode);
            return $linkNode;
          };
        }
        function wrongMode(localName, mode) {
          throw Error('Unsupported \'' + mode + '\' for \'' + localName + '\'.');
        }
        function safeAddClass($element, className) {
          try {
            $element.addClass(className);
          } catch (e) {
          }
        }
        function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority) {
          var linkFns = [], nodeLinkFn, childLinkFn, directives, attrs, linkFnFound;
          for (var i = 0; i < nodeList.length; i++) {
            attrs = new Attributes();
            directives = collectDirectives(nodeList[i], [], attrs, maxPriority);
            nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement) : null;
            childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !nodeList[i].childNodes || !nodeList[i].childNodes.length ? null : compileNodes(nodeList[i].childNodes, nodeLinkFn ? nodeLinkFn.transclude : transcludeFn);
            linkFns.push(nodeLinkFn);
            linkFns.push(childLinkFn);
            linkFnFound = linkFnFound || nodeLinkFn || childLinkFn;
          }
          return linkFnFound ? compositeLinkFn : null;
          function compositeLinkFn(scope, nodeList, $rootElement, boundTranscludeFn) {
            var nodeLinkFn, childLinkFn, node, childScope, childTranscludeFn, i, ii, n;
            var stableNodeList = [];
            for (i = 0, ii = nodeList.length; i < ii; i++) {
              stableNodeList.push(nodeList[i]);
            }
            for (i = 0, n = 0, ii = linkFns.length; i < ii; n++) {
              node = stableNodeList[n];
              nodeLinkFn = linkFns[i++];
              childLinkFn = linkFns[i++];
              if (nodeLinkFn) {
                if (nodeLinkFn.scope) {
                  childScope = scope.$new(isObject(nodeLinkFn.scope));
                  jqLite(node).data('$scope', childScope);
                } else {
                  childScope = scope;
                }
                childTranscludeFn = nodeLinkFn.transclude;
                if (childTranscludeFn || !boundTranscludeFn && transcludeFn) {
                  nodeLinkFn(childLinkFn, childScope, node, $rootElement, function (transcludeFn) {
                    return function (cloneFn) {
                      var transcludeScope = scope.$new();
                      transcludeScope.$$transcluded = true;
                      return transcludeFn(transcludeScope, cloneFn).bind('$destroy', bind(transcludeScope, transcludeScope.$destroy));
                    };
                  }(childTranscludeFn || transcludeFn));
                } else {
                  nodeLinkFn(childLinkFn, childScope, node, undefined, boundTranscludeFn);
                }
              } else if (childLinkFn) {
                childLinkFn(scope, node.childNodes, undefined, boundTranscludeFn);
              }
            }
          }
        }
        function collectDirectives(node, directives, attrs, maxPriority) {
          var nodeType = node.nodeType, attrsMap = attrs.$attr, match, className;
          switch (nodeType) {
          case 1:
            addDirective(directives, directiveNormalize(nodeName_(node).toLowerCase()), 'E', maxPriority);
            for (var attr, name, nName, value, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
              attr = nAttrs[j];
              if (attr.specified) {
                name = attr.name;
                nName = directiveNormalize(name.toLowerCase());
                attrsMap[nName] = name;
                attrs[nName] = value = trim(msie && name == 'href' ? decodeURIComponent(node.getAttribute(name, 2)) : attr.value);
                if (getBooleanAttrName(node, nName)) {
                  attrs[nName] = true;
                }
                addAttrInterpolateDirective(node, directives, value, nName);
                addDirective(directives, nName, 'A', maxPriority);
              }
            }
            className = node.className;
            if (isString(className) && className !== '') {
              while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                nName = directiveNormalize(match[2]);
                if (addDirective(directives, nName, 'C', maxPriority)) {
                  attrs[nName] = trim(match[3]);
                }
                className = className.substr(match.index + match[0].length);
              }
            }
            break;
          case 3:
            addTextInterpolateDirective(directives, node.nodeValue);
            break;
          case 8:
            try {
              match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
              if (match) {
                nName = directiveNormalize(match[1]);
                if (addDirective(directives, nName, 'M', maxPriority)) {
                  attrs[nName] = trim(match[2]);
                }
              }
            } catch (e) {
            }
            break;
          }
          directives.sort(byPriority);
          return directives;
        }
        function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection) {
          var terminalPriority = -Number.MAX_VALUE, preLinkFns = [], postLinkFns = [], newScopeDirective = null, newIsolateScopeDirective = null, templateDirective = null, $compileNode = templateAttrs.$$element = jqLite(compileNode), directive, directiveName, $template, transcludeDirective, childTranscludeFn = transcludeFn, controllerDirectives, linkFn, directiveValue;
          for (var i = 0, ii = directives.length; i < ii; i++) {
            directive = directives[i];
            $template = undefined;
            if (terminalPriority > directive.priority) {
              break;
            }
            if (directiveValue = directive.scope) {
              assertNoDuplicate('isolated scope', newIsolateScopeDirective, directive, $compileNode);
              if (isObject(directiveValue)) {
                safeAddClass($compileNode, 'ng-isolate-scope');
                newIsolateScopeDirective = directive;
              }
              safeAddClass($compileNode, 'ng-scope');
              newScopeDirective = newScopeDirective || directive;
            }
            directiveName = directive.name;
            if (directiveValue = directive.controller) {
              controllerDirectives = controllerDirectives || {};
              assertNoDuplicate('\'' + directiveName + '\' controller', controllerDirectives[directiveName], directive, $compileNode);
              controllerDirectives[directiveName] = directive;
            }
            if (directiveValue = directive.transclude) {
              assertNoDuplicate('transclusion', transcludeDirective, directive, $compileNode);
              transcludeDirective = directive;
              terminalPriority = directive.priority;
              if (directiveValue == 'element') {
                $template = jqLite(compileNode);
                $compileNode = templateAttrs.$$element = jqLite(document.createComment(' ' + directiveName + ': ' + templateAttrs[directiveName] + ' '));
                compileNode = $compileNode[0];
                replaceWith(jqCollection, jqLite($template[0]), compileNode);
                childTranscludeFn = compile($template, transcludeFn, terminalPriority);
              } else {
                $template = jqLite(JQLiteClone(compileNode)).contents();
                $compileNode.html('');
                childTranscludeFn = compile($template, transcludeFn);
              }
            }
            if (directiveValue = directive.template) {
              assertNoDuplicate('template', templateDirective, directive, $compileNode);
              templateDirective = directive;
              directiveValue = denormalizeTemplate(directiveValue);
              if (directive.replace) {
                $template = jqLite('<div>' + trim(directiveValue) + '</div>').contents();
                compileNode = $template[0];
                if ($template.length != 1 || compileNode.nodeType !== 1) {
                  throw new Error(MULTI_ROOT_TEMPLATE_ERROR + directiveValue);
                }
                replaceWith(jqCollection, $compileNode, compileNode);
                var newTemplateAttrs = { $attr: {} };
                directives = directives.concat(collectDirectives(compileNode, directives.splice(i + 1, directives.length - (i + 1)), newTemplateAttrs));
                mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                ii = directives.length;
              } else {
                $compileNode.html(directiveValue);
              }
            }
            if (directive.templateUrl) {
              assertNoDuplicate('template', templateDirective, directive, $compileNode);
              templateDirective = directive;
              nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), nodeLinkFn, $compileNode, templateAttrs, jqCollection, directive.replace, childTranscludeFn);
              ii = directives.length;
            } else if (directive.compile) {
              try {
                linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                if (isFunction(linkFn)) {
                  addLinkFns(null, linkFn);
                } else if (linkFn) {
                  addLinkFns(linkFn.pre, linkFn.post);
                }
              } catch (e) {
                $exceptionHandler(e, startingTag($compileNode));
              }
            }
            if (directive.terminal) {
              nodeLinkFn.terminal = true;
              terminalPriority = Math.max(terminalPriority, directive.priority);
            }
          }
          nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope;
          nodeLinkFn.transclude = transcludeDirective && childTranscludeFn;
          return nodeLinkFn;
          function addLinkFns(pre, post) {
            if (pre) {
              pre.require = directive.require;
              preLinkFns.push(pre);
            }
            if (post) {
              post.require = directive.require;
              postLinkFns.push(post);
            }
          }
          function getControllers(require, $element) {
            var value, retrievalMethod = 'data', optional = false;
            if (isString(require)) {
              while ((value = require.charAt(0)) == '^' || value == '?') {
                require = require.substr(1);
                if (value == '^') {
                  retrievalMethod = 'inheritedData';
                }
                optional = optional || value == '?';
              }
              value = $element[retrievalMethod]('$' + require + 'Controller');
              if (!value && !optional) {
                throw Error('No controller: ' + require);
              }
              return value;
            } else if (isArray(require)) {
              value = [];
              forEach(require, function (require) {
                value.push(getControllers(require, $element));
              });
            }
            return value;
          }
          function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
            var attrs, $element, i, ii, linkFn, controller;
            if (compileNode === linkNode) {
              attrs = templateAttrs;
            } else {
              attrs = shallowCopy(templateAttrs, new Attributes(jqLite(linkNode), templateAttrs.$attr));
            }
            $element = attrs.$$element;
            if (newIsolateScopeDirective) {
              var LOCAL_REGEXP = /^\s*([@=&])\s*(\w*)\s*$/;
              var parentScope = scope.$parent || scope;
              forEach(newIsolateScopeDirective.scope, function (definiton, scopeName) {
                var match = definiton.match(LOCAL_REGEXP) || [], attrName = match[2] || scopeName, mode = match[1], lastValue, parentGet, parentSet;
                scope.$$isolateBindings[scopeName] = mode + attrName;
                switch (mode) {
                case '@': {
                    attrs.$observe(attrName, function (value) {
                      scope[scopeName] = value;
                    });
                    attrs.$$observers[attrName].$$scope = parentScope;
                    break;
                  }
                case '=': {
                    parentGet = $parse(attrs[attrName]);
                    parentSet = parentGet.assign || function () {
                      lastValue = scope[scopeName] = parentGet(parentScope);
                      throw Error(NON_ASSIGNABLE_MODEL_EXPRESSION + attrs[attrName] + ' (directive: ' + newIsolateScopeDirective.name + ')');
                    };
                    lastValue = scope[scopeName] = parentGet(parentScope);
                    scope.$watch(function parentValueWatch() {
                      var parentValue = parentGet(parentScope);
                      if (parentValue !== scope[scopeName]) {
                        if (parentValue !== lastValue) {
                          lastValue = scope[scopeName] = parentValue;
                        } else {
                          parentSet(parentScope, parentValue = lastValue = scope[scopeName]);
                        }
                      }
                      return parentValue;
                    });
                    break;
                  }
                case '&': {
                    parentGet = $parse(attrs[attrName]);
                    scope[scopeName] = function (locals) {
                      return parentGet(parentScope, locals);
                    };
                    break;
                  }
                default: {
                    throw Error('Invalid isolate scope definition for directive ' + newIsolateScopeDirective.name + ': ' + definiton);
                  }
                }
              });
            }
            if (controllerDirectives) {
              forEach(controllerDirectives, function (directive) {
                var locals = {
                    $scope: scope,
                    $element: $element,
                    $attrs: attrs,
                    $transclude: boundTranscludeFn
                  };
                controller = directive.controller;
                if (controller == '@') {
                  controller = attrs[directive.name];
                }
                $element.data('$' + directive.name + 'Controller', $controller(controller, locals));
              });
            }
            for (i = 0, ii = preLinkFns.length; i < ii; i++) {
              try {
                linkFn = preLinkFns[i];
                linkFn(scope, $element, attrs, linkFn.require && getControllers(linkFn.require, $element));
              } catch (e) {
                $exceptionHandler(e, startingTag($element));
              }
            }
            childLinkFn && childLinkFn(scope, linkNode.childNodes, undefined, boundTranscludeFn);
            for (i = 0, ii = postLinkFns.length; i < ii; i++) {
              try {
                linkFn = postLinkFns[i];
                linkFn(scope, $element, attrs, linkFn.require && getControllers(linkFn.require, $element));
              } catch (e) {
                $exceptionHandler(e, startingTag($element));
              }
            }
          }
        }
        function addDirective(tDirectives, name, location, maxPriority) {
          var match = false;
          if (hasDirectives.hasOwnProperty(name)) {
            for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {
              try {
                directive = directives[i];
                if ((maxPriority === undefined || maxPriority > directive.priority) && directive.restrict.indexOf(location) != -1) {
                  tDirectives.push(directive);
                  match = true;
                }
              } catch (e) {
                $exceptionHandler(e);
              }
            }
          }
          return match;
        }
        function mergeTemplateAttributes(dst, src) {
          var srcAttr = src.$attr, dstAttr = dst.$attr, $element = dst.$$element;
          forEach(dst, function (value, key) {
            if (key.charAt(0) != '$') {
              if (src[key]) {
                value += (key === 'style' ? ';' : ' ') + src[key];
              }
              dst.$set(key, value, true, srcAttr[key]);
            }
          });
          forEach(src, function (value, key) {
            if (key == 'class') {
              safeAddClass($element, value);
              dst['class'] = (dst['class'] ? dst['class'] + ' ' : '') + value;
            } else if (key == 'style') {
              $element.attr('style', $element.attr('style') + ';' + value);
            } else if (key.charAt(0) != '$' && !dst.hasOwnProperty(key)) {
              dst[key] = value;
              dstAttr[key] = srcAttr[key];
            }
          });
        }
        function compileTemplateUrl(directives, beforeTemplateNodeLinkFn, $compileNode, tAttrs, $rootElement, replace, childTranscludeFn) {
          var linkQueue = [], afterTemplateNodeLinkFn, afterTemplateChildLinkFn, beforeTemplateCompileNode = $compileNode[0], origAsyncDirective = directives.shift(), derivedSyncDirective = extend({}, origAsyncDirective, {
              controller: null,
              templateUrl: null,
              transclude: null,
              scope: null
            });
          $compileNode.html('');
          $http.get(origAsyncDirective.templateUrl, { cache: $templateCache }).success(function (content) {
            var compileNode, tempTemplateAttrs, $template;
            content = denormalizeTemplate(content);
            if (replace) {
              $template = jqLite('<div>' + trim(content) + '</div>').contents();
              compileNode = $template[0];
              if ($template.length != 1 || compileNode.nodeType !== 1) {
                throw new Error(MULTI_ROOT_TEMPLATE_ERROR + content);
              }
              tempTemplateAttrs = { $attr: {} };
              replaceWith($rootElement, $compileNode, compileNode);
              collectDirectives(compileNode, directives, tempTemplateAttrs);
              mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
            } else {
              compileNode = beforeTemplateCompileNode;
              $compileNode.html(content);
            }
            directives.unshift(derivedSyncDirective);
            afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn);
            afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
            while (linkQueue.length) {
              var controller = linkQueue.pop(), linkRootElement = linkQueue.pop(), beforeTemplateLinkNode = linkQueue.pop(), scope = linkQueue.pop(), linkNode = compileNode;
              if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                linkNode = JQLiteClone(compileNode);
                replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
              }
              afterTemplateNodeLinkFn(function () {
                beforeTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, controller);
              }, scope, linkNode, $rootElement, controller);
            }
            linkQueue = null;
          }).error(function (response, code, headers, config) {
            throw Error('Failed to load template: ' + config.url);
          });
          return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, controller) {
            if (linkQueue) {
              linkQueue.push(scope);
              linkQueue.push(node);
              linkQueue.push(rootElement);
              linkQueue.push(controller);
            } else {
              afterTemplateNodeLinkFn(function () {
                beforeTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, controller);
              }, scope, node, rootElement, controller);
            }
          };
        }
        function byPriority(a, b) {
          return b.priority - a.priority;
        }
        function assertNoDuplicate(what, previousDirective, directive, element) {
          if (previousDirective) {
            throw Error('Multiple directives [' + previousDirective.name + ', ' + directive.name + '] asking for ' + what + ' on: ' + startingTag(element));
          }
        }
        function addTextInterpolateDirective(directives, text) {
          var interpolateFn = $interpolate(text, true);
          if (interpolateFn) {
            directives.push({
              priority: 0,
              compile: valueFn(function textInterpolateLinkFn(scope, node) {
                var parent = node.parent(), bindings = parent.data('$binding') || [];
                bindings.push(interpolateFn);
                safeAddClass(parent.data('$binding', bindings), 'ng-binding');
                scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                  node[0].nodeValue = value;
                });
              })
            });
          }
        }
        function addAttrInterpolateDirective(node, directives, value, name) {
          var interpolateFn = $interpolate(value, true);
          if (!interpolateFn)
            return;
          directives.push({
            priority: 100,
            compile: valueFn(function attrInterpolateLinkFn(scope, element, attr) {
              var $$observers = attr.$$observers || (attr.$$observers = {});
              if (name === 'class') {
                interpolateFn = $interpolate(attr[name], true);
              }
              attr[name] = undefined;
              ($$observers[name] || ($$observers[name] = [])).$$inter = true;
              (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function interpolateFnWatchAction(value) {
                attr.$set(name, value);
              });
            })
          });
        }
        function replaceWith($rootElement, $element, newNode) {
          var oldNode = $element[0], parent = oldNode.parentNode, i, ii;
          if ($rootElement) {
            for (i = 0, ii = $rootElement.length; i < ii; i++) {
              if ($rootElement[i] == oldNode) {
                $rootElement[i] = newNode;
                break;
              }
            }
          }
          if (parent) {
            parent.replaceChild(newNode, oldNode);
          }
          newNode[jqLite.expando] = oldNode[jqLite.expando];
          $element[0] = newNode;
        }
      }
    ];
  }
  var PREFIX_REGEXP = /^(x[\:\-_]|data[\:\-_])/i;
  function directiveNormalize(name) {
    return camelCase(name.replace(PREFIX_REGEXP, ''));
  }
  function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {
  }
  function directiveLinkingFn(nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn) {
  }
  function $ControllerProvider() {
    var controllers = {};
    this.register = function (name, constructor) {
      if (isObject(name)) {
        extend(controllers, name);
      } else {
        controllers[name] = constructor;
      }
    };
    this.$get = [
      '$injector',
      '$window',
      function ($injector, $window) {
        return function (constructor, locals) {
          if (isString(constructor)) {
            var name = constructor;
            constructor = controllers.hasOwnProperty(name) ? controllers[name] : getter(locals.$scope, name, true) || getter($window, name, true);
            assertArgFn(constructor, name, true);
          }
          return $injector.instantiate(constructor, locals);
        };
      }
    ];
  }
  function $DocumentProvider() {
    this.$get = [
      '$window',
      function (window) {
        return jqLite(window.document);
      }
    ];
  }
  function $ExceptionHandlerProvider() {
    this.$get = [
      '$log',
      function ($log) {
        return function (exception, cause) {
          $log.error.apply($log, arguments);
        };
      }
    ];
  }
  function $InterpolateProvider() {
    var startSymbol = '{{';
    var endSymbol = '}}';
    this.startSymbol = function (value) {
      if (value) {
        startSymbol = value;
        return this;
      } else {
        return startSymbol;
      }
    };
    this.endSymbol = function (value) {
      if (value) {
        endSymbol = value;
        return this;
      } else {
        return endSymbol;
      }
    };
    this.$get = [
      '$parse',
      function ($parse) {
        var startSymbolLength = startSymbol.length, endSymbolLength = endSymbol.length;
        function $interpolate(text, mustHaveExpression) {
          var startIndex, endIndex, index = 0, parts = [], length = text.length, hasInterpolation = false, fn, exp, concat = [];
          while (index < length) {
            if ((startIndex = text.indexOf(startSymbol, index)) != -1 && (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1) {
              index != startIndex && parts.push(text.substring(index, startIndex));
              parts.push(fn = $parse(exp = text.substring(startIndex + startSymbolLength, endIndex)));
              fn.exp = exp;
              index = endIndex + endSymbolLength;
              hasInterpolation = true;
            } else {
              index != length && parts.push(text.substring(index));
              index = length;
            }
          }
          if (!(length = parts.length)) {
            parts.push('');
            length = 1;
          }
          if (!mustHaveExpression || hasInterpolation) {
            concat.length = length;
            fn = function (context) {
              for (var i = 0, ii = length, part; i < ii; i++) {
                if (typeof (part = parts[i]) == 'function') {
                  part = part(context);
                  if (part == null || part == undefined) {
                    part = '';
                  } else if (typeof part != 'string') {
                    part = toJson(part);
                  }
                }
                concat[i] = part;
              }
              return concat.join('');
            };
            fn.exp = text;
            fn.parts = parts;
            return fn;
          }
        }
        $interpolate.startSymbol = function () {
          return startSymbol;
        };
        $interpolate.endSymbol = function () {
          return endSymbol;
        };
        return $interpolate;
      }
    ];
  }
  var URL_MATCH = /^([^:]+):\/\/(\w+:{0,1}\w*@)?(\{?[\w\.-]*\}?)(:([0-9]+))?(\/[^\?#]*)?(\?([^#]*))?(#(.*))?$/, PATH_MATCH = /^([^\?#]*)?(\?([^#]*))?(#(.*))?$/, HASH_MATCH = PATH_MATCH, DEFAULT_PORTS = {
      'http': 80,
      'https': 443,
      'ftp': 21
    };
  function encodePath(path) {
    var segments = path.split('/'), i = segments.length;
    while (i--) {
      segments[i] = encodeUriSegment(segments[i]);
    }
    return segments.join('/');
  }
  function stripHash(url) {
    return url.split('#')[0];
  }
  function matchUrl(url, obj) {
    var match = URL_MATCH.exec(url);
    match = {
      protocol: match[1],
      host: match[3],
      port: int(match[5]) || DEFAULT_PORTS[match[1]] || null,
      path: match[6] || '/',
      search: match[8],
      hash: match[10]
    };
    if (obj) {
      obj.$$protocol = match.protocol;
      obj.$$host = match.host;
      obj.$$port = match.port;
    }
    return match;
  }
  function composeProtocolHostPort(protocol, host, port) {
    return protocol + '://' + host + (port == DEFAULT_PORTS[protocol] ? '' : ':' + port);
  }
  function pathPrefixFromBase(basePath) {
    return basePath.substr(0, basePath.lastIndexOf('/'));
  }
  function convertToHtml5Url(url, basePath, hashPrefix) {
    var match = matchUrl(url);
    if (decodeURIComponent(match.path) != basePath || isUndefined(match.hash) || match.hash.indexOf(hashPrefix) !== 0) {
      return url;
    } else {
      return composeProtocolHostPort(match.protocol, match.host, match.port) + pathPrefixFromBase(basePath) + match.hash.substr(hashPrefix.length);
    }
  }
  function convertToHashbangUrl(url, basePath, hashPrefix) {
    var match = matchUrl(url);
    if (decodeURIComponent(match.path) == basePath && !isUndefined(match.hash) && match.hash.indexOf(hashPrefix) === 0) {
      return url;
    } else {
      var search = match.search && '?' + match.search || '', hash = match.hash && '#' + match.hash || '', pathPrefix = pathPrefixFromBase(basePath), path = match.path.substr(pathPrefix.length);
      if (match.path.indexOf(pathPrefix) !== 0) {
        throw Error('Invalid url "' + url + '", missing path prefix "' + pathPrefix + '" !');
      }
      return composeProtocolHostPort(match.protocol, match.host, match.port) + basePath + '#' + hashPrefix + path + search + hash;
    }
  }
  function LocationUrl(url, pathPrefix, appBaseUrl) {
    pathPrefix = pathPrefix || '';
    this.$$parse = function (newAbsoluteUrl) {
      var match = matchUrl(newAbsoluteUrl, this);
      if (match.path.indexOf(pathPrefix) !== 0) {
        throw Error('Invalid url "' + newAbsoluteUrl + '", missing path prefix "' + pathPrefix + '" !');
      }
      this.$$path = decodeURIComponent(match.path.substr(pathPrefix.length));
      this.$$search = parseKeyValue(match.search);
      this.$$hash = match.hash && decodeURIComponent(match.hash) || '';
      this.$$compose();
    };
    this.$$compose = function () {
      var search = toKeyValue(this.$$search), hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
      this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
      this.$$absUrl = composeProtocolHostPort(this.$$protocol, this.$$host, this.$$port) + pathPrefix + this.$$url;
    };
    this.$$rewriteAppUrl = function (absoluteLinkUrl) {
      if (absoluteLinkUrl.indexOf(appBaseUrl) == 0) {
        return absoluteLinkUrl;
      }
    };
    this.$$parse(url);
  }
  function LocationHashbangUrl(url, hashPrefix, appBaseUrl) {
    var basePath;
    this.$$parse = function (url) {
      var match = matchUrl(url, this);
      if (match.hash && match.hash.indexOf(hashPrefix) !== 0) {
        throw Error('Invalid url "' + url + '", missing hash prefix "' + hashPrefix + '" !');
      }
      basePath = match.path + (match.search ? '?' + match.search : '');
      match = HASH_MATCH.exec((match.hash || '').substr(hashPrefix.length));
      if (match[1]) {
        this.$$path = (match[1].charAt(0) == '/' ? '' : '/') + decodeURIComponent(match[1]);
      } else {
        this.$$path = '';
      }
      this.$$search = parseKeyValue(match[3]);
      this.$$hash = match[5] && decodeURIComponent(match[5]) || '';
      this.$$compose();
    };
    this.$$compose = function () {
      var search = toKeyValue(this.$$search), hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
      this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
      this.$$absUrl = composeProtocolHostPort(this.$$protocol, this.$$host, this.$$port) + basePath + (this.$$url ? '#' + hashPrefix + this.$$url : '');
    };
    this.$$rewriteAppUrl = function (absoluteLinkUrl) {
      if (absoluteLinkUrl.indexOf(appBaseUrl) == 0) {
        return absoluteLinkUrl;
      }
    };
    this.$$parse(url);
  }
  LocationUrl.prototype = {
    $$replace: false,
    absUrl: locationGetter('$$absUrl'),
    url: function (url, replace) {
      if (isUndefined(url))
        return this.$$url;
      var match = PATH_MATCH.exec(url);
      if (match[1])
        this.path(decodeURIComponent(match[1]));
      if (match[2] || match[1])
        this.search(match[3] || '');
      this.hash(match[5] || '', replace);
      return this;
    },
    protocol: locationGetter('$$protocol'),
    host: locationGetter('$$host'),
    port: locationGetter('$$port'),
    path: locationGetterSetter('$$path', function (path) {
      return path.charAt(0) == '/' ? path : '/' + path;
    }),
    search: function (search, paramValue) {
      if (isUndefined(search))
        return this.$$search;
      if (isDefined(paramValue)) {
        if (paramValue === null) {
          delete this.$$search[search];
        } else {
          this.$$search[search] = paramValue;
        }
      } else {
        this.$$search = isString(search) ? parseKeyValue(search) : search;
      }
      this.$$compose();
      return this;
    },
    hash: locationGetterSetter('$$hash', identity),
    replace: function () {
      this.$$replace = true;
      return this;
    }
  };
  LocationHashbangUrl.prototype = inherit(LocationUrl.prototype);
  function LocationHashbangInHtml5Url(url, hashPrefix, appBaseUrl, baseExtra) {
    LocationHashbangUrl.apply(this, arguments);
    this.$$rewriteAppUrl = function (absoluteLinkUrl) {
      if (absoluteLinkUrl.indexOf(appBaseUrl) == 0) {
        return appBaseUrl + baseExtra + '#' + hashPrefix + absoluteLinkUrl.substr(appBaseUrl.length);
      }
    };
  }
  LocationHashbangInHtml5Url.prototype = inherit(LocationHashbangUrl.prototype);
  function locationGetter(property) {
    return function () {
      return this[property];
    };
  }
  function locationGetterSetter(property, preprocess) {
    return function (value) {
      if (isUndefined(value))
        return this[property];
      this[property] = preprocess(value);
      this.$$compose();
      return this;
    };
  }
  function $LocationProvider() {
    var hashPrefix = '', html5Mode = false;
    this.hashPrefix = function (prefix) {
      if (isDefined(prefix)) {
        hashPrefix = prefix;
        return this;
      } else {
        return hashPrefix;
      }
    };
    this.html5Mode = function (mode) {
      if (isDefined(mode)) {
        html5Mode = mode;
        return this;
      } else {
        return html5Mode;
      }
    };
    this.$get = [
      '$rootScope',
      '$browser',
      '$sniffer',
      '$rootElement',
      function ($rootScope, $browser, $sniffer, $rootElement) {
        var $location, basePath, pathPrefix, initUrl = $browser.url(), initUrlParts = matchUrl(initUrl), appBaseUrl;
        if (html5Mode) {
          basePath = $browser.baseHref() || '/';
          pathPrefix = pathPrefixFromBase(basePath);
          appBaseUrl = composeProtocolHostPort(initUrlParts.protocol, initUrlParts.host, initUrlParts.port) + pathPrefix + '/';
          if ($sniffer.history) {
            $location = new LocationUrl(convertToHtml5Url(initUrl, basePath, hashPrefix), pathPrefix, appBaseUrl);
          } else {
            $location = new LocationHashbangInHtml5Url(convertToHashbangUrl(initUrl, basePath, hashPrefix), hashPrefix, appBaseUrl, basePath.substr(pathPrefix.length + 1));
          }
        } else {
          appBaseUrl = composeProtocolHostPort(initUrlParts.protocol, initUrlParts.host, initUrlParts.port) + (initUrlParts.path || '') + (initUrlParts.search ? '?' + initUrlParts.search : '') + '#' + hashPrefix + '/';
          $location = new LocationHashbangUrl(initUrl, hashPrefix, appBaseUrl);
        }
        $rootElement.bind('click', function (event) {
          if (event.ctrlKey || event.metaKey || event.which == 2)
            return;
          var elm = jqLite(event.target);
          while (lowercase(elm[0].nodeName) !== 'a') {
            if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0])
              return;
          }
          var absHref = elm.prop('href'), rewrittenUrl = $location.$$rewriteAppUrl(absHref);
          if (absHref && !elm.attr('target') && rewrittenUrl) {
            $location.$$parse(rewrittenUrl);
            $rootScope.$apply();
            event.preventDefault();
            window.angular['ff-684208-preventDefault'] = true;
          }
        });
        if ($location.absUrl() != initUrl) {
          $browser.url($location.absUrl(), true);
        }
        $browser.onUrlChange(function (newUrl) {
          if ($location.absUrl() != newUrl) {
            if ($rootScope.$broadcast('$locationChangeStart', newUrl, $location.absUrl()).defaultPrevented) {
              $browser.url($location.absUrl());
              return;
            }
            $rootScope.$evalAsync(function () {
              var oldUrl = $location.absUrl();
              $location.$$parse(newUrl);
              afterLocationChange(oldUrl);
            });
            if (!$rootScope.$$phase)
              $rootScope.$digest();
          }
        });
        var changeCounter = 0;
        $rootScope.$watch(function $locationWatch() {
          var oldUrl = $browser.url();
          var currentReplace = $location.$$replace;
          if (!changeCounter || oldUrl != $location.absUrl()) {
            changeCounter++;
            $rootScope.$evalAsync(function () {
              if ($rootScope.$broadcast('$locationChangeStart', $location.absUrl(), oldUrl).defaultPrevented) {
                $location.$$parse(oldUrl);
              } else {
                $browser.url($location.absUrl(), currentReplace);
                afterLocationChange(oldUrl);
              }
            });
          }
          $location.$$replace = false;
          return changeCounter;
        });
        return $location;
        function afterLocationChange(oldUrl) {
          $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl);
        }
      }
    ];
  }
  function $LogProvider() {
    this.$get = [
      '$window',
      function ($window) {
        return {
          log: consoleLog('log'),
          warn: consoleLog('warn'),
          info: consoleLog('info'),
          error: consoleLog('error')
        };
        function formatError(arg) {
          if (arg instanceof Error) {
            if (arg.stack) {
              arg = arg.message && arg.stack.indexOf(arg.message) === -1 ? 'Error: ' + arg.message + '\n' + arg.stack : arg.stack;
            } else if (arg.sourceURL) {
              arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;
            }
          }
          return arg;
        }
        function consoleLog(type) {
          var console = $window.console || {}, logFn = console[type] || console.log || noop;
          if (logFn.apply) {
            return function () {
              var args = [];
              forEach(arguments, function (arg) {
                args.push(formatError(arg));
              });
              return logFn.apply(console, args);
            };
          }
          return function (arg1, arg2) {
            logFn(arg1, arg2);
          };
        }
      }
    ];
  }
  var OPERATORS = {
      'null': function () {
        return null;
      },
      'true': function () {
        return true;
      },
      'false': function () {
        return false;
      },
      undefined: noop,
      '+': function (self, locals, a, b) {
        a = a(self, locals);
        b = b(self, locals);
        if (isDefined(a)) {
          if (isDefined(b)) {
            return a + b;
          }
          return a;
        }
        return isDefined(b) ? b : undefined;
      },
      '-': function (self, locals, a, b) {
        a = a(self, locals);
        b = b(self, locals);
        return (isDefined(a) ? a : 0) - (isDefined(b) ? b : 0);
      },
      '*': function (self, locals, a, b) {
        return a(self, locals) * b(self, locals);
      },
      '/': function (self, locals, a, b) {
        return a(self, locals) / b(self, locals);
      },
      '%': function (self, locals, a, b) {
        return a(self, locals) % b(self, locals);
      },
      '^': function (self, locals, a, b) {
        return a(self, locals) ^ b(self, locals);
      },
      '=': noop,
      '==': function (self, locals, a, b) {
        return a(self, locals) == b(self, locals);
      },
      '!=': function (self, locals, a, b) {
        return a(self, locals) != b(self, locals);
      },
      '<': function (self, locals, a, b) {
        return a(self, locals) < b(self, locals);
      },
      '>': function (self, locals, a, b) {
        return a(self, locals) > b(self, locals);
      },
      '<=': function (self, locals, a, b) {
        return a(self, locals) <= b(self, locals);
      },
      '>=': function (self, locals, a, b) {
        return a(self, locals) >= b(self, locals);
      },
      '&&': function (self, locals, a, b) {
        return a(self, locals) && b(self, locals);
      },
      '||': function (self, locals, a, b) {
        return a(self, locals) || b(self, locals);
      },
      '&': function (self, locals, a, b) {
        return a(self, locals) & b(self, locals);
      },
      '|': function (self, locals, a, b) {
        return b(self, locals)(self, locals, a(self, locals));
      },
      '!': function (self, locals, a) {
        return !a(self, locals);
      }
    };
  var ESCAPE = {
      'n': '\n',
      'f': '\f',
      'r': '\r',
      't': '\t',
      'v': '\x0B',
      '\'': '\'',
      '"': '"'
    };
  function lex(text, csp) {
    var tokens = [], token, index = 0, json = [], ch, lastCh = ':';
    while (index < text.length) {
      ch = text.charAt(index);
      if (is('"\'')) {
        readString(ch);
      } else if (isNumber(ch) || is('.') && isNumber(peek())) {
        readNumber();
      } else if (isIdent(ch)) {
        readIdent();
        if (was('{,') && json[0] == '{' && (token = tokens[tokens.length - 1])) {
          token.json = token.text.indexOf('.') == -1;
        }
      } else if (is('(){}[].,;:')) {
        tokens.push({
          index: index,
          text: ch,
          json: was(':[,') && is('{[') || is('}]:,')
        });
        if (is('{['))
          json.unshift(ch);
        if (is('}]'))
          json.shift();
        index++;
      } else if (isWhitespace(ch)) {
        index++;
        continue;
      } else {
        var ch2 = ch + peek(), fn = OPERATORS[ch], fn2 = OPERATORS[ch2];
        if (fn2) {
          tokens.push({
            index: index,
            text: ch2,
            fn: fn2
          });
          index += 2;
        } else if (fn) {
          tokens.push({
            index: index,
            text: ch,
            fn: fn,
            json: was('[,:') && is('+-')
          });
          index += 1;
        } else {
          throwError('Unexpected next character ', index, index + 1);
        }
      }
      lastCh = ch;
    }
    return tokens;
    function is(chars) {
      return chars.indexOf(ch) != -1;
    }
    function was(chars) {
      return chars.indexOf(lastCh) != -1;
    }
    function peek() {
      return index + 1 < text.length ? text.charAt(index + 1) : false;
    }
    function isNumber(ch) {
      return '0' <= ch && ch <= '9';
    }
    function isWhitespace(ch) {
      return ch == ' ' || ch == '\r' || ch == '\t' || ch == '\n' || ch == '\x0B' || ch == '\xa0';
    }
    function isIdent(ch) {
      return 'a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || '_' == ch || ch == '$';
    }
    function isExpOperator(ch) {
      return ch == '-' || ch == '+' || isNumber(ch);
    }
    function throwError(error, start, end) {
      end = end || index;
      throw Error('Lexer Error: ' + error + ' at column' + (isDefined(start) ? 's ' + start + '-' + index + ' [' + text.substring(start, end) + ']' : ' ' + end) + ' in expression [' + text + '].');
    }
    function readNumber() {
      var number = '';
      var start = index;
      while (index < text.length) {
        var ch = lowercase(text.charAt(index));
        if (ch == '.' || isNumber(ch)) {
          number += ch;
        } else {
          var peekCh = peek();
          if (ch == 'e' && isExpOperator(peekCh)) {
            number += ch;
          } else if (isExpOperator(ch) && peekCh && isNumber(peekCh) && number.charAt(number.length - 1) == 'e') {
            number += ch;
          } else if (isExpOperator(ch) && (!peekCh || !isNumber(peekCh)) && number.charAt(number.length - 1) == 'e') {
            throwError('Invalid exponent');
          } else {
            break;
          }
        }
        index++;
      }
      number = 1 * number;
      tokens.push({
        index: start,
        text: number,
        json: true,
        fn: function () {
          return number;
        }
      });
    }
    function readIdent() {
      var ident = '', start = index, lastDot, peekIndex, methodName, ch;
      while (index < text.length) {
        ch = text.charAt(index);
        if (ch == '.' || isIdent(ch) || isNumber(ch)) {
          if (ch == '.')
            lastDot = index;
          ident += ch;
        } else {
          break;
        }
        index++;
      }
      if (lastDot) {
        peekIndex = index;
        while (peekIndex < text.length) {
          ch = text.charAt(peekIndex);
          if (ch == '(') {
            methodName = ident.substr(lastDot - start + 1);
            ident = ident.substr(0, lastDot - start);
            index = peekIndex;
            break;
          }
          if (isWhitespace(ch)) {
            peekIndex++;
          } else {
            break;
          }
        }
      }
      var token = {
          index: start,
          text: ident
        };
      if (OPERATORS.hasOwnProperty(ident)) {
        token.fn = token.json = OPERATORS[ident];
      } else {
        var getter = getterFn(ident, csp);
        token.fn = extend(function (self, locals) {
          return getter(self, locals);
        }, {
          assign: function (self, value) {
            return setter(self, ident, value);
          }
        });
      }
      tokens.push(token);
      if (methodName) {
        tokens.push({
          index: lastDot,
          text: '.',
          json: false
        });
        tokens.push({
          index: lastDot + 1,
          text: methodName,
          json: false
        });
      }
    }
    function readString(quote) {
      var start = index;
      index++;
      var string = '';
      var rawString = quote;
      var escape = false;
      while (index < text.length) {
        var ch = text.charAt(index);
        rawString += ch;
        if (escape) {
          if (ch == 'u') {
            var hex = text.substring(index + 1, index + 5);
            if (!hex.match(/[\da-f]{4}/i))
              throwError('Invalid unicode escape [\\u' + hex + ']');
            index += 4;
            string += String.fromCharCode(parseInt(hex, 16));
          } else {
            var rep = ESCAPE[ch];
            if (rep) {
              string += rep;
            } else {
              string += ch;
            }
          }
          escape = false;
        } else if (ch == '\\') {
          escape = true;
        } else if (ch == quote) {
          index++;
          tokens.push({
            index: start,
            text: rawString,
            string: string,
            json: true,
            fn: function () {
              return string;
            }
          });
          return;
        } else {
          string += ch;
        }
        index++;
      }
      throwError('Unterminated quote', start);
    }
  }
  function parser(text, json, $filter, csp) {
    var ZERO = valueFn(0), value, tokens = lex(text, csp), assignment = _assignment, functionCall = _functionCall, fieldAccess = _fieldAccess, objectIndex = _objectIndex, filterChain = _filterChain;
    if (json) {
      assignment = logicalOR;
      functionCall = fieldAccess = objectIndex = filterChain = function () {
        throwError('is not valid json', {
          text: text,
          index: 0
        });
      };
      value = primary();
    } else {
      value = statements();
    }
    if (tokens.length !== 0) {
      throwError('is an unexpected token', tokens[0]);
    }
    return value;
    function throwError(msg, token) {
      throw Error('Syntax Error: Token \'' + token.text + '\' ' + msg + ' at column ' + (token.index + 1) + ' of the expression [' + text + '] starting at [' + text.substring(token.index) + '].');
    }
    function peekToken() {
      if (tokens.length === 0)
        throw Error('Unexpected end of expression: ' + text);
      return tokens[0];
    }
    function peek(e1, e2, e3, e4) {
      if (tokens.length > 0) {
        var token = tokens[0];
        var t = token.text;
        if (t == e1 || t == e2 || t == e3 || t == e4 || !e1 && !e2 && !e3 && !e4) {
          return token;
        }
      }
      return false;
    }
    function expect(e1, e2, e3, e4) {
      var token = peek(e1, e2, e3, e4);
      if (token) {
        if (json && !token.json) {
          throwError('is not valid json', token);
        }
        tokens.shift();
        return token;
      }
      return false;
    }
    function consume(e1) {
      if (!expect(e1)) {
        throwError('is unexpected, expecting [' + e1 + ']', peek());
      }
    }
    function unaryFn(fn, right) {
      return function (self, locals) {
        return fn(self, locals, right);
      };
    }
    function binaryFn(left, fn, right) {
      return function (self, locals) {
        return fn(self, locals, left, right);
      };
    }
    function statements() {
      var statements = [];
      while (true) {
        if (tokens.length > 0 && !peek('}', ')', ';', ']'))
          statements.push(filterChain());
        if (!expect(';')) {
          return statements.length == 1 ? statements[0] : function (self, locals) {
            var value;
            for (var i = 0; i < statements.length; i++) {
              var statement = statements[i];
              if (statement)
                value = statement(self, locals);
            }
            return value;
          };
        }
      }
    }
    function _filterChain() {
      var left = expression();
      var token;
      while (true) {
        if (token = expect('|')) {
          left = binaryFn(left, token.fn, filter());
        } else {
          return left;
        }
      }
    }
    function filter() {
      var token = expect();
      var fn = $filter(token.text);
      var argsFn = [];
      while (true) {
        if (token = expect(':')) {
          argsFn.push(expression());
        } else {
          var fnInvoke = function (self, locals, input) {
            var args = [input];
            for (var i = 0; i < argsFn.length; i++) {
              args.push(argsFn[i](self, locals));
            }
            return fn.apply(self, args);
          };
          return function () {
            return fnInvoke;
          };
        }
      }
    }
    function expression() {
      return assignment();
    }
    function _assignment() {
      var left = logicalOR();
      var right;
      var token;
      if (token = expect('=')) {
        if (!left.assign) {
          throwError('implies assignment but [' + text.substring(0, token.index) + '] can not be assigned to', token);
        }
        right = logicalOR();
        return function (scope, locals) {
          return left.assign(scope, right(scope, locals), locals);
        };
      } else {
        return left;
      }
    }
    function logicalOR() {
      var left = logicalAND();
      var token;
      while (true) {
        if (token = expect('||')) {
          left = binaryFn(left, token.fn, logicalAND());
        } else {
          return left;
        }
      }
    }
    function logicalAND() {
      var left = equality();
      var token;
      if (token = expect('&&')) {
        left = binaryFn(left, token.fn, logicalAND());
      }
      return left;
    }
    function equality() {
      var left = relational();
      var token;
      if (token = expect('==', '!=')) {
        left = binaryFn(left, token.fn, equality());
      }
      return left;
    }
    function relational() {
      var left = additive();
      var token;
      if (token = expect('<', '>', '<=', '>=')) {
        left = binaryFn(left, token.fn, relational());
      }
      return left;
    }
    function additive() {
      var left = multiplicative();
      var token;
      while (token = expect('+', '-')) {
        left = binaryFn(left, token.fn, multiplicative());
      }
      return left;
    }
    function multiplicative() {
      var left = unary();
      var token;
      while (token = expect('*', '/', '%')) {
        left = binaryFn(left, token.fn, unary());
      }
      return left;
    }
    function unary() {
      var token;
      if (expect('+')) {
        return primary();
      } else if (token = expect('-')) {
        return binaryFn(ZERO, token.fn, unary());
      } else if (token = expect('!')) {
        return unaryFn(token.fn, unary());
      } else {
        return primary();
      }
    }
    function primary() {
      var primary;
      if (expect('(')) {
        primary = filterChain();
        consume(')');
      } else if (expect('[')) {
        primary = arrayDeclaration();
      } else if (expect('{')) {
        primary = object();
      } else {
        var token = expect();
        primary = token.fn;
        if (!primary) {
          throwError('not a primary expression', token);
        }
      }
      var next, context;
      while (next = expect('(', '[', '.')) {
        if (next.text === '(') {
          primary = functionCall(primary, context);
          context = null;
        } else if (next.text === '[') {
          context = primary;
          primary = objectIndex(primary);
        } else if (next.text === '.') {
          context = primary;
          primary = fieldAccess(primary);
        } else {
          throwError('IMPOSSIBLE');
        }
      }
      return primary;
    }
    function _fieldAccess(object) {
      var field = expect().text;
      var getter = getterFn(field, csp);
      return extend(function (scope, locals, self) {
        return getter(self || object(scope, locals), locals);
      }, {
        assign: function (scope, value, locals) {
          return setter(object(scope, locals), field, value);
        }
      });
    }
    function _objectIndex(obj) {
      var indexFn = expression();
      consume(']');
      return extend(function (self, locals) {
        var o = obj(self, locals), i = indexFn(self, locals), v, p;
        if (!o)
          return undefined;
        v = o[i];
        if (v && v.then) {
          p = v;
          if (!('$$v' in v)) {
            p.$$v = undefined;
            p.then(function (val) {
              p.$$v = val;
            });
          }
          v = v.$$v;
        }
        return v;
      }, {
        assign: function (self, value, locals) {
          return obj(self, locals)[indexFn(self, locals)] = value;
        }
      });
    }
    function _functionCall(fn, contextGetter) {
      var argsFn = [];
      if (peekToken().text != ')') {
        do {
          argsFn.push(expression());
        } while (expect(','));
      }
      consume(')');
      return function (scope, locals) {
        var args = [], context = contextGetter ? contextGetter(scope, locals) : scope;
        for (var i = 0; i < argsFn.length; i++) {
          args.push(argsFn[i](scope, locals));
        }
        var fnPtr = fn(scope, locals, context) || noop;
        return fnPtr.apply ? fnPtr.apply(context, args) : fnPtr(args[0], args[1], args[2], args[3], args[4]);
      };
    }
    function arrayDeclaration() {
      var elementFns = [];
      if (peekToken().text != ']') {
        do {
          elementFns.push(expression());
        } while (expect(','));
      }
      consume(']');
      return function (self, locals) {
        var array = [];
        for (var i = 0; i < elementFns.length; i++) {
          array.push(elementFns[i](self, locals));
        }
        return array;
      };
    }
    function object() {
      var keyValues = [];
      if (peekToken().text != '}') {
        do {
          var token = expect(), key = token.string || token.text;
          consume(':');
          var value = expression();
          keyValues.push({
            key: key,
            value: value
          });
        } while (expect(','));
      }
      consume('}');
      return function (self, locals) {
        var object = {};
        for (var i = 0; i < keyValues.length; i++) {
          var keyValue = keyValues[i];
          object[keyValue.key] = keyValue.value(self, locals);
        }
        return object;
      };
    }
  }
  function setter(obj, path, setValue) {
    var element = path.split('.');
    for (var i = 0; element.length > 1; i++) {
      var key = element.shift();
      var propertyObj = obj[key];
      if (!propertyObj) {
        propertyObj = {};
        obj[key] = propertyObj;
      }
      obj = propertyObj;
    }
    obj[element.shift()] = setValue;
    return setValue;
  }
  function getter(obj, path, bindFnToScope) {
    if (!path)
      return obj;
    var keys = path.split('.');
    var key;
    var lastInstance = obj;
    var len = keys.length;
    for (var i = 0; i < len; i++) {
      key = keys[i];
      if (obj) {
        obj = (lastInstance = obj)[key];
      }
    }
    if (!bindFnToScope && isFunction(obj)) {
      return bind(lastInstance, obj);
    }
    return obj;
  }
  var getterFnCache = {};
  function cspSafeGetterFn(key0, key1, key2, key3, key4) {
    return function (scope, locals) {
      var pathVal = locals && locals.hasOwnProperty(key0) ? locals : scope, promise;
      if (pathVal === null || pathVal === undefined)
        return pathVal;
      pathVal = pathVal[key0];
      if (pathVal && pathVal.then) {
        if (!('$$v' in pathVal)) {
          promise = pathVal;
          promise.$$v = undefined;
          promise.then(function (val) {
            promise.$$v = val;
          });
        }
        pathVal = pathVal.$$v;
      }
      if (!key1 || pathVal === null || pathVal === undefined)
        return pathVal;
      pathVal = pathVal[key1];
      if (pathVal && pathVal.then) {
        if (!('$$v' in pathVal)) {
          promise = pathVal;
          promise.$$v = undefined;
          promise.then(function (val) {
            promise.$$v = val;
          });
        }
        pathVal = pathVal.$$v;
      }
      if (!key2 || pathVal === null || pathVal === undefined)
        return pathVal;
      pathVal = pathVal[key2];
      if (pathVal && pathVal.then) {
        if (!('$$v' in pathVal)) {
          promise = pathVal;
          promise.$$v = undefined;
          promise.then(function (val) {
            promise.$$v = val;
          });
        }
        pathVal = pathVal.$$v;
      }
      if (!key3 || pathVal === null || pathVal === undefined)
        return pathVal;
      pathVal = pathVal[key3];
      if (pathVal && pathVal.then) {
        if (!('$$v' in pathVal)) {
          promise = pathVal;
          promise.$$v = undefined;
          promise.then(function (val) {
            promise.$$v = val;
          });
        }
        pathVal = pathVal.$$v;
      }
      if (!key4 || pathVal === null || pathVal === undefined)
        return pathVal;
      pathVal = pathVal[key4];
      if (pathVal && pathVal.then) {
        if (!('$$v' in pathVal)) {
          promise = pathVal;
          promise.$$v = undefined;
          promise.then(function (val) {
            promise.$$v = val;
          });
        }
        pathVal = pathVal.$$v;
      }
      return pathVal;
    };
  }
  function getterFn(path, csp) {
    if (getterFnCache.hasOwnProperty(path)) {
      return getterFnCache[path];
    }
    var pathKeys = path.split('.'), pathKeysLength = pathKeys.length, fn;
    if (csp) {
      fn = pathKeysLength < 6 ? cspSafeGetterFn(pathKeys[0], pathKeys[1], pathKeys[2], pathKeys[3], pathKeys[4]) : function (scope, locals) {
        var i = 0, val;
        do {
          val = cspSafeGetterFn(pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++])(scope, locals);
          locals = undefined;
          scope = val;
        } while (i < pathKeysLength);
        return val;
      };
    } else {
      var code = 'var l, fn, p;\n';
      forEach(pathKeys, function (key, index) {
        code += 'if(s === null || s === undefined) return s;\n' + 'l=s;\n' + 's=' + (index ? 's' : '((k&&k.hasOwnProperty("' + key + '"))?k:s)') + '["' + key + '"]' + ';\n' + 'if (s && s.then) {\n' + ' if (!("$$v" in s)) {\n' + ' p=s;\n' + ' p.$$v = undefined;\n' + ' p.then(function(v) {p.$$v=v;});\n' + '}\n' + ' s=s.$$v\n' + '}\n';
      });
      code += 'return s;';
      fn = Function('s', 'k', code);
      fn.toString = function () {
        return code;
      };
    }
    return getterFnCache[path] = fn;
  }
  function $ParseProvider() {
    var cache = {};
    this.$get = [
      '$filter',
      '$sniffer',
      function ($filter, $sniffer) {
        return function (exp) {
          switch (typeof exp) {
          case 'string':
            return cache.hasOwnProperty(exp) ? cache[exp] : cache[exp] = parser(exp, false, $filter, $sniffer.csp);
          case 'function':
            return exp;
          default:
            return noop;
          }
        };
      }
    ];
  }
  function $QProvider() {
    this.$get = [
      '$rootScope',
      '$exceptionHandler',
      function ($rootScope, $exceptionHandler) {
        return qFactory(function (callback) {
          $rootScope.$evalAsync(callback);
        }, $exceptionHandler);
      }
    ];
  }
  function qFactory(nextTick, exceptionHandler) {
    var defer = function () {
      var pending = [], value, deferred;
      deferred = {
        resolve: function (val) {
          if (pending) {
            var callbacks = pending;
            pending = undefined;
            value = ref(val);
            if (callbacks.length) {
              nextTick(function () {
                var callback;
                for (var i = 0, ii = callbacks.length; i < ii; i++) {
                  callback = callbacks[i];
                  value.then(callback[0], callback[1]);
                }
              });
            }
          }
        },
        reject: function (reason) {
          deferred.resolve(reject(reason));
        },
        promise: {
          then: function (callback, errback) {
            var result = defer();
            var wrappedCallback = function (value) {
              try {
                result.resolve((callback || defaultCallback)(value));
              } catch (e) {
                exceptionHandler(e);
                result.reject(e);
              }
            };
            var wrappedErrback = function (reason) {
              try {
                result.resolve((errback || defaultErrback)(reason));
              } catch (e) {
                exceptionHandler(e);
                result.reject(e);
              }
            };
            if (pending) {
              pending.push([
                wrappedCallback,
                wrappedErrback
              ]);
            } else {
              value.then(wrappedCallback, wrappedErrback);
            }
            return result.promise;
          }
        }
      };
      return deferred;
    };
    var ref = function (value) {
      if (value && value.then)
        return value;
      return {
        then: function (callback) {
          var result = defer();
          nextTick(function () {
            result.resolve(callback(value));
          });
          return result.promise;
        }
      };
    };
    var reject = function (reason) {
      return {
        then: function (callback, errback) {
          var result = defer();
          nextTick(function () {
            result.resolve((errback || defaultErrback)(reason));
          });
          return result.promise;
        }
      };
    };
    var when = function (value, callback, errback) {
      var result = defer(), done;
      var wrappedCallback = function (value) {
        try {
          return (callback || defaultCallback)(value);
        } catch (e) {
          exceptionHandler(e);
          return reject(e);
        }
      };
      var wrappedErrback = function (reason) {
        try {
          return (errback || defaultErrback)(reason);
        } catch (e) {
          exceptionHandler(e);
          return reject(e);
        }
      };
      nextTick(function () {
        ref(value).then(function (value) {
          if (done)
            return;
          done = true;
          result.resolve(ref(value).then(wrappedCallback, wrappedErrback));
        }, function (reason) {
          if (done)
            return;
          done = true;
          result.resolve(wrappedErrback(reason));
        });
      });
      return result.promise;
    };
    function defaultCallback(value) {
      return value;
    }
    function defaultErrback(reason) {
      return reject(reason);
    }
    function all(promises) {
      var deferred = defer(), counter = promises.length, results = [];
      if (counter) {
        forEach(promises, function (promise, index) {
          ref(promise).then(function (value) {
            if (index in results)
              return;
            results[index] = value;
            if (!--counter)
              deferred.resolve(results);
          }, function (reason) {
            if (index in results)
              return;
            deferred.reject(reason);
          });
        });
      } else {
        deferred.resolve(results);
      }
      return deferred.promise;
    }
    return {
      defer: defer,
      reject: reject,
      when: when,
      all: all
    };
  }
  function $RouteProvider() {
    var routes = {};
    this.when = function (path, route) {
      routes[path] = extend({ reloadOnSearch: true }, route);
      if (path) {
        var redirectPath = path[path.length - 1] == '/' ? path.substr(0, path.length - 1) : path + '/';
        routes[redirectPath] = { redirectTo: path };
      }
      return this;
    };
    this.otherwise = function (params) {
      this.when(null, params);
      return this;
    };
    this.$get = [
      '$rootScope',
      '$location',
      '$routeParams',
      '$q',
      '$injector',
      '$http',
      '$templateCache',
      function ($rootScope, $location, $routeParams, $q, $injector, $http, $templateCache) {
        var forceReload = false, $route = {
            routes: routes,
            reload: function () {
              forceReload = true;
              $rootScope.$evalAsync(updateRoute);
            }
          };
        $rootScope.$on('$locationChangeSuccess', updateRoute);
        return $route;
        function switchRouteMatcher(on, when) {
          when = '^' + when.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') + '$';
          var regex = '', params = [], dst = {};
          var re = /:(\w+)/g, paramMatch, lastMatchedIndex = 0;
          while ((paramMatch = re.exec(when)) !== null) {
            regex += when.slice(lastMatchedIndex, paramMatch.index);
            regex += '([^\\/]*)';
            params.push(paramMatch[1]);
            lastMatchedIndex = re.lastIndex;
          }
          regex += when.substr(lastMatchedIndex);
          var match = on.match(new RegExp(regex));
          if (match) {
            forEach(params, function (name, index) {
              dst[name] = match[index + 1];
            });
          }
          return match ? dst : null;
        }
        function updateRoute() {
          var next = parseRoute(), last = $route.current;
          if (next && last && next.$$route === last.$$route && equals(next.pathParams, last.pathParams) && !next.reloadOnSearch && !forceReload) {
            last.params = next.params;
            copy(last.params, $routeParams);
            $rootScope.$broadcast('$routeUpdate', last);
          } else if (next || last) {
            forceReload = false;
            $rootScope.$broadcast('$routeChangeStart', next, last);
            $route.current = next;
            if (next) {
              if (next.redirectTo) {
                if (isString(next.redirectTo)) {
                  $location.path(interpolate(next.redirectTo, next.params)).search(next.params).replace();
                } else {
                  $location.url(next.redirectTo(next.pathParams, $location.path(), $location.search())).replace();
                }
              }
            }
            $q.when(next).then(function () {
              if (next) {
                var keys = [], values = [], template;
                forEach(next.resolve || {}, function (value, key) {
                  keys.push(key);
                  values.push(isString(value) ? $injector.get(value) : $injector.invoke(value));
                });
                if (isDefined(template = next.template)) {
                } else if (isDefined(template = next.templateUrl)) {
                  template = $http.get(template, { cache: $templateCache }).then(function (response) {
                    return response.data;
                  });
                }
                if (isDefined(template)) {
                  keys.push('$template');
                  values.push(template);
                }
                return $q.all(values).then(function (values) {
                  var locals = {};
                  forEach(values, function (value, index) {
                    locals[keys[index]] = value;
                  });
                  return locals;
                });
              }
            }).then(function (locals) {
              if (next == $route.current) {
                if (next) {
                  next.locals = locals;
                  copy(next.params, $routeParams);
                }
                $rootScope.$broadcast('$routeChangeSuccess', next, last);
              }
            }, function (error) {
              if (next == $route.current) {
                $rootScope.$broadcast('$routeChangeError', next, last, error);
              }
            });
          }
        }
        function parseRoute() {
          var params, match;
          forEach(routes, function (route, path) {
            if (!match && (params = switchRouteMatcher($location.path(), path))) {
              match = inherit(route, {
                params: extend({}, $location.search(), params),
                pathParams: params
              });
              match.$$route = route;
            }
          });
          return match || routes[null] && inherit(routes[null], {
            params: {},
            pathParams: {}
          });
        }
        function interpolate(string, params) {
          var result = [];
          forEach((string || '').split(':'), function (segment, i) {
            if (i == 0) {
              result.push(segment);
            } else {
              var segmentMatch = segment.match(/(\w+)(.*)/);
              var key = segmentMatch[1];
              result.push(params[key]);
              result.push(segmentMatch[2] || '');
              delete params[key];
            }
          });
          return result.join('');
        }
      }
    ];
  }
  function $RouteParamsProvider() {
    this.$get = valueFn({});
  }
  function $RootScopeProvider() {
    var TTL = 10;
    this.digestTtl = function (value) {
      if (arguments.length) {
        TTL = value;
      }
      return TTL;
    };
    this.$get = [
      '$injector',
      '$exceptionHandler',
      '$parse',
      function ($injector, $exceptionHandler, $parse) {
        function Scope() {
          this.$id = nextUid();
          this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
          this['this'] = this.$root = this;
          this.$$destroyed = false;
          this.$$asyncQueue = [];
          this.$$listeners = {};
          this.$$isolateBindings = {};
        }
        Scope.prototype = {
          $new: function (isolate) {
            var Child, child;
            if (isFunction(isolate)) {
              throw Error('API-CHANGE: Use $controller to instantiate controllers.');
            }
            if (isolate) {
              child = new Scope();
              child.$root = this.$root;
            } else {
              Child = function () {
              };
              Child.prototype = this;
              child = new Child();
              child.$id = nextUid();
            }
            child['this'] = child;
            child.$$listeners = {};
            child.$parent = this;
            child.$$asyncQueue = [];
            child.$$watchers = child.$$nextSibling = child.$$childHead = child.$$childTail = null;
            child.$$prevSibling = this.$$childTail;
            if (this.$$childHead) {
              this.$$childTail.$$nextSibling = child;
              this.$$childTail = child;
            } else {
              this.$$childHead = this.$$childTail = child;
            }
            return child;
          },
          $watch: function (watchExp, listener, objectEquality) {
            var scope = this, get = compileToFn(watchExp, 'watch'), array = scope.$$watchers, watcher = {
                fn: listener,
                last: initWatchVal,
                get: get,
                exp: watchExp,
                eq: !!objectEquality
              };
            if (!isFunction(listener)) {
              var listenFn = compileToFn(listener || noop, 'listener');
              watcher.fn = function (newVal, oldVal, scope) {
                listenFn(scope);
              };
            }
            if (!array) {
              array = scope.$$watchers = [];
            }
            array.unshift(watcher);
            return function () {
              arrayRemove(array, watcher);
            };
          },
          $digest: function () {
            var watch, value, last, watchers, asyncQueue, length, dirty, ttl = TTL, next, current, target = this, watchLog = [], logIdx, logMsg;
            beginPhase('$digest');
            do {
              dirty = false;
              current = target;
              do {
                asyncQueue = current.$$asyncQueue;
                while (asyncQueue.length) {
                  try {
                    current.$eval(asyncQueue.shift());
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (watchers = current.$$watchers) {
                  length = watchers.length;
                  while (length--) {
                    try {
                      watch = watchers[length];
                      if ((value = watch.get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : typeof value == 'number' && typeof last == 'number' && isNaN(value) && isNaN(last))) {
                        dirty = true;
                        watch.last = watch.eq ? copy(value) : value;
                        watch.fn(value, last === initWatchVal ? value : last, current);
                        if (ttl < 5) {
                          logIdx = 4 - ttl;
                          if (!watchLog[logIdx])
                            watchLog[logIdx] = [];
                          logMsg = isFunction(watch.exp) ? 'fn: ' + (watch.exp.name || watch.exp.toString()) : watch.exp;
                          logMsg += '; newVal: ' + toJson(value) + '; oldVal: ' + toJson(last);
                          watchLog[logIdx].push(logMsg);
                        }
                      }
                    } catch (e) {
                      $exceptionHandler(e);
                    }
                  }
                }
                if (!(next = current.$$childHead || current !== target && current.$$nextSibling)) {
                  while (current !== target && !(next = current.$$nextSibling)) {
                    current = current.$parent;
                  }
                }
              } while (current = next);
              if (dirty && !ttl--) {
                clearPhase();
                throw Error(TTL + ' $digest() iterations reached. Aborting!\n' + 'Watchers fired in the last 5 iterations: ' + toJson(watchLog));
              }
            } while (dirty || asyncQueue.length);
            clearPhase();
          },
          $destroy: function () {
            if ($rootScope == this || this.$$destroyed)
              return;
            var parent = this.$parent;
            this.$broadcast('$destroy');
            this.$$destroyed = true;
            if (parent.$$childHead == this)
              parent.$$childHead = this.$$nextSibling;
            if (parent.$$childTail == this)
              parent.$$childTail = this.$$prevSibling;
            if (this.$$prevSibling)
              this.$$prevSibling.$$nextSibling = this.$$nextSibling;
            if (this.$$nextSibling)
              this.$$nextSibling.$$prevSibling = this.$$prevSibling;
            this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
          },
          $eval: function (expr, locals) {
            return $parse(expr)(this, locals);
          },
          $evalAsync: function (expr) {
            this.$$asyncQueue.push(expr);
          },
          $apply: function (expr) {
            try {
              beginPhase('$apply');
              return this.$eval(expr);
            } catch (e) {
              $exceptionHandler(e);
            } finally {
              clearPhase();
              try {
                $rootScope.$digest();
              } catch (e) {
                $exceptionHandler(e);
                throw e;
              }
            }
          },
          $on: function (name, listener) {
            var namedListeners = this.$$listeners[name];
            if (!namedListeners) {
              this.$$listeners[name] = namedListeners = [];
            }
            namedListeners.push(listener);
            return function () {
              namedListeners[indexOf(namedListeners, listener)] = null;
            };
          },
          $emit: function (name, args) {
            var empty = [], namedListeners, scope = this, stopPropagation = false, event = {
                name: name,
                targetScope: scope,
                stopPropagation: function () {
                  stopPropagation = true;
                },
                preventDefault: function () {
                  event.defaultPrevented = true;
                },
                defaultPrevented: false
              }, listenerArgs = concat([event], arguments, 1), i, length;
            do {
              namedListeners = scope.$$listeners[name] || empty;
              event.currentScope = scope;
              for (i = 0, length = namedListeners.length; i < length; i++) {
                if (!namedListeners[i]) {
                  namedListeners.splice(i, 1);
                  i--;
                  length--;
                  continue;
                }
                try {
                  namedListeners[i].apply(null, listenerArgs);
                  if (stopPropagation)
                    return event;
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
              scope = scope.$parent;
            } while (scope);
            return event;
          },
          $broadcast: function (name, args) {
            var target = this, current = target, next = target, event = {
                name: name,
                targetScope: target,
                preventDefault: function () {
                  event.defaultPrevented = true;
                },
                defaultPrevented: false
              }, listenerArgs = concat([event], arguments, 1), listeners, i, length;
            do {
              current = next;
              event.currentScope = current;
              listeners = current.$$listeners[name] || [];
              for (i = 0, length = listeners.length; i < length; i++) {
                if (!listeners[i]) {
                  listeners.splice(i, 1);
                  i--;
                  length--;
                  continue;
                }
                try {
                  listeners[i].apply(null, listenerArgs);
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
              if (!(next = current.$$childHead || current !== target && current.$$nextSibling)) {
                while (current !== target && !(next = current.$$nextSibling)) {
                  current = current.$parent;
                }
              }
            } while (current = next);
            return event;
          }
        };
        var $rootScope = new Scope();
        return $rootScope;
        function beginPhase(phase) {
          if ($rootScope.$$phase) {
            throw Error($rootScope.$$phase + ' already in progress');
          }
          $rootScope.$$phase = phase;
        }
        function clearPhase() {
          $rootScope.$$phase = null;
        }
        function compileToFn(exp, name) {
          var fn = $parse(exp);
          assertArgFn(fn, name);
          return fn;
        }
        function initWatchVal() {
        }
      }
    ];
  }
  function $SnifferProvider() {
    this.$get = [
      '$window',
      function ($window) {
        var eventSupport = {}, android = int((/android (\d+)/.exec(lowercase($window.navigator.userAgent)) || [])[1]);
        return {
          history: !!($window.history && $window.history.pushState && !(android < 4)),
          hashchange: 'onhashchange' in $window && (!$window.document.documentMode || $window.document.documentMode > 7),
          hasEvent: function (event) {
            if (event == 'input' && msie == 9)
              return false;
            if (isUndefined(eventSupport[event])) {
              var divElm = $window.document.createElement('div');
              eventSupport[event] = 'on' + event in divElm;
            }
            return eventSupport[event];
          },
          csp: false
        };
      }
    ];
  }
  function $WindowProvider() {
    this.$get = valueFn(window);
  }
  function parseHeaders(headers) {
    var parsed = {}, key, val, i;
    if (!headers)
      return parsed;
    forEach(headers.split('\n'), function (line) {
      i = line.indexOf(':');
      key = lowercase(trim(line.substr(0, i)));
      val = trim(line.substr(i + 1));
      if (key) {
        if (parsed[key]) {
          parsed[key] += ', ' + val;
        } else {
          parsed[key] = val;
        }
      }
    });
    return parsed;
  }
  function headersGetter(headers) {
    var headersObj = isObject(headers) ? headers : undefined;
    return function (name) {
      if (!headersObj)
        headersObj = parseHeaders(headers);
      if (name) {
        return headersObj[lowercase(name)] || null;
      }
      return headersObj;
    };
  }
  function transformData(data, headers, fns) {
    if (isFunction(fns))
      return fns(data, headers);
    forEach(fns, function (fn) {
      data = fn(data, headers);
    });
    return data;
  }
  function isSuccess(status) {
    return 200 <= status && status < 300;
  }
  function $HttpProvider() {
    var JSON_START = /^\s*(\[|\{[^\{])/, JSON_END = /[\}\]]\s*$/, PROTECTION_PREFIX = /^\)\]\}',?\n/;
    var $config = this.defaults = {
        transformResponse: [function (data) {
            if (isString(data)) {
              data = data.replace(PROTECTION_PREFIX, '');
              if (JSON_START.test(data) && JSON_END.test(data))
                data = fromJson(data, true);
            }
            return data;
          }],
        transformRequest: [function (d) {
            return isObject(d) && !isFile(d) ? toJson(d) : d;
          }],
        headers: {
          common: {
            'Accept': 'application/json, text/plain, */*',
            'X-Requested-With': 'XMLHttpRequest'
          },
          post: { 'Content-Type': 'application/json;charset=utf-8' },
          put: { 'Content-Type': 'application/json;charset=utf-8' }
        }
      };
    var providerResponseInterceptors = this.responseInterceptors = [];
    this.$get = [
      '$httpBackend',
      '$browser',
      '$cacheFactory',
      '$rootScope',
      '$q',
      '$injector',
      function ($httpBackend, $browser, $cacheFactory, $rootScope, $q, $injector) {
        var defaultCache = $cacheFactory('$http'), responseInterceptors = [];
        forEach(providerResponseInterceptors, function (interceptor) {
          responseInterceptors.push(isString(interceptor) ? $injector.get(interceptor) : $injector.invoke(interceptor));
        });
        function $http(config) {
          config.method = uppercase(config.method);
          var reqTransformFn = config.transformRequest || $config.transformRequest, respTransformFn = config.transformResponse || $config.transformResponse, defHeaders = $config.headers, reqHeaders = extend({ 'X-XSRF-TOKEN': $browser.cookies()['XSRF-TOKEN'] }, defHeaders.common, defHeaders[lowercase(config.method)], config.headers), reqData = transformData(config.data, headersGetter(reqHeaders), reqTransformFn), promise;
          if (isUndefined(config.data)) {
            delete reqHeaders['Content-Type'];
          }
          promise = sendReq(config, reqData, reqHeaders);
          promise = promise.then(transformResponse, transformResponse);
          forEach(responseInterceptors, function (interceptor) {
            promise = interceptor(promise);
          });
          promise.success = function (fn) {
            promise.then(function (response) {
              fn(response.data, response.status, response.headers, config);
            });
            return promise;
          };
          promise.error = function (fn) {
            promise.then(null, function (response) {
              fn(response.data, response.status, response.headers, config);
            });
            return promise;
          };
          return promise;
          function transformResponse(response) {
            var resp = extend({}, response, { data: transformData(response.data, response.headers, respTransformFn) });
            return isSuccess(response.status) ? resp : $q.reject(resp);
          }
        }
        $http.pendingRequests = [];
        createShortMethods('get', 'delete', 'head', 'jsonp');
        createShortMethodsWithData('post', 'put');
        $http.defaults = $config;
        return $http;
        function createShortMethods(names) {
          forEach(arguments, function (name) {
            $http[name] = function (url, config) {
              return $http(extend(config || {}, {
                method: name,
                url: url
              }));
            };
          });
        }
        function createShortMethodsWithData(name) {
          forEach(arguments, function (name) {
            $http[name] = function (url, data, config) {
              return $http(extend(config || {}, {
                method: name,
                url: url,
                data: data
              }));
            };
          });
        }
        function sendReq(config, reqData, reqHeaders) {
          var deferred = $q.defer(), promise = deferred.promise, cache, cachedResp, url = buildUrl(config.url, config.params);
          $http.pendingRequests.push(config);
          promise.then(removePendingReq, removePendingReq);
          if (config.cache && config.method == 'GET') {
            cache = isObject(config.cache) ? config.cache : defaultCache;
          }
          if (cache) {
            cachedResp = cache.get(url);
            if (cachedResp) {
              if (cachedResp.then) {
                cachedResp.then(removePendingReq, removePendingReq);
                return cachedResp;
              } else {
                if (isArray(cachedResp)) {
                  resolvePromise(cachedResp[1], cachedResp[0], copy(cachedResp[2]));
                } else {
                  resolvePromise(cachedResp, 200, {});
                }
              }
            } else {
              cache.put(url, promise);
            }
          }
          if (!cachedResp) {
            $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials);
          }
          return promise;
          function done(status, response, headersString) {
            if (cache) {
              if (isSuccess(status)) {
                cache.put(url, [
                  status,
                  response,
                  parseHeaders(headersString)
                ]);
              } else {
                cache.remove(url);
              }
            }
            resolvePromise(response, status, headersString);
            $rootScope.$apply();
          }
          function resolvePromise(response, status, headers) {
            status = Math.max(status, 0);
            (isSuccess(status) ? deferred.resolve : deferred.reject)({
              data: response,
              status: status,
              headers: headersGetter(headers),
              config: config
            });
          }
          function removePendingReq() {
            var idx = indexOf($http.pendingRequests, config);
            if (idx !== -1)
              $http.pendingRequests.splice(idx, 1);
          }
        }
        function buildUrl(url, params) {
          if (!params)
            return url;
          var parts = [];
          forEachSorted(params, function (value, key) {
            if (value == null || value == undefined)
              return;
            if (isObject(value)) {
              value = toJson(value);
            }
            parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
          });
          return url + (url.indexOf('?') == -1 ? '?' : '&') + parts.join('&');
        }
      }
    ];
  }
  var XHR = window.XMLHttpRequest || function () {
      try {
        return new ActiveXObject('Msxml2.XMLHTTP.6.0');
      } catch (e1) {
      }
      try {
        return new ActiveXObject('Msxml2.XMLHTTP.3.0');
      } catch (e2) {
      }
      try {
        return new ActiveXObject('Msxml2.XMLHTTP');
      } catch (e3) {
      }
      throw new Error('This browser does not support XMLHttpRequest.');
    };
  function $HttpBackendProvider() {
    this.$get = [
      '$browser',
      '$window',
      '$document',
      function ($browser, $window, $document) {
        return createHttpBackend($browser, XHR, $browser.defer, $window.angular.callbacks, $document[0], $window.location.protocol.replace(':', ''));
      }
    ];
  }
  function createHttpBackend($browser, XHR, $browserDefer, callbacks, rawDocument, locationProtocol) {
    return function (method, url, post, callback, headers, timeout, withCredentials) {
      $browser.$$incOutstandingRequestCount();
      url = url || $browser.url();
      if (lowercase(method) == 'jsonp') {
        var callbackId = '_' + (callbacks.counter++).toString(36);
        callbacks[callbackId] = function (data) {
          callbacks[callbackId].data = data;
        };
        jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId), function () {
          if (callbacks[callbackId].data) {
            completeRequest(callback, 200, callbacks[callbackId].data);
          } else {
            completeRequest(callback, -2);
          }
          delete callbacks[callbackId];
        });
      } else {
        var xhr = new XHR();
        xhr.open(method, url, true);
        forEach(headers, function (value, key) {
          if (value)
            xhr.setRequestHeader(key, value);
        });
        var status;
        xhr.onreadystatechange = function () {
          if (xhr.readyState == 4) {
            var responseHeaders = xhr.getAllResponseHeaders();
            var value, simpleHeaders = [
                'Cache-Control',
                'Content-Language',
                'Content-Type',
                'Expires',
                'Last-Modified',
                'Pragma'
              ];
            if (!responseHeaders) {
              responseHeaders = '';
              forEach(simpleHeaders, function (header) {
                var value = xhr.getResponseHeader(header);
                if (value) {
                  responseHeaders += header + ': ' + value + '\n';
                }
              });
            }
            completeRequest(callback, status || xhr.status, xhr.responseText, responseHeaders);
          }
        };
        if (withCredentials) {
          xhr.withCredentials = true;
        }
        xhr.send(post || '');
        if (timeout > 0) {
          $browserDefer(function () {
            status = -1;
            xhr.abort();
          }, timeout);
        }
      }
      function completeRequest(callback, status, response, headersString) {
        var protocol = (url.match(URL_MATCH) || [
            '',
            locationProtocol
          ])[1];
        status = protocol == 'file' ? response ? 200 : 404 : status;
        status = status == 1223 ? 204 : status;
        callback(status, response, headersString);
        $browser.$$completeOutstandingRequest(noop);
      }
    };
    function jsonpReq(url, done) {
      var script = rawDocument.createElement('script'), doneWrapper = function () {
          rawDocument.body.removeChild(script);
          if (done)
            done();
        };
      script.type = 'text/javascript';
      script.src = url;
      if (msie) {
        script.onreadystatechange = function () {
          if (/loaded|complete/.test(script.readyState))
            doneWrapper();
        };
      } else {
        script.onload = script.onerror = doneWrapper;
      }
      rawDocument.body.appendChild(script);
    }
  }
  function $LocaleProvider() {
    this.$get = function () {
      return {
        id: 'en-us',
        NUMBER_FORMATS: {
          DECIMAL_SEP: '.',
          GROUP_SEP: ',',
          PATTERNS: [
            {
              minInt: 1,
              minFrac: 0,
              maxFrac: 3,
              posPre: '',
              posSuf: '',
              negPre: '-',
              negSuf: '',
              gSize: 3,
              lgSize: 3
            },
            {
              minInt: 1,
              minFrac: 2,
              maxFrac: 2,
              posPre: '\xa4',
              posSuf: '',
              negPre: '(\xa4',
              negSuf: ')',
              gSize: 3,
              lgSize: 3
            }
          ],
          CURRENCY_SYM: '$'
        },
        DATETIME_FORMATS: {
          MONTH: 'January,February,March,April,May,June,July,August,September,October,November,December'.split(','),
          SHORTMONTH: 'Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec'.split(','),
          DAY: 'Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday'.split(','),
          SHORTDAY: 'Sun,Mon,Tue,Wed,Thu,Fri,Sat'.split(','),
          AMPMS: [
            'AM',
            'PM'
          ],
          medium: 'MMM d, y h:mm:ss a',
          short: 'M/d/yy h:mm a',
          fullDate: 'EEEE, MMMM d, y',
          longDate: 'MMMM d, y',
          mediumDate: 'MMM d, y',
          shortDate: 'M/d/yy',
          mediumTime: 'h:mm:ss a',
          shortTime: 'h:mm a'
        },
        pluralCat: function (num) {
          if (num === 1) {
            return 'one';
          }
          return 'other';
        }
      };
    };
  }
  function $TimeoutProvider() {
    this.$get = [
      '$rootScope',
      '$browser',
      '$q',
      '$exceptionHandler',
      function ($rootScope, $browser, $q, $exceptionHandler) {
        var deferreds = {};
        function timeout(fn, delay, invokeApply) {
          var deferred = $q.defer(), promise = deferred.promise, skipApply = isDefined(invokeApply) && !invokeApply, timeoutId, cleanup;
          timeoutId = $browser.defer(function () {
            try {
              deferred.resolve(fn());
            } catch (e) {
              deferred.reject(e);
              $exceptionHandler(e);
            }
            if (!skipApply)
              $rootScope.$apply();
          }, delay);
          cleanup = function () {
            delete deferreds[promise.$$timeoutId];
          };
          promise.$$timeoutId = timeoutId;
          deferreds[timeoutId] = deferred;
          promise.then(cleanup, cleanup);
          return promise;
        }
        timeout.cancel = function (promise) {
          if (promise && promise.$$timeoutId in deferreds) {
            deferreds[promise.$$timeoutId].reject('canceled');
            return $browser.defer.cancel(promise.$$timeoutId);
          }
          return false;
        };
        return timeout;
      }
    ];
  }
  $FilterProvider.$inject = ['$provide'];
  function $FilterProvider($provide) {
    var suffix = 'Filter';
    function register(name, factory) {
      return $provide.factory(name + suffix, factory);
    }
    this.register = register;
    this.$get = [
      '$injector',
      function ($injector) {
        return function (name) {
          return $injector.get(name + suffix);
        };
      }
    ];
    register('currency', currencyFilter);
    register('date', dateFilter);
    register('filter', filterFilter);
    register('json', jsonFilter);
    register('limitTo', limitToFilter);
    register('lowercase', lowercaseFilter);
    register('number', numberFilter);
    register('orderBy', orderByFilter);
    register('uppercase', uppercaseFilter);
  }
  function filterFilter() {
    return function (array, expression) {
      if (!isArray(array))
        return array;
      var predicates = [];
      predicates.check = function (value) {
        for (var j = 0; j < predicates.length; j++) {
          if (!predicates[j](value)) {
            return false;
          }
        }
        return true;
      };
      var search = function (obj, text) {
        if (text.charAt(0) === '!') {
          return !search(obj, text.substr(1));
        }
        switch (typeof obj) {
        case 'boolean':
        case 'number':
        case 'string':
          return ('' + obj).toLowerCase().indexOf(text) > -1;
        case 'object':
          for (var objKey in obj) {
            if (objKey.charAt(0) !== '$' && search(obj[objKey], text)) {
              return true;
            }
          }
          return false;
        case 'array':
          for (var i = 0; i < obj.length; i++) {
            if (search(obj[i], text)) {
              return true;
            }
          }
          return false;
        default:
          return false;
        }
      };
      switch (typeof expression) {
      case 'boolean':
      case 'number':
      case 'string':
        expression = { $: expression };
      case 'object':
        for (var key in expression) {
          if (key == '$') {
            (function () {
              var text = ('' + expression[key]).toLowerCase();
              if (!text)
                return;
              predicates.push(function (value) {
                return search(value, text);
              });
            }());
          } else {
            (function () {
              var path = key;
              var text = ('' + expression[key]).toLowerCase();
              if (!text)
                return;
              predicates.push(function (value) {
                return search(getter(value, path), text);
              });
            }());
          }
        }
        break;
      case 'function':
        predicates.push(expression);
        break;
      default:
        return array;
      }
      var filtered = [];
      for (var j = 0; j < array.length; j++) {
        var value = array[j];
        if (predicates.check(value)) {
          filtered.push(value);
        }
      }
      return filtered;
    };
  }
  currencyFilter.$inject = ['$locale'];
  function currencyFilter($locale) {
    var formats = $locale.NUMBER_FORMATS;
    return function (amount, currencySymbol) {
      if (isUndefined(currencySymbol))
        currencySymbol = formats.CURRENCY_SYM;
      return formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, 2).replace(/\u00A4/g, currencySymbol);
    };
  }
  numberFilter.$inject = ['$locale'];
  function numberFilter($locale) {
    var formats = $locale.NUMBER_FORMATS;
    return function (number, fractionSize) {
      return formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
    };
  }
  var DECIMAL_SEP = '.';
  function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
    if (isNaN(number) || !isFinite(number))
      return '';
    var isNegative = number < 0;
    number = Math.abs(number);
    var numStr = number + '', formatedText = '', parts = [];
    var hasExponent = false;
    if (numStr.indexOf('e') !== -1) {
      var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
      if (match && match[2] == '-' && match[3] > fractionSize + 1) {
        numStr = '0';
      } else {
        formatedText = numStr;
        hasExponent = true;
      }
    }
    if (!hasExponent) {
      var fractionLen = (numStr.split(DECIMAL_SEP)[1] || '').length;
      if (isUndefined(fractionSize)) {
        fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);
      }
      var pow = Math.pow(10, fractionSize);
      number = Math.round(number * pow) / pow;
      var fraction = ('' + number).split(DECIMAL_SEP);
      var whole = fraction[0];
      fraction = fraction[1] || '';
      var pos = 0, lgroup = pattern.lgSize, group = pattern.gSize;
      if (whole.length >= lgroup + group) {
        pos = whole.length - lgroup;
        for (var i = 0; i < pos; i++) {
          if ((pos - i) % group === 0 && i !== 0) {
            formatedText += groupSep;
          }
          formatedText += whole.charAt(i);
        }
      }
      for (i = pos; i < whole.length; i++) {
        if ((whole.length - i) % lgroup === 0 && i !== 0) {
          formatedText += groupSep;
        }
        formatedText += whole.charAt(i);
      }
      while (fraction.length < fractionSize) {
        fraction += '0';
      }
      if (fractionSize && fractionSize !== '0')
        formatedText += decimalSep + fraction.substr(0, fractionSize);
    }
    parts.push(isNegative ? pattern.negPre : pattern.posPre);
    parts.push(formatedText);
    parts.push(isNegative ? pattern.negSuf : pattern.posSuf);
    return parts.join('');
  }
  function padNumber(num, digits, trim) {
    var neg = '';
    if (num < 0) {
      neg = '-';
      num = -num;
    }
    num = '' + num;
    while (num.length < digits)
      num = '0' + num;
    if (trim)
      num = num.substr(num.length - digits);
    return neg + num;
  }
  function dateGetter(name, size, offset, trim) {
    offset = offset || 0;
    return function (date) {
      var value = date['get' + name]();
      if (offset > 0 || value > -offset)
        value += offset;
      if (value === 0 && offset == -12)
        value = 12;
      return padNumber(value, size, trim);
    };
  }
  function dateStrGetter(name, shortForm) {
    return function (date, formats) {
      var value = date['get' + name]();
      var get = uppercase(shortForm ? 'SHORT' + name : name);
      return formats[get][value];
    };
  }
  function timeZoneGetter(date) {
    var zone = -1 * date.getTimezoneOffset();
    var paddedZone = zone >= 0 ? '+' : '';
    paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
    return paddedZone;
  }
  function ampmGetter(date, formats) {
    return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
  }
  var DATE_FORMATS = {
      yyyy: dateGetter('FullYear', 4),
      yy: dateGetter('FullYear', 2, 0, true),
      y: dateGetter('FullYear', 1),
      MMMM: dateStrGetter('Month'),
      MMM: dateStrGetter('Month', true),
      MM: dateGetter('Month', 2, 1),
      M: dateGetter('Month', 1, 1),
      dd: dateGetter('Date', 2),
      d: dateGetter('Date', 1),
      HH: dateGetter('Hours', 2),
      H: dateGetter('Hours', 1),
      hh: dateGetter('Hours', 2, -12),
      h: dateGetter('Hours', 1, -12),
      mm: dateGetter('Minutes', 2),
      m: dateGetter('Minutes', 1),
      ss: dateGetter('Seconds', 2),
      s: dateGetter('Seconds', 1),
      EEEE: dateStrGetter('Day'),
      EEE: dateStrGetter('Day', true),
      a: ampmGetter,
      Z: timeZoneGetter
    };
  var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZE']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z))(.*)/, NUMBER_STRING = /^\d+$/;
  dateFilter.$inject = ['$locale'];
  function dateFilter($locale) {
    var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
    function jsonStringToDate(string) {
      var match;
      if (match = string.match(R_ISO8601_STR)) {
        var date = new Date(0), tzHour = 0, tzMin = 0;
        if (match[9]) {
          tzHour = int(match[9] + match[10]);
          tzMin = int(match[9] + match[11]);
        }
        date.setUTCFullYear(int(match[1]), int(match[2]) - 1, int(match[3]));
        date.setUTCHours(int(match[4] || 0) - tzHour, int(match[5] || 0) - tzMin, int(match[6] || 0), int(match[7] || 0));
        return date;
      }
      return string;
    }
    return function (date, format) {
      var text = '', parts = [], fn, match;
      format = format || 'mediumDate';
      format = $locale.DATETIME_FORMATS[format] || format;
      if (isString(date)) {
        if (NUMBER_STRING.test(date)) {
          date = int(date);
        } else {
          date = jsonStringToDate(date);
        }
      }
      if (isNumber(date)) {
        date = new Date(date);
      }
      if (!isDate(date)) {
        return date;
      }
      while (format) {
        match = DATE_FORMATS_SPLIT.exec(format);
        if (match) {
          parts = concat(parts, match, 1);
          format = parts.pop();
        } else {
          parts.push(format);
          format = null;
        }
      }
      forEach(parts, function (value) {
        fn = DATE_FORMATS[value];
        text += fn ? fn(date, $locale.DATETIME_FORMATS) : value.replace(/(^'|'$)/g, '').replace(/''/g, '\'');
      });
      return text;
    };
  }
  function jsonFilter() {
    return function (object) {
      return toJson(object, true);
    };
  }
  var lowercaseFilter = valueFn(lowercase);
  var uppercaseFilter = valueFn(uppercase);
  function limitToFilter() {
    return function (array, limit) {
      if (!(array instanceof Array))
        return array;
      limit = int(limit);
      var out = [], i, n;
      if (!array || !(array instanceof Array))
        return out;
      if (limit > array.length)
        limit = array.length;
      else if (limit < -array.length)
        limit = -array.length;
      if (limit > 0) {
        i = 0;
        n = limit;
      } else {
        i = array.length + limit;
        n = array.length;
      }
      for (; i < n; i++) {
        out.push(array[i]);
      }
      return out;
    };
  }
  orderByFilter.$inject = ['$parse'];
  function orderByFilter($parse) {
    return function (array, sortPredicate, reverseOrder) {
      if (!isArray(array))
        return array;
      if (!sortPredicate)
        return array;
      sortPredicate = isArray(sortPredicate) ? sortPredicate : [sortPredicate];
      sortPredicate = map(sortPredicate, function (predicate) {
        var descending = false, get = predicate || identity;
        if (isString(predicate)) {
          if (predicate.charAt(0) == '+' || predicate.charAt(0) == '-') {
            descending = predicate.charAt(0) == '-';
            predicate = predicate.substring(1);
          }
          get = $parse(predicate);
        }
        return reverseComparator(function (a, b) {
          return compare(get(a), get(b));
        }, descending);
      });
      var arrayCopy = [];
      for (var i = 0; i < array.length; i++) {
        arrayCopy.push(array[i]);
      }
      return arrayCopy.sort(reverseComparator(comparator, reverseOrder));
      function comparator(o1, o2) {
        for (var i = 0; i < sortPredicate.length; i++) {
          var comp = sortPredicate[i](o1, o2);
          if (comp !== 0)
            return comp;
        }
        return 0;
      }
      function reverseComparator(comp, descending) {
        return toBoolean(descending) ? function (a, b) {
          return comp(b, a);
        } : comp;
      }
      function compare(v1, v2) {
        var t1 = typeof v1;
        var t2 = typeof v2;
        if (t1 == t2) {
          if (t1 == 'string')
            v1 = v1.toLowerCase();
          if (t1 == 'string')
            v2 = v2.toLowerCase();
          if (v1 === v2)
            return 0;
          return v1 < v2 ? -1 : 1;
        } else {
          return t1 < t2 ? -1 : 1;
        }
      }
    };
  }
  function ngDirective(directive) {
    if (isFunction(directive)) {
      directive = { link: directive };
    }
    directive.restrict = directive.restrict || 'AC';
    return valueFn(directive);
  }
  var htmlAnchorDirective = valueFn({
      restrict: 'E',
      compile: function (element, attr) {
        if (msie <= 8) {
          if (!attr.href && !attr.name) {
            attr.$set('href', '');
          }
          element.append(document.createComment('IE fix'));
        }
        return function (scope, element) {
          element.bind('click', function (event) {
            if (!element.attr('href')) {
              event.preventDefault();
            }
          });
        };
      }
    });
  var ngAttributeAliasDirectives = {};
  forEach(BOOLEAN_ATTR, function (propName, attrName) {
    var normalized = directiveNormalize('ng-' + attrName);
    ngAttributeAliasDirectives[normalized] = function () {
      return {
        priority: 100,
        compile: function () {
          return function (scope, element, attr) {
            scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
              attr.$set(attrName, !!value);
            });
          };
        }
      };
    };
  });
  forEach([
    'src',
    'href'
  ], function (attrName) {
    var normalized = directiveNormalize('ng-' + attrName);
    ngAttributeAliasDirectives[normalized] = function () {
      return {
        priority: 99,
        link: function (scope, element, attr) {
          attr.$observe(normalized, function (value) {
            if (!value)
              return;
            attr.$set(attrName, value);
            if (msie)
              element.prop(attrName, attr[attrName]);
          });
        }
      };
    };
  });
  var nullFormCtrl = {
      $addControl: noop,
      $removeControl: noop,
      $setValidity: noop,
      $setDirty: noop
    };
  FormController.$inject = [
    '$element',
    '$attrs',
    '$scope'
  ];
  function FormController(element, attrs) {
    var form = this, parentForm = element.parent().controller('form') || nullFormCtrl, invalidCount = 0, errors = form.$error = {};
    form.$name = attrs.name;
    form.$dirty = false;
    form.$pristine = true;
    form.$valid = true;
    form.$invalid = false;
    parentForm.$addControl(form);
    element.addClass(PRISTINE_CLASS);
    toggleValidCss(true);
    function toggleValidCss(isValid, validationErrorKey) {
      validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
      element.removeClass((isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey).addClass((isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);
    }
    form.$addControl = function (control) {
      if (control.$name && !form.hasOwnProperty(control.$name)) {
        form[control.$name] = control;
      }
    };
    form.$removeControl = function (control) {
      if (control.$name && form[control.$name] === control) {
        delete form[control.$name];
      }
      forEach(errors, function (queue, validationToken) {
        form.$setValidity(validationToken, true, control);
      });
    };
    form.$setValidity = function (validationToken, isValid, control) {
      var queue = errors[validationToken];
      if (isValid) {
        if (queue) {
          arrayRemove(queue, control);
          if (!queue.length) {
            invalidCount--;
            if (!invalidCount) {
              toggleValidCss(isValid);
              form.$valid = true;
              form.$invalid = false;
            }
            errors[validationToken] = false;
            toggleValidCss(true, validationToken);
            parentForm.$setValidity(validationToken, true, form);
          }
        }
      } else {
        if (!invalidCount) {
          toggleValidCss(isValid);
        }
        if (queue) {
          if (includes(queue, control))
            return;
        } else {
          errors[validationToken] = queue = [];
          invalidCount++;
          toggleValidCss(false, validationToken);
          parentForm.$setValidity(validationToken, false, form);
        }
        queue.push(control);
        form.$valid = false;
        form.$invalid = true;
      }
    };
    form.$setDirty = function () {
      element.removeClass(PRISTINE_CLASS).addClass(DIRTY_CLASS);
      form.$dirty = true;
      form.$pristine = false;
      parentForm.$setDirty();
    };
  }
  var formDirectiveFactory = function (isNgForm) {
    return [
      '$timeout',
      function ($timeout) {
        var formDirective = {
            name: 'form',
            restrict: 'E',
            controller: FormController,
            compile: function () {
              return {
                pre: function (scope, formElement, attr, controller) {
                  if (!attr.action) {
                    var preventDefaultListener = function (event) {
                      event.preventDefault ? event.preventDefault() : event.returnValue = false;
                    };
                    addEventListenerFn(formElement[0], 'submit', preventDefaultListener);
                    formElement.bind('$destroy', function () {
                      $timeout(function () {
                        removeEventListenerFn(formElement[0], 'submit', preventDefaultListener);
                      }, 0, false);
                    });
                  }
                  var parentFormCtrl = formElement.parent().controller('form'), alias = attr.name || attr.ngForm;
                  if (alias) {
                    scope[alias] = controller;
                  }
                  if (parentFormCtrl) {
                    formElement.bind('$destroy', function () {
                      parentFormCtrl.$removeControl(controller);
                      if (alias) {
                        scope[alias] = undefined;
                      }
                      extend(controller, nullFormCtrl);
                    });
                  }
                }
              };
            }
          };
        return isNgForm ? extend(copy(formDirective), { restrict: 'EAC' }) : formDirective;
      }
    ];
  };
  var formDirective = formDirectiveFactory();
  var ngFormDirective = formDirectiveFactory(true);
  var URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/;
  var EMAIL_REGEXP = /^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,4}$/;
  var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/;
  var inputType = {
      'text': textInputType,
      'number': numberInputType,
      'url': urlInputType,
      'email': emailInputType,
      'radio': radioInputType,
      'checkbox': checkboxInputType,
      'hidden': noop,
      'button': noop,
      'submit': noop,
      'reset': noop
    };
  function isEmpty(value) {
    return isUndefined(value) || value === '' || value === null || value !== value;
  }
  function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    var listener = function () {
      var value = trim(element.val());
      if (ctrl.$viewValue !== value) {
        scope.$apply(function () {
          ctrl.$setViewValue(value);
        });
      }
    };
    if ($sniffer.hasEvent('input')) {
      element.bind('input', listener);
    } else {
      var timeout;
      var deferListener = function () {
        if (!timeout) {
          timeout = $browser.defer(function () {
            listener();
            timeout = null;
          });
        }
      };
      element.bind('keydown', function (event) {
        var key = event.keyCode;
        if (key === 91 || 15 < key && key < 19 || 37 <= key && key <= 40)
          return;
        deferListener();
      });
      element.bind('change', listener);
      if ($sniffer.hasEvent('paste')) {
        element.bind('paste cut', deferListener);
      }
    }
    ctrl.$render = function () {
      element.val(isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue);
    };
    var pattern = attr.ngPattern, patternValidator;
    var validate = function (regexp, value) {
      if (isEmpty(value) || regexp.test(value)) {
        ctrl.$setValidity('pattern', true);
        return value;
      } else {
        ctrl.$setValidity('pattern', false);
        return undefined;
      }
    };
    if (pattern) {
      if (pattern.match(/^\/(.*)\/$/)) {
        pattern = new RegExp(pattern.substr(1, pattern.length - 2));
        patternValidator = function (value) {
          return validate(pattern, value);
        };
      } else {
        patternValidator = function (value) {
          var patternObj = scope.$eval(pattern);
          if (!patternObj || !patternObj.test) {
            throw new Error('Expected ' + pattern + ' to be a RegExp but was ' + patternObj);
          }
          return validate(patternObj, value);
        };
      }
      ctrl.$formatters.push(patternValidator);
      ctrl.$parsers.push(patternValidator);
    }
    if (attr.ngMinlength) {
      var minlength = int(attr.ngMinlength);
      var minLengthValidator = function (value) {
        if (!isEmpty(value) && value.length < minlength) {
          ctrl.$setValidity('minlength', false);
          return undefined;
        } else {
          ctrl.$setValidity('minlength', true);
          return value;
        }
      };
      ctrl.$parsers.push(minLengthValidator);
      ctrl.$formatters.push(minLengthValidator);
    }
    if (attr.ngMaxlength) {
      var maxlength = int(attr.ngMaxlength);
      var maxLengthValidator = function (value) {
        if (!isEmpty(value) && value.length > maxlength) {
          ctrl.$setValidity('maxlength', false);
          return undefined;
        } else {
          ctrl.$setValidity('maxlength', true);
          return value;
        }
      };
      ctrl.$parsers.push(maxLengthValidator);
      ctrl.$formatters.push(maxLengthValidator);
    }
  }
  function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    textInputType(scope, element, attr, ctrl, $sniffer, $browser);
    ctrl.$parsers.push(function (value) {
      var empty = isEmpty(value);
      if (empty || NUMBER_REGEXP.test(value)) {
        ctrl.$setValidity('number', true);
        return value === '' ? null : empty ? value : parseFloat(value);
      } else {
        ctrl.$setValidity('number', false);
        return undefined;
      }
    });
    ctrl.$formatters.push(function (value) {
      return isEmpty(value) ? '' : '' + value;
    });
    if (attr.min) {
      var min = parseFloat(attr.min);
      var minValidator = function (value) {
        if (!isEmpty(value) && value < min) {
          ctrl.$setValidity('min', false);
          return undefined;
        } else {
          ctrl.$setValidity('min', true);
          return value;
        }
      };
      ctrl.$parsers.push(minValidator);
      ctrl.$formatters.push(minValidator);
    }
    if (attr.max) {
      var max = parseFloat(attr.max);
      var maxValidator = function (value) {
        if (!isEmpty(value) && value > max) {
          ctrl.$setValidity('max', false);
          return undefined;
        } else {
          ctrl.$setValidity('max', true);
          return value;
        }
      };
      ctrl.$parsers.push(maxValidator);
      ctrl.$formatters.push(maxValidator);
    }
    ctrl.$formatters.push(function (value) {
      if (isEmpty(value) || isNumber(value)) {
        ctrl.$setValidity('number', true);
        return value;
      } else {
        ctrl.$setValidity('number', false);
        return undefined;
      }
    });
  }
  function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    textInputType(scope, element, attr, ctrl, $sniffer, $browser);
    var urlValidator = function (value) {
      if (isEmpty(value) || URL_REGEXP.test(value)) {
        ctrl.$setValidity('url', true);
        return value;
      } else {
        ctrl.$setValidity('url', false);
        return undefined;
      }
    };
    ctrl.$formatters.push(urlValidator);
    ctrl.$parsers.push(urlValidator);
  }
  function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    textInputType(scope, element, attr, ctrl, $sniffer, $browser);
    var emailValidator = function (value) {
      if (isEmpty(value) || EMAIL_REGEXP.test(value)) {
        ctrl.$setValidity('email', true);
        return value;
      } else {
        ctrl.$setValidity('email', false);
        return undefined;
      }
    };
    ctrl.$formatters.push(emailValidator);
    ctrl.$parsers.push(emailValidator);
  }
  function radioInputType(scope, element, attr, ctrl) {
    if (isUndefined(attr.name)) {
      element.attr('name', nextUid());
    }
    element.bind('click', function () {
      if (element[0].checked) {
        scope.$apply(function () {
          ctrl.$setViewValue(attr.value);
        });
      }
    });
    ctrl.$render = function () {
      var value = attr.value;
      element[0].checked = value == ctrl.$viewValue;
    };
    attr.$observe('value', ctrl.$render);
  }
  function checkboxInputType(scope, element, attr, ctrl) {
    var trueValue = attr.ngTrueValue, falseValue = attr.ngFalseValue;
    if (!isString(trueValue))
      trueValue = true;
    if (!isString(falseValue))
      falseValue = false;
    element.bind('click', function () {
      scope.$apply(function () {
        ctrl.$setViewValue(element[0].checked);
      });
    });
    ctrl.$render = function () {
      element[0].checked = ctrl.$viewValue;
    };
    ctrl.$formatters.push(function (value) {
      return value === trueValue;
    });
    ctrl.$parsers.push(function (value) {
      return value ? trueValue : falseValue;
    });
  }
  var inputDirective = [
      '$browser',
      '$sniffer',
      function ($browser, $sniffer) {
        return {
          restrict: 'E',
          require: '?ngModel',
          link: function (scope, element, attr, ctrl) {
            if (ctrl) {
              (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrl, $sniffer, $browser);
            }
          }
        };
      }
    ];
  var VALID_CLASS = 'ng-valid', INVALID_CLASS = 'ng-invalid', PRISTINE_CLASS = 'ng-pristine', DIRTY_CLASS = 'ng-dirty';
  var NgModelController = [
      '$scope',
      '$exceptionHandler',
      '$attrs',
      '$element',
      '$parse',
      function ($scope, $exceptionHandler, $attr, $element, $parse) {
        this.$viewValue = Number.NaN;
        this.$modelValue = Number.NaN;
        this.$parsers = [];
        this.$formatters = [];
        this.$viewChangeListeners = [];
        this.$pristine = true;
        this.$dirty = false;
        this.$valid = true;
        this.$invalid = false;
        this.$name = $attr.name;
        var ngModelGet = $parse($attr.ngModel), ngModelSet = ngModelGet.assign;
        if (!ngModelSet) {
          throw Error(NON_ASSIGNABLE_MODEL_EXPRESSION + $attr.ngModel + ' (' + startingTag($element) + ')');
        }
        this.$render = noop;
        var parentForm = $element.inheritedData('$formController') || nullFormCtrl, invalidCount = 0, $error = this.$error = {};
        $element.addClass(PRISTINE_CLASS);
        toggleValidCss(true);
        function toggleValidCss(isValid, validationErrorKey) {
          validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
          $element.removeClass((isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey).addClass((isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);
        }
        this.$setValidity = function (validationErrorKey, isValid) {
          if ($error[validationErrorKey] === !isValid)
            return;
          if (isValid) {
            if ($error[validationErrorKey])
              invalidCount--;
            if (!invalidCount) {
              toggleValidCss(true);
              this.$valid = true;
              this.$invalid = false;
            }
          } else {
            toggleValidCss(false);
            this.$invalid = true;
            this.$valid = false;
            invalidCount++;
          }
          $error[validationErrorKey] = !isValid;
          toggleValidCss(isValid, validationErrorKey);
          parentForm.$setValidity(validationErrorKey, isValid, this);
        };
        this.$setViewValue = function (value) {
          this.$viewValue = value;
          if (this.$pristine) {
            this.$dirty = true;
            this.$pristine = false;
            $element.removeClass(PRISTINE_CLASS).addClass(DIRTY_CLASS);
            parentForm.$setDirty();
          }
          forEach(this.$parsers, function (fn) {
            value = fn(value);
          });
          if (this.$modelValue !== value) {
            this.$modelValue = value;
            ngModelSet($scope, value);
            forEach(this.$viewChangeListeners, function (listener) {
              try {
                listener();
              } catch (e) {
                $exceptionHandler(e);
              }
            });
          }
        };
        var ctrl = this;
        $scope.$watch(function ngModelWatch() {
          var value = ngModelGet($scope);
          if (ctrl.$modelValue !== value) {
            var formatters = ctrl.$formatters, idx = formatters.length;
            ctrl.$modelValue = value;
            while (idx--) {
              value = formatters[idx](value);
            }
            if (ctrl.$viewValue !== value) {
              ctrl.$viewValue = value;
              ctrl.$render();
            }
          }
        });
      }
    ];
  var ngModelDirective = function () {
    return {
      require: [
        'ngModel',
        '^?form'
      ],
      controller: NgModelController,
      link: function (scope, element, attr, ctrls) {
        var modelCtrl = ctrls[0], formCtrl = ctrls[1] || nullFormCtrl;
        formCtrl.$addControl(modelCtrl);
        element.bind('$destroy', function () {
          formCtrl.$removeControl(modelCtrl);
        });
      }
    };
  };
  var ngChangeDirective = valueFn({
      require: 'ngModel',
      link: function (scope, element, attr, ctrl) {
        ctrl.$viewChangeListeners.push(function () {
          scope.$eval(attr.ngChange);
        });
      }
    });
  var requiredDirective = function () {
    return {
      require: '?ngModel',
      link: function (scope, elm, attr, ctrl) {
        if (!ctrl)
          return;
        attr.required = true;
        var validator = function (value) {
          if (attr.required && (isEmpty(value) || value === false)) {
            ctrl.$setValidity('required', false);
            return;
          } else {
            ctrl.$setValidity('required', true);
            return value;
          }
        };
        ctrl.$formatters.push(validator);
        ctrl.$parsers.unshift(validator);
        attr.$observe('required', function () {
          validator(ctrl.$viewValue);
        });
      }
    };
  };
  var ngListDirective = function () {
    return {
      require: 'ngModel',
      link: function (scope, element, attr, ctrl) {
        var match = /\/(.*)\//.exec(attr.ngList), separator = match && new RegExp(match[1]) || attr.ngList || ',';
        var parse = function (viewValue) {
          var list = [];
          if (viewValue) {
            forEach(viewValue.split(separator), function (value) {
              if (value)
                list.push(trim(value));
            });
          }
          return list;
        };
        ctrl.$parsers.push(parse);
        ctrl.$formatters.push(function (value) {
          if (isArray(value)) {
            return value.join(', ');
          }
          return undefined;
        });
      }
    };
  };
  var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
  var ngValueDirective = function () {
    return {
      priority: 100,
      compile: function (tpl, tplAttr) {
        if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
          return function (scope, elm, attr) {
            attr.$set('value', scope.$eval(attr.ngValue));
          };
        } else {
          return function (scope, elm, attr) {
            scope.$watch(attr.ngValue, function valueWatchAction(value) {
              attr.$set('value', value, false);
            });
          };
        }
      }
    };
  };
  var ngBindDirective = ngDirective(function (scope, element, attr) {
      element.addClass('ng-binding').data('$binding', attr.ngBind);
      scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
        element.text(value == undefined ? '' : value);
      });
    });
  var ngBindTemplateDirective = [
      '$interpolate',
      function ($interpolate) {
        return function (scope, element, attr) {
          var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
          element.addClass('ng-binding').data('$binding', interpolateFn);
          attr.$observe('ngBindTemplate', function (value) {
            element.text(value);
          });
        };
      }
    ];
  var ngBindHtmlUnsafeDirective = [function () {
        return function (scope, element, attr) {
          element.addClass('ng-binding').data('$binding', attr.ngBindHtmlUnsafe);
          scope.$watch(attr.ngBindHtmlUnsafe, function ngBindHtmlUnsafeWatchAction(value) {
            element.html(value || '');
          });
        };
      }];
  function classDirective(name, selector) {
    name = 'ngClass' + name;
    return ngDirective(function (scope, element, attr) {
      var oldVal = undefined;
      scope.$watch(attr[name], ngClassWatchAction, true);
      attr.$observe('class', function (value) {
        var ngClass = scope.$eval(attr[name]);
        ngClassWatchAction(ngClass, ngClass);
      });
      if (name !== 'ngClass') {
        scope.$watch('$index', function ($index, old$index) {
          var mod = $index & 1;
          if (mod !== old$index & 1) {
            if (mod === selector) {
              addClass(scope.$eval(attr[name]));
            } else {
              removeClass(scope.$eval(attr[name]));
            }
          }
        });
      }
      function ngClassWatchAction(newVal) {
        if (selector === true || scope.$index % 2 === selector) {
          if (oldVal && !equals(newVal, oldVal)) {
            removeClass(oldVal);
          }
          addClass(newVal);
        }
        oldVal = copy(newVal);
      }
      function removeClass(classVal) {
        if (isObject(classVal) && !isArray(classVal)) {
          classVal = map(classVal, function (v, k) {
            if (v)
              return k;
          });
        }
        element.removeClass(isArray(classVal) ? classVal.join(' ') : classVal);
      }
      function addClass(classVal) {
        if (isObject(classVal) && !isArray(classVal)) {
          classVal = map(classVal, function (v, k) {
            if (v)
              return k;
          });
        }
        if (classVal) {
          element.addClass(isArray(classVal) ? classVal.join(' ') : classVal);
        }
      }
    });
  }
  var ngClassDirective = classDirective('', true);
  var ngClassOddDirective = classDirective('Odd', 0);
  var ngClassEvenDirective = classDirective('Even', 1);
  var ngCloakDirective = ngDirective({
      compile: function (element, attr) {
        attr.$set('ngCloak', undefined);
        element.removeClass('ng-cloak');
      }
    });
  var ngControllerDirective = [function () {
        return {
          scope: true,
          controller: '@'
        };
      }];
  var ngCspDirective = [
      '$sniffer',
      function ($sniffer) {
        return {
          priority: 1000,
          compile: function () {
            $sniffer.csp = true;
          }
        };
      }
    ];
  var ngEventDirectives = {};
  forEach('click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave'.split(' '), function (name) {
    var directiveName = directiveNormalize('ng-' + name);
    ngEventDirectives[directiveName] = [
      '$parse',
      function ($parse) {
        return function (scope, element, attr) {
          var fn = $parse(attr[directiveName]);
          element.bind(lowercase(name), function (event) {
            scope.$apply(function () {
              fn(scope, { $event: event });
            });
          });
        };
      }
    ];
  });
  var ngSubmitDirective = ngDirective(function (scope, element, attrs) {
      element.bind('submit', function () {
        scope.$apply(attrs.ngSubmit);
      });
    });
  var ngIncludeDirective = [
      '$http',
      '$templateCache',
      '$anchorScroll',
      '$compile',
      function ($http, $templateCache, $anchorScroll, $compile) {
        return {
          restrict: 'ECA',
          terminal: true,
          compile: function (element, attr) {
            var srcExp = attr.ngInclude || attr.src, onloadExp = attr.onload || '', autoScrollExp = attr.autoscroll;
            return function (scope, element) {
              var changeCounter = 0, childScope;
              var clearContent = function () {
                if (childScope) {
                  childScope.$destroy();
                  childScope = null;
                }
                element.html('');
              };
              scope.$watch(srcExp, function ngIncludeWatchAction(src) {
                var thisChangeId = ++changeCounter;
                if (src) {
                  $http.get(src, { cache: $templateCache }).success(function (response) {
                    if (thisChangeId !== changeCounter)
                      return;
                    if (childScope)
                      childScope.$destroy();
                    childScope = scope.$new();
                    element.html(response);
                    $compile(element.contents())(childScope);
                    if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                      $anchorScroll();
                    }
                    childScope.$emit('$includeContentLoaded');
                    scope.$eval(onloadExp);
                  }).error(function () {
                    if (thisChangeId === changeCounter)
                      clearContent();
                  });
                } else
                  clearContent();
              });
            };
          }
        };
      }
    ];
  var ngInitDirective = ngDirective({
      compile: function () {
        return {
          pre: function (scope, element, attrs) {
            scope.$eval(attrs.ngInit);
          }
        };
      }
    });
  var ngNonBindableDirective = ngDirective({
      terminal: true,
      priority: 1000
    });
  var ngPluralizeDirective = [
      '$locale',
      '$interpolate',
      function ($locale, $interpolate) {
        var BRACE = /{}/g;
        return {
          restrict: 'EA',
          link: function (scope, element, attr) {
            var numberExp = attr.count, whenExp = element.attr(attr.$attr.when), offset = attr.offset || 0, whens = scope.$eval(whenExp), whensExpFns = {}, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol();
            forEach(whens, function (expression, key) {
              whensExpFns[key] = $interpolate(expression.replace(BRACE, startSymbol + numberExp + '-' + offset + endSymbol));
            });
            scope.$watch(function ngPluralizeWatch() {
              var value = parseFloat(scope.$eval(numberExp));
              if (!isNaN(value)) {
                if (!(value in whens))
                  value = $locale.pluralCat(value - offset);
                return whensExpFns[value](scope, element, true);
              } else {
                return '';
              }
            }, function ngPluralizeWatchAction(newVal) {
              element.text(newVal);
            });
          }
        };
      }
    ];
  var ngRepeatDirective = ngDirective({
      transclude: 'element',
      priority: 1000,
      terminal: true,
      compile: function (element, attr, linker) {
        return function (scope, iterStartElement, attr) {
          var expression = attr.ngRepeat;
          var match = expression.match(/^\s*(.+)\s+in\s+(.*)\s*$/), lhs, rhs, valueIdent, keyIdent;
          if (!match) {
            throw Error('Expected ngRepeat in form of \'_item_ in _collection_\' but got \'' + expression + '\'.');
          }
          lhs = match[1];
          rhs = match[2];
          match = lhs.match(/^(?:([\$\w]+)|\(([\$\w]+)\s*,\s*([\$\w]+)\))$/);
          if (!match) {
            throw Error('\'item\' in \'item in collection\' should be identifier or (key, value) but got \'' + lhs + '\'.');
          }
          valueIdent = match[3] || match[1];
          keyIdent = match[2];
          var lastOrder = new HashQueueMap();
          scope.$watch(function ngRepeatWatch(scope) {
            var index, length, collection = scope.$eval(rhs), cursor = iterStartElement, nextOrder = new HashQueueMap(), arrayBound, childScope, key, value, array, last;
            if (!isArray(collection)) {
              array = [];
              for (key in collection) {
                if (collection.hasOwnProperty(key) && key.charAt(0) != '$') {
                  array.push(key);
                }
              }
              array.sort();
            } else {
              array = collection || [];
            }
            arrayBound = array.length - 1;
            for (index = 0, length = array.length; index < length; index++) {
              key = collection === array ? index : array[index];
              value = collection[key];
              last = lastOrder.shift(value);
              if (last) {
                childScope = last.scope;
                nextOrder.push(value, last);
                if (index === last.index) {
                  cursor = last.element;
                } else {
                  last.index = index;
                  cursor.after(last.element);
                  cursor = last.element;
                }
              } else {
                childScope = scope.$new();
              }
              childScope[valueIdent] = value;
              if (keyIdent)
                childScope[keyIdent] = key;
              childScope.$index = index;
              childScope.$first = index === 0;
              childScope.$last = index === arrayBound;
              childScope.$middle = !(childScope.$first || childScope.$last);
              if (!last) {
                linker(childScope, function (clone) {
                  cursor.after(clone);
                  last = {
                    scope: childScope,
                    element: cursor = clone,
                    index: index
                  };
                  nextOrder.push(value, last);
                });
              }
            }
            for (key in lastOrder) {
              if (lastOrder.hasOwnProperty(key)) {
                array = lastOrder[key];
                while (array.length) {
                  value = array.pop();
                  value.element.remove();
                  value.scope.$destroy();
                }
              }
            }
            lastOrder = nextOrder;
          });
        };
      }
    });
  var ngShowDirective = ngDirective(function (scope, element, attr) {
      scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
        element.css('display', toBoolean(value) ? '' : 'none');
      });
    });
  var ngHideDirective = ngDirective(function (scope, element, attr) {
      scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
        element.css('display', toBoolean(value) ? 'none' : '');
      });
    });
  var ngStyleDirective = ngDirective(function (scope, element, attr) {
      scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
        if (oldStyles && newStyles !== oldStyles) {
          forEach(oldStyles, function (val, style) {
            element.css(style, '');
          });
        }
        if (newStyles)
          element.css(newStyles);
      }, true);
    });
  var NG_SWITCH = 'ng-switch';
  var ngSwitchDirective = valueFn({
      restrict: 'EA',
      require: 'ngSwitch',
      controller: [
        '$scope',
        function ngSwitchController() {
          this.cases = {};
        }
      ],
      link: function (scope, element, attr, ctrl) {
        var watchExpr = attr.ngSwitch || attr.on, selectedTransclude, selectedElement, selectedScope;
        scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
          if (selectedElement) {
            selectedScope.$destroy();
            selectedElement.remove();
            selectedElement = selectedScope = null;
          }
          if (selectedTransclude = ctrl.cases['!' + value] || ctrl.cases['?']) {
            scope.$eval(attr.change);
            selectedScope = scope.$new();
            selectedTransclude(selectedScope, function (caseElement) {
              selectedElement = caseElement;
              element.append(caseElement);
            });
          }
        });
      }
    });
  var ngSwitchWhenDirective = ngDirective({
      transclude: 'element',
      priority: 500,
      require: '^ngSwitch',
      compile: function (element, attrs, transclude) {
        return function (scope, element, attr, ctrl) {
          ctrl.cases['!' + attrs.ngSwitchWhen] = transclude;
        };
      }
    });
  var ngSwitchDefaultDirective = ngDirective({
      transclude: 'element',
      priority: 500,
      require: '^ngSwitch',
      compile: function (element, attrs, transclude) {
        return function (scope, element, attr, ctrl) {
          ctrl.cases['?'] = transclude;
        };
      }
    });
  var ngTranscludeDirective = ngDirective({
      controller: [
        '$transclude',
        '$element',
        function ($transclude, $element) {
          $transclude(function (clone) {
            $element.append(clone);
          });
        }
      ]
    });
  var ngViewDirective = [
      '$http',
      '$templateCache',
      '$route',
      '$anchorScroll',
      '$compile',
      '$controller',
      function ($http, $templateCache, $route, $anchorScroll, $compile, $controller) {
        return {
          restrict: 'ECA',
          terminal: true,
          link: function (scope, element, attr) {
            var lastScope, onloadExp = attr.onload || '';
            scope.$on('$routeChangeSuccess', update);
            update();
            function destroyLastScope() {
              if (lastScope) {
                lastScope.$destroy();
                lastScope = null;
              }
            }
            function clearContent() {
              element.html('');
              destroyLastScope();
            }
            function update() {
              var locals = $route.current && $route.current.locals, template = locals && locals.$template;
              if (template) {
                element.html(template);
                destroyLastScope();
                var link = $compile(element.contents()), current = $route.current, controller;
                lastScope = current.scope = scope.$new();
                if (current.controller) {
                  locals.$scope = lastScope;
                  controller = $controller(current.controller, locals);
                  element.children().data('$ngControllerController', controller);
                }
                link(lastScope);
                lastScope.$emit('$viewContentLoaded');
                lastScope.$eval(onloadExp);
                $anchorScroll();
              } else {
                clearContent();
              }
            }
          }
        };
      }
    ];
  var scriptDirective = [
      '$templateCache',
      function ($templateCache) {
        return {
          restrict: 'E',
          terminal: true,
          compile: function (element, attr) {
            if (attr.type == 'text/ng-template') {
              var templateUrl = attr.id, text = element[0].text;
              $templateCache.put(templateUrl, text);
            }
          }
        };
      }
    ];
  var ngOptionsDirective = valueFn({ terminal: true });
  var selectDirective = [
      '$compile',
      '$parse',
      function ($compile, $parse) {
        var NG_OPTIONS_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?(?:\s+group\s+by\s+(.*))?\s+for\s+(?:([\$\w][\$\w\d]*)|(?:\(\s*([\$\w][\$\w\d]*)\s*,\s*([\$\w][\$\w\d]*)\s*\)))\s+in\s+(.*)$/, nullModelCtrl = { $setViewValue: noop };
        return {
          restrict: 'E',
          require: [
            'select',
            '?ngModel'
          ],
          controller: [
            '$element',
            '$scope',
            '$attrs',
            function ($element, $scope, $attrs) {
              var self = this, optionsMap = {}, ngModelCtrl = nullModelCtrl, nullOption, unknownOption;
              self.databound = $attrs.ngModel;
              self.init = function (ngModelCtrl_, nullOption_, unknownOption_) {
                ngModelCtrl = ngModelCtrl_;
                nullOption = nullOption_;
                unknownOption = unknownOption_;
              };
              self.addOption = function (value) {
                optionsMap[value] = true;
                if (ngModelCtrl.$viewValue == value) {
                  $element.val(value);
                  if (unknownOption.parent())
                    unknownOption.remove();
                }
              };
              self.removeOption = function (value) {
                if (this.hasOption(value)) {
                  delete optionsMap[value];
                  if (ngModelCtrl.$viewValue == value) {
                    this.renderUnknownOption(value);
                  }
                }
              };
              self.renderUnknownOption = function (val) {
                var unknownVal = '? ' + hashKey(val) + ' ?';
                unknownOption.val(unknownVal);
                $element.prepend(unknownOption);
                $element.val(unknownVal);
                unknownOption.prop('selected', true);
              };
              self.hasOption = function (value) {
                return optionsMap.hasOwnProperty(value);
              };
              $scope.$on('$destroy', function () {
                self.renderUnknownOption = noop;
              });
            }
          ],
          link: function (scope, element, attr, ctrls) {
            if (!ctrls[1])
              return;
            var selectCtrl = ctrls[0], ngModelCtrl = ctrls[1], multiple = attr.multiple, optionsExp = attr.ngOptions, nullOption = false, emptyOption, optionTemplate = jqLite(document.createElement('option')), optGroupTemplate = jqLite(document.createElement('optgroup')), unknownOption = optionTemplate.clone();
            for (var i = 0, children = element.children(), ii = children.length; i < ii; i++) {
              if (children[i].value == '') {
                emptyOption = nullOption = children.eq(i);
                break;
              }
            }
            selectCtrl.init(ngModelCtrl, nullOption, unknownOption);
            if (multiple && (attr.required || attr.ngRequired)) {
              var requiredValidator = function (value) {
                ngModelCtrl.$setValidity('required', !attr.required || value && value.length);
                return value;
              };
              ngModelCtrl.$parsers.push(requiredValidator);
              ngModelCtrl.$formatters.unshift(requiredValidator);
              attr.$observe('required', function () {
                requiredValidator(ngModelCtrl.$viewValue);
              });
            }
            if (optionsExp)
              Options(scope, element, ngModelCtrl);
            else if (multiple)
              Multiple(scope, element, ngModelCtrl);
            else
              Single(scope, element, ngModelCtrl, selectCtrl);
            function Single(scope, selectElement, ngModelCtrl, selectCtrl) {
              ngModelCtrl.$render = function () {
                var viewValue = ngModelCtrl.$viewValue;
                if (selectCtrl.hasOption(viewValue)) {
                  if (unknownOption.parent())
                    unknownOption.remove();
                  selectElement.val(viewValue);
                  if (viewValue === '')
                    emptyOption.prop('selected', true);
                } else {
                  if (isUndefined(viewValue) && emptyOption) {
                    selectElement.val('');
                  } else {
                    selectCtrl.renderUnknownOption(viewValue);
                  }
                }
              };
              selectElement.bind('change', function () {
                scope.$apply(function () {
                  if (unknownOption.parent())
                    unknownOption.remove();
                  ngModelCtrl.$setViewValue(selectElement.val());
                });
              });
            }
            function Multiple(scope, selectElement, ctrl) {
              var lastView;
              ctrl.$render = function () {
                var items = new HashMap(ctrl.$viewValue);
                forEach(selectElement.find('option'), function (option) {
                  option.selected = isDefined(items.get(option.value));
                });
              };
              scope.$watch(function selectMultipleWatch() {
                if (!equals(lastView, ctrl.$viewValue)) {
                  lastView = copy(ctrl.$viewValue);
                  ctrl.$render();
                }
              });
              selectElement.bind('change', function () {
                scope.$apply(function () {
                  var array = [];
                  forEach(selectElement.find('option'), function (option) {
                    if (option.selected) {
                      array.push(option.value);
                    }
                  });
                  ctrl.$setViewValue(array);
                });
              });
            }
            function Options(scope, selectElement, ctrl) {
              var match;
              if (!(match = optionsExp.match(NG_OPTIONS_REGEXP))) {
                throw Error('Expected ngOptions in form of \'_select_ (as _label_)? for (_key_,)?_value_ in _collection_\'' + ' but got \'' + optionsExp + '\'.');
              }
              var displayFn = $parse(match[2] || match[1]), valueName = match[4] || match[6], keyName = match[5], groupByFn = $parse(match[3] || ''), valueFn = $parse(match[2] ? match[1] : valueName), valuesFn = $parse(match[7]), optionGroupsCache = [[{
                      element: selectElement,
                      label: ''
                    }]];
              if (nullOption) {
                $compile(nullOption)(scope);
                nullOption.removeClass('ng-scope');
                nullOption.remove();
              }
              selectElement.html('');
              selectElement.bind('change', function () {
                scope.$apply(function () {
                  var optionGroup, collection = valuesFn(scope) || [], locals = {}, key, value, optionElement, index, groupIndex, length, groupLength;
                  if (multiple) {
                    value = [];
                    for (groupIndex = 0, groupLength = optionGroupsCache.length; groupIndex < groupLength; groupIndex++) {
                      optionGroup = optionGroupsCache[groupIndex];
                      for (index = 1, length = optionGroup.length; index < length; index++) {
                        if ((optionElement = optionGroup[index].element)[0].selected) {
                          key = optionElement.val();
                          if (keyName)
                            locals[keyName] = key;
                          locals[valueName] = collection[key];
                          value.push(valueFn(scope, locals));
                        }
                      }
                    }
                  } else {
                    key = selectElement.val();
                    if (key == '?') {
                      value = undefined;
                    } else if (key == '') {
                      value = null;
                    } else {
                      locals[valueName] = collection[key];
                      if (keyName)
                        locals[keyName] = key;
                      value = valueFn(scope, locals);
                    }
                  }
                  ctrl.$setViewValue(value);
                });
              });
              ctrl.$render = render;
              scope.$watch(render);
              function render() {
                var optionGroups = { '': [] }, optionGroupNames = [''], optionGroupName, optionGroup, option, existingParent, existingOptions, existingOption, modelValue = ctrl.$modelValue, values = valuesFn(scope) || [], keys = keyName ? sortedKeys(values) : values, groupLength, length, groupIndex, index, locals = {}, selected, selectedSet = false, lastElement, element, label;
                if (multiple) {
                  selectedSet = new HashMap(modelValue);
                }
                for (index = 0; length = keys.length, index < length; index++) {
                  locals[valueName] = values[keyName ? locals[keyName] = keys[index] : index];
                  optionGroupName = groupByFn(scope, locals) || '';
                  if (!(optionGroup = optionGroups[optionGroupName])) {
                    optionGroup = optionGroups[optionGroupName] = [];
                    optionGroupNames.push(optionGroupName);
                  }
                  if (multiple) {
                    selected = selectedSet.remove(valueFn(scope, locals)) != undefined;
                  } else {
                    selected = modelValue === valueFn(scope, locals);
                    selectedSet = selectedSet || selected;
                  }
                  label = displayFn(scope, locals);
                  label = label === undefined ? '' : label;
                  optionGroup.push({
                    id: keyName ? keys[index] : index,
                    label: label,
                    selected: selected
                  });
                }
                if (!multiple) {
                  if (nullOption || modelValue === null) {
                    optionGroups[''].unshift({
                      id: '',
                      label: '',
                      selected: !selectedSet
                    });
                  } else if (!selectedSet) {
                    optionGroups[''].unshift({
                      id: '?',
                      label: '',
                      selected: true
                    });
                  }
                }
                for (groupIndex = 0, groupLength = optionGroupNames.length; groupIndex < groupLength; groupIndex++) {
                  optionGroupName = optionGroupNames[groupIndex];
                  optionGroup = optionGroups[optionGroupName];
                  if (optionGroupsCache.length <= groupIndex) {
                    existingParent = {
                      element: optGroupTemplate.clone().attr('label', optionGroupName),
                      label: optionGroup.label
                    };
                    existingOptions = [existingParent];
                    optionGroupsCache.push(existingOptions);
                    selectElement.append(existingParent.element);
                  } else {
                    existingOptions = optionGroupsCache[groupIndex];
                    existingParent = existingOptions[0];
                    if (existingParent.label != optionGroupName) {
                      existingParent.element.attr('label', existingParent.label = optionGroupName);
                    }
                  }
                  lastElement = null;
                  for (index = 0, length = optionGroup.length; index < length; index++) {
                    option = optionGroup[index];
                    if (existingOption = existingOptions[index + 1]) {
                      lastElement = existingOption.element;
                      if (existingOption.label !== option.label) {
                        lastElement.text(existingOption.label = option.label);
                      }
                      if (existingOption.id !== option.id) {
                        lastElement.val(existingOption.id = option.id);
                      }
                      if (lastElement[0].selected !== option.selected) {
                        lastElement.prop('selected', existingOption.selected = option.selected);
                      }
                    } else {
                      if (option.id === '' && nullOption) {
                        element = nullOption;
                      } else {
                        (element = optionTemplate.clone()).val(option.id).attr('selected', option.selected).text(option.label);
                      }
                      existingOptions.push(existingOption = {
                        element: element,
                        label: option.label,
                        id: option.id,
                        selected: option.selected
                      });
                      if (lastElement) {
                        lastElement.after(element);
                      } else {
                        existingParent.element.append(element);
                      }
                      lastElement = element;
                    }
                  }
                  index++;
                  while (existingOptions.length > index) {
                    existingOptions.pop().element.remove();
                  }
                }
                while (optionGroupsCache.length > groupIndex) {
                  optionGroupsCache.pop()[0].element.remove();
                }
              }
            }
          }
        };
      }
    ];
  var optionDirective = [
      '$interpolate',
      function ($interpolate) {
        var nullSelectCtrl = {
            addOption: noop,
            removeOption: noop
          };
        return {
          restrict: 'E',
          priority: 100,
          compile: function (element, attr) {
            if (isUndefined(attr.value)) {
              var interpolateFn = $interpolate(element.text(), true);
              if (!interpolateFn) {
                attr.$set('value', element.text());
              }
            }
            return function (scope, element, attr) {
              var selectCtrlName = '$selectController', parent = element.parent(), selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
              if (selectCtrl && selectCtrl.databound) {
                element.prop('selected', false);
              } else {
                selectCtrl = nullSelectCtrl;
              }
              if (interpolateFn) {
                scope.$watch(interpolateFn, function interpolateWatchAction(newVal, oldVal) {
                  attr.$set('value', newVal);
                  if (newVal !== oldVal)
                    selectCtrl.removeOption(oldVal);
                  selectCtrl.addOption(newVal);
                });
              } else {
                selectCtrl.addOption(attr.value);
              }
              element.bind('$destroy', function () {
                selectCtrl.removeOption(attr.value);
              });
            };
          }
        };
      }
    ];
  var styleDirective = valueFn({
      restrict: 'E',
      terminal: true
    });
  bindJQuery();
  publishExternalAPI(angular);
  jqLite(document).ready(function () {
    angularInit(document, bootstrap);
  });
}(window, document));
angular.element(document).find('head').append('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak{display:none;}ng\\:form{display:block;}</style>');
(function () {
  var root = this;
  var previousUnderscore = root._;
  var breaker = {};
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
  var push = ArrayProto.push, slice = ArrayProto.slice, concat = ArrayProto.concat, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty;
  var nativeForEach = ArrayProto.forEach, nativeMap = ArrayProto.map, nativeReduce = ArrayProto.reduce, nativeReduceRight = ArrayProto.reduceRight, nativeFilter = ArrayProto.filter, nativeEvery = ArrayProto.every, nativeSome = ArrayProto.some, nativeIndexOf = ArrayProto.indexOf, nativeLastIndexOf = ArrayProto.lastIndexOf, nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeBind = FuncProto.bind;
  var _ = function (obj) {
    if (obj instanceof _)
      return obj;
    if (!(this instanceof _))
      return new _(obj);
    this._wrapped = obj;
  };
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }
  _.VERSION = '1.6.0';
  var each = _.each = _.forEach = function (obj, iterator, context) {
      if (obj == null)
        return obj;
      if (nativeForEach && obj.forEach === nativeForEach) {
        obj.forEach(iterator, context);
      } else if (obj.length === +obj.length) {
        for (var i = 0, length = obj.length; i < length; i++) {
          if (iterator.call(context, obj[i], i, obj) === breaker)
            return;
        }
      } else {
        var keys = _.keys(obj);
        for (var i = 0, length = keys.length; i < length; i++) {
          if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker)
            return;
        }
      }
      return obj;
    };
  _.map = _.collect = function (obj, iterator, context) {
    var results = [];
    if (obj == null)
      return results;
    if (nativeMap && obj.map === nativeMap)
      return obj.map(iterator, context);
    each(obj, function (value, index, list) {
      results.push(iterator.call(context, value, index, list));
    });
    return results;
  };
  var reduceError = 'Reduce of empty array with no initial value';
  _.reduce = _.foldl = _.inject = function (obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null)
      obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context)
        iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function (value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial)
      throw new TypeError(reduceError);
    return memo;
  };
  _.reduceRight = _.foldr = function (obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null)
      obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context)
        iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function (value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial)
      throw new TypeError(reduceError);
    return memo;
  };
  _.find = _.detect = function (obj, predicate, context) {
    var result;
    any(obj, function (value, index, list) {
      if (predicate.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };
  _.filter = _.select = function (obj, predicate, context) {
    var results = [];
    if (obj == null)
      return results;
    if (nativeFilter && obj.filter === nativeFilter)
      return obj.filter(predicate, context);
    each(obj, function (value, index, list) {
      if (predicate.call(context, value, index, list))
        results.push(value);
    });
    return results;
  };
  _.reject = function (obj, predicate, context) {
    return _.filter(obj, function (value, index, list) {
      return !predicate.call(context, value, index, list);
    }, context);
  };
  _.every = _.all = function (obj, predicate, context) {
    predicate || (predicate = _.identity);
    var result = true;
    if (obj == null)
      return result;
    if (nativeEvery && obj.every === nativeEvery)
      return obj.every(predicate, context);
    each(obj, function (value, index, list) {
      if (!(result = result && predicate.call(context, value, index, list)))
        return breaker;
    });
    return !!result;
  };
  var any = _.some = _.any = function (obj, predicate, context) {
      predicate || (predicate = _.identity);
      var result = false;
      if (obj == null)
        return result;
      if (nativeSome && obj.some === nativeSome)
        return obj.some(predicate, context);
      each(obj, function (value, index, list) {
        if (result || (result = predicate.call(context, value, index, list)))
          return breaker;
      });
      return !!result;
    };
  _.contains = _.include = function (obj, target) {
    if (obj == null)
      return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf)
      return obj.indexOf(target) != -1;
    return any(obj, function (value) {
      return value === target;
    });
  };
  _.invoke = function (obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function (value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };
  _.pluck = function (obj, key) {
    return _.map(obj, _.property(key));
  };
  _.where = function (obj, attrs) {
    return _.filter(obj, _.matches(attrs));
  };
  _.findWhere = function (obj, attrs) {
    return _.find(obj, _.matches(attrs));
  };
  _.max = function (obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    var result = -Infinity, lastComputed = -Infinity;
    each(obj, function (value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      if (computed > lastComputed) {
        result = value;
        lastComputed = computed;
      }
    });
    return result;
  };
  _.min = function (obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    var result = Infinity, lastComputed = Infinity;
    each(obj, function (value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      if (computed < lastComputed) {
        result = value;
        lastComputed = computed;
      }
    });
    return result;
  };
  _.shuffle = function (obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function (value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };
  _.sample = function (obj, n, guard) {
    if (n == null || guard) {
      if (obj.length !== +obj.length)
        obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };
  var lookupIterator = function (value) {
    if (value == null)
      return _.identity;
    if (_.isFunction(value))
      return value;
    return _.property(value);
  };
  _.sortBy = function (obj, iterator, context) {
    iterator = lookupIterator(iterator);
    return _.pluck(_.map(obj, function (value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iterator.call(context, value, index, list)
      };
    }).sort(function (left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0)
          return 1;
        if (a < b || b === void 0)
          return -1;
      }
      return left.index - right.index;
    }), 'value');
  };
  var group = function (behavior) {
    return function (obj, iterator, context) {
      var result = {};
      iterator = lookupIterator(iterator);
      each(obj, function (value, index) {
        var key = iterator.call(context, value, index, obj);
        behavior(result, key, value);
      });
      return result;
    };
  };
  _.groupBy = group(function (result, key, value) {
    _.has(result, key) ? result[key].push(value) : result[key] = [value];
  });
  _.indexBy = group(function (result, key, value) {
    result[key] = value;
  });
  _.countBy = group(function (result, key) {
    _.has(result, key) ? result[key]++ : result[key] = 1;
  });
  _.sortedIndex = function (array, obj, iterator, context) {
    iterator = lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = low + high >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };
  _.toArray = function (obj) {
    if (!obj)
      return [];
    if (_.isArray(obj))
      return slice.call(obj);
    if (obj.length === +obj.length)
      return _.map(obj, _.identity);
    return _.values(obj);
  };
  _.size = function (obj) {
    if (obj == null)
      return 0;
    return obj.length === +obj.length ? obj.length : _.keys(obj).length;
  };
  _.first = _.head = _.take = function (array, n, guard) {
    if (array == null)
      return void 0;
    if (n == null || guard)
      return array[0];
    if (n < 0)
      return [];
    return slice.call(array, 0, n);
  };
  _.initial = function (array, n, guard) {
    return slice.call(array, 0, array.length - (n == null || guard ? 1 : n));
  };
  _.last = function (array, n, guard) {
    if (array == null)
      return void 0;
    if (n == null || guard)
      return array[array.length - 1];
    return slice.call(array, Math.max(array.length - n, 0));
  };
  _.rest = _.tail = _.drop = function (array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };
  _.compact = function (array) {
    return _.filter(array, _.identity);
  };
  var flatten = function (input, shallow, output) {
    if (shallow && _.every(input, _.isArray)) {
      return concat.apply(output, input);
    }
    each(input, function (value) {
      if (_.isArray(value) || _.isArguments(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };
  _.flatten = function (array, shallow) {
    return flatten(array, shallow, []);
  };
  _.without = function (array) {
    return _.difference(array, slice.call(arguments, 1));
  };
  _.partition = function (array, predicate) {
    var pass = [], fail = [];
    each(array, function (elem) {
      (predicate(elem) ? pass : fail).push(elem);
    });
    return [
      pass,
      fail
    ];
  };
  _.uniq = _.unique = function (array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function (value, index) {
      if (isSorted ? !index || seen[seen.length - 1] !== value : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };
  _.union = function () {
    return _.uniq(_.flatten(arguments, true));
  };
  _.intersection = function (array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function (item) {
      return _.every(rest, function (other) {
        return _.contains(other, item);
      });
    });
  };
  _.difference = function (array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function (value) {
      return !_.contains(rest, value);
    });
  };
  _.zip = function () {
    var length = _.max(_.pluck(arguments, 'length').concat(0));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(arguments, '' + i);
    }
    return results;
  };
  _.object = function (list, values) {
    if (list == null)
      return {};
    var result = {};
    for (var i = 0, length = list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };
  _.indexOf = function (array, item, isSorted) {
    if (array == null)
      return -1;
    var i = 0, length = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf)
      return array.indexOf(item, isSorted);
    for (; i < length; i++)
      if (array[i] === item)
        return i;
    return -1;
  };
  _.lastIndexOf = function (array, item, from) {
    if (array == null)
      return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = hasIndex ? from : array.length;
    while (i--)
      if (array[i] === item)
        return i;
    return -1;
  };
  _.range = function (start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;
    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(length);
    while (idx < length) {
      range[idx++] = start;
      start += step;
    }
    return range;
  };
  var ctor = function () {
  };
  _.bind = function (func, context) {
    var args, bound;
    if (nativeBind && func.bind === nativeBind)
      return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func))
      throw new TypeError();
    args = slice.call(arguments, 2);
    return bound = function () {
      if (!(this instanceof bound))
        return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor();
      ctor.prototype = null;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result)
        return result;
      return self;
    };
  };
  _.partial = function (func) {
    var boundArgs = slice.call(arguments, 1);
    return function () {
      var position = 0;
      var args = boundArgs.slice();
      for (var i = 0, length = args.length; i < length; i++) {
        if (args[i] === _)
          args[i] = arguments[position++];
      }
      while (position < arguments.length)
        args.push(arguments[position++]);
      return func.apply(this, args);
    };
  };
  _.bindAll = function (obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0)
      throw new Error('bindAll must be passed function names');
    each(funcs, function (f) {
      obj[f] = _.bind(obj[f], obj);
    });
    return obj;
  };
  _.memoize = function (func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function () {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : memo[key] = func.apply(this, arguments);
    };
  };
  _.delay = function (func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function () {
      return func.apply(null, args);
    }, wait);
  };
  _.defer = function (func) {
    return _.delay.apply(_, [
      func,
      1
    ].concat(slice.call(arguments, 1)));
  };
  _.throttle = function (func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    options || (options = {});
    var later = function () {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      context = args = null;
    };
    return function () {
      var now = _.now();
      if (!previous && options.leading === false)
        previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
        context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };
  _.debounce = function (func, wait, immediate) {
    var timeout, args, context, timestamp, result;
    var later = function () {
      var last = _.now() - timestamp;
      if (last < wait) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          context = args = null;
        }
      }
    };
    return function () {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) {
        timeout = setTimeout(later, wait);
      }
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }
      return result;
    };
  };
  _.once = function (func) {
    var ran = false, memo;
    return function () {
      if (ran)
        return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };
  _.wrap = function (func, wrapper) {
    return _.partial(wrapper, func);
  };
  _.compose = function () {
    var funcs = arguments;
    return function () {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };
  _.after = function (times, func) {
    return function () {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };
  _.keys = function (obj) {
    if (!_.isObject(obj))
      return [];
    if (nativeKeys)
      return nativeKeys(obj);
    var keys = [];
    for (var key in obj)
      if (_.has(obj, key))
        keys.push(key);
    return keys;
  };
  _.values = function (obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = new Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };
  _.pairs = function (obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = new Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [
        keys[i],
        obj[keys[i]]
      ];
    }
    return pairs;
  };
  _.invert = function (obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };
  _.functions = _.methods = function (obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key]))
        names.push(key);
    }
    return names.sort();
  };
  _.extend = function (obj) {
    each(slice.call(arguments, 1), function (source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };
  _.pick = function (obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function (key) {
      if (key in obj)
        copy[key] = obj[key];
    });
    return copy;
  };
  _.omit = function (obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key))
        copy[key] = obj[key];
    }
    return copy;
  };
  _.defaults = function (obj) {
    each(slice.call(arguments, 1), function (source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] === void 0)
            obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };
  _.clone = function (obj) {
    if (!_.isObject(obj))
      return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };
  _.tap = function (obj, interceptor) {
    interceptor(obj);
    return obj;
  };
  var eq = function (a, b, aStack, bStack) {
    if (a === b)
      return a !== 0 || 1 / a == 1 / b;
    if (a == null || b == null)
      return a === b;
    if (a instanceof _)
      a = a._wrapped;
    if (b instanceof _)
      b = b._wrapped;
    var className = toString.call(a);
    if (className != toString.call(b))
      return false;
    switch (className) {
    case '[object String]':
      return a == String(b);
    case '[object Number]':
      return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;
    case '[object Date]':
    case '[object Boolean]':
      return +a == +b;
    case '[object RegExp]':
      return a.source == b.source && a.global == b.global && a.multiline == b.multiline && a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object')
      return false;
    var length = aStack.length;
    while (length--) {
      if (aStack[length] == a)
        return bStack[length] == b;
    }
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor) && ('constructor' in a && 'constructor' in b)) {
      return false;
    }
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    if (className == '[object Array]') {
      size = a.length;
      result = size == b.length;
      if (result) {
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack)))
            break;
        }
      }
    } else {
      for (var key in a) {
        if (_.has(a, key)) {
          size++;
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack)))
            break;
        }
      }
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !size--)
            break;
        }
        result = !size;
      }
    }
    aStack.pop();
    bStack.pop();
    return result;
  };
  _.isEqual = function (a, b) {
    return eq(a, b, [], []);
  };
  _.isEmpty = function (obj) {
    if (obj == null)
      return true;
    if (_.isArray(obj) || _.isString(obj))
      return obj.length === 0;
    for (var key in obj)
      if (_.has(obj, key))
        return false;
    return true;
  };
  _.isElement = function (obj) {
    return !!(obj && obj.nodeType === 1);
  };
  _.isArray = nativeIsArray || function (obj) {
    return toString.call(obj) == '[object Array]';
  };
  _.isObject = function (obj) {
    return obj === Object(obj);
  };
  each([
    'Arguments',
    'Function',
    'String',
    'Number',
    'Date',
    'RegExp'
  ], function (name) {
    _['is' + name] = function (obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });
  if (!_.isArguments(arguments)) {
    _.isArguments = function (obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }
  if (typeof /./ !== 'function') {
    _.isFunction = function (obj) {
      return typeof obj === 'function';
    };
  }
  _.isFinite = function (obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };
  _.isNaN = function (obj) {
    return _.isNumber(obj) && obj != +obj;
  };
  _.isBoolean = function (obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };
  _.isNull = function (obj) {
    return obj === null;
  };
  _.isUndefined = function (obj) {
    return obj === void 0;
  };
  _.has = function (obj, key) {
    return hasOwnProperty.call(obj, key);
  };
  _.noConflict = function () {
    root._ = previousUnderscore;
    return this;
  };
  _.identity = function (value) {
    return value;
  };
  _.constant = function (value) {
    return function () {
      return value;
    };
  };
  _.property = function (key) {
    return function (obj) {
      return obj[key];
    };
  };
  _.matches = function (attrs) {
    return function (obj) {
      if (obj === attrs)
        return true;
      for (var key in attrs) {
        if (attrs[key] !== obj[key])
          return false;
      }
      return true;
    };
  };
  _.times = function (n, iterator, context) {
    var accum = Array(Math.max(0, n));
    for (var i = 0; i < n; i++)
      accum[i] = iterator.call(context, i);
    return accum;
  };
  _.random = function (min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };
  _.now = Date.now || function () {
    return new Date().getTime();
  };
  var entityMap = {
      escape: {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        '\'': '&#x27;'
      }
    };
  entityMap.unescape = _.invert(entityMap.escape);
  var entityRegexes = {
      escape: new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
      unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
    };
  _.each([
    'escape',
    'unescape'
  ], function (method) {
    _[method] = function (string) {
      if (string == null)
        return '';
      return ('' + string).replace(entityRegexes[method], function (match) {
        return entityMap[method][match];
      });
    };
  });
  _.result = function (object, property) {
    if (object == null)
      return void 0;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };
  _.mixin = function (obj) {
    each(_.functions(obj), function (name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function () {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };
  var idCounter = 0;
  _.uniqueId = function (prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };
  _.templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g
  };
  var noMatch = /(.)^/;
  var escapes = {
      '\'': '\'',
      '\\': '\\',
      '\r': 'r',
      '\n': 'n',
      '\t': 't',
      '\u2028': 'u2028',
      '\u2029': 'u2029'
    };
  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;
  _.template = function (text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);
    var matcher = new RegExp([
        (settings.escape || noMatch).source,
        (settings.interpolate || noMatch).source,
        (settings.evaluate || noMatch).source
      ].join('|') + '|$', 'g');
    var index = 0;
    var source = '__p+=\'';
    text.replace(matcher, function (match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, function (match) {
        return '\\' + escapes[match];
      });
      if (escape) {
        source += '\'+\n((__t=(' + escape + '))==null?\'\':_.escape(__t))+\n\'';
      }
      if (interpolate) {
        source += '\'+\n((__t=(' + interpolate + '))==null?\'\':__t)+\n\'';
      }
      if (evaluate) {
        source += '\';\n' + evaluate + '\n__p+=\'';
      }
      index = offset + match.length;
      return match;
    });
    source += '\';\n';
    if (!settings.variable)
      source = 'with(obj||{}){\n' + source + '}\n';
    source = 'var __t,__p=\'\',__j=Array.prototype.join,' + 'print=function(){__p+=__j.call(arguments,\'\');};\n' + source + 'return __p;\n';
    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }
    if (data)
      return render(data, _);
    var template = function (data) {
      return render.call(this, data, _);
    };
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';
    return template;
  };
  _.chain = function (obj) {
    return _(obj).chain();
  };
  var result = function (obj) {
    return this._chain ? _(obj).chain() : obj;
  };
  _.mixin(_);
  each([
    'pop',
    'push',
    'reverse',
    'shift',
    'sort',
    'splice',
    'unshift'
  ], function (name) {
    var method = ArrayProto[name];
    _.prototype[name] = function () {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0)
        delete obj[0];
      return result.call(this, obj);
    };
  });
  each([
    'concat',
    'join',
    'slice'
  ], function (name) {
    var method = ArrayProto[name];
    _.prototype[name] = function () {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });
  _.extend(_.prototype, {
    chain: function () {
      this._chain = true;
      return this;
    },
    value: function () {
      return this._wrapped;
    }
  });
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function () {
      return _;
    });
  }
}.call(this));
(function (root, undef) {
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, slice = ArrayProto.slice, hasOwnProp = ObjProto.hasOwnProperty, nativeForEach = ArrayProto.forEach, breaker = {};
  var _ = {
      forEach: function (obj, iterator, context) {
        var i, l, key;
        if (obj === null) {
          return;
        }
        if (nativeForEach && obj.forEach === nativeForEach) {
          obj.forEach(iterator, context);
        } else if (obj.length === +obj.length) {
          for (i = 0, l = obj.length; i < l; i++) {
            if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) {
              return;
            }
          }
        } else {
          for (key in obj) {
            if (hasOwnProp.call(obj, key)) {
              if (iterator.call(context, obj[key], key, obj) === breaker) {
                return;
              }
            }
          }
        }
      },
      extend: function (obj) {
        this.forEach(slice.call(arguments, 1), function (source) {
          for (var prop in source) {
            obj[prop] = source[prop];
          }
        });
        return obj;
      }
    };
  var Jed = function (options) {
    this.defaults = {
      'locale_data': {
        'messages': {
          '': {
            'domain': 'messages',
            'lang': 'en',
            'plural_forms': 'nplurals=2; plural=(n != 1);'
          }
        }
      },
      'domain': 'messages'
    };
    this.options = _.extend({}, this.defaults, options);
    this.textdomain(this.options.domain);
    if (options.domain && !this.options.locale_data[this.options.domain]) {
      throw new Error('Text domain set to non-existent domain: `' + options.domain + '`');
    }
  };
  Jed.context_delimiter = String.fromCharCode(4);
  function getPluralFormFunc(plural_form_string) {
    return Jed.PF.compile(plural_form_string || 'nplurals=2; plural=(n != 1);');
  }
  function Chain(key, i18n) {
    this._key = key;
    this._i18n = i18n;
  }
  _.extend(Chain.prototype, {
    onDomain: function (domain) {
      this._domain = domain;
      return this;
    },
    withContext: function (context) {
      this._context = context;
      return this;
    },
    ifPlural: function (num, pkey) {
      this._val = num;
      this._pkey = pkey;
      return this;
    },
    fetch: function (sArr) {
      if ({}.toString.call(sArr) != '[object Array]') {
        sArr = [].slice.call(arguments);
      }
      return (sArr && sArr.length ? Jed.sprintf : function (x) {
        return x;
      })(this._i18n.dcnpgettext(this._domain, this._context, this._key, this._pkey, this._val), sArr);
    }
  });
  _.extend(Jed.prototype, {
    translate: function (key) {
      return new Chain(key, this);
    },
    textdomain: function (domain) {
      if (!domain) {
        return this._textdomain;
      }
      this._textdomain = domain;
    },
    gettext: function (key) {
      return this.dcnpgettext.call(this, undef, undef, key);
    },
    dgettext: function (domain, key) {
      return this.dcnpgettext.call(this, domain, undef, key);
    },
    dcgettext: function (domain, key) {
      return this.dcnpgettext.call(this, domain, undef, key);
    },
    ngettext: function (skey, pkey, val) {
      return this.dcnpgettext.call(this, undef, undef, skey, pkey, val);
    },
    dngettext: function (domain, skey, pkey, val) {
      return this.dcnpgettext.call(this, domain, undef, skey, pkey, val);
    },
    dcngettext: function (domain, skey, pkey, val) {
      return this.dcnpgettext.call(this, domain, undef, skey, pkey, val);
    },
    pgettext: function (context, key) {
      return this.dcnpgettext.call(this, undef, context, key);
    },
    dpgettext: function (domain, context, key) {
      return this.dcnpgettext.call(this, domain, context, key);
    },
    dcpgettext: function (domain, context, key) {
      return this.dcnpgettext.call(this, domain, context, key);
    },
    npgettext: function (context, skey, pkey, val) {
      return this.dcnpgettext.call(this, undef, context, skey, pkey, val);
    },
    dnpgettext: function (domain, context, skey, pkey, val) {
      return this.dcnpgettext.call(this, domain, context, skey, pkey, val);
    },
    dcnpgettext: function (domain, context, singular_key, plural_key, val) {
      plural_key = plural_key || singular_key;
      domain = domain || this._textdomain;
      val = typeof val == 'undefined' ? 1 : val;
      var fallback;
      if (!this.options) {
        fallback = new Jed();
        return fallback.dcnpgettext.call(fallback, undefined, undefined, singular_key, plural_key, val);
      }
      if (!this.options.locale_data) {
        throw new Error('No locale data provided.');
      }
      if (!this.options.locale_data[domain]) {
        throw new Error('Domain `' + domain + '` was not found.');
      }
      if (!this.options.locale_data[domain]['']) {
        throw new Error('No locale meta information provided.');
      }
      if (!singular_key) {
        throw new Error('No translation key found.');
      }
      if (typeof val != 'number') {
        val = parseInt(val, 10);
        if (isNaN(val)) {
          throw new Error('The number that was passed in is not a number.');
        }
      }
      var key = context ? context + Jed.context_delimiter + singular_key : singular_key, locale_data = this.options.locale_data, dict = locale_data[domain], pluralForms = dict[''].plural_forms || (locale_data.messages || this.defaults.locale_data.messages)[''].plural_forms, val_idx = getPluralFormFunc(pluralForms)(val) + 1, val_list, res;
      if (!dict) {
        throw new Error('No domain named `' + domain + '` could be found.');
      }
      val_list = dict[key];
      if (!val_list || val_idx >= val_list.length) {
        if (this.options.missing_key_callback) {
          this.options.missing_key_callback(key);
        }
        res = [
          null,
          singular_key,
          plural_key
        ];
        return res[getPluralFormFunc(pluralForms)(val) + 1];
      }
      res = val_list[val_idx];
      if (!res) {
        res = [
          null,
          singular_key,
          plural_key
        ];
        return res[getPluralFormFunc(pluralForms)(val) + 1];
      }
      return res;
    }
  });
  var sprintf = function () {
      function get_type(variable) {
        return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
      }
      function str_repeat(input, multiplier) {
        for (var output = []; multiplier > 0; output[--multiplier] = input) {
        }
        return output.join('');
      }
      var str_format = function () {
        if (!str_format.cache.hasOwnProperty(arguments[0])) {
          str_format.cache[arguments[0]] = str_format.parse(arguments[0]);
        }
        return str_format.format.call(null, str_format.cache[arguments[0]], arguments);
      };
      str_format.format = function (parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;
        for (i = 0; i < tree_length; i++) {
          node_type = get_type(parse_tree[i]);
          if (node_type === 'string') {
            output.push(parse_tree[i]);
          } else if (node_type === 'array') {
            match = parse_tree[i];
            if (match[2]) {
              arg = argv[cursor];
              for (k = 0; k < match[2].length; k++) {
                if (!arg.hasOwnProperty(match[2][k])) {
                  throw sprintf('[sprintf] property "%s" does not exist', match[2][k]);
                }
                arg = arg[match[2][k]];
              }
            } else if (match[1]) {
              arg = argv[match[1]];
            } else {
              arg = argv[cursor++];
            }
            if (/[^s]/.test(match[8]) && get_type(arg) != 'number') {
              throw sprintf('[sprintf] expecting number but found %s', get_type(arg));
            }
            if (typeof arg == 'undefined' || arg === null) {
              arg = '';
            }
            switch (match[8]) {
            case 'b':
              arg = arg.toString(2);
              break;
            case 'c':
              arg = String.fromCharCode(arg);
              break;
            case 'd':
              arg = parseInt(arg, 10);
              break;
            case 'e':
              arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential();
              break;
            case 'f':
              arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg);
              break;
            case 'o':
              arg = arg.toString(8);
              break;
            case 's':
              arg = (arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg;
              break;
            case 'u':
              arg = Math.abs(arg);
              break;
            case 'x':
              arg = arg.toString(16);
              break;
            case 'X':
              arg = arg.toString(16).toUpperCase();
              break;
            }
            arg = /[def]/.test(match[8]) && match[3] && arg >= 0 ? '+' + arg : arg;
            pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';
            pad_length = match[6] - String(arg).length;
            pad = match[6] ? str_repeat(pad_character, pad_length) : '';
            output.push(match[5] ? arg + pad : pad + arg);
          }
        }
        return output.join('');
      };
      str_format.cache = {};
      str_format.parse = function (fmt) {
        var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
        while (_fmt) {
          if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
            parse_tree.push(match[0]);
          } else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
            parse_tree.push('%');
          } else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
            if (match[2]) {
              arg_names |= 1;
              var field_list = [], replacement_field = match[2], field_match = [];
              if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                field_list.push(field_match[1]);
                while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                  if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else {
                    throw '[sprintf] huh?';
                  }
                }
              } else {
                throw '[sprintf] huh?';
              }
              match[2] = field_list;
            } else {
              arg_names |= 2;
            }
            if (arg_names === 3) {
              throw '[sprintf] mixing positional and named placeholders is not (yet) supported';
            }
            parse_tree.push(match);
          } else {
            throw '[sprintf] huh?';
          }
          _fmt = _fmt.substring(match[0].length);
        }
        return parse_tree;
      };
      return str_format;
    }();
  var vsprintf = function (fmt, argv) {
    argv.unshift(fmt);
    return sprintf.apply(null, argv);
  };
  Jed.parse_plural = function (plural_forms, n) {
    plural_forms = plural_forms.replace(/n/g, n);
    return Jed.parse_expression(plural_forms);
  };
  Jed.sprintf = function (fmt, args) {
    if ({}.toString.call(args) == '[object Array]') {
      return vsprintf(fmt, [].slice.call(args));
    }
    return sprintf.apply(this, [].slice.call(arguments));
  };
  Jed.prototype.sprintf = function () {
    return Jed.sprintf.apply(this, arguments);
  };
  Jed.PF = {};
  Jed.PF.parse = function (p) {
    var plural_str = Jed.PF.extractPluralExpr(p);
    return Jed.PF.parser.parse.call(Jed.PF.parser, plural_str);
  };
  Jed.PF.compile = function (p) {
    function imply(val) {
      return val === true ? 1 : val ? val : 0;
    }
    var ast = Jed.PF.parse(p);
    return function (n) {
      return imply(Jed.PF.interpreter(ast)(n));
    };
  };
  Jed.PF.interpreter = function (ast) {
    return function (n) {
      var res;
      switch (ast.type) {
      case 'GROUP':
        return Jed.PF.interpreter(ast.expr)(n);
      case 'TERNARY':
        if (Jed.PF.interpreter(ast.expr)(n)) {
          return Jed.PF.interpreter(ast.truthy)(n);
        }
        return Jed.PF.interpreter(ast.falsey)(n);
      case 'OR':
        return Jed.PF.interpreter(ast.left)(n) || Jed.PF.interpreter(ast.right)(n);
      case 'AND':
        return Jed.PF.interpreter(ast.left)(n) && Jed.PF.interpreter(ast.right)(n);
      case 'LT':
        return Jed.PF.interpreter(ast.left)(n) < Jed.PF.interpreter(ast.right)(n);
      case 'GT':
        return Jed.PF.interpreter(ast.left)(n) > Jed.PF.interpreter(ast.right)(n);
      case 'LTE':
        return Jed.PF.interpreter(ast.left)(n) <= Jed.PF.interpreter(ast.right)(n);
      case 'GTE':
        return Jed.PF.interpreter(ast.left)(n) >= Jed.PF.interpreter(ast.right)(n);
      case 'EQ':
        return Jed.PF.interpreter(ast.left)(n) == Jed.PF.interpreter(ast.right)(n);
      case 'NEQ':
        return Jed.PF.interpreter(ast.left)(n) != Jed.PF.interpreter(ast.right)(n);
      case 'MOD':
        return Jed.PF.interpreter(ast.left)(n) % Jed.PF.interpreter(ast.right)(n);
      case 'VAR':
        return n;
      case 'NUM':
        return ast.val;
      default:
        throw new Error('Invalid Token found.');
      }
    };
  };
  Jed.PF.extractPluralExpr = function (p) {
    p = p.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    if (!/;\s*$/.test(p)) {
      p = p.concat(';');
    }
    var nplurals_re = /nplurals\=(\d+);/, plural_re = /plural\=(.*);/, nplurals_matches = p.match(nplurals_re), res = {}, plural_matches;
    if (nplurals_matches.length > 1) {
      res.nplurals = nplurals_matches[1];
    } else {
      throw new Error('nplurals not found in plural_forms string: ' + p);
    }
    p = p.replace(nplurals_re, '');
    plural_matches = p.match(plural_re);
    if (!(plural_matches && plural_matches.length > 1)) {
      throw new Error('`plural` expression not found: ' + p);
    }
    return plural_matches[1];
  };
  Jed.PF.parser = function () {
    var parser = {
        trace: function trace() {
        },
        yy: {},
        symbols_: {
          'error': 2,
          'expressions': 3,
          'e': 4,
          'EOF': 5,
          '?': 6,
          ':': 7,
          '||': 8,
          '&&': 9,
          '<': 10,
          '<=': 11,
          '>': 12,
          '>=': 13,
          '!=': 14,
          '==': 15,
          '%': 16,
          '(': 17,
          ')': 18,
          'n': 19,
          'NUMBER': 20,
          '$accept': 0,
          '$end': 1
        },
        terminals_: {
          2: 'error',
          5: 'EOF',
          6: '?',
          7: ':',
          8: '||',
          9: '&&',
          10: '<',
          11: '<=',
          12: '>',
          13: '>=',
          14: '!=',
          15: '==',
          16: '%',
          17: '(',
          18: ')',
          19: 'n',
          20: 'NUMBER'
        },
        productions_: [
          0,
          [
            3,
            2
          ],
          [
            4,
            5
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            1
          ],
          [
            4,
            1
          ]
        ],
        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
          var $0 = $$.length - 1;
          switch (yystate) {
          case 1:
            return {
              type: 'GROUP',
              expr: $$[$0 - 1]
            };
            break;
          case 2:
            this.$ = {
              type: 'TERNARY',
              expr: $$[$0 - 4],
              truthy: $$[$0 - 2],
              falsey: $$[$0]
            };
            break;
          case 3:
            this.$ = {
              type: 'OR',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 4:
            this.$ = {
              type: 'AND',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 5:
            this.$ = {
              type: 'LT',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 6:
            this.$ = {
              type: 'LTE',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 7:
            this.$ = {
              type: 'GT',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 8:
            this.$ = {
              type: 'GTE',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 9:
            this.$ = {
              type: 'NEQ',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 10:
            this.$ = {
              type: 'EQ',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 11:
            this.$ = {
              type: 'MOD',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 12:
            this.$ = {
              type: 'GROUP',
              expr: $$[$0 - 1]
            };
            break;
          case 13:
            this.$ = { type: 'VAR' };
            break;
          case 14:
            this.$ = {
              type: 'NUM',
              val: Number(yytext)
            };
            break;
          }
        },
        table: [
          {
            3: 1,
            4: 2,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          { 1: [3] },
          {
            5: [
              1,
              6
            ],
            6: [
              1,
              7
            ],
            8: [
              1,
              8
            ],
            9: [
              1,
              9
            ],
            10: [
              1,
              10
            ],
            11: [
              1,
              11
            ],
            12: [
              1,
              12
            ],
            13: [
              1,
              13
            ],
            14: [
              1,
              14
            ],
            15: [
              1,
              15
            ],
            16: [
              1,
              16
            ]
          },
          {
            4: 17,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            5: [
              2,
              13
            ],
            6: [
              2,
              13
            ],
            7: [
              2,
              13
            ],
            8: [
              2,
              13
            ],
            9: [
              2,
              13
            ],
            10: [
              2,
              13
            ],
            11: [
              2,
              13
            ],
            12: [
              2,
              13
            ],
            13: [
              2,
              13
            ],
            14: [
              2,
              13
            ],
            15: [
              2,
              13
            ],
            16: [
              2,
              13
            ],
            18: [
              2,
              13
            ]
          },
          {
            5: [
              2,
              14
            ],
            6: [
              2,
              14
            ],
            7: [
              2,
              14
            ],
            8: [
              2,
              14
            ],
            9: [
              2,
              14
            ],
            10: [
              2,
              14
            ],
            11: [
              2,
              14
            ],
            12: [
              2,
              14
            ],
            13: [
              2,
              14
            ],
            14: [
              2,
              14
            ],
            15: [
              2,
              14
            ],
            16: [
              2,
              14
            ],
            18: [
              2,
              14
            ]
          },
          {
            1: [
              2,
              1
            ]
          },
          {
            4: 18,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 19,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 20,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 21,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 22,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 23,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 24,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 25,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 26,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 27,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            6: [
              1,
              7
            ],
            8: [
              1,
              8
            ],
            9: [
              1,
              9
            ],
            10: [
              1,
              10
            ],
            11: [
              1,
              11
            ],
            12: [
              1,
              12
            ],
            13: [
              1,
              13
            ],
            14: [
              1,
              14
            ],
            15: [
              1,
              15
            ],
            16: [
              1,
              16
            ],
            18: [
              1,
              28
            ]
          },
          {
            6: [
              1,
              7
            ],
            7: [
              1,
              29
            ],
            8: [
              1,
              8
            ],
            9: [
              1,
              9
            ],
            10: [
              1,
              10
            ],
            11: [
              1,
              11
            ],
            12: [
              1,
              12
            ],
            13: [
              1,
              13
            ],
            14: [
              1,
              14
            ],
            15: [
              1,
              15
            ],
            16: [
              1,
              16
            ]
          },
          {
            5: [
              2,
              3
            ],
            6: [
              2,
              3
            ],
            7: [
              2,
              3
            ],
            8: [
              2,
              3
            ],
            9: [
              1,
              9
            ],
            10: [
              1,
              10
            ],
            11: [
              1,
              11
            ],
            12: [
              1,
              12
            ],
            13: [
              1,
              13
            ],
            14: [
              1,
              14
            ],
            15: [
              1,
              15
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              3
            ]
          },
          {
            5: [
              2,
              4
            ],
            6: [
              2,
              4
            ],
            7: [
              2,
              4
            ],
            8: [
              2,
              4
            ],
            9: [
              2,
              4
            ],
            10: [
              1,
              10
            ],
            11: [
              1,
              11
            ],
            12: [
              1,
              12
            ],
            13: [
              1,
              13
            ],
            14: [
              1,
              14
            ],
            15: [
              1,
              15
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              4
            ]
          },
          {
            5: [
              2,
              5
            ],
            6: [
              2,
              5
            ],
            7: [
              2,
              5
            ],
            8: [
              2,
              5
            ],
            9: [
              2,
              5
            ],
            10: [
              2,
              5
            ],
            11: [
              2,
              5
            ],
            12: [
              2,
              5
            ],
            13: [
              2,
              5
            ],
            14: [
              2,
              5
            ],
            15: [
              2,
              5
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              5
            ]
          },
          {
            5: [
              2,
              6
            ],
            6: [
              2,
              6
            ],
            7: [
              2,
              6
            ],
            8: [
              2,
              6
            ],
            9: [
              2,
              6
            ],
            10: [
              2,
              6
            ],
            11: [
              2,
              6
            ],
            12: [
              2,
              6
            ],
            13: [
              2,
              6
            ],
            14: [
              2,
              6
            ],
            15: [
              2,
              6
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              6
            ]
          },
          {
            5: [
              2,
              7
            ],
            6: [
              2,
              7
            ],
            7: [
              2,
              7
            ],
            8: [
              2,
              7
            ],
            9: [
              2,
              7
            ],
            10: [
              2,
              7
            ],
            11: [
              2,
              7
            ],
            12: [
              2,
              7
            ],
            13: [
              2,
              7
            ],
            14: [
              2,
              7
            ],
            15: [
              2,
              7
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              7
            ]
          },
          {
            5: [
              2,
              8
            ],
            6: [
              2,
              8
            ],
            7: [
              2,
              8
            ],
            8: [
              2,
              8
            ],
            9: [
              2,
              8
            ],
            10: [
              2,
              8
            ],
            11: [
              2,
              8
            ],
            12: [
              2,
              8
            ],
            13: [
              2,
              8
            ],
            14: [
              2,
              8
            ],
            15: [
              2,
              8
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              8
            ]
          },
          {
            5: [
              2,
              9
            ],
            6: [
              2,
              9
            ],
            7: [
              2,
              9
            ],
            8: [
              2,
              9
            ],
            9: [
              2,
              9
            ],
            10: [
              2,
              9
            ],
            11: [
              2,
              9
            ],
            12: [
              2,
              9
            ],
            13: [
              2,
              9
            ],
            14: [
              2,
              9
            ],
            15: [
              2,
              9
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              9
            ]
          },
          {
            5: [
              2,
              10
            ],
            6: [
              2,
              10
            ],
            7: [
              2,
              10
            ],
            8: [
              2,
              10
            ],
            9: [
              2,
              10
            ],
            10: [
              2,
              10
            ],
            11: [
              2,
              10
            ],
            12: [
              2,
              10
            ],
            13: [
              2,
              10
            ],
            14: [
              2,
              10
            ],
            15: [
              2,
              10
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              10
            ]
          },
          {
            5: [
              2,
              11
            ],
            6: [
              2,
              11
            ],
            7: [
              2,
              11
            ],
            8: [
              2,
              11
            ],
            9: [
              2,
              11
            ],
            10: [
              2,
              11
            ],
            11: [
              2,
              11
            ],
            12: [
              2,
              11
            ],
            13: [
              2,
              11
            ],
            14: [
              2,
              11
            ],
            15: [
              2,
              11
            ],
            16: [
              2,
              11
            ],
            18: [
              2,
              11
            ]
          },
          {
            5: [
              2,
              12
            ],
            6: [
              2,
              12
            ],
            7: [
              2,
              12
            ],
            8: [
              2,
              12
            ],
            9: [
              2,
              12
            ],
            10: [
              2,
              12
            ],
            11: [
              2,
              12
            ],
            12: [
              2,
              12
            ],
            13: [
              2,
              12
            ],
            14: [
              2,
              12
            ],
            15: [
              2,
              12
            ],
            16: [
              2,
              12
            ],
            18: [
              2,
              12
            ]
          },
          {
            4: 30,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            5: [
              2,
              2
            ],
            6: [
              1,
              7
            ],
            7: [
              2,
              2
            ],
            8: [
              1,
              8
            ],
            9: [
              1,
              9
            ],
            10: [
              1,
              10
            ],
            11: [
              1,
              11
            ],
            12: [
              1,
              12
            ],
            13: [
              1,
              13
            ],
            14: [
              1,
              14
            ],
            15: [
              1,
              15
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              2
            ]
          }
        ],
        defaultActions: {
          6: [
            2,
            1
          ]
        },
        parseError: function parseError(str, hash) {
          throw new Error(str);
        },
        parse: function parse(input) {
          var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
          this.lexer.setInput(input);
          this.lexer.yy = this.yy;
          this.yy.lexer = this.lexer;
          if (typeof this.lexer.yylloc == 'undefined')
            this.lexer.yylloc = {};
          var yyloc = this.lexer.yylloc;
          lstack.push(yyloc);
          if (typeof this.yy.parseError === 'function')
            this.parseError = this.yy.parseError;
          function popStack(n) {
            stack.length = stack.length - 2 * n;
            vstack.length = vstack.length - n;
            lstack.length = lstack.length - n;
          }
          function lex() {
            var token;
            token = self.lexer.lex() || 1;
            if (typeof token !== 'number') {
              token = self.symbols_[token] || token;
            }
            return token;
          }
          var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
          while (true) {
            state = stack[stack.length - 1];
            if (this.defaultActions[state]) {
              action = this.defaultActions[state];
            } else {
              if (symbol == null)
                symbol = lex();
              action = table[state] && table[state][symbol];
            }
            _handle_error:
              if (typeof action === 'undefined' || !action.length || !action[0]) {
                if (!recovering) {
                  expected = [];
                  for (p in table[state])
                    if (this.terminals_[p] && p > 2) {
                      expected.push('\'' + this.terminals_[p] + '\'');
                    }
                  var errStr = '';
                  if (this.lexer.showPosition) {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + this.lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + this.terminals_[symbol] + '\'';
                  } else {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == 1 ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                  }
                  this.parseError(errStr, {
                    text: this.lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: this.lexer.yylineno,
                    loc: yyloc,
                    expected: expected
                  });
                }
                if (recovering == 3) {
                  if (symbol == EOF) {
                    throw new Error(errStr || 'Parsing halted.');
                  }
                  yyleng = this.lexer.yyleng;
                  yytext = this.lexer.yytext;
                  yylineno = this.lexer.yylineno;
                  yyloc = this.lexer.yylloc;
                  symbol = lex();
                }
                while (1) {
                  if (TERROR.toString() in table[state]) {
                    break;
                  }
                  if (state == 0) {
                    throw new Error(errStr || 'Parsing halted.');
                  }
                  popStack(1);
                  state = stack[stack.length - 1];
                }
                preErrorSymbol = symbol;
                symbol = TERROR;
                state = stack[stack.length - 1];
                action = table[state] && table[state][TERROR];
                recovering = 3;
              }
            if (action[0] instanceof Array && action.length > 1) {
              throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
            }
            switch (action[0]) {
            case 1:
              stack.push(symbol);
              vstack.push(this.lexer.yytext);
              lstack.push(this.lexer.yylloc);
              stack.push(action[1]);
              symbol = null;
              if (!preErrorSymbol) {
                yyleng = this.lexer.yyleng;
                yytext = this.lexer.yytext;
                yylineno = this.lexer.yylineno;
                yyloc = this.lexer.yylloc;
                if (recovering > 0)
                  recovering--;
              } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
              }
              break;
            case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
              };
              r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
              if (typeof r !== 'undefined') {
                return r;
              }
              if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
              }
              stack.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
              stack.push(newState);
              break;
            case 3:
              return true;
            }
          }
          return true;
        }
      };
    var lexer = function () {
        var lexer = {
            EOF: 1,
            parseError: function parseError(str, hash) {
              if (this.yy.parseError) {
                this.yy.parseError(str, hash);
              } else {
                throw new Error(str);
              }
            },
            setInput: function (input) {
              this._input = input;
              this._more = this._less = this.done = false;
              this.yylineno = this.yyleng = 0;
              this.yytext = this.matched = this.match = '';
              this.conditionStack = ['INITIAL'];
              this.yylloc = {
                first_line: 1,
                first_column: 0,
                last_line: 1,
                last_column: 0
              };
              return this;
            },
            input: function () {
              var ch = this._input[0];
              this.yytext += ch;
              this.yyleng++;
              this.match += ch;
              this.matched += ch;
              var lines = ch.match(/\n/);
              if (lines)
                this.yylineno++;
              this._input = this._input.slice(1);
              return ch;
            },
            unput: function (ch) {
              this._input = ch + this._input;
              return this;
            },
            more: function () {
              this._more = true;
              return this;
            },
            pastInput: function () {
              var past = this.matched.substr(0, this.matched.length - this.match.length);
              return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, '');
            },
            upcomingInput: function () {
              var next = this.match;
              if (next.length < 20) {
                next += this._input.substr(0, 20 - next.length);
              }
              return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, '');
            },
            showPosition: function () {
              var pre = this.pastInput();
              var c = new Array(pre.length + 1).join('-');
              return pre + this.upcomingInput() + '\n' + c + '^';
            },
            next: function () {
              if (this.done) {
                return this.EOF;
              }
              if (!this._input)
                this.done = true;
              var token, match, col, lines;
              if (!this._more) {
                this.yytext = '';
                this.match = '';
              }
              var rules = this._currentRules();
              for (var i = 0; i < rules.length; i++) {
                match = this._input.match(this.rules[rules[i]]);
                if (match) {
                  lines = match[0].match(/\n.*/g);
                  if (lines)
                    this.yylineno += lines.length;
                  this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: lines ? lines[lines.length - 1].length - 1 : this.yylloc.last_column + match[0].length
                  };
                  this.yytext += match[0];
                  this.match += match[0];
                  this.matches = match;
                  this.yyleng = this.yytext.length;
                  this._more = false;
                  this._input = this._input.slice(match[0].length);
                  this.matched += match[0];
                  token = this.performAction.call(this, this.yy, this, rules[i], this.conditionStack[this.conditionStack.length - 1]);
                  if (token)
                    return token;
                  else
                    return;
                }
              }
              if (this._input === '') {
                return this.EOF;
              } else {
                this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                  text: '',
                  token: null,
                  line: this.yylineno
                });
              }
            },
            lex: function lex() {
              var r = this.next();
              if (typeof r !== 'undefined') {
                return r;
              } else {
                return this.lex();
              }
            },
            begin: function begin(condition) {
              this.conditionStack.push(condition);
            },
            popState: function popState() {
              return this.conditionStack.pop();
            },
            _currentRules: function _currentRules() {
              return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
            },
            topState: function () {
              return this.conditionStack[this.conditionStack.length - 2];
            },
            pushState: function begin(condition) {
              this.begin(condition);
            }
          };
        lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
          var YYSTATE = YY_START;
          switch ($avoiding_name_collisions) {
          case 0:
            break;
          case 1:
            return 20;
            break;
          case 2:
            return 19;
            break;
          case 3:
            return 8;
            break;
          case 4:
            return 9;
            break;
          case 5:
            return 6;
            break;
          case 6:
            return 7;
            break;
          case 7:
            return 11;
            break;
          case 8:
            return 13;
            break;
          case 9:
            return 10;
            break;
          case 10:
            return 12;
            break;
          case 11:
            return 14;
            break;
          case 12:
            return 15;
            break;
          case 13:
            return 16;
            break;
          case 14:
            return 17;
            break;
          case 15:
            return 18;
            break;
          case 16:
            return 5;
            break;
          case 17:
            return 'INVALID';
            break;
          }
        };
        lexer.rules = [
          /^\s+/,
          /^[0-9]+(\.[0-9]+)?\b/,
          /^n\b/,
          /^\|\|/,
          /^&&/,
          /^\?/,
          /^:/,
          /^<=/,
          /^>=/,
          /^</,
          /^>/,
          /^!=/,
          /^==/,
          /^%/,
          /^\(/,
          /^\)/,
          /^$/,
          /^./
        ];
        lexer.conditions = {
          'INITIAL': {
            'rules': [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              14,
              15,
              16,
              17
            ],
            'inclusive': true
          }
        };
        return lexer;
      }();
    parser.lexer = lexer;
    return parser;
  }();
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = Jed;
    }
    exports.Jed = Jed;
  } else {
    if (typeof define === 'function' && define.amd) {
      define('jed', function () {
        return Jed;
      });
    }
    root['Jed'] = Jed;
  }
}(this));
window.CodeMirror = function () {
  'use strict';
  var gecko = /gecko\/\d/i.test(navigator.userAgent);
  var ie = /MSIE \d/.test(navigator.userAgent);
  var ie_lt8 = ie && (document.documentMode == null || document.documentMode < 8);
  var ie_lt9 = ie && (document.documentMode == null || document.documentMode < 9);
  var webkit = /WebKit\//.test(navigator.userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(navigator.userAgent);
  var chrome = /Chrome\//.test(navigator.userAgent);
  var opera = /Opera\//.test(navigator.userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var khtml = /KHTML\//.test(navigator.userAgent);
  var mac_geLion = /Mac OS X 1\d\D([7-9]|\d\d)\D/.test(navigator.userAgent);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(navigator.userAgent);
  var phantom = /PhantomJS/.test(navigator.userAgent);
  var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent);
  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);
  var mac = ios || /Mac/.test(navigator.platform);
  var windows = /windows/i.test(navigator.platform);
  var opera_version = opera && navigator.userAgent.match(/Version\/(\d*\.\d*)/);
  if (opera_version)
    opera_version = Number(opera_version[1]);
  var flipCtrlCmd = mac && (qtwebkit || opera && (opera_version == null || opera_version < 12.11));
  var captureMiddleClick = gecko || ie && !ie_lt9;
  var sawReadOnlySpans = false, sawCollapsedSpans = false;
  function CodeMirror(place, options) {
    if (!(this instanceof CodeMirror))
      return new CodeMirror(place, options);
    this.options = options = options || {};
    for (var opt in defaults)
      if (!options.hasOwnProperty(opt) && defaults.hasOwnProperty(opt))
        options[opt] = defaults[opt];
    setGuttersForLineNumbers(options);
    var docStart = typeof options.value == 'string' ? 0 : options.value.first;
    var display = this.display = makeDisplay(place, docStart);
    display.wrapper.CodeMirror = this;
    updateGutters(this);
    if (options.autofocus && !mobile)
      focusInput(this);
    this.state = {
      keyMaps: [],
      overlays: [],
      modeGen: 0,
      overwrite: false,
      focused: false,
      suppressEdits: false,
      pasteIncoming: false,
      draggingText: false,
      highlight: new Delayed()
    };
    themeChanged(this);
    if (options.lineWrapping)
      this.display.wrapper.className += ' CodeMirror-wrap';
    var doc = options.value;
    if (typeof doc == 'string')
      doc = new Doc(options.value, options.mode);
    operation(this, attachDoc)(this, doc);
    if (ie)
      setTimeout(bind(resetInput, this, true), 20);
    registerEventHandlers(this);
    var hasFocus;
    try {
      hasFocus = document.activeElement == display.input;
    } catch (e) {
    }
    if (hasFocus || options.autofocus && !mobile)
      setTimeout(bind(onFocus, this), 20);
    else
      onBlur(this);
    operation(this, function () {
      for (var opt in optionHandlers)
        if (optionHandlers.propertyIsEnumerable(opt))
          optionHandlers[opt](this, options[opt], Init);
      for (var i = 0; i < initHooks.length; ++i)
        initHooks[i](this);
    })();
  }
  function makeDisplay(place, docStart) {
    var d = {};
    var input = d.input = elt('textarea', null, null, 'position: absolute; padding: 0; width: 1px; height: 1em; outline: none; font-size: 4px;');
    if (webkit)
      input.style.width = '1000px';
    else
      input.setAttribute('wrap', 'off');
    if (ios)
      input.style.border = '1px solid black';
    input.setAttribute('autocorrect', 'off');
    input.setAttribute('autocapitalize', 'off');
    d.inputDiv = elt('div', [input], null, 'overflow: hidden; position: relative; width: 3px; height: 0px;');
    d.scrollbarH = elt('div', [elt('div', null, null, 'height: 1px')], 'CodeMirror-hscrollbar');
    d.scrollbarV = elt('div', [elt('div', null, null, 'width: 1px')], 'CodeMirror-vscrollbar');
    d.scrollbarFiller = elt('div', null, 'CodeMirror-scrollbar-filler');
    d.lineDiv = elt('div');
    d.selectionDiv = elt('div', null, null, 'position: relative; z-index: 1');
    d.cursor = elt('div', '\xa0', 'CodeMirror-cursor');
    d.otherCursor = elt('div', '\xa0', 'CodeMirror-cursor CodeMirror-secondarycursor');
    d.measure = elt('div', null, 'CodeMirror-measure');
    d.lineSpace = elt('div', [
      d.measure,
      d.selectionDiv,
      d.lineDiv,
      d.cursor,
      d.otherCursor
    ], null, 'position: relative; outline: none');
    d.mover = elt('div', [elt('div', [d.lineSpace], 'CodeMirror-lines')], null, 'position: relative');
    d.sizer = elt('div', [d.mover], 'CodeMirror-sizer');
    d.heightForcer = elt('div', null, null, 'position: absolute; height: ' + scrollerCutOff + 'px; width: 1px;');
    d.gutters = elt('div', null, 'CodeMirror-gutters');
    d.lineGutter = null;
    var scrollerInner = elt('div', [
        d.sizer,
        d.heightForcer,
        d.gutters
      ], null, 'position: relative; min-height: 100%');
    d.scroller = elt('div', [scrollerInner], 'CodeMirror-scroll');
    d.scroller.setAttribute('tabIndex', '-1');
    d.wrapper = elt('div', [
      d.inputDiv,
      d.scrollbarH,
      d.scrollbarV,
      d.scrollbarFiller,
      d.scroller
    ], 'CodeMirror');
    if (ie_lt8) {
      d.gutters.style.zIndex = -1;
      d.scroller.style.paddingRight = 0;
    }
    if (place.appendChild)
      place.appendChild(d.wrapper);
    else
      place(d.wrapper);
    if (ios)
      input.style.width = '0px';
    if (!webkit)
      d.scroller.draggable = true;
    if (khtml) {
      d.inputDiv.style.height = '1px';
      d.inputDiv.style.position = 'absolute';
    } else if (ie_lt8)
      d.scrollbarH.style.minWidth = d.scrollbarV.style.minWidth = '18px';
    d.viewOffset = d.lastSizeC = 0;
    d.showingFrom = d.showingTo = docStart;
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    d.prevInput = '';
    d.alignWidgets = false;
    d.pollingFast = false;
    d.poll = new Delayed();
    d.cachedCharWidth = d.cachedTextHeight = null;
    d.measureLineCache = [];
    d.measureLineCachePos = 0;
    d.inaccurateSelection = false;
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;
    return d;
  }
  function loadMode(cm) {
    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);
    cm.doc.iter(function (line) {
      if (line.stateAfter)
        line.stateAfter = null;
      if (line.styles)
        line.styles = null;
    });
    cm.doc.frontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp)
      regChange(cm);
  }
  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      cm.display.wrapper.className += ' CodeMirror-wrap';
      cm.display.sizer.style.minWidth = '';
    } else {
      cm.display.wrapper.className = cm.display.wrapper.className.replace(' CodeMirror-wrap', '');
      computeMaxLength(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function () {
      updateScrollbars(cm.display, cm.doc.height);
    }, 100);
  }
  function estimateHeight(cm) {
    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function (line) {
      if (lineIsHidden(cm.doc, line))
        return 0;
      else if (wrapping)
        return (Math.ceil(line.text.length / perLine) || 1) * th;
      else
        return th;
    };
  }
  function estimateLineHeights(cm) {
    var doc = cm.doc, est = estimateHeight(cm);
    doc.iter(function (line) {
      var estHeight = est(line);
      if (estHeight != line.height)
        updateLineHeight(line, estHeight);
    });
  }
  function keyMapChanged(cm) {
    var style = keyMap[cm.options.keyMap].style;
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-keymap-\S+/g, '') + (style ? ' cm-keymap-' + style : '');
  }
  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, '') + cm.options.theme.replace(/(^|\s)\s*/g, ' cm-s-');
    clearCaches(cm);
  }
  function guttersChanged(cm) {
    updateGutters(cm);
    regChange(cm);
  }
  function updateGutters(cm) {
    var gutters = cm.display.gutters, specs = cm.options.gutters;
    removeChildren(gutters);
    for (var i = 0; i < specs.length; ++i) {
      var gutterClass = specs[i];
      var gElt = gutters.appendChild(elt('div', null, 'CodeMirror-gutter ' + gutterClass));
      if (gutterClass == 'CodeMirror-linenumbers') {
        cm.display.lineGutter = gElt;
        gElt.style.width = (cm.display.lineNumWidth || 1) + 'px';
      }
    }
    gutters.style.display = i ? '' : 'none';
  }
  function lineLength(doc, line) {
    if (line.height == 0)
      return 0;
    var len = line.text.length, merged, cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find();
      cur = getLine(doc, found.from.line);
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found = merged.find();
      len -= cur.text.length - found.from.ch;
      cur = getLine(doc, found.to.line);
      len += cur.text.length - found.to.ch;
    }
    return len;
  }
  function computeMaxLength(cm) {
    var d = cm.display, doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(doc, d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function (line) {
      var len = lineLength(doc, line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }
  function setGuttersForLineNumbers(options) {
    var found = false;
    for (var i = 0; i < options.gutters.length; ++i) {
      if (options.gutters[i] == 'CodeMirror-linenumbers') {
        if (options.lineNumbers)
          found = true;
        else
          options.gutters.splice(i--, 1);
      }
    }
    if (!found && options.lineNumbers)
      options.gutters.push('CodeMirror-linenumbers');
  }
  function updateScrollbars(d, docHeight) {
    var totalHeight = docHeight + paddingVert(d);
    d.sizer.style.minHeight = d.heightForcer.style.top = totalHeight + 'px';
    var scrollHeight = Math.max(totalHeight, d.scroller.scrollHeight);
    var needsH = d.scroller.scrollWidth > d.scroller.clientWidth;
    var needsV = scrollHeight > d.scroller.clientHeight;
    if (needsV) {
      d.scrollbarV.style.display = 'block';
      d.scrollbarV.style.bottom = needsH ? scrollbarWidth(d.measure) + 'px' : '0';
      d.scrollbarV.firstChild.style.height = scrollHeight - d.scroller.clientHeight + d.scrollbarV.clientHeight + 'px';
    } else
      d.scrollbarV.style.display = '';
    if (needsH) {
      d.scrollbarH.style.display = 'block';
      d.scrollbarH.style.right = needsV ? scrollbarWidth(d.measure) + 'px' : '0';
      d.scrollbarH.firstChild.style.width = d.scroller.scrollWidth - d.scroller.clientWidth + d.scrollbarH.clientWidth + 'px';
    } else
      d.scrollbarH.style.display = '';
    if (needsH && needsV) {
      d.scrollbarFiller.style.display = 'block';
      d.scrollbarFiller.style.height = d.scrollbarFiller.style.width = scrollbarWidth(d.measure) + 'px';
    } else
      d.scrollbarFiller.style.display = '';
    if (mac_geLion && scrollbarWidth(d.measure) === 0)
      d.scrollbarV.style.minWidth = d.scrollbarH.style.minHeight = mac_geMountainLion ? '18px' : '12px';
  }
  function visibleLines(display, doc, viewPort) {
    var top = display.scroller.scrollTop, height = display.wrapper.clientHeight;
    if (typeof viewPort == 'number')
      top = viewPort;
    else if (viewPort) {
      top = viewPort.top;
      height = viewPort.bottom - viewPort.top;
    }
    top = Math.floor(top - paddingTop(display));
    var bottom = Math.ceil(top + height);
    return {
      from: lineAtHeight(doc, top),
      to: lineAtHeight(doc, bottom)
    };
  }
  function alignHorizontally(cm) {
    var display = cm.display;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter))
      return;
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth, l = comp + 'px';
    for (var n = display.lineDiv.firstChild; n; n = n.nextSibling)
      if (n.alignable) {
        for (var i = 0, a = n.alignable; i < a.length; ++i)
          a[i].style.left = l;
      }
    if (cm.options.fixedGutter)
      display.gutters.style.left = comp + gutterW + 'px';
  }
  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers)
      return false;
    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt('div', [elt('div', last)], 'CodeMirror-linenumber CodeMirror-gutter-elt'));
      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = '';
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding);
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + 'px';
      return true;
    }
    return false;
  }
  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber));
  }
  function compensateForHScroll(display) {
    return getRect(display.scroller).left - getRect(display.sizer).left;
  }
  function updateDisplay(cm, changes, viewPort) {
    var oldFrom = cm.display.showingFrom, oldTo = cm.display.showingTo, updated;
    var visible = visibleLines(cm.display, cm.doc, viewPort);
    for (;;) {
      if (updateDisplayInner(cm, changes, visible)) {
        updated = true;
        signalLater(cm, 'update', cm);
        if (cm.display.showingFrom != oldFrom || cm.display.showingTo != oldTo)
          signalLater(cm, 'viewportChange', cm, cm.display.showingFrom, cm.display.showingTo);
      } else
        break;
      updateSelection(cm);
      updateScrollbars(cm.display, cm.doc.height);
      if (viewPort)
        viewPort = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, typeof viewPort == 'number' ? viewPort : viewPort.top);
      visible = visibleLines(cm.display, cm.doc, viewPort);
      if (visible.from >= cm.display.showingFrom && visible.to <= cm.display.showingTo)
        break;
      changes = [];
    }
    return updated;
  }
  function updateDisplayInner(cm, changes, visible) {
    var display = cm.display, doc = cm.doc;
    if (!display.wrapper.clientWidth) {
      display.showingFrom = display.showingTo = doc.first;
      display.viewOffset = 0;
      return;
    }
    if (changes.length == 0 && visible.from > display.showingFrom && visible.to < display.showingTo)
      return;
    if (maybeUpdateLineNumberWidth(cm))
      changes = [{
          from: doc.first,
          to: doc.first + doc.size
        }];
    var gutterW = display.sizer.style.marginLeft = display.gutters.offsetWidth + 'px';
    display.scrollbarH.style.left = cm.options.fixedGutter ? gutterW : '0';
    var positionsChangedFrom = Infinity;
    if (cm.options.lineNumbers)
      for (var i = 0; i < changes.length; ++i)
        if (changes[i].diff) {
          positionsChangedFrom = changes[i].from;
          break;
        }
    var end = doc.first + doc.size;
    var from = Math.max(visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, visible.to + cm.options.viewportMargin);
    if (display.showingFrom < from && from - display.showingFrom < 20)
      from = Math.max(doc.first, display.showingFrom);
    if (display.showingTo > to && display.showingTo - to < 20)
      to = Math.min(end, display.showingTo);
    if (sawCollapsedSpans) {
      from = lineNo(visualLine(doc, getLine(doc, from)));
      while (to < end && lineIsHidden(doc, getLine(doc, to)))
        ++to;
    }
    var intact = [{
          from: Math.max(display.showingFrom, doc.first),
          to: Math.min(display.showingTo, end)
        }];
    if (intact[0].from >= intact[0].to)
      intact = [];
    else
      intact = computeIntact(intact, changes);
    if (sawCollapsedSpans)
      for (var i = 0; i < intact.length; ++i) {
        var range = intact[i], merged;
        while (merged = collapsedSpanAtEnd(getLine(doc, range.to - 1))) {
          var newTo = merged.find().from.line;
          if (newTo > range.from)
            range.to = newTo;
          else {
            intact.splice(i--, 1);
            break;
          }
        }
      }
    var intactLines = 0;
    for (var i = 0; i < intact.length; ++i) {
      var range = intact[i];
      if (range.from < from)
        range.from = from;
      if (range.to > to)
        range.to = to;
      if (range.from >= range.to)
        intact.splice(i--, 1);
      else
        intactLines += range.to - range.from;
    }
    if (intactLines == to - from && from == display.showingFrom && to == display.showingTo) {
      updateViewOffset(cm);
      return;
    }
    intact.sort(function (a, b) {
      return a.from - b.from;
    });
    try {
      var focused = document.activeElement;
    } catch (e) {
    }
    if (intactLines < (to - from) * 0.7)
      display.lineDiv.style.display = 'none';
    patchDisplay(cm, from, to, intact, positionsChangedFrom);
    display.lineDiv.style.display = '';
    if (focused && document.activeElement != focused && focused.offsetHeight)
      focused.focus();
    var different = from != display.showingFrom || to != display.showingTo || display.lastSizeC != display.wrapper.clientHeight;
    if (different)
      display.lastSizeC = display.wrapper.clientHeight;
    display.showingFrom = from;
    display.showingTo = to;
    startWorker(cm, 100);
    var prevBottom = display.lineDiv.offsetTop;
    for (var node = display.lineDiv.firstChild, height; node; node = node.nextSibling)
      if (node.lineObj) {
        if (ie_lt8) {
          var bot = node.offsetTop + node.offsetHeight;
          height = bot - prevBottom;
          prevBottom = bot;
        } else {
          var box = getRect(node);
          height = box.bottom - box.top;
        }
        var diff = node.lineObj.height - height;
        if (height < 2)
          height = textHeight(display);
        if (diff > 0.001 || diff < -0.001) {
          updateLineHeight(node.lineObj, height);
          var widgets = node.lineObj.widgets;
          if (widgets)
            for (var i = 0; i < widgets.length; ++i)
              widgets[i].height = widgets[i].node.offsetHeight;
        }
      }
    updateViewOffset(cm);
    return true;
  }
  function updateViewOffset(cm) {
    var off = cm.display.viewOffset = heightAtLine(cm, getLine(cm.doc, cm.display.showingFrom));
    cm.display.mover.style.top = off + 'px';
  }
  function computeIntact(intact, changes) {
    for (var i = 0, l = changes.length || 0; i < l; ++i) {
      var change = changes[i], intact2 = [], diff = change.diff || 0;
      for (var j = 0, l2 = intact.length; j < l2; ++j) {
        var range = intact[j];
        if (change.to <= range.from && change.diff) {
          intact2.push({
            from: range.from + diff,
            to: range.to + diff
          });
        } else if (change.to <= range.from || change.from >= range.to) {
          intact2.push(range);
        } else {
          if (change.from > range.from)
            intact2.push({
              from: range.from,
              to: change.from
            });
          if (change.to < range.to)
            intact2.push({
              from: change.to + diff,
              to: range.to + diff
            });
        }
      }
      intact = intact2;
    }
    return intact;
  }
  function getDimensions(cm) {
    var d = cm.display, left = {}, width = {};
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      left[cm.options.gutters[i]] = n.offsetLeft;
      width[cm.options.gutters[i]] = n.offsetWidth;
    }
    return {
      fixedPos: compensateForHScroll(d),
      gutterTotalWidth: d.gutters.offsetWidth,
      gutterLeft: left,
      gutterWidth: width,
      wrapperWidth: d.wrapper.clientWidth
    };
  }
  function patchDisplay(cm, from, to, intact, updateNumbersFrom) {
    var dims = getDimensions(cm);
    var display = cm.display, lineNumbers = cm.options.lineNumbers;
    if (!intact.length && (!webkit || !cm.display.currentWheelTarget))
      removeChildren(display.lineDiv);
    var container = display.lineDiv, cur = container.firstChild;
    function rm(node) {
      var next = node.nextSibling;
      if (webkit && mac && cm.display.currentWheelTarget == node) {
        node.style.display = 'none';
        node.lineObj = null;
      } else {
        node.parentNode.removeChild(node);
      }
      return next;
    }
    var nextIntact = intact.shift(), lineN = from;
    cm.doc.iter(from, to, function (line) {
      if (nextIntact && nextIntact.to == lineN)
        nextIntact = intact.shift();
      if (lineIsHidden(cm.doc, line)) {
        if (line.height != 0)
          updateLineHeight(line, 0);
        if (line.widgets && cur.previousSibling)
          for (var i = 0; i < line.widgets.length; ++i)
            if (line.widgets[i].showIfHidden) {
              var prev = cur.previousSibling;
              if (/pre/i.test(prev.nodeName)) {
                var wrap = elt('div', null, null, 'position: relative');
                prev.parentNode.replaceChild(wrap, prev);
                wrap.appendChild(prev);
                prev = wrap;
              }
              var wnode = prev.appendChild(elt('div', [line.widgets[i].node], 'CodeMirror-linewidget'));
              positionLineWidget(line.widgets[i], wnode, prev, dims);
            }
      } else if (nextIntact && nextIntact.from <= lineN && nextIntact.to > lineN) {
        while (cur.lineObj != line)
          cur = rm(cur);
        if (lineNumbers && updateNumbersFrom <= lineN && cur.lineNumber)
          setTextContent(cur.lineNumber, lineNumberFor(cm.options, lineN));
        cur = cur.nextSibling;
      } else {
        if (line.widgets)
          for (var j = 0, search = cur, reuse; search && j < 20; ++j, search = search.nextSibling)
            if (search.lineObj == line && /div/i.test(search.nodeName)) {
              reuse = search;
              break;
            }
        var lineNode = buildLineElement(cm, line, lineN, dims, reuse);
        if (lineNode != reuse) {
          container.insertBefore(lineNode, cur);
        } else {
          while (cur != reuse)
            cur = rm(cur);
          cur = cur.nextSibling;
        }
        lineNode.lineObj = line;
      }
      ++lineN;
    });
    while (cur)
      cur = rm(cur);
  }
  function buildLineElement(cm, line, lineNo, dims, reuse) {
    var lineElement = lineContent(cm, line);
    var markers = line.gutterMarkers, display = cm.display, wrap;
    if (!cm.options.lineNumbers && !markers && !line.bgClass && !line.wrapClass && !line.widgets)
      return lineElement;
    if (reuse) {
      reuse.alignable = null;
      var isOk = true, widgetsSeen = 0;
      for (var n = reuse.firstChild, next; n; n = next) {
        next = n.nextSibling;
        if (!/\bCodeMirror-linewidget\b/.test(n.className)) {
          reuse.removeChild(n);
        } else {
          for (var i = 0, first = true; i < line.widgets.length; ++i) {
            var widget = line.widgets[i], isFirst = false;
            if (!widget.above) {
              isFirst = first;
              first = false;
            }
            if (widget.node == n.firstChild) {
              positionLineWidget(widget, n, reuse, dims);
              ++widgetsSeen;
              if (isFirst)
                reuse.insertBefore(lineElement, n);
              break;
            }
          }
          if (i == line.widgets.length) {
            isOk = false;
            break;
          }
        }
      }
      if (isOk && widgetsSeen == line.widgets.length) {
        wrap = reuse;
        reuse.className = line.wrapClass || '';
      }
    }
    if (!wrap) {
      wrap = elt('div', null, line.wrapClass, 'position: relative');
      wrap.appendChild(lineElement);
    }
    if (line.bgClass)
      wrap.insertBefore(elt('div', null, line.bgClass + ' CodeMirror-linebackground'), wrap.firstChild);
    if (cm.options.lineNumbers || markers) {
      var gutterWrap = wrap.insertBefore(elt('div', null, null, 'position: absolute; left: ' + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + 'px'), wrap.firstChild);
      if (cm.options.fixedGutter)
        (wrap.alignable || (wrap.alignable = [])).push(gutterWrap);
      if (cm.options.lineNumbers && (!markers || !markers['CodeMirror-linenumbers']))
        wrap.lineNumber = gutterWrap.appendChild(elt('div', lineNumberFor(cm.options, lineNo), 'CodeMirror-linenumber CodeMirror-gutter-elt', 'left: ' + dims.gutterLeft['CodeMirror-linenumbers'] + 'px; width: ' + display.lineNumInnerWidth + 'px'));
      if (markers)
        for (var k = 0; k < cm.options.gutters.length; ++k) {
          var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
          if (found)
            gutterWrap.appendChild(elt('div', [found], 'CodeMirror-gutter-elt', 'left: ' + dims.gutterLeft[id] + 'px; width: ' + dims.gutterWidth[id] + 'px'));
        }
    }
    if (ie_lt8)
      wrap.style.zIndex = 2;
    if (line.widgets && wrap != reuse)
      for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
        var widget = ws[i], node = elt('div', [widget.node], 'CodeMirror-linewidget');
        positionLineWidget(widget, node, wrap, dims);
        if (widget.above)
          wrap.insertBefore(node, cm.options.lineNumbers && line.height != 0 ? gutterWrap : lineElement);
        else
          wrap.appendChild(node);
        signalLater(widget, 'redraw');
      }
    return wrap;
  }
  function positionLineWidget(widget, node, wrap, dims) {
    if (widget.noHScroll) {
      (wrap.alignable || (wrap.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + 'px';
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + 'px';
      }
      node.style.width = width + 'px';
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = 'relative';
      if (!widget.noHScroll)
        node.style.marginLeft = -dims.gutterTotalWidth + 'px';
    }
  }
  function updateSelection(cm) {
    var display = cm.display;
    var collapsed = posEq(cm.doc.sel.from, cm.doc.sel.to);
    if (collapsed || cm.options.showCursorWhenSelecting)
      updateSelectionCursor(cm);
    else
      display.cursor.style.display = display.otherCursor.style.display = 'none';
    if (!collapsed)
      updateSelectionRange(cm);
    else
      display.selectionDiv.style.display = 'none';
    if (cm.options.moveInputWithCursor) {
      var headPos = cursorCoords(cm, cm.doc.sel.head, 'div');
      var wrapOff = getRect(display.wrapper), lineOff = getRect(display.lineDiv);
      display.inputDiv.style.top = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top)) + 'px';
      display.inputDiv.style.left = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left)) + 'px';
    }
  }
  function updateSelectionCursor(cm) {
    var display = cm.display, pos = cursorCoords(cm, cm.doc.sel.head, 'div');
    display.cursor.style.left = pos.left + 'px';
    display.cursor.style.top = pos.top + 'px';
    display.cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + 'px';
    display.cursor.style.display = '';
    if (pos.other) {
      display.otherCursor.style.display = '';
      display.otherCursor.style.left = pos.other.left + 'px';
      display.otherCursor.style.top = pos.other.top + 'px';
      display.otherCursor.style.height = (pos.other.bottom - pos.other.top) * 0.85 + 'px';
    } else {
      display.otherCursor.style.display = 'none';
    }
  }
  function updateSelectionRange(cm) {
    var display = cm.display, doc = cm.doc, sel = cm.doc.sel;
    var fragment = document.createDocumentFragment();
    var clientWidth = display.lineSpace.offsetWidth, pl = paddingLeft(cm.display);
    function add(left, top, width, bottom) {
      if (top < 0)
        top = 0;
      fragment.appendChild(elt('div', null, 'CodeMirror-selected', 'position: absolute; left: ' + left + 'px; top: ' + top + 'px; width: ' + (width == null ? clientWidth - left : width) + 'px; height: ' + (bottom - top) + 'px'));
    }
    function drawForLine(line, fromArg, toArg, retTop) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length, rVal = retTop ? Infinity : -Infinity;
      function coords(ch) {
        return charCoords(cm, Pos(line, ch), 'div', lineObj);
      }
      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir) {
        var leftPos = coords(from), rightPos, left, right;
        if (from == to) {
          rightPos = leftPos;
          left = right = leftPos.left;
        } else {
          rightPos = coords(to - 1);
          if (dir == 'rtl') {
            var tmp = leftPos;
            leftPos = rightPos;
            rightPos = tmp;
          }
          left = leftPos.left;
          right = rightPos.right;
        }
        if (rightPos.top - leftPos.top > 3) {
          add(left, leftPos.top, null, leftPos.bottom);
          left = pl;
          if (leftPos.bottom < rightPos.top)
            add(left, leftPos.bottom, null, rightPos.top);
        }
        if (toArg == null && to == lineLen)
          right = clientWidth;
        if (fromArg == null && from == 0)
          left = pl;
        rVal = retTop ? Math.min(rightPos.top, rVal) : Math.max(rightPos.bottom, rVal);
        if (left < pl + 1)
          left = pl;
        add(left, rightPos.top, right - left, rightPos.bottom);
      });
      return rVal;
    }
    if (sel.from.line == sel.to.line) {
      drawForLine(sel.from.line, sel.from.ch, sel.to.ch);
    } else {
      var fromObj = getLine(doc, sel.from.line);
      var cur = fromObj, merged, path = [
          sel.from.line,
          sel.from.ch
        ], singleLine;
      while (merged = collapsedSpanAtEnd(cur)) {
        var found = merged.find();
        path.push(found.from.ch, found.to.line, found.to.ch);
        if (found.to.line == sel.to.line) {
          path.push(sel.to.ch);
          singleLine = true;
          break;
        }
        cur = getLine(doc, found.to.line);
      }
      if (singleLine) {
        for (var i = 0; i < path.length; i += 3)
          drawForLine(path[i], path[i + 1], path[i + 2]);
      } else {
        var middleTop, middleBot, toObj = getLine(doc, sel.to.line);
        if (sel.from.ch)
          middleTop = drawForLine(sel.from.line, sel.from.ch, null, false);
        else
          middleTop = heightAtLine(cm, fromObj) - display.viewOffset;
        if (!sel.to.ch)
          middleBot = heightAtLine(cm, toObj) - display.viewOffset;
        else
          middleBot = drawForLine(sel.to.line, collapsedSpanAtStart(toObj) ? null : 0, sel.to.ch, true);
        if (middleTop < middleBot)
          add(pl, middleTop, null, middleBot);
      }
    }
    removeChildrenAndAdd(display.selectionDiv, fragment);
    display.selectionDiv.style.display = '';
  }
  function restartBlink(cm) {
    if (!cm.state.focused)
      return;
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursor.style.visibility = display.otherCursor.style.visibility = '';
    display.blinker = setInterval(function () {
      display.cursor.style.visibility = display.otherCursor.style.visibility = (on = !on) ? '' : 'hidden';
    }, cm.options.cursorBlinkRate);
  }
  function startWorker(cm, time) {
    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.showingTo)
      cm.state.highlight.set(time, bind(highlightWorker, cm));
  }
  function highlightWorker(cm) {
    var doc = cm.doc;
    if (doc.frontier < doc.first)
      doc.frontier = doc.first;
    if (doc.frontier >= cm.display.showingTo)
      return;
    var end = +new Date() + cm.options.workTime;
    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));
    var changed = [], prevChange;
    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.showingTo + 500), function (line) {
      if (doc.frontier >= cm.display.showingFrom) {
        var oldStyles = line.styles;
        line.styles = highlightLine(cm, line, state);
        var ischange = !oldStyles || oldStyles.length != line.styles.length;
        for (var i = 0; !ischange && i < oldStyles.length; ++i)
          ischange = oldStyles[i] != line.styles[i];
        if (ischange) {
          if (prevChange && prevChange.end == doc.frontier)
            prevChange.end++;
          else
            changed.push(prevChange = {
              start: doc.frontier,
              end: doc.frontier + 1
            });
        }
        line.stateAfter = copyState(doc.mode, state);
      } else {
        processLine(cm, line, state);
        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
      }
      ++doc.frontier;
      if (+new Date() > end) {
        startWorker(cm, cm.options.workDelay);
        return true;
      }
    });
    if (changed.length)
      operation(cm, function () {
        for (var i = 0; i < changed.length; ++i)
          regChange(this, changed[i].start, changed[i].end);
      })();
  }
  function findStartLine(cm, n) {
    var minindent, minline, doc = cm.doc;
    for (var search = n, lim = n - 100; search > lim; --search) {
      if (search <= doc.first)
        return doc.first;
      var line = getLine(doc, search - 1);
      if (line.stateAfter)
        return search;
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline;
  }
  function getStateBefore(cm, n) {
    var doc = cm.doc, display = cm.display;
    if (!doc.mode.startState)
      return true;
    var pos = findStartLine(cm, n), state = pos > doc.first && getLine(doc, pos - 1).stateAfter;
    if (!state)
      state = startState(doc.mode);
    else
      state = copyState(doc.mode, state);
    doc.iter(pos, n, function (line) {
      processLine(cm, line, state);
      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.showingFrom && pos < display.showingTo;
      line.stateAfter = save ? copyState(doc.mode, state) : null;
      ++pos;
    });
    return state;
  }
  function paddingTop(display) {
    return display.lineSpace.offsetTop;
  }
  function paddingVert(display) {
    return display.mover.offsetHeight - display.lineSpace.offsetHeight;
  }
  function paddingLeft(display) {
    var e = removeChildrenAndAdd(display.measure, elt('pre', null, null, 'text-align: left')).appendChild(elt('span', 'x'));
    return e.offsetLeft;
  }
  function measureChar(cm, line, ch, data) {
    var dir = -1;
    data = data || measureLine(cm, line);
    for (var pos = ch;; pos += dir) {
      var r = data[pos];
      if (r)
        break;
      if (dir < 0 && pos == 0)
        dir = 1;
    }
    return {
      left: pos < ch ? r.right : r.left,
      right: pos > ch ? r.left : r.right,
      top: r.top,
      bottom: r.bottom
    };
  }
  function findCachedMeasurement(cm, line) {
    var cache = cm.display.measureLineCache;
    for (var i = 0; i < cache.length; ++i) {
      var memo = cache[i];
      if (memo.text == line.text && memo.markedSpans == line.markedSpans && cm.display.scroller.clientWidth == memo.width && memo.classes == line.textClass + '|' + line.bgClass + '|' + line.wrapClass)
        return memo.measure;
    }
  }
  function measureLine(cm, line) {
    var measure = findCachedMeasurement(cm, line);
    if (!measure) {
      measure = measureLineInner(cm, line);
      var cache = cm.display.measureLineCache;
      var memo = {
          text: line.text,
          width: cm.display.scroller.clientWidth,
          markedSpans: line.markedSpans,
          measure: measure,
          classes: line.textClass + '|' + line.bgClass + '|' + line.wrapClass
        };
      if (cache.length == 16)
        cache[++cm.display.measureLineCachePos % 16] = memo;
      else
        cache.push(memo);
    }
    return measure;
  }
  function measureLineInner(cm, line) {
    var display = cm.display, measure = emptyArray(line.text.length);
    var pre = lineContent(cm, line, measure);
    if (ie && !ie_lt8 && !cm.options.lineWrapping && pre.childNodes.length > 100) {
      var fragment = document.createDocumentFragment();
      var chunk = 10, n = pre.childNodes.length;
      for (var i = 0, chunks = Math.ceil(n / chunk); i < chunks; ++i) {
        var wrap = elt('div', null, null, 'display: inline-block');
        for (var j = 0; j < chunk && n; ++j) {
          wrap.appendChild(pre.firstChild);
          --n;
        }
        fragment.appendChild(wrap);
      }
      pre.appendChild(fragment);
    }
    removeChildrenAndAdd(display.measure, pre);
    var outer = getRect(display.lineDiv);
    var vranges = [], data = emptyArray(line.text.length), maxBot = pre.offsetHeight;
    if (ie_lt9 && display.measure.first != pre)
      removeChildrenAndAdd(display.measure, pre);
    for (var i = 0, cur; i < measure.length; ++i)
      if (cur = measure[i]) {
        var size = getRect(cur);
        var top = Math.max(0, size.top - outer.top), bot = Math.min(size.bottom - outer.top, maxBot);
        for (var j = 0; j < vranges.length; j += 2) {
          var rtop = vranges[j], rbot = vranges[j + 1];
          if (rtop > bot || rbot < top)
            continue;
          if (rtop <= top && rbot >= bot || top <= rtop && bot >= rbot || Math.min(bot, rbot) - Math.max(top, rtop) >= bot - top >> 1) {
            vranges[j] = Math.min(top, rtop);
            vranges[j + 1] = Math.max(bot, rbot);
            break;
          }
        }
        if (j == vranges.length)
          vranges.push(top, bot);
        var right = size.right;
        if (cur.measureRight)
          right = getRect(cur.measureRight).left;
        data[i] = {
          left: size.left - outer.left,
          right: right - outer.left,
          top: j
        };
      }
    for (var i = 0, cur; i < data.length; ++i)
      if (cur = data[i]) {
        var vr = cur.top;
        cur.top = vranges[vr];
        cur.bottom = vranges[vr + 1];
      }
    return data;
  }
  function measureLineWidth(cm, line) {
    var hasBadSpan = false;
    if (line.markedSpans)
      for (var i = 0; i < line.markedSpans; ++i) {
        var sp = line.markedSpans[i];
        if (sp.collapsed && (sp.to == null || sp.to == line.text.length))
          hasBadSpan = true;
      }
    var cached = !hasBadSpan && findCachedMeasurement(cm, line);
    if (cached)
      return measureChar(cm, line, line.text.length, cached).right;
    var pre = lineContent(cm, line);
    var end = pre.appendChild(zeroWidthElement(cm.display.measure));
    removeChildrenAndAdd(cm.display.measure, pre);
    return getRect(end).right - getRect(cm.display.lineDiv).left;
  }
  function clearCaches(cm) {
    cm.display.measureLineCache.length = cm.display.measureLineCachePos = 0;
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = null;
    if (!cm.options.lineWrapping)
      cm.display.maxLineChanged = true;
    cm.display.lineNumChars = null;
  }
  function intoCoordSystem(cm, lineObj, rect, context) {
    if (lineObj.widgets)
      for (var i = 0; i < lineObj.widgets.length; ++i)
        if (lineObj.widgets[i].above) {
          var size = widgetHeight(lineObj.widgets[i]);
          rect.top += size;
          rect.bottom += size;
        }
    if (context == 'line')
      return rect;
    if (!context)
      context = 'local';
    var yOff = heightAtLine(cm, lineObj);
    if (context != 'local')
      yOff -= cm.display.viewOffset;
    if (context == 'page') {
      var lOff = getRect(cm.display.lineSpace);
      yOff += lOff.top + (window.pageYOffset || (document.documentElement || document.body).scrollTop);
      var xOff = lOff.left + (window.pageXOffset || (document.documentElement || document.body).scrollLeft);
      rect.left += xOff;
      rect.right += xOff;
    }
    rect.top += yOff;
    rect.bottom += yOff;
    return rect;
  }
  function fromCoordSystem(cm, coords, context) {
    if (context == 'div')
      return coords;
    var left = coords.left, top = coords.top;
    if (context == 'page') {
      left -= window.pageXOffset || (document.documentElement || document.body).scrollLeft;
      top -= window.pageYOffset || (document.documentElement || document.body).scrollTop;
    }
    var lineSpaceBox = getRect(cm.display.lineSpace);
    left -= lineSpaceBox.left;
    top -= lineSpaceBox.top;
    if (context == 'local' || !context) {
      var editorBox = getRect(cm.display.wrapper);
      left += editorBox.left;
      top += editorBox.top;
    }
    return {
      left: left,
      top: top
    };
  }
  function charCoords(cm, pos, context, lineObj) {
    if (!lineObj)
      lineObj = getLine(cm.doc, pos.line);
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch), context);
  }
  function cursorCoords(cm, pos, context, lineObj, measurement) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!measurement)
      measurement = measureLine(cm, lineObj);
    function get(ch, right) {
      var m = measureChar(cm, lineObj, ch, measurement);
      if (right)
        m.left = m.right;
      else
        m.right = m.left;
      return intoCoordSystem(cm, lineObj, m, context);
    }
    var order = getOrder(lineObj), ch = pos.ch;
    if (!order)
      return get(ch);
    var main, other, linedir = order[0].level;
    for (var i = 0; i < order.length; ++i) {
      var part = order[i], rtl = part.level % 2, nb, here;
      if (part.from < ch && part.to > ch)
        return get(ch, rtl);
      var left = rtl ? part.to : part.from, right = rtl ? part.from : part.to;
      if (left == ch) {
        if (i && part.level < (nb = order[i - 1]).level)
          here = get(nb.level % 2 ? nb.from : nb.to - 1, true);
        else
          here = get(rtl && part.from != part.to ? ch - 1 : ch);
        if (rtl == linedir)
          main = here;
        else
          other = here;
      } else if (right == ch) {
        var nb = i < order.length - 1 && order[i + 1];
        if (!rtl && nb && nb.from == nb.to)
          continue;
        if (nb && part.level < nb.level)
          here = get(nb.level % 2 ? nb.to - 1 : nb.from);
        else
          here = get(rtl ? ch : ch - 1, true);
        if (rtl == linedir)
          main = here;
        else
          other = here;
      }
    }
    if (linedir && !ch)
      other = get(order[0].to - 1);
    if (!main)
      return other;
    if (other)
      main.other = other;
    return main;
  }
  function PosMaybeOutside(line, ch, outside) {
    var pos = new Pos(line, ch);
    if (outside)
      pos.outside = true;
    return pos;
  }
  function coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0)
      return PosMaybeOutside(doc.first, 0, true);
    var lineNo = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
    if (lineNo > last)
      return PosMaybeOutside(doc.first + doc.size - 1, getLine(doc, last).text.length, true);
    if (x < 0)
      x = 0;
    for (;;) {
      var lineObj = getLine(doc, lineNo);
      var found = coordsCharInner(cm, lineObj, lineNo, x, y);
      var merged = collapsedSpanAtEnd(lineObj);
      var mergedPos = merged && merged.find();
      if (merged && found.ch >= mergedPos.from.ch)
        lineNo = mergedPos.to.line;
      else
        return found;
    }
  }
  function coordsCharInner(cm, lineObj, lineNo, x, y) {
    var innerOff = y - heightAtLine(cm, lineObj);
    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;
    var measurement = measureLine(cm, lineObj);
    function getX(ch) {
      var sp = cursorCoords(cm, Pos(lineNo, ch), 'line', lineObj, measurement);
      wrongLine = true;
      if (innerOff > sp.bottom)
        return sp.left - adjust;
      else if (innerOff < sp.top)
        return sp.left + adjust;
      else
        wrongLine = false;
      return sp.left;
    }
    var bidi = getOrder(lineObj), dist = lineObj.text.length;
    var from = lineLeft(lineObj), to = lineRight(lineObj);
    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;
    if (x > toX)
      return PosMaybeOutside(lineNo, to, toOutside);
    for (;;) {
      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
        var after = x - fromX < toX - x, ch = after ? from : to;
        while (isExtendingChar.test(lineObj.text.charAt(ch)))
          ++ch;
        var pos = PosMaybeOutside(lineNo, ch, after ? fromOutside : toOutside);
        pos.after = after;
        return pos;
      }
      var step = Math.ceil(dist / 2), middle = from + step;
      if (bidi) {
        middle = from;
        for (var i = 0; i < step; ++i)
          middle = moveVisually(lineObj, middle, 1);
      }
      var middleX = getX(middle);
      if (middleX > x) {
        to = middle;
        toX = middleX;
        if (toOutside = wrongLine)
          toX += 1000;
        dist = step;
      } else {
        from = middle;
        fromX = middleX;
        fromOutside = wrongLine;
        dist -= step;
      }
    }
  }
  var measureText;
  function textHeight(display) {
    if (display.cachedTextHeight != null)
      return display.cachedTextHeight;
    if (measureText == null) {
      measureText = elt('pre');
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode('x'));
        measureText.appendChild(elt('br'));
      }
      measureText.appendChild(document.createTextNode('x'));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3)
      display.cachedTextHeight = height;
    removeChildren(display.measure);
    return height || 1;
  }
  function charWidth(display) {
    if (display.cachedCharWidth != null)
      return display.cachedCharWidth;
    var anchor = elt('span', 'x');
    var pre = elt('pre', [anchor]);
    removeChildrenAndAdd(display.measure, pre);
    var width = anchor.offsetWidth;
    if (width > 2)
      display.cachedCharWidth = width;
    return width || 10;
  }
  var nextOpId = 0;
  function startOperation(cm) {
    cm.curOp = {
      changes: [],
      updateInput: null,
      userSelChange: null,
      textChanged: null,
      selectionChanged: false,
      cursorActivity: false,
      updateMaxLine: false,
      updateScrollPos: false,
      id: ++nextOpId
    };
    if (!delayedCallbackDepth++)
      delayedCallbacks = [];
  }
  function endOperation(cm) {
    var op = cm.curOp, doc = cm.doc, display = cm.display;
    cm.curOp = null;
    if (op.updateMaxLine)
      computeMaxLength(cm);
    if (display.maxLineChanged && !cm.options.lineWrapping && display.maxLine) {
      var width = measureLineWidth(cm, display.maxLine);
      display.sizer.style.minWidth = Math.max(0, width + 3 + scrollerCutOff) + 'px';
      display.maxLineChanged = false;
      var maxScrollLeft = Math.max(0, display.sizer.offsetLeft + display.sizer.offsetWidth - display.scroller.clientWidth);
      if (maxScrollLeft < doc.scrollLeft && !op.updateScrollPos)
        setScrollLeft(cm, Math.min(display.scroller.scrollLeft, maxScrollLeft), true);
    }
    var newScrollPos, updated;
    if (op.updateScrollPos) {
      newScrollPos = op.updateScrollPos;
    } else if (op.selectionChanged && display.scroller.clientHeight) {
      var coords = cursorCoords(cm, doc.sel.head);
      newScrollPos = calculateScrollPos(cm, coords.left, coords.top, coords.left, coords.bottom);
    }
    if (op.changes.length || newScrollPos && newScrollPos.scrollTop != null) {
      updated = updateDisplay(cm, op.changes, newScrollPos && newScrollPos.scrollTop);
      if (cm.display.scroller.offsetHeight)
        cm.doc.scrollTop = cm.display.scroller.scrollTop;
    }
    if (!updated && op.selectionChanged)
      updateSelection(cm);
    if (op.updateScrollPos) {
      display.scroller.scrollTop = display.scrollbarV.scrollTop = doc.scrollTop = newScrollPos.scrollTop;
      display.scroller.scrollLeft = display.scrollbarH.scrollLeft = doc.scrollLeft = newScrollPos.scrollLeft;
      alignHorizontally(cm);
      if (op.scrollToPos)
        scrollPosIntoView(cm, clipPos(cm.doc, op.scrollToPos), op.scrollToPosMargin);
    } else if (newScrollPos) {
      scrollCursorIntoView(cm);
    }
    if (op.selectionChanged)
      restartBlink(cm);
    if (cm.state.focused && op.updateInput)
      resetInput(cm, op.userSelChange);
    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
    if (hidden)
      for (var i = 0; i < hidden.length; ++i)
        if (!hidden[i].lines.length)
          signal(hidden[i], 'hide');
    if (unhidden)
      for (var i = 0; i < unhidden.length; ++i)
        if (unhidden[i].lines.length)
          signal(unhidden[i], 'unhide');
    var delayed;
    if (!--delayedCallbackDepth) {
      delayed = delayedCallbacks;
      delayedCallbacks = null;
    }
    if (op.textChanged)
      signal(cm, 'change', cm, op.textChanged);
    if (op.cursorActivity)
      signal(cm, 'cursorActivity', cm);
    if (delayed)
      for (var i = 0; i < delayed.length; ++i)
        delayed[i]();
  }
  function operation(cm1, f) {
    return function () {
      var cm = cm1 || this, withOp = !cm.curOp;
      if (withOp)
        startOperation(cm);
      try {
        var result = f.apply(cm, arguments);
      } finally {
        if (withOp)
          endOperation(cm);
      }
      return result;
    };
  }
  function docOperation(f) {
    return function () {
      var withOp = this.cm && !this.cm.curOp, result;
      if (withOp)
        startOperation(this.cm);
      try {
        result = f.apply(this, arguments);
      } finally {
        if (withOp)
          endOperation(this.cm);
      }
      return result;
    };
  }
  function runInOp(cm, f) {
    var withOp = !cm.curOp, result;
    if (withOp)
      startOperation(cm);
    try {
      result = f();
    } finally {
      if (withOp)
        endOperation(cm);
    }
    return result;
  }
  function regChange(cm, from, to, lendiff) {
    if (from == null)
      from = cm.doc.first;
    if (to == null)
      to = cm.doc.first + cm.doc.size;
    cm.curOp.changes.push({
      from: from,
      to: to,
      diff: lendiff
    });
  }
  function slowPoll(cm) {
    if (cm.display.pollingFast)
      return;
    cm.display.poll.set(cm.options.pollInterval, function () {
      readInput(cm);
      if (cm.state.focused)
        slowPoll(cm);
    });
  }
  function fastPoll(cm) {
    var missed = false;
    cm.display.pollingFast = true;
    function p() {
      var changed = readInput(cm);
      if (!changed && !missed) {
        missed = true;
        cm.display.poll.set(60, p);
      } else {
        cm.display.pollingFast = false;
        slowPoll(cm);
      }
    }
    cm.display.poll.set(20, p);
  }
  function readInput(cm) {
    var input = cm.display.input, prevInput = cm.display.prevInput, doc = cm.doc, sel = doc.sel;
    if (!cm.state.focused || hasSelection(input) || isReadOnly(cm))
      return false;
    var text = input.value;
    if (text == prevInput && posEq(sel.from, sel.to))
      return false;
    if (ie && !ie_lt9 && cm.display.inputHasSelection === text) {
      resetInput(cm, true);
      return false;
    }
    var withOp = !cm.curOp;
    if (withOp)
      startOperation(cm);
    sel.shift = false;
    var same = 0, l = Math.min(prevInput.length, text.length);
    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same))
      ++same;
    var from = sel.from, to = sel.to;
    if (same < prevInput.length)
      from = Pos(from.line, from.ch - (prevInput.length - same));
    else if (cm.state.overwrite && posEq(from, to) && !cm.state.pasteIncoming)
      to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + (text.length - same)));
    var updateInput = cm.curOp.updateInput;
    makeChange(cm.doc, {
      from: from,
      to: to,
      text: splitLines(text.slice(same)),
      origin: cm.state.pasteIncoming ? 'paste' : '+input'
    }, 'end');
    cm.curOp.updateInput = updateInput;
    if (text.length > 1000 || text.indexOf('\n') > -1)
      input.value = cm.display.prevInput = '';
    else
      cm.display.prevInput = text;
    if (withOp)
      endOperation(cm);
    cm.state.pasteIncoming = false;
    return true;
  }
  function resetInput(cm, user) {
    var minimal, selected, doc = cm.doc;
    if (!posEq(doc.sel.from, doc.sel.to)) {
      cm.display.prevInput = '';
      minimal = hasCopyEvent && (doc.sel.to.line - doc.sel.from.line > 100 || (selected = cm.getSelection()).length > 1000);
      var content = minimal ? '-' : selected || cm.getSelection();
      cm.display.input.value = content;
      if (cm.state.focused)
        selectInput(cm.display.input);
      if (ie && !ie_lt9)
        cm.display.inputHasSelection = content;
    } else if (user) {
      cm.display.prevInput = cm.display.input.value = '';
      if (ie && !ie_lt9)
        cm.display.inputHasSelection = null;
    }
    cm.display.inaccurateSelection = minimal;
  }
  function focusInput(cm) {
    if (cm.options.readOnly != 'nocursor' && (!mobile || document.activeElement != cm.display.input))
      cm.display.input.focus();
  }
  function isReadOnly(cm) {
    return cm.options.readOnly || cm.doc.cantEdit;
  }
  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, 'mousedown', operation(cm, onMouseDown));
    if (ie)
      on(d.scroller, 'dblclick', operation(cm, function (e) {
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e))
          return;
        e_preventDefault(e);
        var word = findWordAt(getLine(cm.doc, pos.line).text, pos);
        extendSelection(cm.doc, word.from, word.to);
      }));
    else
      on(d.scroller, 'dblclick', e_preventDefault);
    on(d.lineSpace, 'selectstart', function (e) {
      if (!eventInWidget(d, e))
        e_preventDefault(e);
    });
    if (!captureMiddleClick)
      on(d.scroller, 'contextmenu', function (e) {
        onContextMenu(cm, e);
      });
    on(d.scroller, 'scroll', function () {
      if (d.scroller.clientHeight) {
        setScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, 'scroll', cm);
      }
    });
    on(d.scrollbarV, 'scroll', function () {
      if (d.scroller.clientHeight)
        setScrollTop(cm, d.scrollbarV.scrollTop);
    });
    on(d.scrollbarH, 'scroll', function () {
      if (d.scroller.clientHeight)
        setScrollLeft(cm, d.scrollbarH.scrollLeft);
    });
    on(d.scroller, 'mousewheel', function (e) {
      onScrollWheel(cm, e);
    });
    on(d.scroller, 'DOMMouseScroll', function (e) {
      onScrollWheel(cm, e);
    });
    function reFocus() {
      if (cm.state.focused)
        setTimeout(bind(focusInput, cm), 0);
    }
    on(d.scrollbarH, 'mousedown', reFocus);
    on(d.scrollbarV, 'mousedown', reFocus);
    on(d.wrapper, 'scroll', function () {
      d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
    });
    function onResize() {
      d.cachedCharWidth = d.cachedTextHeight = null;
      clearCaches(cm);
      runInOp(cm, bind(regChange, cm));
    }
    on(window, 'resize', onResize);
    function unregister() {
      for (var p = d.wrapper.parentNode; p && p != document.body; p = p.parentNode) {
      }
      if (p)
        setTimeout(unregister, 5000);
      else
        off(window, 'resize', onResize);
    }
    setTimeout(unregister, 5000);
    on(d.input, 'keyup', operation(cm, function (e) {
      if (cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e)))
        return;
      if (e.keyCode == 16)
        cm.doc.sel.shift = false;
    }));
    on(d.input, 'input', bind(fastPoll, cm));
    on(d.input, 'keydown', operation(cm, onKeyDown));
    on(d.input, 'keypress', operation(cm, onKeyPress));
    on(d.input, 'focus', bind(onFocus, cm));
    on(d.input, 'blur', bind(onBlur, cm));
    function drag_(e) {
      if (cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e)))
        return;
      e_stop(e);
    }
    if (cm.options.dragDrop) {
      on(d.scroller, 'dragstart', function (e) {
        onDragStart(cm, e);
      });
      on(d.scroller, 'dragenter', drag_);
      on(d.scroller, 'dragover', drag_);
      on(d.scroller, 'drop', operation(cm, onDrop));
    }
    on(d.scroller, 'paste', function (e) {
      if (eventInWidget(d, e))
        return;
      focusInput(cm);
      fastPoll(cm);
    });
    on(d.input, 'paste', function () {
      cm.state.pasteIncoming = true;
      fastPoll(cm);
    });
    function prepareCopy() {
      if (d.inaccurateSelection) {
        d.prevInput = '';
        d.inaccurateSelection = false;
        d.input.value = cm.getSelection();
        selectInput(d.input);
      }
    }
    on(d.input, 'cut', prepareCopy);
    on(d.input, 'copy', prepareCopy);
    if (khtml)
      on(d.sizer, 'mouseup', function () {
        if (document.activeElement == d.input)
          d.input.blur();
        focusInput(cm);
      });
  }
  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n)
        return true;
      if (/\bCodeMirror-(?:line)?widget\b/.test(n.className) || n.parentNode == display.sizer && n != display.mover)
        return true;
    }
  }
  function posFromMouse(cm, e, liberal) {
    var display = cm.display;
    if (!liberal) {
      var target = e_target(e);
      if (target == display.scrollbarH || target == display.scrollbarH.firstChild || target == display.scrollbarV || target == display.scrollbarV.firstChild || target == display.scrollbarFiller)
        return null;
    }
    var x, y, space = getRect(display.lineSpace);
    try {
      x = e.clientX;
      y = e.clientY;
    } catch (e) {
      return null;
    }
    return coordsChar(cm, x - space.left, y - space.top);
  }
  var lastClick, lastDoubleClick;
  function onMouseDown(e) {
    var cm = this, display = cm.display, doc = cm.doc, sel = doc.sel;
    sel.shift = e.shiftKey;
    if (eventInWidget(display, e)) {
      if (!webkit) {
        display.scroller.draggable = false;
        setTimeout(function () {
          display.scroller.draggable = true;
        }, 100);
      }
      return;
    }
    if (clickInGutter(cm, e))
      return;
    var start = posFromMouse(cm, e);
    switch (e_button(e)) {
    case 3:
      if (captureMiddleClick)
        onContextMenu.call(cm, cm, e);
      return;
    case 2:
      if (start)
        extendSelection(cm.doc, start);
      setTimeout(bind(focusInput, cm), 20);
      e_preventDefault(e);
      return;
    }
    if (!start) {
      if (e_target(e) == display.scroller)
        e_preventDefault(e);
      return;
    }
    if (!cm.state.focused)
      onFocus(cm);
    var now = +new Date(), type = 'single';
    if (lastDoubleClick && lastDoubleClick.time > now - 400 && posEq(lastDoubleClick.pos, start)) {
      type = 'triple';
      e_preventDefault(e);
      setTimeout(bind(focusInput, cm), 20);
      selectLine(cm, start.line);
    } else if (lastClick && lastClick.time > now - 400 && posEq(lastClick.pos, start)) {
      type = 'double';
      lastDoubleClick = {
        time: now,
        pos: start
      };
      e_preventDefault(e);
      var word = findWordAt(getLine(doc, start.line).text, start);
      extendSelection(cm.doc, word.from, word.to);
    } else {
      lastClick = {
        time: now,
        pos: start
      };
    }
    var last = start;
    if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) && !posEq(sel.from, sel.to) && !posLess(start, sel.from) && !posLess(sel.to, start) && type == 'single') {
      var dragEnd = operation(cm, function (e2) {
          if (webkit)
            display.scroller.draggable = false;
          cm.state.draggingText = false;
          off(document, 'mouseup', dragEnd);
          off(display.scroller, 'drop', dragEnd);
          if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
            e_preventDefault(e2);
            extendSelection(cm.doc, start);
            focusInput(cm);
          }
        });
      if (webkit)
        display.scroller.draggable = true;
      cm.state.draggingText = dragEnd;
      if (display.scroller.dragDrop)
        display.scroller.dragDrop();
      on(document, 'mouseup', dragEnd);
      on(display.scroller, 'drop', dragEnd);
      return;
    }
    e_preventDefault(e);
    if (type == 'single')
      extendSelection(cm.doc, clipPos(doc, start));
    var startstart = sel.from, startend = sel.to, lastPos = start;
    function doSelect(cur) {
      if (posEq(lastPos, cur))
        return;
      lastPos = cur;
      if (type == 'single') {
        extendSelection(cm.doc, clipPos(doc, start), cur);
        return;
      }
      startstart = clipPos(doc, startstart);
      startend = clipPos(doc, startend);
      if (type == 'double') {
        var word = findWordAt(getLine(doc, cur.line).text, cur);
        if (posLess(cur, startstart))
          extendSelection(cm.doc, word.from, startend);
        else
          extendSelection(cm.doc, startstart, word.to);
      } else if (type == 'triple') {
        if (posLess(cur, startstart))
          extendSelection(cm.doc, startend, clipPos(doc, Pos(cur.line, 0)));
        else
          extendSelection(cm.doc, startstart, clipPos(doc, Pos(cur.line + 1, 0)));
      }
    }
    var editorSize = getRect(display.wrapper);
    var counter = 0;
    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true);
      if (!cur)
        return;
      if (!posEq(cur, last)) {
        if (!cm.state.focused)
          onFocus(cm);
        last = cur;
        doSelect(cur);
        var visible = visibleLines(display, doc);
        if (cur.line >= visible.to || cur.line < visible.from)
          setTimeout(operation(cm, function () {
            if (counter == curCount)
              extend(e);
          }), 150);
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside)
          setTimeout(operation(cm, function () {
            if (counter != curCount)
              return;
            display.scroller.scrollTop += outside;
            extend(e);
          }), 50);
      }
    }
    function done(e) {
      counter = Infinity;
      var cur = posFromMouse(cm, e);
      if (cur)
        doSelect(cur);
      e_preventDefault(e);
      focusInput(cm);
      off(document, 'mousemove', move);
      off(document, 'mouseup', up);
    }
    var move = operation(cm, function (e) {
        if (!ie && !e_button(e))
          done(e);
        else
          extend(e);
      });
    var up = operation(cm, done);
    on(document, 'mousemove', move);
    on(document, 'mouseup', up);
  }
  function onDrop(e) {
    var cm = this;
    if (eventInWidget(cm.display, e) || cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e)))
      return;
    e_preventDefault(e);
    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
    if (!pos || isReadOnly(cm))
      return;
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length, text = Array(n), read = 0;
      var loadFile = function (file, i) {
        var reader = new FileReader();
        reader.onload = function () {
          text[i] = reader.result;
          if (++read == n) {
            pos = clipPos(cm.doc, pos);
            makeChange(cm.doc, {
              from: pos,
              to: pos,
              text: splitLines(text.join('\n')),
              origin: 'paste'
            }, 'around');
          }
        };
        reader.readAsText(file);
      };
      for (var i = 0; i < n; ++i)
        loadFile(files[i], i);
    } else {
      if (cm.state.draggingText && !(posLess(pos, cm.doc.sel.from) || posLess(cm.doc.sel.to, pos))) {
        cm.state.draggingText(e);
        setTimeout(bind(focusInput, cm), 20);
        return;
      }
      try {
        var text = e.dataTransfer.getData('Text');
        if (text) {
          var curFrom = cm.doc.sel.from, curTo = cm.doc.sel.to;
          setSelection(cm.doc, pos, pos);
          if (cm.state.draggingText)
            replaceRange(cm.doc, '', curFrom, curTo, 'paste');
          cm.replaceSelection(text, null, 'paste');
          focusInput(cm);
          onFocus(cm);
        }
      } catch (e) {
      }
    }
  }
  function clickInGutter(cm, e) {
    var display = cm.display;
    try {
      var mX = e.clientX, mY = e.clientY;
    } catch (e) {
      return false;
    }
    if (mX >= Math.floor(getRect(display.gutters).right))
      return false;
    e_preventDefault(e);
    if (!hasHandler(cm, 'gutterClick'))
      return true;
    var lineBox = getRect(display.lineDiv);
    if (mY > lineBox.bottom)
      return true;
    mY -= lineBox.top - display.viewOffset;
    for (var i = 0; i < cm.options.gutters.length; ++i) {
      var g = display.gutters.childNodes[i];
      if (g && getRect(g).right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.options.gutters[i];
        signalLater(cm, 'gutterClick', cm, line, gutter, e);
        break;
      }
    }
    return true;
  }
  function onDragStart(cm, e) {
    if (ie && !cm.state.draggingText) {
      e_stop(e);
      return;
    }
    if (eventInWidget(cm.display, e))
      return;
    var txt = cm.getSelection();
    e.dataTransfer.setData('Text', txt);
    if (e.dataTransfer.setDragImage) {
      var img = elt('img', null, null, 'position: fixed; left: 0; top: 0;');
      if (opera) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        img._top = img.offsetTop;
      }
      if (safari) {
        if (cm.display.dragImg) {
          img = cm.display.dragImg;
        } else {
          cm.display.dragImg = img;
          img.src = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';
          cm.display.wrapper.appendChild(img);
        }
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (opera)
        img.parentNode.removeChild(img);
    }
  }
  function setScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2)
      return;
    cm.doc.scrollTop = val;
    if (!gecko)
      updateDisplay(cm, [], val);
    if (cm.display.scroller.scrollTop != val)
      cm.display.scroller.scrollTop = val;
    if (cm.display.scrollbarV.scrollTop != val)
      cm.display.scrollbarV.scrollTop = val;
    if (gecko)
      updateDisplay(cm, []);
  }
  function setScrollLeft(cm, val, isScroller) {
    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2)
      return;
    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val)
      cm.display.scroller.scrollLeft = val;
    if (cm.display.scrollbarH.scrollLeft != val)
      cm.display.scrollbarH.scrollLeft = val;
  }
  var wheelSamples = 0, wheelPixelsPerUnit = null;
  if (ie)
    wheelPixelsPerUnit = -0.53;
  else if (gecko)
    wheelPixelsPerUnit = 15;
  else if (chrome)
    wheelPixelsPerUnit = -0.7;
  else if (safari)
    wheelPixelsPerUnit = -1 / 3;
  function onScrollWheel(cm, e) {
    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS)
      dx = e.detail;
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS)
      dy = e.detail;
    else if (dy == null)
      dy = e.wheelDelta;
    var display = cm.display, scroll = display.scroller;
    if (!(dx && scroll.scrollWidth > scroll.clientWidth || dy && scroll.scrollHeight > scroll.clientHeight))
      return;
    if (dy && mac && webkit) {
      for (var cur = e.target; cur != scroll; cur = cur.parentNode) {
        if (cur.lineObj) {
          cm.display.currentWheelTarget = cur;
          break;
        }
      }
    }
    if (dx && !gecko && !opera && wheelPixelsPerUnit != null) {
      if (dy)
        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
      e_preventDefault(e);
      display.wheelStartX = null;
      return;
    }
    if (dy && wheelPixelsPerUnit != null) {
      var pixels = dy * wheelPixelsPerUnit;
      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
      if (pixels < 0)
        top = Math.max(0, top + pixels - 50);
      else
        bot = Math.min(cm.doc.height, bot + pixels + 50);
      updateDisplay(cm, [], {
        top: top,
        bottom: bot
      });
    }
    if (wheelSamples < 20) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft;
        display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx;
        display.wheelDY = dy;
        setTimeout(function () {
          if (display.wheelStartX == null)
            return;
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
          display.wheelStartX = display.wheelStartY = null;
          if (!sample)
            return;
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx;
        display.wheelDY += dy;
      }
    }
  }
  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == 'string') {
      bound = commands[bound];
      if (!bound)
        return false;
    }
    if (cm.display.pollingFast && readInput(cm))
      cm.display.pollingFast = false;
    var doc = cm.doc, prevShift = doc.sel.shift, done = false;
    try {
      if (isReadOnly(cm))
        cm.state.suppressEdits = true;
      if (dropShift)
        doc.sel.shift = false;
      done = bound(cm) != Pass;
    } finally {
      doc.sel.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done;
  }
  function allKeyMaps(cm) {
    var maps = cm.state.keyMaps.slice(0);
    if (cm.options.extraKeys)
      maps.push(cm.options.extraKeys);
    maps.push(cm.options.keyMap);
    return maps;
  }
  var maybeTransition;
  function handleKeyBinding(cm, e) {
    var startMap = getKeyMap(cm.options.keyMap), next = startMap.auto;
    clearTimeout(maybeTransition);
    if (next && !isModifierKey(e))
      maybeTransition = setTimeout(function () {
        if (getKeyMap(cm.options.keyMap) == startMap)
          cm.options.keyMap = next.call ? next.call(null, cm) : next;
      }, 50);
    var name = keyName(e, true), handled = false;
    if (!name)
      return false;
    var keymaps = allKeyMaps(cm);
    if (e.shiftKey) {
      handled = lookupKey('Shift-' + name, keymaps, function (b) {
        return doHandleBinding(cm, b, true);
      }) || lookupKey(name, keymaps, function (b) {
        if (typeof b == 'string' && /^go[A-Z]/.test(b))
          return doHandleBinding(cm, b);
      });
    } else {
      handled = lookupKey(name, keymaps, function (b) {
        return doHandleBinding(cm, b);
      });
    }
    if (handled == 'stop')
      handled = false;
    if (handled) {
      e_preventDefault(e);
      restartBlink(cm);
      if (ie_lt9) {
        e.oldKeyCode = e.keyCode;
        e.keyCode = 0;
      }
    }
    return handled;
  }
  function handleCharBinding(cm, e, ch) {
    var handled = lookupKey('\'' + ch + '\'', allKeyMaps(cm), function (b) {
        return doHandleBinding(cm, b, true);
      });
    if (handled) {
      e_preventDefault(e);
      restartBlink(cm);
    }
    return handled;
  }
  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    if (!cm.state.focused)
      onFocus(cm);
    if (ie && e.keyCode == 27) {
      e.returnValue = false;
    }
    if (cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e)))
      return;
    var code = e.keyCode;
    cm.doc.sel.shift = code == 16 || e.shiftKey;
    var handled = handleKeyBinding(cm, e);
    if (opera) {
      lastStoppedKey = handled ? code : null;
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
        cm.replaceSelection('');
    }
  }
  function onKeyPress(e) {
    var cm = this;
    if (cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e)))
      return;
    var keyCode = e.keyCode, charCode = e.charCode;
    if (opera && keyCode == lastStoppedKey) {
      lastStoppedKey = null;
      e_preventDefault(e);
      return;
    }
    if ((opera && (!e.which || e.which < 10) || khtml) && handleKeyBinding(cm, e))
      return;
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    if (this.options.electricChars && this.doc.mode.electricChars && this.options.smartIndent && !isReadOnly(this) && this.doc.mode.electricChars.indexOf(ch) > -1)
      setTimeout(operation(cm, function () {
        indentLine(cm, cm.doc.sel.to.line, 'smart');
      }), 75);
    if (handleCharBinding(cm, e, ch))
      return;
    if (ie && !ie_lt9)
      cm.display.inputHasSelection = null;
    fastPoll(cm);
  }
  function onFocus(cm) {
    if (cm.options.readOnly == 'nocursor')
      return;
    if (!cm.state.focused) {
      signal(cm, 'focus', cm);
      cm.state.focused = true;
      if (cm.display.wrapper.className.search(/\bCodeMirror-focused\b/) == -1)
        cm.display.wrapper.className += ' CodeMirror-focused';
      resetInput(cm, true);
    }
    slowPoll(cm);
    restartBlink(cm);
  }
  function onBlur(cm) {
    if (cm.state.focused) {
      signal(cm, 'blur', cm);
      cm.state.focused = false;
      cm.display.wrapper.className = cm.display.wrapper.className.replace(' CodeMirror-focused', '');
    }
    clearInterval(cm.display.blinker);
    setTimeout(function () {
      if (!cm.state.focused)
        cm.doc.sel.shift = false;
    }, 150);
  }
  var detectingSelectAll;
  function onContextMenu(cm, e) {
    var display = cm.display, sel = cm.doc.sel;
    if (eventInWidget(display, e))
      return;
    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
    if (!pos || opera)
      return;
    if (posEq(sel.from, sel.to) || posLess(pos, sel.from) || !posLess(pos, sel.to))
      operation(cm, setSelection)(cm.doc, pos, pos);
    var oldCSS = display.input.style.cssText;
    display.inputDiv.style.position = 'absolute';
    display.input.style.cssText = 'position: fixed; width: 30px; height: 30px; top: ' + (e.clientY - 5) + 'px; left: ' + (e.clientX - 5) + 'px; z-index: 1000; background: white; outline: none;' + 'border-width: 0; outline: none; overflow: hidden; opacity: .05; -ms-opacity: .05; filter: alpha(opacity=5);';
    focusInput(cm);
    resetInput(cm, true);
    if (posEq(sel.from, sel.to))
      display.input.value = display.prevInput = ' ';
    function rehide() {
      display.inputDiv.style.position = 'relative';
      display.input.style.cssText = oldCSS;
      if (ie_lt9)
        display.scrollbarV.scrollTop = display.scroller.scrollTop = scrollPos;
      slowPoll(cm);
      if (display.input.selectionStart != null && (!ie || ie_lt9)) {
        clearTimeout(detectingSelectAll);
        var extval = display.input.value = ' ' + (posEq(sel.from, sel.to) ? '' : display.input.value), i = 0;
        display.prevInput = ' ';
        display.input.selectionStart = 1;
        display.input.selectionEnd = extval.length;
        var poll = function () {
          if (display.prevInput == ' ' && display.input.selectionStart == 0)
            operation(cm, commands.selectAll)(cm);
          else if (i++ < 10)
            detectingSelectAll = setTimeout(poll, 500);
          else
            resetInput(cm);
        };
        detectingSelectAll = setTimeout(poll, 200);
      }
    }
    if (captureMiddleClick) {
      e_stop(e);
      var mouseup = function () {
        off(window, 'mouseup', mouseup);
        setTimeout(rehide, 20);
      };
      on(window, 'mouseup', mouseup);
    } else {
      setTimeout(rehide, 50);
    }
  }
  function changeEnd(change) {
    if (!change.text)
      return change.to;
    return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
  }
  function clipPostChange(doc, change, pos) {
    if (!posLess(change.from, pos))
      return clipPos(doc, pos);
    var diff = change.text.length - 1 - (change.to.line - change.from.line);
    if (pos.line > change.to.line + diff) {
      var preLine = pos.line - diff, lastLine = doc.first + doc.size - 1;
      if (preLine > lastLine)
        return Pos(lastLine, getLine(doc, lastLine).text.length);
      return clipToLen(pos, getLine(doc, preLine).text.length);
    }
    if (pos.line == change.to.line + diff)
      return clipToLen(pos, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0) + getLine(doc, change.to.line).text.length - change.to.ch);
    var inside = pos.line - change.from.line;
    return clipToLen(pos, change.text[inside].length + (inside ? 0 : change.from.ch));
  }
  function computeSelAfterChange(doc, change, hint) {
    if (hint && typeof hint == 'object')
      return {
        anchor: clipPostChange(doc, change, hint.anchor),
        head: clipPostChange(doc, change, hint.head)
      };
    if (hint == 'start')
      return {
        anchor: change.from,
        head: change.from
      };
    var end = changeEnd(change);
    if (hint == 'around')
      return {
        anchor: change.from,
        head: end
      };
    if (hint == 'end')
      return {
        anchor: end,
        head: end
      };
    var adjustPos = function (pos) {
      if (posLess(pos, change.from))
        return pos;
      if (!posLess(change.to, pos))
        return end;
      var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
      if (pos.line == change.to.line)
        ch += end.ch - change.to.ch;
      return Pos(line, ch);
    };
    return {
      anchor: adjustPos(doc.sel.anchor),
      head: adjustPos(doc.sel.head)
    };
  }
  function filterChange(doc, change) {
    var obj = {
        canceled: false,
        from: change.from,
        to: change.to,
        text: change.text,
        origin: change.origin,
        update: function (from, to, text, origin) {
          if (from)
            this.from = clipPos(doc, from);
          if (to)
            this.to = clipPos(doc, to);
          if (text)
            this.text = text;
          if (origin !== undefined)
            this.origin = origin;
        },
        cancel: function () {
          this.canceled = true;
        }
      };
    signal(doc, 'beforeChange', doc, obj);
    if (doc.cm)
      signal(doc.cm, 'beforeChange', doc.cm, obj);
    if (obj.canceled)
      return null;
    return {
      from: obj.from,
      to: obj.to,
      text: obj.text,
      origin: obj.origin
    };
  }
  function makeChange(doc, change, selUpdate, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp)
        return operation(doc.cm, makeChange)(doc, change, selUpdate, ignoreReadOnly);
      if (doc.cm.state.suppressEdits)
        return;
    }
    if (hasHandler(doc, 'beforeChange') || doc.cm && hasHandler(doc.cm, 'beforeChange')) {
      change = filterChange(doc, change);
      if (!change)
        return;
    }
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 1; --i)
        makeChangeNoReadonly(doc, {
          from: split[i].from,
          to: split[i].to,
          text: ['']
        });
      if (split.length)
        makeChangeNoReadonly(doc, {
          from: split[0].from,
          to: split[0].to,
          text: change.text
        }, selUpdate);
    } else {
      makeChangeNoReadonly(doc, change, selUpdate);
    }
  }
  function makeChangeNoReadonly(doc, change, selUpdate) {
    var selAfter = computeSelAfterChange(doc, change, selUpdate);
    addToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);
    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];
    linkedDocs(doc, function (doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }
  function makeChangeFromHistory(doc, type) {
    if (doc.cm && doc.cm.state.suppressEdits)
      return;
    var hist = doc.history;
    var event = (type == 'undo' ? hist.done : hist.undone).pop();
    if (!event)
      return;
    hist.dirtyCounter += type == 'undo' ? -1 : 1;
    var anti = {
        changes: [],
        anchorBefore: event.anchorAfter,
        headBefore: event.headAfter,
        anchorAfter: event.anchorBefore,
        headAfter: event.headBefore
      };
    (type == 'undo' ? hist.undone : hist.done).push(anti);
    for (var i = event.changes.length - 1; i >= 0; --i) {
      var change = event.changes[i];
      change.origin = type;
      anti.changes.push(historyChangeFromChange(doc, change));
      var after = i ? computeSelAfterChange(doc, change, null) : {
          anchor: event.anchorBefore,
          head: event.headBefore
        };
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      var rebased = [];
      linkedDocs(doc, function (doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    }
  }
  function shiftDoc(doc, distance) {
    function shiftPos(pos) {
      return Pos(pos.line + distance, pos.ch);
    }
    doc.first += distance;
    if (doc.cm)
      regChange(doc.cm, doc.first, doc.first, distance);
    doc.sel.head = shiftPos(doc.sel.head);
    doc.sel.anchor = shiftPos(doc.sel.anchor);
    doc.sel.from = shiftPos(doc.sel.from);
    doc.sel.to = shiftPos(doc.sel.to);
  }
  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp)
      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return;
    }
    if (change.from.line > doc.lastLine())
      return;
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {
        from: Pos(doc.first, 0),
        to: Pos(change.to.line + shift, change.to.ch),
        text: [lst(change.text)],
        origin: change.origin
      };
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = {
        from: change.from,
        to: Pos(last, getLine(doc, last).text.length),
        text: [change.text[0]],
        origin: change.origin
      };
    }
    change.removed = getBetween(doc, change.from, change.to);
    if (!selAfter)
      selAfter = computeSelAfterChange(doc, change, null);
    if (doc.cm)
      makeChangeSingleDocInEditor(doc.cm, change, spans, selAfter);
    else
      updateDoc(doc, change, spans, selAfter);
  }
  function makeChangeSingleDocInEditor(cm, change, spans, selAfter) {
    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;
    var recomputeMaxLength = false, checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(doc, getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function (line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true;
        }
      });
    }
    if (!posLess(doc.sel.head, change.from) && !posLess(change.to, doc.sel.head))
      cm.curOp.cursorActivity = true;
    updateDoc(doc, change, spans, selAfter, estimateHeight(cm));
    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
        var len = lineLength(doc, line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength)
        cm.curOp.updateMaxLine = true;
    }
    doc.frontier = Math.min(doc.frontier, from.line);
    startWorker(cm, 400);
    var lendiff = change.text.length - (to.line - from.line) - 1;
    regChange(cm, from.line, to.line + 1, lendiff);
    if (hasHandler(cm, 'change')) {
      var changeObj = {
          from: from,
          to: to,
          text: change.text,
          removed: change.removed,
          origin: change.origin
        };
      if (cm.curOp.textChanged) {
        for (var cur = cm.curOp.textChanged; cur.next; cur = cur.next) {
        }
        cur.next = changeObj;
      } else
        cm.curOp.textChanged = changeObj;
    }
  }
  function replaceRange(doc, code, from, to, origin) {
    if (!to)
      to = from;
    if (posLess(to, from)) {
      var tmp = to;
      to = from;
      from = tmp;
    }
    if (typeof code == 'string')
      code = splitLines(code);
    makeChange(doc, {
      from: from,
      to: to,
      text: code,
      origin: origin
    }, null);
  }
  function Pos(line, ch) {
    if (!(this instanceof Pos))
      return new Pos(line, ch);
    this.line = line;
    this.ch = ch;
  }
  CodeMirror.Pos = Pos;
  function posEq(a, b) {
    return a.line == b.line && a.ch == b.ch;
  }
  function posLess(a, b) {
    return a.line < b.line || a.line == b.line && a.ch < b.ch;
  }
  function copyPos(x) {
    return Pos(x.line, x.ch);
  }
  function clipLine(doc, n) {
    return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));
  }
  function clipPos(doc, pos) {
    if (pos.line < doc.first)
      return Pos(doc.first, 0);
    var last = doc.first + doc.size - 1;
    if (pos.line > last)
      return Pos(last, getLine(doc, last).text.length);
    return clipToLen(pos, getLine(doc, pos.line).text.length);
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen)
      return Pos(pos.line, linelen);
    else if (ch < 0)
      return Pos(pos.line, 0);
    else
      return pos;
  }
  function isLine(doc, l) {
    return l >= doc.first && l < doc.first + doc.size;
  }
  function extendSelection(doc, pos, other, bias) {
    if (doc.sel.shift || doc.sel.extend) {
      var anchor = doc.sel.anchor;
      if (other) {
        var posBefore = posLess(pos, anchor);
        if (posBefore != posLess(other, anchor)) {
          anchor = pos;
          pos = other;
        } else if (posBefore != posLess(pos, other)) {
          pos = other;
        }
      }
      setSelection(doc, anchor, pos, bias);
    } else {
      setSelection(doc, pos, other || pos, bias);
    }
    if (doc.cm)
      doc.cm.curOp.userSelChange = true;
  }
  function filterSelectionChange(doc, anchor, head) {
    var obj = {
        anchor: anchor,
        head: head
      };
    signal(doc, 'beforeSelectionChange', doc, obj);
    if (doc.cm)
      signal(doc.cm, 'beforeSelectionChange', doc.cm, obj);
    obj.anchor = clipPos(doc, obj.anchor);
    obj.head = clipPos(doc, obj.head);
    return obj;
  }
  function setSelection(doc, anchor, head, bias, checkAtomic) {
    if (!checkAtomic && hasHandler(doc, 'beforeSelectionChange') || doc.cm && hasHandler(doc.cm, 'beforeSelectionChange')) {
      var filtered = filterSelectionChange(doc, anchor, head);
      head = filtered.head;
      anchor = filtered.anchor;
    }
    var sel = doc.sel;
    sel.goalColumn = null;
    if (checkAtomic || !posEq(anchor, sel.anchor))
      anchor = skipAtomic(doc, anchor, bias, checkAtomic != 'push');
    if (checkAtomic || !posEq(head, sel.head))
      head = skipAtomic(doc, head, bias, checkAtomic != 'push');
    if (posEq(sel.anchor, anchor) && posEq(sel.head, head))
      return;
    sel.anchor = anchor;
    sel.head = head;
    var inv = posLess(head, anchor);
    sel.from = inv ? head : anchor;
    sel.to = inv ? anchor : head;
    if (doc.cm)
      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = doc.cm.curOp.cursorActivity = true;
    signalLater(doc, 'cursorActivity', doc);
  }
  function reCheckSelection(cm) {
    setSelection(cm.doc, cm.doc.sel.from, cm.doc.sel.to, null, 'push');
  }
  function skipAtomic(doc, pos, bias, mayClear) {
    var flipped = false, curPos = pos;
    var dir = bias || 1;
    doc.cantEdit = false;
    search:
      for (;;) {
        var line = getLine(doc, curPos.line);
        if (line.markedSpans) {
          for (var i = 0; i < line.markedSpans.length; ++i) {
            var sp = line.markedSpans[i], m = sp.marker;
            if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) && (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {
              if (mayClear) {
                signal(m, 'beforeCursorEnter');
                if (m.explicitlyCleared) {
                  if (!line.markedSpans)
                    break;
                  else {
                    --i;
                    continue;
                  }
                }
              }
              if (!m.atomic)
                continue;
              var newPos = m.find()[dir < 0 ? 'from' : 'to'];
              if (posEq(newPos, curPos)) {
                newPos.ch += dir;
                if (newPos.ch < 0) {
                  if (newPos.line > doc.first)
                    newPos = clipPos(doc, Pos(newPos.line - 1));
                  else
                    newPos = null;
                } else if (newPos.ch > line.text.length) {
                  if (newPos.line < doc.first + doc.size - 1)
                    newPos = Pos(newPos.line + 1, 0);
                  else
                    newPos = null;
                }
                if (!newPos) {
                  if (flipped) {
                    if (!mayClear)
                      return skipAtomic(doc, pos, bias, true);
                    doc.cantEdit = true;
                    return Pos(doc.first, 0);
                  }
                  flipped = true;
                  newPos = pos;
                  dir = -dir;
                }
              }
              curPos = newPos;
              continue search;
            }
          }
        }
        return curPos;
      }
  }
  function scrollCursorIntoView(cm) {
    var coords = scrollPosIntoView(cm, cm.doc.sel.head);
    if (!cm.state.focused)
      return;
    var display = cm.display, box = getRect(display.sizer), doScroll = null, pTop = paddingTop(cm.display);
    if (coords.top + pTop + box.top < 0)
      doScroll = true;
    else if (coords.bottom + pTop + box.top > (window.innerHeight || document.documentElement.clientHeight))
      doScroll = false;
    if (doScroll != null && !phantom) {
      var hidden = display.cursor.style.display == 'none';
      if (hidden) {
        display.cursor.style.display = '';
        display.cursor.style.left = coords.left + 'px';
        display.cursor.style.top = coords.top - display.viewOffset + 'px';
      }
      display.cursor.scrollIntoView(doScroll);
      if (hidden)
        display.cursor.style.display = 'none';
    }
  }
  function scrollPosIntoView(cm, pos, margin) {
    if (margin == null)
      margin = 0;
    for (;;) {
      var changed = false, coords = cursorCoords(cm, pos);
      var scrollPos = calculateScrollPos(cm, coords.left, coords.top - margin, coords.left, coords.bottom + margin);
      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        setScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1)
          changed = true;
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1)
          changed = true;
      }
      if (!changed)
        return coords;
    }
  }
  function scrollIntoView(cm, x1, y1, x2, y2) {
    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
    if (scrollPos.scrollTop != null)
      setScrollTop(cm, scrollPos.scrollTop);
    if (scrollPos.scrollLeft != null)
      setScrollLeft(cm, scrollPos.scrollLeft);
  }
  function calculateScrollPos(cm, x1, y1, x2, y2) {
    var display = cm.display, pt = paddingTop(display);
    y1 += pt;
    y2 += pt;
    if (y1 < 0)
      y1 = 0;
    var screen = display.scroller.clientHeight - scrollerCutOff, screentop = display.scroller.scrollTop, result = {};
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = y1 < pt + 10, atBottom = y2 + pt > docBottom - 10;
    if (y1 < screentop) {
      result.scrollTop = atTop ? 0 : y1;
    } else if (y2 > screentop + screen) {
      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
      if (newTop != screentop)
        result.scrollTop = newTop;
    }
    var screenw = display.scroller.clientWidth - scrollerCutOff, screenleft = display.scroller.scrollLeft;
    x1 += display.gutters.offsetWidth;
    x2 += display.gutters.offsetWidth;
    var gutterw = display.gutters.offsetWidth;
    var atLeft = x1 < gutterw + 10;
    if (x1 < screenleft + gutterw || atLeft) {
      if (atLeft)
        x1 = 0;
      result.scrollLeft = Math.max(0, x1 - 10 - gutterw);
    } else if (x2 > screenw + screenleft - 3) {
      result.scrollLeft = x2 + 10 - screenw;
    }
    return result;
  }
  function updateScrollPos(cm, left, top) {
    cm.curOp.updateScrollPos = {
      scrollLeft: left == null ? cm.doc.scrollLeft : left,
      scrollTop: top == null ? cm.doc.scrollTop : top
    };
  }
  function addToScrollPos(cm, left, top) {
    var pos = cm.curOp.updateScrollPos || (cm.curOp.updateScrollPos = {
        scrollLeft: cm.doc.scrollLeft,
        scrollTop: cm.doc.scrollTop
      });
    var scroll = cm.display.scroller;
    pos.scrollTop = Math.max(0, Math.min(scroll.scrollHeight - scroll.clientHeight, pos.scrollTop + top));
    pos.scrollLeft = Math.max(0, Math.min(scroll.scrollWidth - scroll.clientWidth, pos.scrollLeft + left));
  }
  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc;
    if (!how)
      how = 'add';
    if (how == 'smart') {
      if (!cm.doc.mode.indent)
        how = 'prev';
      else
        var state = getStateBefore(cm, n);
    }
    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
    if (how == 'smart') {
      indentation = cm.doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass) {
        if (!aggressive)
          return;
        how = 'prev';
      }
    }
    if (how == 'prev') {
      if (n > doc.first)
        indentation = countColumn(getLine(doc, n - 1).text, null, tabSize);
      else
        indentation = 0;
    } else if (how == 'add') {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == 'subtract') {
      indentation = curSpace - cm.options.indentUnit;
    }
    indentation = Math.max(0, indentation);
    var indentString = '', pos = 0;
    if (cm.options.indentWithTabs)
      for (var i = Math.floor(indentation / tabSize); i; --i) {
        pos += tabSize;
        indentString += '\t';
      }
    if (pos < indentation)
      indentString += spaceStr(indentation - pos);
    if (indentString != curSpaceString)
      replaceRange(cm.doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), '+input');
    line.stateAfter = null;
  }
  function changeLine(cm, handle, op) {
    var no = handle, line = handle, doc = cm.doc;
    if (typeof handle == 'number')
      line = getLine(doc, clipLine(doc, handle));
    else
      no = lineNo(handle);
    if (no == null)
      return null;
    if (op(line, no))
      regChange(cm, no, no + 1);
    else
      return null;
    return line;
  }
  function findPosH(doc, pos, dir, unit, visually) {
    var line = pos.line, ch = pos.ch;
    var lineObj = getLine(doc, line);
    var possible = true;
    function findNextLine() {
      var l = line + dir;
      if (l < doc.first || l >= doc.first + doc.size)
        return possible = false;
      line = l;
      return lineObj = getLine(doc, l);
    }
    function moveOnce(boundToLine) {
      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);
      if (next == null) {
        if (!boundToLine && findNextLine()) {
          if (visually)
            ch = (dir < 0 ? lineRight : lineLeft)(lineObj);
          else
            ch = dir < 0 ? lineObj.text.length : 0;
        } else
          return possible = false;
      } else
        ch = next;
      return true;
    }
    if (unit == 'char')
      moveOnce();
    else if (unit == 'column')
      moveOnce(true);
    else if (unit == 'word' || unit == 'group') {
      var sawType = null, group = unit == 'group';
      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first))
          break;
        var cur = lineObj.text.charAt(ch) || '\n';
        var type = isWordChar(cur) ? 'w' : !group ? null : /\s/.test(cur) ? null : 'p';
        if (sawType && sawType != type) {
          if (dir < 0) {
            dir = 1;
            moveOnce();
          }
          break;
        }
        if (type)
          sawType = type;
        if (dir > 0 && !moveOnce(!first))
          break;
      }
    }
    var result = skipAtomic(doc, Pos(line, ch), dir, true);
    if (!possible)
      result.hitSide = true;
    return result;
  }
  function findPosV(cm, pos, dir, unit) {
    var doc = cm.doc, x = pos.left, y;
    if (unit == 'page') {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : 0.5) * textHeight(cm.display));
    } else if (unit == 'line') {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    for (;;) {
      var target = coordsChar(cm, x, y);
      if (!target.outside)
        break;
      if (dir < 0 ? y <= 0 : y >= doc.height) {
        target.hitSide = true;
        break;
      }
      y += dir * 5;
    }
    return target;
  }
  function findWordAt(line, pos) {
    var start = pos.ch, end = pos.ch;
    if (line) {
      if (pos.after === false || end == line.length)
        --start;
      else
        ++end;
      var startChar = line.charAt(start);
      var check = isWordChar(startChar) ? isWordChar : /\s/.test(startChar) ? function (ch) {
          return /\s/.test(ch);
        } : function (ch) {
          return !/\s/.test(ch) && !isWordChar(ch);
        };
      while (start > 0 && check(line.charAt(start - 1)))
        --start;
      while (end < line.length && check(line.charAt(end)))
        ++end;
    }
    return {
      from: Pos(pos.line, start),
      to: Pos(pos.line, end)
    };
  }
  function selectLine(cm, line) {
    extendSelection(cm.doc, Pos(line, 0), clipPos(cm.doc, Pos(line + 1, 0)));
  }
  CodeMirror.prototype = {
    focus: function () {
      window.focus();
      focusInput(this);
      onFocus(this);
      fastPoll(this);
    },
    setOption: function (option, value) {
      var options = this.options, old = options[option];
      if (options[option] == value && option != 'mode')
        return;
      options[option] = value;
      if (optionHandlers.hasOwnProperty(option))
        operation(this, optionHandlers[option])(this, value, old);
    },
    getOption: function (option) {
      return this.options[option];
    },
    getDoc: function () {
      return this.doc;
    },
    addKeyMap: function (map, bottom) {
      this.state.keyMaps[bottom ? 'push' : 'unshift'](map);
    },
    removeKeyMap: function (map) {
      var maps = this.state.keyMaps;
      for (var i = 0; i < maps.length; ++i)
        if ((typeof map == 'string' ? maps[i].name : maps[i]) == map) {
          maps.splice(i, 1);
          return true;
        }
    },
    addOverlay: operation(null, function (spec, options) {
      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
      if (mode.startState)
        throw new Error('Overlays may not be stateful.');
      this.state.overlays.push({
        mode: mode,
        modeSpec: spec,
        opaque: options && options.opaque
      });
      this.state.modeGen++;
      regChange(this);
    }),
    removeOverlay: operation(null, function (spec) {
      var overlays = this.state.overlays;
      for (var i = 0; i < overlays.length; ++i) {
        if (overlays[i].modeSpec == spec) {
          overlays.splice(i, 1);
          this.state.modeGen++;
          regChange(this);
          return;
        }
      }
    }),
    indentLine: operation(null, function (n, dir, aggressive) {
      if (typeof dir != 'string') {
        if (dir == null)
          dir = this.options.smartIndent ? 'smart' : 'prev';
        else
          dir = dir ? 'add' : 'subtract';
      }
      if (isLine(this.doc, n))
        indentLine(this, n, dir, aggressive);
    }),
    indentSelection: operation(null, function (how) {
      var sel = this.doc.sel;
      if (posEq(sel.from, sel.to))
        return indentLine(this, sel.from.line, how);
      var e = sel.to.line - (sel.to.ch ? 0 : 1);
      for (var i = sel.from.line; i <= e; ++i)
        indentLine(this, i, how);
    }),
    getTokenAt: function (pos) {
      var doc = this.doc;
      pos = clipPos(doc, pos);
      var state = getStateBefore(this, pos.line), mode = this.doc.mode;
      var line = getLine(doc, pos.line);
      var stream = new StringStream(line.text, this.options.tabSize);
      while (stream.pos < pos.ch && !stream.eol()) {
        stream.start = stream.pos;
        var style = mode.token(stream, state);
      }
      return {
        start: stream.start,
        end: stream.pos,
        string: stream.current(),
        className: style || null,
        type: style || null,
        state: state
      };
    },
    getStateAfter: function (line) {
      var doc = this.doc;
      line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);
      return getStateBefore(this, line + 1);
    },
    cursorCoords: function (start, mode) {
      var pos, sel = this.doc.sel;
      if (start == null)
        pos = sel.head;
      else if (typeof start == 'object')
        pos = clipPos(this.doc, start);
      else
        pos = start ? sel.from : sel.to;
      return cursorCoords(this, pos, mode || 'page');
    },
    charCoords: function (pos, mode) {
      return charCoords(this, clipPos(this.doc, pos), mode || 'page');
    },
    coordsChar: function (coords, mode) {
      coords = fromCoordSystem(this, coords, mode || 'page');
      return coordsChar(this, coords.left, coords.top);
    },
    defaultTextHeight: function () {
      return textHeight(this.display);
    },
    defaultCharWidth: function () {
      return charWidth(this.display);
    },
    setGutterMarker: operation(null, function (line, gutterID, value) {
      return changeLine(this, line, function (line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers))
          line.gutterMarkers = null;
        return true;
      });
    }),
    clearGutter: operation(null, function (gutterID) {
      var cm = this, doc = cm.doc, i = doc.first;
      doc.iter(function (line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          line.gutterMarkers[gutterID] = null;
          regChange(cm, i, i + 1);
          if (isEmpty(line.gutterMarkers))
            line.gutterMarkers = null;
        }
        ++i;
      });
    }),
    addLineClass: operation(null, function (handle, where, cls) {
      return changeLine(this, handle, function (line) {
        var prop = where == 'text' ? 'textClass' : where == 'background' ? 'bgClass' : 'wrapClass';
        if (!line[prop])
          line[prop] = cls;
        else if (new RegExp('\\b' + cls + '\\b').test(line[prop]))
          return false;
        else
          line[prop] += ' ' + cls;
        return true;
      });
    }),
    removeLineClass: operation(null, function (handle, where, cls) {
      return changeLine(this, handle, function (line) {
        var prop = where == 'text' ? 'textClass' : where == 'background' ? 'bgClass' : 'wrapClass';
        var cur = line[prop];
        if (!cur)
          return false;
        else if (cls == null)
          line[prop] = null;
        else {
          var upd = cur.replace(new RegExp('^' + cls + '\\b\\s*|\\s*\\b' + cls + '\\b'), '');
          if (upd == cur)
            return false;
          line[prop] = upd || null;
        }
        return true;
      });
    }),
    addLineWidget: operation(null, function (handle, node, options) {
      return addLineWidget(this, handle, node, options);
    }),
    removeLineWidget: function (widget) {
      widget.clear();
    },
    lineInfo: function (line) {
      if (typeof line == 'number') {
        if (!isLine(this.doc, line))
          return null;
        var n = line;
        line = getLine(this.doc, line);
        if (!line)
          return null;
      } else {
        var n = lineNo(line);
        if (n == null)
          return null;
      }
      return {
        line: n,
        handle: line,
        text: line.text,
        gutterMarkers: line.gutterMarkers,
        textClass: line.textClass,
        bgClass: line.bgClass,
        wrapClass: line.wrapClass,
        widgets: line.widgets
      };
    },
    getViewport: function () {
      return {
        from: this.display.showingFrom,
        to: this.display.showingTo
      };
    },
    addWidget: function (pos, node, scroll, vert, horiz) {
      var display = this.display;
      pos = cursorCoords(this, clipPos(this.doc, pos));
      var top = pos.bottom, left = pos.left;
      node.style.position = 'absolute';
      display.sizer.appendChild(node);
      if (vert == 'over') {
        top = pos.top;
      } else if (vert == 'above' || vert == 'near') {
        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
          top = pos.top - node.offsetHeight;
        else if (pos.bottom + node.offsetHeight <= vspace)
          top = pos.bottom;
        if (left + node.offsetWidth > hspace)
          left = hspace - node.offsetWidth;
      }
      node.style.top = top + paddingTop(display) + 'px';
      node.style.left = node.style.right = '';
      if (horiz == 'right') {
        left = display.sizer.clientWidth - node.offsetWidth;
        node.style.right = '0px';
      } else {
        if (horiz == 'left')
          left = 0;
        else if (horiz == 'middle')
          left = (display.sizer.clientWidth - node.offsetWidth) / 2;
        node.style.left = left + 'px';
      }
      if (scroll)
        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
    },
    triggerOnKeyDown: operation(null, onKeyDown),
    execCommand: function (cmd) {
      return commands[cmd](this);
    },
    findPosH: function (from, amount, unit, visually) {
      var dir = 1;
      if (amount < 0) {
        dir = -1;
        amount = -amount;
      }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        cur = findPosH(this.doc, cur, dir, unit, visually);
        if (cur.hitSide)
          break;
      }
      return cur;
    },
    moveH: operation(null, function (dir, unit) {
      var sel = this.doc.sel, pos;
      if (sel.shift || sel.extend || posEq(sel.from, sel.to))
        pos = findPosH(this.doc, sel.head, dir, unit, this.options.rtlMoveVisually);
      else
        pos = dir < 0 ? sel.from : sel.to;
      extendSelection(this.doc, pos, pos, dir);
    }),
    deleteH: operation(null, function (dir, unit) {
      var sel = this.doc.sel;
      if (!posEq(sel.from, sel.to))
        replaceRange(this.doc, '', sel.from, sel.to, '+delete');
      else
        replaceRange(this.doc, '', sel.from, findPosH(this.doc, sel.head, dir, unit, false), '+delete');
      this.curOp.userSelChange = true;
    }),
    findPosV: function (from, amount, unit, goalColumn) {
      var dir = 1, x = goalColumn;
      if (amount < 0) {
        dir = -1;
        amount = -amount;
      }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        var coords = cursorCoords(this, cur, 'div');
        if (x == null)
          x = coords.left;
        else
          coords.left = x;
        cur = findPosV(this, coords, dir, unit);
        if (cur.hitSide)
          break;
      }
      return cur;
    },
    moveV: operation(null, function (dir, unit) {
      var sel = this.doc.sel;
      var pos = cursorCoords(this, sel.head, 'div');
      if (sel.goalColumn != null)
        pos.left = sel.goalColumn;
      var target = findPosV(this, pos, dir, unit);
      if (unit == 'page')
        addToScrollPos(this, 0, charCoords(this, target, 'div').top - pos.top);
      extendSelection(this.doc, target, target, dir);
      sel.goalColumn = pos.left;
    }),
    toggleOverwrite: function () {
      if (this.state.overwrite = !this.state.overwrite)
        this.display.cursor.className += ' CodeMirror-overwrite';
      else
        this.display.cursor.className = this.display.cursor.className.replace(' CodeMirror-overwrite', '');
    },
    hasFocus: function () {
      return this.state.focused;
    },
    scrollTo: operation(null, function (x, y) {
      updateScrollPos(this, x, y);
    }),
    getScrollInfo: function () {
      var scroller = this.display.scroller, co = scrollerCutOff;
      return {
        left: scroller.scrollLeft,
        top: scroller.scrollTop,
        height: scroller.scrollHeight - co,
        width: scroller.scrollWidth - co,
        clientHeight: scroller.clientHeight - co,
        clientWidth: scroller.clientWidth - co
      };
    },
    scrollIntoView: operation(null, function (pos, margin) {
      if (typeof pos == 'number')
        pos = Pos(pos, 0);
      if (!margin)
        margin = 0;
      var coords = pos;
      if (!pos || pos.line != null) {
        this.curOp.scrollToPos = pos ? clipPos(this.doc, pos) : this.doc.sel.head;
        this.curOp.scrollToPosMargin = margin;
        coords = cursorCoords(this, this.curOp.scrollToPos);
      }
      var sPos = calculateScrollPos(this, coords.left, coords.top - margin, coords.right, coords.bottom + margin);
      updateScrollPos(this, sPos.scrollLeft, sPos.scrollTop);
    }),
    setSize: function (width, height) {
      function interpret(val) {
        return typeof val == 'number' || /^\d+$/.test(String(val)) ? val + 'px' : val;
      }
      if (width != null)
        this.display.wrapper.style.width = interpret(width);
      if (height != null)
        this.display.wrapper.style.height = interpret(height);
      this.refresh();
    },
    on: function (type, f) {
      on(this, type, f);
    },
    off: function (type, f) {
      off(this, type, f);
    },
    operation: function (f) {
      return runInOp(this, f);
    },
    refresh: operation(null, function () {
      clearCaches(this);
      updateScrollPos(this, this.doc.scrollLeft, this.doc.scrollTop);
      regChange(this);
    }),
    swapDoc: operation(null, function (doc) {
      var old = this.doc;
      old.cm = null;
      attachDoc(this, doc);
      clearCaches(this);
      resetInput(this, true);
      updateScrollPos(this, doc.scrollLeft, doc.scrollTop);
      return old;
    }),
    getInputField: function () {
      return this.display.input;
    },
    getWrapperElement: function () {
      return this.display.wrapper;
    },
    getScrollerElement: function () {
      return this.display.scroller;
    },
    getGutterElement: function () {
      return this.display.gutters;
    }
  };
  var optionHandlers = CodeMirror.optionHandlers = {};
  var defaults = CodeMirror.defaults = {};
  function option(name, deflt, handle, notOnInit) {
    CodeMirror.defaults[name] = deflt;
    if (handle)
      optionHandlers[name] = notOnInit ? function (cm, val, old) {
        if (old != Init)
          handle(cm, val, old);
      } : handle;
  }
  var Init = CodeMirror.Init = {
      toString: function () {
        return 'CodeMirror.Init';
      }
    };
  option('value', '', function (cm, val) {
    cm.setValue(val);
  }, true);
  option('mode', null, function (cm, val) {
    cm.doc.modeOption = val;
    loadMode(cm);
  }, true);
  option('indentUnit', 2, loadMode, true);
  option('indentWithTabs', false);
  option('smartIndent', true);
  option('tabSize', 4, function (cm) {
    loadMode(cm);
    clearCaches(cm);
    regChange(cm);
  }, true);
  option('electricChars', true);
  option('rtlMoveVisually', !windows);
  option('theme', 'default', function (cm) {
    themeChanged(cm);
    guttersChanged(cm);
  }, true);
  option('keyMap', 'default', keyMapChanged);
  option('extraKeys', null);
  option('onKeyEvent', null);
  option('onDragEvent', null);
  option('lineWrapping', false, wrappingChanged, true);
  option('gutters', [], function (cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option('fixedGutter', true, function (cm, val) {
    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + 'px' : '0';
    cm.refresh();
  }, true);
  option('lineNumbers', false, function (cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option('firstLineNumber', 1, guttersChanged, true);
  option('lineNumberFormatter', function (integer) {
    return integer;
  }, guttersChanged, true);
  option('showCursorWhenSelecting', false, updateSelection, true);
  option('readOnly', false, function (cm, val) {
    if (val == 'nocursor') {
      onBlur(cm);
      cm.display.input.blur();
    } else if (!val)
      resetInput(cm, true);
  });
  option('dragDrop', true);
  option('cursorBlinkRate', 530);
  option('cursorHeight', 1);
  option('workTime', 100);
  option('workDelay', 100);
  option('flattenSpans', true);
  option('pollInterval', 100);
  option('undoDepth', 40, function (cm, val) {
    cm.doc.history.undoDepth = val;
  });
  option('historyEventDelay', 500);
  option('viewportMargin', 10, function (cm) {
    cm.refresh();
  }, true);
  option('maxHighlightLength', 10000, function (cm) {
    loadMode(cm);
    cm.refresh();
  }, true);
  option('moveInputWithCursor', true, function (cm, val) {
    if (!val)
      cm.display.inputDiv.style.top = cm.display.inputDiv.style.left = 0;
  });
  option('tabindex', null, function (cm, val) {
    cm.display.input.tabIndex = val || '';
  });
  option('autofocus', null);
  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};
  CodeMirror.defineMode = function (name, mode) {
    if (!CodeMirror.defaults.mode && name != 'null')
      CodeMirror.defaults.mode = name;
    if (arguments.length > 2) {
      mode.dependencies = [];
      for (var i = 2; i < arguments.length; ++i)
        mode.dependencies.push(arguments[i]);
    }
    modes[name] = mode;
  };
  CodeMirror.defineMIME = function (mime, spec) {
    mimeModes[mime] = spec;
  };
  CodeMirror.resolveMode = function (spec) {
    if (typeof spec == 'string' && mimeModes.hasOwnProperty(spec))
      spec = mimeModes[spec];
    else if (typeof spec == 'string' && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec))
      return CodeMirror.resolveMode('application/xml');
    if (typeof spec == 'string')
      return { name: spec };
    else
      return spec || { name: 'null' };
  };
  CodeMirror.getMode = function (options, spec) {
    spec = CodeMirror.resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory)
      return CodeMirror.getMode(options, 'text/plain');
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop))
          continue;
        if (modeObj.hasOwnProperty(prop))
          modeObj['_' + prop] = modeObj[prop];
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;
    return modeObj;
  };
  CodeMirror.defineMode('null', function () {
    return {
      token: function (stream) {
        stream.skipToEnd();
      }
    };
  });
  CodeMirror.defineMIME('text/plain', 'null');
  var modeExtensions = CodeMirror.modeExtensions = {};
  CodeMirror.extendMode = function (mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
    copyObj(properties, exts);
  };
  CodeMirror.defineExtension = function (name, func) {
    CodeMirror.prototype[name] = func;
  };
  CodeMirror.defineDocExtension = function (name, func) {
    Doc.prototype[name] = func;
  };
  CodeMirror.defineOption = option;
  var initHooks = [];
  CodeMirror.defineInitHook = function (f) {
    initHooks.push(f);
  };
  function copyState(mode, state) {
    if (state === true)
      return state;
    if (mode.copyState)
      return mode.copyState(state);
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array)
        val = val.concat([]);
      nstate[n] = val;
    }
    return nstate;
  }
  CodeMirror.copyState = copyState;
  function startState(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true;
  }
  CodeMirror.startState = startState;
  CodeMirror.innerMode = function (mode, state) {
    while (mode.innerMode) {
      var info = mode.innerMode(state);
      state = info.state;
      mode = info.mode;
    }
    return info || {
      mode: mode,
      state: state
    };
  };
  var commands = CodeMirror.commands = {
      selectAll: function (cm) {
        cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()));
      },
      killLine: function (cm) {
        var from = cm.getCursor(true), to = cm.getCursor(false), sel = !posEq(from, to);
        if (!sel && cm.getLine(from.line).length == from.ch)
          cm.replaceRange('', from, Pos(from.line + 1, 0), '+delete');
        else
          cm.replaceRange('', from, sel ? to : Pos(from.line), '+delete');
      },
      deleteLine: function (cm) {
        var l = cm.getCursor().line;
        cm.replaceRange('', Pos(l, 0), Pos(l), '+delete');
      },
      undo: function (cm) {
        cm.undo();
      },
      redo: function (cm) {
        cm.redo();
      },
      goDocStart: function (cm) {
        cm.extendSelection(Pos(cm.firstLine(), 0));
      },
      goDocEnd: function (cm) {
        cm.extendSelection(Pos(cm.lastLine()));
      },
      goLineStart: function (cm) {
        cm.extendSelection(lineStart(cm, cm.getCursor().line));
      },
      goLineStartSmart: function (cm) {
        var cur = cm.getCursor(), start = lineStart(cm, cur.line);
        var line = cm.getLineHandle(start.line);
        var order = getOrder(line);
        if (!order || order[0].level == 0) {
          var firstNonWS = Math.max(0, line.text.search(/\S/));
          var inWS = cur.line == start.line && cur.ch <= firstNonWS && cur.ch;
          cm.extendSelection(Pos(start.line, inWS ? 0 : firstNonWS));
        } else
          cm.extendSelection(start);
      },
      goLineEnd: function (cm) {
        cm.extendSelection(lineEnd(cm, cm.getCursor().line));
      },
      goLineRight: function (cm) {
        var top = cm.charCoords(cm.getCursor(), 'div').top + 5;
        cm.extendSelection(cm.coordsChar({
          left: cm.display.lineDiv.offsetWidth + 100,
          top: top
        }, 'div'));
      },
      goLineLeft: function (cm) {
        var top = cm.charCoords(cm.getCursor(), 'div').top + 5;
        cm.extendSelection(cm.coordsChar({
          left: 0,
          top: top
        }, 'div'));
      },
      goLineUp: function (cm) {
        cm.moveV(-1, 'line');
      },
      goLineDown: function (cm) {
        cm.moveV(1, 'line');
      },
      goPageUp: function (cm) {
        cm.moveV(-1, 'page');
      },
      goPageDown: function (cm) {
        cm.moveV(1, 'page');
      },
      goCharLeft: function (cm) {
        cm.moveH(-1, 'char');
      },
      goCharRight: function (cm) {
        cm.moveH(1, 'char');
      },
      goColumnLeft: function (cm) {
        cm.moveH(-1, 'column');
      },
      goColumnRight: function (cm) {
        cm.moveH(1, 'column');
      },
      goWordLeft: function (cm) {
        cm.moveH(-1, 'word');
      },
      goGroupRight: function (cm) {
        cm.moveH(1, 'group');
      },
      goGroupLeft: function (cm) {
        cm.moveH(-1, 'group');
      },
      goWordRight: function (cm) {
        cm.moveH(1, 'word');
      },
      delCharBefore: function (cm) {
        cm.deleteH(-1, 'char');
      },
      delCharAfter: function (cm) {
        cm.deleteH(1, 'char');
      },
      delWordBefore: function (cm) {
        cm.deleteH(-1, 'word');
      },
      delWordAfter: function (cm) {
        cm.deleteH(1, 'word');
      },
      delGroupBefore: function (cm) {
        cm.deleteH(-1, 'group');
      },
      delGroupAfter: function (cm) {
        cm.deleteH(1, 'group');
      },
      indentAuto: function (cm) {
        cm.indentSelection('smart');
      },
      indentMore: function (cm) {
        cm.indentSelection('add');
      },
      indentLess: function (cm) {
        cm.indentSelection('subtract');
      },
      insertTab: function (cm) {
        cm.replaceSelection('\t', 'end', '+input');
      },
      defaultTab: function (cm) {
        if (cm.somethingSelected())
          cm.indentSelection('add');
        else
          cm.replaceSelection('\t', 'end', '+input');
      },
      transposeChars: function (cm) {
        var cur = cm.getCursor(), line = cm.getLine(cur.line);
        if (cur.ch > 0 && cur.ch < line.length - 1)
          cm.replaceRange(line.charAt(cur.ch) + line.charAt(cur.ch - 1), Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1));
      },
      newlineAndIndent: function (cm) {
        operation(cm, function () {
          cm.replaceSelection('\n', 'end', '+input');
          cm.indentLine(cm.getCursor().line, null, true);
        })();
      },
      toggleOverwrite: function (cm) {
        cm.toggleOverwrite();
      }
    };
  var keyMap = CodeMirror.keyMap = {};
  keyMap.basic = {
    'Left': 'goCharLeft',
    'Right': 'goCharRight',
    'Up': 'goLineUp',
    'Down': 'goLineDown',
    'End': 'goLineEnd',
    'Home': 'goLineStartSmart',
    'PageUp': 'goPageUp',
    'PageDown': 'goPageDown',
    'Delete': 'delCharAfter',
    'Backspace': 'delCharBefore',
    'Tab': 'defaultTab',
    'Shift-Tab': 'indentAuto',
    'Enter': 'newlineAndIndent',
    'Insert': 'toggleOverwrite'
  };
  keyMap.pcDefault = {
    'Ctrl-A': 'selectAll',
    'Ctrl-D': 'deleteLine',
    'Ctrl-Z': 'undo',
    'Shift-Ctrl-Z': 'redo',
    'Ctrl-Y': 'redo',
    'Ctrl-Home': 'goDocStart',
    'Alt-Up': 'goDocStart',
    'Ctrl-End': 'goDocEnd',
    'Ctrl-Down': 'goDocEnd',
    'Ctrl-Left': 'goGroupLeft',
    'Ctrl-Right': 'goGroupRight',
    'Alt-Left': 'goLineStart',
    'Alt-Right': 'goLineEnd',
    'Ctrl-Backspace': 'delGroupBefore',
    'Ctrl-Delete': 'delGroupAfter',
    'Ctrl-S': 'save',
    'Ctrl-F': 'find',
    'Ctrl-G': 'findNext',
    'Shift-Ctrl-G': 'findPrev',
    'Shift-Ctrl-F': 'replace',
    'Shift-Ctrl-R': 'replaceAll',
    'Ctrl-[': 'indentLess',
    'Ctrl-]': 'indentMore',
    fallthrough: 'basic'
  };
  keyMap.macDefault = {
    'Cmd-A': 'selectAll',
    'Cmd-D': 'deleteLine',
    'Cmd-Z': 'undo',
    'Shift-Cmd-Z': 'redo',
    'Cmd-Y': 'redo',
    'Cmd-Up': 'goDocStart',
    'Cmd-End': 'goDocEnd',
    'Cmd-Down': 'goDocEnd',
    'Alt-Left': 'goGroupLeft',
    'Alt-Right': 'goGroupRight',
    'Cmd-Left': 'goLineStart',
    'Cmd-Right': 'goLineEnd',
    'Alt-Backspace': 'delGroupBefore',
    'Ctrl-Alt-Backspace': 'delGroupAfter',
    'Alt-Delete': 'delGroupAfter',
    'Cmd-S': 'save',
    'Cmd-F': 'find',
    'Cmd-G': 'findNext',
    'Shift-Cmd-G': 'findPrev',
    'Cmd-Alt-F': 'replace',
    'Shift-Cmd-Alt-F': 'replaceAll',
    'Cmd-[': 'indentLess',
    'Cmd-]': 'indentMore',
    fallthrough: [
      'basic',
      'emacsy'
    ]
  };
  keyMap['default'] = mac ? keyMap.macDefault : keyMap.pcDefault;
  keyMap.emacsy = {
    'Ctrl-F': 'goCharRight',
    'Ctrl-B': 'goCharLeft',
    'Ctrl-P': 'goLineUp',
    'Ctrl-N': 'goLineDown',
    'Alt-F': 'goWordRight',
    'Alt-B': 'goWordLeft',
    'Ctrl-A': 'goLineStart',
    'Ctrl-E': 'goLineEnd',
    'Ctrl-V': 'goPageDown',
    'Shift-Ctrl-V': 'goPageUp',
    'Ctrl-D': 'delCharAfter',
    'Ctrl-H': 'delCharBefore',
    'Alt-D': 'delWordAfter',
    'Alt-Backspace': 'delWordBefore',
    'Ctrl-K': 'killLine',
    'Ctrl-T': 'transposeChars'
  };
  function getKeyMap(val) {
    if (typeof val == 'string')
      return keyMap[val];
    else
      return val;
  }
  function lookupKey(name, maps, handle) {
    function lookup(map) {
      map = getKeyMap(map);
      var found = map[name];
      if (found === false)
        return 'stop';
      if (found != null && handle(found))
        return true;
      if (map.nofallthrough)
        return 'stop';
      var fallthrough = map.fallthrough;
      if (fallthrough == null)
        return false;
      if (Object.prototype.toString.call(fallthrough) != '[object Array]')
        return lookup(fallthrough);
      for (var i = 0, e = fallthrough.length; i < e; ++i) {
        var done = lookup(fallthrough[i]);
        if (done)
          return done;
      }
      return false;
    }
    for (var i = 0; i < maps.length; ++i) {
      var done = lookup(maps[i]);
      if (done)
        return done;
    }
  }
  function isModifierKey(event) {
    var name = keyNames[event.keyCode];
    return name == 'Ctrl' || name == 'Alt' || name == 'Shift' || name == 'Mod';
  }
  function keyName(event, noShift) {
    if (opera && event.keyCode == 34 && event['char'])
      return false;
    var name = keyNames[event.keyCode];
    if (name == null || event.altGraphKey)
      return false;
    if (event.altKey)
      name = 'Alt-' + name;
    if (flipCtrlCmd ? event.metaKey : event.ctrlKey)
      name = 'Ctrl-' + name;
    if (flipCtrlCmd ? event.ctrlKey : event.metaKey)
      name = 'Cmd-' + name;
    if (!noShift && event.shiftKey)
      name = 'Shift-' + name;
    return name;
  }
  CodeMirror.lookupKey = lookupKey;
  CodeMirror.isModifierKey = isModifierKey;
  CodeMirror.keyName = keyName;
  CodeMirror.fromTextArea = function (textarea, options) {
    if (!options)
      options = {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabindex)
      options.tabindex = textarea.tabindex;
    if (!options.placeholder && textarea.placeholder)
      options.placeholder = textarea.placeholder;
    if (options.autofocus == null) {
      var hasFocus = document.body;
      try {
        hasFocus = document.activeElement;
      } catch (e) {
      }
      options.autofocus = hasFocus == textarea || textarea.getAttribute('autofocus') != null && hasFocus == document.body;
    }
    function save() {
      textarea.value = cm.getValue();
    }
    if (textarea.form) {
      on(textarea.form, 'submit', save);
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form, realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function () {
              save();
              form.submit = realSubmit;
              form.submit();
              form.submit = wrappedSubmit;
            };
        } catch (e) {
        }
      }
    }
    textarea.style.display = 'none';
    var cm = CodeMirror(function (node) {
        textarea.parentNode.insertBefore(node, textarea.nextSibling);
      }, options);
    cm.save = save;
    cm.getTextArea = function () {
      return textarea;
    };
    cm.toTextArea = function () {
      save();
      textarea.parentNode.removeChild(cm.getWrapperElement());
      textarea.style.display = '';
      if (textarea.form) {
        off(textarea.form, 'submit', save);
        if (typeof textarea.form.submit == 'function')
          textarea.form.submit = realSubmit;
      }
    };
    return cm;
  };
  function StringStream(string, tabSize) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
  }
  StringStream.prototype = {
    eol: function () {
      return this.pos >= this.string.length;
    },
    sol: function () {
      return this.pos == 0;
    },
    peek: function () {
      return this.string.charAt(this.pos) || undefined;
    },
    next: function () {
      if (this.pos < this.string.length)
        return this.string.charAt(this.pos++);
    },
    eat: function (match) {
      var ch = this.string.charAt(this.pos);
      if (typeof match == 'string')
        var ok = ch == match;
      else
        var ok = ch && (match.test ? match.test(ch) : match(ch));
      if (ok) {
        ++this.pos;
        return ch;
      }
    },
    eatWhile: function (match) {
      var start = this.pos;
      while (this.eat(match)) {
      }
      return this.pos > start;
    },
    eatSpace: function () {
      var start = this.pos;
      while (/[\s\u00a0]/.test(this.string.charAt(this.pos)))
        ++this.pos;
      return this.pos > start;
    },
    skipToEnd: function () {
      this.pos = this.string.length;
    },
    skipTo: function (ch) {
      var found = this.string.indexOf(ch, this.pos);
      if (found > -1) {
        this.pos = found;
        return true;
      }
    },
    backUp: function (n) {
      this.pos -= n;
    },
    column: function () {
      if (this.lastColumnPos < this.start) {
        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
        this.lastColumnPos = this.start;
      }
      return this.lastColumnValue;
    },
    indentation: function () {
      return countColumn(this.string, null, this.tabSize);
    },
    match: function (pattern, consume, caseInsensitive) {
      if (typeof pattern == 'string') {
        var cased = function (str) {
          return caseInsensitive ? str.toLowerCase() : str;
        };
        var substr = this.string.substr(this.pos, pattern.length);
        if (cased(substr) == cased(pattern)) {
          if (consume !== false)
            this.pos += pattern.length;
          return true;
        }
      } else {
        var match = this.string.slice(this.pos).match(pattern);
        if (match && match.index > 0)
          return null;
        if (match && consume !== false)
          this.pos += match[0].length;
        return match;
      }
    },
    current: function () {
      return this.string.slice(this.start, this.pos);
    }
  };
  CodeMirror.StringStream = StringStream;
  function TextMarker(doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
  }
  CodeMirror.TextMarker = TextMarker;
  TextMarker.prototype.clear = function () {
    if (this.explicitlyCleared)
      return;
    var cm = this.doc.cm, withOp = cm && !cm.curOp;
    if (withOp)
      startOperation(cm);
    var min = null, max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.to != null)
        max = lineNo(line);
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from != null)
        min = lineNo(line);
      else if (this.collapsed && !lineIsHidden(this.doc, line) && cm)
        updateLineHeight(line, textHeight(cm.display));
    }
    if (cm && this.collapsed && !cm.options.lineWrapping)
      for (var i = 0; i < this.lines.length; ++i) {
        var visual = visualLine(cm.doc, this.lines[i]), len = lineLength(cm.doc, visual);
        if (len > cm.display.maxLineLength) {
          cm.display.maxLine = visual;
          cm.display.maxLineLength = len;
          cm.display.maxLineChanged = true;
        }
      }
    if (min != null && cm)
      regChange(cm, min, max + 1);
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.collapsed && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm)
        reCheckSelection(cm);
    }
    if (withOp)
      endOperation(cm);
    signalLater(this, 'clear');
  };
  TextMarker.prototype.find = function () {
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.from != null || span.to != null) {
        var found = lineNo(line);
        if (span.from != null)
          from = Pos(found, span.from);
        if (span.to != null)
          to = Pos(found, span.to);
      }
    }
    if (this.type == 'bookmark')
      return from;
    return from && {
      from: from,
      to: to
    };
  };
  TextMarker.prototype.getOptions = function (copyWidget) {
    var repl = this.replacedWith;
    return {
      className: this.className,
      inclusiveLeft: this.inclusiveLeft,
      inclusiveRight: this.inclusiveRight,
      atomic: this.atomic,
      collapsed: this.collapsed,
      replacedWith: copyWidget ? repl && repl.cloneNode(true) : repl,
      readOnly: this.readOnly,
      startStyle: this.startStyle,
      endStyle: this.endStyle
    };
  };
  TextMarker.prototype.attachLine = function (line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
    }
    this.lines.push(line);
  };
  TextMarker.prototype.detachLine = function (line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };
  function markText(doc, from, to, options, type) {
    if (options && options.shared)
      return markTextShared(doc, from, to, options, type);
    if (doc.cm && !doc.cm.curOp)
      return operation(doc.cm, markText)(doc, from, to, options, type);
    var marker = new TextMarker(doc, type);
    if (type == 'range' && !posLess(from, to))
      return marker;
    if (options)
      copyObj(options, marker);
    if (marker.replacedWith) {
      marker.collapsed = true;
      marker.replacedWith = elt('span', [marker.replacedWith], 'CodeMirror-widget');
    }
    if (marker.collapsed)
      sawCollapsedSpans = true;
    if (marker.addToHistory)
      addToHistory(doc, {
        from: from,
        to: to,
        origin: 'markText'
      }, {
        head: doc.sel.head,
        anchor: doc.sel.anchor
      }, NaN);
    var curLine = from.line, size = 0, collapsedAtStart, collapsedAtEnd, cm = doc.cm, updateMaxLine;
    doc.iter(curLine, to.line + 1, function (line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(doc, line) == cm.display.maxLine)
        updateMaxLine = true;
      var span = {
          from: null,
          to: null,
          marker: marker
        };
      size += line.text.length;
      if (curLine == from.line) {
        span.from = from.ch;
        size -= from.ch;
      }
      if (curLine == to.line) {
        span.to = to.ch;
        size -= line.text.length - to.ch;
      }
      if (marker.collapsed) {
        if (curLine == to.line)
          collapsedAtEnd = collapsedSpanAt(line, to.ch);
        if (curLine == from.line)
          collapsedAtStart = collapsedSpanAt(line, from.ch);
        else
          updateLineHeight(line, 0);
      }
      addMarkedSpan(line, span);
      ++curLine;
    });
    if (marker.collapsed)
      doc.iter(from.line, to.line + 1, function (line) {
        if (lineIsHidden(doc, line))
          updateLineHeight(line, 0);
      });
    if (marker.clearOnEnter)
      on(marker, 'beforeCursorEnter', function () {
        marker.clear();
      });
    if (marker.readOnly) {
      sawReadOnlySpans = true;
      if (doc.history.done.length || doc.history.undone.length)
        doc.clearHistory();
    }
    if (marker.collapsed) {
      if (collapsedAtStart != collapsedAtEnd)
        throw new Error('Inserting collapsed marker overlapping an existing one');
      marker.size = size;
      marker.atomic = true;
    }
    if (cm) {
      if (updateMaxLine)
        cm.curOp.updateMaxLine = true;
      if (marker.className || marker.startStyle || marker.endStyle || marker.collapsed)
        regChange(cm, from.line, to.line + 1);
      if (marker.atomic)
        reCheckSelection(cm);
    }
    return marker;
  }
  function SharedTextMarker(markers, primary) {
    this.markers = markers;
    this.primary = primary;
    for (var i = 0, me = this; i < markers.length; ++i) {
      markers[i].parent = this;
      on(markers[i], 'clear', function () {
        me.clear();
      });
    }
  }
  CodeMirror.SharedTextMarker = SharedTextMarker;
  SharedTextMarker.prototype.clear = function () {
    if (this.explicitlyCleared)
      return;
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i)
      this.markers[i].clear();
    signalLater(this, 'clear');
  };
  SharedTextMarker.prototype.find = function () {
    return this.primary.find();
  };
  SharedTextMarker.prototype.getOptions = function (copyWidget) {
    var inner = this.primary.getOptions(copyWidget);
    inner.shared = true;
    return inner;
  };
  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
    var widget = options.replacedWith;
    linkedDocs(doc, function (doc) {
      if (widget)
        options.replacedWith = widget.cloneNode(true);
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i)
        if (doc.linked[i].isParent)
          return;
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary);
  }
  function getMarkedSpanFor(spans, marker) {
    if (spans)
      for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if (span.marker == marker)
          return span;
      }
  }
  function removeMarkedSpan(spans, span) {
    for (var r, i = 0; i < spans.length; ++i)
      if (spans[i] != span)
        (r || (r = [])).push(spans[i]);
    return r;
  }
  function addMarkedSpan(line, span) {
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
    span.marker.attachLine(line);
  }
  function markedSpansBefore(old, startCh, isInsert) {
    if (old)
      for (var i = 0, nw; i < old.length; ++i) {
        var span = old[i], marker = span.marker;
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
        if (startsBefore || marker.type == 'bookmark' && span.from == startCh && (!isInsert || !span.marker.insertLeft)) {
          var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
          (nw || (nw = [])).push({
            from: span.from,
            to: endsAfter ? null : span.to,
            marker: marker
          });
        }
      }
    return nw;
  }
  function markedSpansAfter(old, endCh, isInsert) {
    if (old)
      for (var i = 0, nw; i < old.length; ++i) {
        var span = old[i], marker = span.marker;
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
        if (endsAfter || marker.type == 'bookmark' && span.from == endCh && (!isInsert || span.marker.insertLeft)) {
          var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
          (nw || (nw = [])).push({
            from: startsBefore ? null : span.from - endCh,
            to: span.to == null ? null : span.to - endCh,
            marker: marker
          });
        }
      }
    return nw;
  }
  function stretchSpansOverChange(doc, change) {
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast)
      return null;
    var startCh = change.from.ch, endCh = change.to.ch, isInsert = posEq(change.from, change.to);
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);
    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found)
            span.to = startCh;
          else if (sameLine)
            span.to = found.to == null ? null : found.to + offset;
        }
      }
    }
    if (last) {
      for (var i = 0; i < last.length; ++i) {
        var span = last[i];
        if (span.to != null)
          span.to += offset;
        if (span.from == null) {
          var found = getMarkedSpanFor(first, span.marker);
          if (!found) {
            span.from = offset;
            if (sameLine)
              (first || (first = [])).push(span);
          }
        } else {
          span.from += offset;
          if (sameLine)
            (first || (first = [])).push(span);
        }
      }
    }
    var newMarkers = [first];
    if (!sameLine) {
      var gap = change.text.length - 2, gapMarkers;
      if (gap > 0 && first)
        for (var i = 0; i < first.length; ++i)
          if (first[i].to == null)
            (gapMarkers || (gapMarkers = [])).push({
              from: null,
              to: null,
              marker: first[i].marker
            });
      for (var i = 0; i < gap; ++i)
        newMarkers.push(gapMarkers);
      newMarkers.push(last);
    }
    return newMarkers;
  }
  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old)
      return stretched;
    if (!stretched)
      return old;
    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i], stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans:
          for (var j = 0; j < stretchCur.length; ++j) {
            var span = stretchCur[j];
            for (var k = 0; k < oldCur.length; ++k)
              if (oldCur[k].marker == span.marker)
                continue spans;
            oldCur.push(span);
          }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old;
  }
  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function (line) {
      if (line.markedSpans)
        for (var i = 0; i < line.markedSpans.length; ++i) {
          var mark = line.markedSpans[i].marker;
          if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
            (markers || (markers = [])).push(mark);
        }
    });
    if (!markers)
      return null;
    var parts = [{
          from: from,
          to: to
        }];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i], m = mk.find();
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (posLess(p.to, m.from) || posLess(m.to, p.from))
          continue;
        var newParts = [
            j,
            1
          ];
        if (posLess(p.from, m.from) || !mk.inclusiveLeft && posEq(p.from, m.from))
          newParts.push({
            from: p.from,
            to: m.from
          });
        if (posLess(m.to, p.to) || !mk.inclusiveRight && posEq(p.to, m.to))
          newParts.push({
            from: m.to,
            to: p.to
          });
        parts.splice.apply(parts, newParts);
        j += newParts.length - 1;
      }
    }
    return parts;
  }
  function collapsedSpanAt(line, ch) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps)
      for (var sp, i = 0; i < sps.length; ++i) {
        sp = sps[i];
        if (!sp.marker.collapsed)
          continue;
        if ((sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || found.width < sp.marker.width))
          found = sp.marker;
      }
    return found;
  }
  function collapsedSpanAtStart(line) {
    return collapsedSpanAt(line, -1);
  }
  function collapsedSpanAtEnd(line) {
    return collapsedSpanAt(line, line.text.length + 1);
  }
  function visualLine(doc, line) {
    var merged;
    while (merged = collapsedSpanAtStart(line))
      line = getLine(doc, merged.find().from.line);
    return line;
  }
  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps)
      for (var sp, i = 0; i < sps.length; ++i) {
        sp = sps[i];
        if (!sp.marker.collapsed)
          continue;
        if (sp.from == null)
          return true;
        if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
          return true;
      }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find().to, endLine = getLine(doc, end.line);
      return lineIsHiddenInner(doc, endLine, getMarkedSpanFor(endLine.markedSpans, span.marker));
    }
    if (span.marker.inclusiveRight && span.to == line.text.length)
      return true;
    for (var sp, i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && sp.from == span.to && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp))
        return true;
    }
  }
  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans)
      return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.detachLine(line);
    line.markedSpans = null;
  }
  function attachMarkedSpans(line, spans) {
    if (!spans)
      return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.attachLine(line);
    line.markedSpans = spans;
  }
  var LineWidget = CodeMirror.LineWidget = function (cm, node, options) {
      for (var opt in options)
        if (options.hasOwnProperty(opt))
          this[opt] = options[opt];
      this.cm = cm;
      this.node = node;
    };
  function widgetOperation(f) {
    return function () {
      var withOp = !this.cm.curOp;
      if (withOp)
        startOperation(this.cm);
      try {
        var result = f.apply(this, arguments);
      } finally {
        if (withOp)
          endOperation(this.cm);
      }
      return result;
    };
  }
  LineWidget.prototype.clear = widgetOperation(function () {
    var ws = this.line.widgets, no = lineNo(this.line);
    if (no == null || !ws)
      return;
    for (var i = 0; i < ws.length; ++i)
      if (ws[i] == this)
        ws.splice(i--, 1);
    if (!ws.length)
      this.line.widgets = null;
    updateLineHeight(this.line, Math.max(0, this.line.height - widgetHeight(this)));
    regChange(this.cm, no, no + 1);
  });
  LineWidget.prototype.changed = widgetOperation(function () {
    var oldH = this.height;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff)
      return;
    updateLineHeight(this.line, this.line.height + diff);
    var no = lineNo(this.line);
    regChange(this.cm, no, no + 1);
  });
  function widgetHeight(widget) {
    if (widget.height != null)
      return widget.height;
    if (!widget.node.parentNode || widget.node.parentNode.nodeType != 1)
      removeChildrenAndAdd(widget.cm.display.measure, elt('div', [widget.node], null, 'position: relative'));
    return widget.height = widget.node.offsetHeight;
  }
  function addLineWidget(cm, handle, node, options) {
    var widget = new LineWidget(cm, node, options);
    if (widget.noHScroll)
      cm.display.alignWidgets = true;
    changeLine(cm, handle, function (line) {
      (line.widgets || (line.widgets = [])).push(widget);
      widget.line = line;
      if (!lineIsHidden(cm.doc, line) || widget.showIfHidden) {
        var aboveVisible = heightAtLine(cm, line) < cm.display.scroller.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible)
          addToScrollPos(cm, 0, widget.height);
      }
      return true;
    });
    return widget;
  }
  function makeLine(text, markedSpans, estimateHeight) {
    var line = { text: text };
    attachMarkedSpans(line, markedSpans);
    line.height = estimateHeight ? estimateHeight(line) : 1;
    return line;
  }
  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter)
      line.stateAfter = null;
    if (line.styles)
      line.styles = null;
    if (line.order != null)
      line.order = null;
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height)
      updateLineHeight(line, estHeight);
  }
  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }
  function runMode(cm, text, mode, state, f) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null)
      flattenSpans = cm.options.flattenSpans;
    var curText = '', curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize), style;
    if (text == '' && mode.blankLine)
      mode.blankLine(state);
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        stream.pos = Math.min(text.length, stream.start + 50000);
        style = null;
      } else {
        style = mode.token(stream, state);
      }
      var substr = stream.current();
      stream.start = stream.pos;
      if (!flattenSpans || curStyle != style) {
        if (curText)
          f(curText, curStyle);
        curText = substr;
        curStyle = style;
      } else
        curText = curText + substr;
    }
    if (curText)
      f(curText, curStyle);
  }
  function highlightLine(cm, line, state) {
    var st = [cm.state.modeGen];
    runMode(cm, line.text, cm.doc.mode, state, function (txt, style) {
      st.push(txt, style);
    });
    for (var o = 0; o < cm.state.overlays.length; ++o) {
      var overlay = cm.state.overlays[o], i = 1;
      runMode(cm, line.text, overlay.mode, true, function (txt, style) {
        var start = i, len = txt.length;
        while (len) {
          var cur = st[i], len_ = cur.length;
          if (len_ <= len) {
            len -= len_;
          } else {
            st.splice(i, 1, cur.slice(0, len), st[i + 1], cur.slice(len));
            len = 0;
          }
          i += 2;
        }
        if (!style)
          return;
        if (overlay.opaque) {
          st.splice(start, i - start, txt, style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start + 1];
            st[start + 1] = cur ? cur + ' ' + style : style;
          }
        }
      });
    }
    return st;
  }
  function getLineStyles(cm, line) {
    if (!line.styles || line.styles[0] != cm.state.modeGen)
      line.styles = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));
    return line.styles;
  }
  function processLine(cm, line, state) {
    var mode = cm.doc.mode;
    var stream = new StringStream(line.text, cm.options.tabSize);
    if (line.text == '' && mode.blankLine)
      mode.blankLine(state);
    while (!stream.eol() && stream.pos <= cm.options.maxHighlightLength) {
      mode.token(stream, state);
      stream.start = stream.pos;
    }
  }
  var styleToClassCache = {};
  function styleToClass(style) {
    if (!style)
      return null;
    return styleToClassCache[style] || (styleToClassCache[style] = 'cm-' + style.replace(/ +/g, ' cm-'));
  }
  function lineContent(cm, realLine, measure) {
    var merged, line = realLine, lineBefore, sawBefore, simple = true;
    while (merged = collapsedSpanAtStart(line)) {
      simple = false;
      line = getLine(cm.doc, merged.find().from.line);
      if (!lineBefore)
        lineBefore = line;
    }
    var builder = {
        pre: elt('pre'),
        col: 0,
        pos: 0,
        display: !measure,
        measure: null,
        addedOne: false,
        cm: cm
      };
    if (line.textClass)
      builder.pre.className = line.textClass;
    do {
      builder.measure = line == realLine && measure;
      builder.pos = 0;
      builder.addToken = builder.measure ? buildTokenMeasure : buildToken;
      if ((ie || webkit) && cm.getOption('lineWrapping'))
        builder.addToken = buildTokenSplitSpaces(builder.addToken);
      if (measure && sawBefore && line != realLine && !builder.addedOne) {
        measure[0] = builder.pre.appendChild(zeroWidthElement(cm.display.measure));
        builder.addedOne = true;
      }
      var next = insertLineContent(line, builder, getLineStyles(cm, line));
      sawBefore = line == lineBefore;
      if (next) {
        line = getLine(cm.doc, next.to.line);
        simple = false;
      }
    } while (next);
    if (measure && !builder.addedOne)
      measure[0] = builder.pre.appendChild(simple ? elt('span', '\xa0') : zeroWidthElement(cm.display.measure));
    if (!builder.pre.firstChild && !lineIsHidden(cm.doc, realLine))
      builder.pre.appendChild(document.createTextNode('\xa0'));
    var order;
    if (measure && ie && (order = getOrder(line))) {
      var l = order.length - 1;
      if (order[l].from == order[l].to)
        --l;
      var last = order[l], prev = order[l - 1];
      if (last.from + 1 == last.to && prev && last.level < prev.level) {
        var span = measure[builder.pos - 1];
        if (span)
          span.parentNode.insertBefore(span.measureRight = zeroWidthElement(cm.display.measure), span.nextSibling);
      }
    }
    signal(cm, 'renderLine', cm, realLine, builder.pre);
    return builder.pre;
  }
  var tokenSpecialChars = /[\t\u0000-\u0019\u00ad\u200b\u2028\u2029\uFEFF]/g;
  function buildToken(builder, text, style, startStyle, endStyle) {
    if (!text)
      return;
    if (!tokenSpecialChars.test(text)) {
      builder.col += text.length;
      var content = document.createTextNode(text);
    } else {
      var content = document.createDocumentFragment(), pos = 0;
      while (true) {
        tokenSpecialChars.lastIndex = pos;
        var m = tokenSpecialChars.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          content.appendChild(document.createTextNode(text.slice(pos, pos + skipped)));
          builder.col += skipped;
        }
        if (!m)
          break;
        pos += skipped + 1;
        if (m[0] == '\t') {
          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
          content.appendChild(elt('span', spaceStr(tabWidth), 'cm-tab'));
          builder.col += tabWidth;
        } else {
          var token = elt('span', '\u2022', 'cm-invalidchar');
          token.title = '\\u' + m[0].charCodeAt(0).toString(16);
          content.appendChild(token);
          builder.col += 1;
        }
      }
    }
    if (style || startStyle || endStyle || builder.measure) {
      var fullStyle = style || '';
      if (startStyle)
        fullStyle += startStyle;
      if (endStyle)
        fullStyle += endStyle;
      return builder.pre.appendChild(elt('span', [content], fullStyle));
    }
    builder.pre.appendChild(content);
  }
  function buildTokenMeasure(builder, text, style, startStyle, endStyle) {
    var wrapping = builder.cm.options.lineWrapping;
    for (var i = 0; i < text.length; ++i) {
      var ch = text.charAt(i), start = i == 0;
      if (ch >= '\ud800' && ch < '\udbff' && i < text.length - 1) {
        ch = text.slice(i, i + 2);
        ++i;
      } else if (i && wrapping && spanAffectsWrapping.test(text.slice(i - 1, i + 1))) {
        builder.pre.appendChild(elt('wbr'));
      }
      var span = builder.measure[builder.pos] = buildToken(builder, ch, style, start && startStyle, i == text.length - 1 && endStyle);
      if (ie && wrapping && ch == ' ' && i && !/\s/.test(text.charAt(i - 1)) && i < text.length - 1 && !/\s/.test(text.charAt(i + 1)))
        span.style.whiteSpace = 'normal';
      builder.pos += ch.length;
    }
    if (text.length)
      builder.addedOne = true;
  }
  function buildTokenSplitSpaces(inner) {
    function split(old) {
      var out = ' ';
      for (var i = 0; i < old.length - 2; ++i)
        out += i % 2 ? ' ' : '\xa0';
      out += ' ';
      return out;
    }
    return function (builder, text, style, startStyle, endStyle) {
      return inner(builder, text.replace(/ {3,}/, split), style, startStyle, endStyle);
    };
  }
  function buildCollapsedSpan(builder, size, widget) {
    if (widget) {
      if (!builder.display)
        widget = widget.cloneNode(true);
      builder.pre.appendChild(widget);
      if (builder.measure && size) {
        builder.measure[builder.pos] = widget;
        builder.addedOne = true;
      }
    }
    builder.pos += size;
  }
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans;
    if (!spans) {
      for (var i = 1; i < styles.length; i += 2)
        builder.addToken(builder, styles[i], styleToClass(styles[i + 1]));
      return;
    }
    var allText = line.text, len = allText.length;
    var pos = 0, i = 1, text = '', style;
    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed;
    for (;;) {
      if (nextChange == pos) {
        spanStyle = spanEndStyle = spanStartStyle = '';
        collapsed = null;
        nextChange = Infinity;
        var foundBookmark = null;
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j], m = sp.marker;
          if (sp.from <= pos && (sp.to == null || sp.to > pos)) {
            if (sp.to != null && nextChange > sp.to) {
              nextChange = sp.to;
              spanEndStyle = '';
            }
            if (m.className)
              spanStyle += ' ' + m.className;
            if (m.startStyle && sp.from == pos)
              spanStartStyle += ' ' + m.startStyle;
            if (m.endStyle && sp.to == nextChange)
              spanEndStyle += ' ' + m.endStyle;
            if (m.collapsed && (!collapsed || collapsed.marker.width < m.width))
              collapsed = sp;
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
          if (m.type == 'bookmark' && sp.from == pos && m.replacedWith)
            foundBookmark = m.replacedWith;
        }
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len : collapsed.to) - pos, collapsed.from != null && collapsed.marker.replacedWith);
          if (collapsed.to == null)
            return collapsed.marker.find();
        }
        if (foundBookmark && !collapsed)
          buildCollapsedSpan(builder, 0, foundBookmark);
      }
      if (pos >= len)
        break;
      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : '');
          }
          if (end >= upto) {
            text = text.slice(upto - pos);
            pos = upto;
            break;
          }
          pos = end;
          spanStartStyle = '';
        }
        text = styles[i++];
        style = styleToClass(styles[i++]);
      }
    }
  }
  function updateDoc(doc, change, markedSpans, selAfter, estimateHeight) {
    function spansFor(n) {
      return markedSpans ? markedSpans[n] : null;
    }
    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight);
      signalLater(line, 'change', line, change);
    }
    var from = change.from, to = change.to, text = change.text;
    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;
    if (from.ch == 0 && to.ch == 0 && lastText == '') {
      for (var i = 0, e = text.length - 1, added = []; i < e; ++i)
        added.push(makeLine(text[i], spansFor(i), estimateHeight));
      update(lastLine, lastLine.text, lastSpans);
      if (nlines)
        doc.remove(from.line, nlines);
      if (added.length)
        doc.insert(from.line, added);
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        for (var added = [], i = 1, e = text.length - 1; i < e; ++i)
          added.push(makeLine(text[i], spansFor(i), estimateHeight));
        added.push(makeLine(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      for (var i = 1, e = text.length - 1, added = []; i < e; ++i)
        added.push(makeLine(text[i], spansFor(i), estimateHeight));
      if (nlines > 1)
        doc.remove(from.line + 1, nlines - 1);
      doc.insert(from.line + 1, added);
    }
    signalLater(doc, 'change', doc, change);
    setSelection(doc, selAfter.anchor, selAfter.head, null, true);
  }
  function LeafChunk(lines) {
    this.lines = lines;
    this.parent = null;
    for (var i = 0, e = lines.length, height = 0; i < e; ++i) {
      lines[i].parent = this;
      height += lines[i].height;
    }
    this.height = height;
  }
  LeafChunk.prototype = {
    chunkSize: function () {
      return this.lines.length;
    },
    removeInner: function (at, n) {
      for (var i = at, e = at + n; i < e; ++i) {
        var line = this.lines[i];
        this.height -= line.height;
        cleanUpLine(line);
        signalLater(line, 'delete');
      }
      this.lines.splice(at, n);
    },
    collapse: function (lines) {
      lines.splice.apply(lines, [
        lines.length,
        0
      ].concat(this.lines));
    },
    insertInner: function (at, lines, height) {
      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0, e = lines.length; i < e; ++i)
        lines[i].parent = this;
    },
    iterN: function (at, n, op) {
      for (var e = at + n; at < e; ++at)
        if (op(this.lines[at]))
          return true;
    }
  };
  function BranchChunk(children) {
    this.children = children;
    var size = 0, height = 0;
    for (var i = 0, e = children.length; i < e; ++i) {
      var ch = children[i];
      size += ch.chunkSize();
      height += ch.height;
      ch.parent = this;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }
  BranchChunk.prototype = {
    chunkSize: function () {
      return this.size;
    },
    removeInner: function (at, n) {
      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at), oldHeight = child.height;
          child.removeInner(at, rm);
          this.height -= oldHeight - child.height;
          if (sz == rm) {
            this.children.splice(i--, 1);
            child.parent = null;
          }
          if ((n -= rm) == 0)
            break;
          at = 0;
        } else
          at -= sz;
      }
      if (this.size - n < 25) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },
    collapse: function (lines) {
      for (var i = 0, e = this.children.length; i < e; ++i)
        this.children[i].collapse(lines);
    },
    insertInner: function (at, lines, height) {
      this.size += lines.length;
      this.height += height;
      for (var i = 0, e = this.children.length; i < e; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            while (child.lines.length > 50) {
              var spilled = child.lines.splice(child.lines.length - 25, 25);
              var newleaf = new LeafChunk(spilled);
              child.height -= newleaf.height;
              this.children.splice(i + 1, 0, newleaf);
              newleaf.parent = this;
            }
            this.maybeSpill();
          }
          break;
        }
        at -= sz;
      }
    },
    maybeSpill: function () {
      if (this.children.length <= 10)
        return;
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) {
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [
            copy,
            sibling
          ];
          me = copy;
        } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10);
      me.parent.maybeSpill();
    },
    iterN: function (at, n, op) {
      for (var i = 0, e = this.children.length; i < e; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op))
            return true;
          if ((n -= used) == 0)
            break;
          at = 0;
        } else
          at -= sz;
      }
    }
  };
  var nextDocId = 0;
  var Doc = CodeMirror.Doc = function (text, mode, firstLine) {
      if (!(this instanceof Doc))
        return new Doc(text, mode, firstLine);
      if (firstLine == null)
        firstLine = 0;
      BranchChunk.call(this, [new LeafChunk([makeLine('', null)])]);
      this.first = firstLine;
      this.scrollTop = this.scrollLeft = 0;
      this.cantEdit = false;
      this.history = makeHistory();
      this.frontier = firstLine;
      var start = Pos(firstLine, 0);
      this.sel = {
        from: start,
        to: start,
        head: start,
        anchor: start,
        shift: false,
        extend: false,
        goalColumn: null
      };
      this.id = ++nextDocId;
      this.modeOption = mode;
      if (typeof text == 'string')
        text = splitLines(text);
      updateDoc(this, {
        from: start,
        to: start,
        text: text
      }, null, {
        head: start,
        anchor: start
      });
    };
  Doc.prototype = createObj(BranchChunk.prototype, {
    iter: function (from, to, op) {
      if (op)
        this.iterN(from - this.first, to - from, op);
      else
        this.iterN(this.first, this.first + this.size, from);
    },
    insert: function (at, lines) {
      var height = 0;
      for (var i = 0, e = lines.length; i < e; ++i)
        height += lines[i].height;
      this.insertInner(at - this.first, lines, height);
    },
    remove: function (at, n) {
      this.removeInner(at - this.first, n);
    },
    getValue: function (lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false)
        return lines;
      return lines.join(lineSep || '\n');
    },
    setValue: function (code) {
      var top = Pos(this.first, 0), last = this.first + this.size - 1;
      makeChange(this, {
        from: top,
        to: Pos(last, getLine(this, last).text.length),
        text: splitLines(code),
        origin: 'setValue'
      }, {
        head: top,
        anchor: top
      }, true);
    },
    replaceRange: function (code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function (from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false)
        return lines;
      return lines.join(lineSep || '\n');
    },
    getLine: function (line) {
      var l = this.getLineHandle(line);
      return l && l.text;
    },
    setLine: function (line, text) {
      if (isLine(this, line))
        replaceRange(this, text, Pos(line, 0), clipPos(this, Pos(line)));
    },
    removeLine: function (line) {
      if (line)
        replaceRange(this, '', clipPos(this, Pos(line - 1)), clipPos(this, Pos(line)));
      else
        replaceRange(this, '', Pos(0, 0), clipPos(this, Pos(1, 0)));
    },
    getLineHandle: function (line) {
      if (isLine(this, line))
        return getLine(this, line);
    },
    getLineNumber: function (line) {
      return lineNo(line);
    },
    lineCount: function () {
      return this.size;
    },
    firstLine: function () {
      return this.first;
    },
    lastLine: function () {
      return this.first + this.size - 1;
    },
    clipPos: function (pos) {
      return clipPos(this, pos);
    },
    getCursor: function (start) {
      var sel = this.sel, pos;
      if (start == null || start == 'head')
        pos = sel.head;
      else if (start == 'anchor')
        pos = sel.anchor;
      else if (start == 'end' || start === false)
        pos = sel.to;
      else
        pos = sel.from;
      return copyPos(pos);
    },
    somethingSelected: function () {
      return !posEq(this.sel.head, this.sel.anchor);
    },
    setCursor: docOperation(function (line, ch, extend) {
      var pos = clipPos(this, typeof line == 'number' ? Pos(line, ch || 0) : line);
      if (extend)
        extendSelection(this, pos);
      else
        setSelection(this, pos, pos);
    }),
    setSelection: docOperation(function (anchor, head) {
      setSelection(this, clipPos(this, anchor), clipPos(this, head || anchor));
    }),
    extendSelection: docOperation(function (from, to) {
      extendSelection(this, clipPos(this, from), to && clipPos(this, to));
    }),
    getSelection: function (lineSep) {
      return this.getRange(this.sel.from, this.sel.to, lineSep);
    },
    replaceSelection: function (code, collapse, origin) {
      makeChange(this, {
        from: this.sel.from,
        to: this.sel.to,
        text: splitLines(code),
        origin: origin
      }, collapse || 'around');
    },
    undo: docOperation(function () {
      makeChangeFromHistory(this, 'undo');
    }),
    redo: docOperation(function () {
      makeChangeFromHistory(this, 'redo');
    }),
    setExtending: function (val) {
      this.sel.extend = val;
    },
    historySize: function () {
      var hist = this.history;
      return {
        undo: hist.done.length,
        redo: hist.undone.length
      };
    },
    clearHistory: function () {
      this.history = makeHistory();
    },
    markClean: function () {
      this.history.dirtyCounter = 0;
      this.history.lastOp = this.history.lastOrigin = null;
    },
    isClean: function () {
      return this.history.dirtyCounter == 0;
    },
    getHistory: function () {
      return {
        done: copyHistoryArray(this.history.done),
        undone: copyHistoryArray(this.history.undone)
      };
    },
    setHistory: function (histData) {
      var hist = this.history = makeHistory();
      hist.done = histData.done.slice(0);
      hist.undone = histData.undone.slice(0);
    },
    markText: function (from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, 'range');
    },
    setBookmark: function (pos, options) {
      var realOpts = {
          replacedWith: options && (options.nodeType == null ? options.widget : options),
          insertLeft: options && options.insertLeft
        };
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, 'bookmark');
    },
    findMarksAt: function (pos) {
      pos = clipPos(this, pos);
      var markers = [], spans = getLine(this, pos.line).markedSpans;
      if (spans)
        for (var i = 0; i < spans.length; ++i) {
          var span = spans[i];
          if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch))
            markers.push(span.marker.parent || span.marker);
        }
      return markers;
    },
    getAllMarks: function () {
      var markers = [];
      this.iter(function (line) {
        var sps = line.markedSpans;
        if (sps)
          for (var i = 0; i < sps.length; ++i)
            if (sps[i].from != null)
              markers.push(sps[i].marker);
      });
      return markers;
    },
    posFromIndex: function (off) {
      var ch, lineNo = this.first;
      this.iter(function (line) {
        var sz = line.text.length + 1;
        if (sz > off) {
          ch = off;
          return true;
        }
        off -= sz;
        ++lineNo;
      });
      return clipPos(this, Pos(lineNo, ch));
    },
    indexFromPos: function (coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0)
        return 0;
      this.iter(this.first, coords.line, function (line) {
        index += line.text.length + 1;
      });
      return index;
    },
    copy: function (copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);
      doc.scrollTop = this.scrollTop;
      doc.scrollLeft = this.scrollLeft;
      doc.sel = {
        from: this.sel.from,
        to: this.sel.to,
        head: this.sel.head,
        anchor: this.sel.anchor,
        shift: this.sel.shift,
        extend: false,
        goalColumn: this.sel.goalColumn
      };
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc;
    },
    linkedDoc: function (options) {
      if (!options)
        options = {};
      var from = this.first, to = this.first + this.size;
      if (options.from != null && options.from > from)
        from = options.from;
      if (options.to != null && options.to < to)
        to = options.to;
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);
      if (options.sharedHist)
        copy.history = this.history;
      (this.linked || (this.linked = [])).push({
        doc: copy,
        sharedHist: options.sharedHist
      });
      copy.linked = [{
          doc: this,
          isParent: true,
          sharedHist: options.sharedHist
        }];
      return copy;
    },
    unlinkDoc: function (other) {
      if (other instanceof CodeMirror)
        other = other.doc;
      if (this.linked)
        for (var i = 0; i < this.linked.length; ++i) {
          var link = this.linked[i];
          if (link.doc != other)
            continue;
          this.linked.splice(i, 1);
          other.unlinkDoc(this);
          break;
        }
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function (doc) {
          splitIds.push(doc.id);
        }, true);
        other.history = makeHistory();
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function (f) {
      linkedDocs(this, f);
    },
    getMode: function () {
      return this.mode;
    },
    getEditor: function () {
      return this.cm;
    }
  });
  Doc.prototype.eachLine = Doc.prototype.iter;
  var dontDelegate = 'iter insert remove copy getEditor'.split(' ');
  for (var prop in Doc.prototype)
    if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
      CodeMirror.prototype[prop] = function (method) {
        return function () {
          return method.apply(this.doc, arguments);
        };
      }(Doc.prototype[prop]);
  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked)
        for (var i = 0; i < doc.linked.length; ++i) {
          var rel = doc.linked[i];
          if (rel.doc == skip)
            continue;
          var shared = sharedHist && rel.sharedHist;
          if (sharedHistOnly && !shared)
            continue;
          f(rel.doc, shared);
          propagate(rel.doc, doc, shared);
        }
    }
    propagate(doc, null, true);
  }
  function attachDoc(cm, doc) {
    if (doc.cm)
      throw new Error('This document is already in use.');
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    if (!cm.options.lineWrapping)
      computeMaxLength(cm);
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }
  function getLine(chunk, n) {
    n -= chunk.first;
    while (!chunk.lines) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i], sz = child.chunkSize();
        if (n < sz) {
          chunk = child;
          break;
        }
        n -= sz;
      }
    }
    return chunk.lines[n];
  }
  function getBetween(doc, start, end) {
    var out = [], n = start.line;
    doc.iter(start.line, end.line + 1, function (line) {
      var text = line.text;
      if (n == end.line)
        text = text.slice(0, end.ch);
      if (n == start.line)
        text = text.slice(start.ch);
      out.push(text);
      ++n;
    });
    return out;
  }
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function (line) {
      out.push(line.text);
    });
    return out;
  }
  function updateLineHeight(line, height) {
    var diff = height - line.height;
    for (var n = line; n; n = n.parent)
      n.height += diff;
  }
  function lineNo(line) {
    if (line.parent == null)
      return null;
    var cur = line.parent, no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur)
          break;
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first;
  }
  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer:
      do {
        for (var i = 0, e = chunk.children.length; i < e; ++i) {
          var child = chunk.children[i], ch = child.height;
          if (h < ch) {
            chunk = child;
            continue outer;
          }
          h -= ch;
          n += child.chunkSize();
        }
        return n;
      } while (!chunk.lines);
    for (var i = 0, e = chunk.lines.length; i < e; ++i) {
      var line = chunk.lines[i], lh = line.height;
      if (h < lh)
        break;
      h -= lh;
    }
    return n + i;
  }
  function heightAtLine(cm, lineObj) {
    lineObj = visualLine(cm.doc, lineObj);
    var h = 0, chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj)
        break;
      else
        h += line.height;
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i = 0; i < p.children.length; ++i) {
        var cur = p.children[i];
        if (cur == chunk)
          break;
        else
          h += cur.height;
      }
    }
    return h;
  }
  function getOrder(line) {
    var order = line.order;
    if (order == null)
      order = line.order = bidiOrdering(line.text);
    return order;
  }
  function makeHistory() {
    return {
      done: [],
      undone: [],
      undoDepth: Infinity,
      lastTime: 0,
      lastOp: null,
      lastOrigin: null,
      dirtyCounter: 0
    };
  }
  function attachLocalSpans(doc, change, from, to) {
    var existing = change['spans_' + doc.id], n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
      if (line.markedSpans)
        (existing || (existing = change['spans_' + doc.id] = {}))[n] = line.markedSpans;
      ++n;
    });
  }
  function historyChangeFromChange(doc, change) {
    var histChange = {
        from: change.from,
        to: changeEnd(change),
        text: getBetween(doc, change.from, change.to)
      };
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function (doc) {
      attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    }, true);
    return histChange;
  }
  function addToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date(), cur = lst(hist.done);
    if (cur && (hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == '+' && doc.cm && hist.lastTime > time - doc.cm.options.historyEventDelay || change.origin.charAt(0) == '*'))) {
      var last = lst(cur.changes);
      if (posEq(change.from, change.to) && posEq(change.from, last.to)) {
        last.to = changeEnd(change);
      } else {
        cur.changes.push(historyChangeFromChange(doc, change));
      }
      cur.anchorAfter = selAfter.anchor;
      cur.headAfter = selAfter.head;
    } else {
      cur = {
        changes: [historyChangeFromChange(doc, change)],
        anchorBefore: doc.sel.anchor,
        headBefore: doc.sel.head,
        anchorAfter: selAfter.anchor,
        headAfter: selAfter.head
      };
      hist.done.push(cur);
      while (hist.done.length > hist.undoDepth)
        hist.done.shift();
      if (hist.dirtyCounter < 0)
        hist.dirtyCounter = NaN;
      else
        hist.dirtyCounter++;
    }
    hist.lastTime = time;
    hist.lastOp = opId;
    hist.lastOrigin = change.origin;
  }
  function removeClearedSpans(spans) {
    if (!spans)
      return null;
    for (var i = 0, out; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) {
        if (!out)
          out = spans.slice(0, i);
      } else if (out)
        out.push(spans[i]);
    }
    return !out ? spans : out.length ? out : null;
  }
  function getOldSpans(doc, change) {
    var found = change['spans_' + doc.id];
    if (!found)
      return null;
    for (var i = 0, nw = []; i < change.text.length; ++i)
      nw.push(removeClearedSpans(found[i]));
    return nw;
  }
  function copyHistoryArray(events, newGroup) {
    for (var i = 0, copy = []; i < events.length; ++i) {
      var event = events[i], changes = event.changes, newChanges = [];
      copy.push({
        changes: newChanges,
        anchorBefore: event.anchorBefore,
        headBefore: event.headBefore,
        anchorAfter: event.anchorAfter,
        headAfter: event.headAfter
      });
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j], m;
        newChanges.push({
          from: change.from,
          to: change.to,
          text: change.text
        });
        if (newGroup)
          for (var prop in change)
            if (m = prop.match(/^spans_(\d+)$/)) {
              if (indexOf(newGroup, Number(m[1])) > -1) {
                lst(newChanges)[prop] = change[prop];
                delete change[prop];
              }
            }
      }
    }
    return copy;
  }
  function rebaseHistSel(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i], ok = true;
      for (var j = 0; j < sub.changes.length; ++j) {
        var cur = sub.changes[j];
        if (!sub.copied) {
          cur.from = copyPos(cur.from);
          cur.to = copyPos(cur.to);
        }
        if (to < cur.from.line) {
          cur.from.line += diff;
          cur.to.line += diff;
        } else if (from <= cur.to.line) {
          ok = false;
          break;
        }
      }
      if (!sub.copied) {
        sub.anchorBefore = copyPos(sub.anchorBefore);
        sub.headBefore = copyPos(sub.headBefore);
        sub.anchorAfter = copyPos(sub.anchorAfter);
        sub.readAfter = copyPos(sub.headAfter);
        sub.copied = true;
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      } else {
        rebaseHistSel(sub.anchorBefore);
        rebaseHistSel(sub.headBefore);
        rebaseHistSel(sub.anchorAfter);
        rebaseHistSel(sub.headAfter);
      }
    }
  }
  function rebaseHist(hist, change) {
    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }
  function stopMethod() {
    e_stop(this);
  }
  function addStop(event) {
    if (!event.stop)
      event.stop = stopMethod;
    return event;
  }
  function e_preventDefault(e) {
    if (e.preventDefault)
      e.preventDefault();
    else
      e.returnValue = false;
  }
  function e_stopPropagation(e) {
    if (e.stopPropagation)
      e.stopPropagation();
    else
      e.cancelBubble = true;
  }
  function e_stop(e) {
    e_preventDefault(e);
    e_stopPropagation(e);
  }
  CodeMirror.e_stop = e_stop;
  CodeMirror.e_preventDefault = e_preventDefault;
  CodeMirror.e_stopPropagation = e_stopPropagation;
  function e_target(e) {
    return e.target || e.srcElement;
  }
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1)
        b = 1;
      else if (e.button & 2)
        b = 3;
      else if (e.button & 4)
        b = 2;
    }
    if (mac && e.ctrlKey && b == 1)
      b = 3;
    return b;
  }
  function on(emitter, type, f) {
    if (emitter.addEventListener)
      emitter.addEventListener(type, f, false);
    else if (emitter.attachEvent)
      emitter.attachEvent('on' + type, f);
    else {
      var map = emitter._handlers || (emitter._handlers = {});
      var arr = map[type] || (map[type] = []);
      arr.push(f);
    }
  }
  function off(emitter, type, f) {
    if (emitter.removeEventListener)
      emitter.removeEventListener(type, f, false);
    else if (emitter.detachEvent)
      emitter.detachEvent('on' + type, f);
    else {
      var arr = emitter._handlers && emitter._handlers[type];
      if (!arr)
        return;
      for (var i = 0; i < arr.length; ++i)
        if (arr[i] == f) {
          arr.splice(i, 1);
          break;
        }
    }
  }
  function signal(emitter, type) {
    var arr = emitter._handlers && emitter._handlers[type];
    if (!arr)
      return;
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i = 0; i < arr.length; ++i)
      arr[i].apply(null, args);
  }
  var delayedCallbacks, delayedCallbackDepth = 0;
  function signalLater(emitter, type) {
    var arr = emitter._handlers && emitter._handlers[type];
    if (!arr)
      return;
    var args = Array.prototype.slice.call(arguments, 2);
    if (!delayedCallbacks) {
      ++delayedCallbackDepth;
      delayedCallbacks = [];
      setTimeout(fireDelayed, 0);
    }
    function bnd(f) {
      return function () {
        f.apply(null, args);
      };
    }
    ;
    for (var i = 0; i < arr.length; ++i)
      delayedCallbacks.push(bnd(arr[i]));
  }
  function fireDelayed() {
    --delayedCallbackDepth;
    var delayed = delayedCallbacks;
    delayedCallbacks = null;
    for (var i = 0; i < delayed.length; ++i)
      delayed[i]();
  }
  function hasHandler(emitter, type) {
    var arr = emitter._handlers && emitter._handlers[type];
    return arr && arr.length > 0;
  }
  CodeMirror.on = on;
  CodeMirror.off = off;
  CodeMirror.signal = signal;
  var scrollerCutOff = 30;
  var Pass = CodeMirror.Pass = {
      toString: function () {
        return 'CodeMirror.Pass';
      }
    };
  function Delayed() {
    this.id = null;
  }
  Delayed.prototype = {
    set: function (ms, f) {
      clearTimeout(this.id);
      this.id = setTimeout(f, ms);
    }
  };
  function countColumn(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);
      if (end == -1)
        end = string.length;
    }
    for (var i = startIndex || 0, n = startValue || 0; i < end; ++i) {
      if (string.charAt(i) == '\t')
        n += tabSize - n % tabSize;
      else
        ++n;
    }
    return n;
  }
  CodeMirror.countColumn = countColumn;
  var spaceStrs = [''];
  function spaceStr(n) {
    while (spaceStrs.length <= n)
      spaceStrs.push(lst(spaceStrs) + ' ');
    return spaceStrs[n];
  }
  function lst(arr) {
    return arr[arr.length - 1];
  }
  function selectInput(node) {
    if (ios) {
      node.selectionStart = 0;
      node.selectionEnd = node.value.length;
    } else
      node.select();
  }
  function indexOf(collection, elt) {
    if (collection.indexOf)
      return collection.indexOf(elt);
    for (var i = 0, e = collection.length; i < e; ++i)
      if (collection[i] == elt)
        return i;
    return -1;
  }
  function createObj(base, props) {
    function Obj() {
    }
    Obj.prototype = base;
    var inst = new Obj();
    if (props)
      copyObj(props, inst);
    return inst;
  }
  function copyObj(obj, target) {
    if (!target)
      target = {};
    for (var prop in obj)
      if (obj.hasOwnProperty(prop))
        target[prop] = obj[prop];
    return target;
  }
  function emptyArray(size) {
    for (var a = [], i = 0; i < size; ++i)
      a.push(undefined);
    return a;
  }
  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function () {
      return f.apply(null, args);
    };
  }
  var nonASCIISingleCaseWordChar = /[\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc]/;
  function isWordChar(ch) {
    return /\w/.test(ch) || ch > '\x80' && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
  }
  function isEmpty(obj) {
    for (var n in obj)
      if (obj.hasOwnProperty(n) && obj[n])
        return false;
    return true;
  }
  var isExtendingChar = /[\u0300-\u036F\u0483-\u0487\u0488-\u0489\u0591-\u05BD\u05BF\u05C1-\u05C2\u05C4-\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7-\u06E8\u06EA-\u06ED\uA66F\uA670-\uA672\uA674-\uA67D\uA69F\udc00-\udfff]/;
  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className)
      e.className = className;
    if (style)
      e.style.cssText = style;
    if (typeof content == 'string')
      setTextContent(e, content);
    else if (content)
      for (var i = 0; i < content.length; ++i)
        e.appendChild(content[i]);
    return e;
  }
  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count)
      e.removeChild(e.firstChild);
    return e;
  }
  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e);
  }
  function setTextContent(e, str) {
    if (ie_lt9) {
      e.innerHTML = '';
      e.appendChild(document.createTextNode(str));
    } else
      e.textContent = str;
  }
  function getRect(node) {
    return node.getBoundingClientRect();
  }
  CodeMirror.replaceGetRect = function (f) {
    getRect = f;
  };
  var dragAndDrop = function () {
      if (ie_lt9)
        return false;
      var div = elt('div');
      return 'draggable' in div || 'dragDrop' in div;
    }();
  var spanAffectsWrapping = /^$/;
  if (gecko)
    spanAffectsWrapping = /$'/;
  else if (safari && !/Version\/([6-9]|\d\d)\b/.test(navigator.userAgent))
    spanAffectsWrapping = /\-[^ \-?]|\?[^ !'\"\),.\-\/:;\?\]\}]/;
  else if (webkit)
    spanAffectsWrapping = /[~!#%&*)=+}\]|\"\.>,:;][({[<]|-[^\-?\.]|\?[\w~`@#$%\^&*(_=+{[|><]/;
  var knownScrollbarWidth;
  function scrollbarWidth(measure) {
    if (knownScrollbarWidth != null)
      return knownScrollbarWidth;
    var test = elt('div', null, null, 'width: 50px; height: 50px; overflow-x: scroll');
    removeChildrenAndAdd(measure, test);
    if (test.offsetWidth)
      knownScrollbarWidth = test.offsetHeight - test.clientHeight;
    return knownScrollbarWidth || 0;
  }
  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt('span', '\u200b');
      removeChildrenAndAdd(measure, elt('span', [
        test,
        document.createTextNode('x')
      ]));
      if (measure.firstChild.offsetHeight != 0)
        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !ie_lt8;
    }
    if (zwspSupported)
      return elt('span', '\u200b');
    else
      return elt('span', '\xa0', null, 'display: inline-block; width: 1px; margin-right: -1px');
  }
  var splitLines = '\n\nb'.split(/\n/).length != 3 ? function (string) {
      var pos = 0, result = [], l = string.length;
      while (pos <= l) {
        var nl = string.indexOf('\n', pos);
        if (nl == -1)
          nl = string.length;
        var line = string.slice(pos, string.charAt(nl - 1) == '\r' ? nl - 1 : nl);
        var rt = line.indexOf('\r');
        if (rt != -1) {
          result.push(line.slice(0, rt));
          pos += rt + 1;
        } else {
          result.push(line);
          pos = nl + 1;
        }
      }
      return result;
    } : function (string) {
      return string.split(/\r\n?|\n/);
    };
  CodeMirror.splitLines = splitLines;
  var hasSelection = window.getSelection ? function (te) {
      try {
        return te.selectionStart != te.selectionEnd;
      } catch (e) {
        return false;
      }
    } : function (te) {
      try {
        var range = te.ownerDocument.selection.createRange();
      } catch (e) {
      }
      if (!range || range.parentElement() != te)
        return false;
      return range.compareEndPoints('StartToEnd', range) != 0;
    };
  var hasCopyEvent = function () {
      var e = elt('div');
      if ('oncopy' in e)
        return true;
      e.setAttribute('oncopy', 'return;');
      return typeof e.oncopy == 'function';
    }();
  var keyNames = {
      3: 'Enter',
      8: 'Backspace',
      9: 'Tab',
      13: 'Enter',
      16: 'Shift',
      17: 'Ctrl',
      18: 'Alt',
      19: 'Pause',
      20: 'CapsLock',
      27: 'Esc',
      32: 'Space',
      33: 'PageUp',
      34: 'PageDown',
      35: 'End',
      36: 'Home',
      37: 'Left',
      38: 'Up',
      39: 'Right',
      40: 'Down',
      44: 'PrintScrn',
      45: 'Insert',
      46: 'Delete',
      59: ';',
      91: 'Mod',
      92: 'Mod',
      93: 'Mod',
      109: '-',
      107: '=',
      127: 'Delete',
      186: ';',
      187: '=',
      188: ',',
      189: '-',
      190: '.',
      191: '/',
      192: '`',
      219: '[',
      220: '\\',
      221: ']',
      222: '\'',
      63276: 'PageUp',
      63277: 'PageDown',
      63275: 'End',
      63273: 'Home',
      63234: 'Left',
      63232: 'Up',
      63235: 'Right',
      63233: 'Down',
      63302: 'Insert',
      63272: 'Delete'
    };
  CodeMirror.keyNames = keyNames;
  (function () {
    for (var i = 0; i < 10; i++)
      keyNames[i + 48] = String(i);
    for (var i = 65; i <= 90; i++)
      keyNames[i] = String.fromCharCode(i);
    for (var i = 1; i <= 12; i++)
      keyNames[i + 111] = keyNames[i + 63235] = 'F' + i;
  }());
  function iterateBidiSections(order, from, to, f) {
    if (!order)
      return f(from, to, 'ltr');
    for (var i = 0; i < order.length; ++i) {
      var part = order[i];
      if (part.from < to && part.to > from || from == to && part.to == from)
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? 'rtl' : 'ltr');
    }
  }
  function bidiLeft(part) {
    return part.level % 2 ? part.to : part.from;
  }
  function bidiRight(part) {
    return part.level % 2 ? part.from : part.to;
  }
  function lineLeft(line) {
    var order = getOrder(line);
    return order ? bidiLeft(order[0]) : 0;
  }
  function lineRight(line) {
    var order = getOrder(line);
    if (!order)
      return line.text.length;
    return bidiRight(lst(order));
  }
  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(cm.doc, line);
    if (visual != line)
      lineN = lineNo(visual);
    var order = getOrder(visual);
    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);
    return Pos(lineN, ch);
  }
  function lineEnd(cm, lineN) {
    var merged, line;
    while (merged = collapsedSpanAtEnd(line = getLine(cm.doc, lineN)))
      lineN = merged.find().to.line;
    var order = getOrder(line);
    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);
    return Pos(lineN, ch);
  }
  function moveVisually(line, start, dir, byUnit) {
    var bidi = getOrder(line);
    if (!bidi)
      return moveLogically(line, start, dir, byUnit);
    var moveOneUnit = byUnit ? function (pos, dir) {
        do
          pos += dir;
        while (pos > 0 && isExtendingChar.test(line.text.charAt(pos)));
        return pos;
      } : function (pos, dir) {
        return pos + dir;
      };
    var linedir = bidi[0].level;
    for (var i = 0; i < bidi.length; ++i) {
      var part = bidi[i], sticky = part.level % 2 == linedir;
      if (part.from < start && part.to > start || sticky && (part.from == start || part.to == start))
        break;
    }
    var target = moveOneUnit(start, part.level % 2 ? -dir : dir);
    while (target != null) {
      if (part.level % 2 == linedir) {
        if (target < part.from || target > part.to) {
          part = bidi[i += dir];
          target = part && (dir > 0 == part.level % 2 ? moveOneUnit(part.to, -1) : moveOneUnit(part.from, 1));
        } else
          break;
      } else {
        if (target == bidiLeft(part)) {
          part = bidi[--i];
          target = part && bidiRight(part);
        } else if (target == bidiRight(part)) {
          part = bidi[++i];
          target = part && bidiLeft(part);
        } else
          break;
      }
    }
    return target < 0 || target > line.text.length ? null : target;
  }
  function moveLogically(line, start, dir, byUnit) {
    var target = start + dir;
    if (byUnit)
      while (target > 0 && isExtendingChar.test(line.text.charAt(target)))
        target += dir;
    return target < 0 || target > line.text.length ? null : target;
  }
  var bidiOrdering = function () {
      var lowTypes = 'bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLL';
      var arabicTypes = 'rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmmrrrrrrrrrrrrrrrrrr';
      function charType(code) {
        if (code <= 255)
          return lowTypes.charAt(code);
        else if (1424 <= code && code <= 1524)
          return 'R';
        else if (1536 <= code && code <= 1791)
          return arabicTypes.charAt(code - 1536);
        else if (1792 <= code && code <= 2220)
          return 'r';
        else
          return 'L';
      }
      var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
      var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
      var outerType = 'L';
      return function (str) {
        if (!bidiRE.test(str))
          return false;
        var len = str.length, types = [];
        for (var i = 0, type; i < len; ++i)
          types.push(type = charType(str.charCodeAt(i)));
        for (var i = 0, prev = outerType; i < len; ++i) {
          var type = types[i];
          if (type == 'm')
            types[i] = prev;
          else
            prev = type;
        }
        for (var i = 0, cur = outerType; i < len; ++i) {
          var type = types[i];
          if (type == '1' && cur == 'r')
            types[i] = 'n';
          else if (isStrong.test(type)) {
            cur = type;
            if (type == 'r')
              types[i] = 'R';
          }
        }
        for (var i = 1, prev = types[0]; i < len - 1; ++i) {
          var type = types[i];
          if (type == '+' && prev == '1' && types[i + 1] == '1')
            types[i] = '1';
          else if (type == ',' && prev == types[i + 1] && (prev == '1' || prev == 'n'))
            types[i] = prev;
          prev = type;
        }
        for (var i = 0; i < len; ++i) {
          var type = types[i];
          if (type == ',')
            types[i] = 'N';
          else if (type == '%') {
            for (var end = i + 1; end < len && types[end] == '%'; ++end) {
            }
            var replace = i && types[i - 1] == '!' || end < len - 1 && types[end] == '1' ? '1' : 'N';
            for (var j = i; j < end; ++j)
              types[j] = replace;
            i = end - 1;
          }
        }
        for (var i = 0, cur = outerType; i < len; ++i) {
          var type = types[i];
          if (cur == 'L' && type == '1')
            types[i] = 'L';
          else if (isStrong.test(type))
            cur = type;
        }
        for (var i = 0; i < len; ++i) {
          if (isNeutral.test(types[i])) {
            for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {
            }
            var before = (i ? types[i - 1] : outerType) == 'L';
            var after = (end < len - 1 ? types[end] : outerType) == 'L';
            var replace = before || after ? 'L' : 'R';
            for (var j = i; j < end; ++j)
              types[j] = replace;
            i = end - 1;
          }
        }
        var order = [], m;
        for (var i = 0; i < len;) {
          if (countsAsLeft.test(types[i])) {
            var start = i;
            for (++i; i < len && countsAsLeft.test(types[i]); ++i) {
            }
            order.push({
              from: start,
              to: i,
              level: 0
            });
          } else {
            var pos = i, at = order.length;
            for (++i; i < len && types[i] != 'L'; ++i) {
            }
            for (var j = pos; j < i;) {
              if (countsAsNum.test(types[j])) {
                if (pos < j)
                  order.splice(at, 0, {
                    from: pos,
                    to: j,
                    level: 1
                  });
                var nstart = j;
                for (++j; j < i && countsAsNum.test(types[j]); ++j) {
                }
                order.splice(at, 0, {
                  from: nstart,
                  to: j,
                  level: 2
                });
                pos = j;
              } else
                ++j;
            }
            if (pos < i)
              order.splice(at, 0, {
                from: pos,
                to: i,
                level: 1
              });
          }
        }
        if (order[0].level == 1 && (m = str.match(/^\s+/))) {
          order[0].from = m[0].length;
          order.unshift({
            from: 0,
            to: m[0].length,
            level: 0
          });
        }
        if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
          lst(order).to -= m[0].length;
          order.push({
            from: len - m[0].length,
            to: len,
            level: 0
          });
        }
        if (order[0].level != lst(order).level)
          order.push({
            from: len,
            to: len,
            level: order[0].level
          });
        return order;
      };
    }();
  CodeMirror.version = '3.11 +';
  return CodeMirror;
}();
CodeMirror.defineMode('python', function (conf, parserConf) {
  var ERRORCLASS = 'error';
  function wordRegexp(words) {
    return new RegExp('^((' + words.join(')|(') + '))\\b');
  }
  var singleOperators = parserConf.singleOperators || new RegExp('^[\\+\\-\\*/%&|\\^~<>!]');
  var singleDelimiters = parserConf.singleDelimiters || new RegExp('^[\\(\\)\\[\\]\\{\\}@,:`=;\\.]');
  var doubleOperators = parserConf.doubleOperators || new RegExp('^((==)|(!=)|(<=)|(>=)|(<>)|(<<)|(>>)|(//)|(\\*\\*))');
  var doubleDelimiters = parserConf.doubleDelimiters || new RegExp('^((\\+=)|(\\-=)|(\\*=)|(%=)|(/=)|(&=)|(\\|=)|(\\^=))');
  var tripleDelimiters = parserConf.tripleDelimiters || new RegExp('^((//=)|(>>=)|(<<=)|(\\*\\*=))');
  var identifiers = parserConf.identifiers || new RegExp('^[_A-Za-z][_A-Za-z0-9]*');
  var wordOperators = wordRegexp([
      'and',
      'or',
      'not',
      'is',
      'in'
    ]);
  var commonkeywords = [
      'as',
      'assert',
      'break',
      'class',
      'continue',
      'def',
      'del',
      'elif',
      'else',
      'except',
      'finally',
      'for',
      'from',
      'global',
      'if',
      'import',
      'lambda',
      'pass',
      'raise',
      'return',
      'try',
      'while',
      'with',
      'yield'
    ];
  var commonBuiltins = [
      'abs',
      'all',
      'any',
      'bin',
      'bool',
      'bytearray',
      'callable',
      'chr',
      'classmethod',
      'compile',
      'complex',
      'delattr',
      'dict',
      'dir',
      'divmod',
      'enumerate',
      'eval',
      'filter',
      'float',
      'format',
      'frozenset',
      'getattr',
      'globals',
      'hasattr',
      'hash',
      'help',
      'hex',
      'id',
      'input',
      'int',
      'isinstance',
      'issubclass',
      'iter',
      'len',
      'list',
      'locals',
      'map',
      'max',
      'memoryview',
      'min',
      'next',
      'object',
      'oct',
      'open',
      'ord',
      'pow',
      'property',
      'range',
      'repr',
      'reversed',
      'round',
      'set',
      'setattr',
      'slice',
      'sorted',
      'staticmethod',
      'str',
      'sum',
      'super',
      'tuple',
      'type',
      'vars',
      'zip',
      '__import__',
      'NotImplemented',
      'Ellipsis',
      '__debug__'
    ];
  var py2 = {
      'builtins': [
        'apply',
        'basestring',
        'buffer',
        'cmp',
        'coerce',
        'execfile',
        'file',
        'intern',
        'long',
        'raw_input',
        'reduce',
        'reload',
        'unichr',
        'unicode',
        'xrange',
        'False',
        'True',
        'None'
      ],
      'keywords': [
        'exec',
        'print'
      ]
    };
  var py3 = {
      'builtins': [
        'ascii',
        'bytes',
        'exec',
        'print'
      ],
      'keywords': [
        'nonlocal',
        'False',
        'True',
        'None'
      ]
    };
  if (!!parserConf.version && parseInt(parserConf.version, 10) === 3) {
    commonkeywords = commonkeywords.concat(py3.keywords);
    commonBuiltins = commonBuiltins.concat(py3.builtins);
    var stringPrefixes = new RegExp('^(([rb]|(br))?(\'{3}|"{3}|[\'"]))', 'i');
  } else {
    commonkeywords = commonkeywords.concat(py2.keywords);
    commonBuiltins = commonBuiltins.concat(py2.builtins);
    var stringPrefixes = new RegExp('^(([rub]|(ur)|(br))?(\'{3}|"{3}|[\'"]))', 'i');
  }
  var keywords = wordRegexp(commonkeywords);
  var builtins = wordRegexp(commonBuiltins);
  var indentInfo = null;
  function tokenBase(stream, state) {
    if (stream.sol()) {
      var scopeOffset = state.scopes[0].offset;
      if (stream.eatSpace()) {
        var lineOffset = stream.indentation();
        if (lineOffset > scopeOffset) {
          indentInfo = 'indent';
        } else if (lineOffset < scopeOffset) {
          indentInfo = 'dedent';
        }
        return null;
      } else {
        if (scopeOffset > 0) {
          dedent(stream, state);
        }
      }
    }
    if (stream.eatSpace()) {
      return null;
    }
    var ch = stream.peek();
    if (ch === '#') {
      stream.skipToEnd();
      return 'comment';
    }
    if (stream.match(/^[0-9\.]/, false)) {
      var floatLiteral = false;
      if (stream.match(/^\d*\.\d+(e[\+\-]?\d+)?/i)) {
        floatLiteral = true;
      }
      if (stream.match(/^\d+\.\d*/)) {
        floatLiteral = true;
      }
      if (stream.match(/^\.\d+/)) {
        floatLiteral = true;
      }
      if (floatLiteral) {
        stream.eat(/J/i);
        return 'number';
      }
      var intLiteral = false;
      if (stream.match(/^0x[0-9a-f]+/i)) {
        intLiteral = true;
      }
      if (stream.match(/^0b[01]+/i)) {
        intLiteral = true;
      }
      if (stream.match(/^0o[0-7]+/i)) {
        intLiteral = true;
      }
      if (stream.match(/^[1-9]\d*(e[\+\-]?\d+)?/)) {
        stream.eat(/J/i);
        intLiteral = true;
      }
      if (stream.match(/^0(?![\dx])/i)) {
        intLiteral = true;
      }
      if (intLiteral) {
        stream.eat(/L/i);
        return 'number';
      }
    }
    if (stream.match(stringPrefixes)) {
      state.tokenize = tokenStringFactory(stream.current());
      return state.tokenize(stream, state);
    }
    if (stream.match(tripleDelimiters) || stream.match(doubleDelimiters)) {
      return null;
    }
    if (stream.match(doubleOperators) || stream.match(singleOperators) || stream.match(wordOperators)) {
      return 'operator';
    }
    if (stream.match(singleDelimiters)) {
      return null;
    }
    if (stream.match(keywords)) {
      return 'keyword';
    }
    if (stream.match(builtins)) {
      return 'builtin';
    }
    if (stream.match(identifiers)) {
      return 'variable';
    }
    stream.next();
    return ERRORCLASS;
  }
  function tokenStringFactory(delimiter) {
    while ('rub'.indexOf(delimiter.charAt(0).toLowerCase()) >= 0) {
      delimiter = delimiter.substr(1);
    }
    var singleline = delimiter.length == 1;
    var OUTCLASS = 'string';
    function tokenString(stream, state) {
      while (!stream.eol()) {
        stream.eatWhile(/[^'"\\]/);
        if (stream.eat('\\')) {
          stream.next();
          if (singleline && stream.eol()) {
            return OUTCLASS;
          }
        } else if (stream.match(delimiter)) {
          state.tokenize = tokenBase;
          return OUTCLASS;
        } else {
          stream.eat(/['"]/);
        }
      }
      if (singleline) {
        if (parserConf.singleLineStringErrors) {
          return ERRORCLASS;
        } else {
          state.tokenize = tokenBase;
        }
      }
      return OUTCLASS;
    }
    tokenString.isString = true;
    return tokenString;
  }
  function indent(stream, state, type) {
    type = type || 'py';
    var indentUnit = 0;
    if (type === 'py') {
      if (state.scopes[0].type !== 'py') {
        state.scopes[0].offset = stream.indentation();
        return;
      }
      for (var i = 0; i < state.scopes.length; ++i) {
        if (state.scopes[i].type === 'py') {
          indentUnit = state.scopes[i].offset + conf.indentUnit;
          break;
        }
      }
    } else {
      indentUnit = stream.column() + stream.current().length;
    }
    state.scopes.unshift({
      offset: indentUnit,
      type: type
    });
  }
  function dedent(stream, state, type) {
    type = type || 'py';
    if (state.scopes.length == 1)
      return;
    if (state.scopes[0].type === 'py') {
      var _indent = stream.indentation();
      var _indent_index = -1;
      for (var i = 0; i < state.scopes.length; ++i) {
        if (_indent === state.scopes[i].offset) {
          _indent_index = i;
          break;
        }
      }
      if (_indent_index === -1) {
        return true;
      }
      while (state.scopes[0].offset !== _indent) {
        state.scopes.shift();
      }
      return false;
    } else {
      if (type === 'py') {
        state.scopes[0].offset = stream.indentation();
        return false;
      } else {
        if (state.scopes[0].type != type) {
          return true;
        }
        state.scopes.shift();
        return false;
      }
    }
  }
  function tokenLexer(stream, state) {
    indentInfo = null;
    var style = state.tokenize(stream, state);
    var current = stream.current();
    if (current === '.') {
      style = stream.match(identifiers, false) ? null : ERRORCLASS;
      if (style === null && state.lastToken === 'meta') {
        style = 'meta';
      }
      return style;
    }
    if (current === '@') {
      return stream.match(identifiers, false) ? 'meta' : ERRORCLASS;
    }
    if ((style === 'variable' || style === 'builtin') && state.lastToken === 'meta') {
      style = 'meta';
    }
    if (current === 'pass' || current === 'return') {
      state.dedent += 1;
    }
    if (current === 'lambda')
      state.lambda = true;
    if (current === ':' && !state.lambda && state.scopes[0].type == 'py' || indentInfo === 'indent') {
      indent(stream, state);
    }
    var delimiter_index = '[({'.indexOf(current);
    if (delimiter_index !== -1) {
      indent(stream, state, '])}'.slice(delimiter_index, delimiter_index + 1));
    }
    if (indentInfo === 'dedent') {
      if (dedent(stream, state)) {
        return ERRORCLASS;
      }
    }
    delimiter_index = '])}'.indexOf(current);
    if (delimiter_index !== -1) {
      if (dedent(stream, state, current)) {
        return ERRORCLASS;
      }
    }
    if (state.dedent > 0 && stream.eol() && state.scopes[0].type == 'py') {
      if (state.scopes.length > 1)
        state.scopes.shift();
      state.dedent -= 1;
    }
    return style;
  }
  var external = {
      startState: function (basecolumn) {
        return {
          tokenize: tokenBase,
          scopes: [{
              offset: basecolumn || 0,
              type: 'py'
            }],
          lastToken: null,
          lambda: false,
          dedent: 0
        };
      },
      token: function (stream, state) {
        var style = tokenLexer(stream, state);
        state.lastToken = style;
        if (stream.eol() && stream.lambda) {
          state.lambda = false;
        }
        return style;
      },
      indent: function (state) {
        if (state.tokenize != tokenBase) {
          return state.tokenize.isString ? CodeMirror.Pass : 0;
        }
        return state.scopes[0].offset;
      }
    };
  return external;
});
CodeMirror.defineMIME('text/x-python', 'python');
this.createjs = this.createjs || {};
(function () {
  var c = function () {
    throw 'UID cannot be instantiated';
  };
  c._nextID = 0;
  c.get = function () {
    return c._nextID++;
  };
  createjs.UID = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
      this.initialize();
    }, b = c.prototype;
  c.initialize = function (a) {
    a.addEventListener = b.addEventListener;
    a.removeEventListener = b.removeEventListener;
    a.removeAllEventListeners = b.removeAllEventListeners;
    a.hasEventListener = b.hasEventListener;
    a.dispatchEvent = b.dispatchEvent;
  };
  b._listeners = null;
  b.initialize = function () {
  };
  b.addEventListener = function (a, m) {
    var b = this._listeners;
    b ? this.removeEventListener(a, m) : b = this._listeners = {};
    var d = b[a];
    d || (d = b[a] = []);
    d.push(m);
    return m;
  };
  b.removeEventListener = function (a, m) {
    var b = this._listeners;
    if (b) {
      var d = b[a];
      if (d)
        for (var e = 0, c = d.length; e < c; e++)
          if (d[e] == m) {
            1 == c ? delete b[a] : d.splice(e, 1);
            break;
          }
    }
  };
  b.removeAllEventListeners = function (a) {
    a ? this._listeners && delete this._listeners[a] : this._listeners = null;
  };
  b.dispatchEvent = function (a, m) {
    var b = !1, d = this._listeners;
    if (a && d) {
      'string' == typeof a && (a = { type: a });
      d = d[a.type];
      if (!d)
        return b;
      a.target = m || this;
      for (var d = d.slice(), e = 0, c = d.length; e < c; e++)
        var h = d[e], b = h.handleEvent ? b || h.handleEvent(a) : b || h(a);
    }
    return !!b;
  };
  b.hasEventListener = function (a) {
    var m = this._listeners;
    return !(!m || !m[a]);
  };
  b.toString = function () {
    return '[EventDispatcher]';
  };
  createjs.EventDispatcher = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
    throw 'Ticker cannot be instantiated.';
  };
  c.useRAF = !1;
  c.addEventListener = null;
  c.removeEventListener = null;
  c.removeAllEventListeners = null;
  c.dispatchEvent = null;
  c.hasEventListener = null;
  c._listeners = null;
  createjs.EventDispatcher.initialize(c);
  c._listeners = null;
  c._pauseable = null;
  c._paused = !1;
  c._inited = !1;
  c._startTime = 0;
  c._pausedTime = 0;
  c._ticks = 0;
  c._pausedTicks = 0;
  c._interval = 50;
  c._lastTime = 0;
  c._times = null;
  c._tickTimes = null;
  c._rafActive = !1;
  c._timeoutID = null;
  c.addListener = function (a, m) {
    null != a && (c.removeListener(a), c._pauseable[c._listeners.length] = null == m ? !0 : m, c._listeners.push(a));
  };
  c.init = function () {
    c._inited = !0;
    c._times = [];
    c._tickTimes = [];
    c._pauseable = [];
    c._listeners = [];
    c._times.push(c._lastTime = c._startTime = c._getTime());
    c.setInterval(c._interval);
  };
  c.removeListener = function (a) {
    var m = c._listeners;
    m && (a = m.indexOf(a), -1 != a && (m.splice(a, 1), c._pauseable.splice(a, 1)));
  };
  c.removeAllListeners = function () {
    c._listeners = [];
    c._pauseable = [];
  };
  c.setInterval = function (a) {
    c._interval = a;
    c._inited && c._setupTick();
  };
  c.getInterval = function () {
    return c._interval;
  };
  c.setFPS = function (a) {
    c.setInterval(1000 / a);
  };
  c.getFPS = function () {
    return 1000 / c._interval;
  };
  c.getMeasuredFPS = function (a) {
    if (2 > c._times.length)
      return -1;
    null == a && (a = c.getFPS() | 0);
    a = Math.min(c._times.length - 1, a);
    return 1000 / ((c._times[0] - c._times[a]) / a);
  };
  c.setPaused = function (a) {
    c._paused = a;
  };
  c.getPaused = function () {
    return c._paused;
  };
  c.getTime = function (a) {
    return c._getTime() - c._startTime - (a ? c._pausedTime : 0);
  };
  c.getTicks = function (a) {
    return c._ticks - (a ? c._pausedTicks : 0);
  };
  c._handleAF = function () {
    c._rafActive = !1;
    c._setupTick();
    c._getTime() - c._lastTime >= 0.97 * (c._interval - 1) && c._tick();
  };
  c._handleTimeout = function () {
    c.timeoutID = null;
    c._setupTick();
    c._tick();
  };
  c._setupTick = function () {
    if (!(c._rafActive || null != c.timeoutID)) {
      if (c.useRAF) {
        var a = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;
        if (a) {
          a(c._handleAF);
          c._rafActive = !0;
          return;
        }
      }
      c.timeoutID = setTimeout(c._handleTimeout, c._interval);
    }
  };
  c._tick = function () {
    var a = c._getTime();
    c._ticks++;
    var m = a - c._lastTime, b = c._paused;
    b && (c._pausedTicks++, c._pausedTime += m);
    c._lastTime = a;
    for (var d = c._pauseable, e = c._listeners.slice(), f = e ? e.length : 0, h = 0; h < f; h++) {
      var k = e[h];
      null == k || b && d[h] || (k.tick ? k.tick(m, b) : k instanceof Function && k(m, b));
    }
    c.dispatchEvent({
      type: 'tick',
      paused: b,
      delta: m,
      time: a,
      runTime: a - c._pausedTime
    });
    for (c._tickTimes.unshift(c._getTime() - a); 100 < c._tickTimes.length;)
      c._tickTimes.pop();
    for (c._times.unshift(a); 100 < c._times.length;)
      c._times.pop();
  };
  var b = window.performance && (performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow);
  c._getTime = function () {
    return b && b.call(performance) || new Date().getTime();
  };
  c.init();
  createjs.Ticker = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a, m, b, d, e, c, h, k, j) {
      this.initialize(a, m, b, d, e, c, h, k, j);
    }, b = c.prototype;
  b.stageX = 0;
  b.stageY = 0;
  b.rawX = 0;
  b.rawY = 0;
  b.type = null;
  b.nativeEvent = null;
  b.onMouseMove = null;
  b.onMouseUp = null;
  b.target = null;
  b.pointerID = 0;
  b.primary = !1;
  b.addEventListener = null;
  b.removeEventListener = null;
  b.removeAllEventListeners = null;
  b.dispatchEvent = null;
  b.hasEventListener = null;
  b._listeners = null;
  createjs.EventDispatcher.initialize(b);
  b.initialize = function (a, m, b, d, e, c, h, k, j) {
    this.type = a;
    this.stageX = m;
    this.stageY = b;
    this.target = d;
    this.nativeEvent = e;
    this.pointerID = c;
    this.primary = h;
    this.rawX = null == k ? m : k;
    this.rawY = null == j ? b : j;
  };
  b.clone = function () {
    return new c(this.type, this.stageX, this.stageY, this.target, this.nativeEvent, this.pointerID, this.primary, this.rawX, this.rawY);
  };
  b.toString = function () {
    return '[MouseEvent (type=' + this.type + ' stageX=' + this.stageX + ' stageY=' + this.stageY + ')]';
  };
  createjs.MouseEvent = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a, m, b, d, c, f) {
      this.initialize(a, m, b, d, c, f);
    }, b = c.prototype;
  c.identity = null;
  c.DEG_TO_RAD = Math.PI / 180;
  b.a = 1;
  b.b = 0;
  b.c = 0;
  b.d = 1;
  b.tx = 0;
  b.ty = 0;
  b.alpha = 1;
  b.shadow = null;
  b.compositeOperation = null;
  b.initialize = function (a, m, b, d, c, f) {
    null != a && (this.a = a);
    this.b = m || 0;
    this.c = b || 0;
    null != d && (this.d = d);
    this.tx = c || 0;
    this.ty = f || 0;
    return this;
  };
  b.prepend = function (a, b, g, d, c, f) {
    var h = this.tx;
    if (1 != a || 0 != b || 0 != g || 1 != d) {
      var k = this.a, j = this.c;
      this.a = k * a + this.b * g;
      this.b = k * b + this.b * d;
      this.c = j * a + this.d * g;
      this.d = j * b + this.d * d;
    }
    this.tx = h * a + this.ty * g + c;
    this.ty = h * b + this.ty * d + f;
    return this;
  };
  b.append = function (a, b, g, d, c, f) {
    var h = this.a, k = this.b, j = this.c, l = this.d;
    this.a = a * h + b * j;
    this.b = a * k + b * l;
    this.c = g * h + d * j;
    this.d = g * k + d * l;
    this.tx = c * h + f * j + this.tx;
    this.ty = c * k + f * l + this.ty;
    return this;
  };
  b.prependMatrix = function (a) {
    this.prepend(a.a, a.b, a.c, a.d, a.tx, a.ty);
    this.prependProperties(a.alpha, a.shadow, a.compositeOperation);
    return this;
  };
  b.appendMatrix = function (a) {
    this.append(a.a, a.b, a.c, a.d, a.tx, a.ty);
    this.appendProperties(a.alpha, a.shadow, a.compositeOperation);
    return this;
  };
  b.prependTransform = function (a, b, g, d, e, f, h, k, j) {
    if (e % 360) {
      var l = e * c.DEG_TO_RAD;
      e = Math.cos(l);
      l = Math.sin(l);
    } else
      e = 1, l = 0;
    if (k || j)
      this.tx -= k, this.ty -= j;
    f || h ? (f *= c.DEG_TO_RAD, h *= c.DEG_TO_RAD, this.prepend(e * g, l * g, -l * d, e * d, 0, 0), this.prepend(Math.cos(h), Math.sin(h), -Math.sin(f), Math.cos(f), a, b)) : this.prepend(e * g, l * g, -l * d, e * d, a, b);
    return this;
  };
  b.appendTransform = function (a, b, g, d, e, f, h, k, j) {
    if (e % 360) {
      var l = e * c.DEG_TO_RAD;
      e = Math.cos(l);
      l = Math.sin(l);
    } else
      e = 1, l = 0;
    f || h ? (f *= c.DEG_TO_RAD, h *= c.DEG_TO_RAD, this.append(Math.cos(h), Math.sin(h), -Math.sin(f), Math.cos(f), a, b), this.append(e * g, l * g, -l * d, e * d, 0, 0)) : this.append(e * g, l * g, -l * d, e * d, a, b);
    if (k || j)
      this.tx -= k * this.a + j * this.c, this.ty -= k * this.b + j * this.d;
    return this;
  };
  b.rotate = function (a) {
    var b = Math.cos(a);
    a = Math.sin(a);
    var g = this.a, d = this.c, c = this.tx;
    this.a = g * b - this.b * a;
    this.b = g * a + this.b * b;
    this.c = d * b - this.d * a;
    this.d = d * a + this.d * b;
    this.tx = c * b - this.ty * a;
    this.ty = c * a + this.ty * b;
    return this;
  };
  b.skew = function (a, b) {
    a *= c.DEG_TO_RAD;
    b *= c.DEG_TO_RAD;
    this.append(Math.cos(b), Math.sin(b), -Math.sin(a), Math.cos(a), 0, 0);
    return this;
  };
  b.scale = function (a, b) {
    this.a *= a;
    this.d *= b;
    this.c *= a;
    this.b *= b;
    this.tx *= a;
    this.ty *= b;
    return this;
  };
  b.translate = function (a, b) {
    this.tx += a;
    this.ty += b;
    return this;
  };
  b.identity = function () {
    this.alpha = this.a = this.d = 1;
    this.b = this.c = this.tx = this.ty = 0;
    this.shadow = this.compositeOperation = null;
    return this;
  };
  b.invert = function () {
    var a = this.a, b = this.b, g = this.c, d = this.d, c = this.tx, f = a * d - b * g;
    this.a = d / f;
    this.b = -b / f;
    this.c = -g / f;
    this.d = a / f;
    this.tx = (g * this.ty - d * c) / f;
    this.ty = -(a * this.ty - b * c) / f;
    return this;
  };
  b.isIdentity = function () {
    return 0 == this.tx && 0 == this.ty && 1 == this.a && 0 == this.b && 0 == this.c && 1 == this.d;
  };
  b.decompose = function (a) {
    null == a && (a = {});
    a.x = this.tx;
    a.y = this.ty;
    a.scaleX = Math.sqrt(this.a * this.a + this.b * this.b);
    a.scaleY = Math.sqrt(this.c * this.c + this.d * this.d);
    var b = Math.atan2(-this.c, this.d), g = Math.atan2(this.b, this.a);
    b == g ? (a.rotation = g / c.DEG_TO_RAD, 0 > this.a && 0 <= this.d && (a.rotation += 0 >= a.rotation ? 180 : -180), a.skewX = a.skewY = 0) : (a.skewX = b / c.DEG_TO_RAD, a.skewY = g / c.DEG_TO_RAD);
    return a;
  };
  b.reinitialize = function (a, b, g, d, c, f, h, k, j) {
    this.initialize(a, b, g, d, c, f);
    this.alpha = h || 1;
    this.shadow = k;
    this.compositeOperation = j;
    return this;
  };
  b.appendProperties = function (a, b, g) {
    this.alpha *= a;
    this.shadow = b || this.shadow;
    this.compositeOperation = g || this.compositeOperation;
    return this;
  };
  b.prependProperties = function (a, b, g) {
    this.alpha *= a;
    this.shadow = this.shadow || b;
    this.compositeOperation = this.compositeOperation || g;
    return this;
  };
  b.clone = function () {
    var a = new c(this.a, this.b, this.c, this.d, this.tx, this.ty);
    a.shadow = this.shadow;
    a.alpha = this.alpha;
    a.compositeOperation = this.compositeOperation;
    return a;
  };
  b.toString = function () {
    return '[Matrix2D (a=' + this.a + ' b=' + this.b + ' c=' + this.c + ' d=' + this.d + ' tx=' + this.tx + ' ty=' + this.ty + ')]';
  };
  c.identity = new c(1, 0, 0, 1, 0, 0);
  createjs.Matrix2D = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a, b) {
      this.initialize(a, b);
    }, b = c.prototype;
  b.x = 0;
  b.y = 0;
  b.initialize = function (a, b) {
    this.x = null == a ? 0 : a;
    this.y = null == b ? 0 : b;
  };
  b.clone = function () {
    return new c(this.x, this.y);
  };
  b.toString = function () {
    return '[Point (x=' + this.x + ' y=' + this.y + ')]';
  };
  createjs.Point = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a, b, g, d) {
      this.initialize(a, b, g, d);
    }, b = c.prototype;
  b.x = 0;
  b.y = 0;
  b.width = 0;
  b.height = 0;
  b.initialize = function (a, b, g, d) {
    this.x = null == a ? 0 : a;
    this.y = null == b ? 0 : b;
    this.width = null == g ? 0 : g;
    this.height = null == d ? 0 : d;
  };
  b.clone = function () {
    return new c(this.x, this.y, this.width, this.height);
  };
  b.toString = function () {
    return '[Rectangle (x=' + this.x + ' y=' + this.y + ' width=' + this.width + ' height=' + this.height + ')]';
  };
  createjs.Rectangle = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a, b, g, d, c, f, h) {
      this.initialize(a, b, g, d, c, f, h);
    }, b = c.prototype;
  b.target = null;
  b.overLabel = null;
  b.outLabel = null;
  b.downLabel = null;
  b.play = !1;
  b._isPressed = !1;
  b._isOver = !1;
  b.initialize = function (a, b, g, d, c, f, h) {
    a.addEventListener && (this.target = a, a.cursor = 'pointer', this.overLabel = null == g ? 'over' : g, this.outLabel = null == b ? 'out' : b, this.downLabel = null == d ? 'down' : d, this.play = c, this.setEnabled(!0), this.handleEvent({}), f && (h && (f.actionsEnabled = !1, f.gotoAndStop && f.gotoAndStop(h)), a.hitArea = f));
  };
  b.setEnabled = function (a) {
    var b = this.target;
    a ? (b.addEventListener('mouseover', this), b.addEventListener('mouseout', this), b.addEventListener('mousedown', this)) : (b.removeEventListener('mouseover', this), b.removeEventListener('mouseout', this), b.removeEventListener('mousedown', this));
  };
  b.toString = function () {
    return '[ButtonHelper]';
  };
  b.handleEvent = function (a) {
    var b = this.target, g = a.type;
    'mousedown' == g ? (a.addEventListener('mouseup', this), this._isPressed = !0, a = this.downLabel) : 'mouseup' == g ? (this._isPressed = !1, a = this._isOver ? this.overLabel : this.outLabel) : 'mouseover' == g ? (this._isOver = !0, a = this._isPressed ? this.downLabel : this.overLabel) : (this._isOver = !1, a = this._isPressed ? this.overLabel : this.outLabel);
    this.play ? b.gotoAndPlay && b.gotoAndPlay(a) : b.gotoAndStop && b.gotoAndStop(a);
  };
  createjs.ButtonHelper = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a, b, g, d) {
      this.initialize(a, b, g, d);
    }, b = c.prototype;
  c.identity = null;
  b.color = null;
  b.offsetX = 0;
  b.offsetY = 0;
  b.blur = 0;
  b.initialize = function (a, b, g, d) {
    this.color = a;
    this.offsetX = b;
    this.offsetY = g;
    this.blur = d;
  };
  b.toString = function () {
    return '[Shadow]';
  };
  b.clone = function () {
    return new c(this.color, this.offsetX, this.offsetY, this.blur);
  };
  c.identity = new c('transparent', 0, 0, 0);
  createjs.Shadow = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a) {
      this.initialize(a);
    }, b = c.prototype;
  b.complete = !0;
  b.onComplete = null;
  b.addEventListener = null;
  b.removeEventListener = null;
  b.removeAllEventListeners = null;
  b.dispatchEvent = null;
  b.hasEventListener = null;
  b._listeners = null;
  createjs.EventDispatcher.initialize(b);
  b._animations = null;
  b._frames = null;
  b._images = null;
  b._data = null;
  b._loadCount = 0;
  b._frameHeight = 0;
  b._frameWidth = 0;
  b._numFrames = 0;
  b._regX = 0;
  b._regY = 0;
  b.initialize = function (a) {
    var b, g, d;
    if (null != a) {
      if (a.images && 0 < (g = a.images.length)) {
        d = this._images = [];
        for (b = 0; b < g; b++) {
          var c = a.images[b];
          if ('string' == typeof c) {
            var f = c, c = new Image();
            c.src = f;
          }
          d.push(c);
          !c.getContext && !c.complete && (this._loadCount++, this.complete = !1, function (a) {
            c.onload = function () {
              a._handleImageLoad();
            };
          }(this));
        }
      }
      if (null != a.frames)
        if (a.frames instanceof Array) {
          this._frames = [];
          d = a.frames;
          b = 0;
          for (g = d.length; b < g; b++)
            f = d[b], this._frames.push({
              image: this._images[f[4] ? f[4] : 0],
              rect: new createjs.Rectangle(f[0], f[1], f[2], f[3]),
              regX: f[5] || 0,
              regY: f[6] || 0
            });
        } else
          g = a.frames, this._frameWidth = g.width, this._frameHeight = g.height, this._regX = g.regX || 0, this._regY = g.regY || 0, this._numFrames = g.count, 0 == this._loadCount && this._calculateFrames();
      if (null != (g = a.animations)) {
        this._animations = [];
        this._data = {};
        for (var h in g) {
          a = { name: h };
          f = g[h];
          if ('number' == typeof f)
            d = a.frames = [f];
          else if (f instanceof Array)
            if (1 == f.length)
              a.frames = [f[0]];
            else {
              a.frequency = f[3];
              a.next = f[2];
              d = a.frames = [];
              for (b = f[0]; b <= f[1]; b++)
                d.push(b);
            }
          else
            a.frequency = f.frequency, a.next = f.next, b = f.frames, d = a.frames = 'number' == typeof b ? [b] : b.slice(0);
          a.next = 2 > d.length || !1 == a.next ? null : null == a.next || !0 == a.next ? h : a.next;
          a.frequency || (a.frequency = 1);
          this._animations.push(h);
          this._data[h] = a;
        }
      }
    }
  };
  b.getNumFrames = function (a) {
    if (null == a)
      return this._frames ? this._frames.length : this._numFrames;
    a = this._data[a];
    return null == a ? 0 : a.frames.length;
  };
  b.getAnimations = function () {
    return this._animations.slice(0);
  };
  b.getAnimation = function (a) {
    return this._data[a];
  };
  b.getFrame = function (a) {
    var b;
    return this.complete && this._frames && (b = this._frames[a]) ? b : null;
  };
  b.getFrameBounds = function (a) {
    return (a = this.getFrame(a)) ? new createjs.Rectangle(-a.regX, -a.regY, a.rect.width, a.rect.height) : null;
  };
  b.toString = function () {
    return '[SpriteSheet]';
  };
  b.clone = function () {
    var a = new c();
    a.complete = this.complete;
    a._animations = this._animations;
    a._frames = this._frames;
    a._images = this._images;
    a._data = this._data;
    a._frameHeight = this._frameHeight;
    a._frameWidth = this._frameWidth;
    a._numFrames = this._numFrames;
    a._loadCount = this._loadCount;
    return a;
  };
  b._handleImageLoad = function () {
    0 == --this._loadCount && (this._calculateFrames(), this.complete = !0, this.onComplete && this.onComplete(), this.dispatchEvent('complete'));
  };
  b._calculateFrames = function () {
    if (!(this._frames || 0 == this._frameWidth)) {
      this._frames = [];
      for (var a = 0, b = this._frameWidth, g = this._frameHeight, d = 0, c = this._images; d < c.length; d++) {
        for (var f = c[d], h = (f.width + 1) / b | 0, k = (f.height + 1) / g | 0, k = 0 < this._numFrames ? Math.min(this._numFrames - a, h * k) : h * k, j = 0; j < k; j++)
          this._frames.push({
            image: f,
            rect: new createjs.Rectangle(j % h * b, (j / h | 0) * g, b, g),
            regX: this._regX,
            regY: this._regY
          });
        a += k;
      }
      this._numFrames = a;
    }
  };
  createjs.SpriteSheet = c;
}());
this.createjs = this.createjs || {};
(function () {
  function c(a, b, d) {
    this.f = a;
    this.params = b;
    this.path = null == d ? !0 : d;
  }
  c.prototype.exec = function (a) {
    this.f.apply(a, this.params);
  };
  var b = function () {
      this.initialize();
    }, a = b.prototype;
  b.getRGB = function (a, b, d, c) {
    null != a && null == d && (c = b, d = a & 255, b = a >> 8 & 255, a = a >> 16 & 255);
    return null == c ? 'rgb(' + a + ',' + b + ',' + d + ')' : 'rgba(' + a + ',' + b + ',' + d + ',' + c + ')';
  };
  b.getHSL = function (a, b, d, c) {
    return null == c ? 'hsl(' + a % 360 + ',' + b + '%,' + d + '%)' : 'hsla(' + a % 360 + ',' + b + '%,' + d + '%,' + c + ')';
  };
  b.BASE_64 = {
    A: 0,
    B: 1,
    C: 2,
    D: 3,
    E: 4,
    F: 5,
    G: 6,
    H: 7,
    I: 8,
    J: 9,
    K: 10,
    L: 11,
    M: 12,
    N: 13,
    O: 14,
    P: 15,
    Q: 16,
    R: 17,
    S: 18,
    T: 19,
    U: 20,
    V: 21,
    W: 22,
    X: 23,
    Y: 24,
    Z: 25,
    a: 26,
    b: 27,
    c: 28,
    d: 29,
    e: 30,
    f: 31,
    g: 32,
    h: 33,
    i: 34,
    j: 35,
    k: 36,
    l: 37,
    m: 38,
    n: 39,
    o: 40,
    p: 41,
    q: 42,
    r: 43,
    s: 44,
    t: 45,
    u: 46,
    v: 47,
    w: 48,
    x: 49,
    y: 50,
    z: 51,
    '0': 52,
    1: 53,
    2: 54,
    3: 55,
    4: 56,
    5: 57,
    6: 58,
    7: 59,
    8: 60,
    9: 61,
    '+': 62,
    '/': 63
  };
  b.STROKE_CAPS_MAP = [
    'butt',
    'round',
    'square'
  ];
  b.STROKE_JOINTS_MAP = [
    'miter',
    'round',
    'bevel'
  ];
  b._ctx = (createjs.createCanvas ? createjs.createCanvas() : document.createElement('canvas')).getContext('2d');
  b.beginCmd = new c(b._ctx.beginPath, [], !1);
  b.fillCmd = new c(b._ctx.fill, [], !1);
  b.strokeCmd = new c(b._ctx.stroke, [], !1);
  a._strokeInstructions = null;
  a._strokeStyleInstructions = null;
  a._ignoreScaleStroke = !1;
  a._fillInstructions = null;
  a._instructions = null;
  a._oldInstructions = null;
  a._activeInstructions = null;
  a._active = !1;
  a._dirty = !1;
  a.initialize = function () {
    this.clear();
    this._ctx = b._ctx;
  };
  a.isEmpty = function () {
    return !(this._instructions.length || this._oldInstructions.length || this._activeInstructions.length);
  };
  a.draw = function (a) {
    this._dirty && this._updateInstructions();
    for (var b = this._instructions, d = 0, c = b.length; d < c; d++)
      b[d].exec(a);
  };
  a.drawAsPath = function (a) {
    this._dirty && this._updateInstructions();
    for (var b, d = this._instructions, c = 0, f = d.length; c < f; c++)
      ((b = d[c]).path || 0 == c) && b.exec(a);
  };
  a.moveTo = function (a, b) {
    this._activeInstructions.push(new c(this._ctx.moveTo, [
      a,
      b
    ]));
    return this;
  };
  a.lineTo = function (a, b) {
    this._dirty = this._active = !0;
    this._activeInstructions.push(new c(this._ctx.lineTo, [
      a,
      b
    ]));
    return this;
  };
  a.arcTo = function (a, b, d, e, f) {
    this._dirty = this._active = !0;
    this._activeInstructions.push(new c(this._ctx.arcTo, [
      a,
      b,
      d,
      e,
      f
    ]));
    return this;
  };
  a.arc = function (a, b, d, e, f, h) {
    this._dirty = this._active = !0;
    null == h && (h = !1);
    this._activeInstructions.push(new c(this._ctx.arc, [
      a,
      b,
      d,
      e,
      f,
      h
    ]));
    return this;
  };
  a.quadraticCurveTo = function (a, b, d, e) {
    this._dirty = this._active = !0;
    this._activeInstructions.push(new c(this._ctx.quadraticCurveTo, [
      a,
      b,
      d,
      e
    ]));
    return this;
  };
  a.bezierCurveTo = function (a, b, d, e, f, h) {
    this._dirty = this._active = !0;
    this._activeInstructions.push(new c(this._ctx.bezierCurveTo, [
      a,
      b,
      d,
      e,
      f,
      h
    ]));
    return this;
  };
  a.rect = function (a, b, d, e) {
    this._dirty = this._active = !0;
    this._activeInstructions.push(new c(this._ctx.rect, [
      a,
      b,
      d,
      e
    ]));
    return this;
  };
  a.closePath = function () {
    this._active && (this._dirty = !0, this._activeInstructions.push(new c(this._ctx.closePath, [])));
    return this;
  };
  a.clear = function () {
    this._instructions = [];
    this._oldInstructions = [];
    this._activeInstructions = [];
    this._strokeStyleInstructions = this._strokeInstructions = this._fillInstructions = null;
    this._active = this._dirty = !1;
    return this;
  };
  a.beginFill = function (a) {
    this._active && this._newPath();
    this._fillInstructions = a ? [
      new c(this._setProp, [
        'fillStyle',
        a
      ], !1),
      b.fillCmd
    ] : null;
    return this;
  };
  a.beginLinearGradientFill = function (a, g, d, e, f, h) {
    this._active && this._newPath();
    d = this._ctx.createLinearGradient(d, e, f, h);
    e = 0;
    for (f = a.length; e < f; e++)
      d.addColorStop(g[e], a[e]);
    this._fillInstructions = [
      new c(this._setProp, [
        'fillStyle',
        d
      ], !1),
      b.fillCmd
    ];
    return this;
  };
  a.beginRadialGradientFill = function (a, g, d, e, f, h, k, j) {
    this._active && this._newPath();
    d = this._ctx.createRadialGradient(d, e, f, h, k, j);
    e = 0;
    for (f = a.length; e < f; e++)
      d.addColorStop(g[e], a[e]);
    this._fillInstructions = [
      new c(this._setProp, [
        'fillStyle',
        d
      ], !1),
      b.fillCmd
    ];
    return this;
  };
  a.beginBitmapFill = function (a, g, d) {
    this._active && this._newPath();
    a = this._ctx.createPattern(a, g || '');
    a = new c(this._setProp, [
      'fillStyle',
      a
    ], !1);
    this._fillInstructions = d ? [
      a,
      new c(this._ctx.save, [], !1),
      new c(this._ctx.transform, [
        d.a,
        d.b,
        d.c,
        d.d,
        d.tx,
        d.ty
      ], !1),
      b.fillCmd,
      new c(this._ctx.restore, [], !1)
    ] : [
      a,
      b.fillCmd
    ];
    return this;
  };
  a.endFill = function () {
    return this.beginFill();
  };
  a.setStrokeStyle = function (a, g, d, e, f) {
    this._active && this._newPath();
    this._strokeStyleInstructions = [
      new c(this._setProp, [
        'lineWidth',
        null == a ? '1' : a
      ], !1),
      new c(this._setProp, [
        'lineCap',
        null == g ? 'butt' : isNaN(g) ? g : b.STROKE_CAPS_MAP[g]
      ], !1),
      new c(this._setProp, [
        'lineJoin',
        null == d ? 'miter' : isNaN(d) ? d : b.STROKE_JOINTS_MAP[d]
      ], !1),
      new c(this._setProp, [
        'miterLimit',
        null == e ? '10' : e
      ], !1)
    ];
    this._ignoreScaleStroke = f;
    return this;
  };
  a.beginStroke = function (a) {
    this._active && this._newPath();
    this._strokeInstructions = a ? [new c(this._setProp, [
        'strokeStyle',
        a
      ], !1)] : null;
    return this;
  };
  a.beginLinearGradientStroke = function (a, b, d, e, f, h) {
    this._active && this._newPath();
    d = this._ctx.createLinearGradient(d, e, f, h);
    e = 0;
    for (f = a.length; e < f; e++)
      d.addColorStop(b[e], a[e]);
    this._strokeInstructions = [new c(this._setProp, [
        'strokeStyle',
        d
      ], !1)];
    return this;
  };
  a.beginRadialGradientStroke = function (a, b, d, e, f, h, k, j) {
    this._active && this._newPath();
    d = this._ctx.createRadialGradient(d, e, f, h, k, j);
    e = 0;
    for (f = a.length; e < f; e++)
      d.addColorStop(b[e], a[e]);
    this._strokeInstructions = [new c(this._setProp, [
        'strokeStyle',
        d
      ], !1)];
    return this;
  };
  a.beginBitmapStroke = function (a, b) {
    this._active && this._newPath();
    var d = this._ctx.createPattern(a, b || '');
    this._strokeInstructions = [new c(this._setProp, [
        'strokeStyle',
        d
      ], !1)];
    return this;
  };
  a.endStroke = function () {
    this.beginStroke();
    return this;
  };
  a.curveTo = a.quadraticCurveTo;
  a.drawRect = a.rect;
  a.drawRoundRect = function (a, b, d, c, f) {
    this.drawRoundRectComplex(a, b, d, c, f, f, f, f);
    return this;
  };
  a.drawRoundRectComplex = function (a, b, d, e, f, h, k, j) {
    var l = (d < e ? d : e) / 2, n = 0, q = 0, p = 0, s = 0;
    0 > f && (f *= n = -1);
    f > l && (f = l);
    0 > h && (h *= q = -1);
    h > l && (h = l);
    0 > k && (k *= p = -1);
    k > l && (k = l);
    0 > j && (j *= s = -1);
    j > l && (j = l);
    this._dirty = this._active = !0;
    var l = this._ctx.arcTo, r = this._ctx.lineTo;
    this._activeInstructions.push(new c(this._ctx.moveTo, [
      a + d - h,
      b
    ]), new c(l, [
      a + d + h * q,
      b - h * q,
      a + d,
      b + h,
      h
    ]), new c(r, [
      a + d,
      b + e - k
    ]), new c(l, [
      a + d + k * p,
      b + e + k * p,
      a + d - k,
      b + e,
      k
    ]), new c(r, [
      a + j,
      b + e
    ]), new c(l, [
      a - j * s,
      b + e + j * s,
      a,
      b + e - j,
      j
    ]), new c(r, [
      a,
      b + f
    ]), new c(l, [
      a - f * n,
      b - f * n,
      a + f,
      b,
      f
    ]), new c(this._ctx.closePath));
    return this;
  };
  a.drawCircle = function (a, b, d) {
    this.arc(a, b, d, 0, 2 * Math.PI);
    return this;
  };
  a.drawEllipse = function (a, b, d, e) {
    this._dirty = this._active = !0;
    var f = 0.5522848 * (d / 2), h = 0.5522848 * (e / 2), k = a + d, j = b + e;
    d = a + d / 2;
    e = b + e / 2;
    this._activeInstructions.push(new c(this._ctx.moveTo, [
      a,
      e
    ]), new c(this._ctx.bezierCurveTo, [
      a,
      e - h,
      d - f,
      b,
      d,
      b
    ]), new c(this._ctx.bezierCurveTo, [
      d + f,
      b,
      k,
      e - h,
      k,
      e
    ]), new c(this._ctx.bezierCurveTo, [
      k,
      e + h,
      d + f,
      j,
      d,
      j
    ]), new c(this._ctx.bezierCurveTo, [
      d - f,
      j,
      a,
      e + h,
      a,
      e
    ]));
    return this;
  };
  a.drawPolyStar = function (a, b, d, e, f, h) {
    this._dirty = this._active = !0;
    null == f && (f = 0);
    f = 1 - f;
    h = null == h ? 0 : h / (180 / Math.PI);
    var k = Math.PI / e;
    this._activeInstructions.push(new c(this._ctx.moveTo, [
      a + Math.cos(h) * d,
      b + Math.sin(h) * d
    ]));
    for (var j = 0; j < e; j++)
      h += k, 1 != f && this._activeInstructions.push(new c(this._ctx.lineTo, [
        a + Math.cos(h) * d * f,
        b + Math.sin(h) * d * f
      ])), h += k, this._activeInstructions.push(new c(this._ctx.lineTo, [
        a + Math.cos(h) * d,
        b + Math.sin(h) * d
      ]));
    return this;
  };
  a.decodePath = function (a) {
    for (var g = [
          this.moveTo,
          this.lineTo,
          this.quadraticCurveTo,
          this.bezierCurveTo,
          this.closePath
        ], d = [
          2,
          2,
          4,
          6,
          0
        ], c = 0, f = a.length, h = [], k = 0, j = 0, l = b.BASE_64; c < f;) {
      var n = a.charAt(c), q = l[n], p = q >> 3, s = g[p];
      if (!s || q & 3)
        throw 'bad path data (@' + c + '): ' + n;
      n = d[p];
      p || (k = j = 0);
      h.length = 0;
      c++;
      q = (q >> 2 & 1) + 2;
      for (p = 0; p < n; p++) {
        var r = l[a.charAt(c)], u = r >> 5 ? -1 : 1, r = (r & 31) << 6 | l[a.charAt(c + 1)];
        3 == q && (r = r << 6 | l[a.charAt(c + 2)]);
        r = u * r / 10;
        p % 2 ? k = r += k : j = r += j;
        h[p] = r;
        c += q;
      }
      s.apply(this, h);
    }
    return this;
  };
  a.clone = function () {
    var a = new b();
    a._instructions = this._instructions.slice();
    a._activeInstructions = this._activeInstructions.slice();
    a._oldInstructions = this._oldInstructions.slice();
    this._fillInstructions && (a._fillInstructions = this._fillInstructions.slice());
    this._strokeInstructions && (a._strokeInstructions = this._strokeInstructions.slice());
    this._strokeStyleInstructions && (a._strokeStyleInstructions = this._strokeStyleInstructions.slice());
    a._active = this._active;
    a._dirty = this._dirty;
    return a;
  };
  a.toString = function () {
    return '[Graphics]';
  };
  a.mt = a.moveTo;
  a.lt = a.lineTo;
  a.at = a.arcTo;
  a.bt = a.bezierCurveTo;
  a.qt = a.quadraticCurveTo;
  a.a = a.arc;
  a.r = a.rect;
  a.cp = a.closePath;
  a.c = a.clear;
  a.f = a.beginFill;
  a.lf = a.beginLinearGradientFill;
  a.rf = a.beginRadialGradientFill;
  a.bf = a.beginBitmapFill;
  a.ef = a.endFill;
  a.ss = a.setStrokeStyle;
  a.s = a.beginStroke;
  a.ls = a.beginLinearGradientStroke;
  a.rs = a.beginRadialGradientStroke;
  a.bs = a.beginBitmapStroke;
  a.es = a.endStroke;
  a.dr = a.drawRect;
  a.rr = a.drawRoundRect;
  a.rc = a.drawRoundRectComplex;
  a.dc = a.drawCircle;
  a.de = a.drawEllipse;
  a.dp = a.drawPolyStar;
  a.p = a.decodePath;
  a._updateInstructions = function () {
    this._instructions = this._oldInstructions.slice();
    this._instructions.push(b.beginCmd);
    this._instructions.push.apply(this._instructions, this._activeInstructions);
    this._fillInstructions && this._instructions.push.apply(this._instructions, this._fillInstructions);
    this._strokeInstructions && (this._strokeStyleInstructions && this._instructions.push.apply(this._instructions, this._strokeStyleInstructions), this._instructions.push.apply(this._instructions, this._strokeInstructions), this._ignoreScaleStroke ? this._instructions.push(new c(this._ctx.save, [], !1), new c(this._ctx.setTransform, [
      1,
      0,
      0,
      1,
      0,
      0
    ], !1), b.strokeCmd, new c(this._ctx.restore, [], !1)) : this._instructions.push(b.strokeCmd));
  };
  a._newPath = function () {
    this._dirty && this._updateInstructions();
    this._oldInstructions = this._instructions;
    this._activeInstructions = [];
    this._active = this._dirty = !1;
  };
  a._setProp = function (a, b) {
    this[a] = b;
  };
  createjs.Graphics = b;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
      this.initialize();
    }, b = c.prototype;
  c.suppressCrossDomainErrors = !1;
  c._hitTestCanvas = createjs.createCanvas ? createjs.createCanvas() : document.createElement('canvas');
  c._hitTestCanvas.width = c._hitTestCanvas.height = 1;
  c._hitTestContext = c._hitTestCanvas.getContext('2d');
  c._nextCacheID = 1;
  b.alpha = 1;
  b.cacheCanvas = null;
  b.id = -1;
  b.mouseEnabled = !0;
  b.name = null;
  b.parent = null;
  b.regX = 0;
  b.regY = 0;
  b.rotation = 0;
  b.scaleX = 1;
  b.scaleY = 1;
  b.skewX = 0;
  b.skewY = 0;
  b.shadow = null;
  b.visible = !0;
  b.x = 0;
  b.y = 0;
  b.compositeOperation = null;
  b.snapToPixel = !1;
  b.onPress = null;
  b.onClick = null;
  b.onDoubleClick = null;
  b.onMouseOver = null;
  b.onMouseOut = null;
  b.onTick = null;
  b.filters = null;
  b.cacheID = 0;
  b.mask = null;
  b.hitArea = null;
  b.cursor = null;
  b.addEventListener = null;
  b.removeEventListener = null;
  b.removeAllEventListeners = null;
  b.dispatchEvent = null;
  b.hasEventListener = null;
  b._listeners = null;
  createjs.EventDispatcher.initialize(b);
  b._cacheOffsetX = 0;
  b._cacheOffsetY = 0;
  b._cacheScale = 1;
  b._cacheDataURLID = 0;
  b._cacheDataURL = null;
  b._matrix = null;
  b.initialize = function () {
    this.id = createjs.UID.get();
    this._matrix = new createjs.Matrix2D();
  };
  b.isVisible = function () {
    return !(!this.visible || !(0 < this.alpha && 0 != this.scaleX && 0 != this.scaleY));
  };
  b.draw = function (a, b) {
    var c = this.cacheCanvas;
    if (b || !c)
      return !1;
    var d = this._cacheScale;
    a.drawImage(c, this._cacheOffsetX, this._cacheOffsetY, c.width / d, c.height / d);
    return !0;
  };
  b.updateContext = function (a) {
    var b, c = this.mask;
    c && (c.graphics && !c.graphics.isEmpty()) && (b = c.getMatrix(c._matrix), a.transform(b.a, b.b, b.c, b.d, b.tx, b.ty), c.graphics.drawAsPath(a), a.clip(), b.invert(), a.transform(b.a, b.b, b.c, b.d, b.tx, b.ty));
    b = this._matrix.identity().appendTransform(this.x, this.y, this.scaleX, this.scaleY, this.rotation, this.skewX, this.skewY, this.regX, this.regY);
    createjs.Stage._snapToPixelEnabled && this.snapToPixel ? a.transform(b.a, b.b, b.c, b.d, b.tx + 0.5 | 0, b.ty + 0.5 | 0) : a.transform(b.a, b.b, b.c, b.d, b.tx, b.ty);
    a.globalAlpha *= this.alpha;
    this.compositeOperation && (a.globalCompositeOperation = this.compositeOperation);
    this.shadow && this._applyShadow(a, this.shadow);
  };
  b.cache = function (a, b, c, d, e) {
    e = e || 1;
    this.cacheCanvas || (this.cacheCanvas = createjs.createCanvas ? createjs.createCanvas() : document.createElement('canvas'));
    this.cacheCanvas.width = Math.ceil(c * e);
    this.cacheCanvas.height = Math.ceil(d * e);
    this._cacheOffsetX = a;
    this._cacheOffsetY = b;
    this._cacheScale = e || 1;
    this.updateCache();
  };
  b.updateCache = function (a) {
    var b = this.cacheCanvas, g = this._cacheScale, d = this._cacheOffsetX * g, e = this._cacheOffsetY * g;
    if (!b)
      throw 'cache() must be called before updateCache()';
    var f = b.getContext('2d');
    f.save();
    a || f.clearRect(0, 0, b.width + 1, b.height + 1);
    f.globalCompositeOperation = a;
    f.setTransform(g, 0, 0, g, -d, -e);
    this.draw(f, !0);
    this._applyFilters();
    f.restore();
    this.cacheID = c._nextCacheID++;
  };
  b.uncache = function () {
    this._cacheDataURL = this.cacheCanvas = null;
    this.cacheID = this._cacheOffsetX = this._cacheOffsetY = 0;
    this._cacheScale = 1;
  };
  b.getCacheDataURL = function () {
    if (!this.cacheCanvas)
      return null;
    this.cacheID != this._cacheDataURLID && (this._cacheDataURL = this.cacheCanvas.toDataURL());
    return this._cacheDataURL;
  };
  b.getStage = function () {
    for (var a = this; a.parent;)
      a = a.parent;
    return a instanceof createjs.Stage ? a : null;
  };
  b.localToGlobal = function (a, b) {
    var c = this.getConcatenatedMatrix(this._matrix);
    if (null == c)
      return null;
    c.append(1, 0, 0, 1, a, b);
    return new createjs.Point(c.tx, c.ty);
  };
  b.globalToLocal = function (a, b) {
    var c = this.getConcatenatedMatrix(this._matrix);
    if (null == c)
      return null;
    c.invert();
    c.append(1, 0, 0, 1, a, b);
    return new createjs.Point(c.tx, c.ty);
  };
  b.localToLocal = function (a, b, c) {
    a = this.localToGlobal(a, b);
    return c.globalToLocal(a.x, a.y);
  };
  b.setTransform = function (a, b, c, d, e, f, h, k, j) {
    this.x = a || 0;
    this.y = b || 0;
    this.scaleX = null == c ? 1 : c;
    this.scaleY = null == d ? 1 : d;
    this.rotation = e || 0;
    this.skewX = f || 0;
    this.skewY = h || 0;
    this.regX = k || 0;
    this.regY = j || 0;
    return this;
  };
  b.getMatrix = function (a) {
    return (a ? a.identity() : new createjs.Matrix2D()).appendTransform(this.x, this.y, this.scaleX, this.scaleY, this.rotation, this.skewX, this.skewY, this.regX, this.regY).appendProperties(this.alpha, this.shadow, this.compositeOperation);
  };
  b.getConcatenatedMatrix = function (a) {
    a ? a.identity() : a = new createjs.Matrix2D();
    for (var b = this; null != b;)
      a.prependTransform(b.x, b.y, b.scaleX, b.scaleY, b.rotation, b.skewX, b.skewY, b.regX, b.regY).prependProperties(b.alpha, b.shadow, b.compositeOperation), b = b.parent;
    return a;
  };
  b.hitTest = function (a, b) {
    var g = c._hitTestContext;
    g.setTransform(1, 0, 0, 1, -a, -b);
    this.draw(g);
    var d = this._testHit(g);
    g.setTransform(1, 0, 0, 1, 0, 0);
    g.clearRect(0, 0, 2, 2);
    return d;
  };
  b.set = function (a) {
    for (var b in a)
      this[b] = a[b];
    return this;
  };
  b.clone = function () {
    var a = new c();
    this.cloneProps(a);
    return a;
  };
  b.toString = function () {
    return '[DisplayObject (name=' + this.name + ')]';
  };
  b.cloneProps = function (a) {
    a.alpha = this.alpha;
    a.name = this.name;
    a.regX = this.regX;
    a.regY = this.regY;
    a.rotation = this.rotation;
    a.scaleX = this.scaleX;
    a.scaleY = this.scaleY;
    a.shadow = this.shadow;
    a.skewX = this.skewX;
    a.skewY = this.skewY;
    a.visible = this.visible;
    a.x = this.x;
    a.y = this.y;
    a.mouseEnabled = this.mouseEnabled;
    a.compositeOperation = this.compositeOperation;
    this.cacheCanvas && (a.cacheCanvas = this.cacheCanvas.cloneNode(!0), a.cacheCanvas.getContext('2d').putImageData(this.cacheCanvas.getContext('2d').getImageData(0, 0, this.cacheCanvas.width, this.cacheCanvas.height), 0, 0));
  };
  b._applyShadow = function (a, b) {
    b = b || Shadow.identity;
    a.shadowColor = b.color;
    a.shadowOffsetX = b.offsetX;
    a.shadowOffsetY = b.offsetY;
    a.shadowBlur = b.blur;
  };
  b._tick = function (a) {
    this.onTick && this.onTick.apply(this, a);
    var b = this._listeners;
    b && b.tick && this.dispatchEvent({
      type: 'tick',
      params: a
    });
  };
  b._testHit = function (a) {
    try {
      var b = 1 < a.getImageData(0, 0, 1, 1).data[3];
    } catch (g) {
      if (!c.suppressCrossDomainErrors)
        throw 'An error has occurred. This is most likely due to security restrictions on reading canvas pixel data with local or cross-domain images.';
    }
    return b;
  };
  b._applyFilters = function () {
    if (this.filters && 0 != this.filters.length && this.cacheCanvas)
      for (var a = this.filters.length, b = this.cacheCanvas.getContext('2d'), c = this.cacheCanvas.width, d = this.cacheCanvas.height, e = 0; e < a; e++)
        this.filters[e].applyFilter(b, 0, 0, c, d);
  };
  b._hasMouseHandler = function (a) {
    var b = this._listeners;
    return !!(a & 1 && (this.onPress || this.onClick || this.onDoubleClick || b && (this.hasEventListener('mousedown') || this.hasEventListener('click') || this.hasEventListener('dblclick'))) || a & 2 && (this.onMouseOver || this.onMouseOut || this.cursor || b && (this.hasEventListener('mouseover') || this.hasEventListener('mouseout'))));
  };
  createjs.DisplayObject = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
      this.initialize();
    }, b = c.prototype = new createjs.DisplayObject();
  b.children = null;
  b.DisplayObject_initialize = b.initialize;
  b.initialize = function () {
    this.DisplayObject_initialize();
    this.children = [];
  };
  b.isVisible = function () {
    var a = this.cacheCanvas || this.children.length;
    return !(!this.visible || !(0 < this.alpha && 0 != this.scaleX && 0 != this.scaleY && a));
  };
  b.DisplayObject_draw = b.draw;
  b.draw = function (a, b) {
    if (this.DisplayObject_draw(a, b))
      return !0;
    for (var c = this.children.slice(0), d = 0, e = c.length; d < e; d++) {
      var f = c[d];
      f.isVisible() && (a.save(), f.updateContext(a), f.draw(a), a.restore());
    }
    return !0;
  };
  b.addChild = function (a) {
    if (null == a)
      return a;
    var b = arguments.length;
    if (1 < b) {
      for (var c = 0; c < b; c++)
        this.addChild(arguments[c]);
      return arguments[b - 1];
    }
    a.parent && a.parent.removeChild(a);
    a.parent = this;
    this.children.push(a);
    return a;
  };
  b.addChildAt = function (a, b) {
    var c = arguments.length, d = arguments[c - 1];
    if (0 > d || d > this.children.length)
      return arguments[c - 2];
    if (2 < c) {
      for (var e = 0; e < c - 1; e++)
        this.addChildAt(arguments[e], d + e);
      return arguments[c - 2];
    }
    a.parent && a.parent.removeChild(a);
    a.parent = this;
    this.children.splice(b, 0, a);
    return a;
  };
  b.removeChild = function (a) {
    var b = arguments.length;
    if (1 < b) {
      for (var c = !0, d = 0; d < b; d++)
        c = c && this.removeChild(arguments[d]);
      return c;
    }
    return this.removeChildAt(this.children.indexOf(a));
  };
  b.removeChildAt = function (a) {
    var b = arguments.length;
    if (1 < b) {
      for (var c = [], d = 0; d < b; d++)
        c[d] = arguments[d];
      c.sort(function (a, b) {
        return b - a;
      });
      for (var e = !0, d = 0; d < b; d++)
        e = e && this.removeChildAt(c[d]);
      return e;
    }
    if (0 > a || a > this.children.length - 1)
      return !1;
    if (b = this.children[a])
      b.parent = null;
    this.children.splice(a, 1);
    return !0;
  };
  b.removeAllChildren = function () {
    for (var a = this.children; a.length;)
      a.pop().parent = null;
  };
  b.getChildAt = function (a) {
    return this.children[a];
  };
  b.getChildByName = function (a) {
    for (var b = this.children, c = 0, d = b.length; c < d; c++)
      if (b[c].name == a)
        return b[c];
    return null;
  };
  b.sortChildren = function (a) {
    this.children.sort(a);
  };
  b.getChildIndex = function (a) {
    return this.children.indexOf(a);
  };
  b.getNumChildren = function () {
    return this.children.length;
  };
  b.swapChildrenAt = function (a, b) {
    var c = this.children, d = c[a], e = c[b];
    d && e && (c[a] = e, c[b] = d);
  };
  b.swapChildren = function (a, b) {
    for (var c = this.children, d, e, f = 0, h = c.length; f < h && !(c[f] == a && (d = f), c[f] == b && (e = f), null != d && null != e); f++);
    f != h && (c[d] = b, c[e] = a);
  };
  b.setChildIndex = function (a, b) {
    var c = this.children, d = c.length;
    if (!(a.parent != this || 0 > b || b >= d)) {
      for (var e = 0; e < d && c[e] != a; e++);
      e == d || e == b || (c.splice(e, 1), b < e && b--, c.splice(b, 0, a));
    }
  };
  b.contains = function (a) {
    for (; a;) {
      if (a == this)
        return !0;
      a = a.parent;
    }
    return !1;
  };
  b.hitTest = function (a, b) {
    return null != this.getObjectUnderPoint(a, b);
  };
  b.getObjectsUnderPoint = function (a, b) {
    var c = [], d = this.localToGlobal(a, b);
    this._getObjectsUnderPoint(d.x, d.y, c);
    return c;
  };
  b.getObjectUnderPoint = function (a, b) {
    var c = this.localToGlobal(a, b);
    return this._getObjectsUnderPoint(c.x, c.y);
  };
  b.clone = function (a) {
    var b = new c();
    this.cloneProps(b);
    if (a)
      for (var g = b.children = [], d = 0, e = this.children.length; d < e; d++) {
        var f = this.children[d].clone(a);
        f.parent = b;
        g.push(f);
      }
    return b;
  };
  b.toString = function () {
    return '[Container (name=' + this.name + ')]';
  };
  b.DisplayObject__tick = b._tick;
  b._tick = function (a) {
    for (var b = this.children.length - 1; 0 <= b; b--) {
      var c = this.children[b];
      c._tick && c._tick(a);
    }
    this.DisplayObject__tick(a);
  };
  b._getObjectsUnderPoint = function (a, b, g, d) {
    var e = createjs.DisplayObject._hitTestContext, f = this._matrix, h = this._hasMouseHandler(d);
    if (!this.hitArea && (this.cacheCanvas && h) && (this.getConcatenatedMatrix(f), e.setTransform(f.a, f.b, f.c, f.d, f.tx - a, f.ty - b), e.globalAlpha = f.alpha, this.draw(e), this._testHit(e)))
      return e.setTransform(1, 0, 0, 1, 0, 0), e.clearRect(0, 0, 2, 2), this;
    for (var k = this.children.length - 1; 0 <= k; k--) {
      var j = this.children[k], l = j.hitArea;
      if (j.visible && !(!l && !j.isVisible() || d && !j.mouseEnabled)) {
        var n = d && j._hasMouseHandler(d);
        if (j instanceof c && (!l || !n))
          if (h) {
            if (j = j._getObjectsUnderPoint(a, b))
              return this;
          } else {
            if (j = j._getObjectsUnderPoint(a, b, g, d), !g && j)
              return j;
          }
        else if (!d || h || n)
          if (j.getConcatenatedMatrix(f), l && (f.appendTransform(l.x, l.y, l.scaleX, l.scaleY, l.rotation, l.skewX, l.skewY, l.regX, l.regY), f.alpha = l.alpha), e.globalAlpha = f.alpha, e.setTransform(f.a, f.b, f.c, f.d, f.tx - a, f.ty - b), (l || j).draw(e), this._testHit(e)) {
            e.setTransform(1, 0, 0, 1, 0, 0);
            e.clearRect(0, 0, 2, 2);
            if (h)
              return this;
            if (g)
              g.push(j);
            else
              return j;
          }
      }
    }
    return null;
  };
  createjs.Container = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a) {
      this.initialize(a);
    }, b = c.prototype = new createjs.Container();
  c._snapToPixelEnabled = !1;
  b.autoClear = !0;
  b.canvas = null;
  b.mouseX = 0;
  b.mouseY = 0;
  b.onMouseMove = null;
  b.onMouseUp = null;
  b.onMouseDown = null;
  b.snapToPixelEnabled = !1;
  b.mouseInBounds = !1;
  b.tickOnUpdate = !0;
  b.mouseMoveOutside = !1;
  b._pointerData = null;
  b._pointerCount = 0;
  b._primaryPointerID = null;
  b._mouseOverIntervalID = null;
  b.Container_initialize = b.initialize;
  b.initialize = function (a) {
    this.Container_initialize();
    this.canvas = 'string' == typeof a ? document.getElementById(a) : a;
    this._pointerData = {};
    this.enableDOMEvents(!0);
  };
  b.update = function () {
    if (this.canvas) {
      this.autoClear && this.clear();
      c._snapToPixelEnabled = this.snapToPixelEnabled;
      this.tickOnUpdate && this._tick(arguments.length ? arguments : null);
      var a = this.canvas.getContext('2d');
      a.save();
      this.updateContext(a);
      this.draw(a, !1);
      a.restore();
    }
  };
  b.tick = b.update;
  b.handleEvent = function (a) {
    'tick' == a.type && this.update(a);
  };
  b.clear = function () {
    if (this.canvas) {
      var a = this.canvas.getContext('2d');
      a.setTransform(1, 0, 0, 1, 0, 0);
      a.clearRect(0, 0, this.canvas.width + 1, this.canvas.height + 1);
    }
  };
  b.toDataURL = function (a, b) {
    b || (b = 'image/png');
    var c = this.canvas.getContext('2d'), d = this.canvas.width, e = this.canvas.height, f;
    if (a) {
      f = c.getImageData(0, 0, d, e);
      var h = c.globalCompositeOperation;
      c.globalCompositeOperation = 'destination-over';
      c.fillStyle = a;
      c.fillRect(0, 0, d, e);
    }
    var k = this.canvas.toDataURL(b);
    a && (c.clearRect(0, 0, d + 1, e + 1), c.putImageData(f, 0, 0), c.globalCompositeOperation = h);
    return k;
  };
  b.enableMouseOver = function (a) {
    this._mouseOverIntervalID && (clearInterval(this._mouseOverIntervalID), this._mouseOverIntervalID = null);
    if (null == a)
      a = 20;
    else if (0 >= a)
      return;
    var b = this;
    this._mouseOverIntervalID = setInterval(function () {
      b._testMouseOver();
    }, 1000 / Math.min(50, a));
  };
  b.enableDOMEvents = function (a) {
    null == a && (a = !0);
    var b, c = this._eventListeners;
    if (!a && c) {
      for (b in c)
        a = c[b], a.t.removeEventListener(b, a.f);
      this._eventListeners = null;
    } else if (a && !c && this.canvas) {
      a = window.addEventListener ? window : document;
      var d = this, c = this._eventListeners = {};
      c.mouseup = {
        t: a,
        f: function (a) {
          d._handleMouseUp(a);
        }
      };
      c.mousemove = {
        t: a,
        f: function (a) {
          d._handleMouseMove(a);
        }
      };
      c.dblclick = {
        t: a,
        f: function (a) {
          d._handleDoubleClick(a);
        }
      };
      c.mousedown = {
        t: this.canvas,
        f: function (a) {
          d._handleMouseDown(a);
        }
      };
      for (b in c)
        a = c[b], a.t.addEventListener(b, a.f);
    }
  };
  b.clone = function () {
    var a = new c(null);
    this.cloneProps(a);
    return a;
  };
  b.toString = function () {
    return '[Stage (name=' + this.name + ')]';
  };
  b._getPointerData = function (a) {
    var b = this._pointerData[a];
    if (!b && (b = this._pointerData[a] = {
        x: 0,
        y: 0
      }, null == this._primaryPointerID || -1 == this._primaryPointerID))
      this._primaryPointerID = a;
    return b;
  };
  b._handleMouseMove = function (a) {
    a || (a = window.event);
    this._handlePointerMove(-1, a, a.pageX, a.pageY);
  };
  b._handlePointerMove = function (a, b, c, d) {
    if (this.canvas) {
      var e = this._getPointerData(a), f = e.inBounds;
      this._updatePointerPosition(a, c, d);
      if (f || e.inBounds || this.mouseMoveOutside) {
        if (this.onMouseMove || this.hasEventListener('stagemousemove'))
          c = new createjs.MouseEvent('stagemousemove', e.x, e.y, this, b, a, a == this._primaryPointerID, e.rawX, e.rawY), this.onMouseMove && this.onMouseMove(c), this.dispatchEvent(c);
        if ((d = e.event) && (d.onMouseMove || d.hasEventListener('mousemove')))
          c = new createjs.MouseEvent('mousemove', e.x, e.y, d.target, b, a, a == this._primaryPointerID, e.rawX, e.rawY), d.onMouseMove && d.onMouseMove(c), d.dispatchEvent(c, d.target);
      }
    }
  };
  b._updatePointerPosition = function (a, b, c) {
    var d = this._getElementRect(this.canvas);
    b -= d.left;
    c -= d.top;
    var e = this.canvas.width, f = this.canvas.height;
    b /= (d.right - d.left) / e;
    c /= (d.bottom - d.top) / f;
    d = this._getPointerData(a);
    (d.inBounds = 0 <= b && 0 <= c && b <= e - 1 && c <= f - 1) ? (d.x = b, d.y = c) : this.mouseMoveOutside && (d.x = 0 > b ? 0 : b > e - 1 ? e - 1 : b, d.y = 0 > c ? 0 : c > f - 1 ? f - 1 : c);
    d.rawX = b;
    d.rawY = c;
    a == this._primaryPointerID && (this.mouseX = d.x, this.mouseY = d.y, this.mouseInBounds = d.inBounds);
  };
  b._getElementRect = function (a) {
    var b;
    try {
      b = a.getBoundingClientRect();
    } catch (c) {
      b = {
        top: a.offsetTop,
        left: a.offsetLeft,
        width: a.offsetWidth,
        height: a.offsetHeight
      };
    }
    var d = (window.pageXOffset || document.scrollLeft || 0) - (document.clientLeft || document.body.clientLeft || 0), e = (window.pageYOffset || document.scrollTop || 0) - (document.clientTop || document.body.clientTop || 0), f = window.getComputedStyle ? getComputedStyle(a) : a.currentStyle;
    a = parseInt(f.paddingLeft) + parseInt(f.borderLeftWidth);
    var h = parseInt(f.paddingTop) + parseInt(f.borderTopWidth), k = parseInt(f.paddingRight) + parseInt(f.borderRightWidth), f = parseInt(f.paddingBottom) + parseInt(f.borderBottomWidth);
    return {
      left: b.left + d + a,
      right: b.right + d - k,
      top: b.top + e + h,
      bottom: b.bottom + e - f
    };
  };
  b._handleMouseUp = function (a) {
    this._handlePointerUp(-1, a, !1);
  };
  b._handlePointerUp = function (a, b, c) {
    var d = this._getPointerData(a), e;
    if (this.onMouseMove || this.hasEventListener('stagemouseup'))
      e = new createjs.MouseEvent('stagemouseup', d.x, d.y, this, b, a, a == this._primaryPointerID, d.rawX, d.rawY), this.onMouseUp && this.onMouseUp(e), this.dispatchEvent(e);
    var f = d.event;
    if (f && (f.onMouseUp || f.hasEventListener('mouseup')))
      e = new createjs.MouseEvent('mouseup', d.x, d.y, f.target, b, a, a == this._primaryPointerID, d.rawX, d.rawY), f.onMouseUp && f.onMouseUp(e), f.dispatchEvent(e, f.target);
    if ((f = d.target) && (f.onClick || f.hasEventListener('click')) && this._getObjectsUnderPoint(d.x, d.y, null, !0, this._mouseOverIntervalID ? 3 : 1) == f)
      e = new createjs.MouseEvent('click', d.x, d.y, f, b, a, a == this._primaryPointerID, d.rawX, d.rawY), f.onClick && f.onClick(e), f.dispatchEvent(e);
    c ? (a == this._primaryPointerID && (this._primaryPointerID = null), delete this._pointerData[a]) : d.event = d.target = null;
  };
  b._handleMouseDown = function (a) {
    this._handlePointerDown(-1, a, !1);
  };
  b._handlePointerDown = function (a, b, c, d) {
    var e = this._getPointerData(a);
    null != d && this._updatePointerPosition(a, c, d);
    if (this.onMouseDown || this.hasEventListener('stagemousedown'))
      c = new createjs.MouseEvent('stagemousedown', e.x, e.y, this, b, a, a == this._primaryPointerID, e.rawX, e.rawY), this.onMouseDown && this.onMouseDown(c), this.dispatchEvent(c);
    if (d = this._getObjectsUnderPoint(e.x, e.y, null, this._mouseOverIntervalID ? 3 : 1))
      if (e.target = d, d.onPress || d.hasEventListener('mousedown'))
        if (c = new createjs.MouseEvent('mousedown', e.x, e.y, d, b, a, a == this._primaryPointerID, e.rawX, e.rawY), d.onPress && d.onPress(c), d.dispatchEvent(c), c.onMouseMove || c.onMouseUp || c.hasEventListener('mousemove') || c.hasEventListener('mouseup'))
          e.event = c;
  };
  b._testMouseOver = function () {
    if (-1 == this._primaryPointerID && !(this.mouseX == this._mouseOverX && this.mouseY == this._mouseOverY && this.mouseInBounds)) {
      var a = null;
      this.mouseInBounds && (a = this._getObjectsUnderPoint(this.mouseX, this.mouseY, null, 3), this._mouseOverX = this.mouseX, this._mouseOverY = this.mouseY);
      var b = this._mouseOverTarget;
      if (b != a) {
        var c = this._getPointerData(-1);
        if (b && (b.onMouseOut || b.hasEventListener('mouseout'))) {
          var d = new createjs.MouseEvent('mouseout', c.x, c.y, b, null, -1, c.rawX, c.rawY);
          b.onMouseOut && b.onMouseOut(d);
          b.dispatchEvent(d);
        }
        b && (this.canvas.style.cursor = '');
        if (a && (a.onMouseOver || a.hasEventListener('mouseover')))
          d = new createjs.MouseEvent('mouseover', c.x, c.y, a, null, -1, c.rawX, c.rawY), a.onMouseOver && a.onMouseOver(d), a.dispatchEvent(d);
        a && (this.canvas.style.cursor = a.cursor || '');
        this._mouseOverTarget = a;
      }
    }
  };
  b._handleDoubleClick = function (a) {
    var b = this._getPointerData(-1), c = this._getObjectsUnderPoint(b.x, b.y, null, this._mouseOverIntervalID ? 3 : 1);
    if (c && (c.onDoubleClick || c.hasEventListener('dblclick')))
      evt = new createjs.MouseEvent('dblclick', b.x, b.y, c, a, -1, !0, b.rawX, b.rawY), c.onDoubleClick && c.onDoubleClick(evt), c.dispatchEvent(evt);
  };
  createjs.Stage = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a) {
      this.initialize(a);
    }, b = c.prototype = new createjs.DisplayObject();
  b.image = null;
  b.snapToPixel = !0;
  b.sourceRect = null;
  b.DisplayObject_initialize = b.initialize;
  b.initialize = function (a) {
    this.DisplayObject_initialize();
    'string' == typeof a ? (this.image = new Image(), this.image.src = a) : this.image = a;
  };
  b.isVisible = function () {
    var a = this.cacheCanvas || this.image && (this.image.complete || this.image.getContext || 2 <= this.image.readyState);
    return !(!this.visible || !(0 < this.alpha && 0 != this.scaleX && 0 != this.scaleY && a));
  };
  b.DisplayObject_draw = b.draw;
  b.draw = function (a, b) {
    if (this.DisplayObject_draw(a, b))
      return !0;
    var c = this.sourceRect;
    c ? a.drawImage(this.image, c.x, c.y, c.width, c.height, 0, 0, c.width, c.height) : a.drawImage(this.image, 0, 0);
    return !0;
  };
  b.clone = function () {
    var a = new c(this.image);
    this.sourceRect && (a.sourceRect = this.sourceRect.clone());
    this.cloneProps(a);
    return a;
  };
  b.toString = function () {
    return '[Bitmap (name=' + this.name + ')]';
  };
  createjs.Bitmap = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a) {
      this.initialize(a);
    }, b = c.prototype = new createjs.DisplayObject();
  b.onAnimationEnd = null;
  b.currentFrame = -1;
  b.currentAnimation = null;
  b.paused = !0;
  b.spriteSheet = null;
  b.snapToPixel = !0;
  b.offset = 0;
  b.currentAnimationFrame = 0;
  b.addEventListener = null;
  b.removeEventListener = null;
  b.removeAllEventListeners = null;
  b.dispatchEvent = null;
  b.hasEventListener = null;
  b._listeners = null;
  createjs.EventDispatcher.initialize(b);
  b._advanceCount = 0;
  b._animation = null;
  b.DisplayObject_initialize = b.initialize;
  b.initialize = function (a) {
    this.DisplayObject_initialize();
    this.spriteSheet = a;
  };
  b.isVisible = function () {
    var a = this.cacheCanvas || this.spriteSheet.complete && 0 <= this.currentFrame;
    return !(!this.visible || !(0 < this.alpha && 0 != this.scaleX && 0 != this.scaleY && a));
  };
  b.DisplayObject_draw = b.draw;
  b.draw = function (a, b) {
    if (this.DisplayObject_draw(a, b))
      return !0;
    this._normalizeFrame();
    var c = this.spriteSheet.getFrame(this.currentFrame);
    if (c) {
      var d = c.rect;
      a.drawImage(c.image, d.x, d.y, d.width, d.height, -c.regX, -c.regY, d.width, d.height);
      return !0;
    }
  };
  b.play = function () {
    this.paused = !1;
  };
  b.stop = function () {
    this.paused = !0;
  };
  b.gotoAndPlay = function (a) {
    this.paused = !1;
    this._goto(a);
  };
  b.gotoAndStop = function (a) {
    this.paused = !0;
    this._goto(a);
  };
  b.advance = function () {
    this._animation ? this.currentAnimationFrame++ : this.currentFrame++;
    this._normalizeFrame();
  };
  b.getBounds = function () {
    return this.spriteSheet.getFrameBounds(this.currentFrame);
  };
  b.clone = function () {
    var a = new c(this.spriteSheet);
    this.cloneProps(a);
    return a;
  };
  b.toString = function () {
    return '[BitmapAnimation (name=' + this.name + ')]';
  };
  b.DisplayObject__tick = b._tick;
  b._tick = function (a) {
    var b = this._animation ? this._animation.frequency : 1;
    !this.paused && 0 == (++this._advanceCount + this.offset) % b && this.advance();
    this.DisplayObject__tick(a);
  };
  b._normalizeFrame = function () {
    var a = this._animation, b = this.currentFrame, c = this.paused, d;
    if (a)
      if (d = a.frames.length, this.currentAnimationFrame >= d) {
        var e = a.next;
        this._dispatchAnimationEnd(a, b, c, e, d - 1) || (e ? this._goto(e) : (this.paused = !0, this.currentAnimationFrame = a.frames.length - 1, this.currentFrame = a.frames[this.currentAnimationFrame]));
      } else
        this.currentFrame = a.frames[this.currentAnimationFrame];
    else
      d = this.spriteSheet.getNumFrames(), b >= d && !this._dispatchAnimationEnd(a, b, c, d - 1) && (this.currentFrame = 0);
  };
  b._dispatchAnimationEnd = function (a, b, c, d, e) {
    var f = a ? a.name : null;
    this.onAnimationEnd && this.onAnimationEnd(this, f, d);
    this.dispatchEvent({
      type: 'animationend',
      name: f,
      next: d
    });
    !c && this.paused && (this.currentAnimationFrame = e);
    return this.paused != c || this._animation != a || this.currentFrame != b;
  };
  b.DisplayObject_cloneProps = b.cloneProps;
  b.cloneProps = function (a) {
    this.DisplayObject_cloneProps(a);
    a.onAnimationEnd = this.onAnimationEnd;
    a.currentFrame = this.currentFrame;
    a.currentAnimation = this.currentAnimation;
    a.paused = this.paused;
    a.offset = this.offset;
    a._animation = this._animation;
    a.currentAnimationFrame = this.currentAnimationFrame;
  };
  b._goto = function (a) {
    if (isNaN(a)) {
      var b = this.spriteSheet.getAnimation(a);
      b && (this.currentAnimationFrame = 0, this._animation = b, this.currentAnimation = a, this._normalizeFrame());
    } else
      this.currentAnimation = this._animation = null, this.currentFrame = a;
  };
  createjs.BitmapAnimation = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a) {
      this.initialize(a);
    }, b = c.prototype = new createjs.DisplayObject();
  b.graphics = null;
  b.DisplayObject_initialize = b.initialize;
  b.initialize = function (a) {
    this.DisplayObject_initialize();
    this.graphics = a ? a : new createjs.Graphics();
  };
  b.isVisible = function () {
    var a = this.cacheCanvas || this.graphics && !this.graphics.isEmpty();
    return !(!this.visible || !(0 < this.alpha && 0 != this.scaleX && 0 != this.scaleY && a));
  };
  b.DisplayObject_draw = b.draw;
  b.draw = function (a, b) {
    if (this.DisplayObject_draw(a, b))
      return !0;
    this.graphics.draw(a);
    return !0;
  };
  b.clone = function (a) {
    a = new c(a && this.graphics ? this.graphics.clone() : this.graphics);
    this.cloneProps(a);
    return a;
  };
  b.toString = function () {
    return '[Shape (name=' + this.name + ')]';
  };
  createjs.Shape = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a, b, c) {
      this.initialize(a, b, c);
    }, b = c.prototype = new createjs.DisplayObject();
  c._workingContext = (createjs.createCanvas ? createjs.createCanvas() : document.createElement('canvas')).getContext('2d');
  b.text = '';
  b.font = null;
  b.color = '#000';
  b.textAlign = 'left';
  b.textBaseline = 'top';
  b.maxWidth = null;
  b.outline = !1;
  b.lineHeight = 0;
  b.lineWidth = null;
  b.DisplayObject_initialize = b.initialize;
  b.initialize = function (a, b, c) {
    this.DisplayObject_initialize();
    this.text = a;
    this.font = b;
    this.color = c ? c : '#000';
  };
  b.isVisible = function () {
    var a = this.cacheCanvas || null != this.text && '' !== this.text;
    return !(!this.visible || !(0 < this.alpha && 0 != this.scaleX && 0 != this.scaleY && a));
  };
  b.DisplayObject_draw = b.draw;
  b.draw = function (a, b) {
    if (this.DisplayObject_draw(a, b))
      return !0;
    this.outline ? a.strokeStyle = this.color : a.fillStyle = this.color;
    a.font = this.font;
    a.textAlign = this.textAlign || 'start';
    a.textBaseline = this.textBaseline || 'alphabetic';
    this._drawText(a);
    return !0;
  };
  b.getMeasuredWidth = function () {
    return this._getWorkingContext().measureText(this.text).width;
  };
  b.getMeasuredLineHeight = function () {
    return 1.2 * this._getWorkingContext().measureText('M').width;
  };
  b.getMeasuredHeight = function () {
    return this._drawText() * (this.lineHeight || this.getMeasuredLineHeight());
  };
  b.clone = function () {
    var a = new c(this.text, this.font, this.color);
    this.cloneProps(a);
    return a;
  };
  b.toString = function () {
    return '[Text (text=' + (20 < this.text.length ? this.text.substr(0, 17) + '...' : this.text) + ')]';
  };
  b.DisplayObject_cloneProps = b.cloneProps;
  b.cloneProps = function (a) {
    this.DisplayObject_cloneProps(a);
    a.textAlign = this.textAlign;
    a.textBaseline = this.textBaseline;
    a.maxWidth = this.maxWidth;
    a.outline = this.outline;
    a.lineHeight = this.lineHeight;
    a.lineWidth = this.lineWidth;
  };
  b._getWorkingContext = function () {
    var a = c._workingContext;
    a.font = this.font;
    a.textAlign = this.textAlign || 'start';
    a.textBaseline = this.textBaseline || 'alphabetic';
    return a;
  };
  b._drawText = function (a) {
    var b = !!a;
    b || (a = this._getWorkingContext());
    for (var c = String(this.text).split(/(?:\r\n|\r|\n)/), d = this.lineHeight || this.getMeasuredLineHeight(), e = 0, f = 0, h = c.length; f < h; f++) {
      var k = a.measureText(c[f]).width;
      if (null == this.lineWidth || k < this.lineWidth)
        b && this._drawTextLine(a, c[f], e * d);
      else {
        for (var k = c[f].split(/(\s)/), j = k[0], l = 1, n = k.length; l < n; l += 2)
          a.measureText(j + k[l] + k[l + 1]).width > this.lineWidth ? (b && this._drawTextLine(a, j, e * d), e++, j = k[l + 1]) : j += k[l] + k[l + 1];
        b && this._drawTextLine(a, j, e * d);
      }
      e++;
    }
    return e;
  };
  b._drawTextLine = function (a, b, c) {
    this.outline ? a.strokeText(b, 0, c, this.maxWidth || 65535) : a.fillText(b, 0, c, this.maxWidth || 65535);
  };
  createjs.Text = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
    throw 'SpriteSheetUtils cannot be instantiated';
  };
  c._workingCanvas = createjs.createCanvas ? createjs.createCanvas() : document.createElement('canvas');
  c._workingContext = c._workingCanvas.getContext('2d');
  c.addFlippedFrames = function (b, a, m, g) {
    if (a || m || g) {
      var d = 0;
      a && c._flip(b, ++d, !0, !1);
      m && c._flip(b, ++d, !1, !0);
      g && c._flip(b, ++d, !0, !0);
    }
  };
  c.extractFrame = function (b, a) {
    isNaN(a) && (a = b.getAnimation(a).frames[0]);
    var m = b.getFrame(a);
    if (!m)
      return null;
    var g = m.rect, d = c._workingCanvas;
    d.width = g.width;
    d.height = g.height;
    c._workingContext.drawImage(m.image, g.x, g.y, g.width, g.height, 0, 0, g.width, g.height);
    m = new Image();
    m.src = d.toDataURL('image/png');
    return m;
  };
  c.mergeAlpha = function (b, a, c) {
    c || (c = createjs.createCanvas ? createjs.createCanvas() : document.createElement('canvas'));
    c.width = Math.max(a.width, b.width);
    c.height = Math.max(a.height, b.height);
    var g = c.getContext('2d');
    g.save();
    g.drawImage(b, 0, 0);
    g.globalCompositeOperation = 'destination-in';
    g.drawImage(a, 0, 0);
    g.restore();
    return c;
  };
  c._flip = function (b, a, m, g) {
    for (var d = b._images, e = c._workingCanvas, f = c._workingContext, h = d.length / a, k = 0; k < h; k++) {
      var j = d[k];
      j.__tmp = k;
      f.setTransform(1, 0, 0, 1, 0, 0);
      f.clearRect(0, 0, e.width + 1, e.height + 1);
      e.width = j.width;
      e.height = j.height;
      f.setTransform(m ? -1 : 1, 0, 0, g ? -1 : 1, m ? j.width : 0, g ? j.height : 0);
      f.drawImage(j, 0, 0);
      var l = new Image();
      l.src = e.toDataURL('image/png');
      l.width = j.width;
      l.height = j.height;
      d.push(l);
    }
    f = b._frames;
    e = f.length / a;
    for (k = 0; k < e; k++) {
      var j = f[k], n = j.rect.clone(), l = d[j.image.__tmp + h * a], q = {
          image: l,
          rect: n,
          regX: j.regX,
          regY: j.regY
        };
      m && (n.x = l.width - n.x - n.width, q.regX = n.width - j.regX);
      g && (n.y = l.height - n.y - n.height, q.regY = n.height - j.regY);
      f.push(q);
    }
    m = '_' + (m ? 'h' : '') + (g ? 'v' : '');
    g = b._animations;
    b = b._data;
    d = g.length / a;
    for (k = 0; k < d; k++) {
      f = g[k];
      j = b[f];
      h = {
        name: f + m,
        frequency: j.frequency,
        next: j.next,
        frames: []
      };
      j.next && (h.next += m);
      f = j.frames;
      j = 0;
      for (l = f.length; j < l; j++)
        h.frames.push(f[j] + e * a);
      b[h.name] = h;
      g.push(h.name);
    }
  };
  createjs.SpriteSheetUtils = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
      this.initialize();
    }, b = c.prototype;
  c.ERR_DIMENSIONS = 'frame dimensions exceed max spritesheet dimensions';
  c.ERR_RUNNING = 'a build is already running';
  b.maxWidth = 2048;
  b.maxHeight = 2048;
  b.spriteSheet = null;
  b.scale = 1;
  b.padding = 1;
  b.timeSlice = 0.3;
  b.progress = -1;
  b.onComplete = null;
  b.onProgress = null;
  b.addEventListener = null;
  b.removeEventListener = null;
  b.removeAllEventListeners = null;
  b.dispatchEvent = null;
  b.hasEventListener = null;
  b._listeners = null;
  createjs.EventDispatcher.initialize(b);
  b._frames = null;
  b._animations = null;
  b._data = null;
  b._nextFrameIndex = 0;
  b._index = 0;
  b._timerID = null;
  b._scale = 1;
  b.initialize = function () {
    this._frames = [];
    this._animations = {};
  };
  b.addFrame = function (a, b, g, d, e, f) {
    if (this._data)
      throw c.ERR_RUNNING;
    b = b || a.bounds || a.nominalBounds;
    !b && a.getBounds && (b = a.getBounds());
    if (!b)
      return null;
    g = g || 1;
    return this._frames.push({
      source: a,
      sourceRect: b,
      scale: g,
      funct: d,
      params: e,
      scope: f,
      index: this._frames.length,
      height: b.height * g
    }) - 1;
  };
  b.addAnimation = function (a, b, g, d) {
    if (this._data)
      throw c.ERR_RUNNING;
    this._animations[a] = {
      frames: b,
      next: g,
      frequency: d
    };
  };
  b.addMovieClip = function (a, b, g) {
    if (this._data)
      throw c.ERR_RUNNING;
    var d = a.frameBounds, e = b || a.bounds || a.nominalBounds;
    !e && a.getBounds && (e = a.getBounds());
    if (!e && !d)
      return null;
    b = this._frames.length;
    for (var f = a.timeline.duration, h = 0; h < f; h++)
      this.addFrame(a, d && d[h] ? d[h] : e, g, function (a) {
        var b = this.actionsEnabled;
        this.actionsEnabled = !1;
        this.gotoAndStop(a);
        this.actionsEnabled = b;
      }, [h], a);
    h = a.timeline._labels;
    a = [];
    for (var k in h)
      a.push({
        index: h[k],
        label: k
      });
    if (a.length) {
      a.sort(function (a, b) {
        return a.index - b.index;
      });
      h = 0;
      for (k = a.length; h < k; h++) {
        g = a[h].label;
        for (var d = b + (h == k - 1 ? f : a[h + 1].index), e = [], j = b + a[h].index; j < d; j++)
          e.push(j);
        this.addAnimation(g, e, !0);
      }
    }
  };
  b.build = function () {
    if (this._data)
      throw c.ERR_RUNNING;
    for (this._startBuild(); this._drawNext(););
    this._endBuild();
    return this.spriteSheet;
  };
  b.buildAsync = function (a) {
    if (this._data)
      throw c.ERR_RUNNING;
    this.timeSlice = a;
    this._startBuild();
    var b = this;
    this._timerID = setTimeout(function () {
      b._run();
    }, 50 - 50 * Math.max(0.01, Math.min(0.99, this.timeSlice || 0.3)));
  };
  b.stopAsync = function () {
    clearTimeout(this._timerID);
    this._data = null;
  };
  b.clone = function () {
    throw 'SpriteSheetBuilder cannot be cloned.';
  };
  b.toString = function () {
    return '[SpriteSheetBuilder]';
  };
  b._startBuild = function () {
    var a = this.padding || 0;
    this.progress = 0;
    this.spriteSheet = null;
    this._index = 0;
    this._scale = this.scale;
    var b = [];
    this._data = {
      images: [],
      frames: b,
      animations: this._animations
    };
    var g = this._frames.slice();
    g.sort(function (a, b) {
      return a.height <= b.height ? -1 : 1;
    });
    if (g[g.length - 1].height + 2 * a > this.maxHeight)
      throw c.ERR_DIMENSIONS;
    for (var d = 0, e = 0, f = 0; g.length;) {
      var h = this._fillRow(g, d, f, b, a);
      h.w > e && (e = h.w);
      d += h.h;
      if (!h.h || !g.length) {
        var k = createjs.createCanvas ? createjs.createCanvas() : document.createElement('canvas');
        k.width = this._getSize(e, this.maxWidth);
        k.height = this._getSize(d, this.maxHeight);
        this._data.images[f] = k;
        h.h || (e = d = 0, f++);
      }
    }
  };
  b._getSize = function (a, b) {
    for (var c = 4; Math.pow(2, ++c) < a;);
    return Math.min(b, Math.pow(2, c));
  };
  b._fillRow = function (a, b, g, d, e) {
    var f = this.maxWidth, h = this.maxHeight;
    b += e;
    for (var h = h - b, k = e, j = 0, l = a.length - 1; 0 <= l; l--) {
      var n = a[l], q = this._scale * n.scale, p = n.sourceRect, s = n.source, r = Math.floor(q * p.x - e), u = Math.floor(q * p.y - e), t = Math.ceil(q * p.height + 2 * e), p = Math.ceil(q * p.width + 2 * e);
      if (p > f)
        throw c.ERR_DIMENSIONS;
      t > h || k + p > f || (n.img = g, n.rect = new createjs.Rectangle(k, b, p, t), j = j || t, a.splice(l, 1), d[n.index] = [
        k,
        b,
        p,
        t,
        g,
        Math.round(-r + q * s.regX - e),
        Math.round(-u + q * s.regY - e)
      ], k += p);
    }
    return {
      w: k,
      h: j
    };
  };
  b._endBuild = function () {
    this.spriteSheet = new createjs.SpriteSheet(this._data);
    this._data = null;
    this.progress = 1;
    this.onComplete && this.onComplete(this);
    this.dispatchEvent('complete');
  };
  b._run = function () {
    for (var a = 50 * Math.max(0.01, Math.min(0.99, this.timeSlice || 0.3)), b = new Date().getTime() + a, c = !1; b > new Date().getTime();)
      if (!this._drawNext()) {
        c = !0;
        break;
      }
    if (c)
      this._endBuild();
    else {
      var d = this;
      this._timerID = setTimeout(function () {
        d._run();
      }, 50 - a);
    }
    a = this.progress = this._index / this._frames.length;
    this.onProgress && this.onProgress(this, a);
    this.dispatchEvent({
      type: 'progress',
      progress: a
    });
  };
  b._drawNext = function () {
    var a = this._frames[this._index], b = a.scale * this._scale, c = a.rect, d = a.sourceRect, e = this._data.images[a.img].getContext('2d');
    a.funct && a.funct.apply(a.scope, a.params);
    e.save();
    e.beginPath();
    e.rect(c.x, c.y, c.width, c.height);
    e.clip();
    e.translate(Math.ceil(c.x - d.x * b), Math.ceil(c.y - d.y * b));
    e.scale(b, b);
    a.source.draw(e);
    e.restore();
    return ++this._index < this._frames.length;
  };
  createjs.SpriteSheetBuilder = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a) {
      this.initialize(a);
    }, b = c.prototype = new createjs.DisplayObject();
  b.htmlElement = null;
  b._oldMtx = null;
  b.DisplayObject_initialize = b.initialize;
  b.initialize = function (a) {
    'string' == typeof a && (a = document.getElementById(a));
    this.DisplayObject_initialize();
    this.mouseEnabled = !1;
    this.htmlElement = a;
    a = a.style;
    a.position = 'absolute';
    a.transformOrigin = a.WebkitTransformOrigin = a.msTransformOrigin = a.MozTransformOrigin = a.OTransformOrigin = '0% 0%';
  };
  b.isVisible = function () {
    return null != this.htmlElement;
  };
  b.draw = function () {
    if (null != this.htmlElement) {
      var a = this.getConcatenatedMatrix(this._matrix), b = this.htmlElement.style;
      if (this.visible)
        b.visibility = 'visible';
      else
        return !0;
      var c = this._oldMtx || {};
      c.alpha != a.alpha && (b.opacity = '' + a.alpha, c.alpha = a.alpha);
      if (c.tx != a.tx || c.ty != a.ty || c.a != a.a || c.b != a.b || c.c != a.c || c.d != a.d)
        b.transform = b.WebkitTransform = b.OTransform = b.msTransform = [
          'matrix(' + a.a,
          a.b,
          a.c,
          a.d,
          a.tx + 0.5 | 0,
          (a.ty + 0.5 | 0) + ')'
        ].join(), b.MozTransform = [
          'matrix(' + a.a,
          a.b,
          a.c,
          a.d,
          (a.tx + 0.5 | 0) + 'px',
          (a.ty + 0.5 | 0) + 'px)'
        ].join(), this._oldMtx = a.clone();
      return !0;
    }
  };
  b.cache = function () {
  };
  b.uncache = function () {
  };
  b.updateCache = function () {
  };
  b.hitTest = function () {
  };
  b.localToGlobal = function () {
  };
  b.globalToLocal = function () {
  };
  b.localToLocal = function () {
  };
  b.clone = function () {
    throw 'DOMElement cannot be cloned.';
  };
  b.toString = function () {
    return '[DOMElement (name=' + this.name + ')]';
  };
  b.DisplayObject__tick = b._tick;
  b._tick = function (a) {
    this.htmlElement.style.visibility = 'hidden';
    this.DisplayObject__tick(a);
  };
  createjs.DOMElement = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
      this.initialize();
    }, b = c.prototype;
  b.initialize = function () {
  };
  b.getBounds = function () {
    return new createjs.Rectangle(0, 0, 0, 0);
  };
  b.applyFilter = function () {
  };
  b.toString = function () {
    return '[Filter]';
  };
  b.clone = function () {
    return new c();
  };
  createjs.Filter = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
    throw 'Touch cannot be instantiated';
  };
  c.isSupported = function () {
    return 'ontouchstart' in window || window.navigator.msPointerEnabled;
  };
  c.enable = function (b, a, m) {
    if (!b || !b.canvas || !c.isSupported())
      return !1;
    b.__touch = {
      pointers: {},
      multitouch: !a,
      preventDefault: !m,
      count: 0
    };
    'ontouchstart' in window ? c._IOS_enable(b) : window.navigator.msPointerEnabled && c._IE_enable(b);
    return !0;
  };
  c.disable = function (b) {
    b && ('ontouchstart' in window ? c._IOS_disable(b) : window.navigator.msPointerEnabled && c._IE_disable(b));
  };
  c._IOS_enable = function (b) {
    var a = b.canvas, m = b.__touch.f = function (a) {
        c._IOS_handleEvent(b, a);
      };
    a.addEventListener('touchstart', m, !1);
    a.addEventListener('touchmove', m, !1);
    a.addEventListener('touchend', m, !1);
    a.addEventListener('touchcancel', m, !1);
  };
  c._IOS_disable = function (b) {
    var a = b.canvas;
    a && (b = b.__touch.f, a.removeEventListener('touchstart', b, !1), a.removeEventListener('touchmove', b, !1), a.removeEventListener('touchend', b, !1), a.removeEventListener('touchcancel', b, !1));
  };
  c._IOS_handleEvent = function (b, a) {
    if (b) {
      b.__touch.preventDefault && a.preventDefault && a.preventDefault();
      for (var c = a.changedTouches, g = a.type, d = 0, e = c.length; d < e; d++) {
        var f = c[d], h = f.identifier;
        f.target == b.canvas && ('touchstart' == g ? this._handleStart(b, h, a, f.pageX, f.pageY) : 'touchmove' == g ? this._handleMove(b, h, a, f.pageX, f.pageY) : ('touchend' == g || 'touchcancel' == g) && this._handleEnd(b, h, a));
      }
    }
  };
  c._IE_enable = function (b) {
    var a = b.canvas, m = b.__touch.f = function (a) {
        c._IE_handleEvent(b, a);
      };
    a.addEventListener('MSPointerDown', m, !1);
    window.addEventListener('MSPointerMove', m, !1);
    window.addEventListener('MSPointerUp', m, !1);
    window.addEventListener('MSPointerCancel', m, !1);
    b.__touch.preventDefault && (a.style.msTouchAction = 'none');
    b.__touch.activeIDs = {};
  };
  c._IE_disable = function (b) {
    var a = b.__touch.f;
    window.removeEventListener('MSPointerMove', a, !1);
    window.removeEventListener('MSPointerUp', a, !1);
    window.removeEventListener('MSPointerCancel', a, !1);
    b.canvas && b.canvas.removeEventListener('MSPointerDown', a, !1);
  };
  c._IE_handleEvent = function (b, a) {
    if (b) {
      b.__touch.preventDefault && a.preventDefault && a.preventDefault();
      var c = a.type, g = a.pointerId, d = b.__touch.activeIDs;
      if ('MSPointerDown' == c)
        a.srcElement == b.canvas && (d[g] = !0, this._handleStart(b, g, a, a.pageX, a.pageY));
      else if (d[g])
        if ('MSPointerMove' == c)
          this._handleMove(b, g, a, a.pageX, a.pageY);
        else if ('MSPointerUp' == c || 'MSPointerCancel' == c)
          delete d[g], this._handleEnd(b, g, a);
    }
  };
  c._handleStart = function (b, a, c, g, d) {
    var e = b.__touch;
    if (e.multitouch || !e.count) {
      var f = e.pointers;
      f[a] || (f[a] = !0, e.count++, b._handlePointerDown(a, c, g, d));
    }
  };
  c._handleMove = function (b, a, c, g, d) {
    b.__touch.pointers[a] && b._handlePointerMove(a, c, g, d);
  };
  c._handleEnd = function (b, a, c) {
    var g = b.__touch, d = g.pointers;
    d[a] && (g.count--, b._handlePointerUp(a, c, !0), delete d[a]);
  };
  createjs.Touch = c;
}());
(function () {
  var c = this.createjs = this.createjs || {}, c = c.EaselJS = c.EaselJS || {};
  c.version = '0.6.1';
  c.buildDate = 'Tue, 14 May 2013 21:43:02 GMT';
}());
this.createjs = this.createjs || {};
(function () {
  var b = function () {
      this.initialize();
    }, a = b.prototype;
  b.initialize = function (d) {
    d.addEventListener = a.addEventListener;
    d.removeEventListener = a.removeEventListener;
    d.removeAllEventListeners = a.removeAllEventListeners;
    d.hasEventListener = a.hasEventListener;
    d.dispatchEvent = a.dispatchEvent;
  };
  a._listeners = null;
  a.initialize = function () {
  };
  a.addEventListener = function (d, a) {
    var c = this._listeners;
    c ? this.removeEventListener(d, a) : c = this._listeners = {};
    var b = c[d];
    b || (b = c[d] = []);
    b.push(a);
    return a;
  };
  a.removeEventListener = function (d, a) {
    var c = this._listeners;
    if (c) {
      var b = c[d];
      if (b)
        for (var f = 0, g = b.length; f < g; f++)
          if (b[f] == a) {
            1 == g ? delete c[d] : b.splice(f, 1);
            break;
          }
    }
  };
  a.removeAllEventListeners = function (d) {
    d ? this._listeners && delete this._listeners[d] : this._listeners = null;
  };
  a.dispatchEvent = function (d, a) {
    var c = !1, b = this._listeners;
    if (d && b) {
      'string' == typeof d && (d = { type: d });
      b = b[d.type];
      if (!b)
        return c;
      d.target = a || this;
      for (var b = b.slice(), f = 0, g = b.length; f < g; f++)
        var j = b[f], c = j.handleEvent ? c || j.handleEvent(d) : c || j(d);
    }
    return !!c;
  };
  a.hasEventListener = function (d) {
    var a = this._listeners;
    return !(!a || !a[d]);
  };
  a.toString = function () {
    return '[EventDispatcher]';
  };
  createjs.EventDispatcher = b;
}());
this.createjs = this.createjs || {};
(function () {
  var b = function (d, a, c) {
      this.initialize(d, a, c);
    }, a = b.prototype;
  b.NONE = 0;
  b.LOOP = 1;
  b.REVERSE = 2;
  b.IGNORE = {};
  b._tweens = [];
  b._plugins = {};
  b.get = function (d, a, c, e) {
    e && b.removeTweens(d);
    return new b(d, a, c);
  };
  b.tick = function (d, a) {
    for (var c = b._tweens.slice(), e = c.length - 1; 0 <= e; e--) {
      var f = c[e];
      a && !f.ignoreGlobalPause || f._paused || f.tick(f._useTicks ? 1 : d);
    }
  };
  createjs.Ticker && createjs.Ticker.addListener(b, !1);
  b.removeTweens = function (d) {
    if (d.tweenjs_count) {
      for (var a = b._tweens, c = a.length - 1; 0 <= c; c--)
        a[c]._target == d && (a[c]._paused = !0, a.splice(c, 1));
      d.tweenjs_count = 0;
    }
  };
  b.removeAllTweens = function () {
    for (var d = b._tweens, a = 0, c = d.length; a < c; a++) {
      var e = d[a];
      e.paused = !0;
      e.target.tweenjs_count = 0;
    }
    d.length = 0;
  };
  b.hasActiveTweens = function (d) {
    return d ? d.tweenjs_count : b._tweens && b._tweens.length;
  };
  b.installPlugin = function (d, a) {
    var c = d.priority;
    null == c && (d.priority = c = 0);
    for (var e = 0, f = a.length, g = b._plugins; e < f; e++) {
      var j = a[e];
      if (g[j]) {
        for (var l = g[j], k = 0, p = l.length; k < p && !(c < l[k].priority); k++);
        g[j].splice(k, 0, d);
      } else
        g[j] = [d];
    }
  };
  b._register = function (d, a) {
    var c = d._target;
    a ? (c && (c.tweenjs_count = c.tweenjs_count ? c.tweenjs_count + 1 : 1), b._tweens.push(d)) : (c && c.tweenjs_count--, c = b._tweens.indexOf(d), -1 != c && b._tweens.splice(c, 1));
  };
  a.addEventListener = null;
  a.removeEventListener = null;
  a.removeAllEventListeners = null;
  a.dispatchEvent = null;
  a.hasEventListener = null;
  a._listeners = null;
  createjs.EventDispatcher.initialize(a);
  a.ignoreGlobalPause = !1;
  a.loop = !1;
  a.duration = 0;
  a.pluginData = null;
  a.onChange = null;
  a.change = null;
  a.target = null;
  a.position = null;
  a._paused = !1;
  a._curQueueProps = null;
  a._initQueueProps = null;
  a._steps = null;
  a._actions = null;
  a._prevPosition = 0;
  a._stepPosition = 0;
  a._prevPos = -1;
  a._target = null;
  a._useTicks = !1;
  a.initialize = function (d, a, c) {
    this.target = this._target = d;
    a && (this._useTicks = a.useTicks, this.ignoreGlobalPause = a.ignoreGlobalPause, this.loop = a.loop, this.onChange = a.onChange, a.override && b.removeTweens(d));
    this.pluginData = c || {};
    this._curQueueProps = {};
    this._initQueueProps = {};
    this._steps = [];
    this._actions = [];
    a && a.paused ? this._paused = !0 : b._register(this, !0);
    a && null != a.position && this.setPosition(a.position, b.NONE);
  };
  a.wait = function (a) {
    if (null == a || 0 >= a)
      return this;
    var b = this._cloneProps(this._curQueueProps);
    return this._addStep({
      d: a,
      p0: b,
      e: this._linearEase,
      p1: b
    });
  };
  a.to = function (a, b, c) {
    if (isNaN(b) || 0 > b)
      b = 0;
    return this._addStep({
      d: b || 0,
      p0: this._cloneProps(this._curQueueProps),
      e: c,
      p1: this._cloneProps(this._appendQueueProps(a))
    });
  };
  a.call = function (a, b, c) {
    return this._addAction({
      f: a,
      p: b ? b : [this],
      o: c ? c : this._target
    });
  };
  a.set = function (a, b) {
    return this._addAction({
      f: this._set,
      o: this,
      p: [
        a,
        b ? b : this._target
      ]
    });
  };
  a.play = function (a) {
    return this.call(a.setPaused, [!1], a);
  };
  a.pause = function (a) {
    a || (a = this);
    return this.call(a.setPaused, [!0], a);
  };
  a.setPosition = function (a, b) {
    0 > a && (a = 0);
    null == b && (b = 1);
    var c = a, e = !1;
    c >= this.duration && (this.loop ? c %= this.duration : (c = this.duration, e = !0));
    if (c == this._prevPos)
      return e;
    var f = this._prevPos;
    this.position = this._prevPos = c;
    this._prevPosition = a;
    if (this._target)
      if (e)
        this._updateTargetProps(null, 1);
      else if (0 < this._steps.length) {
        for (var g = 0, j = this._steps.length; g < j && !(this._steps[g].t > c); g++);
        g = this._steps[g - 1];
        this._updateTargetProps(g, (this._stepPosition = c - g.t) / g.d);
      }
    0 != b && 0 < this._actions.length && (this._useTicks ? this._runActions(c, c) : 1 == b && c < f ? (f != this.duration && this._runActions(f, this.duration), this._runActions(0, c, !0)) : this._runActions(f, c));
    e && this.setPaused(!0);
    this.onChange && this.onChange(this);
    this.dispatchEvent('change');
    return e;
  };
  a.tick = function (a) {
    this._paused || this.setPosition(this._prevPosition + a);
  };
  a.setPaused = function (a) {
    this._paused = !!a;
    b._register(this, !a);
    return this;
  };
  a.w = a.wait;
  a.t = a.to;
  a.c = a.call;
  a.s = a.set;
  a.toString = function () {
    return '[Tween]';
  };
  a.clone = function () {
    throw 'Tween can not be cloned.';
  };
  a._updateTargetProps = function (a, h) {
    var c, e, f, g;
    !a && 1 == h ? c = e = this._curQueueProps : (a.e && (h = a.e(h, 0, 1, 1)), c = a.p0, e = a.p1);
    for (n in this._initQueueProps) {
      if (null == (f = c[n]))
        c[n] = f = this._initQueueProps[n];
      if (null == (g = e[n]))
        e[n] = g = f;
      f = f == g || 0 == h || 1 == h || 'number' != typeof f ? 1 == h ? g : f : f + (g - f) * h;
      var j = !1;
      if (g = b._plugins[n])
        for (var l = 0, k = g.length; l < k; l++) {
          var p = g[l].tween(this, n, f, c, e, h, !!a && c == e, !a);
          p == b.IGNORE ? j = !0 : f = p;
        }
      j || (this._target[n] = f);
    }
  };
  a._runActions = function (a, b, c) {
    var e = a, f = b, g = -1, j = this._actions.length, l = 1;
    a > b && (e = b, f = a, g = j, j = l = -1);
    for (; (g += l) != j;) {
      b = this._actions[g];
      var k = b.t;
      (k == f || k > e && k < f || c && k == a) && b.f.apply(b.o, b.p);
    }
  };
  a._appendQueueProps = function (a) {
    var h, c, e, f, g, j;
    for (j in a) {
      if (void 0 === this._initQueueProps[j]) {
        c = this._target[j];
        if (h = b._plugins[j]) {
          e = 0;
          for (f = h.length; e < f; e++)
            c = h[e].init(this, j, c);
        }
        this._initQueueProps[j] = void 0 === c ? null : c;
      } else
        c = this._curQueueProps[j];
      if (h = b._plugins[j]) {
        g = g || {};
        e = 0;
        for (f = h.length; e < f; e++)
          h[e].step && h[e].step(this, j, c, a[j], g);
      }
      this._curQueueProps[j] = a[j];
    }
    g && this._appendQueueProps(g);
    return this._curQueueProps;
  };
  a._cloneProps = function (a) {
    var b = {}, c;
    for (c in a)
      b[c] = a[c];
    return b;
  };
  a._addStep = function (a) {
    0 < a.d && (this._steps.push(a), a.t = this.duration, this.duration += a.d);
    return this;
  };
  a._addAction = function (a) {
    a.t = this.duration;
    this._actions.push(a);
    return this;
  };
  a._set = function (a, b) {
    for (var c in a)
      b[c] = a[c];
  };
  createjs.Tween = b;
}());
this.createjs = this.createjs || {};
(function () {
  var b = function (a, b, c) {
      this.initialize(a, b, c);
    }, a = b.prototype;
  a.ignoreGlobalPause = !1;
  a.duration = 0;
  a.loop = !1;
  a.onChange = null;
  a.position = null;
  a._paused = !1;
  a._tweens = null;
  a._labels = null;
  a._prevPosition = 0;
  a._prevPos = -1;
  a._useTicks = !1;
  a.initialize = function (a, b, c) {
    this._tweens = [];
    c && (this._useTicks = c.useTicks, this.loop = c.loop, this.ignoreGlobalPause = c.ignoreGlobalPause, this.onChange = c.onChange);
    a && this.addTween.apply(this, a);
    this.setLabels(b);
    c && c.paused ? this._paused = !0 : createjs.Tween._register(this, !0);
    c && null != c.position && this.setPosition(c.position, createjs.Tween.NONE);
  };
  a.addTween = function (a) {
    var b = arguments.length;
    if (1 < b) {
      for (var c = 0; c < b; c++)
        this.addTween(arguments[c]);
      return arguments[0];
    }
    if (0 == b)
      return null;
    this.removeTween(a);
    this._tweens.push(a);
    a.setPaused(!0);
    a._paused = !1;
    a._useTicks = this._useTicks;
    a.duration > this.duration && (this.duration = a.duration);
    0 <= this._prevPos && a.setPosition(this._prevPos, createjs.Tween.NONE);
    return a;
  };
  a.removeTween = function (a) {
    var b = arguments.length;
    if (1 < b) {
      for (var c = !0, e = 0; e < b; e++)
        c = c && this.removeTween(arguments[e]);
      return c;
    }
    if (0 == b)
      return !1;
    b = this._tweens.indexOf(a);
    return -1 != b ? (this._tweens.splice(b, 1), a.duration >= this.duration && this.updateDuration(), !0) : !1;
  };
  a.addLabel = function (a, b) {
    this._labels[a] = b;
  };
  a.setLabels = function (a) {
    this._labels = a ? a : {};
  };
  a.gotoAndPlay = function (a) {
    this.setPaused(!1);
    this._goto(a);
  };
  a.gotoAndStop = function (a) {
    this.setPaused(!0);
    this._goto(a);
  };
  a.setPosition = function (a, b) {
    0 > a && (a = 0);
    var c = this.loop ? a % this.duration : a, e = !this.loop && a >= this.duration;
    if (c == this._prevPos)
      return e;
    this._prevPosition = a;
    this.position = this._prevPos = c;
    for (var f = 0, g = this._tweens.length; f < g; f++)
      if (this._tweens[f].setPosition(c, b), c != this._prevPos)
        return !1;
    e && this.setPaused(!0);
    this.onChange && this.onChange(this);
    return e;
  };
  a.setPaused = function (a) {
    this._paused = !!a;
    createjs.Tween._register(this, !a);
  };
  a.updateDuration = function () {
    for (var a = this.duration = 0, b = this._tweens.length; a < b; a++) {
      var c = this._tweens[a];
      c.duration > this.duration && (this.duration = c.duration);
    }
  };
  a.tick = function (a) {
    this.setPosition(this._prevPosition + a);
  };
  a.resolve = function (a) {
    var b = parseFloat(a);
    isNaN(b) && (b = this._labels[a]);
    return b;
  };
  a.toString = function () {
    return '[Timeline]';
  };
  a.clone = function () {
    throw 'Timeline can not be cloned.';
  };
  a._goto = function (a) {
    a = this.resolve(a);
    null != a && this.setPosition(a);
  };
  createjs.Timeline = b;
}());
this.createjs = this.createjs || {};
(function () {
  var b = function () {
    throw 'Ease cannot be instantiated.';
  };
  b.linear = function (a) {
    return a;
  };
  b.none = b.linear;
  b.get = function (a) {
    -1 > a && (a = -1);
    1 < a && (a = 1);
    return function (b) {
      return 0 == a ? b : 0 > a ? b * (b * -a + 1 + a) : b * ((2 - b) * a + (1 - a));
    };
  };
  b.getPowIn = function (a) {
    return function (b) {
      return Math.pow(b, a);
    };
  };
  b.getPowOut = function (a) {
    return function (b) {
      return 1 - Math.pow(1 - b, a);
    };
  };
  b.getPowInOut = function (a) {
    return function (b) {
      return 1 > (b *= 2) ? 0.5 * Math.pow(b, a) : 1 - 0.5 * Math.abs(Math.pow(2 - b, a));
    };
  };
  b.quadIn = b.getPowIn(2);
  b.quadOut = b.getPowOut(2);
  b.quadInOut = b.getPowInOut(2);
  b.cubicIn = b.getPowIn(3);
  b.cubicOut = b.getPowOut(3);
  b.cubicInOut = b.getPowInOut(3);
  b.quartIn = b.getPowIn(4);
  b.quartOut = b.getPowOut(4);
  b.quartInOut = b.getPowInOut(4);
  b.quintIn = b.getPowIn(5);
  b.quintOut = b.getPowOut(5);
  b.quintInOut = b.getPowInOut(5);
  b.sineIn = function (a) {
    return 1 - Math.cos(a * Math.PI / 2);
  };
  b.sineOut = function (a) {
    return Math.sin(a * Math.PI / 2);
  };
  b.sineInOut = function (a) {
    return -0.5 * (Math.cos(Math.PI * a) - 1);
  };
  b.getBackIn = function (a) {
    return function (b) {
      return b * b * ((a + 1) * b - a);
    };
  };
  b.backIn = b.getBackIn(1.7);
  b.getBackOut = function (a) {
    return function (b) {
      return --b * b * ((a + 1) * b + a) + 1;
    };
  };
  b.backOut = b.getBackOut(1.7);
  b.getBackInOut = function (a) {
    a *= 1.525;
    return function (b) {
      return 1 > (b *= 2) ? 0.5 * b * b * ((a + 1) * b - a) : 0.5 * ((b -= 2) * b * ((a + 1) * b + a) + 2);
    };
  };
  b.backInOut = b.getBackInOut(1.7);
  b.circIn = function (a) {
    return -(Math.sqrt(1 - a * a) - 1);
  };
  b.circOut = function (a) {
    return Math.sqrt(1 - --a * a);
  };
  b.circInOut = function (a) {
    return 1 > (a *= 2) ? -0.5 * (Math.sqrt(1 - a * a) - 1) : 0.5 * (Math.sqrt(1 - (a -= 2) * a) + 1);
  };
  b.bounceIn = function (a) {
    return 1 - b.bounceOut(1 - a);
  };
  b.bounceOut = function (a) {
    return a < 1 / 2.75 ? 7.5625 * a * a : a < 2 / 2.75 ? 7.5625 * (a -= 1.5 / 2.75) * a + 0.75 : a < 2.5 / 2.75 ? 7.5625 * (a -= 2.25 / 2.75) * a + 0.9375 : 7.5625 * (a -= 2.625 / 2.75) * a + 0.984375;
  };
  b.bounceInOut = function (a) {
    return 0.5 > a ? 0.5 * b.bounceIn(2 * a) : 0.5 * b.bounceOut(2 * a - 1) + 0.5;
  };
  b.getElasticIn = function (a, b) {
    var h = 2 * Math.PI;
    return function (c) {
      if (0 == c || 1 == c)
        return c;
      var e = b / h * Math.asin(1 / a);
      return -(a * Math.pow(2, 10 * (c -= 1)) * Math.sin((c - e) * h / b));
    };
  };
  b.elasticIn = b.getElasticIn(1, 0.3);
  b.getElasticOut = function (a, b) {
    var h = 2 * Math.PI;
    return function (c) {
      if (0 == c || 1 == c)
        return c;
      var e = b / h * Math.asin(1 / a);
      return a * Math.pow(2, -10 * c) * Math.sin((c - e) * h / b) + 1;
    };
  };
  b.elasticOut = b.getElasticOut(1, 0.3);
  b.getElasticInOut = function (a, b) {
    var h = 2 * Math.PI;
    return function (c) {
      var e = b / h * Math.asin(1 / a);
      return 1 > (c *= 2) ? -0.5 * a * Math.pow(2, 10 * (c -= 1)) * Math.sin((c - e) * h / b) : 0.5 * a * Math.pow(2, -10 * (c -= 1)) * Math.sin((c - e) * h / b) + 1;
    };
  };
  b.elasticInOut = b.getElasticInOut(1, 0.3 * 1.5);
  createjs.Ease = b;
}());
this.createjs = this.createjs || {};
(function () {
  var b = function () {
    throw 'MotionGuidePlugin cannot be instantiated.';
  };
  b.priority = 0;
  b.install = function () {
    createjs.Tween.installPlugin(b, [
      'guide',
      'x',
      'y',
      'rotation'
    ]);
    return createjs.Tween.IGNORE;
  };
  b.init = function (a, b, h) {
    a = a.target;
    a.hasOwnProperty('x') || (a.x = 0);
    a.hasOwnProperty('y') || (a.y = 0);
    a.hasOwnProperty('rotation') || (a.rotation = 0);
    return 'guide' == b ? null : h;
  };
  b.step = function (a, d, h, c, e) {
    if ('guide' != d)
      return c;
    var f;
    c.hasOwnProperty('path') || (c.path = []);
    a = c.path;
    c.hasOwnProperty('end') || (c.end = 1);
    c.hasOwnProperty('start') || (c.start = h && h.hasOwnProperty('end') && h.path === a ? h.end : 0);
    if (c.hasOwnProperty('_segments') && c._length)
      return c;
    h = a.length;
    if (6 <= h && 0 == (h - 2) % 4) {
      c._segments = [];
      c._length = 0;
      for (d = 2; d < h; d += 4) {
        for (var g = a[d - 2], j = a[d - 1], l = a[d + 0], k = a[d + 1], p = a[d + 2], x = a[d + 3], v = g, w = j, s, m, r = 0, t = [], u = 1; 10 >= u; u++) {
          m = u / 10;
          var q = 1 - m;
          s = q * q * g + 2 * q * m * l + m * m * p;
          m = q * q * j + 2 * q * m * k + m * m * x;
          r += t[t.push(Math.sqrt((f = s - v) * f + (f = m - w) * f)) - 1];
          v = s;
          w = m;
        }
        c._segments.push(r);
        c._segments.push(t);
        c._length += r;
      }
    } else
      throw 'invalid \'path\' data, please see documentation for valid paths';
    f = c.orient;
    c.orient = !1;
    b.calc(c, c.end, e);
    c.orient = f;
    return c;
  };
  b.tween = function (a, d, h, c, e, f, g) {
    e = e.guide;
    if (void 0 == e || e === c.guide)
      return h;
    e.lastRatio != f && (b.calc(e, (e.end - e.start) * (g ? e.end : f) + e.start, a.target), e.orient && (a.target.rotation += c.rotation || 0), e.lastRatio = f);
    return !e.orient && 'rotation' == d ? h : a.target[d];
  };
  b.calc = function (a, d, h) {
    void 0 == a._segments && b.validate(a);
    void 0 == h && (h = {
      x: 0,
      y: 0,
      rotation: 0
    });
    var c = a._segments, e = a.path, f = a._length * d, g = c.length - 2;
    for (d = 0; f > c[d] && d < g;)
      f -= c[d], d += 2;
    for (var c = c[d + 1], j = 0, g = c.length - 1; f > c[j] && j < g;)
      f -= c[j], j++;
    f = j / ++g + f / (g * c[j]);
    d = 2 * d + 2;
    g = 1 - f;
    h.x = g * g * e[d - 2] + 2 * g * f * e[d + 0] + f * f * e[d + 2];
    h.y = g * g * e[d - 1] + 2 * g * f * e[d + 1] + f * f * e[d + 3];
    a.orient && (h.rotation = 57.2957795 * Math.atan2((e[d + 1] - e[d - 1]) * g + (e[d + 3] - e[d + 1]) * f, (e[d + 0] - e[d - 2]) * g + (e[d + 2] - e[d + 0]) * f));
    return h;
  };
  createjs.MotionGuidePlugin = b;
}());
(function () {
  var b = this.createjs = this.createjs || {}, b = b.TweenJS = b.TweenJS || {};
  b.version = '0.4.0';
  b.buildDate = 'Tue, 12 Feb 2013 21:08:16 GMT';
}());
this.createjs = this.createjs || {};
(function () {
  var d = function (b, a, c, f) {
      this.initialize(b, a, c, f);
    }, a = d.prototype = new createjs.Container();
  d.INDEPENDENT = 'independent';
  d.SINGLE_FRAME = 'single';
  d.SYNCHED = 'synched';
  a.startPosition = 0;
  a.loop = !0;
  a.currentFrame = 0;
  a.timeline = null;
  a.paused = !1;
  a.actionsEnabled = !0;
  a.autoReset = !0;
  a._synchOffset = 0;
  a._prevPos = -1;
  a._prevPosition = 0;
  a.Container_initialize = a.initialize;
  a.initialize = function (b, a, c, f) {
    this.mode = b || d.INDEPENDENT;
    this.startPosition = a || 0;
    this.loop = c;
    props = {
      paused: !0,
      position: a,
      useTicks: !0
    };
    this.Container_initialize();
    this.timeline = new createjs.Timeline(null, f, props);
    this._managed = {};
  };
  a.isVisible = function () {
    return !(!this.visible || !(0 < this.alpha && 0 != this.scaleX && 0 != this.scaleY));
  };
  a.Container_draw = a.draw;
  a.draw = function (b, a, c) {
    if (this.DisplayObject_draw(b, a))
      return !0;
    this._updateTimeline();
    this.Container_draw(b, a, c);
  };
  a.play = function () {
    this.paused = !1;
  };
  a.stop = function () {
    this.paused = !0;
  };
  a.gotoAndPlay = function (b) {
    this.paused = !1;
    this._goto(b);
  };
  a.gotoAndStop = function (b) {
    this.paused = !0;
    this._goto(b);
  };
  a.clone = function () {
    throw 'MovieClip cannot be cloned.';
  };
  a.toString = function () {
    return '[MovieClip (name=' + this.name + ')]';
  };
  a.Container__tick = a._tick;
  a._tick = function (b) {
    !this.paused && this.mode == d.INDEPENDENT && (this._prevPosition = 0 > this._prevPos ? 0 : this._prevPosition + 1);
    this.Container__tick(b);
  };
  a._goto = function (b) {
    b = this.timeline.resolve(b);
    null != b && (-1 == this._prevPos && (this._prevPos = NaN), this._prevPosition = b, this._updateTimeline());
  };
  a._reset = function () {
    this._prevPos = -1;
    this.currentFrame = 0;
  };
  a._updateTimeline = function () {
    var b = this.timeline, a = b._tweens, c = this.children, f = this.mode != d.INDEPENDENT;
    b.loop = null == this.loop ? !0 : this.loop;
    f ? b.setPosition(this.startPosition + (this.mode == d.SINGLE_FRAME ? 0 : this._synchOffset), createjs.Tween.NONE) : b.setPosition(0 > this._prevPos ? 0 : this._prevPosition, this.actionsEnabled ? null : createjs.Tween.NONE);
    this._prevPosition = b._prevPosition;
    if (this._prevPos != b._prevPos) {
      this.currentFrame = this._prevPos = b._prevPos;
      for (var e in this._managed)
        this._managed[e] = 1;
      for (b = a.length - 1; 0 <= b; b--)
        e = a[b], f = e._target, f != this && (e = e._stepPosition, f instanceof createjs.DisplayObject ? this._addManagedChild(f, e) : this._setState(f.state, e));
      for (b = c.length - 1; 0 <= b; b--)
        a = c[b].id, 1 == this._managed[a] && (this.removeChildAt(b), delete this._managed[a]);
    }
  };
  a._setState = function (b, a) {
    if (b)
      for (var c = 0, f = b.length; c < f; c++) {
        var e = b[c], d = e.t, e = e.p, g;
        for (g in e)
          d[g] = e[g];
        this._addManagedChild(d, a);
      }
  };
  a._addManagedChild = function (b, a) {
    b._off || (this.addChild(b), b instanceof d && (b._synchOffset = a, b.mode == d.INDEPENDENT && (b.autoReset && !this._managed[b.id]) && b._reset()), this._managed[b.id] = 2);
  };
  createjs.MovieClip = d;
  var g = function () {
    throw 'MovieClipPlugin cannot be instantiated.';
  };
  g.priority = 100;
  g.install = function () {
    createjs.Tween.installPlugin(g, ['startPosition']);
  };
  g.init = function (b, a, c) {
    return c;
  };
  g.step = function () {
  };
  g.tween = function (b, a, c, f, e, g) {
    return !(b.target instanceof d) ? c : 1 == g ? e[a] : f[a];
  };
  g.install();
}());
'use strict';
var THREE = { REVISION: '66' };
self.console = self.console || {
  info: function () {
  },
  log: function () {
  },
  debug: function () {
  },
  warn: function () {
  },
  error: function () {
  }
};
(function () {
  for (var a = 0, b = [
        'ms',
        'moz',
        'webkit',
        'o'
      ], c = 0; c < b.length && !self.requestAnimationFrame; ++c)
    self.requestAnimationFrame = self[b[c] + 'RequestAnimationFrame'], self.cancelAnimationFrame = self[b[c] + 'CancelAnimationFrame'] || self[b[c] + 'CancelRequestAnimationFrame'];
  void 0 === self.requestAnimationFrame && void 0 !== self.setTimeout && (self.requestAnimationFrame = function (b) {
    var c = Date.now(), f = Math.max(0, 16 - (c - a)), g = self.setTimeout(function () {
        b(c + f);
      }, f);
    a = c + f;
    return g;
  });
  void 0 === self.cancelAnimationFrame && void 0 !== self.clearTimeout && (self.cancelAnimationFrame = function (a) {
    self.clearTimeout(a);
  });
}());
THREE.CullFaceNone = 0;
THREE.CullFaceBack = 1;
THREE.CullFaceFront = 2;
THREE.CullFaceFrontBack = 3;
THREE.FrontFaceDirectionCW = 0;
THREE.FrontFaceDirectionCCW = 1;
THREE.BasicShadowMap = 0;
THREE.PCFShadowMap = 1;
THREE.PCFSoftShadowMap = 2;
THREE.FrontSide = 0;
THREE.BackSide = 1;
THREE.DoubleSide = 2;
THREE.NoShading = 0;
THREE.FlatShading = 1;
THREE.SmoothShading = 2;
THREE.NoColors = 0;
THREE.FaceColors = 1;
THREE.VertexColors = 2;
THREE.NoBlending = 0;
THREE.NormalBlending = 1;
THREE.AdditiveBlending = 2;
THREE.SubtractiveBlending = 3;
THREE.MultiplyBlending = 4;
THREE.CustomBlending = 5;
THREE.AddEquation = 100;
THREE.SubtractEquation = 101;
THREE.ReverseSubtractEquation = 102;
THREE.ZeroFactor = 200;
THREE.OneFactor = 201;
THREE.SrcColorFactor = 202;
THREE.OneMinusSrcColorFactor = 203;
THREE.SrcAlphaFactor = 204;
THREE.OneMinusSrcAlphaFactor = 205;
THREE.DstAlphaFactor = 206;
THREE.OneMinusDstAlphaFactor = 207;
THREE.DstColorFactor = 208;
THREE.OneMinusDstColorFactor = 209;
THREE.SrcAlphaSaturateFactor = 210;
THREE.MultiplyOperation = 0;
THREE.MixOperation = 1;
THREE.AddOperation = 2;
THREE.UVMapping = function () {
};
THREE.CubeReflectionMapping = function () {
};
THREE.CubeRefractionMapping = function () {
};
THREE.SphericalReflectionMapping = function () {
};
THREE.SphericalRefractionMapping = function () {
};
THREE.RepeatWrapping = 1000;
THREE.ClampToEdgeWrapping = 1001;
THREE.MirroredRepeatWrapping = 1002;
THREE.NearestFilter = 1003;
THREE.NearestMipMapNearestFilter = 1004;
THREE.NearestMipMapLinearFilter = 1005;
THREE.LinearFilter = 1006;
THREE.LinearMipMapNearestFilter = 1007;
THREE.LinearMipMapLinearFilter = 1008;
THREE.UnsignedByteType = 1009;
THREE.ByteType = 1010;
THREE.ShortType = 1011;
THREE.UnsignedShortType = 1012;
THREE.IntType = 1013;
THREE.UnsignedIntType = 1014;
THREE.FloatType = 1015;
THREE.UnsignedShort4444Type = 1016;
THREE.UnsignedShort5551Type = 1017;
THREE.UnsignedShort565Type = 1018;
THREE.AlphaFormat = 1019;
THREE.RGBFormat = 1020;
THREE.RGBAFormat = 1021;
THREE.LuminanceFormat = 1022;
THREE.LuminanceAlphaFormat = 1023;
THREE.RGB_S3TC_DXT1_Format = 2001;
THREE.RGBA_S3TC_DXT1_Format = 2002;
THREE.RGBA_S3TC_DXT3_Format = 2003;
THREE.RGBA_S3TC_DXT5_Format = 2004;
THREE.Color = function (a) {
  return 3 === arguments.length ? this.setRGB(arguments[0], arguments[1], arguments[2]) : this.set(a);
};
THREE.Color.prototype = {
  constructor: THREE.Color,
  r: 1,
  g: 1,
  b: 1,
  set: function (a) {
    a instanceof THREE.Color ? this.copy(a) : 'number' === typeof a ? this.setHex(a) : 'string' === typeof a && this.setStyle(a);
    return this;
  },
  setHex: function (a) {
    a = Math.floor(a);
    this.r = (a >> 16 & 255) / 255;
    this.g = (a >> 8 & 255) / 255;
    this.b = (a & 255) / 255;
    return this;
  },
  setRGB: function (a, b, c) {
    this.r = a;
    this.g = b;
    this.b = c;
    return this;
  },
  setHSL: function (a, b, c) {
    if (0 === b)
      this.r = this.g = this.b = c;
    else {
      var d = function (a, b, c) {
        0 > c && (c += 1);
        1 < c && (c -= 1);
        return c < 1 / 6 ? a + 6 * (b - a) * c : 0.5 > c ? b : c < 2 / 3 ? a + 6 * (b - a) * (2 / 3 - c) : a;
      };
      b = 0.5 >= c ? c * (1 + b) : c + b - c * b;
      c = 2 * c - b;
      this.r = d(c, b, a + 1 / 3);
      this.g = d(c, b, a);
      this.b = d(c, b, a - 1 / 3);
    }
    return this;
  },
  setStyle: function (a) {
    if (/^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test(a))
      return a = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec(a), this.r = Math.min(255, parseInt(a[1], 10)) / 255, this.g = Math.min(255, parseInt(a[2], 10)) / 255, this.b = Math.min(255, parseInt(a[3], 10)) / 255, this;
    if (/^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test(a))
      return a = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec(a), this.r = Math.min(100, parseInt(a[1], 10)) / 100, this.g = Math.min(100, parseInt(a[2], 10)) / 100, this.b = Math.min(100, parseInt(a[3], 10)) / 100, this;
    if (/^\#([0-9a-f]{6})$/i.test(a))
      return a = /^\#([0-9a-f]{6})$/i.exec(a), this.setHex(parseInt(a[1], 16)), this;
    if (/^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(a))
      return a = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(a), this.setHex(parseInt(a[1] + a[1] + a[2] + a[2] + a[3] + a[3], 16)), this;
    if (/^(\w+)$/i.test(a))
      return this.setHex(THREE.ColorKeywords[a]), this;
  },
  copy: function (a) {
    this.r = a.r;
    this.g = a.g;
    this.b = a.b;
    return this;
  },
  copyGammaToLinear: function (a) {
    this.r = a.r * a.r;
    this.g = a.g * a.g;
    this.b = a.b * a.b;
    return this;
  },
  copyLinearToGamma: function (a) {
    this.r = Math.sqrt(a.r);
    this.g = Math.sqrt(a.g);
    this.b = Math.sqrt(a.b);
    return this;
  },
  convertGammaToLinear: function () {
    var a = this.r, b = this.g, c = this.b;
    this.r = a * a;
    this.g = b * b;
    this.b = c * c;
    return this;
  },
  convertLinearToGamma: function () {
    this.r = Math.sqrt(this.r);
    this.g = Math.sqrt(this.g);
    this.b = Math.sqrt(this.b);
    return this;
  },
  getHex: function () {
    return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;
  },
  getHexString: function () {
    return ('000000' + this.getHex().toString(16)).slice(-6);
  },
  getHSL: function (a) {
    a = a || {
      h: 0,
      s: 0,
      l: 0
    };
    var b = this.r, c = this.g, d = this.b, e = Math.max(b, c, d), f = Math.min(b, c, d), g, h = (f + e) / 2;
    if (f === e)
      f = g = 0;
    else {
      var k = e - f, f = 0.5 >= h ? k / (e + f) : k / (2 - e - f);
      switch (e) {
      case b:
        g = (c - d) / k + (c < d ? 6 : 0);
        break;
      case c:
        g = (d - b) / k + 2;
        break;
      case d:
        g = (b - c) / k + 4;
      }
      g /= 6;
    }
    a.h = g;
    a.s = f;
    a.l = h;
    return a;
  },
  getStyle: function () {
    return 'rgb(' + (255 * this.r | 0) + ',' + (255 * this.g | 0) + ',' + (255 * this.b | 0) + ')';
  },
  offsetHSL: function (a, b, c) {
    var d = this.getHSL();
    d.h += a;
    d.s += b;
    d.l += c;
    this.setHSL(d.h, d.s, d.l);
    return this;
  },
  add: function (a) {
    this.r += a.r;
    this.g += a.g;
    this.b += a.b;
    return this;
  },
  addColors: function (a, b) {
    this.r = a.r + b.r;
    this.g = a.g + b.g;
    this.b = a.b + b.b;
    return this;
  },
  addScalar: function (a) {
    this.r += a;
    this.g += a;
    this.b += a;
    return this;
  },
  multiply: function (a) {
    this.r *= a.r;
    this.g *= a.g;
    this.b *= a.b;
    return this;
  },
  multiplyScalar: function (a) {
    this.r *= a;
    this.g *= a;
    this.b *= a;
    return this;
  },
  lerp: function (a, b) {
    this.r += (a.r - this.r) * b;
    this.g += (a.g - this.g) * b;
    this.b += (a.b - this.b) * b;
    return this;
  },
  equals: function (a) {
    return a.r === this.r && a.g === this.g && a.b === this.b;
  },
  fromArray: function (a) {
    this.r = a[0];
    this.g = a[1];
    this.b = a[2];
    return this;
  },
  toArray: function () {
    return [
      this.r,
      this.g,
      this.b
    ];
  },
  clone: function () {
    return new THREE.Color().setRGB(this.r, this.g, this.b);
  }
};
THREE.ColorKeywords = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
THREE.Quaternion = function (a, b, c, d) {
  this._x = a || 0;
  this._y = b || 0;
  this._z = c || 0;
  this._w = void 0 !== d ? d : 1;
};
THREE.Quaternion.prototype = {
  constructor: THREE.Quaternion,
  _x: 0,
  _y: 0,
  _z: 0,
  _w: 0,
  _euler: void 0,
  _updateEuler: function (a) {
    void 0 !== this._euler && this._euler.setFromQuaternion(this, void 0, !1);
  },
  get x() {
    return this._x;
  },
  set x(a) {
    this._x = a;
    this._updateEuler();
  },
  get y() {
    return this._y;
  },
  set y(a) {
    this._y = a;
    this._updateEuler();
  },
  get z() {
    return this._z;
  },
  set z(a) {
    this._z = a;
    this._updateEuler();
  },
  get w() {
    return this._w;
  },
  set w(a) {
    this._w = a;
    this._updateEuler();
  },
  set: function (a, b, c, d) {
    this._x = a;
    this._y = b;
    this._z = c;
    this._w = d;
    this._updateEuler();
    return this;
  },
  copy: function (a) {
    this._x = a._x;
    this._y = a._y;
    this._z = a._z;
    this._w = a._w;
    this._updateEuler();
    return this;
  },
  setFromEuler: function (a, b) {
    if (!1 === a instanceof THREE.Euler)
      throw Error('ERROR: Quaternion\'s .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.');
    var c = Math.cos(a._x / 2), d = Math.cos(a._y / 2), e = Math.cos(a._z / 2), f = Math.sin(a._x / 2), g = Math.sin(a._y / 2), h = Math.sin(a._z / 2);
    'XYZ' === a.order ? (this._x = f * d * e + c * g * h, this._y = c * g * e - f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e - f * g * h) : 'YXZ' === a.order ? (this._x = f * d * e + c * g * h, this._y = c * g * e - f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e + f * g * h) : 'ZXY' === a.order ? (this._x = f * d * e - c * g * h, this._y = c * g * e + f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e - f * g * h) : 'ZYX' === a.order ? (this._x = f * d * e - c * g * h, this._y = c * g * e + f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e + f * g * h) : 'YZX' === a.order ? (this._x = f * d * e + c * g * h, this._y = c * g * e + f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e - f * g * h) : 'XZY' === a.order && (this._x = f * d * e - c * g * h, this._y = c * g * e - f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e + f * g * h);
    !1 !== b && this._updateEuler();
    return this;
  },
  setFromAxisAngle: function (a, b) {
    var c = b / 2, d = Math.sin(c);
    this._x = a.x * d;
    this._y = a.y * d;
    this._z = a.z * d;
    this._w = Math.cos(c);
    this._updateEuler();
    return this;
  },
  setFromRotationMatrix: function (a) {
    var b = a.elements, c = b[0];
    a = b[4];
    var d = b[8], e = b[1], f = b[5], g = b[9], h = b[2], k = b[6], b = b[10], l = c + f + b;
    0 < l ? (c = 0.5 / Math.sqrt(l + 1), this._w = 0.25 / c, this._x = (k - g) * c, this._y = (d - h) * c, this._z = (e - a) * c) : c > f && c > b ? (c = 2 * Math.sqrt(1 + c - f - b), this._w = (k - g) / c, this._x = 0.25 * c, this._y = (a + e) / c, this._z = (d + h) / c) : f > b ? (c = 2 * Math.sqrt(1 + f - c - b), this._w = (d - h) / c, this._x = (a + e) / c, this._y = 0.25 * c, this._z = (g + k) / c) : (c = 2 * Math.sqrt(1 + b - c - f), this._w = (e - a) / c, this._x = (d + h) / c, this._y = (g + k) / c, this._z = 0.25 * c);
    this._updateEuler();
    return this;
  },
  inverse: function () {
    this.conjugate().normalize();
    return this;
  },
  conjugate: function () {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._updateEuler();
    return this;
  },
  lengthSq: function () {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  },
  length: function () {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  },
  normalize: function () {
    var a = this.length();
    0 === a ? (this._z = this._y = this._x = 0, this._w = 1) : (a = 1 / a, this._x *= a, this._y *= a, this._z *= a, this._w *= a);
    return this;
  },
  multiply: function (a, b) {
    return void 0 !== b ? (console.warn('DEPRECATED: Quaternion\'s .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.'), this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a);
  },
  multiplyQuaternions: function (a, b) {
    var c = a._x, d = a._y, e = a._z, f = a._w, g = b._x, h = b._y, k = b._z, l = b._w;
    this._x = c * l + f * g + d * k - e * h;
    this._y = d * l + f * h + e * g - c * k;
    this._z = e * l + f * k + c * h - d * g;
    this._w = f * l - c * g - d * h - e * k;
    this._updateEuler();
    return this;
  },
  multiplyVector3: function (a) {
    console.warn('DEPRECATED: Quaternion\'s .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
    return a.applyQuaternion(this);
  },
  slerp: function (a, b) {
    var c = this._x, d = this._y, e = this._z, f = this._w, g = f * a._w + c * a._x + d * a._y + e * a._z;
    0 > g ? (this._w = -a._w, this._x = -a._x, this._y = -a._y, this._z = -a._z, g = -g) : this.copy(a);
    if (1 <= g)
      return this._w = f, this._x = c, this._y = d, this._z = e, this;
    var h = Math.acos(g), k = Math.sqrt(1 - g * g);
    if (0.001 > Math.abs(k))
      return this._w = 0.5 * (f + this._w), this._x = 0.5 * (c + this._x), this._y = 0.5 * (d + this._y), this._z = 0.5 * (e + this._z), this;
    g = Math.sin((1 - b) * h) / k;
    h = Math.sin(b * h) / k;
    this._w = f * g + this._w * h;
    this._x = c * g + this._x * h;
    this._y = d * g + this._y * h;
    this._z = e * g + this._z * h;
    this._updateEuler();
    return this;
  },
  equals: function (a) {
    return a._x === this._x && a._y === this._y && a._z === this._z && a._w === this._w;
  },
  fromArray: function (a) {
    this._x = a[0];
    this._y = a[1];
    this._z = a[2];
    this._w = a[3];
    this._updateEuler();
    return this;
  },
  toArray: function () {
    return [
      this._x,
      this._y,
      this._z,
      this._w
    ];
  },
  clone: function () {
    return new THREE.Quaternion(this._x, this._y, this._z, this._w);
  }
};
THREE.Quaternion.slerp = function (a, b, c, d) {
  return c.copy(a).slerp(b, d);
};
THREE.Vector2 = function (a, b) {
  this.x = a || 0;
  this.y = b || 0;
};
THREE.Vector2.prototype = {
  constructor: THREE.Vector2,
  set: function (a, b) {
    this.x = a;
    this.y = b;
    return this;
  },
  setX: function (a) {
    this.x = a;
    return this;
  },
  setY: function (a) {
    this.y = a;
    return this;
  },
  setComponent: function (a, b) {
    switch (a) {
    case 0:
      this.x = b;
      break;
    case 1:
      this.y = b;
      break;
    default:
      throw Error('index is out of range: ' + a);
    }
  },
  getComponent: function (a) {
    switch (a) {
    case 0:
      return this.x;
    case 1:
      return this.y;
    default:
      throw Error('index is out of range: ' + a);
    }
  },
  copy: function (a) {
    this.x = a.x;
    this.y = a.y;
    return this;
  },
  add: function (a, b) {
    if (void 0 !== b)
      return console.warn('DEPRECATED: Vector2\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.'), this.addVectors(a, b);
    this.x += a.x;
    this.y += a.y;
    return this;
  },
  addVectors: function (a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
  },
  addScalar: function (a) {
    this.x += a;
    this.y += a;
    return this;
  },
  sub: function (a, b) {
    if (void 0 !== b)
      return console.warn('DEPRECATED: Vector2\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.'), this.subVectors(a, b);
    this.x -= a.x;
    this.y -= a.y;
    return this;
  },
  subVectors: function (a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
  },
  multiplyScalar: function (a) {
    this.x *= a;
    this.y *= a;
    return this;
  },
  divideScalar: function (a) {
    0 !== a ? (a = 1 / a, this.x *= a, this.y *= a) : this.y = this.x = 0;
    return this;
  },
  min: function (a) {
    this.x > a.x && (this.x = a.x);
    this.y > a.y && (this.y = a.y);
    return this;
  },
  max: function (a) {
    this.x < a.x && (this.x = a.x);
    this.y < a.y && (this.y = a.y);
    return this;
  },
  clamp: function (a, b) {
    this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x);
    this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y);
    return this;
  },
  clampScalar: function () {
    var a, b;
    return function (c, d) {
      void 0 === a && (a = new THREE.Vector2(), b = new THREE.Vector2());
      a.set(c, c);
      b.set(d, d);
      return this.clamp(a, b);
    };
  }(),
  floor: function () {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  },
  ceil: function () {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  },
  round: function () {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  },
  roundToZero: function () {
    this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
    return this;
  },
  negate: function () {
    return this.multiplyScalar(-1);
  },
  dot: function (a) {
    return this.x * a.x + this.y * a.y;
  },
  lengthSq: function () {
    return this.x * this.x + this.y * this.y;
  },
  length: function () {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  },
  normalize: function () {
    return this.divideScalar(this.length());
  },
  distanceTo: function (a) {
    return Math.sqrt(this.distanceToSquared(a));
  },
  distanceToSquared: function (a) {
    var b = this.x - a.x;
    a = this.y - a.y;
    return b * b + a * a;
  },
  setLength: function (a) {
    var b = this.length();
    0 !== b && a !== b && this.multiplyScalar(a / b);
    return this;
  },
  lerp: function (a, b) {
    this.x += (a.x - this.x) * b;
    this.y += (a.y - this.y) * b;
    return this;
  },
  equals: function (a) {
    return a.x === this.x && a.y === this.y;
  },
  fromArray: function (a) {
    this.x = a[0];
    this.y = a[1];
    return this;
  },
  toArray: function () {
    return [
      this.x,
      this.y
    ];
  },
  clone: function () {
    return new THREE.Vector2(this.x, this.y);
  }
};
THREE.Vector3 = function (a, b, c) {
  this.x = a || 0;
  this.y = b || 0;
  this.z = c || 0;
};
THREE.Vector3.prototype = {
  constructor: THREE.Vector3,
  set: function (a, b, c) {
    this.x = a;
    this.y = b;
    this.z = c;
    return this;
  },
  setX: function (a) {
    this.x = a;
    return this;
  },
  setY: function (a) {
    this.y = a;
    return this;
  },
  setZ: function (a) {
    this.z = a;
    return this;
  },
  setComponent: function (a, b) {
    switch (a) {
    case 0:
      this.x = b;
      break;
    case 1:
      this.y = b;
      break;
    case 2:
      this.z = b;
      break;
    default:
      throw Error('index is out of range: ' + a);
    }
  },
  getComponent: function (a) {
    switch (a) {
    case 0:
      return this.x;
    case 1:
      return this.y;
    case 2:
      return this.z;
    default:
      throw Error('index is out of range: ' + a);
    }
  },
  copy: function (a) {
    this.x = a.x;
    this.y = a.y;
    this.z = a.z;
    return this;
  },
  add: function (a, b) {
    if (void 0 !== b)
      return console.warn('DEPRECATED: Vector3\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.'), this.addVectors(a, b);
    this.x += a.x;
    this.y += a.y;
    this.z += a.z;
    return this;
  },
  addScalar: function (a) {
    this.x += a;
    this.y += a;
    this.z += a;
    return this;
  },
  addVectors: function (a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
  },
  sub: function (a, b) {
    if (void 0 !== b)
      return console.warn('DEPRECATED: Vector3\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.'), this.subVectors(a, b);
    this.x -= a.x;
    this.y -= a.y;
    this.z -= a.z;
    return this;
  },
  subVectors: function (a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  },
  multiply: function (a, b) {
    if (void 0 !== b)
      return console.warn('DEPRECATED: Vector3\'s .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.'), this.multiplyVectors(a, b);
    this.x *= a.x;
    this.y *= a.y;
    this.z *= a.z;
    return this;
  },
  multiplyScalar: function (a) {
    this.x *= a;
    this.y *= a;
    this.z *= a;
    return this;
  },
  multiplyVectors: function (a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this;
  },
  applyEuler: function () {
    var a;
    return function (b) {
      !1 === b instanceof THREE.Euler && console.error('ERROR: Vector3\'s .applyEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.');
      void 0 === a && (a = new THREE.Quaternion());
      this.applyQuaternion(a.setFromEuler(b));
      return this;
    };
  }(),
  applyAxisAngle: function () {
    var a;
    return function (b, c) {
      void 0 === a && (a = new THREE.Quaternion());
      this.applyQuaternion(a.setFromAxisAngle(b, c));
      return this;
    };
  }(),
  applyMatrix3: function (a) {
    var b = this.x, c = this.y, d = this.z;
    a = a.elements;
    this.x = a[0] * b + a[3] * c + a[6] * d;
    this.y = a[1] * b + a[4] * c + a[7] * d;
    this.z = a[2] * b + a[5] * c + a[8] * d;
    return this;
  },
  applyMatrix4: function (a) {
    var b = this.x, c = this.y, d = this.z;
    a = a.elements;
    this.x = a[0] * b + a[4] * c + a[8] * d + a[12];
    this.y = a[1] * b + a[5] * c + a[9] * d + a[13];
    this.z = a[2] * b + a[6] * c + a[10] * d + a[14];
    return this;
  },
  applyProjection: function (a) {
    var b = this.x, c = this.y, d = this.z;
    a = a.elements;
    var e = 1 / (a[3] * b + a[7] * c + a[11] * d + a[15]);
    this.x = (a[0] * b + a[4] * c + a[8] * d + a[12]) * e;
    this.y = (a[1] * b + a[5] * c + a[9] * d + a[13]) * e;
    this.z = (a[2] * b + a[6] * c + a[10] * d + a[14]) * e;
    return this;
  },
  applyQuaternion: function (a) {
    var b = this.x, c = this.y, d = this.z, e = a.x, f = a.y, g = a.z;
    a = a.w;
    var h = a * b + f * d - g * c, k = a * c + g * b - e * d, l = a * d + e * c - f * b, b = -e * b - f * c - g * d;
    this.x = h * a + b * -e + k * -g - l * -f;
    this.y = k * a + b * -f + l * -e - h * -g;
    this.z = l * a + b * -g + h * -f - k * -e;
    return this;
  },
  transformDirection: function (a) {
    var b = this.x, c = this.y, d = this.z;
    a = a.elements;
    this.x = a[0] * b + a[4] * c + a[8] * d;
    this.y = a[1] * b + a[5] * c + a[9] * d;
    this.z = a[2] * b + a[6] * c + a[10] * d;
    this.normalize();
    return this;
  },
  divide: function (a) {
    this.x /= a.x;
    this.y /= a.y;
    this.z /= a.z;
    return this;
  },
  divideScalar: function (a) {
    0 !== a ? (a = 1 / a, this.x *= a, this.y *= a, this.z *= a) : this.z = this.y = this.x = 0;
    return this;
  },
  min: function (a) {
    this.x > a.x && (this.x = a.x);
    this.y > a.y && (this.y = a.y);
    this.z > a.z && (this.z = a.z);
    return this;
  },
  max: function (a) {
    this.x < a.x && (this.x = a.x);
    this.y < a.y && (this.y = a.y);
    this.z < a.z && (this.z = a.z);
    return this;
  },
  clamp: function (a, b) {
    this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x);
    this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y);
    this.z < a.z ? this.z = a.z : this.z > b.z && (this.z = b.z);
    return this;
  },
  clampScalar: function () {
    var a, b;
    return function (c, d) {
      void 0 === a && (a = new THREE.Vector3(), b = new THREE.Vector3());
      a.set(c, c, c);
      b.set(d, d, d);
      return this.clamp(a, b);
    };
  }(),
  floor: function () {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  },
  ceil: function () {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  },
  round: function () {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  },
  roundToZero: function () {
    this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
    return this;
  },
  negate: function () {
    return this.multiplyScalar(-1);
  },
  dot: function (a) {
    return this.x * a.x + this.y * a.y + this.z * a.z;
  },
  lengthSq: function () {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  },
  length: function () {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  },
  lengthManhattan: function () {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  },
  normalize: function () {
    return this.divideScalar(this.length());
  },
  setLength: function (a) {
    var b = this.length();
    0 !== b && a !== b && this.multiplyScalar(a / b);
    return this;
  },
  lerp: function (a, b) {
    this.x += (a.x - this.x) * b;
    this.y += (a.y - this.y) * b;
    this.z += (a.z - this.z) * b;
    return this;
  },
  cross: function (a, b) {
    if (void 0 !== b)
      return console.warn('DEPRECATED: Vector3\'s .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.'), this.crossVectors(a, b);
    var c = this.x, d = this.y, e = this.z;
    this.x = d * a.z - e * a.y;
    this.y = e * a.x - c * a.z;
    this.z = c * a.y - d * a.x;
    return this;
  },
  crossVectors: function (a, b) {
    var c = a.x, d = a.y, e = a.z, f = b.x, g = b.y, h = b.z;
    this.x = d * h - e * g;
    this.y = e * f - c * h;
    this.z = c * g - d * f;
    return this;
  },
  projectOnVector: function () {
    var a, b;
    return function (c) {
      void 0 === a && (a = new THREE.Vector3());
      a.copy(c).normalize();
      b = this.dot(a);
      return this.copy(a).multiplyScalar(b);
    };
  }(),
  projectOnPlane: function () {
    var a;
    return function (b) {
      void 0 === a && (a = new THREE.Vector3());
      a.copy(this).projectOnVector(b);
      return this.sub(a);
    };
  }(),
  reflect: function () {
    var a;
    return function (b) {
      void 0 === a && (a = new THREE.Vector3());
      return this.sub(a.copy(b).multiplyScalar(2 * this.dot(b)));
    };
  }(),
  angleTo: function (a) {
    a = this.dot(a) / (this.length() * a.length());
    return Math.acos(THREE.Math.clamp(a, -1, 1));
  },
  distanceTo: function (a) {
    return Math.sqrt(this.distanceToSquared(a));
  },
  distanceToSquared: function (a) {
    var b = this.x - a.x, c = this.y - a.y;
    a = this.z - a.z;
    return b * b + c * c + a * a;
  },
  setEulerFromRotationMatrix: function (a, b) {
    console.error('REMOVED: Vector3\'s setEulerFromRotationMatrix has been removed in favor of Euler.setFromRotationMatrix(), please update your code.');
  },
  setEulerFromQuaternion: function (a, b) {
    console.error('REMOVED: Vector3\'s setEulerFromQuaternion: has been removed in favor of Euler.setFromQuaternion(), please update your code.');
  },
  getPositionFromMatrix: function (a) {
    console.warn('DEPRECATED: Vector3\'s .getPositionFromMatrix() has been renamed to .setFromMatrixPosition(). Please update your code.');
    return this.setFromMatrixPosition(a);
  },
  getScaleFromMatrix: function (a) {
    console.warn('DEPRECATED: Vector3\'s .getScaleFromMatrix() has been renamed to .setFromMatrixScale(). Please update your code.');
    return this.setFromMatrixScale(a);
  },
  getColumnFromMatrix: function (a, b) {
    console.warn('DEPRECATED: Vector3\'s .getColumnFromMatrix() has been renamed to .setFromMatrixColumn(). Please update your code.');
    return this.setFromMatrixColumn(a, b);
  },
  setFromMatrixPosition: function (a) {
    this.x = a.elements[12];
    this.y = a.elements[13];
    this.z = a.elements[14];
    return this;
  },
  setFromMatrixScale: function (a) {
    var b = this.set(a.elements[0], a.elements[1], a.elements[2]).length(), c = this.set(a.elements[4], a.elements[5], a.elements[6]).length();
    a = this.set(a.elements[8], a.elements[9], a.elements[10]).length();
    this.x = b;
    this.y = c;
    this.z = a;
    return this;
  },
  setFromMatrixColumn: function (a, b) {
    var c = 4 * a, d = b.elements;
    this.x = d[c];
    this.y = d[c + 1];
    this.z = d[c + 2];
    return this;
  },
  equals: function (a) {
    return a.x === this.x && a.y === this.y && a.z === this.z;
  },
  fromArray: function (a) {
    this.x = a[0];
    this.y = a[1];
    this.z = a[2];
    return this;
  },
  toArray: function () {
    return [
      this.x,
      this.y,
      this.z
    ];
  },
  clone: function () {
    return new THREE.Vector3(this.x, this.y, this.z);
  }
};
THREE.Vector4 = function (a, b, c, d) {
  this.x = a || 0;
  this.y = b || 0;
  this.z = c || 0;
  this.w = void 0 !== d ? d : 1;
};
THREE.Vector4.prototype = {
  constructor: THREE.Vector4,
  set: function (a, b, c, d) {
    this.x = a;
    this.y = b;
    this.z = c;
    this.w = d;
    return this;
  },
  setX: function (a) {
    this.x = a;
    return this;
  },
  setY: function (a) {
    this.y = a;
    return this;
  },
  setZ: function (a) {
    this.z = a;
    return this;
  },
  setW: function (a) {
    this.w = a;
    return this;
  },
  setComponent: function (a, b) {
    switch (a) {
    case 0:
      this.x = b;
      break;
    case 1:
      this.y = b;
      break;
    case 2:
      this.z = b;
      break;
    case 3:
      this.w = b;
      break;
    default:
      throw Error('index is out of range: ' + a);
    }
  },
  getComponent: function (a) {
    switch (a) {
    case 0:
      return this.x;
    case 1:
      return this.y;
    case 2:
      return this.z;
    case 3:
      return this.w;
    default:
      throw Error('index is out of range: ' + a);
    }
  },
  copy: function (a) {
    this.x = a.x;
    this.y = a.y;
    this.z = a.z;
    this.w = void 0 !== a.w ? a.w : 1;
    return this;
  },
  add: function (a, b) {
    if (void 0 !== b)
      return console.warn('DEPRECATED: Vector4\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.'), this.addVectors(a, b);
    this.x += a.x;
    this.y += a.y;
    this.z += a.z;
    this.w += a.w;
    return this;
  },
  addScalar: function (a) {
    this.x += a;
    this.y += a;
    this.z += a;
    this.w += a;
    return this;
  },
  addVectors: function (a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;
    return this;
  },
  sub: function (a, b) {
    if (void 0 !== b)
      return console.warn('DEPRECATED: Vector4\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.'), this.subVectors(a, b);
    this.x -= a.x;
    this.y -= a.y;
    this.z -= a.z;
    this.w -= a.w;
    return this;
  },
  subVectors: function (a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;
    return this;
  },
  multiplyScalar: function (a) {
    this.x *= a;
    this.y *= a;
    this.z *= a;
    this.w *= a;
    return this;
  },
  applyMatrix4: function (a) {
    var b = this.x, c = this.y, d = this.z, e = this.w;
    a = a.elements;
    this.x = a[0] * b + a[4] * c + a[8] * d + a[12] * e;
    this.y = a[1] * b + a[5] * c + a[9] * d + a[13] * e;
    this.z = a[2] * b + a[6] * c + a[10] * d + a[14] * e;
    this.w = a[3] * b + a[7] * c + a[11] * d + a[15] * e;
    return this;
  },
  divideScalar: function (a) {
    0 !== a ? (a = 1 / a, this.x *= a, this.y *= a, this.z *= a, this.w *= a) : (this.z = this.y = this.x = 0, this.w = 1);
    return this;
  },
  setAxisAngleFromQuaternion: function (a) {
    this.w = 2 * Math.acos(a.w);
    var b = Math.sqrt(1 - a.w * a.w);
    0.0001 > b ? (this.x = 1, this.z = this.y = 0) : (this.x = a.x / b, this.y = a.y / b, this.z = a.z / b);
    return this;
  },
  setAxisAngleFromRotationMatrix: function (a) {
    var b, c, d;
    a = a.elements;
    var e = a[0];
    d = a[4];
    var f = a[8], g = a[1], h = a[5], k = a[9];
    c = a[2];
    b = a[6];
    var l = a[10];
    if (0.01 > Math.abs(d - g) && 0.01 > Math.abs(f - c) && 0.01 > Math.abs(k - b)) {
      if (0.1 > Math.abs(d + g) && 0.1 > Math.abs(f + c) && 0.1 > Math.abs(k + b) && 0.1 > Math.abs(e + h + l - 3))
        return this.set(1, 0, 0, 0), this;
      a = Math.PI;
      e = (e + 1) / 2;
      h = (h + 1) / 2;
      l = (l + 1) / 2;
      d = (d + g) / 4;
      f = (f + c) / 4;
      k = (k + b) / 4;
      e > h && e > l ? 0.01 > e ? (b = 0, d = c = 0.707106781) : (b = Math.sqrt(e), c = d / b, d = f / b) : h > l ? 0.01 > h ? (b = 0.707106781, c = 0, d = 0.707106781) : (c = Math.sqrt(h), b = d / c, d = k / c) : 0.01 > l ? (c = b = 0.707106781, d = 0) : (d = Math.sqrt(l), b = f / d, c = k / d);
      this.set(b, c, d, a);
      return this;
    }
    a = Math.sqrt((b - k) * (b - k) + (f - c) * (f - c) + (g - d) * (g - d));
    0.001 > Math.abs(a) && (a = 1);
    this.x = (b - k) / a;
    this.y = (f - c) / a;
    this.z = (g - d) / a;
    this.w = Math.acos((e + h + l - 1) / 2);
    return this;
  },
  min: function (a) {
    this.x > a.x && (this.x = a.x);
    this.y > a.y && (this.y = a.y);
    this.z > a.z && (this.z = a.z);
    this.w > a.w && (this.w = a.w);
    return this;
  },
  max: function (a) {
    this.x < a.x && (this.x = a.x);
    this.y < a.y && (this.y = a.y);
    this.z < a.z && (this.z = a.z);
    this.w < a.w && (this.w = a.w);
    return this;
  },
  clamp: function (a, b) {
    this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x);
    this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y);
    this.z < a.z ? this.z = a.z : this.z > b.z && (this.z = b.z);
    this.w < a.w ? this.w = a.w : this.w > b.w && (this.w = b.w);
    return this;
  },
  clampScalar: function () {
    var a, b;
    return function (c, d) {
      void 0 === a && (a = new THREE.Vector4(), b = new THREE.Vector4());
      a.set(c, c, c, c);
      b.set(d, d, d, d);
      return this.clamp(a, b);
    };
  }(),
  floor: function () {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  },
  ceil: function () {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  },
  round: function () {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  },
  roundToZero: function () {
    this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
    this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w);
    return this;
  },
  negate: function () {
    return this.multiplyScalar(-1);
  },
  dot: function (a) {
    return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w;
  },
  lengthSq: function () {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  },
  length: function () {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  },
  lengthManhattan: function () {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  },
  normalize: function () {
    return this.divideScalar(this.length());
  },
  setLength: function (a) {
    var b = this.length();
    0 !== b && a !== b && this.multiplyScalar(a / b);
    return this;
  },
  lerp: function (a, b) {
    this.x += (a.x - this.x) * b;
    this.y += (a.y - this.y) * b;
    this.z += (a.z - this.z) * b;
    this.w += (a.w - this.w) * b;
    return this;
  },
  equals: function (a) {
    return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w;
  },
  fromArray: function (a) {
    this.x = a[0];
    this.y = a[1];
    this.z = a[2];
    this.w = a[3];
    return this;
  },
  toArray: function () {
    return [
      this.x,
      this.y,
      this.z,
      this.w
    ];
  },
  clone: function () {
    return new THREE.Vector4(this.x, this.y, this.z, this.w);
  }
};
THREE.Euler = function (a, b, c, d) {
  this._x = a || 0;
  this._y = b || 0;
  this._z = c || 0;
  this._order = d || THREE.Euler.DefaultOrder;
};
THREE.Euler.RotationOrders = 'XYZ YZX ZXY XZY YXZ ZYX'.split(' ');
THREE.Euler.DefaultOrder = 'XYZ';
THREE.Euler.prototype = {
  constructor: THREE.Euler,
  _x: 0,
  _y: 0,
  _z: 0,
  _order: THREE.Euler.DefaultOrder,
  _quaternion: void 0,
  _updateQuaternion: function () {
    void 0 !== this._quaternion && this._quaternion.setFromEuler(this, !1);
  },
  get x() {
    return this._x;
  },
  set x(a) {
    this._x = a;
    this._updateQuaternion();
  },
  get y() {
    return this._y;
  },
  set y(a) {
    this._y = a;
    this._updateQuaternion();
  },
  get z() {
    return this._z;
  },
  set z(a) {
    this._z = a;
    this._updateQuaternion();
  },
  get order() {
    return this._order;
  },
  set order(a) {
    this._order = a;
    this._updateQuaternion();
  },
  set: function (a, b, c, d) {
    this._x = a;
    this._y = b;
    this._z = c;
    this._order = d || this._order;
    this._updateQuaternion();
    return this;
  },
  copy: function (a) {
    this._x = a._x;
    this._y = a._y;
    this._z = a._z;
    this._order = a._order;
    this._updateQuaternion();
    return this;
  },
  setFromRotationMatrix: function (a, b) {
    function c(a) {
      return Math.min(Math.max(a, -1), 1);
    }
    var d = a.elements, e = d[0], f = d[4], g = d[8], h = d[1], k = d[5], l = d[9], n = d[2], s = d[6], d = d[10];
    b = b || this._order;
    'XYZ' === b ? (this._y = Math.asin(c(g)), 0.99999 > Math.abs(g) ? (this._x = Math.atan2(-l, d), this._z = Math.atan2(-f, e)) : (this._x = Math.atan2(s, k), this._z = 0)) : 'YXZ' === b ? (this._x = Math.asin(-c(l)), 0.99999 > Math.abs(l) ? (this._y = Math.atan2(g, d), this._z = Math.atan2(h, k)) : (this._y = Math.atan2(-n, e), this._z = 0)) : 'ZXY' === b ? (this._x = Math.asin(c(s)), 0.99999 > Math.abs(s) ? (this._y = Math.atan2(-n, d), this._z = Math.atan2(-f, k)) : (this._y = 0, this._z = Math.atan2(h, e))) : 'ZYX' === b ? (this._y = Math.asin(-c(n)), 0.99999 > Math.abs(n) ? (this._x = Math.atan2(s, d), this._z = Math.atan2(h, e)) : (this._x = 0, this._z = Math.atan2(-f, k))) : 'YZX' === b ? (this._z = Math.asin(c(h)), 0.99999 > Math.abs(h) ? (this._x = Math.atan2(-l, k), this._y = Math.atan2(-n, e)) : (this._x = 0, this._y = Math.atan2(g, d))) : 'XZY' === b ? (this._z = Math.asin(-c(f)), 0.99999 > Math.abs(f) ? (this._x = Math.atan2(s, k), this._y = Math.atan2(g, e)) : (this._x = Math.atan2(-l, d), this._y = 0)) : console.warn('WARNING: Euler.setFromRotationMatrix() given unsupported order: ' + b);
    this._order = b;
    this._updateQuaternion();
    return this;
  },
  setFromQuaternion: function (a, b, c) {
    function d(a) {
      return Math.min(Math.max(a, -1), 1);
    }
    var e = a.x * a.x, f = a.y * a.y, g = a.z * a.z, h = a.w * a.w;
    b = b || this._order;
    'XYZ' === b ? (this._x = Math.atan2(2 * (a.x * a.w - a.y * a.z), h - e - f + g), this._y = Math.asin(d(2 * (a.x * a.z + a.y * a.w))), this._z = Math.atan2(2 * (a.z * a.w - a.x * a.y), h + e - f - g)) : 'YXZ' === b ? (this._x = Math.asin(d(2 * (a.x * a.w - a.y * a.z))), this._y = Math.atan2(2 * (a.x * a.z + a.y * a.w), h - e - f + g), this._z = Math.atan2(2 * (a.x * a.y + a.z * a.w), h - e + f - g)) : 'ZXY' === b ? (this._x = Math.asin(d(2 * (a.x * a.w + a.y * a.z))), this._y = Math.atan2(2 * (a.y * a.w - a.z * a.x), h - e - f + g), this._z = Math.atan2(2 * (a.z * a.w - a.x * a.y), h - e + f - g)) : 'ZYX' === b ? (this._x = Math.atan2(2 * (a.x * a.w + a.z * a.y), h - e - f + g), this._y = Math.asin(d(2 * (a.y * a.w - a.x * a.z))), this._z = Math.atan2(2 * (a.x * a.y + a.z * a.w), h + e - f - g)) : 'YZX' === b ? (this._x = Math.atan2(2 * (a.x * a.w - a.z * a.y), h - e + f - g), this._y = Math.atan2(2 * (a.y * a.w - a.x * a.z), h + e - f - g), this._z = Math.asin(d(2 * (a.x * a.y + a.z * a.w)))) : 'XZY' === b ? (this._x = Math.atan2(2 * (a.x * a.w + a.y * a.z), h - e + f - g), this._y = Math.atan2(2 * (a.x * a.z + a.y * a.w), h + e - f - g), this._z = Math.asin(d(2 * (a.z * a.w - a.x * a.y)))) : console.warn('WARNING: Euler.setFromQuaternion() given unsupported order: ' + b);
    this._order = b;
    !1 !== c && this._updateQuaternion();
    return this;
  },
  reorder: function () {
    var a = new THREE.Quaternion();
    return function (b) {
      a.setFromEuler(this);
      this.setFromQuaternion(a, b);
    };
  }(),
  fromArray: function (a) {
    this._x = a[0];
    this._y = a[1];
    this._z = a[2];
    void 0 !== a[3] && (this._order = a[3]);
    this._updateQuaternion();
    return this;
  },
  toArray: function () {
    return [
      this._x,
      this._y,
      this._z,
      this._order
    ];
  },
  equals: function (a) {
    return a._x === this._x && a._y === this._y && a._z === this._z && a._order === this._order;
  },
  clone: function () {
    return new THREE.Euler(this._x, this._y, this._z, this._order);
  }
};
THREE.Line3 = function (a, b) {
  this.start = void 0 !== a ? a : new THREE.Vector3();
  this.end = void 0 !== b ? b : new THREE.Vector3();
};
THREE.Line3.prototype = {
  constructor: THREE.Line3,
  set: function (a, b) {
    this.start.copy(a);
    this.end.copy(b);
    return this;
  },
  copy: function (a) {
    this.start.copy(a.start);
    this.end.copy(a.end);
    return this;
  },
  center: function (a) {
    return (a || new THREE.Vector3()).addVectors(this.start, this.end).multiplyScalar(0.5);
  },
  delta: function (a) {
    return (a || new THREE.Vector3()).subVectors(this.end, this.start);
  },
  distanceSq: function () {
    return this.start.distanceToSquared(this.end);
  },
  distance: function () {
    return this.start.distanceTo(this.end);
  },
  at: function (a, b) {
    var c = b || new THREE.Vector3();
    return this.delta(c).multiplyScalar(a).add(this.start);
  },
  closestPointToPointParameter: function () {
    var a = new THREE.Vector3(), b = new THREE.Vector3();
    return function (c, d) {
      a.subVectors(c, this.start);
      b.subVectors(this.end, this.start);
      var e = b.dot(b), e = b.dot(a) / e;
      d && (e = THREE.Math.clamp(e, 0, 1));
      return e;
    };
  }(),
  closestPointToPoint: function (a, b, c) {
    a = this.closestPointToPointParameter(a, b);
    c = c || new THREE.Vector3();
    return this.delta(c).multiplyScalar(a).add(this.start);
  },
  applyMatrix4: function (a) {
    this.start.applyMatrix4(a);
    this.end.applyMatrix4(a);
    return this;
  },
  equals: function (a) {
    return a.start.equals(this.start) && a.end.equals(this.end);
  },
  clone: function () {
    return new THREE.Line3().copy(this);
  }
};
THREE.Box2 = function (a, b) {
  this.min = void 0 !== a ? a : new THREE.Vector2(Infinity, Infinity);
  this.max = void 0 !== b ? b : new THREE.Vector2(-Infinity, -Infinity);
};
THREE.Box2.prototype = {
  constructor: THREE.Box2,
  set: function (a, b) {
    this.min.copy(a);
    this.max.copy(b);
    return this;
  },
  setFromPoints: function (a) {
    if (0 < a.length) {
      var b = a[0];
      this.min.copy(b);
      this.max.copy(b);
      for (var c = 1, d = a.length; c < d; c++)
        b = a[c], b.x < this.min.x ? this.min.x = b.x : b.x > this.max.x && (this.max.x = b.x), b.y < this.min.y ? this.min.y = b.y : b.y > this.max.y && (this.max.y = b.y);
    } else
      this.makeEmpty();
    return this;
  },
  setFromCenterAndSize: function () {
    var a = new THREE.Vector2();
    return function (b, c) {
      var d = a.copy(c).multiplyScalar(0.5);
      this.min.copy(b).sub(d);
      this.max.copy(b).add(d);
      return this;
    };
  }(),
  copy: function (a) {
    this.min.copy(a.min);
    this.max.copy(a.max);
    return this;
  },
  makeEmpty: function () {
    this.min.x = this.min.y = Infinity;
    this.max.x = this.max.y = -Infinity;
    return this;
  },
  empty: function () {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  },
  center: function (a) {
    return (a || new THREE.Vector2()).addVectors(this.min, this.max).multiplyScalar(0.5);
  },
  size: function (a) {
    return (a || new THREE.Vector2()).subVectors(this.max, this.min);
  },
  expandByPoint: function (a) {
    this.min.min(a);
    this.max.max(a);
    return this;
  },
  expandByVector: function (a) {
    this.min.sub(a);
    this.max.add(a);
    return this;
  },
  expandByScalar: function (a) {
    this.min.addScalar(-a);
    this.max.addScalar(a);
    return this;
  },
  containsPoint: function (a) {
    return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y ? !1 : !0;
  },
  containsBox: function (a) {
    return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y ? !0 : !1;
  },
  getParameter: function (a, b) {
    return (b || new THREE.Vector2()).set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y));
  },
  isIntersectionBox: function (a) {
    return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y ? !1 : !0;
  },
  clampPoint: function (a, b) {
    return (b || new THREE.Vector2()).copy(a).clamp(this.min, this.max);
  },
  distanceToPoint: function () {
    var a = new THREE.Vector2();
    return function (b) {
      return a.copy(b).clamp(this.min, this.max).sub(b).length();
    };
  }(),
  intersect: function (a) {
    this.min.max(a.min);
    this.max.min(a.max);
    return this;
  },
  union: function (a) {
    this.min.min(a.min);
    this.max.max(a.max);
    return this;
  },
  translate: function (a) {
    this.min.add(a);
    this.max.add(a);
    return this;
  },
  equals: function (a) {
    return a.min.equals(this.min) && a.max.equals(this.max);
  },
  clone: function () {
    return new THREE.Box2().copy(this);
  }
};
THREE.Box3 = function (a, b) {
  this.min = void 0 !== a ? a : new THREE.Vector3(Infinity, Infinity, Infinity);
  this.max = void 0 !== b ? b : new THREE.Vector3(-Infinity, -Infinity, -Infinity);
};
THREE.Box3.prototype = {
  constructor: THREE.Box3,
  set: function (a, b) {
    this.min.copy(a);
    this.max.copy(b);
    return this;
  },
  addPoint: function (a) {
    a.x < this.min.x ? this.min.x = a.x : a.x > this.max.x && (this.max.x = a.x);
    a.y < this.min.y ? this.min.y = a.y : a.y > this.max.y && (this.max.y = a.y);
    a.z < this.min.z ? this.min.z = a.z : a.z > this.max.z && (this.max.z = a.z);
  },
  setFromPoints: function (a) {
    if (0 < a.length) {
      var b = a[0];
      this.min.copy(b);
      this.max.copy(b);
      for (var b = 1, c = a.length; b < c; b++)
        this.addPoint(a[b]);
    } else
      this.makeEmpty();
    return this;
  },
  setFromCenterAndSize: function () {
    var a = new THREE.Vector3();
    return function (b, c) {
      var d = a.copy(c).multiplyScalar(0.5);
      this.min.copy(b).sub(d);
      this.max.copy(b).add(d);
      return this;
    };
  }(),
  setFromObject: function () {
    var a = new THREE.Vector3();
    return function (b) {
      var c = this;
      b.updateMatrixWorld(!0);
      this.makeEmpty();
      b.traverse(function (b) {
        if (void 0 !== b.geometry && void 0 !== b.geometry.vertices)
          for (var e = b.geometry.vertices, f = 0, g = e.length; f < g; f++)
            a.copy(e[f]), a.applyMatrix4(b.matrixWorld), c.expandByPoint(a);
      });
      return this;
    };
  }(),
  copy: function (a) {
    this.min.copy(a.min);
    this.max.copy(a.max);
    return this;
  },
  makeEmpty: function () {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  },
  empty: function () {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  },
  center: function (a) {
    return (a || new THREE.Vector3()).addVectors(this.min, this.max).multiplyScalar(0.5);
  },
  size: function (a) {
    return (a || new THREE.Vector3()).subVectors(this.max, this.min);
  },
  expandByPoint: function (a) {
    this.min.min(a);
    this.max.max(a);
    return this;
  },
  expandByVector: function (a) {
    this.min.sub(a);
    this.max.add(a);
    return this;
  },
  expandByScalar: function (a) {
    this.min.addScalar(-a);
    this.max.addScalar(a);
    return this;
  },
  containsPoint: function (a) {
    return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y || a.z < this.min.z || a.z > this.max.z ? !1 : !0;
  },
  containsBox: function (a) {
    return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z && a.max.z <= this.max.z ? !0 : !1;
  },
  getParameter: function (a, b) {
    return (b || new THREE.Vector3()).set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z - this.min.z) / (this.max.z - this.min.z));
  },
  isIntersectionBox: function (a) {
    return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max.z < this.min.z || a.min.z > this.max.z ? !1 : !0;
  },
  clampPoint: function (a, b) {
    return (b || new THREE.Vector3()).copy(a).clamp(this.min, this.max);
  },
  distanceToPoint: function () {
    var a = new THREE.Vector3();
    return function (b) {
      return a.copy(b).clamp(this.min, this.max).sub(b).length();
    };
  }(),
  getBoundingSphere: function () {
    var a = new THREE.Vector3();
    return function (b) {
      b = b || new THREE.Sphere();
      b.center = this.center();
      b.radius = 0.5 * this.size(a).length();
      return b;
    };
  }(),
  intersect: function (a) {
    this.min.max(a.min);
    this.max.min(a.max);
    return this;
  },
  union: function (a) {
    this.min.min(a.min);
    this.max.max(a.max);
    return this;
  },
  applyMatrix4: function () {
    var a = [
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3()
      ];
    return function (b) {
      a[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(b);
      a[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(b);
      a[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(b);
      a[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(b);
      a[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(b);
      a[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(b);
      a[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(b);
      a[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(b);
      this.makeEmpty();
      this.setFromPoints(a);
      return this;
    };
  }(),
  translate: function (a) {
    this.min.add(a);
    this.max.add(a);
    return this;
  },
  equals: function (a) {
    return a.min.equals(this.min) && a.max.equals(this.max);
  },
  clone: function () {
    return new THREE.Box3().copy(this);
  }
};
THREE.Matrix3 = function (a, b, c, d, e, f, g, h, k) {
  this.elements = new Float32Array(9);
  this.set(void 0 !== a ? a : 1, b || 0, c || 0, d || 0, void 0 !== e ? e : 1, f || 0, g || 0, h || 0, void 0 !== k ? k : 1);
};
THREE.Matrix3.prototype = {
  constructor: THREE.Matrix3,
  set: function (a, b, c, d, e, f, g, h, k) {
    var l = this.elements;
    l[0] = a;
    l[3] = b;
    l[6] = c;
    l[1] = d;
    l[4] = e;
    l[7] = f;
    l[2] = g;
    l[5] = h;
    l[8] = k;
    return this;
  },
  identity: function () {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  },
  copy: function (a) {
    a = a.elements;
    this.set(a[0], a[3], a[6], a[1], a[4], a[7], a[2], a[5], a[8]);
    return this;
  },
  multiplyVector3: function (a) {
    console.warn('DEPRECATED: Matrix3\'s .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
    return a.applyMatrix3(this);
  },
  multiplyVector3Array: function () {
    var a = new THREE.Vector3();
    return function (b) {
      for (var c = 0, d = b.length; c < d; c += 3)
        a.x = b[c], a.y = b[c + 1], a.z = b[c + 2], a.applyMatrix3(this), b[c] = a.x, b[c + 1] = a.y, b[c + 2] = a.z;
      return b;
    };
  }(),
  multiplyScalar: function (a) {
    var b = this.elements;
    b[0] *= a;
    b[3] *= a;
    b[6] *= a;
    b[1] *= a;
    b[4] *= a;
    b[7] *= a;
    b[2] *= a;
    b[5] *= a;
    b[8] *= a;
    return this;
  },
  determinant: function () {
    var a = this.elements, b = a[0], c = a[1], d = a[2], e = a[3], f = a[4], g = a[5], h = a[6], k = a[7], a = a[8];
    return b * f * a - b * g * k - c * e * a + c * g * h + d * e * k - d * f * h;
  },
  getInverse: function (a, b) {
    var c = a.elements, d = this.elements;
    d[0] = c[10] * c[5] - c[6] * c[9];
    d[1] = -c[10] * c[1] + c[2] * c[9];
    d[2] = c[6] * c[1] - c[2] * c[5];
    d[3] = -c[10] * c[4] + c[6] * c[8];
    d[4] = c[10] * c[0] - c[2] * c[8];
    d[5] = -c[6] * c[0] + c[2] * c[4];
    d[6] = c[9] * c[4] - c[5] * c[8];
    d[7] = -c[9] * c[0] + c[1] * c[8];
    d[8] = c[5] * c[0] - c[1] * c[4];
    c = c[0] * d[0] + c[1] * d[3] + c[2] * d[6];
    if (0 === c) {
      if (b)
        throw Error('Matrix3.getInverse(): can\'t invert matrix, determinant is 0');
      console.warn('Matrix3.getInverse(): can\'t invert matrix, determinant is 0');
      this.identity();
      return this;
    }
    this.multiplyScalar(1 / c);
    return this;
  },
  transpose: function () {
    var a, b = this.elements;
    a = b[1];
    b[1] = b[3];
    b[3] = a;
    a = b[2];
    b[2] = b[6];
    b[6] = a;
    a = b[5];
    b[5] = b[7];
    b[7] = a;
    return this;
  },
  getNormalMatrix: function (a) {
    this.getInverse(a).transpose();
    return this;
  },
  transposeIntoArray: function (a) {
    var b = this.elements;
    a[0] = b[0];
    a[1] = b[3];
    a[2] = b[6];
    a[3] = b[1];
    a[4] = b[4];
    a[5] = b[7];
    a[6] = b[2];
    a[7] = b[5];
    a[8] = b[8];
    return this;
  },
  fromArray: function (a) {
    this.elements.set(a);
    return this;
  },
  toArray: function () {
    var a = this.elements;
    return [
      a[0],
      a[1],
      a[2],
      a[3],
      a[4],
      a[5],
      a[6],
      a[7],
      a[8]
    ];
  },
  clone: function () {
    var a = this.elements;
    return new THREE.Matrix3(a[0], a[3], a[6], a[1], a[4], a[7], a[2], a[5], a[8]);
  }
};
THREE.Matrix4 = function (a, b, c, d, e, f, g, h, k, l, n, s, r, q, u, p) {
  var v = this.elements = new Float32Array(16);
  v[0] = void 0 !== a ? a : 1;
  v[4] = b || 0;
  v[8] = c || 0;
  v[12] = d || 0;
  v[1] = e || 0;
  v[5] = void 0 !== f ? f : 1;
  v[9] = g || 0;
  v[13] = h || 0;
  v[2] = k || 0;
  v[6] = l || 0;
  v[10] = void 0 !== n ? n : 1;
  v[14] = s || 0;
  v[3] = r || 0;
  v[7] = q || 0;
  v[11] = u || 0;
  v[15] = void 0 !== p ? p : 1;
};
THREE.Matrix4.prototype = {
  constructor: THREE.Matrix4,
  set: function (a, b, c, d, e, f, g, h, k, l, n, s, r, q, u, p) {
    var v = this.elements;
    v[0] = a;
    v[4] = b;
    v[8] = c;
    v[12] = d;
    v[1] = e;
    v[5] = f;
    v[9] = g;
    v[13] = h;
    v[2] = k;
    v[6] = l;
    v[10] = n;
    v[14] = s;
    v[3] = r;
    v[7] = q;
    v[11] = u;
    v[15] = p;
    return this;
  },
  identity: function () {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  },
  copy: function (a) {
    this.elements.set(a.elements);
    return this;
  },
  extractPosition: function (a) {
    console.warn('DEPRECATED: Matrix4\'s .extractPosition() has been renamed to .copyPosition().');
    return this.copyPosition(a);
  },
  copyPosition: function (a) {
    var b = this.elements;
    a = a.elements;
    b[12] = a[12];
    b[13] = a[13];
    b[14] = a[14];
    return this;
  },
  extractRotation: function () {
    var a = new THREE.Vector3();
    return function (b) {
      var c = this.elements;
      b = b.elements;
      var d = 1 / a.set(b[0], b[1], b[2]).length(), e = 1 / a.set(b[4], b[5], b[6]).length(), f = 1 / a.set(b[8], b[9], b[10]).length();
      c[0] = b[0] * d;
      c[1] = b[1] * d;
      c[2] = b[2] * d;
      c[4] = b[4] * e;
      c[5] = b[5] * e;
      c[6] = b[6] * e;
      c[8] = b[8] * f;
      c[9] = b[9] * f;
      c[10] = b[10] * f;
      return this;
    };
  }(),
  makeRotationFromEuler: function (a) {
    !1 === a instanceof THREE.Euler && console.error('ERROR: Matrix\'s .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.');
    var b = this.elements, c = a.x, d = a.y, e = a.z, f = Math.cos(c), c = Math.sin(c), g = Math.cos(d), d = Math.sin(d), h = Math.cos(e), e = Math.sin(e);
    if ('XYZ' === a.order) {
      a = f * h;
      var k = f * e, l = c * h, n = c * e;
      b[0] = g * h;
      b[4] = -g * e;
      b[8] = d;
      b[1] = k + l * d;
      b[5] = a - n * d;
      b[9] = -c * g;
      b[2] = n - a * d;
      b[6] = l + k * d;
      b[10] = f * g;
    } else
      'YXZ' === a.order ? (a = g * h, k = g * e, l = d * h, n = d * e, b[0] = a + n * c, b[4] = l * c - k, b[8] = f * d, b[1] = f * e, b[5] = f * h, b[9] = -c, b[2] = k * c - l, b[6] = n + a * c, b[10] = f * g) : 'ZXY' === a.order ? (a = g * h, k = g * e, l = d * h, n = d * e, b[0] = a - n * c, b[4] = -f * e, b[8] = l + k * c, b[1] = k + l * c, b[5] = f * h, b[9] = n - a * c, b[2] = -f * d, b[6] = c, b[10] = f * g) : 'ZYX' === a.order ? (a = f * h, k = f * e, l = c * h, n = c * e, b[0] = g * h, b[4] = l * d - k, b[8] = a * d + n, b[1] = g * e, b[5] = n * d + a, b[9] = k * d - l, b[2] = -d, b[6] = c * g, b[10] = f * g) : 'YZX' === a.order ? (a = f * g, k = f * d, l = c * g, n = c * d, b[0] = g * h, b[4] = n - a * e, b[8] = l * e + k, b[1] = e, b[5] = f * h, b[9] = -c * h, b[2] = -d * h, b[6] = k * e + l, b[10] = a - n * e) : 'XZY' === a.order && (a = f * g, k = f * d, l = c * g, n = c * d, b[0] = g * h, b[4] = -e, b[8] = d * h, b[1] = a * e + n, b[5] = f * h, b[9] = k * e - l, b[2] = l * e - k, b[6] = c * h, b[10] = n * e + a);
    b[3] = 0;
    b[7] = 0;
    b[11] = 0;
    b[12] = 0;
    b[13] = 0;
    b[14] = 0;
    b[15] = 1;
    return this;
  },
  setRotationFromQuaternion: function (a) {
    console.warn('DEPRECATED: Matrix4\'s .setRotationFromQuaternion() has been deprecated in favor of makeRotationFromQuaternion.  Please update your code.');
    return this.makeRotationFromQuaternion(a);
  },
  makeRotationFromQuaternion: function (a) {
    var b = this.elements, c = a.x, d = a.y, e = a.z, f = a.w, g = c + c, h = d + d, k = e + e;
    a = c * g;
    var l = c * h, c = c * k, n = d * h, d = d * k, e = e * k, g = f * g, h = f * h, f = f * k;
    b[0] = 1 - (n + e);
    b[4] = l - f;
    b[8] = c + h;
    b[1] = l + f;
    b[5] = 1 - (a + e);
    b[9] = d - g;
    b[2] = c - h;
    b[6] = d + g;
    b[10] = 1 - (a + n);
    b[3] = 0;
    b[7] = 0;
    b[11] = 0;
    b[12] = 0;
    b[13] = 0;
    b[14] = 0;
    b[15] = 1;
    return this;
  },
  lookAt: function () {
    var a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Vector3();
    return function (d, e, f) {
      var g = this.elements;
      c.subVectors(d, e).normalize();
      0 === c.length() && (c.z = 1);
      a.crossVectors(f, c).normalize();
      0 === a.length() && (c.x += 0.0001, a.crossVectors(f, c).normalize());
      b.crossVectors(c, a);
      g[0] = a.x;
      g[4] = b.x;
      g[8] = c.x;
      g[1] = a.y;
      g[5] = b.y;
      g[9] = c.y;
      g[2] = a.z;
      g[6] = b.z;
      g[10] = c.z;
      return this;
    };
  }(),
  multiply: function (a, b) {
    return void 0 !== b ? (console.warn('DEPRECATED: Matrix4\'s .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.'), this.multiplyMatrices(a, b)) : this.multiplyMatrices(this, a);
  },
  multiplyMatrices: function (a, b) {
    var c = a.elements, d = b.elements, e = this.elements, f = c[0], g = c[4], h = c[8], k = c[12], l = c[1], n = c[5], s = c[9], r = c[13], q = c[2], u = c[6], p = c[10], v = c[14], w = c[3], t = c[7], x = c[11], c = c[15], z = d[0], B = d[4], E = d[8], H = d[12], D = d[1], G = d[5], I = d[9], O = d[13], K = d[2], y = d[6], F = d[10], C = d[14], A = d[3], L = d[7], Q = d[11], d = d[15];
    e[0] = f * z + g * D + h * K + k * A;
    e[4] = f * B + g * G + h * y + k * L;
    e[8] = f * E + g * I + h * F + k * Q;
    e[12] = f * H + g * O + h * C + k * d;
    e[1] = l * z + n * D + s * K + r * A;
    e[5] = l * B + n * G + s * y + r * L;
    e[9] = l * E + n * I + s * F + r * Q;
    e[13] = l * H + n * O + s * C + r * d;
    e[2] = q * z + u * D + p * K + v * A;
    e[6] = q * B + u * G + p * y + v * L;
    e[10] = q * E + u * I + p * F + v * Q;
    e[14] = q * H + u * O + p * C + v * d;
    e[3] = w * z + t * D + x * K + c * A;
    e[7] = w * B + t * G + x * y + c * L;
    e[11] = w * E + t * I + x * F + c * Q;
    e[15] = w * H + t * O + x * C + c * d;
    return this;
  },
  multiplyToArray: function (a, b, c) {
    var d = this.elements;
    this.multiplyMatrices(a, b);
    c[0] = d[0];
    c[1] = d[1];
    c[2] = d[2];
    c[3] = d[3];
    c[4] = d[4];
    c[5] = d[5];
    c[6] = d[6];
    c[7] = d[7];
    c[8] = d[8];
    c[9] = d[9];
    c[10] = d[10];
    c[11] = d[11];
    c[12] = d[12];
    c[13] = d[13];
    c[14] = d[14];
    c[15] = d[15];
    return this;
  },
  multiplyScalar: function (a) {
    var b = this.elements;
    b[0] *= a;
    b[4] *= a;
    b[8] *= a;
    b[12] *= a;
    b[1] *= a;
    b[5] *= a;
    b[9] *= a;
    b[13] *= a;
    b[2] *= a;
    b[6] *= a;
    b[10] *= a;
    b[14] *= a;
    b[3] *= a;
    b[7] *= a;
    b[11] *= a;
    b[15] *= a;
    return this;
  },
  multiplyVector3: function (a) {
    console.warn('DEPRECATED: Matrix4\'s .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.');
    return a.applyProjection(this);
  },
  multiplyVector4: function (a) {
    console.warn('DEPRECATED: Matrix4\'s .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
    return a.applyMatrix4(this);
  },
  multiplyVector3Array: function () {
    var a = new THREE.Vector3();
    return function (b) {
      for (var c = 0, d = b.length; c < d; c += 3)
        a.x = b[c], a.y = b[c + 1], a.z = b[c + 2], a.applyProjection(this), b[c] = a.x, b[c + 1] = a.y, b[c + 2] = a.z;
      return b;
    };
  }(),
  rotateAxis: function (a) {
    console.warn('DEPRECATED: Matrix4\'s .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
    a.transformDirection(this);
  },
  crossVector: function (a) {
    console.warn('DEPRECATED: Matrix4\'s .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
    return a.applyMatrix4(this);
  },
  determinant: function () {
    var a = this.elements, b = a[0], c = a[4], d = a[8], e = a[12], f = a[1], g = a[5], h = a[9], k = a[13], l = a[2], n = a[6], s = a[10], r = a[14];
    return a[3] * (+e * h * n - d * k * n - e * g * s + c * k * s + d * g * r - c * h * r) + a[7] * (+b * h * r - b * k * s + e * f * s - d * f * r + d * k * l - e * h * l) + a[11] * (+b * k * n - b * g * r - e * f * n + c * f * r + e * g * l - c * k * l) + a[15] * (-d * g * l - b * h * n + b * g * s + d * f * n - c * f * s + c * h * l);
  },
  transpose: function () {
    var a = this.elements, b;
    b = a[1];
    a[1] = a[4];
    a[4] = b;
    b = a[2];
    a[2] = a[8];
    a[8] = b;
    b = a[6];
    a[6] = a[9];
    a[9] = b;
    b = a[3];
    a[3] = a[12];
    a[12] = b;
    b = a[7];
    a[7] = a[13];
    a[13] = b;
    b = a[11];
    a[11] = a[14];
    a[14] = b;
    return this;
  },
  flattenToArray: function (a) {
    var b = this.elements;
    a[0] = b[0];
    a[1] = b[1];
    a[2] = b[2];
    a[3] = b[3];
    a[4] = b[4];
    a[5] = b[5];
    a[6] = b[6];
    a[7] = b[7];
    a[8] = b[8];
    a[9] = b[9];
    a[10] = b[10];
    a[11] = b[11];
    a[12] = b[12];
    a[13] = b[13];
    a[14] = b[14];
    a[15] = b[15];
    return a;
  },
  flattenToArrayOffset: function (a, b) {
    var c = this.elements;
    a[b] = c[0];
    a[b + 1] = c[1];
    a[b + 2] = c[2];
    a[b + 3] = c[3];
    a[b + 4] = c[4];
    a[b + 5] = c[5];
    a[b + 6] = c[6];
    a[b + 7] = c[7];
    a[b + 8] = c[8];
    a[b + 9] = c[9];
    a[b + 10] = c[10];
    a[b + 11] = c[11];
    a[b + 12] = c[12];
    a[b + 13] = c[13];
    a[b + 14] = c[14];
    a[b + 15] = c[15];
    return a;
  },
  getPosition: function () {
    var a = new THREE.Vector3();
    return function () {
      console.warn('DEPRECATED: Matrix4\'s .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
      var b = this.elements;
      return a.set(b[12], b[13], b[14]);
    };
  }(),
  setPosition: function (a) {
    var b = this.elements;
    b[12] = a.x;
    b[13] = a.y;
    b[14] = a.z;
    return this;
  },
  getInverse: function (a, b) {
    var c = this.elements, d = a.elements, e = d[0], f = d[4], g = d[8], h = d[12], k = d[1], l = d[5], n = d[9], s = d[13], r = d[2], q = d[6], u = d[10], p = d[14], v = d[3], w = d[7], t = d[11], d = d[15];
    c[0] = n * p * w - s * u * w + s * q * t - l * p * t - n * q * d + l * u * d;
    c[4] = h * u * w - g * p * w - h * q * t + f * p * t + g * q * d - f * u * d;
    c[8] = g * s * w - h * n * w + h * l * t - f * s * t - g * l * d + f * n * d;
    c[12] = h * n * q - g * s * q - h * l * u + f * s * u + g * l * p - f * n * p;
    c[1] = s * u * v - n * p * v - s * r * t + k * p * t + n * r * d - k * u * d;
    c[5] = g * p * v - h * u * v + h * r * t - e * p * t - g * r * d + e * u * d;
    c[9] = h * n * v - g * s * v - h * k * t + e * s * t + g * k * d - e * n * d;
    c[13] = g * s * r - h * n * r + h * k * u - e * s * u - g * k * p + e * n * p;
    c[2] = l * p * v - s * q * v + s * r * w - k * p * w - l * r * d + k * q * d;
    c[6] = h * q * v - f * p * v - h * r * w + e * p * w + f * r * d - e * q * d;
    c[10] = f * s * v - h * l * v + h * k * w - e * s * w - f * k * d + e * l * d;
    c[14] = h * l * r - f * s * r - h * k * q + e * s * q + f * k * p - e * l * p;
    c[3] = n * q * v - l * u * v - n * r * w + k * u * w + l * r * t - k * q * t;
    c[7] = f * u * v - g * q * v + g * r * w - e * u * w - f * r * t + e * q * t;
    c[11] = g * l * v - f * n * v - g * k * w + e * n * w + f * k * t - e * l * t;
    c[15] = f * n * r - g * l * r + g * k * q - e * n * q - f * k * u + e * l * u;
    c = e * c[0] + k * c[4] + r * c[8] + v * c[12];
    if (0 == c) {
      if (b)
        throw Error('Matrix4.getInverse(): can\'t invert matrix, determinant is 0');
      console.warn('Matrix4.getInverse(): can\'t invert matrix, determinant is 0');
      this.identity();
      return this;
    }
    this.multiplyScalar(1 / c);
    return this;
  },
  translate: function (a) {
    console.warn('DEPRECATED: Matrix4\'s .translate() has been removed.');
  },
  rotateX: function (a) {
    console.warn('DEPRECATED: Matrix4\'s .rotateX() has been removed.');
  },
  rotateY: function (a) {
    console.warn('DEPRECATED: Matrix4\'s .rotateY() has been removed.');
  },
  rotateZ: function (a) {
    console.warn('DEPRECATED: Matrix4\'s .rotateZ() has been removed.');
  },
  rotateByAxis: function (a, b) {
    console.warn('DEPRECATED: Matrix4\'s .rotateByAxis() has been removed.');
  },
  scale: function (a) {
    var b = this.elements, c = a.x, d = a.y;
    a = a.z;
    b[0] *= c;
    b[4] *= d;
    b[8] *= a;
    b[1] *= c;
    b[5] *= d;
    b[9] *= a;
    b[2] *= c;
    b[6] *= d;
    b[10] *= a;
    b[3] *= c;
    b[7] *= d;
    b[11] *= a;
    return this;
  },
  getMaxScaleOnAxis: function () {
    var a = this.elements;
    return Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], Math.max(a[4] * a[4] + a[5] * a[5] + a[6] * a[6], a[8] * a[8] + a[9] * a[9] + a[10] * a[10])));
  },
  makeTranslation: function (a, b, c) {
    this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1);
    return this;
  },
  makeRotationX: function (a) {
    var b = Math.cos(a);
    a = Math.sin(a);
    this.set(1, 0, 0, 0, 0, b, -a, 0, 0, a, b, 0, 0, 0, 0, 1);
    return this;
  },
  makeRotationY: function (a) {
    var b = Math.cos(a);
    a = Math.sin(a);
    this.set(b, 0, a, 0, 0, 1, 0, 0, -a, 0, b, 0, 0, 0, 0, 1);
    return this;
  },
  makeRotationZ: function (a) {
    var b = Math.cos(a);
    a = Math.sin(a);
    this.set(b, -a, 0, 0, a, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  },
  makeRotationAxis: function (a, b) {
    var c = Math.cos(b), d = Math.sin(b), e = 1 - c, f = a.x, g = a.y, h = a.z, k = e * f, l = e * g;
    this.set(k * f + c, k * g - d * h, k * h + d * g, 0, k * g + d * h, l * g + c, l * h - d * f, 0, k * h - d * g, l * h + d * f, e * h * h + c, 0, 0, 0, 0, 1);
    return this;
  },
  makeScale: function (a, b, c) {
    this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1);
    return this;
  },
  compose: function (a, b, c) {
    this.makeRotationFromQuaternion(b);
    this.scale(c);
    this.setPosition(a);
    return this;
  },
  decompose: function () {
    var a = new THREE.Vector3(), b = new THREE.Matrix4();
    return function (c, d, e) {
      var f = this.elements, g = a.set(f[0], f[1], f[2]).length(), h = a.set(f[4], f[5], f[6]).length(), k = a.set(f[8], f[9], f[10]).length();
      0 > this.determinant() && (g = -g);
      c.x = f[12];
      c.y = f[13];
      c.z = f[14];
      b.elements.set(this.elements);
      c = 1 / g;
      var f = 1 / h, l = 1 / k;
      b.elements[0] *= c;
      b.elements[1] *= c;
      b.elements[2] *= c;
      b.elements[4] *= f;
      b.elements[5] *= f;
      b.elements[6] *= f;
      b.elements[8] *= l;
      b.elements[9] *= l;
      b.elements[10] *= l;
      d.setFromRotationMatrix(b);
      e.x = g;
      e.y = h;
      e.z = k;
      return this;
    };
  }(),
  makeFrustum: function (a, b, c, d, e, f) {
    var g = this.elements;
    g[0] = 2 * e / (b - a);
    g[4] = 0;
    g[8] = (b + a) / (b - a);
    g[12] = 0;
    g[1] = 0;
    g[5] = 2 * e / (d - c);
    g[9] = (d + c) / (d - c);
    g[13] = 0;
    g[2] = 0;
    g[6] = 0;
    g[10] = -(f + e) / (f - e);
    g[14] = -2 * f * e / (f - e);
    g[3] = 0;
    g[7] = 0;
    g[11] = -1;
    g[15] = 0;
    return this;
  },
  makePerspective: function (a, b, c, d) {
    a = c * Math.tan(THREE.Math.degToRad(0.5 * a));
    var e = -a;
    return this.makeFrustum(e * b, a * b, e, a, c, d);
  },
  makeOrthographic: function (a, b, c, d, e, f) {
    var g = this.elements, h = b - a, k = c - d, l = f - e;
    g[0] = 2 / h;
    g[4] = 0;
    g[8] = 0;
    g[12] = -((b + a) / h);
    g[1] = 0;
    g[5] = 2 / k;
    g[9] = 0;
    g[13] = -((c + d) / k);
    g[2] = 0;
    g[6] = 0;
    g[10] = -2 / l;
    g[14] = -((f + e) / l);
    g[3] = 0;
    g[7] = 0;
    g[11] = 0;
    g[15] = 1;
    return this;
  },
  fromArray: function (a) {
    this.elements.set(a);
    return this;
  },
  toArray: function () {
    var a = this.elements;
    return [
      a[0],
      a[1],
      a[2],
      a[3],
      a[4],
      a[5],
      a[6],
      a[7],
      a[8],
      a[9],
      a[10],
      a[11],
      a[12],
      a[13],
      a[14],
      a[15]
    ];
  },
  clone: function () {
    var a = this.elements;
    return new THREE.Matrix4(a[0], a[4], a[8], a[12], a[1], a[5], a[9], a[13], a[2], a[6], a[10], a[14], a[3], a[7], a[11], a[15]);
  }
};
THREE.Ray = function (a, b) {
  this.origin = void 0 !== a ? a : new THREE.Vector3();
  this.direction = void 0 !== b ? b : new THREE.Vector3();
};
THREE.Ray.prototype = {
  constructor: THREE.Ray,
  set: function (a, b) {
    this.origin.copy(a);
    this.direction.copy(b);
    return this;
  },
  copy: function (a) {
    this.origin.copy(a.origin);
    this.direction.copy(a.direction);
    return this;
  },
  at: function (a, b) {
    return (b || new THREE.Vector3()).copy(this.direction).multiplyScalar(a).add(this.origin);
  },
  recast: function () {
    var a = new THREE.Vector3();
    return function (b) {
      this.origin.copy(this.at(b, a));
      return this;
    };
  }(),
  closestPointToPoint: function (a, b) {
    var c = b || new THREE.Vector3();
    c.subVectors(a, this.origin);
    var d = c.dot(this.direction);
    return 0 > d ? c.copy(this.origin) : c.copy(this.direction).multiplyScalar(d).add(this.origin);
  },
  distanceToPoint: function () {
    var a = new THREE.Vector3();
    return function (b) {
      var c = a.subVectors(b, this.origin).dot(this.direction);
      if (0 > c)
        return this.origin.distanceTo(b);
      a.copy(this.direction).multiplyScalar(c).add(this.origin);
      return a.distanceTo(b);
    };
  }(),
  distanceSqToSegment: function (a, b, c, d) {
    var e = a.clone().add(b).multiplyScalar(0.5), f = b.clone().sub(a).normalize(), g = 0.5 * a.distanceTo(b), h = this.origin.clone().sub(e);
    a = -this.direction.dot(f);
    b = h.dot(this.direction);
    var k = -h.dot(f), l = h.lengthSq(), n = Math.abs(1 - a * a), s, r;
    0 <= n ? (h = a * k - b, s = a * b - k, r = g * n, 0 <= h ? s >= -r ? s <= r ? (g = 1 / n, h *= g, s *= g, a = h * (h + a * s + 2 * b) + s * (a * h + s + 2 * k) + l) : (s = g, h = Math.max(0, -(a * s + b)), a = -h * h + s * (s + 2 * k) + l) : (s = -g, h = Math.max(0, -(a * s + b)), a = -h * h + s * (s + 2 * k) + l) : s <= -r ? (h = Math.max(0, -(-a * g + b)), s = 0 < h ? -g : Math.min(Math.max(-g, -k), g), a = -h * h + s * (s + 2 * k) + l) : s <= r ? (h = 0, s = Math.min(Math.max(-g, -k), g), a = s * (s + 2 * k) + l) : (h = Math.max(0, -(a * g + b)), s = 0 < h ? g : Math.min(Math.max(-g, -k), g), a = -h * h + s * (s + 2 * k) + l)) : (s = 0 < a ? -g : g, h = Math.max(0, -(a * s + b)), a = -h * h + s * (s + 2 * k) + l);
    c && c.copy(this.direction.clone().multiplyScalar(h).add(this.origin));
    d && d.copy(f.clone().multiplyScalar(s).add(e));
    return a;
  },
  isIntersectionSphere: function (a) {
    return this.distanceToPoint(a.center) <= a.radius;
  },
  isIntersectionPlane: function (a) {
    var b = a.distanceToPoint(this.origin);
    return 0 === b || 0 > a.normal.dot(this.direction) * b ? !0 : !1;
  },
  distanceToPlane: function (a) {
    var b = a.normal.dot(this.direction);
    if (0 == b)
      return 0 == a.distanceToPoint(this.origin) ? 0 : null;
    a = -(this.origin.dot(a.normal) + a.constant) / b;
    return 0 <= a ? a : null;
  },
  intersectPlane: function (a, b) {
    var c = this.distanceToPlane(a);
    return null === c ? null : this.at(c, b);
  },
  isIntersectionBox: function () {
    var a = new THREE.Vector3();
    return function (b) {
      return null !== this.intersectBox(b, a);
    };
  }(),
  intersectBox: function (a, b) {
    var c, d, e, f, g;
    d = 1 / this.direction.x;
    f = 1 / this.direction.y;
    g = 1 / this.direction.z;
    var h = this.origin;
    0 <= d ? (c = (a.min.x - h.x) * d, d *= a.max.x - h.x) : (c = (a.max.x - h.x) * d, d *= a.min.x - h.x);
    0 <= f ? (e = (a.min.y - h.y) * f, f *= a.max.y - h.y) : (e = (a.max.y - h.y) * f, f *= a.min.y - h.y);
    if (c > f || e > d)
      return null;
    if (e > c || c !== c)
      c = e;
    if (f < d || d !== d)
      d = f;
    0 <= g ? (e = (a.min.z - h.z) * g, g *= a.max.z - h.z) : (e = (a.max.z - h.z) * g, g *= a.min.z - h.z);
    if (c > g || e > d)
      return null;
    if (e > c || c !== c)
      c = e;
    if (g < d || d !== d)
      d = g;
    return 0 > d ? null : this.at(0 <= c ? c : d, b);
  },
  intersectTriangle: function () {
    var a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Vector3(), d = new THREE.Vector3();
    return function (e, f, g, h, k) {
      b.subVectors(f, e);
      c.subVectors(g, e);
      d.crossVectors(b, c);
      f = this.direction.dot(d);
      if (0 < f) {
        if (h)
          return null;
        h = 1;
      } else if (0 > f)
        h = -1, f = -f;
      else
        return null;
      a.subVectors(this.origin, e);
      e = h * this.direction.dot(c.crossVectors(a, c));
      if (0 > e)
        return null;
      g = h * this.direction.dot(b.cross(a));
      if (0 > g || e + g > f)
        return null;
      e = -h * a.dot(d);
      return 0 > e ? null : this.at(e / f, k);
    };
  }(),
  applyMatrix4: function (a) {
    this.direction.add(this.origin).applyMatrix4(a);
    this.origin.applyMatrix4(a);
    this.direction.sub(this.origin);
    this.direction.normalize();
    return this;
  },
  equals: function (a) {
    return a.origin.equals(this.origin) && a.direction.equals(this.direction);
  },
  clone: function () {
    return new THREE.Ray().copy(this);
  }
};
THREE.Sphere = function (a, b) {
  this.center = void 0 !== a ? a : new THREE.Vector3();
  this.radius = void 0 !== b ? b : 0;
};
THREE.Sphere.prototype = {
  constructor: THREE.Sphere,
  set: function (a, b) {
    this.center.copy(a);
    this.radius = b;
    return this;
  },
  setFromPoints: function () {
    var a = new THREE.Box3();
    return function (b, c) {
      var d = this.center;
      void 0 !== c ? d.copy(c) : a.setFromPoints(b).center(d);
      for (var e = 0, f = 0, g = b.length; f < g; f++)
        e = Math.max(e, d.distanceToSquared(b[f]));
      this.radius = Math.sqrt(e);
      return this;
    };
  }(),
  copy: function (a) {
    this.center.copy(a.center);
    this.radius = a.radius;
    return this;
  },
  empty: function () {
    return 0 >= this.radius;
  },
  containsPoint: function (a) {
    return a.distanceToSquared(this.center) <= this.radius * this.radius;
  },
  distanceToPoint: function (a) {
    return a.distanceTo(this.center) - this.radius;
  },
  intersectsSphere: function (a) {
    var b = this.radius + a.radius;
    return a.center.distanceToSquared(this.center) <= b * b;
  },
  clampPoint: function (a, b) {
    var c = this.center.distanceToSquared(a), d = b || new THREE.Vector3();
    d.copy(a);
    c > this.radius * this.radius && (d.sub(this.center).normalize(), d.multiplyScalar(this.radius).add(this.center));
    return d;
  },
  getBoundingBox: function (a) {
    a = a || new THREE.Box3();
    a.set(this.center, this.center);
    a.expandByScalar(this.radius);
    return a;
  },
  applyMatrix4: function (a) {
    this.center.applyMatrix4(a);
    this.radius *= a.getMaxScaleOnAxis();
    return this;
  },
  translate: function (a) {
    this.center.add(a);
    return this;
  },
  equals: function (a) {
    return a.center.equals(this.center) && a.radius === this.radius;
  },
  clone: function () {
    return new THREE.Sphere().copy(this);
  }
};
THREE.Frustum = function (a, b, c, d, e, f) {
  this.planes = [
    void 0 !== a ? a : new THREE.Plane(),
    void 0 !== b ? b : new THREE.Plane(),
    void 0 !== c ? c : new THREE.Plane(),
    void 0 !== d ? d : new THREE.Plane(),
    void 0 !== e ? e : new THREE.Plane(),
    void 0 !== f ? f : new THREE.Plane()
  ];
};
THREE.Frustum.prototype = {
  constructor: THREE.Frustum,
  set: function (a, b, c, d, e, f) {
    var g = this.planes;
    g[0].copy(a);
    g[1].copy(b);
    g[2].copy(c);
    g[3].copy(d);
    g[4].copy(e);
    g[5].copy(f);
    return this;
  },
  copy: function (a) {
    for (var b = this.planes, c = 0; 6 > c; c++)
      b[c].copy(a.planes[c]);
    return this;
  },
  setFromMatrix: function (a) {
    var b = this.planes, c = a.elements;
    a = c[0];
    var d = c[1], e = c[2], f = c[3], g = c[4], h = c[5], k = c[6], l = c[7], n = c[8], s = c[9], r = c[10], q = c[11], u = c[12], p = c[13], v = c[14], c = c[15];
    b[0].setComponents(f - a, l - g, q - n, c - u).normalize();
    b[1].setComponents(f + a, l + g, q + n, c + u).normalize();
    b[2].setComponents(f + d, l + h, q + s, c + p).normalize();
    b[3].setComponents(f - d, l - h, q - s, c - p).normalize();
    b[4].setComponents(f - e, l - k, q - r, c - v).normalize();
    b[5].setComponents(f + e, l + k, q + r, c + v).normalize();
    return this;
  },
  intersectsObject: function () {
    var a = new THREE.Sphere();
    return function (b) {
      var c = b.geometry;
      null === c.boundingSphere && c.computeBoundingSphere();
      a.copy(c.boundingSphere);
      a.applyMatrix4(b.matrixWorld);
      return this.intersectsSphere(a);
    };
  }(),
  intersectsSphere: function (a) {
    var b = this.planes, c = a.center;
    a = -a.radius;
    for (var d = 0; 6 > d; d++)
      if (b[d].distanceToPoint(c) < a)
        return !1;
    return !0;
  },
  intersectsBox: function () {
    var a = new THREE.Vector3(), b = new THREE.Vector3();
    return function (c) {
      for (var d = this.planes, e = 0; 6 > e; e++) {
        var f = d[e];
        a.x = 0 < f.normal.x ? c.min.x : c.max.x;
        b.x = 0 < f.normal.x ? c.max.x : c.min.x;
        a.y = 0 < f.normal.y ? c.min.y : c.max.y;
        b.y = 0 < f.normal.y ? c.max.y : c.min.y;
        a.z = 0 < f.normal.z ? c.min.z : c.max.z;
        b.z = 0 < f.normal.z ? c.max.z : c.min.z;
        var g = f.distanceToPoint(a), f = f.distanceToPoint(b);
        if (0 > g && 0 > f)
          return !1;
      }
      return !0;
    };
  }(),
  containsPoint: function (a) {
    for (var b = this.planes, c = 0; 6 > c; c++)
      if (0 > b[c].distanceToPoint(a))
        return !1;
    return !0;
  },
  clone: function () {
    return new THREE.Frustum().copy(this);
  }
};
THREE.Plane = function (a, b) {
  this.normal = void 0 !== a ? a : new THREE.Vector3(1, 0, 0);
  this.constant = void 0 !== b ? b : 0;
};
THREE.Plane.prototype = {
  constructor: THREE.Plane,
  set: function (a, b) {
    this.normal.copy(a);
    this.constant = b;
    return this;
  },
  setComponents: function (a, b, c, d) {
    this.normal.set(a, b, c);
    this.constant = d;
    return this;
  },
  setFromNormalAndCoplanarPoint: function (a, b) {
    this.normal.copy(a);
    this.constant = -b.dot(this.normal);
    return this;
  },
  setFromCoplanarPoints: function () {
    var a = new THREE.Vector3(), b = new THREE.Vector3();
    return function (c, d, e) {
      d = a.subVectors(e, d).cross(b.subVectors(c, d)).normalize();
      this.setFromNormalAndCoplanarPoint(d, c);
      return this;
    };
  }(),
  copy: function (a) {
    this.normal.copy(a.normal);
    this.constant = a.constant;
    return this;
  },
  normalize: function () {
    var a = 1 / this.normal.length();
    this.normal.multiplyScalar(a);
    this.constant *= a;
    return this;
  },
  negate: function () {
    this.constant *= -1;
    this.normal.negate();
    return this;
  },
  distanceToPoint: function (a) {
    return this.normal.dot(a) + this.constant;
  },
  distanceToSphere: function (a) {
    return this.distanceToPoint(a.center) - a.radius;
  },
  projectPoint: function (a, b) {
    return this.orthoPoint(a, b).sub(a).negate();
  },
  orthoPoint: function (a, b) {
    var c = this.distanceToPoint(a);
    return (b || new THREE.Vector3()).copy(this.normal).multiplyScalar(c);
  },
  isIntersectionLine: function (a) {
    var b = this.distanceToPoint(a.start);
    a = this.distanceToPoint(a.end);
    return 0 > b && 0 < a || 0 > a && 0 < b;
  },
  intersectLine: function () {
    var a = new THREE.Vector3();
    return function (b, c) {
      var d = c || new THREE.Vector3(), e = b.delta(a), f = this.normal.dot(e);
      if (0 == f) {
        if (0 == this.distanceToPoint(b.start))
          return d.copy(b.start);
      } else
        return f = -(b.start.dot(this.normal) + this.constant) / f, 0 > f || 1 < f ? void 0 : d.copy(e).multiplyScalar(f).add(b.start);
    };
  }(),
  coplanarPoint: function (a) {
    return (a || new THREE.Vector3()).copy(this.normal).multiplyScalar(-this.constant);
  },
  applyMatrix4: function () {
    var a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Matrix3();
    return function (d, e) {
      var f = e || c.getNormalMatrix(d), f = a.copy(this.normal).applyMatrix3(f), g = this.coplanarPoint(b);
      g.applyMatrix4(d);
      this.setFromNormalAndCoplanarPoint(f, g);
      return this;
    };
  }(),
  translate: function (a) {
    this.constant -= a.dot(this.normal);
    return this;
  },
  equals: function (a) {
    return a.normal.equals(this.normal) && a.constant == this.constant;
  },
  clone: function () {
    return new THREE.Plane().copy(this);
  }
};
THREE.Math = {
  PI2: 2 * Math.PI,
  generateUUID: function () {
    var a = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''), b = Array(36), c = 0, d;
    return function () {
      for (var e = 0; 36 > e; e++)
        8 == e || 13 == e || 18 == e || 23 == e ? b[e] = '-' : 14 == e ? b[e] = '4' : (2 >= c && (c = 33554432 + 16777216 * Math.random() | 0), d = c & 15, c >>= 4, b[e] = a[19 == e ? d & 3 | 8 : d]);
      return b.join('');
    };
  }(),
  clamp: function (a, b, c) {
    return a < b ? b : a > c ? c : a;
  },
  clampBottom: function (a, b) {
    return a < b ? b : a;
  },
  mapLinear: function (a, b, c, d, e) {
    return d + (a - b) * (e - d) / (c - b);
  },
  smoothstep: function (a, b, c) {
    if (a <= b)
      return 0;
    if (a >= c)
      return 1;
    a = (a - b) / (c - b);
    return a * a * (3 - 2 * a);
  },
  smootherstep: function (a, b, c) {
    if (a <= b)
      return 0;
    if (a >= c)
      return 1;
    a = (a - b) / (c - b);
    return a * a * a * (a * (6 * a - 15) + 10);
  },
  random16: function () {
    return (65280 * Math.random() + 255 * Math.random()) / 65535;
  },
  randInt: function (a, b) {
    return a + Math.floor(Math.random() * (b - a + 1));
  },
  randFloat: function (a, b) {
    return a + Math.random() * (b - a);
  },
  randFloatSpread: function (a) {
    return a * (0.5 - Math.random());
  },
  sign: function (a) {
    return 0 > a ? -1 : 0 < a ? 1 : 0;
  },
  degToRad: function () {
    var a = Math.PI / 180;
    return function (b) {
      return b * a;
    };
  }(),
  radToDeg: function () {
    var a = 180 / Math.PI;
    return function (b) {
      return b * a;
    };
  }(),
  isPowerOfTwo: function (a) {
    return 0 === (a & a - 1) && 0 !== a;
  }
};
THREE.Spline = function (a) {
  function b(a, b, c, d, e, f, g) {
    a = 0.5 * (c - a);
    d = 0.5 * (d - b);
    return (2 * (b - c) + a + d) * g + (-3 * (b - c) - 2 * a - d) * f + a * e + b;
  }
  this.points = a;
  var c = [], d = {
      x: 0,
      y: 0,
      z: 0
    }, e, f, g, h, k, l, n, s, r;
  this.initFromArray = function (a) {
    this.points = [];
    for (var b = 0; b < a.length; b++)
      this.points[b] = {
        x: a[b][0],
        y: a[b][1],
        z: a[b][2]
      };
  };
  this.getPoint = function (a) {
    e = (this.points.length - 1) * a;
    f = Math.floor(e);
    g = e - f;
    c[0] = 0 === f ? f : f - 1;
    c[1] = f;
    c[2] = f > this.points.length - 2 ? this.points.length - 1 : f + 1;
    c[3] = f > this.points.length - 3 ? this.points.length - 1 : f + 2;
    l = this.points[c[0]];
    n = this.points[c[1]];
    s = this.points[c[2]];
    r = this.points[c[3]];
    h = g * g;
    k = g * h;
    d.x = b(l.x, n.x, s.x, r.x, g, h, k);
    d.y = b(l.y, n.y, s.y, r.y, g, h, k);
    d.z = b(l.z, n.z, s.z, r.z, g, h, k);
    return d;
  };
  this.getControlPointsArray = function () {
    var a, b, c = this.points.length, d = [];
    for (a = 0; a < c; a++)
      b = this.points[a], d[a] = [
        b.x,
        b.y,
        b.z
      ];
    return d;
  };
  this.getLength = function (a) {
    var b, c, d, e = b = b = 0, f = new THREE.Vector3(), g = new THREE.Vector3(), h = [], k = 0;
    h[0] = 0;
    a || (a = 100);
    c = this.points.length * a;
    f.copy(this.points[0]);
    for (a = 1; a < c; a++)
      b = a / c, d = this.getPoint(b), g.copy(d), k += g.distanceTo(f), f.copy(d), b *= this.points.length - 1, b = Math.floor(b), b != e && (h[b] = k, e = b);
    h[h.length] = k;
    return {
      chunks: h,
      total: k
    };
  };
  this.reparametrizeByArcLength = function (a) {
    var b, c, d, e, f, g, h = [], k = new THREE.Vector3(), l = this.getLength();
    h.push(k.copy(this.points[0]).clone());
    for (b = 1; b < this.points.length; b++) {
      c = l.chunks[b] - l.chunks[b - 1];
      g = Math.ceil(a * c / l.total);
      e = (b - 1) / (this.points.length - 1);
      f = b / (this.points.length - 1);
      for (c = 1; c < g - 1; c++)
        d = e + 1 / g * c * (f - e), d = this.getPoint(d), h.push(k.copy(d).clone());
      h.push(k.copy(this.points[b]).clone());
    }
    this.points = h;
  };
};
THREE.Triangle = function (a, b, c) {
  this.a = void 0 !== a ? a : new THREE.Vector3();
  this.b = void 0 !== b ? b : new THREE.Vector3();
  this.c = void 0 !== c ? c : new THREE.Vector3();
};
THREE.Triangle.normal = function () {
  var a = new THREE.Vector3();
  return function (b, c, d, e) {
    e = e || new THREE.Vector3();
    e.subVectors(d, c);
    a.subVectors(b, c);
    e.cross(a);
    b = e.lengthSq();
    return 0 < b ? e.multiplyScalar(1 / Math.sqrt(b)) : e.set(0, 0, 0);
  };
}();
THREE.Triangle.barycoordFromPoint = function () {
  var a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Vector3();
  return function (d, e, f, g, h) {
    a.subVectors(g, e);
    b.subVectors(f, e);
    c.subVectors(d, e);
    d = a.dot(a);
    e = a.dot(b);
    f = a.dot(c);
    var k = b.dot(b);
    g = b.dot(c);
    var l = d * k - e * e;
    h = h || new THREE.Vector3();
    if (0 == l)
      return h.set(-2, -1, -1);
    l = 1 / l;
    k = (k * f - e * g) * l;
    d = (d * g - e * f) * l;
    return h.set(1 - k - d, d, k);
  };
}();
THREE.Triangle.containsPoint = function () {
  var a = new THREE.Vector3();
  return function (b, c, d, e) {
    b = THREE.Triangle.barycoordFromPoint(b, c, d, e, a);
    return 0 <= b.x && 0 <= b.y && 1 >= b.x + b.y;
  };
}();
THREE.Triangle.prototype = {
  constructor: THREE.Triangle,
  set: function (a, b, c) {
    this.a.copy(a);
    this.b.copy(b);
    this.c.copy(c);
    return this;
  },
  setFromPointsAndIndices: function (a, b, c, d) {
    this.a.copy(a[b]);
    this.b.copy(a[c]);
    this.c.copy(a[d]);
    return this;
  },
  copy: function (a) {
    this.a.copy(a.a);
    this.b.copy(a.b);
    this.c.copy(a.c);
    return this;
  },
  area: function () {
    var a = new THREE.Vector3(), b = new THREE.Vector3();
    return function () {
      a.subVectors(this.c, this.b);
      b.subVectors(this.a, this.b);
      return 0.5 * a.cross(b).length();
    };
  }(),
  midpoint: function (a) {
    return (a || new THREE.Vector3()).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  },
  normal: function (a) {
    return THREE.Triangle.normal(this.a, this.b, this.c, a);
  },
  plane: function (a) {
    return (a || new THREE.Plane()).setFromCoplanarPoints(this.a, this.b, this.c);
  },
  barycoordFromPoint: function (a, b) {
    return THREE.Triangle.barycoordFromPoint(a, this.a, this.b, this.c, b);
  },
  containsPoint: function (a) {
    return THREE.Triangle.containsPoint(a, this.a, this.b, this.c);
  },
  equals: function (a) {
    return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c);
  },
  clone: function () {
    return new THREE.Triangle().copy(this);
  }
};
THREE.Vertex = function (a) {
  console.warn('THREE.Vertex has been DEPRECATED. Use THREE.Vector3 instead.');
  return a;
};
THREE.UV = function (a, b) {
  console.warn('THREE.UV has been DEPRECATED. Use THREE.Vector2 instead.');
  return new THREE.Vector2(a, b);
};
THREE.Clock = function (a) {
  this.autoStart = void 0 !== a ? a : !0;
  this.elapsedTime = this.oldTime = this.startTime = 0;
  this.running = !1;
};
THREE.Clock.prototype = {
  constructor: THREE.Clock,
  start: function () {
    this.oldTime = this.startTime = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now();
    this.running = !0;
  },
  stop: function () {
    this.getElapsedTime();
    this.running = !1;
  },
  getElapsedTime: function () {
    this.getDelta();
    return this.elapsedTime;
  },
  getDelta: function () {
    var a = 0;
    this.autoStart && !this.running && this.start();
    if (this.running) {
      var b = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now(), a = 0.001 * (b - this.oldTime);
      this.oldTime = b;
      this.elapsedTime += a;
    }
    return a;
  }
};
THREE.EventDispatcher = function () {
};
THREE.EventDispatcher.prototype = {
  constructor: THREE.EventDispatcher,
  apply: function (a) {
    a.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
    a.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
    a.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
    a.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;
  },
  addEventListener: function (a, b) {
    void 0 === this._listeners && (this._listeners = {});
    var c = this._listeners;
    void 0 === c[a] && (c[a] = []);
    -1 === c[a].indexOf(b) && c[a].push(b);
  },
  hasEventListener: function (a, b) {
    if (void 0 === this._listeners)
      return !1;
    var c = this._listeners;
    return void 0 !== c[a] && -1 !== c[a].indexOf(b) ? !0 : !1;
  },
  removeEventListener: function (a, b) {
    if (void 0 !== this._listeners) {
      var c = this._listeners[a];
      if (void 0 !== c) {
        var d = c.indexOf(b);
        -1 !== d && c.splice(d, 1);
      }
    }
  },
  dispatchEvent: function () {
    var a = [];
    return function (b) {
      if (void 0 !== this._listeners) {
        var c = this._listeners[b.type];
        if (void 0 !== c) {
          b.target = this;
          for (var d = c.length, e = 0; e < d; e++)
            a[e] = c[e];
          for (e = 0; e < d; e++)
            a[e].call(this, b);
        }
      }
    };
  }()
};
(function (a) {
  a.Raycaster = function (b, c, d, e) {
    this.ray = new a.Ray(b, c);
    this.near = d || 0;
    this.far = e || Infinity;
  };
  var b = new a.Sphere(), c = new a.Ray();
  new a.Plane();
  new a.Vector3();
  var d = new a.Vector3(), e = new a.Matrix4(), f = function (a, b) {
      return a.distance - b.distance;
    }, g = new a.Vector3(), h = new a.Vector3(), k = new a.Vector3(), l = function (f, n, q) {
      if (f instanceof a.Sprite) {
        d.setFromMatrixPosition(f.matrixWorld);
        var u = n.ray.distanceToPoint(d);
        if (u > f.scale.x)
          return q;
        q.push({
          distance: u,
          point: f.position,
          face: null,
          object: f
        });
      } else if (f instanceof a.LOD)
        d.setFromMatrixPosition(f.matrixWorld), u = n.ray.origin.distanceTo(d), l(f.getObjectForDistance(u), n, q);
      else if (f instanceof a.Mesh) {
        var p = f.geometry;
        null === p.boundingSphere && p.computeBoundingSphere();
        b.copy(p.boundingSphere);
        b.applyMatrix4(f.matrixWorld);
        if (!1 === n.ray.isIntersectionSphere(b))
          return q;
        e.getInverse(f.matrixWorld);
        c.copy(n.ray).applyMatrix4(e);
        if (null !== p.boundingBox && !1 === c.isIntersectionBox(p.boundingBox))
          return q;
        if (p instanceof a.BufferGeometry) {
          var v = f.material;
          if (void 0 === v)
            return q;
          var w = p.attributes, t, x, z = n.precision;
          if (void 0 !== w.index)
            for (var B = p.offsets, E = w.index.array, H = w.position.array, D = 0, G = B.length; D < G; ++D)
              for (var w = B[D].start, I = B[D].index, p = w, O = w + B[D].count; p < O; p += 3) {
                w = I + E[p];
                t = I + E[p + 1];
                x = I + E[p + 2];
                g.set(H[3 * w], H[3 * w + 1], H[3 * w + 2]);
                h.set(H[3 * t], H[3 * t + 1], H[3 * t + 2]);
                k.set(H[3 * x], H[3 * x + 1], H[3 * x + 2]);
                var K = v.side === a.BackSide ? c.intersectTriangle(k, h, g, !0) : c.intersectTriangle(g, h, k, v.side !== a.DoubleSide);
                null !== K && (K.applyMatrix4(f.matrixWorld), u = n.ray.origin.distanceTo(K), u < z || u < n.near || u > n.far || q.push({
                  distance: u,
                  point: K,
                  indices: [
                    w,
                    t,
                    x
                  ],
                  face: null,
                  faceIndex: null,
                  object: f
                }));
              }
          else
            for (H = w.position.array, p = 0, O = w.position.array.length; p < O; p += 3)
              w = p, t = p + 1, x = p + 2, g.set(H[3 * w], H[3 * w + 1], H[3 * w + 2]), h.set(H[3 * t], H[3 * t + 1], H[3 * t + 2]), k.set(H[3 * x], H[3 * x + 1], H[3 * x + 2]), K = v.side === a.BackSide ? c.intersectTriangle(k, h, g, !0) : c.intersectTriangle(g, h, k, v.side !== a.DoubleSide), null !== K && (K.applyMatrix4(f.matrixWorld), u = n.ray.origin.distanceTo(K), u < z || u < n.near || u > n.far || q.push({
                distance: u,
                point: K,
                indices: [
                  w,
                  t,
                  x
                ],
                face: null,
                faceIndex: null,
                object: f
              }));
        } else if (p instanceof a.Geometry)
          for (E = f.material instanceof a.MeshFaceMaterial, H = !0 === E ? f.material.materials : null, z = n.precision, B = p.vertices, D = 0, G = p.faces.length; D < G; D++)
            if (I = p.faces[D], v = !0 === E ? H[I.materialIndex] : f.material, void 0 !== v) {
              w = B[I.a];
              t = B[I.b];
              x = B[I.c];
              if (!0 === v.morphTargets) {
                u = p.morphTargets;
                K = f.morphTargetInfluences;
                g.set(0, 0, 0);
                h.set(0, 0, 0);
                k.set(0, 0, 0);
                for (var O = 0, y = u.length; O < y; O++) {
                  var F = K[O];
                  if (0 !== F) {
                    var C = u[O].vertices;
                    g.x += (C[I.a].x - w.x) * F;
                    g.y += (C[I.a].y - w.y) * F;
                    g.z += (C[I.a].z - w.z) * F;
                    h.x += (C[I.b].x - t.x) * F;
                    h.y += (C[I.b].y - t.y) * F;
                    h.z += (C[I.b].z - t.z) * F;
                    k.x += (C[I.c].x - x.x) * F;
                    k.y += (C[I.c].y - x.y) * F;
                    k.z += (C[I.c].z - x.z) * F;
                  }
                }
                g.add(w);
                h.add(t);
                k.add(x);
                w = g;
                t = h;
                x = k;
              }
              K = v.side === a.BackSide ? c.intersectTriangle(x, t, w, !0) : c.intersectTriangle(w, t, x, v.side !== a.DoubleSide);
              null !== K && (K.applyMatrix4(f.matrixWorld), u = n.ray.origin.distanceTo(K), u < z || u < n.near || u > n.far || q.push({
                distance: u,
                point: K,
                face: I,
                faceIndex: D,
                object: f
              }));
            }
      } else if (f instanceof a.Line) {
        z = n.linePrecision;
        v = z * z;
        p = f.geometry;
        null === p.boundingSphere && p.computeBoundingSphere();
        b.copy(p.boundingSphere);
        b.applyMatrix4(f.matrixWorld);
        if (!1 === n.ray.isIntersectionSphere(b))
          return q;
        e.getInverse(f.matrixWorld);
        c.copy(n.ray).applyMatrix4(e);
        if (p instanceof a.Geometry)
          for (B = p.vertices, z = B.length, w = new a.Vector3(), t = new a.Vector3(), x = f.type === a.LineStrip ? 1 : 2, p = 0; p < z - 1; p += x)
            c.distanceSqToSegment(B[p], B[p + 1], t, w) > v || (u = c.origin.distanceTo(t), u < n.near || u > n.far || q.push({
              distance: u,
              point: w.clone().applyMatrix4(f.matrixWorld),
              face: null,
              faceIndex: null,
              object: f
            }));
      }
    }, n = function (a, b, c) {
      a = a.getDescendants();
      for (var d = 0, e = a.length; d < e; d++)
        l(a[d], b, c);
    };
  a.Raycaster.prototype.precision = 0.0001;
  a.Raycaster.prototype.linePrecision = 1;
  a.Raycaster.prototype.set = function (a, b) {
    this.ray.set(a, b);
  };
  a.Raycaster.prototype.intersectObject = function (a, b) {
    var c = [];
    !0 === b && n(a, this, c);
    l(a, this, c);
    c.sort(f);
    return c;
  };
  a.Raycaster.prototype.intersectObjects = function (a, b) {
    for (var c = [], d = 0, e = a.length; d < e; d++)
      l(a[d], this, c), !0 === b && n(a[d], this, c);
    c.sort(f);
    return c;
  };
}(THREE));
THREE.Object3D = function () {
  this.id = THREE.Object3DIdCount++;
  this.uuid = THREE.Math.generateUUID();
  this.name = '';
  this.parent = void 0;
  this.children = [];
  this.up = new THREE.Vector3(0, 1, 0);
  this.position = new THREE.Vector3();
  this._rotation = new THREE.Euler();
  this._quaternion = new THREE.Quaternion();
  this.scale = new THREE.Vector3(1, 1, 1);
  this._rotation._quaternion = this.quaternion;
  this._quaternion._euler = this.rotation;
  this.renderDepth = null;
  this.rotationAutoUpdate = !0;
  this.matrix = new THREE.Matrix4();
  this.matrixWorld = new THREE.Matrix4();
  this.visible = this.matrixWorldNeedsUpdate = this.matrixAutoUpdate = !0;
  this.receiveShadow = this.castShadow = !1;
  this.frustumCulled = !0;
  this.userData = {};
};
THREE.Object3D.prototype = {
  constructor: THREE.Object3D,
  get rotation() {
    return this._rotation;
  },
  set rotation(a) {
    this._rotation = a;
    this._rotation._quaternion = this._quaternion;
    this._quaternion._euler = this._rotation;
    this._rotation._updateQuaternion();
  },
  get quaternion() {
    return this._quaternion;
  },
  set quaternion(a) {
    this._quaternion = a;
    this._quaternion._euler = this._rotation;
    this._rotation._quaternion = this._quaternion;
    this._quaternion._updateEuler();
  },
  get eulerOrder() {
    console.warn('DEPRECATED: Object3D\'s .eulerOrder has been moved to Object3D\'s .rotation.order.');
    return this.rotation.order;
  },
  set eulerOrder(a) {
    console.warn('DEPRECATED: Object3D\'s .eulerOrder has been moved to Object3D\'s .rotation.order.');
    this.rotation.order = a;
  },
  get useQuaternion() {
    console.warn('DEPRECATED: Object3D\'s .useQuaternion has been removed. The library now uses quaternions by default.');
  },
  set useQuaternion(a) {
    console.warn('DEPRECATED: Object3D\'s .useQuaternion has been removed. The library now uses quaternions by default.');
  },
  applyMatrix: function (a) {
    this.matrix.multiplyMatrices(a, this.matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  },
  setRotationFromAxisAngle: function (a, b) {
    this.quaternion.setFromAxisAngle(a, b);
  },
  setRotationFromEuler: function (a) {
    this.quaternion.setFromEuler(a, !0);
  },
  setRotationFromMatrix: function (a) {
    this.quaternion.setFromRotationMatrix(a);
  },
  setRotationFromQuaternion: function (a) {
    this.quaternion.copy(a);
  },
  rotateOnAxis: function () {
    var a = new THREE.Quaternion();
    return function (b, c) {
      a.setFromAxisAngle(b, c);
      this.quaternion.multiply(a);
      return this;
    };
  }(),
  rotateX: function () {
    var a = new THREE.Vector3(1, 0, 0);
    return function (b) {
      return this.rotateOnAxis(a, b);
    };
  }(),
  rotateY: function () {
    var a = new THREE.Vector3(0, 1, 0);
    return function (b) {
      return this.rotateOnAxis(a, b);
    };
  }(),
  rotateZ: function () {
    var a = new THREE.Vector3(0, 0, 1);
    return function (b) {
      return this.rotateOnAxis(a, b);
    };
  }(),
  translateOnAxis: function () {
    var a = new THREE.Vector3();
    return function (b, c) {
      a.copy(b);
      a.applyQuaternion(this.quaternion);
      this.position.add(a.multiplyScalar(c));
      return this;
    };
  }(),
  translate: function (a, b) {
    console.warn('DEPRECATED: Object3D\'s .translate() has been removed. Use .translateOnAxis( axis, distance ) instead. Note args have been changed.');
    return this.translateOnAxis(b, a);
  },
  translateX: function () {
    var a = new THREE.Vector3(1, 0, 0);
    return function (b) {
      return this.translateOnAxis(a, b);
    };
  }(),
  translateY: function () {
    var a = new THREE.Vector3(0, 1, 0);
    return function (b) {
      return this.translateOnAxis(a, b);
    };
  }(),
  translateZ: function () {
    var a = new THREE.Vector3(0, 0, 1);
    return function (b) {
      return this.translateOnAxis(a, b);
    };
  }(),
  localToWorld: function (a) {
    return a.applyMatrix4(this.matrixWorld);
  },
  worldToLocal: function () {
    var a = new THREE.Matrix4();
    return function (b) {
      return b.applyMatrix4(a.getInverse(this.matrixWorld));
    };
  }(),
  lookAt: function () {
    var a = new THREE.Matrix4();
    return function (b) {
      a.lookAt(b, this.position, this.up);
      this.quaternion.setFromRotationMatrix(a);
    };
  }(),
  add: function (a) {
    if (a === this)
      console.warn('THREE.Object3D.add: An object can\'t be added as a child of itself.');
    else if (a instanceof THREE.Object3D) {
      void 0 !== a.parent && a.parent.remove(a);
      a.parent = this;
      a.dispatchEvent({ type: 'added' });
      this.children.push(a);
      for (var b = this; void 0 !== b.parent;)
        b = b.parent;
      void 0 !== b && b instanceof THREE.Scene && b.__addObject(a);
    }
  },
  remove: function (a) {
    var b = this.children.indexOf(a);
    if (-1 !== b) {
      a.parent = void 0;
      a.dispatchEvent({ type: 'removed' });
      this.children.splice(b, 1);
      for (b = this; void 0 !== b.parent;)
        b = b.parent;
      void 0 !== b && b instanceof THREE.Scene && b.__removeObject(a);
    }
  },
  traverse: function (a) {
    a(this);
    for (var b = 0, c = this.children.length; b < c; b++)
      this.children[b].traverse(a);
  },
  getObjectById: function (a, b) {
    for (var c = 0, d = this.children.length; c < d; c++) {
      var e = this.children[c];
      if (e.id === a || !0 === b && (e = e.getObjectById(a, b), void 0 !== e))
        return e;
    }
  },
  getObjectByName: function (a, b) {
    for (var c = 0, d = this.children.length; c < d; c++) {
      var e = this.children[c];
      if (e.name === a || !0 === b && (e = e.getObjectByName(a, b), void 0 !== e))
        return e;
    }
  },
  getChildByName: function (a, b) {
    console.warn('DEPRECATED: Object3D\'s .getChildByName() has been renamed to .getObjectByName().');
    return this.getObjectByName(a, b);
  },
  getDescendants: function (a) {
    void 0 === a && (a = []);
    Array.prototype.push.apply(a, this.children);
    for (var b = 0, c = this.children.length; b < c; b++)
      this.children[b].getDescendants(a);
    return a;
  },
  updateMatrix: function () {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = !0;
  },
  updateMatrixWorld: function (a) {
    !0 === this.matrixAutoUpdate && this.updateMatrix();
    if (!0 === this.matrixWorldNeedsUpdate || !0 === a)
      void 0 === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, a = !0;
    for (var b = 0, c = this.children.length; b < c; b++)
      this.children[b].updateMatrixWorld(a);
  },
  clone: function (a, b) {
    void 0 === a && (a = new THREE.Object3D());
    void 0 === b && (b = !0);
    a.name = this.name;
    a.up.copy(this.up);
    a.position.copy(this.position);
    a.quaternion.copy(this.quaternion);
    a.scale.copy(this.scale);
    a.renderDepth = this.renderDepth;
    a.rotationAutoUpdate = this.rotationAutoUpdate;
    a.matrix.copy(this.matrix);
    a.matrixWorld.copy(this.matrixWorld);
    a.matrixAutoUpdate = this.matrixAutoUpdate;
    a.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;
    a.visible = this.visible;
    a.castShadow = this.castShadow;
    a.receiveShadow = this.receiveShadow;
    a.frustumCulled = this.frustumCulled;
    a.userData = JSON.parse(JSON.stringify(this.userData));
    if (!0 === b)
      for (var c = 0; c < this.children.length; c++)
        a.add(this.children[c].clone());
    return a;
  }
};
THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype);
THREE.Object3DIdCount = 0;
THREE.Projector = function () {
  function a() {
    if (n === r) {
      var a = new THREE.RenderableVertex();
      s.push(a);
      r++;
      n++;
      return a;
    }
    return s[n++];
  }
  function b() {
    if (u === v) {
      var a = new THREE.RenderableFace();
      p.push(a);
      v++;
      u++;
      return a;
    }
    return p[u++];
  }
  function c() {
    if (t === z) {
      var a = new THREE.RenderableLine();
      x.push(a);
      z++;
      t++;
      return a;
    }
    return x[t++];
  }
  function d(a, b) {
    return a.z !== b.z ? b.z - a.z : a.id !== b.id ? a.id - b.id : 0;
  }
  function e(a, b) {
    var c = 0, d = 1, e = a.z + a.w, f = b.z + b.w, g = -a.z + a.w, h = -b.z + b.w;
    if (0 <= e && 0 <= f && 0 <= g && 0 <= h)
      return !0;
    if (0 > e && 0 > f || 0 > g && 0 > h)
      return !1;
    0 > e ? c = Math.max(c, e / (e - f)) : 0 > f && (d = Math.min(d, e / (e - f)));
    0 > g ? c = Math.max(c, g / (g - h)) : 0 > h && (d = Math.min(d, g / (g - h)));
    if (d < c)
      return !1;
    a.lerp(b, c);
    b.lerp(a, 1 - d);
    return !0;
  }
  var f, g, h = [], k = 0, l, n, s = [], r = 0, q, u, p = [], v = 0, w, t, x = [], z = 0, B, E, H = [], D = 0, G = {
      objects: [],
      lights: [],
      elements: []
    }, I = new THREE.Vector3(), O = new THREE.Vector3(), K = new THREE.Vector3(), y = new THREE.Vector3(), F = new THREE.Vector4(), C = new THREE.Box3(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1)), A = new THREE.Box3(), L = Array(3), Q = new THREE.Matrix4(), Y = new THREE.Matrix4(), R, fa = new THREE.Matrix4(), V = new THREE.Matrix3(), ga = new THREE.Frustum(), J = new THREE.Vector4(), da = new THREE.Vector4();
  this.projectVector = function (a, b) {
    b.matrixWorldInverse.getInverse(b.matrixWorld);
    Y.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse);
    return a.applyProjection(Y);
  };
  this.unprojectVector = function () {
    var a = new THREE.Matrix4();
    return function (b, c) {
      a.getInverse(c.projectionMatrix);
      Y.multiplyMatrices(c.matrixWorld, a);
      return b.applyProjection(Y);
    };
  }();
  this.pickingRay = function (a, b) {
    a.z = -1;
    var c = new THREE.Vector3(a.x, a.y, 1);
    this.unprojectVector(a, b);
    this.unprojectVector(c, b);
    c.sub(a).normalize();
    return new THREE.Raycaster(a, c);
  };
  var W = function (a) {
      if (!1 !== a.visible) {
        if (a instanceof THREE.Light)
          G.lights.push(a);
        else if (a instanceof THREE.Mesh || a instanceof THREE.Line || a instanceof THREE.Sprite)
          if (!1 === a.frustumCulled || !0 === ga.intersectsObject(a)) {
            if (g === k) {
              var b = new THREE.RenderableObject();
              h.push(b);
              k++;
              g++;
              f = b;
            } else
              f = h[g++];
            f.id = a.id;
            f.object = a;
            null !== a.renderDepth ? f.z = a.renderDepth : (y.setFromMatrixPosition(a.matrixWorld), y.applyProjection(Y), f.z = y.z);
            G.objects.push(f);
          }
        for (var b = 0, c = a.children.length; b < c; b++)
          W(a.children[b]);
      }
    }, N = new function () {
      var d = [], e = null, f = new THREE.Matrix3(), g = function (a) {
          var b = a.positionWorld, c = a.positionScreen;
          b.copy(a.position).applyMatrix4(R);
          c.copy(b).applyMatrix4(Y);
          b = 1 / c.w;
          c.x *= b;
          c.y *= b;
          c.z *= b;
          a.visible = -1 <= c.x && 1 >= c.x && -1 <= c.y && 1 >= c.y && -1 <= c.z && 1 >= c.z;
        }, h = function (a, b, c) {
          L[0] = a.positionScreen;
          L[1] = b.positionScreen;
          L[2] = c.positionScreen;
          return !0 === a.visible || !0 === b.visible || !0 === c.visible || C.isIntersectionBox(A.setFromPoints(L)) ? 0 > (c.positionScreen.x - a.positionScreen.x) * (b.positionScreen.y - a.positionScreen.y) - (c.positionScreen.y - a.positionScreen.y) * (b.positionScreen.x - a.positionScreen.x) : !1;
        };
      return {
        setObject: function (a) {
          e = a;
          f.getNormalMatrix(e.matrixWorld);
          d.length = 0;
        },
        projectVertex: g,
        checkTriangleVisibility: h,
        pushVertex: function (b, c, d) {
          l = a();
          l.position.set(b, c, d);
          g(l);
        },
        pushNormal: function (a, b, c) {
          d.push(a, b, c);
        },
        pushLine: function (a, b) {
          var d = s[a], f = s[b];
          w = c();
          w.id = e.id;
          w.v1.copy(d);
          w.v2.copy(f);
          w.z = (d.positionScreen.z + f.positionScreen.z) / 2;
          w.material = e.material;
          G.elements.push(w);
        },
        pushTriangle: function (a, c, g) {
          var k = s[a], l = s[c], n = s[g];
          if (!0 === h(k, l, n)) {
            q = b();
            q.id = e.id;
            q.v1.copy(k);
            q.v2.copy(l);
            q.v3.copy(n);
            q.z = (k.positionScreen.z + l.positionScreen.z + n.positionScreen.z) / 3;
            for (k = 0; 3 > k; k++)
              l = 3 * arguments[k], n = q.vertexNormalsModel[k], n.set(d[l + 0], d[l + 1], d[l + 2]), n.applyMatrix3(f).normalize();
            q.vertexNormalsLength = 3;
            q.material = e.material;
            G.elements.push(q);
          }
        }
      };
    }();
  this.projectScene = function (f, h, k, l) {
    var p, r, v, x, y, z, C, L, A;
    E = t = u = 0;
    G.elements.length = 0;
    !0 === f.autoUpdate && f.updateMatrixWorld();
    void 0 === h.parent && h.updateMatrixWorld();
    Q.copy(h.matrixWorldInverse.getInverse(h.matrixWorld));
    Y.multiplyMatrices(h.projectionMatrix, Q);
    ga.setFromMatrix(Y);
    g = 0;
    G.objects.length = 0;
    G.lights.length = 0;
    W(f);
    !0 === k && G.objects.sort(d);
    f = 0;
    for (k = G.objects.length; f < k; f++)
      if (p = G.objects[f].object, r = p.geometry, N.setObject(p), R = p.matrixWorld, n = 0, p instanceof THREE.Mesh)
        if (r instanceof THREE.BufferGeometry) {
          if (z = r.attributes, p = r.offsets, void 0 !== z.position) {
            L = z.position.array;
            r = 0;
            for (x = L.length; r < x; r += 3)
              N.pushVertex(L[r], L[r + 1], L[r + 2]);
            A = z.normal.array;
            r = 0;
            for (x = A.length; r < x; r += 3)
              N.pushNormal(A[r], A[r + 1], A[r + 2]);
            if (void 0 !== z.index)
              if (z = z.index.array, 0 < p.length)
                for (f = 0; f < p.length; f++)
                  for (x = p[f], L = x.index, r = x.start, x = x.start + x.count; r < x; r += 3)
                    N.pushTriangle(z[r] + L, z[r + 1] + L, z[r + 2] + L);
              else
                for (r = 0, x = z.length; r < x; r += 3)
                  N.pushTriangle(z[r], z[r + 1], z[r + 2]);
            else
              for (r = 0, x = L.length / 3; r < x; r += 3)
                N.pushTriangle(r, r + 1, r + 2);
          }
        } else {
          if (r instanceof THREE.Geometry) {
            v = r.vertices;
            x = r.faces;
            z = r.faceVertexUvs;
            V.getNormalMatrix(R);
            L = p.material instanceof THREE.MeshFaceMaterial;
            A = !0 === L ? p.material : null;
            for (var ka = 0, Ka = v.length; ka < Ka; ka++) {
              var la = v[ka];
              N.pushVertex(la.x, la.y, la.z);
            }
            ka = 0;
            for (Ka = x.length; ka < Ka; ka++) {
              v = x[ka];
              var Ba = !0 === L ? A.materials[v.materialIndex] : p.material;
              if (void 0 !== Ba) {
                C = Ba.side;
                var la = s[v.a], Ia = s[v.b], ma = s[v.c];
                if (!0 === Ba.morphTargets) {
                  y = r.morphTargets;
                  var Ca = p.morphTargetInfluences, ba = la.position, wa = Ia.position, xa = ma.position;
                  I.set(0, 0, 0);
                  O.set(0, 0, 0);
                  K.set(0, 0, 0);
                  for (var Da = 0, Wa = y.length; Da < Wa; Da++) {
                    var La = Ca[Da];
                    if (0 !== La) {
                      var Ea = y[Da].vertices;
                      I.x += (Ea[v.a].x - ba.x) * La;
                      I.y += (Ea[v.a].y - ba.y) * La;
                      I.z += (Ea[v.a].z - ba.z) * La;
                      O.x += (Ea[v.b].x - wa.x) * La;
                      O.y += (Ea[v.b].y - wa.y) * La;
                      O.z += (Ea[v.b].z - wa.z) * La;
                      K.x += (Ea[v.c].x - xa.x) * La;
                      K.y += (Ea[v.c].y - xa.y) * La;
                      K.z += (Ea[v.c].z - xa.z) * La;
                    }
                  }
                  la.position.add(I);
                  Ia.position.add(O);
                  ma.position.add(K);
                  N.projectVertex(la);
                  N.projectVertex(Ia);
                  N.projectVertex(ma);
                }
                Ca = N.checkTriangleVisibility(la, Ia, ma);
                if (!(!1 === Ca && C === THREE.FrontSide || !0 === Ca && C === THREE.BackSide)) {
                  q = b();
                  q.id = p.id;
                  q.v1.copy(la);
                  q.v2.copy(Ia);
                  q.v3.copy(ma);
                  q.normalModel.copy(v.normal);
                  !1 !== Ca || C !== THREE.BackSide && C !== THREE.DoubleSide || q.normalModel.negate();
                  q.normalModel.applyMatrix3(V).normalize();
                  q.centroidModel.copy(v.centroid).applyMatrix4(R);
                  y = v.vertexNormals;
                  ba = 0;
                  for (wa = Math.min(y.length, 3); ba < wa; ba++)
                    xa = q.vertexNormalsModel[ba], xa.copy(y[ba]), !1 !== Ca || C !== THREE.BackSide && C !== THREE.DoubleSide || xa.negate(), xa.applyMatrix3(V).normalize();
                  q.vertexNormalsLength = y.length;
                  y = 0;
                  for (Ca = Math.min(z.length, 3); y < Ca; y++)
                    if (C = z[y][ka], void 0 !== C)
                      for (ba = 0, wa = C.length; ba < wa; ba++)
                        q.uvs[y][ba] = C[ba];
                  q.color = v.color;
                  q.material = Ba;
                  q.z = (la.positionScreen.z + Ia.positionScreen.z + ma.positionScreen.z) / 3;
                  G.elements.push(q);
                }
              }
            }
          }
        }
      else if (p instanceof THREE.Line)
        if (r instanceof THREE.BufferGeometry) {
          if (z = r.attributes, void 0 !== z.position) {
            L = z.position.array;
            r = 0;
            for (x = L.length; r < x; r += 3)
              N.pushVertex(L[r], L[r + 1], L[r + 2]);
            if (void 0 !== z.index)
              for (z = z.index.array, r = 0, x = z.length; r < x; r += 2)
                N.pushLine(z[r], z[r + 1]);
            else
              for (r = 0, x = L.length / 3 - 1; r < x; r++)
                N.pushLine(r, r + 1);
          }
        } else {
          if (r instanceof THREE.Geometry && (fa.multiplyMatrices(Y, R), v = p.geometry.vertices, 0 !== v.length))
            for (la = a(), la.positionScreen.copy(v[0]).applyMatrix4(fa), r = p.type === THREE.LinePieces ? 2 : 1, ka = 1, Ka = v.length; ka < Ka; ka++)
              la = a(), la.positionScreen.copy(v[ka]).applyMatrix4(fa), 0 < (ka + 1) % r || (Ia = s[n - 2], J.copy(la.positionScreen), da.copy(Ia.positionScreen), !0 === e(J, da) && (J.multiplyScalar(1 / J.w), da.multiplyScalar(1 / da.w), w = c(), w.id = p.id, w.v1.positionScreen.copy(J), w.v2.positionScreen.copy(da), w.z = Math.max(J.z, da.z), w.material = p.material, p.material.vertexColors === THREE.VertexColors && (w.vertexColors[0].copy(p.geometry.colors[ka]), w.vertexColors[1].copy(p.geometry.colors[ka - 1])), G.elements.push(w)));
        }
      else
        p instanceof THREE.Sprite && (F.set(R.elements[12], R.elements[13], R.elements[14], 1), F.applyMatrix4(Y), r = 1 / F.w, F.z *= r, -1 <= F.z && 1 >= F.z && (E === D ? (x = new THREE.RenderableSprite(), H.push(x), D++, E++, B = x) : B = H[E++], B.id = p.id, B.x = F.x * r, B.y = F.y * r, B.z = F.z, B.object = p, B.rotation = p.rotation, B.scale.x = p.scale.x * Math.abs(B.x - (F.x + h.projectionMatrix.elements[0]) / (F.w + h.projectionMatrix.elements[12])), B.scale.y = p.scale.y * Math.abs(B.y - (F.y + h.projectionMatrix.elements[5]) / (F.w + h.projectionMatrix.elements[13])), B.material = p.material, G.elements.push(B)));
    !0 === l && G.elements.sort(d);
    return G;
  };
};
THREE.Face3 = function (a, b, c, d, e, f) {
  this.a = a;
  this.b = b;
  this.c = c;
  this.normal = d instanceof THREE.Vector3 ? d : new THREE.Vector3();
  this.vertexNormals = d instanceof Array ? d : [];
  this.color = e instanceof THREE.Color ? e : new THREE.Color();
  this.vertexColors = e instanceof Array ? e : [];
  this.vertexTangents = [];
  this.materialIndex = void 0 !== f ? f : 0;
  this.centroid = new THREE.Vector3();
};
THREE.Face3.prototype = {
  constructor: THREE.Face3,
  clone: function () {
    var a = new THREE.Face3(this.a, this.b, this.c);
    a.normal.copy(this.normal);
    a.color.copy(this.color);
    a.centroid.copy(this.centroid);
    a.materialIndex = this.materialIndex;
    var b, c;
    b = 0;
    for (c = this.vertexNormals.length; b < c; b++)
      a.vertexNormals[b] = this.vertexNormals[b].clone();
    b = 0;
    for (c = this.vertexColors.length; b < c; b++)
      a.vertexColors[b] = this.vertexColors[b].clone();
    b = 0;
    for (c = this.vertexTangents.length; b < c; b++)
      a.vertexTangents[b] = this.vertexTangents[b].clone();
    return a;
  }
};
THREE.Face4 = function (a, b, c, d, e, f, g) {
  console.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');
  return new THREE.Face3(a, b, c, e, f, g);
};
THREE.BufferGeometry = function () {
  this.id = THREE.GeometryIdCount++;
  this.uuid = THREE.Math.generateUUID();
  this.name = '';
  this.attributes = {};
  this.offsets = [];
  this.boundingSphere = this.boundingBox = null;
};
THREE.BufferGeometry.prototype = {
  constructor: THREE.BufferGeometry,
  addAttribute: function (a, b, c, d) {
    this.attributes[a] = {
      array: new b(c * d),
      itemSize: d
    };
    return this.attributes[a];
  },
  applyMatrix: function (a) {
    var b = this.attributes.position;
    void 0 !== b && (a.multiplyVector3Array(b.array), b.needsUpdate = !0);
    b = this.attributes.normal;
    void 0 !== b && (new THREE.Matrix3().getNormalMatrix(a).multiplyVector3Array(b.array), b.needsUpdate = !0);
  },
  computeBoundingBox: function () {
    null === this.boundingBox && (this.boundingBox = new THREE.Box3());
    var a = this.attributes.position.array;
    if (a) {
      var b = this.boundingBox;
      3 <= a.length && (b.min.x = b.max.x = a[0], b.min.y = b.max.y = a[1], b.min.z = b.max.z = a[2]);
      for (var c = 3, d = a.length; c < d; c += 3) {
        var e = a[c], f = a[c + 1], g = a[c + 2];
        e < b.min.x ? b.min.x = e : e > b.max.x && (b.max.x = e);
        f < b.min.y ? b.min.y = f : f > b.max.y && (b.max.y = f);
        g < b.min.z ? b.min.z = g : g > b.max.z && (b.max.z = g);
      }
    }
    if (void 0 === a || 0 === a.length)
      this.boundingBox.min.set(0, 0, 0), this.boundingBox.max.set(0, 0, 0);
  },
  computeBoundingSphere: function () {
    var a = new THREE.Box3(), b = new THREE.Vector3();
    return function () {
      null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere());
      var c = this.attributes.position.array;
      if (c) {
        a.makeEmpty();
        for (var d = this.boundingSphere.center, e = 0, f = c.length; e < f; e += 3)
          b.set(c[e], c[e + 1], c[e + 2]), a.addPoint(b);
        a.center(d);
        for (var g = 0, e = 0, f = c.length; e < f; e += 3)
          b.set(c[e], c[e + 1], c[e + 2]), g = Math.max(g, d.distanceToSquared(b));
        this.boundingSphere.radius = Math.sqrt(g);
      }
    };
  }(),
  computeVertexNormals: function () {
    if (this.attributes.position) {
      var a, b, c, d;
      a = this.attributes.position.array.length;
      if (void 0 === this.attributes.normal)
        this.attributes.normal = {
          itemSize: 3,
          array: new Float32Array(a)
        };
      else
        for (a = 0, b = this.attributes.normal.array.length; a < b; a++)
          this.attributes.normal.array[a] = 0;
      var e = this.attributes.position.array, f = this.attributes.normal.array, g, h, k, l, n, s, r = new THREE.Vector3(), q = new THREE.Vector3(), u = new THREE.Vector3(), p = new THREE.Vector3(), v = new THREE.Vector3();
      if (this.attributes.index) {
        var w = this.attributes.index.array, t = this.offsets;
        c = 0;
        for (d = t.length; c < d; ++c) {
          b = t[c].start;
          g = t[c].count;
          var x = t[c].index;
          a = b;
          for (b += g; a < b; a += 3)
            g = x + w[a], h = x + w[a + 1], k = x + w[a + 2], l = e[3 * g], n = e[3 * g + 1], s = e[3 * g + 2], r.set(l, n, s), l = e[3 * h], n = e[3 * h + 1], s = e[3 * h + 2], q.set(l, n, s), l = e[3 * k], n = e[3 * k + 1], s = e[3 * k + 2], u.set(l, n, s), p.subVectors(u, q), v.subVectors(r, q), p.cross(v), f[3 * g] += p.x, f[3 * g + 1] += p.y, f[3 * g + 2] += p.z, f[3 * h] += p.x, f[3 * h + 1] += p.y, f[3 * h + 2] += p.z, f[3 * k] += p.x, f[3 * k + 1] += p.y, f[3 * k + 2] += p.z;
        }
      } else
        for (a = 0, b = e.length; a < b; a += 9)
          l = e[a], n = e[a + 1], s = e[a + 2], r.set(l, n, s), l = e[a + 3], n = e[a + 4], s = e[a + 5], q.set(l, n, s), l = e[a + 6], n = e[a + 7], s = e[a + 8], u.set(l, n, s), p.subVectors(u, q), v.subVectors(r, q), p.cross(v), f[a] = p.x, f[a + 1] = p.y, f[a + 2] = p.z, f[a + 3] = p.x, f[a + 4] = p.y, f[a + 5] = p.z, f[a + 6] = p.x, f[a + 7] = p.y, f[a + 8] = p.z;
      this.normalizeNormals();
      this.normalsNeedUpdate = !0;
    }
  },
  normalizeNormals: function () {
    for (var a = this.attributes.normal.array, b, c, d, e = 0, f = a.length; e < f; e += 3)
      b = a[e], c = a[e + 1], d = a[e + 2], b = 1 / Math.sqrt(b * b + c * c + d * d), a[e] *= b, a[e + 1] *= b, a[e + 2] *= b;
  },
  computeTangents: function () {
    function a(a, b, c) {
      s = d[3 * a];
      r = d[3 * a + 1];
      q = d[3 * a + 2];
      u = d[3 * b];
      p = d[3 * b + 1];
      v = d[3 * b + 2];
      w = d[3 * c];
      t = d[3 * c + 1];
      x = d[3 * c + 2];
      z = f[2 * a];
      B = f[2 * a + 1];
      E = f[2 * b];
      H = f[2 * b + 1];
      D = f[2 * c];
      G = f[2 * c + 1];
      I = u - s;
      O = w - s;
      K = p - r;
      y = t - r;
      F = v - q;
      C = x - q;
      A = E - z;
      L = D - z;
      Q = H - B;
      Y = G - B;
      R = 1 / (A * Y - L * Q);
      fa.set((Y * I - Q * O) * R, (Y * K - Q * y) * R, (Y * F - Q * C) * R);
      V.set((A * O - L * I) * R, (A * y - L * K) * R, (A * C - L * F) * R);
      k[a].add(fa);
      k[b].add(fa);
      k[c].add(fa);
      l[a].add(V);
      l[b].add(V);
      l[c].add(V);
    }
    function b(a) {
      S.x = e[3 * a];
      S.y = e[3 * a + 1];
      S.z = e[3 * a + 2];
      $.copy(S);
      ta = k[a];
      T.copy(ta);
      T.sub(S.multiplyScalar(S.dot(ta))).normalize();
      Ja.crossVectors($, ta);
      oa = Ja.dot(l[a]);
      Fa = 0 > oa ? -1 : 1;
      h[4 * a] = T.x;
      h[4 * a + 1] = T.y;
      h[4 * a + 2] = T.z;
      h[4 * a + 3] = Fa;
    }
    if (void 0 === this.attributes.index || void 0 === this.attributes.position || void 0 === this.attributes.normal || void 0 === this.attributes.uv)
      console.warn('Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()');
    else {
      var c = this.attributes.index.array, d = this.attributes.position.array, e = this.attributes.normal.array, f = this.attributes.uv.array, g = d.length / 3;
      void 0 === this.attributes.tangent && (this.attributes.tangent = {
        itemSize: 4,
        array: new Float32Array(4 * g)
      });
      for (var h = this.attributes.tangent.array, k = [], l = [], n = 0; n < g; n++)
        k[n] = new THREE.Vector3(), l[n] = new THREE.Vector3();
      var s, r, q, u, p, v, w, t, x, z, B, E, H, D, G, I, O, K, y, F, C, A, L, Q, Y, R, fa = new THREE.Vector3(), V = new THREE.Vector3(), ga, J, da, W, N, ca = this.offsets, n = 0;
      for (J = ca.length; n < J; ++n) {
        ga = ca[n].start;
        da = ca[n].count;
        var sa = ca[n].index, g = ga;
        for (ga += da; g < ga; g += 3)
          da = sa + c[g], W = sa + c[g + 1], N = sa + c[g + 2], a(da, W, N);
      }
      var T = new THREE.Vector3(), Ja = new THREE.Vector3(), S = new THREE.Vector3(), $ = new THREE.Vector3(), Fa, ta, oa, n = 0;
      for (J = ca.length; n < J; ++n)
        for (ga = ca[n].start, da = ca[n].count, sa = ca[n].index, g = ga, ga += da; g < ga; g += 3)
          da = sa + c[g], W = sa + c[g + 1], N = sa + c[g + 2], b(da), b(W), b(N);
    }
  },
  computeOffsets: function (a) {
    var b = a;
    void 0 === a && (b = 65535);
    Date.now();
    a = this.attributes.index.array;
    for (var c = this.attributes.position.array, d = a.length / 3, e = new Uint16Array(a.length), f = 0, g = 0, h = [{
            start: 0,
            count: 0,
            index: 0
          }], k = h[0], l = 0, n = 0, s = new Int32Array(6), r = new Int32Array(c.length), q = new Int32Array(c.length), u = 0; u < c.length; u++)
      r[u] = -1, q[u] = -1;
    for (c = 0; c < d; c++) {
      for (var p = n = 0; 3 > p; p++)
        u = a[3 * c + p], -1 == r[u] ? (s[2 * p] = u, s[2 * p + 1] = -1, n++) : r[u] < k.index ? (s[2 * p] = u, s[2 * p + 1] = -1, l++) : (s[2 * p] = u, s[2 * p + 1] = r[u]);
      if (g + n > k.index + b)
        for (k = {
            start: f,
            count: 0,
            index: g
          }, h.push(k), n = 0; 6 > n; n += 2)
          p = s[n + 1], -1 < p && p < k.index && (s[n + 1] = -1);
      for (n = 0; 6 > n; n += 2)
        u = s[n], p = s[n + 1], -1 === p && (p = g++), r[u] = p, q[p] = u, e[f++] = p - k.index, k.count++;
    }
    this.reorderBuffers(e, q, g);
    return this.offsets = h;
  },
  reorderBuffers: function (a, b, c) {
    var d = {}, e = [
        Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array
      ], f;
    for (f in this.attributes)
      if ('index' != f)
        for (var g = this.attributes[f].array, h = 0, k = e.length; h < k; h++) {
          var l = e[h];
          if (g instanceof l) {
            d[f] = new l(this.attributes[f].itemSize * c);
            break;
          }
        }
    for (e = 0; e < c; e++)
      for (f in g = b[e], this.attributes)
        if ('index' != f)
          for (var h = this.attributes[f].array, k = this.attributes[f].itemSize, l = d[f], n = 0; n < k; n++)
            l[e * k + n] = h[g * k + n];
    this.attributes.index.array = a;
    for (f in this.attributes)
      'index' != f && (this.attributes[f].array = d[f], this.attributes[f].numItems = this.attributes[f].itemSize * c);
  },
  clone: function () {
    var a = new THREE.BufferGeometry(), b = [
        Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array
      ], c;
    for (c in this.attributes) {
      for (var d = this.attributes[c], e = d.array, f = {
            itemSize: d.itemSize,
            array: null
          }, d = 0, g = b.length; d < g; d++) {
        var h = b[d];
        if (e instanceof h) {
          f.array = new h(e);
          break;
        }
      }
      a.attributes[c] = f;
    }
    d = 0;
    for (g = this.offsets.length; d < g; d++)
      b = this.offsets[d], a.offsets.push({
        start: b.start,
        index: b.index,
        count: b.count
      });
    return a;
  },
  dispose: function () {
    this.dispatchEvent({ type: 'dispose' });
  }
};
THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype);
THREE.Geometry = function () {
  this.id = THREE.GeometryIdCount++;
  this.uuid = THREE.Math.generateUUID();
  this.name = '';
  this.vertices = [];
  this.colors = [];
  this.faces = [];
  this.faceVertexUvs = [[]];
  this.morphTargets = [];
  this.morphColors = [];
  this.morphNormals = [];
  this.skinWeights = [];
  this.skinIndices = [];
  this.lineDistances = [];
  this.boundingSphere = this.boundingBox = null;
  this.hasTangents = !1;
  this.dynamic = !0;
  this.buffersNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.tangentsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.elementsNeedUpdate = this.verticesNeedUpdate = !1;
};
THREE.Geometry.prototype = {
  constructor: THREE.Geometry,
  applyMatrix: function (a) {
    for (var b = new THREE.Matrix3().getNormalMatrix(a), c = 0, d = this.vertices.length; c < d; c++)
      this.vertices[c].applyMatrix4(a);
    c = 0;
    for (d = this.faces.length; c < d; c++) {
      var e = this.faces[c];
      e.normal.applyMatrix3(b).normalize();
      for (var f = 0, g = e.vertexNormals.length; f < g; f++)
        e.vertexNormals[f].applyMatrix3(b).normalize();
      e.centroid.applyMatrix4(a);
    }
    this.boundingBox instanceof THREE.Box3 && this.computeBoundingBox();
    this.boundingSphere instanceof THREE.Sphere && this.computeBoundingSphere();
  },
  computeCentroids: function () {
    var a, b, c;
    a = 0;
    for (b = this.faces.length; a < b; a++)
      c = this.faces[a], c.centroid.set(0, 0, 0), c.centroid.add(this.vertices[c.a]), c.centroid.add(this.vertices[c.b]), c.centroid.add(this.vertices[c.c]), c.centroid.divideScalar(3);
  },
  computeFaceNormals: function () {
    for (var a = new THREE.Vector3(), b = new THREE.Vector3(), c = 0, d = this.faces.length; c < d; c++) {
      var e = this.faces[c], f = this.vertices[e.a], g = this.vertices[e.b];
      a.subVectors(this.vertices[e.c], g);
      b.subVectors(f, g);
      a.cross(b);
      a.normalize();
      e.normal.copy(a);
    }
  },
  computeVertexNormals: function (a) {
    var b, c, d;
    d = Array(this.vertices.length);
    b = 0;
    for (c = this.vertices.length; b < c; b++)
      d[b] = new THREE.Vector3();
    if (a) {
      var e, f, g, h = new THREE.Vector3(), k = new THREE.Vector3();
      new THREE.Vector3();
      new THREE.Vector3();
      new THREE.Vector3();
      a = 0;
      for (b = this.faces.length; a < b; a++)
        c = this.faces[a], e = this.vertices[c.a], f = this.vertices[c.b], g = this.vertices[c.c], h.subVectors(g, f), k.subVectors(e, f), h.cross(k), d[c.a].add(h), d[c.b].add(h), d[c.c].add(h);
    } else
      for (a = 0, b = this.faces.length; a < b; a++)
        c = this.faces[a], d[c.a].add(c.normal), d[c.b].add(c.normal), d[c.c].add(c.normal);
    b = 0;
    for (c = this.vertices.length; b < c; b++)
      d[b].normalize();
    a = 0;
    for (b = this.faces.length; a < b; a++)
      c = this.faces[a], c.vertexNormals[0] = d[c.a].clone(), c.vertexNormals[1] = d[c.b].clone(), c.vertexNormals[2] = d[c.c].clone();
  },
  computeMorphNormals: function () {
    var a, b, c, d, e;
    c = 0;
    for (d = this.faces.length; c < d; c++)
      for (e = this.faces[c], e.__originalFaceNormal ? e.__originalFaceNormal.copy(e.normal) : e.__originalFaceNormal = e.normal.clone(), e.__originalVertexNormals || (e.__originalVertexNormals = []), a = 0, b = e.vertexNormals.length; a < b; a++)
        e.__originalVertexNormals[a] ? e.__originalVertexNormals[a].copy(e.vertexNormals[a]) : e.__originalVertexNormals[a] = e.vertexNormals[a].clone();
    var f = new THREE.Geometry();
    f.faces = this.faces;
    a = 0;
    for (b = this.morphTargets.length; a < b; a++) {
      if (!this.morphNormals[a]) {
        this.morphNormals[a] = {};
        this.morphNormals[a].faceNormals = [];
        this.morphNormals[a].vertexNormals = [];
        e = this.morphNormals[a].faceNormals;
        var g = this.morphNormals[a].vertexNormals, h, k;
        c = 0;
        for (d = this.faces.length; c < d; c++)
          h = new THREE.Vector3(), k = {
            a: new THREE.Vector3(),
            b: new THREE.Vector3(),
            c: new THREE.Vector3()
          }, e.push(h), g.push(k);
      }
      g = this.morphNormals[a];
      f.vertices = this.morphTargets[a].vertices;
      f.computeFaceNormals();
      f.computeVertexNormals();
      c = 0;
      for (d = this.faces.length; c < d; c++)
        e = this.faces[c], h = g.faceNormals[c], k = g.vertexNormals[c], h.copy(e.normal), k.a.copy(e.vertexNormals[0]), k.b.copy(e.vertexNormals[1]), k.c.copy(e.vertexNormals[2]);
    }
    c = 0;
    for (d = this.faces.length; c < d; c++)
      e = this.faces[c], e.normal = e.__originalFaceNormal, e.vertexNormals = e.__originalVertexNormals;
  },
  computeTangents: function () {
    var a, b, c, d, e, f, g, h, k, l, n, s, r, q, u, p, v, w = [], t = [];
    c = new THREE.Vector3();
    var x = new THREE.Vector3(), z = new THREE.Vector3(), B = new THREE.Vector3(), E = new THREE.Vector3();
    a = 0;
    for (b = this.vertices.length; a < b; a++)
      w[a] = new THREE.Vector3(), t[a] = new THREE.Vector3();
    a = 0;
    for (b = this.faces.length; a < b; a++)
      e = this.faces[a], f = this.faceVertexUvs[0][a], d = e.a, v = e.b, e = e.c, g = this.vertices[d], h = this.vertices[v], k = this.vertices[e], l = f[0], n = f[1], s = f[2], f = h.x - g.x, r = k.x - g.x, q = h.y - g.y, u = k.y - g.y, h = h.z - g.z, g = k.z - g.z, k = n.x - l.x, p = s.x - l.x, n = n.y - l.y, l = s.y - l.y, s = 1 / (k * l - p * n), c.set((l * f - n * r) * s, (l * q - n * u) * s, (l * h - n * g) * s), x.set((k * r - p * f) * s, (k * u - p * q) * s, (k * g - p * h) * s), w[d].add(c), w[v].add(c), w[e].add(c), t[d].add(x), t[v].add(x), t[e].add(x);
    x = [
      'a',
      'b',
      'c',
      'd'
    ];
    a = 0;
    for (b = this.faces.length; a < b; a++)
      for (e = this.faces[a], c = 0; c < Math.min(e.vertexNormals.length, 3); c++)
        E.copy(e.vertexNormals[c]), d = e[x[c]], v = w[d], z.copy(v), z.sub(E.multiplyScalar(E.dot(v))).normalize(), B.crossVectors(e.vertexNormals[c], v), d = B.dot(t[d]), d = 0 > d ? -1 : 1, e.vertexTangents[c] = new THREE.Vector4(z.x, z.y, z.z, d);
    this.hasTangents = !0;
  },
  computeLineDistances: function () {
    for (var a = 0, b = this.vertices, c = 0, d = b.length; c < d; c++)
      0 < c && (a += b[c].distanceTo(b[c - 1])), this.lineDistances[c] = a;
  },
  computeBoundingBox: function () {
    null === this.boundingBox && (this.boundingBox = new THREE.Box3());
    this.boundingBox.setFromPoints(this.vertices);
  },
  computeBoundingSphere: function () {
    null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere());
    this.boundingSphere.setFromPoints(this.vertices);
  },
  mergeVertices: function () {
    var a = {}, b = [], c = [], d, e = Math.pow(10, 4), f, g;
    f = 0;
    for (g = this.vertices.length; f < g; f++)
      d = this.vertices[f], d = Math.round(d.x * e) + '_' + Math.round(d.y * e) + '_' + Math.round(d.z * e), void 0 === a[d] ? (a[d] = f, b.push(this.vertices[f]), c[f] = b.length - 1) : c[f] = c[a[d]];
    a = [];
    f = 0;
    for (g = this.faces.length; f < g; f++)
      for (e = this.faces[f], e.a = c[e.a], e.b = c[e.b], e.c = c[e.c], e = [
          e.a,
          e.b,
          e.c
        ], d = 0; 3 > d; d++)
        if (e[d] == e[(d + 1) % 3]) {
          a.push(f);
          break;
        }
    for (f = a.length - 1; 0 <= f; f--)
      for (e = a[f], this.faces.splice(e, 1), c = 0, g = this.faceVertexUvs.length; c < g; c++)
        this.faceVertexUvs[c].splice(e, 1);
    f = this.vertices.length - b.length;
    this.vertices = b;
    return f;
  },
  makeGroups: function () {
    var a = 0;
    return function (b) {
      var c, d, e, f, g = {}, h = this.morphTargets.length, k = this.morphNormals.length;
      this.geometryGroups = {};
      c = 0;
      for (d = this.faces.length; c < d; c++)
        e = this.faces[c], e = b ? e.materialIndex : 0, e in g || (g[e] = {
          hash: e,
          counter: 0
        }), f = g[e].hash + '_' + g[e].counter, f in this.geometryGroups || (this.geometryGroups[f] = {
          faces3: [],
          materialIndex: e,
          vertices: 0,
          numMorphTargets: h,
          numMorphNormals: k
        }), 65535 < this.geometryGroups[f].vertices + 3 && (g[e].counter += 1, f = g[e].hash + '_' + g[e].counter, f in this.geometryGroups || (this.geometryGroups[f] = {
          faces3: [],
          materialIndex: e,
          vertices: 0,
          numMorphTargets: h,
          numMorphNormals: k
        })), this.geometryGroups[f].faces3.push(c), this.geometryGroups[f].vertices += 3;
      this.geometryGroupsList = [];
      for (var l in this.geometryGroups)
        this.geometryGroups[l].id = a++, this.geometryGroupsList.push(this.geometryGroups[l]);
    };
  }(),
  clone: function () {
    for (var a = new THREE.Geometry(), b = this.vertices, c = 0, d = b.length; c < d; c++)
      a.vertices.push(b[c].clone());
    b = this.faces;
    c = 0;
    for (d = b.length; c < d; c++)
      a.faces.push(b[c].clone());
    b = this.faceVertexUvs[0];
    c = 0;
    for (d = b.length; c < d; c++) {
      for (var e = b[c], f = [], g = 0, h = e.length; g < h; g++)
        f.push(new THREE.Vector2(e[g].x, e[g].y));
      a.faceVertexUvs[0].push(f);
    }
    return a;
  },
  dispose: function () {
    this.dispatchEvent({ type: 'dispose' });
  }
};
THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype);
THREE.GeometryIdCount = 0;
THREE.Geometry2 = function (a) {
  THREE.BufferGeometry.call(this);
  this.vertices = this.addAttribute('position', Float32Array, a, 3).array;
  this.normals = this.addAttribute('normal', Float32Array, a, 3).array;
  this.uvs = this.addAttribute('uv', Float32Array, a, 2).array;
  this.boundingSphere = this.boundingBox = null;
};
THREE.Geometry2.prototype = Object.create(THREE.BufferGeometry.prototype);
THREE.Camera = function () {
  THREE.Object3D.call(this);
  this.matrixWorldInverse = new THREE.Matrix4();
  this.projectionMatrix = new THREE.Matrix4();
};
THREE.Camera.prototype = Object.create(THREE.Object3D.prototype);
THREE.Camera.prototype.lookAt = function () {
  var a = new THREE.Matrix4();
  return function (b) {
    a.lookAt(this.position, b, this.up);
    this.quaternion.setFromRotationMatrix(a);
  };
}();
THREE.Camera.prototype.clone = function (a) {
  void 0 === a && (a = new THREE.Camera());
  THREE.Object3D.prototype.clone.call(this, a);
  a.matrixWorldInverse.copy(this.matrixWorldInverse);
  a.projectionMatrix.copy(this.projectionMatrix);
  return a;
};
THREE.OrthographicCamera = function (a, b, c, d, e, f) {
  THREE.Camera.call(this);
  this.left = a;
  this.right = b;
  this.top = c;
  this.bottom = d;
  this.near = void 0 !== e ? e : 0.1;
  this.far = void 0 !== f ? f : 2000;
  this.updateProjectionMatrix();
};
THREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype);
THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {
  this.projectionMatrix.makeOrthographic(this.left, this.right, this.top, this.bottom, this.near, this.far);
};
THREE.OrthographicCamera.prototype.clone = function () {
  var a = new THREE.OrthographicCamera();
  THREE.Camera.prototype.clone.call(this, a);
  a.left = this.left;
  a.right = this.right;
  a.top = this.top;
  a.bottom = this.bottom;
  a.near = this.near;
  a.far = this.far;
  return a;
};
THREE.PerspectiveCamera = function (a, b, c, d) {
  THREE.Camera.call(this);
  this.fov = void 0 !== a ? a : 50;
  this.aspect = void 0 !== b ? b : 1;
  this.near = void 0 !== c ? c : 0.1;
  this.far = void 0 !== d ? d : 2000;
  this.updateProjectionMatrix();
};
THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype);
THREE.PerspectiveCamera.prototype.setLens = function (a, b) {
  void 0 === b && (b = 24);
  this.fov = 2 * THREE.Math.radToDeg(Math.atan(b / (2 * a)));
  this.updateProjectionMatrix();
};
THREE.PerspectiveCamera.prototype.setViewOffset = function (a, b, c, d, e, f) {
  this.fullWidth = a;
  this.fullHeight = b;
  this.x = c;
  this.y = d;
  this.width = e;
  this.height = f;
  this.updateProjectionMatrix();
};
THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {
  if (this.fullWidth) {
    var a = this.fullWidth / this.fullHeight, b = Math.tan(THREE.Math.degToRad(0.5 * this.fov)) * this.near, c = -b, d = a * c, a = Math.abs(a * b - d), c = Math.abs(b - c);
    this.projectionMatrix.makeFrustum(d + this.x * a / this.fullWidth, d + (this.x + this.width) * a / this.fullWidth, b - (this.y + this.height) * c / this.fullHeight, b - this.y * c / this.fullHeight, this.near, this.far);
  } else
    this.projectionMatrix.makePerspective(this.fov, this.aspect, this.near, this.far);
};
THREE.PerspectiveCamera.prototype.clone = function () {
  var a = new THREE.PerspectiveCamera();
  THREE.Camera.prototype.clone.call(this, a);
  a.fov = this.fov;
  a.aspect = this.aspect;
  a.near = this.near;
  a.far = this.far;
  return a;
};
THREE.Light = function (a) {
  THREE.Object3D.call(this);
  this.color = new THREE.Color(a);
};
THREE.Light.prototype = Object.create(THREE.Object3D.prototype);
THREE.Light.prototype.clone = function (a) {
  void 0 === a && (a = new THREE.Light());
  THREE.Object3D.prototype.clone.call(this, a);
  a.color.copy(this.color);
  return a;
};
THREE.AmbientLight = function (a) {
  THREE.Light.call(this, a);
};
THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype);
THREE.AmbientLight.prototype.clone = function () {
  var a = new THREE.AmbientLight();
  THREE.Light.prototype.clone.call(this, a);
  return a;
};
THREE.AreaLight = function (a, b) {
  THREE.Light.call(this, a);
  this.normal = new THREE.Vector3(0, -1, 0);
  this.right = new THREE.Vector3(1, 0, 0);
  this.intensity = void 0 !== b ? b : 1;
  this.height = this.width = 1;
  this.constantAttenuation = 1.5;
  this.linearAttenuation = 0.5;
  this.quadraticAttenuation = 0.1;
};
THREE.AreaLight.prototype = Object.create(THREE.Light.prototype);
THREE.DirectionalLight = function (a, b) {
  THREE.Light.call(this, a);
  this.position.set(0, 1, 0);
  this.target = new THREE.Object3D();
  this.intensity = void 0 !== b ? b : 1;
  this.onlyShadow = this.castShadow = !1;
  this.shadowCameraNear = 50;
  this.shadowCameraFar = 5000;
  this.shadowCameraLeft = -500;
  this.shadowCameraTop = this.shadowCameraRight = 500;
  this.shadowCameraBottom = -500;
  this.shadowCameraVisible = !1;
  this.shadowBias = 0;
  this.shadowDarkness = 0.5;
  this.shadowMapHeight = this.shadowMapWidth = 512;
  this.shadowCascade = !1;
  this.shadowCascadeOffset = new THREE.Vector3(0, 0, -1000);
  this.shadowCascadeCount = 2;
  this.shadowCascadeBias = [
    0,
    0,
    0
  ];
  this.shadowCascadeWidth = [
    512,
    512,
    512
  ];
  this.shadowCascadeHeight = [
    512,
    512,
    512
  ];
  this.shadowCascadeNearZ = [
    -1,
    0.99,
    0.998
  ];
  this.shadowCascadeFarZ = [
    0.99,
    0.998,
    1
  ];
  this.shadowCascadeArray = [];
  this.shadowMatrix = this.shadowCamera = this.shadowMapSize = this.shadowMap = null;
};
THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype);
THREE.DirectionalLight.prototype.clone = function () {
  var a = new THREE.DirectionalLight();
  THREE.Light.prototype.clone.call(this, a);
  a.target = this.target.clone();
  a.intensity = this.intensity;
  a.castShadow = this.castShadow;
  a.onlyShadow = this.onlyShadow;
  return a;
};
THREE.HemisphereLight = function (a, b, c) {
  THREE.Light.call(this, a);
  this.position.set(0, 100, 0);
  this.groundColor = new THREE.Color(b);
  this.intensity = void 0 !== c ? c : 1;
};
THREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype);
THREE.HemisphereLight.prototype.clone = function () {
  var a = new THREE.HemisphereLight();
  THREE.Light.prototype.clone.call(this, a);
  a.groundColor.copy(this.groundColor);
  a.intensity = this.intensity;
  return a;
};
THREE.PointLight = function (a, b, c) {
  THREE.Light.call(this, a);
  this.intensity = void 0 !== b ? b : 1;
  this.distance = void 0 !== c ? c : 0;
};
THREE.PointLight.prototype = Object.create(THREE.Light.prototype);
THREE.PointLight.prototype.clone = function () {
  var a = new THREE.PointLight();
  THREE.Light.prototype.clone.call(this, a);
  a.intensity = this.intensity;
  a.distance = this.distance;
  return a;
};
THREE.SpotLight = function (a, b, c, d, e) {
  THREE.Light.call(this, a);
  this.position.set(0, 1, 0);
  this.target = new THREE.Object3D();
  this.intensity = void 0 !== b ? b : 1;
  this.distance = void 0 !== c ? c : 0;
  this.angle = void 0 !== d ? d : Math.PI / 3;
  this.exponent = void 0 !== e ? e : 10;
  this.onlyShadow = this.castShadow = !1;
  this.shadowCameraNear = 50;
  this.shadowCameraFar = 5000;
  this.shadowCameraFov = 50;
  this.shadowCameraVisible = !1;
  this.shadowBias = 0;
  this.shadowDarkness = 0.5;
  this.shadowMapHeight = this.shadowMapWidth = 512;
  this.shadowMatrix = this.shadowCamera = this.shadowMapSize = this.shadowMap = null;
};
THREE.SpotLight.prototype = Object.create(THREE.Light.prototype);
THREE.SpotLight.prototype.clone = function () {
  var a = new THREE.SpotLight();
  THREE.Light.prototype.clone.call(this, a);
  a.target = this.target.clone();
  a.intensity = this.intensity;
  a.distance = this.distance;
  a.angle = this.angle;
  a.exponent = this.exponent;
  a.castShadow = this.castShadow;
  a.onlyShadow = this.onlyShadow;
  return a;
};
THREE.Loader = function (a) {
  this.statusDomElement = (this.showStatus = a) ? THREE.Loader.prototype.addStatusElement() : null;
  this.onLoadStart = function () {
  };
  this.onLoadProgress = function () {
  };
  this.onLoadComplete = function () {
  };
};
THREE.Loader.prototype = {
  constructor: THREE.Loader,
  crossOrigin: void 0,
  addStatusElement: function () {
    var a = document.createElement('div');
    a.style.position = 'absolute';
    a.style.right = '0px';
    a.style.top = '0px';
    a.style.fontSize = '0.8em';
    a.style.textAlign = 'left';
    a.style.background = 'rgba(0,0,0,0.25)';
    a.style.color = '#fff';
    a.style.width = '120px';
    a.style.padding = '0.5em 0.5em 0.5em 0.5em';
    a.style.zIndex = 1000;
    a.innerHTML = 'Loading ...';
    return a;
  },
  updateProgress: function (a) {
    var b = 'Loaded ', b = a.total ? b + ((100 * a.loaded / a.total).toFixed(0) + '%') : b + ((a.loaded / 1000).toFixed(2) + ' KB');
    this.statusDomElement.innerHTML = b;
  },
  extractUrlBase: function (a) {
    a = a.split('/');
    if (1 === a.length)
      return './';
    a.pop();
    return a.join('/') + '/';
  },
  initMaterials: function (a, b) {
    for (var c = [], d = 0; d < a.length; ++d)
      c[d] = THREE.Loader.prototype.createMaterial(a[d], b);
    return c;
  },
  needsTangents: function (a) {
    for (var b = 0, c = a.length; b < c; b++)
      if (a[b] instanceof THREE.ShaderMaterial)
        return !0;
    return !1;
  },
  createMaterial: function (a, b) {
    function c(a) {
      a = Math.log(a) / Math.LN2;
      return Math.floor(a) == a;
    }
    function d(a) {
      a = Math.log(a) / Math.LN2;
      return Math.pow(2, Math.round(a));
    }
    function e(a, b) {
      var e = new Image();
      e.onload = function () {
        if (c(this.width) && c(this.height))
          a.image = this;
        else {
          var b = d(this.width), e = d(this.height);
          a.image.width = b;
          a.image.height = e;
          a.image.getContext('2d').drawImage(this, 0, 0, b, e);
        }
        a.needsUpdate = !0;
      };
      void 0 !== h.crossOrigin && (e.crossOrigin = h.crossOrigin);
      e.src = b;
    }
    function f(a, c, d, f, g, h, k) {
      var l = /\.dds$/i.test(d), n = b + d;
      if (l) {
        var z = THREE.ImageUtils.loadCompressedTexture(n);
        a[c] = z;
      } else
        z = document.createElement('canvas'), a[c] = new THREE.Texture(z);
      a[c].sourceFile = d;
      f && (a[c].repeat.set(f[0], f[1]), 1 !== f[0] && (a[c].wrapS = THREE.RepeatWrapping), 1 !== f[1] && (a[c].wrapT = THREE.RepeatWrapping));
      g && a[c].offset.set(g[0], g[1]);
      h && (d = {
        repeat: THREE.RepeatWrapping,
        mirror: THREE.MirroredRepeatWrapping
      }, void 0 !== d[h[0]] && (a[c].wrapS = d[h[0]]), void 0 !== d[h[1]] && (a[c].wrapT = d[h[1]]));
      k && (a[c].anisotropy = k);
      l || e(a[c], n);
    }
    function g(a) {
      return (255 * a[0] << 16) + (255 * a[1] << 8) + 255 * a[2];
    }
    var h = this, k = 'MeshLambertMaterial', l = {
        color: 15658734,
        opacity: 1,
        map: null,
        lightMap: null,
        normalMap: null,
        bumpMap: null,
        wireframe: !1
      };
    if (a.shading) {
      var n = a.shading.toLowerCase();
      'phong' === n ? k = 'MeshPhongMaterial' : 'basic' === n && (k = 'MeshBasicMaterial');
    }
    void 0 !== a.blending && void 0 !== THREE[a.blending] && (l.blending = THREE[a.blending]);
    if (void 0 !== a.transparent || 1 > a.opacity)
      l.transparent = a.transparent;
    void 0 !== a.depthTest && (l.depthTest = a.depthTest);
    void 0 !== a.depthWrite && (l.depthWrite = a.depthWrite);
    void 0 !== a.visible && (l.visible = a.visible);
    void 0 !== a.flipSided && (l.side = THREE.BackSide);
    void 0 !== a.doubleSided && (l.side = THREE.DoubleSide);
    void 0 !== a.wireframe && (l.wireframe = a.wireframe);
    void 0 !== a.vertexColors && ('face' === a.vertexColors ? l.vertexColors = THREE.FaceColors : a.vertexColors && (l.vertexColors = THREE.VertexColors));
    a.colorDiffuse ? l.color = g(a.colorDiffuse) : a.DbgColor && (l.color = a.DbgColor);
    a.colorSpecular && (l.specular = g(a.colorSpecular));
    a.colorAmbient && (l.ambient = g(a.colorAmbient));
    a.transparency && (l.opacity = a.transparency);
    a.specularCoef && (l.shininess = a.specularCoef);
    a.mapDiffuse && b && f(l, 'map', a.mapDiffuse, a.mapDiffuseRepeat, a.mapDiffuseOffset, a.mapDiffuseWrap, a.mapDiffuseAnisotropy);
    a.mapLight && b && f(l, 'lightMap', a.mapLight, a.mapLightRepeat, a.mapLightOffset, a.mapLightWrap, a.mapLightAnisotropy);
    a.mapBump && b && f(l, 'bumpMap', a.mapBump, a.mapBumpRepeat, a.mapBumpOffset, a.mapBumpWrap, a.mapBumpAnisotropy);
    a.mapNormal && b && f(l, 'normalMap', a.mapNormal, a.mapNormalRepeat, a.mapNormalOffset, a.mapNormalWrap, a.mapNormalAnisotropy);
    a.mapSpecular && b && f(l, 'specularMap', a.mapSpecular, a.mapSpecularRepeat, a.mapSpecularOffset, a.mapSpecularWrap, a.mapSpecularAnisotropy);
    a.mapBumpScale && (l.bumpScale = a.mapBumpScale);
    a.mapNormal ? (k = THREE.ShaderLib.normalmap, n = THREE.UniformsUtils.clone(k.uniforms), n.tNormal.value = l.normalMap, a.mapNormalFactor && n.uNormalScale.value.set(a.mapNormalFactor, a.mapNormalFactor), l.map && (n.tDiffuse.value = l.map, n.enableDiffuse.value = !0), l.specularMap && (n.tSpecular.value = l.specularMap, n.enableSpecular.value = !0), l.lightMap && (n.tAO.value = l.lightMap, n.enableAO.value = !0), n.diffuse.value.setHex(l.color), n.specular.value.setHex(l.specular), n.ambient.value.setHex(l.ambient), n.shininess.value = l.shininess, void 0 !== l.opacity && (n.opacity.value = l.opacity), k = new THREE.ShaderMaterial({
      fragmentShader: k.fragmentShader,
      vertexShader: k.vertexShader,
      uniforms: n,
      lights: !0,
      fog: !0
    }), l.transparent && (k.transparent = !0)) : k = new THREE[k](l);
    void 0 !== a.DbgName && (k.name = a.DbgName);
    return k;
  }
};
THREE.XHRLoader = function (a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
};
THREE.XHRLoader.prototype = {
  constructor: THREE.XHRLoader,
  load: function (a, b, c, d) {
    var e = this, f = new XMLHttpRequest();
    void 0 !== b && f.addEventListener('load', function (c) {
      b(c.target.responseText);
      e.manager.itemEnd(a);
    }, !1);
    void 0 !== c && f.addEventListener('progress', function (a) {
      c(a);
    }, !1);
    void 0 !== d && f.addEventListener('error', function (a) {
      d(a);
    }, !1);
    void 0 !== this.crossOrigin && (f.crossOrigin = this.crossOrigin);
    f.open('GET', a, !0);
    f.send(null);
    e.manager.itemStart(a);
  },
  setCrossOrigin: function (a) {
    this.crossOrigin = a;
  }
};
THREE.ImageLoader = function (a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
};
THREE.ImageLoader.prototype = {
  constructor: THREE.ImageLoader,
  load: function (a, b, c, d) {
    var e = this, f = document.createElement('img');
    void 0 !== b && f.addEventListener('load', function (c) {
      e.manager.itemEnd(a);
      b(this);
    }, !1);
    void 0 !== c && f.addEventListener('progress', function (a) {
      c(a);
    }, !1);
    void 0 !== d && f.addEventListener('error', function (a) {
      d(a);
    }, !1);
    void 0 !== this.crossOrigin && (f.crossOrigin = this.crossOrigin);
    f.src = a;
    e.manager.itemStart(a);
    return f;
  },
  setCrossOrigin: function (a) {
    this.crossOrigin = a;
  }
};
THREE.JSONLoader = function (a) {
  THREE.Loader.call(this, a);
  this.withCredentials = !1;
};
THREE.JSONLoader.prototype = Object.create(THREE.Loader.prototype);
THREE.JSONLoader.prototype.load = function (a, b, c) {
  c = c && 'string' === typeof c ? c : this.extractUrlBase(a);
  this.onLoadStart();
  this.loadAjaxJSON(this, a, b, c);
};
THREE.JSONLoader.prototype.loadAjaxJSON = function (a, b, c, d, e) {
  var f = new XMLHttpRequest(), g = 0;
  f.onreadystatechange = function () {
    if (f.readyState === f.DONE)
      if (200 === f.status || 0 === f.status) {
        if (f.responseText) {
          var h = JSON.parse(f.responseText);
          if ('scene' === h.metadata.type) {
            console.error('THREE.JSONLoader: "' + b + '" seems to be a Scene. Use THREE.SceneLoader instead.');
            return;
          }
          h = a.parse(h, d);
          c(h.geometry, h.materials);
        } else
          console.error('THREE.JSONLoader: "' + b + '" seems to be unreachable or the file is empty.');
        a.onLoadComplete();
      } else
        console.error('THREE.JSONLoader: Couldn\'t load "' + b + '" (' + f.status + ')');
    else
      f.readyState === f.LOADING ? e && (0 === g && (g = f.getResponseHeader('Content-Length')), e({
        total: g,
        loaded: f.responseText.length
      })) : f.readyState === f.HEADERS_RECEIVED && void 0 !== e && (g = f.getResponseHeader('Content-Length'));
  };
  f.open('GET', b, !0);
  f.withCredentials = this.withCredentials;
  f.send(null);
};
THREE.JSONLoader.prototype.parse = function (a, b) {
  var c = new THREE.Geometry(), d = void 0 !== a.scale ? 1 / a.scale : 1;
  (function (b) {
    var d, g, h, k, l, n, s, r, q, u, p, v, w, t = a.faces;
    n = a.vertices;
    var x = a.normals, z = a.colors, B = 0;
    if (void 0 !== a.uvs) {
      for (d = 0; d < a.uvs.length; d++)
        a.uvs[d].length && B++;
      for (d = 0; d < B; d++)
        c.faceVertexUvs[d] = [];
    }
    k = 0;
    for (l = n.length; k < l;)
      d = new THREE.Vector3(), d.x = n[k++] * b, d.y = n[k++] * b, d.z = n[k++] * b, c.vertices.push(d);
    k = 0;
    for (l = t.length; k < l;)
      if (b = t[k++], q = b & 1, h = b & 2, d = b & 8, s = b & 16, u = b & 32, n = b & 64, b &= 128, q) {
        q = new THREE.Face3();
        q.a = t[k];
        q.b = t[k + 1];
        q.c = t[k + 3];
        p = new THREE.Face3();
        p.a = t[k + 1];
        p.b = t[k + 2];
        p.c = t[k + 3];
        k += 4;
        h && (h = t[k++], q.materialIndex = h, p.materialIndex = h);
        h = c.faces.length;
        if (d)
          for (d = 0; d < B; d++)
            for (v = a.uvs[d], c.faceVertexUvs[d][h] = [], c.faceVertexUvs[d][h + 1] = [], g = 0; 4 > g; g++)
              r = t[k++], w = v[2 * r], r = v[2 * r + 1], w = new THREE.Vector2(w, r), 2 !== g && c.faceVertexUvs[d][h].push(w), 0 !== g && c.faceVertexUvs[d][h + 1].push(w);
        s && (s = 3 * t[k++], q.normal.set(x[s++], x[s++], x[s]), p.normal.copy(q.normal));
        if (u)
          for (d = 0; 4 > d; d++)
            s = 3 * t[k++], u = new THREE.Vector3(x[s++], x[s++], x[s]), 2 !== d && q.vertexNormals.push(u), 0 !== d && p.vertexNormals.push(u);
        n && (n = t[k++], n = z[n], q.color.setHex(n), p.color.setHex(n));
        if (b)
          for (d = 0; 4 > d; d++)
            n = t[k++], n = z[n], 2 !== d && q.vertexColors.push(new THREE.Color(n)), 0 !== d && p.vertexColors.push(new THREE.Color(n));
        c.faces.push(q);
        c.faces.push(p);
      } else {
        q = new THREE.Face3();
        q.a = t[k++];
        q.b = t[k++];
        q.c = t[k++];
        h && (h = t[k++], q.materialIndex = h);
        h = c.faces.length;
        if (d)
          for (d = 0; d < B; d++)
            for (v = a.uvs[d], c.faceVertexUvs[d][h] = [], g = 0; 3 > g; g++)
              r = t[k++], w = v[2 * r], r = v[2 * r + 1], w = new THREE.Vector2(w, r), c.faceVertexUvs[d][h].push(w);
        s && (s = 3 * t[k++], q.normal.set(x[s++], x[s++], x[s]));
        if (u)
          for (d = 0; 3 > d; d++)
            s = 3 * t[k++], u = new THREE.Vector3(x[s++], x[s++], x[s]), q.vertexNormals.push(u);
        n && (n = t[k++], q.color.setHex(z[n]));
        if (b)
          for (d = 0; 3 > d; d++)
            n = t[k++], q.vertexColors.push(new THREE.Color(z[n]));
        c.faces.push(q);
      }
  }(d));
  (function () {
    if (a.skinWeights)
      for (var b = 0, d = a.skinWeights.length; b < d; b += 2)
        c.skinWeights.push(new THREE.Vector4(a.skinWeights[b], a.skinWeights[b + 1], 0, 0));
    if (a.skinIndices)
      for (b = 0, d = a.skinIndices.length; b < d; b += 2)
        c.skinIndices.push(new THREE.Vector4(a.skinIndices[b], a.skinIndices[b + 1], 0, 0));
    c.bones = a.bones;
    c.bones && 0 < c.bones.length && (c.skinWeights.length !== c.skinIndices.length || c.skinIndices.length !== c.vertices.length) && console.warn('When skinning, number of vertices (' + c.vertices.length + '), skinIndices (' + c.skinIndices.length + '), and skinWeights (' + c.skinWeights.length + ') should match.');
    c.animation = a.animation;
    c.animations = a.animations;
  }());
  (function (b) {
    if (void 0 !== a.morphTargets) {
      var d, g, h, k, l, n;
      d = 0;
      for (g = a.morphTargets.length; d < g; d++)
        for (c.morphTargets[d] = {}, c.morphTargets[d].name = a.morphTargets[d].name, c.morphTargets[d].vertices = [], l = c.morphTargets[d].vertices, n = a.morphTargets[d].vertices, h = 0, k = n.length; h < k; h += 3) {
          var s = new THREE.Vector3();
          s.x = n[h] * b;
          s.y = n[h + 1] * b;
          s.z = n[h + 2] * b;
          l.push(s);
        }
    }
    if (void 0 !== a.morphColors)
      for (d = 0, g = a.morphColors.length; d < g; d++)
        for (c.morphColors[d] = {}, c.morphColors[d].name = a.morphColors[d].name, c.morphColors[d].colors = [], k = c.morphColors[d].colors, l = a.morphColors[d].colors, b = 0, h = l.length; b < h; b += 3)
          n = new THREE.Color(16755200), n.setRGB(l[b], l[b + 1], l[b + 2]), k.push(n);
  }(d));
  c.computeCentroids();
  c.computeFaceNormals();
  c.computeBoundingSphere();
  if (void 0 === a.materials)
    return { geometry: c };
  d = this.initMaterials(a.materials, b);
  this.needsTangents(d) && c.computeTangents();
  return {
    geometry: c,
    materials: d
  };
};
THREE.LoadingManager = function (a, b, c) {
  var d = this, e = 0, f = 0;
  this.onLoad = a;
  this.onProgress = b;
  this.onError = c;
  this.itemStart = function (a) {
    f++;
  };
  this.itemEnd = function (a) {
    e++;
    if (void 0 !== d.onProgress)
      d.onProgress(a, e, f);
    if (e === f && void 0 !== d.onLoad)
      d.onLoad();
  };
};
THREE.DefaultLoadingManager = new THREE.LoadingManager();
THREE.BufferGeometryLoader = function (a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
};
THREE.BufferGeometryLoader.prototype = {
  constructor: THREE.BufferGeometryLoader,
  load: function (a, b, c, d) {
    var e = this;
    c = new THREE.XHRLoader();
    c.setCrossOrigin(this.crossOrigin);
    c.load(a, function (a) {
      b(e.parse(JSON.parse(a)));
    });
  },
  setCrossOrigin: function (a) {
    this.crossOrigin = a;
  },
  parse: function (a) {
    var b = new THREE.BufferGeometry(), c = a.attributes, d = a.offsets;
    a = a.boundingSphere;
    for (var e in c) {
      var f = c[e];
      b.attributes[e] = {
        itemSize: f.itemSize,
        array: new self[f.type](f.array)
      };
    }
    void 0 !== d && (b.offsets = JSON.parse(JSON.stringify(d)));
    void 0 !== a && (b.boundingSphere = new THREE.Sphere(new THREE.Vector3().fromArray(void 0 !== a.center ? a.center : [
      0,
      0,
      0
    ]), a.radius));
    return b;
  }
};
THREE.Geometry2Loader = function (a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
};
THREE.Geometry2Loader.prototype = {
  constructor: THREE.Geometry2Loader,
  load: function (a, b, c, d) {
    var e = this;
    c = new THREE.XHRLoader();
    c.setCrossOrigin(this.crossOrigin);
    c.load(a, function (a) {
      b(e.parse(JSON.parse(a)));
    });
  },
  setCrossOrigin: function (a) {
    this.crossOrigin = a;
  },
  parse: function (a) {
    var b = new THREE.Geometry2(a.vertices.length / 3), c = [
        'vertices',
        'normals',
        'uvs'
      ], d = a.boundingSphere, e;
    for (e in c) {
      var f = c[e];
      b[f].set(a[f]);
    }
    void 0 !== d && (b.boundingSphere = new THREE.Sphere(new THREE.Vector3().fromArray(void 0 !== d.center ? d.center : [
      0,
      0,
      0
    ]), d.radius));
    return b;
  }
};
THREE.MaterialLoader = function (a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
};
THREE.MaterialLoader.prototype = {
  constructor: THREE.MaterialLoader,
  load: function (a, b, c, d) {
    var e = this;
    c = new THREE.XHRLoader();
    c.setCrossOrigin(this.crossOrigin);
    c.load(a, function (a) {
      b(e.parse(JSON.parse(a)));
    });
  },
  setCrossOrigin: function (a) {
    this.crossOrigin = a;
  },
  parse: function (a) {
    var b = new THREE[a.type]();
    void 0 !== a.color && b.color.setHex(a.color);
    void 0 !== a.ambient && b.ambient.setHex(a.ambient);
    void 0 !== a.emissive && b.emissive.setHex(a.emissive);
    void 0 !== a.specular && b.specular.setHex(a.specular);
    void 0 !== a.shininess && (b.shininess = a.shininess);
    void 0 !== a.vertexColors && (b.vertexColors = a.vertexColors);
    void 0 !== a.blending && (b.blending = a.blending);
    void 0 !== a.side && (b.side = a.side);
    void 0 !== a.opacity && (b.opacity = a.opacity);
    void 0 !== a.transparent && (b.transparent = a.transparent);
    void 0 !== a.wireframe && (b.wireframe = a.wireframe);
    if (void 0 !== a.materials)
      for (var c = 0, d = a.materials.length; c < d; c++)
        b.materials.push(this.parse(a.materials[c]));
    return b;
  }
};
THREE.ObjectLoader = function (a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
};
THREE.ObjectLoader.prototype = {
  constructor: THREE.ObjectLoader,
  load: function (a, b, c, d) {
    var e = this;
    c = new THREE.XHRLoader(e.manager);
    c.setCrossOrigin(this.crossOrigin);
    c.load(a, function (a) {
      b(e.parse(JSON.parse(a)));
    });
  },
  setCrossOrigin: function (a) {
    this.crossOrigin = a;
  },
  parse: function (a) {
    var b = this.parseGeometries(a.geometries), c = this.parseMaterials(a.materials);
    return this.parseObject(a.object, b, c);
  },
  parseGeometries: function (a) {
    var b = {};
    if (void 0 !== a)
      for (var c = new THREE.JSONLoader(), d = new THREE.Geometry2Loader(), e = new THREE.BufferGeometryLoader(), f = 0, g = a.length; f < g; f++) {
        var h, k = a[f];
        switch (k.type) {
        case 'PlaneGeometry':
          h = new THREE.PlaneGeometry(k.width, k.height, k.widthSegments, k.heightSegments);
          break;
        case 'BoxGeometry':
        case 'CubeGeometry':
          h = new THREE.BoxGeometry(k.width, k.height, k.depth, k.widthSegments, k.heightSegments, k.depthSegments);
          break;
        case 'CircleGeometry':
          h = new THREE.CircleGeometry(k.radius, k.segments);
          break;
        case 'CylinderGeometry':
          h = new THREE.CylinderGeometry(k.radiusTop, k.radiusBottom, k.height, k.radialSegments, k.heightSegments, k.openEnded);
          break;
        case 'SphereGeometry':
          h = new THREE.SphereGeometry(k.radius, k.widthSegments, k.heightSegments, k.phiStart, k.phiLength, k.thetaStart, k.thetaLength);
          break;
        case 'IcosahedronGeometry':
          h = new THREE.IcosahedronGeometry(k.radius, k.detail);
          break;
        case 'TorusGeometry':
          h = new THREE.TorusGeometry(k.radius, k.tube, k.radialSegments, k.tubularSegments, k.arc);
          break;
        case 'TorusKnotGeometry':
          h = new THREE.TorusKnotGeometry(k.radius, k.tube, k.radialSegments, k.tubularSegments, k.p, k.q, k.heightScale);
          break;
        case 'BufferGeometry':
          h = e.parse(k.data);
          break;
        case 'Geometry2':
          h = d.parse(k.data);
          break;
        case 'Geometry':
          h = c.parse(k.data).geometry;
        }
        h.uuid = k.uuid;
        void 0 !== k.name && (h.name = k.name);
        b[k.uuid] = h;
      }
    return b;
  },
  parseMaterials: function (a) {
    var b = {};
    if (void 0 !== a)
      for (var c = new THREE.MaterialLoader(), d = 0, e = a.length; d < e; d++) {
        var f = a[d], g = c.parse(f);
        g.uuid = f.uuid;
        void 0 !== f.name && (g.name = f.name);
        b[f.uuid] = g;
      }
    return b;
  },
  parseObject: function () {
    var a = new THREE.Matrix4();
    return function (b, c, d) {
      var e;
      switch (b.type) {
      case 'Scene':
        e = new THREE.Scene();
        break;
      case 'PerspectiveCamera':
        e = new THREE.PerspectiveCamera(b.fov, b.aspect, b.near, b.far);
        break;
      case 'OrthographicCamera':
        e = new THREE.OrthographicCamera(b.left, b.right, b.top, b.bottom, b.near, b.far);
        break;
      case 'AmbientLight':
        e = new THREE.AmbientLight(b.color);
        break;
      case 'DirectionalLight':
        e = new THREE.DirectionalLight(b.color, b.intensity);
        break;
      case 'PointLight':
        e = new THREE.PointLight(b.color, b.intensity, b.distance);
        break;
      case 'SpotLight':
        e = new THREE.SpotLight(b.color, b.intensity, b.distance, b.angle, b.exponent);
        break;
      case 'HemisphereLight':
        e = new THREE.HemisphereLight(b.color, b.groundColor, b.intensity);
        break;
      case 'Mesh':
        e = c[b.geometry];
        var f = d[b.material];
        void 0 === e && console.error('THREE.ObjectLoader: Undefined geometry ' + b.geometry);
        void 0 === f && console.error('THREE.ObjectLoader: Undefined material ' + b.material);
        e = new THREE.Mesh(e, f);
        break;
      case 'Sprite':
        f = d[b.material];
        void 0 === f && console.error('THREE.ObjectLoader: Undefined material ' + b.material);
        e = new THREE.Sprite(f);
        break;
      default:
        e = new THREE.Object3D();
      }
      e.uuid = b.uuid;
      void 0 !== b.name && (e.name = b.name);
      void 0 !== b.matrix ? (a.fromArray(b.matrix), a.decompose(e.position, e.quaternion, e.scale)) : (void 0 !== b.position && e.position.fromArray(b.position), void 0 !== b.rotation && e.rotation.fromArray(b.rotation), void 0 !== b.scale && e.scale.fromArray(b.scale));
      void 0 !== b.visible && (e.visible = b.visible);
      void 0 !== b.userData && (e.userData = b.userData);
      if (void 0 !== b.children)
        for (var g in b.children)
          e.add(this.parseObject(b.children[g], c, d));
      return e;
    };
  }()
};
THREE.SceneLoader = function () {
  this.onLoadStart = function () {
  };
  this.onLoadProgress = function () {
  };
  this.onLoadComplete = function () {
  };
  this.callbackSync = function () {
  };
  this.callbackProgress = function () {
  };
  this.geometryHandlers = {};
  this.hierarchyHandlers = {};
  this.addGeometryHandler('ascii', THREE.JSONLoader);
};
THREE.SceneLoader.prototype = {
  constructor: THREE.SceneLoader,
  load: function (a, b, c, d) {
    var e = this;
    c = new THREE.XHRLoader(e.manager);
    c.setCrossOrigin(this.crossOrigin);
    c.load(a, function (c) {
      e.parse(JSON.parse(c), b, a);
    });
  },
  setCrossOrigin: function (a) {
    this.crossOrigin = a;
  },
  addGeometryHandler: function (a, b) {
    this.geometryHandlers[a] = { loaderClass: b };
  },
  addHierarchyHandler: function (a, b) {
    this.hierarchyHandlers[a] = { loaderClass: b };
  },
  parse: function (a, b, c) {
    function d(a, b) {
      return 'relativeToHTML' == b ? a : q + a;
    }
    function e() {
      f(D.scene, I.objects);
    }
    function f(a, b) {
      var c, e, g, h, l, n;
      for (n in b) {
        var s = D.objects[n], q = b[n];
        if (void 0 === s) {
          if (q.type && q.type in r.hierarchyHandlers) {
            if (void 0 === q.loading) {
              c = {
                type: 1,
                url: 1,
                material: 1,
                position: 1,
                rotation: 1,
                scale: 1,
                visible: 1,
                children: 1,
                userData: 1,
                skin: 1,
                morph: 1,
                mirroredLoop: 1,
                duration: 1
              };
              var t = {}, w;
              for (w in q)
                w in c || (t[w] = q[w]);
              p = D.materials[q.material];
              q.loading = !0;
              c = r.hierarchyHandlers[q.type].loaderObject;
              c.options ? c.load(d(q.url, I.urlBaseType), k(n, a, p, q)) : c.load(d(q.url, I.urlBaseType), k(n, a, p, q), t);
            }
          } else if (void 0 !== q.geometry) {
            if (u = D.geometries[q.geometry]) {
              s = !1;
              p = D.materials[q.material];
              s = p instanceof THREE.ShaderMaterial;
              e = q.position;
              g = q.rotation;
              h = q.scale;
              c = q.matrix;
              l = q.quaternion;
              q.material || (p = new THREE.MeshFaceMaterial(D.face_materials[q.geometry]));
              p instanceof THREE.MeshFaceMaterial && 0 === p.materials.length && (p = new THREE.MeshFaceMaterial(D.face_materials[q.geometry]));
              if (p instanceof THREE.MeshFaceMaterial)
                for (t = 0; t < p.materials.length; t++)
                  s = s || p.materials[t] instanceof THREE.ShaderMaterial;
              s && u.computeTangents();
              q.skin ? s = new THREE.SkinnedMesh(u, p) : q.morph ? (s = new THREE.MorphAnimMesh(u, p), void 0 !== q.duration && (s.duration = q.duration), void 0 !== q.time && (s.time = q.time), void 0 !== q.mirroredLoop && (s.mirroredLoop = q.mirroredLoop), p.morphNormals && u.computeMorphNormals()) : s = new THREE.Mesh(u, p);
              s.name = n;
              c ? (s.matrixAutoUpdate = !1, s.matrix.set(c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7], c[8], c[9], c[10], c[11], c[12], c[13], c[14], c[15])) : (s.position.fromArray(e), l ? s.quaternion.fromArray(l) : s.rotation.fromArray(g), s.scale.fromArray(h));
              s.visible = q.visible;
              s.castShadow = q.castShadow;
              s.receiveShadow = q.receiveShadow;
              a.add(s);
              D.objects[n] = s;
            }
          } else if ('AmbientLight' === q.type || 'PointLight' === q.type || 'DirectionalLight' === q.type || 'SpotLight' === q.type || 'HemisphereLight' === q.type || 'AreaLight' === q.type) {
            t = q.color;
            c = q.intensity;
            e = q.distance;
            g = q.position;
            h = q.rotation;
            switch (q.type) {
            case 'AmbientLight':
              x = new THREE.AmbientLight(t);
              break;
            case 'PointLight':
              x = new THREE.PointLight(t, c, e);
              x.position.fromArray(g);
              break;
            case 'DirectionalLight':
              x = new THREE.DirectionalLight(t, c);
              x.position.fromArray(q.direction);
              break;
            case 'SpotLight':
              x = new THREE.SpotLight(t, c, e, 1);
              x.angle = q.angle;
              x.position.fromArray(g);
              x.target.set(g[0], g[1] - e, g[2]);
              x.target.applyEuler(new THREE.Euler(h[0], h[1], h[2], 'XYZ'));
              break;
            case 'HemisphereLight':
              x = new THREE.DirectionalLight(t, c, e);
              x.target.set(g[0], g[1] - e, g[2]);
              x.target.applyEuler(new THREE.Euler(h[0], h[1], h[2], 'XYZ'));
              break;
            case 'AreaLight':
              x = new THREE.AreaLight(t, c), x.position.fromArray(g), x.width = q.size, x.height = q.size_y;
            }
            a.add(x);
            x.name = n;
            D.lights[n] = x;
            D.objects[n] = x;
          } else
            'PerspectiveCamera' === q.type || 'OrthographicCamera' === q.type ? (e = q.position, g = q.rotation, l = q.quaternion, 'PerspectiveCamera' === q.type ? v = new THREE.PerspectiveCamera(q.fov, q.aspect, q.near, q.far) : 'OrthographicCamera' === q.type && (v = new THREE.OrthographicCamera(q.left, q.right, q.top, q.bottom, q.near, q.far)), v.name = n, v.position.fromArray(e), void 0 !== l ? v.quaternion.fromArray(l) : void 0 !== g && v.rotation.fromArray(g), a.add(v), D.cameras[n] = v, D.objects[n] = v) : (e = q.position, g = q.rotation, h = q.scale, l = q.quaternion, s = new THREE.Object3D(), s.name = n, s.position.fromArray(e), l ? s.quaternion.fromArray(l) : s.rotation.fromArray(g), s.scale.fromArray(h), s.visible = void 0 !== q.visible ? q.visible : !1, a.add(s), D.objects[n] = s, D.empties[n] = s);
          if (s) {
            if (void 0 !== q.userData)
              for (var z in q.userData)
                s.userData[z] = q.userData[z];
            if (void 0 !== q.groups)
              for (t = 0; t < q.groups.length; t++)
                c = q.groups[t], void 0 === D.groups[c] && (D.groups[c] = []), D.groups[c].push(n);
          }
        }
        void 0 !== s && void 0 !== q.children && f(s, q.children);
      }
    }
    function g(a, b, c, d, f) {
      var g = f.rotation, h = f.quaternion, k = f.scale;
      a.position.fromArray(f.position);
      h ? a.quaternion.fromArray(h) : a.rotation.fromArray(g);
      a.scale.fromArray(k);
      d && a.traverse(function (a) {
        a.material = d;
      });
      var l = void 0 !== f.visible ? f.visible : !0;
      a.traverse(function (a) {
        a.visible = l;
      });
      c.add(a);
      a.name = b;
      D.objects[b] = a;
      e();
    }
    function h(a) {
      return function (b, c) {
        b.name = a;
        D.geometries[a] = b;
        D.face_materials[a] = c;
        e();
        z -= 1;
        r.onLoadComplete();
        n();
      };
    }
    function k(a, b, c, d) {
      return function (e) {
        g(e.content ? e.content : e.dae ? e.scene : e, a, b, c, d);
        z -= 1;
        r.onLoadComplete();
        n();
      };
    }
    function l(a) {
      return function (b, c) {
        b.name = a;
        D.geometries[a] = b;
        D.face_materials[a] = c;
      };
    }
    function n() {
      r.callbackProgress({
        totalModels: E,
        totalTextures: H,
        loadedModels: E - z,
        loadedTextures: H - B
      }, D);
      r.onLoadProgress();
      if (0 === z && 0 === B) {
        for (var a = 0; a < G.length; a++) {
          var c = G[a], d = D.objects[c.targetName];
          d ? c.object.target = d : (c.object.target = new THREE.Object3D(), D.scene.add(c.object.target));
          c.object.target.userData.targetInverse = c.object;
        }
        b(D);
      }
    }
    function s(a, b) {
      b(a);
      if (void 0 !== a.children)
        for (var c in a.children)
          s(a.children[c], b);
    }
    var r = this, q = THREE.Loader.prototype.extractUrlBase(c), u, p, v, w, t, x, z, B, E, H, D, G = [], I = a, O;
    for (O in this.geometryHandlers)
      a = this.geometryHandlers[O].loaderClass, this.geometryHandlers[O].loaderObject = new a();
    for (O in this.hierarchyHandlers)
      a = this.hierarchyHandlers[O].loaderClass, this.hierarchyHandlers[O].loaderObject = new a();
    B = z = 0;
    D = {
      scene: new THREE.Scene(),
      geometries: {},
      face_materials: {},
      materials: {},
      textures: {},
      objects: {},
      cameras: {},
      lights: {},
      fogs: {},
      empties: {},
      groups: {}
    };
    I.transform && (O = I.transform.position, a = I.transform.rotation, c = I.transform.scale, O && D.scene.position.fromArray(O), a && D.scene.rotation.fromArray(a), c && D.scene.scale.fromArray(c), O || a || c) && (D.scene.updateMatrix(), D.scene.updateMatrixWorld());
    O = function (a) {
      return function () {
        B -= a;
        n();
        r.onLoadComplete();
      };
    };
    for (var K in I.fogs)
      a = I.fogs[K], 'linear' === a.type ? w = new THREE.Fog(0, a.near, a.far) : 'exp2' === a.type && (w = new THREE.FogExp2(0, a.density)), a = a.color, w.color.setRGB(a[0], a[1], a[2]), D.fogs[K] = w;
    for (var y in I.geometries)
      w = I.geometries[y], w.type in this.geometryHandlers && (z += 1, r.onLoadStart());
    for (var F in I.objects)
      s(I.objects[F], function (a) {
        a.type && a.type in r.hierarchyHandlers && (z += 1, r.onLoadStart());
      });
    E = z;
    for (y in I.geometries)
      if (w = I.geometries[y], 'cube' === w.type)
        u = new THREE.BoxGeometry(w.width, w.height, w.depth, w.widthSegments, w.heightSegments, w.depthSegments), u.name = y, D.geometries[y] = u;
      else if ('plane' === w.type)
        u = new THREE.PlaneGeometry(w.width, w.height, w.widthSegments, w.heightSegments), u.name = y, D.geometries[y] = u;
      else if ('sphere' === w.type)
        u = new THREE.SphereGeometry(w.radius, w.widthSegments, w.heightSegments), u.name = y, D.geometries[y] = u;
      else if ('cylinder' === w.type)
        u = new THREE.CylinderGeometry(w.topRad, w.botRad, w.height, w.radSegs, w.heightSegs), u.name = y, D.geometries[y] = u;
      else if ('torus' === w.type)
        u = new THREE.TorusGeometry(w.radius, w.tube, w.segmentsR, w.segmentsT), u.name = y, D.geometries[y] = u;
      else if ('icosahedron' === w.type)
        u = new THREE.IcosahedronGeometry(w.radius, w.subdivisions), u.name = y, D.geometries[y] = u;
      else if (w.type in this.geometryHandlers) {
        F = {};
        for (t in w)
          'type' !== t && 'url' !== t && (F[t] = w[t]);
        this.geometryHandlers[w.type].loaderObject.load(d(w.url, I.urlBaseType), h(y), F);
      } else
        'embedded' === w.type && (F = I.embeds[w.id], F.metadata = I.metadata, F && (F = this.geometryHandlers.ascii.loaderObject.parse(F, ''), l(y)(F.geometry, F.materials)));
    for (var C in I.textures)
      if (y = I.textures[C], y.url instanceof Array)
        for (B += y.url.length, t = 0; t < y.url.length; t++)
          r.onLoadStart();
      else
        B += 1, r.onLoadStart();
    H = B;
    for (C in I.textures) {
      y = I.textures[C];
      void 0 !== y.mapping && void 0 !== THREE[y.mapping] && (y.mapping = new THREE[y.mapping]());
      if (y.url instanceof Array) {
        F = y.url.length;
        w = [];
        for (t = 0; t < F; t++)
          w[t] = d(y.url[t], I.urlBaseType);
        t = (t = /\.dds$/i.test(w[0])) ? THREE.ImageUtils.loadCompressedTextureCube(w, y.mapping, O(F)) : THREE.ImageUtils.loadTextureCube(w, y.mapping, O(F));
      } else
        t = /\.dds$/i.test(y.url), F = d(y.url, I.urlBaseType), w = O(1), t = t ? THREE.ImageUtils.loadCompressedTexture(F, y.mapping, w) : THREE.ImageUtils.loadTexture(F, y.mapping, w), void 0 !== THREE[y.minFilter] && (t.minFilter = THREE[y.minFilter]), void 0 !== THREE[y.magFilter] && (t.magFilter = THREE[y.magFilter]), y.anisotropy && (t.anisotropy = y.anisotropy), y.repeat && (t.repeat.set(y.repeat[0], y.repeat[1]), 1 !== y.repeat[0] && (t.wrapS = THREE.RepeatWrapping), 1 !== y.repeat[1] && (t.wrapT = THREE.RepeatWrapping)), y.offset && t.offset.set(y.offset[0], y.offset[1]), y.wrap && (F = {
          repeat: THREE.RepeatWrapping,
          mirror: THREE.MirroredRepeatWrapping
        }, void 0 !== F[y.wrap[0]] && (t.wrapS = F[y.wrap[0]]), void 0 !== F[y.wrap[1]] && (t.wrapT = F[y.wrap[1]]));
      D.textures[C] = t;
    }
    var A, L;
    for (A in I.materials) {
      C = I.materials[A];
      for (L in C.parameters)
        'envMap' === L || 'map' === L || 'lightMap' === L || 'bumpMap' === L ? C.parameters[L] = D.textures[C.parameters[L]] : 'shading' === L ? C.parameters[L] = 'flat' === C.parameters[L] ? THREE.FlatShading : THREE.SmoothShading : 'side' === L ? C.parameters[L] = 'double' == C.parameters[L] ? THREE.DoubleSide : 'back' == C.parameters[L] ? THREE.BackSide : THREE.FrontSide : 'blending' === L ? C.parameters[L] = C.parameters[L] in THREE ? THREE[C.parameters[L]] : THREE.NormalBlending : 'combine' === L ? C.parameters[L] = C.parameters[L] in THREE ? THREE[C.parameters[L]] : THREE.MultiplyOperation : 'vertexColors' === L ? 'face' == C.parameters[L] ? C.parameters[L] = THREE.FaceColors : C.parameters[L] && (C.parameters[L] = THREE.VertexColors) : 'wrapRGB' === L && (O = C.parameters[L], C.parameters[L] = new THREE.Vector3(O[0], O[1], O[2]));
      void 0 !== C.parameters.opacity && 1 > C.parameters.opacity && (C.parameters.transparent = !0);
      C.parameters.normalMap ? (O = THREE.ShaderLib.normalmap, y = THREE.UniformsUtils.clone(O.uniforms), t = C.parameters.color, F = C.parameters.specular, w = C.parameters.ambient, K = C.parameters.shininess, y.tNormal.value = D.textures[C.parameters.normalMap], C.parameters.normalScale && y.uNormalScale.value.set(C.parameters.normalScale[0], C.parameters.normalScale[1]), C.parameters.map && (y.tDiffuse.value = C.parameters.map, y.enableDiffuse.value = !0), C.parameters.envMap && (y.tCube.value = C.parameters.envMap, y.enableReflection.value = !0, y.reflectivity.value = C.parameters.reflectivity), C.parameters.lightMap && (y.tAO.value = C.parameters.lightMap, y.enableAO.value = !0), C.parameters.specularMap && (y.tSpecular.value = D.textures[C.parameters.specularMap], y.enableSpecular.value = !0), C.parameters.displacementMap && (y.tDisplacement.value = D.textures[C.parameters.displacementMap], y.enableDisplacement.value = !0, y.uDisplacementBias.value = C.parameters.displacementBias, y.uDisplacementScale.value = C.parameters.displacementScale), y.diffuse.value.setHex(t), y.specular.value.setHex(F), y.ambient.value.setHex(w), y.shininess.value = K, C.parameters.opacity && (y.opacity.value = C.parameters.opacity), p = new THREE.ShaderMaterial({
        fragmentShader: O.fragmentShader,
        vertexShader: O.vertexShader,
        uniforms: y,
        lights: !0,
        fog: !0
      })) : p = new THREE[C.type](C.parameters);
      p.name = A;
      D.materials[A] = p;
    }
    for (A in I.materials)
      if (C = I.materials[A], C.parameters.materials) {
        L = [];
        for (t = 0; t < C.parameters.materials.length; t++)
          L.push(D.materials[C.parameters.materials[t]]);
        D.materials[A].materials = L;
      }
    e();
    D.cameras && I.defaults.camera && (D.currentCamera = D.cameras[I.defaults.camera]);
    D.fogs && I.defaults.fog && (D.scene.fog = D.fogs[I.defaults.fog]);
    r.callbackSync(D);
    n();
  }
};
THREE.TextureLoader = function (a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
};
THREE.TextureLoader.prototype = {
  constructor: THREE.TextureLoader,
  load: function (a, b, c, d) {
    c = new THREE.ImageLoader(this.manager);
    c.setCrossOrigin(this.crossOrigin);
    c.load(a, function (a) {
      a = new THREE.Texture(a);
      a.needsUpdate = !0;
      void 0 !== b && b(a);
    });
  },
  setCrossOrigin: function (a) {
    this.crossOrigin = a;
  }
};
THREE.Material = function () {
  this.id = THREE.MaterialIdCount++;
  this.uuid = THREE.Math.generateUUID();
  this.name = '';
  this.side = THREE.FrontSide;
  this.opacity = 1;
  this.transparent = !1;
  this.blending = THREE.NormalBlending;
  this.blendSrc = THREE.SrcAlphaFactor;
  this.blendDst = THREE.OneMinusSrcAlphaFactor;
  this.blendEquation = THREE.AddEquation;
  this.depthWrite = this.depthTest = !0;
  this.polygonOffset = !1;
  this.overdraw = this.alphaTest = this.polygonOffsetUnits = this.polygonOffsetFactor = 0;
  this.needsUpdate = this.visible = !0;
};
THREE.Material.prototype = {
  constructor: THREE.Material,
  setValues: function (a) {
    if (void 0 !== a)
      for (var b in a) {
        var c = a[b];
        if (void 0 === c)
          console.warn('THREE.Material: \'' + b + '\' parameter is undefined.');
        else if (b in this) {
          var d = this[b];
          d instanceof THREE.Color ? d.set(c) : d instanceof THREE.Vector3 && c instanceof THREE.Vector3 ? d.copy(c) : this[b] = 'overdraw' == b ? Number(c) : c;
        }
      }
  },
  clone: function (a) {
    void 0 === a && (a = new THREE.Material());
    a.name = this.name;
    a.side = this.side;
    a.opacity = this.opacity;
    a.transparent = this.transparent;
    a.blending = this.blending;
    a.blendSrc = this.blendSrc;
    a.blendDst = this.blendDst;
    a.blendEquation = this.blendEquation;
    a.depthTest = this.depthTest;
    a.depthWrite = this.depthWrite;
    a.polygonOffset = this.polygonOffset;
    a.polygonOffsetFactor = this.polygonOffsetFactor;
    a.polygonOffsetUnits = this.polygonOffsetUnits;
    a.alphaTest = this.alphaTest;
    a.overdraw = this.overdraw;
    a.visible = this.visible;
    return a;
  },
  dispose: function () {
    this.dispatchEvent({ type: 'dispose' });
  }
};
THREE.EventDispatcher.prototype.apply(THREE.Material.prototype);
THREE.MaterialIdCount = 0;
THREE.LineBasicMaterial = function (a) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.linewidth = 1;
  this.linejoin = this.linecap = 'round';
  this.vertexColors = !1;
  this.fog = !0;
  this.setValues(a);
};
THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.LineBasicMaterial.prototype.clone = function () {
  var a = new THREE.LineBasicMaterial();
  THREE.Material.prototype.clone.call(this, a);
  a.color.copy(this.color);
  a.linewidth = this.linewidth;
  a.linecap = this.linecap;
  a.linejoin = this.linejoin;
  a.vertexColors = this.vertexColors;
  a.fog = this.fog;
  return a;
};
THREE.LineDashedMaterial = function (a) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.scale = this.linewidth = 1;
  this.dashSize = 3;
  this.gapSize = 1;
  this.vertexColors = !1;
  this.fog = !0;
  this.setValues(a);
};
THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.LineDashedMaterial.prototype.clone = function () {
  var a = new THREE.LineDashedMaterial();
  THREE.Material.prototype.clone.call(this, a);
  a.color.copy(this.color);
  a.linewidth = this.linewidth;
  a.scale = this.scale;
  a.dashSize = this.dashSize;
  a.gapSize = this.gapSize;
  a.vertexColors = this.vertexColors;
  a.fog = this.fog;
  return a;
};
THREE.MeshBasicMaterial = function (a) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.envMap = this.specularMap = this.lightMap = this.map = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.fog = !0;
  this.shading = THREE.SmoothShading;
  this.wireframe = !1;
  this.wireframeLinewidth = 1;
  this.wireframeLinejoin = this.wireframeLinecap = 'round';
  this.vertexColors = THREE.NoColors;
  this.morphTargets = this.skinning = !1;
  this.setValues(a);
};
THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshBasicMaterial.prototype.clone = function () {
  var a = new THREE.MeshBasicMaterial();
  THREE.Material.prototype.clone.call(this, a);
  a.color.copy(this.color);
  a.map = this.map;
  a.lightMap = this.lightMap;
  a.specularMap = this.specularMap;
  a.envMap = this.envMap;
  a.combine = this.combine;
  a.reflectivity = this.reflectivity;
  a.refractionRatio = this.refractionRatio;
  a.fog = this.fog;
  a.shading = this.shading;
  a.wireframe = this.wireframe;
  a.wireframeLinewidth = this.wireframeLinewidth;
  a.wireframeLinecap = this.wireframeLinecap;
  a.wireframeLinejoin = this.wireframeLinejoin;
  a.vertexColors = this.vertexColors;
  a.skinning = this.skinning;
  a.morphTargets = this.morphTargets;
  return a;
};
THREE.MeshLambertMaterial = function (a) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.ambient = new THREE.Color(16777215);
  this.emissive = new THREE.Color(0);
  this.wrapAround = !1;
  this.wrapRGB = new THREE.Vector3(1, 1, 1);
  this.envMap = this.specularMap = this.lightMap = this.map = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.fog = !0;
  this.shading = THREE.SmoothShading;
  this.wireframe = !1;
  this.wireframeLinewidth = 1;
  this.wireframeLinejoin = this.wireframeLinecap = 'round';
  this.vertexColors = THREE.NoColors;
  this.morphNormals = this.morphTargets = this.skinning = !1;
  this.setValues(a);
};
THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshLambertMaterial.prototype.clone = function () {
  var a = new THREE.MeshLambertMaterial();
  THREE.Material.prototype.clone.call(this, a);
  a.color.copy(this.color);
  a.ambient.copy(this.ambient);
  a.emissive.copy(this.emissive);
  a.wrapAround = this.wrapAround;
  a.wrapRGB.copy(this.wrapRGB);
  a.map = this.map;
  a.lightMap = this.lightMap;
  a.specularMap = this.specularMap;
  a.envMap = this.envMap;
  a.combine = this.combine;
  a.reflectivity = this.reflectivity;
  a.refractionRatio = this.refractionRatio;
  a.fog = this.fog;
  a.shading = this.shading;
  a.wireframe = this.wireframe;
  a.wireframeLinewidth = this.wireframeLinewidth;
  a.wireframeLinecap = this.wireframeLinecap;
  a.wireframeLinejoin = this.wireframeLinejoin;
  a.vertexColors = this.vertexColors;
  a.skinning = this.skinning;
  a.morphTargets = this.morphTargets;
  a.morphNormals = this.morphNormals;
  return a;
};
THREE.MeshPhongMaterial = function (a) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.ambient = new THREE.Color(16777215);
  this.emissive = new THREE.Color(0);
  this.specular = new THREE.Color(1118481);
  this.shininess = 30;
  this.wrapAround = this.metal = !1;
  this.wrapRGB = new THREE.Vector3(1, 1, 1);
  this.bumpMap = this.lightMap = this.map = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalScale = new THREE.Vector2(1, 1);
  this.envMap = this.specularMap = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.fog = !0;
  this.shading = THREE.SmoothShading;
  this.wireframe = !1;
  this.wireframeLinewidth = 1;
  this.wireframeLinejoin = this.wireframeLinecap = 'round';
  this.vertexColors = THREE.NoColors;
  this.morphNormals = this.morphTargets = this.skinning = !1;
  this.setValues(a);
};
THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshPhongMaterial.prototype.clone = function () {
  var a = new THREE.MeshPhongMaterial();
  THREE.Material.prototype.clone.call(this, a);
  a.color.copy(this.color);
  a.ambient.copy(this.ambient);
  a.emissive.copy(this.emissive);
  a.specular.copy(this.specular);
  a.shininess = this.shininess;
  a.metal = this.metal;
  a.wrapAround = this.wrapAround;
  a.wrapRGB.copy(this.wrapRGB);
  a.map = this.map;
  a.lightMap = this.lightMap;
  a.bumpMap = this.bumpMap;
  a.bumpScale = this.bumpScale;
  a.normalMap = this.normalMap;
  a.normalScale.copy(this.normalScale);
  a.specularMap = this.specularMap;
  a.envMap = this.envMap;
  a.combine = this.combine;
  a.reflectivity = this.reflectivity;
  a.refractionRatio = this.refractionRatio;
  a.fog = this.fog;
  a.shading = this.shading;
  a.wireframe = this.wireframe;
  a.wireframeLinewidth = this.wireframeLinewidth;
  a.wireframeLinecap = this.wireframeLinecap;
  a.wireframeLinejoin = this.wireframeLinejoin;
  a.vertexColors = this.vertexColors;
  a.skinning = this.skinning;
  a.morphTargets = this.morphTargets;
  a.morphNormals = this.morphNormals;
  return a;
};
THREE.MeshDepthMaterial = function (a) {
  THREE.Material.call(this);
  this.wireframe = !1;
  this.wireframeLinewidth = 1;
  this.setValues(a);
};
THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshDepthMaterial.prototype.clone = function () {
  var a = new THREE.MeshDepthMaterial();
  THREE.Material.prototype.clone.call(this, a);
  a.wireframe = this.wireframe;
  a.wireframeLinewidth = this.wireframeLinewidth;
  return a;
};
THREE.MeshNormalMaterial = function (a) {
  THREE.Material.call(this, a);
  this.shading = THREE.FlatShading;
  this.wireframe = !1;
  this.wireframeLinewidth = 1;
  this.morphTargets = !1;
  this.setValues(a);
};
THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshNormalMaterial.prototype.clone = function () {
  var a = new THREE.MeshNormalMaterial();
  THREE.Material.prototype.clone.call(this, a);
  a.shading = this.shading;
  a.wireframe = this.wireframe;
  a.wireframeLinewidth = this.wireframeLinewidth;
  return a;
};
THREE.MeshFaceMaterial = function (a) {
  this.materials = a instanceof Array ? a : [];
};
THREE.MeshFaceMaterial.prototype.clone = function () {
  for (var a = new THREE.MeshFaceMaterial(), b = 0; b < this.materials.length; b++)
    a.materials.push(this.materials[b].clone());
  return a;
};
THREE.ParticleSystemMaterial = function (a) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.map = null;
  this.size = 1;
  this.sizeAttenuation = !0;
  this.vertexColors = !1;
  this.fog = !0;
  this.setValues(a);
};
THREE.ParticleSystemMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.ParticleSystemMaterial.prototype.clone = function () {
  var a = new THREE.ParticleSystemMaterial();
  THREE.Material.prototype.clone.call(this, a);
  a.color.copy(this.color);
  a.map = this.map;
  a.size = this.size;
  a.sizeAttenuation = this.sizeAttenuation;
  a.vertexColors = this.vertexColors;
  a.fog = this.fog;
  return a;
};
THREE.ParticleBasicMaterial = THREE.ParticleSystemMaterial;
THREE.ShaderMaterial = function (a) {
  THREE.Material.call(this);
  this.vertexShader = this.fragmentShader = 'void main() {}';
  this.uniforms = {};
  this.defines = {};
  this.attributes = null;
  this.shading = THREE.SmoothShading;
  this.linewidth = 1;
  this.wireframe = !1;
  this.wireframeLinewidth = 1;
  this.lights = this.fog = !1;
  this.vertexColors = THREE.NoColors;
  this.morphNormals = this.morphTargets = this.skinning = !1;
  this.defaultAttributeValues = {
    color: [
      1,
      1,
      1
    ],
    uv: [
      0,
      0
    ],
    uv2: [
      0,
      0
    ]
  };
  this.index0AttributeName = 'position';
  this.setValues(a);
};
THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.ShaderMaterial.prototype.clone = function () {
  var a = new THREE.ShaderMaterial();
  THREE.Material.prototype.clone.call(this, a);
  a.fragmentShader = this.fragmentShader;
  a.vertexShader = this.vertexShader;
  a.uniforms = THREE.UniformsUtils.clone(this.uniforms);
  a.attributes = this.attributes;
  a.defines = this.defines;
  a.shading = this.shading;
  a.wireframe = this.wireframe;
  a.wireframeLinewidth = this.wireframeLinewidth;
  a.fog = this.fog;
  a.lights = this.lights;
  a.vertexColors = this.vertexColors;
  a.skinning = this.skinning;
  a.morphTargets = this.morphTargets;
  a.morphNormals = this.morphNormals;
  return a;
};
THREE.SpriteMaterial = function (a) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.map = null;
  this.rotation = 0;
  this.fog = !1;
  this.setValues(a);
};
THREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.SpriteMaterial.prototype.clone = function () {
  var a = new THREE.SpriteMaterial();
  THREE.Material.prototype.clone.call(this, a);
  a.color.copy(this.color);
  a.map = this.map;
  a.rotation = this.rotation;
  a.fog = this.fog;
  return a;
};
THREE.SpriteCanvasMaterial = function (a) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.program = function (a, c) {
  };
  this.setValues(a);
};
THREE.SpriteCanvasMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.SpriteCanvasMaterial.prototype.clone = function () {
  var a = new THREE.SpriteCanvasMaterial();
  THREE.Material.prototype.clone.call(this, a);
  a.color.copy(this.color);
  a.program = this.program;
  return a;
};
THREE.ParticleCanvasMaterial = THREE.SpriteCanvasMaterial;
THREE.Texture = function (a, b, c, d, e, f, g, h, k) {
  this.id = THREE.TextureIdCount++;
  this.uuid = THREE.Math.generateUUID();
  this.name = '';
  this.image = a;
  this.mipmaps = [];
  this.mapping = void 0 !== b ? b : new THREE.UVMapping();
  this.wrapS = void 0 !== c ? c : THREE.ClampToEdgeWrapping;
  this.wrapT = void 0 !== d ? d : THREE.ClampToEdgeWrapping;
  this.magFilter = void 0 !== e ? e : THREE.LinearFilter;
  this.minFilter = void 0 !== f ? f : THREE.LinearMipMapLinearFilter;
  this.anisotropy = void 0 !== k ? k : 1;
  this.format = void 0 !== g ? g : THREE.RGBAFormat;
  this.type = void 0 !== h ? h : THREE.UnsignedByteType;
  this.offset = new THREE.Vector2(0, 0);
  this.repeat = new THREE.Vector2(1, 1);
  this.generateMipmaps = !0;
  this.premultiplyAlpha = !1;
  this.flipY = !0;
  this.unpackAlignment = 4;
  this._needsUpdate = !1;
  this.onUpdate = null;
};
THREE.Texture.prototype = {
  constructor: THREE.Texture,
  get needsUpdate() {
    return this._needsUpdate;
  },
  set needsUpdate(a) {
    !0 === a && this.update();
    this._needsUpdate = a;
  },
  clone: function (a) {
    void 0 === a && (a = new THREE.Texture());
    a.image = this.image;
    a.mipmaps = this.mipmaps.slice(0);
    a.mapping = this.mapping;
    a.wrapS = this.wrapS;
    a.wrapT = this.wrapT;
    a.magFilter = this.magFilter;
    a.minFilter = this.minFilter;
    a.anisotropy = this.anisotropy;
    a.format = this.format;
    a.type = this.type;
    a.offset.copy(this.offset);
    a.repeat.copy(this.repeat);
    a.generateMipmaps = this.generateMipmaps;
    a.premultiplyAlpha = this.premultiplyAlpha;
    a.flipY = this.flipY;
    a.unpackAlignment = this.unpackAlignment;
    return a;
  },
  update: function () {
    this.dispatchEvent({ type: 'update' });
  },
  dispose: function () {
    this.dispatchEvent({ type: 'dispose' });
  }
};
THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype);
THREE.TextureIdCount = 0;
THREE.CompressedTexture = function (a, b, c, d, e, f, g, h, k, l, n) {
  THREE.Texture.call(this, null, f, g, h, k, l, d, e, n);
  this.image = {
    width: b,
    height: c
  };
  this.mipmaps = a;
  this.generateMipmaps = !1;
};
THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.CompressedTexture.prototype.clone = function () {
  var a = new THREE.CompressedTexture();
  THREE.Texture.prototype.clone.call(this, a);
  return a;
};
THREE.DataTexture = function (a, b, c, d, e, f, g, h, k, l, n) {
  THREE.Texture.call(this, null, f, g, h, k, l, d, e, n);
  this.image = {
    data: a,
    width: b,
    height: c
  };
};
THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.DataTexture.prototype.clone = function () {
  var a = new THREE.DataTexture();
  THREE.Texture.prototype.clone.call(this, a);
  return a;
};
THREE.ParticleSystem = function (a, b) {
  THREE.Object3D.call(this);
  this.geometry = void 0 !== a ? a : new THREE.Geometry();
  this.material = void 0 !== b ? b : new THREE.ParticleSystemMaterial({ color: 16777215 * Math.random() });
  this.frustumCulled = this.sortParticles = !1;
};
THREE.ParticleSystem.prototype = Object.create(THREE.Object3D.prototype);
THREE.ParticleSystem.prototype.clone = function (a) {
  void 0 === a && (a = new THREE.ParticleSystem(this.geometry, this.material));
  a.sortParticles = this.sortParticles;
  THREE.Object3D.prototype.clone.call(this, a);
  return a;
};
THREE.Line = function (a, b, c) {
  THREE.Object3D.call(this);
  this.geometry = void 0 !== a ? a : new THREE.Geometry();
  this.material = void 0 !== b ? b : new THREE.LineBasicMaterial({ color: 16777215 * Math.random() });
  this.type = void 0 !== c ? c : THREE.LineStrip;
};
THREE.LineStrip = 0;
THREE.LinePieces = 1;
THREE.Line.prototype = Object.create(THREE.Object3D.prototype);
THREE.Line.prototype.clone = function (a) {
  void 0 === a && (a = new THREE.Line(this.geometry, this.material, this.type));
  THREE.Object3D.prototype.clone.call(this, a);
  return a;
};
THREE.Mesh = function (a, b) {
  THREE.Object3D.call(this);
  this.geometry = void 0 !== a ? a : new THREE.Geometry();
  this.material = void 0 !== b ? b : new THREE.MeshBasicMaterial({ color: 16777215 * Math.random() });
  this.updateMorphTargets();
};
THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype);
THREE.Mesh.prototype.updateMorphTargets = function () {
  if (void 0 !== this.geometry.morphTargets && 0 < this.geometry.morphTargets.length) {
    this.morphTargetBase = -1;
    this.morphTargetForcedOrder = [];
    this.morphTargetInfluences = [];
    this.morphTargetDictionary = {};
    for (var a = 0, b = this.geometry.morphTargets.length; a < b; a++)
      this.morphTargetInfluences.push(0), this.morphTargetDictionary[this.geometry.morphTargets[a].name] = a;
  }
};
THREE.Mesh.prototype.getMorphTargetIndexByName = function (a) {
  if (void 0 !== this.morphTargetDictionary[a])
    return this.morphTargetDictionary[a];
  console.log('THREE.Mesh.getMorphTargetIndexByName: morph target ' + a + ' does not exist. Returning 0.');
  return 0;
};
THREE.Mesh.prototype.clone = function (a) {
  void 0 === a && (a = new THREE.Mesh(this.geometry, this.material));
  THREE.Object3D.prototype.clone.call(this, a);
  return a;
};
THREE.Bone = function (a) {
  THREE.Object3D.call(this);
  this.skin = a;
  this.skinMatrix = new THREE.Matrix4();
};
THREE.Bone.prototype = Object.create(THREE.Object3D.prototype);
THREE.Bone.prototype.update = function (a, b) {
  this.matrixAutoUpdate && (b |= this.updateMatrix());
  if (b || this.matrixWorldNeedsUpdate)
    a ? this.skinMatrix.multiplyMatrices(a, this.matrix) : this.skinMatrix.copy(this.matrix), this.matrixWorldNeedsUpdate = !1, b = !0;
  var c, d = this.children.length;
  for (c = 0; c < d; c++)
    this.children[c].update(this.skinMatrix, b);
};
THREE.SkinnedMesh = function (a, b, c) {
  THREE.Mesh.call(this, a, b);
  this.useVertexTexture = void 0 !== c ? c : !0;
  this.identityMatrix = new THREE.Matrix4();
  this.bones = [];
  this.boneMatrices = [];
  var d, e, f;
  if (this.geometry && void 0 !== this.geometry.bones) {
    for (a = 0; a < this.geometry.bones.length; a++)
      c = this.geometry.bones[a], d = c.pos, e = c.rotq, f = c.scl, b = this.addBone(), b.name = c.name, b.position.set(d[0], d[1], d[2]), b.quaternion.set(e[0], e[1], e[2], e[3]), void 0 !== f ? b.scale.set(f[0], f[1], f[2]) : b.scale.set(1, 1, 1);
    for (a = 0; a < this.bones.length; a++)
      c = this.geometry.bones[a], b = this.bones[a], -1 === c.parent ? this.add(b) : this.bones[c.parent].add(b);
    a = this.bones.length;
    this.useVertexTexture ? (this.boneTextureHeight = this.boneTextureWidth = a = 256 < a ? 64 : 64 < a ? 32 : 16 < a ? 16 : 8, this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4), this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType), this.boneTexture.minFilter = THREE.NearestFilter, this.boneTexture.magFilter = THREE.NearestFilter, this.boneTexture.generateMipmaps = !1, this.boneTexture.flipY = !1) : this.boneMatrices = new Float32Array(16 * a);
    this.pose();
  }
};
THREE.SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype);
THREE.SkinnedMesh.prototype.addBone = function (a) {
  void 0 === a && (a = new THREE.Bone(this));
  this.bones.push(a);
  return a;
};
THREE.SkinnedMesh.prototype.updateMatrixWorld = function () {
  var a = new THREE.Matrix4();
  return function (b) {
    this.matrixAutoUpdate && this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || b)
      this.parent ? this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix) : this.matrixWorld.copy(this.matrix), this.matrixWorldNeedsUpdate = !1;
    b = 0;
    for (var c = this.children.length; b < c; b++) {
      var d = this.children[b];
      d instanceof THREE.Bone ? d.update(this.identityMatrix, !1) : d.updateMatrixWorld(!0);
    }
    if (void 0 == this.boneInverses)
      for (this.boneInverses = [], b = 0, c = this.bones.length; b < c; b++)
        d = new THREE.Matrix4(), d.getInverse(this.bones[b].skinMatrix), this.boneInverses.push(d);
    b = 0;
    for (c = this.bones.length; b < c; b++)
      a.multiplyMatrices(this.bones[b].skinMatrix, this.boneInverses[b]), a.flattenToArrayOffset(this.boneMatrices, 16 * b);
    this.useVertexTexture && (this.boneTexture.needsUpdate = !0);
  };
}();
THREE.SkinnedMesh.prototype.pose = function () {
  this.updateMatrixWorld(!0);
  this.normalizeSkinWeights();
};
THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {
  if (this.geometry instanceof THREE.Geometry)
    for (var a = 0; a < this.geometry.skinIndices.length; a++) {
      var b = this.geometry.skinWeights[a], c = 1 / b.lengthManhattan();
      Infinity !== c ? b.multiplyScalar(c) : b.set(1);
    }
};
THREE.SkinnedMesh.prototype.clone = function (a) {
  void 0 === a && (a = new THREE.SkinnedMesh(this.geometry, this.material, this.useVertexTexture));
  THREE.Mesh.prototype.clone.call(this, a);
  return a;
};
THREE.MorphAnimMesh = function (a, b) {
  THREE.Mesh.call(this, a, b);
  this.duration = 1000;
  this.mirroredLoop = !1;
  this.currentKeyframe = this.lastKeyframe = this.time = 0;
  this.direction = 1;
  this.directionBackwards = !1;
  this.setFrameRange(0, this.geometry.morphTargets.length - 1);
};
THREE.MorphAnimMesh.prototype = Object.create(THREE.Mesh.prototype);
THREE.MorphAnimMesh.prototype.setFrameRange = function (a, b) {
  this.startKeyframe = a;
  this.endKeyframe = b;
  this.length = this.endKeyframe - this.startKeyframe + 1;
};
THREE.MorphAnimMesh.prototype.setDirectionForward = function () {
  this.direction = 1;
  this.directionBackwards = !1;
};
THREE.MorphAnimMesh.prototype.setDirectionBackward = function () {
  this.direction = -1;
  this.directionBackwards = !0;
};
THREE.MorphAnimMesh.prototype.parseAnimations = function () {
  var a = this.geometry;
  a.animations || (a.animations = {});
  for (var b, c = a.animations, d = /([a-z]+)(\d+)/, e = 0, f = a.morphTargets.length; e < f; e++) {
    var g = a.morphTargets[e].name.match(d);
    if (g && 1 < g.length) {
      g = g[1];
      c[g] || (c[g] = {
        start: Infinity,
        end: -Infinity
      });
      var h = c[g];
      e < h.start && (h.start = e);
      e > h.end && (h.end = e);
      b || (b = g);
    }
  }
  a.firstAnimation = b;
};
THREE.MorphAnimMesh.prototype.setAnimationLabel = function (a, b, c) {
  this.geometry.animations || (this.geometry.animations = {});
  this.geometry.animations[a] = {
    start: b,
    end: c
  };
};
THREE.MorphAnimMesh.prototype.playAnimation = function (a, b) {
  var c = this.geometry.animations[a];
  c ? (this.setFrameRange(c.start, c.end), this.duration = (c.end - c.start) / b * 1000, this.time = 0) : console.warn('animation[' + a + '] undefined');
};
THREE.MorphAnimMesh.prototype.updateAnimation = function (a) {
  var b = this.duration / this.length;
  this.time += this.direction * a;
  if (this.mirroredLoop) {
    if (this.time > this.duration || 0 > this.time)
      this.direction *= -1, this.time > this.duration && (this.time = this.duration, this.directionBackwards = !0), 0 > this.time && (this.time = 0, this.directionBackwards = !1);
  } else
    this.time %= this.duration, 0 > this.time && (this.time += this.duration);
  a = this.startKeyframe + THREE.Math.clamp(Math.floor(this.time / b), 0, this.length - 1);
  a !== this.currentKeyframe && (this.morphTargetInfluences[this.lastKeyframe] = 0, this.morphTargetInfluences[this.currentKeyframe] = 1, this.morphTargetInfluences[a] = 0, this.lastKeyframe = this.currentKeyframe, this.currentKeyframe = a);
  b = this.time % b / b;
  this.directionBackwards && (b = 1 - b);
  this.morphTargetInfluences[this.currentKeyframe] = b;
  this.morphTargetInfluences[this.lastKeyframe] = 1 - b;
};
THREE.MorphAnimMesh.prototype.clone = function (a) {
  void 0 === a && (a = new THREE.MorphAnimMesh(this.geometry, this.material));
  a.duration = this.duration;
  a.mirroredLoop = this.mirroredLoop;
  a.time = this.time;
  a.lastKeyframe = this.lastKeyframe;
  a.currentKeyframe = this.currentKeyframe;
  a.direction = this.direction;
  a.directionBackwards = this.directionBackwards;
  THREE.Mesh.prototype.clone.call(this, a);
  return a;
};
THREE.LOD = function () {
  THREE.Object3D.call(this);
  this.objects = [];
};
THREE.LOD.prototype = Object.create(THREE.Object3D.prototype);
THREE.LOD.prototype.addLevel = function (a, b) {
  void 0 === b && (b = 0);
  b = Math.abs(b);
  for (var c = 0; c < this.objects.length && !(b < this.objects[c].distance); c++);
  this.objects.splice(c, 0, {
    distance: b,
    object: a
  });
  this.add(a);
};
THREE.LOD.prototype.getObjectForDistance = function (a) {
  for (var b = 1, c = this.objects.length; b < c && !(a < this.objects[b].distance); b++);
  return this.objects[b - 1].object;
};
THREE.LOD.prototype.update = function () {
  var a = new THREE.Vector3(), b = new THREE.Vector3();
  return function (c) {
    if (1 < this.objects.length) {
      a.setFromMatrixPosition(c.matrixWorld);
      b.setFromMatrixPosition(this.matrixWorld);
      c = a.distanceTo(b);
      this.objects[0].object.visible = !0;
      for (var d = 1, e = this.objects.length; d < e; d++)
        if (c >= this.objects[d].distance)
          this.objects[d - 1].object.visible = !1, this.objects[d].object.visible = !0;
        else
          break;
      for (; d < e; d++)
        this.objects[d].object.visible = !1;
    }
  };
}();
THREE.LOD.prototype.clone = function (a) {
  void 0 === a && (a = new THREE.LOD());
  THREE.Object3D.prototype.clone.call(this, a);
  for (var b = 0, c = this.objects.length; b < c; b++) {
    var d = this.objects[b].object.clone();
    d.visible = 0 === b;
    a.addLevel(d, this.objects[b].distance);
  }
  return a;
};
THREE.Sprite = function () {
  var a = new THREE.Geometry2(3);
  a.vertices.set([
    -0.5,
    -0.5,
    0,
    0.5,
    -0.5,
    0,
    0.5,
    0.5,
    0
  ]);
  return function (b) {
    THREE.Object3D.call(this);
    this.geometry = a;
    this.material = void 0 !== b ? b : new THREE.SpriteMaterial();
  };
}();
THREE.Sprite.prototype = Object.create(THREE.Object3D.prototype);
THREE.Sprite.prototype.updateMatrix = function () {
  this.matrix.compose(this.position, this.quaternion, this.scale);
  this.matrixWorldNeedsUpdate = !0;
};
THREE.Sprite.prototype.clone = function (a) {
  void 0 === a && (a = new THREE.Sprite(this.material));
  THREE.Object3D.prototype.clone.call(this, a);
  return a;
};
THREE.Particle = THREE.Sprite;
THREE.Scene = function () {
  THREE.Object3D.call(this);
  this.overrideMaterial = this.fog = null;
  this.autoUpdate = !0;
  this.matrixAutoUpdate = !1;
  this.__lights = [];
  this.__objectsAdded = [];
  this.__objectsRemoved = [];
};
THREE.Scene.prototype = Object.create(THREE.Object3D.prototype);
THREE.Scene.prototype.__addObject = function (a) {
  if (a instanceof THREE.Light)
    -1 === this.__lights.indexOf(a) && this.__lights.push(a), a.target && void 0 === a.target.parent && this.add(a.target);
  else if (!(a instanceof THREE.Camera || a instanceof THREE.Bone)) {
    this.__objectsAdded.push(a);
    var b = this.__objectsRemoved.indexOf(a);
    -1 !== b && this.__objectsRemoved.splice(b, 1);
  }
  this.dispatchEvent({
    type: 'objectAdded',
    object: a
  });
  a.dispatchEvent({
    type: 'addedToScene',
    scene: this
  });
  for (b = 0; b < a.children.length; b++)
    this.__addObject(a.children[b]);
};
THREE.Scene.prototype.__removeObject = function (a) {
  if (a instanceof THREE.Light) {
    var b = this.__lights.indexOf(a);
    -1 !== b && this.__lights.splice(b, 1);
    if (a.shadowCascadeArray)
      for (b = 0; b < a.shadowCascadeArray.length; b++)
        this.__removeObject(a.shadowCascadeArray[b]);
  } else
    a instanceof THREE.Camera || (this.__objectsRemoved.push(a), b = this.__objectsAdded.indexOf(a), -1 !== b && this.__objectsAdded.splice(b, 1));
  this.dispatchEvent({
    type: 'objectRemoved',
    object: a
  });
  a.dispatchEvent({
    type: 'removedFromScene',
    scene: this
  });
  for (b = 0; b < a.children.length; b++)
    this.__removeObject(a.children[b]);
};
THREE.Scene.prototype.clone = function (a) {
  void 0 === a && (a = new THREE.Scene());
  THREE.Object3D.prototype.clone.call(this, a);
  null !== this.fog && (a.fog = this.fog.clone());
  null !== this.overrideMaterial && (a.overrideMaterial = this.overrideMaterial.clone());
  a.autoUpdate = this.autoUpdate;
  a.matrixAutoUpdate = this.matrixAutoUpdate;
  return a;
};
THREE.Fog = function (a, b, c) {
  this.name = '';
  this.color = new THREE.Color(a);
  this.near = void 0 !== b ? b : 1;
  this.far = void 0 !== c ? c : 1000;
};
THREE.Fog.prototype.clone = function () {
  return new THREE.Fog(this.color.getHex(), this.near, this.far);
};
THREE.FogExp2 = function (a, b) {
  this.name = '';
  this.color = new THREE.Color(a);
  this.density = void 0 !== b ? b : 0.00025;
};
THREE.FogExp2.prototype.clone = function () {
  return new THREE.FogExp2(this.color.getHex(), this.density);
};
THREE.CanvasRenderer = function (a) {
  function b(a, b, c) {
    for (var d = 0, e = E.length; d < e; d++) {
      var f = E[d];
      Ka.copy(f.color);
      if (f instanceof THREE.DirectionalLight) {
        var g = Na.setFromMatrixPosition(f.matrixWorld).normalize(), h = b.dot(g);
        0 >= h || (h *= f.intensity, c.add(Ka.multiplyScalar(h)));
      } else
        f instanceof THREE.PointLight && (g = Na.setFromMatrixPosition(f.matrixWorld), h = b.dot(Na.subVectors(g, a).normalize()), 0 >= h || (h *= 0 == f.distance ? 1 : 1 - Math.min(a.distanceTo(g) / f.distance, 1), 0 != h && (h *= f.intensity, c.add(Ka.multiplyScalar(h)))));
    }
  }
  function c(a, b, c, d) {
    r(b);
    q(c);
    u(d);
    p(a.getStyle());
    y.stroke();
    Oa.expandByScalar(2 * b);
  }
  function d(a) {
    v(a.getStyle());
    y.fill();
  }
  function e(a) {
    f(a.target);
  }
  function f(a) {
    var b = a.wrapS === THREE.RepeatWrapping, c = a.wrapT === THREE.RepeatWrapping, d = a.image, e = document.createElement('canvas');
    e.width = d.width;
    e.height = d.height;
    var f = e.getContext('2d');
    f.setTransform(1, 0, 0, -1, 0, d.height);
    f.drawImage(d, 0, 0);
    la[a.id] = y.createPattern(e, !0 === b && !0 === c ? 'repeat' : !0 === b && !1 === c ? 'repeat-x' : !1 === b && !0 === c ? 'repeat-y' : 'no-repeat');
  }
  function g(a, b, c, d, g, h, k, m, l, n, p, r, q) {
    if (!(q instanceof THREE.DataTexture)) {
      !1 === q.hasEventListener('update', e) && (void 0 !== q.image && 0 < q.image.width && f(q), q.addEventListener('update', e));
      var s = la[q.id];
      if (void 0 !== s) {
        v(s);
        var s = q.offset.x / q.repeat.x, u = q.offset.y / q.repeat.y, Nb = q.image.width * q.repeat.x;
        q = q.image.height * q.repeat.y;
        k = (k + s) * Nb;
        m = (m + u) * q;
        c -= a;
        d -= b;
        g -= a;
        h -= b;
        l = (l + s) * Nb - k;
        n = (n + u) * q - m;
        p = (p + s) * Nb - k;
        r = (r + u) * q - m;
        q = l * r - p * n;
        0 !== q && (s = 1 / q, q = (r * c - n * g) * s, n = (r * d - n * h) * s, c = (l * g - p * c) * s, d = (l * h - p * d) * s, a = a - q * k - c * m, b = b - n * k - d * m, y.save(), y.transform(q, n, c, d, a, b), y.fill(), y.restore());
      } else
        v('rgba(0,0,0,1)'), y.fill();
    }
  }
  function h(a, b, c, d, e, f, g, h, k, m, l, n, p) {
    var q, r;
    q = p.width - 1;
    r = p.height - 1;
    g *= q;
    h *= r;
    c -= a;
    d -= b;
    e -= a;
    f -= b;
    k = k * q - g;
    m = m * r - h;
    l = l * q - g;
    n = n * r - h;
    r = 1 / (k * n - l * m);
    q = (n * c - m * e) * r;
    m = (n * d - m * f) * r;
    c = (k * e - l * c) * r;
    d = (k * f - l * d) * r;
    a = a - q * g - c * h;
    b = b - m * g - d * h;
    y.save();
    y.transform(q, m, c, d, a, b);
    y.clip();
    y.drawImage(p, 0, 0);
    y.restore();
  }
  function k(a, b, c, d) {
    qa[0] = 255 * a.r | 0;
    qa[1] = 255 * a.g | 0;
    qa[2] = 255 * a.b | 0;
    qa[4] = 255 * b.r | 0;
    qa[5] = 255 * b.g | 0;
    qa[6] = 255 * b.b | 0;
    qa[8] = 255 * c.r | 0;
    qa[9] = 255 * c.g | 0;
    qa[10] = 255 * c.b | 0;
    qa[12] = 255 * d.r | 0;
    qa[13] = 255 * d.g | 0;
    qa[14] = 255 * d.b | 0;
    Ma.putImageData(Pa, 0, 0);
    qb.drawImage(Qa, 0, 0);
    return cb;
  }
  function l(a, b, c) {
    var d = b.x - a.x, e = b.y - a.y, f = d * d + e * e;
    0 !== f && (c /= Math.sqrt(f), d *= c, e *= c, b.x += d, b.y += e, a.x -= d, a.y -= e);
  }
  function n(a) {
    A !== a && (A = y.globalAlpha = a);
  }
  function s(a) {
    L !== a && (a === THREE.NormalBlending ? y.globalCompositeOperation = 'source-over' : a === THREE.AdditiveBlending ? y.globalCompositeOperation = 'lighter' : a === THREE.SubtractiveBlending && (y.globalCompositeOperation = 'darker'), L = a);
  }
  function r(a) {
    R !== a && (R = y.lineWidth = a);
  }
  function q(a) {
    fa !== a && (fa = y.lineCap = a);
  }
  function u(a) {
    V !== a && (V = y.lineJoin = a);
  }
  function p(a) {
    Q !== a && (Q = y.strokeStyle = a);
  }
  function v(a) {
    Y !== a && (Y = y.fillStyle = a);
  }
  function w(a, b) {
    if (ga !== a || J !== b)
      y.setLineDash([
        a,
        b
      ]), ga = a, J = b;
  }
  console.log('THREE.CanvasRenderer', THREE.REVISION);
  var t = THREE.Math.smoothstep;
  a = a || {};
  var x = this, z, B, E, H = new THREE.Projector(), D = void 0 !== a.canvas ? a.canvas : document.createElement('canvas'), G = D.width, I = D.height, O = Math.floor(G / 2), K = Math.floor(I / 2), y = D.getContext('2d', { alpha: !0 === a.alpha }), F = new THREE.Color(0), C = 0, A = 1, L = 0, Q = null, Y = null, R = null, fa = null, V = null, ga = null, J = 0, da, W, N, ca;
  new THREE.RenderableVertex();
  new THREE.RenderableVertex();
  var sa, T, Ja, S, $, Fa, ta = new THREE.Color(), oa = new THREE.Color(), za = new THREE.Color(), Aa = new THREE.Color(), Ua = new THREE.Color(), Va = new THREE.Color(), ka = new THREE.Color(), Ka = new THREE.Color(), la = {}, Ba, Ia, ma, Ca, ba, wa, xa, Da, Wa, La, Ea = new THREE.Box2(), na = new THREE.Box2(), Oa = new THREE.Box2(), hb = new THREE.Color(), ya = new THREE.Color(), ia = new THREE.Color(), Na = new THREE.Vector3(), ha = new THREE.Vector3(), m = new THREE.Matrix3(), Qa, Ma, Pa, qa, cb, qb, db = 16;
  Qa = document.createElement('canvas');
  Qa.width = Qa.height = 2;
  Ma = Qa.getContext('2d');
  Ma.fillStyle = 'rgba(0,0,0,1)';
  Ma.fillRect(0, 0, 2, 2);
  Pa = Ma.getImageData(0, 0, 2, 2);
  qa = Pa.data;
  cb = document.createElement('canvas');
  cb.width = cb.height = db;
  qb = cb.getContext('2d');
  qb.translate(-db / 2, -db / 2);
  qb.scale(db, db);
  db--;
  void 0 === y.setLineDash && (y.setLineDash = void 0 !== y.mozDash ? function (a) {
    y.mozDash = null !== a[0] ? a : null;
  } : function () {
  });
  this.domElement = D;
  this.devicePixelRatio = void 0 !== a.devicePixelRatio ? a.devicePixelRatio : void 0 !== self.devicePixelRatio ? self.devicePixelRatio : 1;
  this.sortElements = this.sortObjects = this.autoClear = !0;
  this.info = {
    render: {
      vertices: 0,
      faces: 0
    }
  };
  this.supportsVertexTextures = function () {
  };
  this.setFaceCulling = function () {
  };
  this.setSize = function (a, b, c) {
    G = a * this.devicePixelRatio;
    I = b * this.devicePixelRatio;
    O = Math.floor(G / 2);
    K = Math.floor(I / 2);
    D.width = G;
    D.height = I;
    1 !== this.devicePixelRatio && !1 !== c && (D.style.width = a + 'px', D.style.height = b + 'px');
    Ea.min.set(-O, -K);
    Ea.max.set(O, K);
    na.min.set(-O, -K);
    na.max.set(O, K);
    A = 1;
    L = 0;
    V = fa = R = Y = Q = null;
  };
  this.setClearColor = function (a, b) {
    F.set(a);
    C = void 0 !== b ? b : 1;
    na.min.set(-O, -K);
    na.max.set(O, K);
  };
  this.setClearColorHex = function (a, b) {
    console.warn('DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.');
    this.setClearColor(a, b);
  };
  this.getMaxAnisotropy = function () {
    return 0;
  };
  this.clear = function () {
    y.setTransform(1, 0, 0, -1, O, K);
    !1 === na.empty() && (na.intersect(Ea), na.expandByScalar(2), 1 > C && y.clearRect(na.min.x | 0, na.min.y | 0, na.max.x - na.min.x | 0, na.max.y - na.min.y | 0), 0 < C && (s(THREE.NormalBlending), n(1), v('rgba(' + Math.floor(255 * F.r) + ',' + Math.floor(255 * F.g) + ',' + Math.floor(255 * F.b) + ',' + C + ')'), y.fillRect(na.min.x | 0, na.min.y | 0, na.max.x - na.min.x | 0, na.max.y - na.min.y | 0)), na.makeEmpty());
  };
  this.clearColor = function () {
  };
  this.clearDepth = function () {
  };
  this.clearStencil = function () {
  };
  this.render = function (a, D) {
    if (!1 === D instanceof THREE.Camera)
      console.error('THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.');
    else {
      !0 === this.autoClear && this.clear();
      y.setTransform(1, 0, 0, -1, O, K);
      x.info.render.vertices = 0;
      x.info.render.faces = 0;
      z = H.projectScene(a, D, this.sortObjects, this.sortElements);
      B = z.elements;
      E = z.lights;
      da = D;
      m.getNormalMatrix(D.matrixWorldInverse);
      hb.setRGB(0, 0, 0);
      ya.setRGB(0, 0, 0);
      ia.setRGB(0, 0, 0);
      for (var I = 0, L = E.length; I < L; I++) {
        var C = E[I], G = C.color;
        C instanceof THREE.AmbientLight ? hb.add(G) : C instanceof THREE.DirectionalLight ? ya.add(G) : C instanceof THREE.PointLight && ia.add(G);
      }
      I = 0;
      for (L = B.length; I < L; I++) {
        var A = B[I], F = A.material;
        if (void 0 !== F && !1 !== F.visible) {
          Oa.makeEmpty();
          if (A instanceof THREE.RenderableSprite) {
            W = A;
            W.x *= O;
            W.y *= K;
            C = W;
            G = F;
            n(G.opacity);
            s(G.blending);
            var J = A.scale.x * O, A = A.scale.y * K, F = 0.5 * Math.sqrt(J * J + A * A);
            Oa.min.set(C.x - F, C.y - F);
            Oa.max.set(C.x + F, C.y + F);
            if (G instanceof THREE.SpriteMaterial || G instanceof THREE.ParticleSystemMaterial) {
              var Q = G.map;
              if (null !== Q) {
                !1 === Q.hasEventListener('update', e) && (void 0 !== Q.image && 0 < Q.image.width && f(Q), Q.addEventListener('update', e));
                F = la[Q.id];
                void 0 !== F ? v(F) : v('rgba( 0, 0, 0, 1 )');
                var R = Q.image, F = R.width * Q.offset.x, Y = R.height * Q.offset.y, V = R.width * Q.repeat.x, Q = R.height * Q.repeat.y, R = J / V, fa = A / Q;
                y.save();
                y.translate(C.x, C.y);
                0 !== G.rotation && y.rotate(G.rotation);
                y.translate(-J / 2, -A / 2);
                y.scale(R, fa);
                y.translate(-F, -Y);
                y.fillRect(F, Y, V, Q);
              } else
                v(G.color.getStyle()), y.save(), y.translate(C.x, C.y), 0 !== G.rotation && y.rotate(G.rotation), y.scale(J, -A), y.fillRect(-0.5, -0.5, 1, 1);
              y.restore();
            } else
              G instanceof THREE.SpriteCanvasMaterial && (p(G.color.getStyle()), v(G.color.getStyle()), y.save(), y.translate(C.x, C.y), 0 !== G.rotation && y.rotate(G.rotation), y.scale(J, A), G.program(y), y.restore());
          } else if (A instanceof THREE.RenderableLine) {
            if (W = A.v1, N = A.v2, W.positionScreen.x *= O, W.positionScreen.y *= K, N.positionScreen.x *= O, N.positionScreen.y *= K, Oa.setFromPoints([
                W.positionScreen,
                N.positionScreen
              ]), !0 === Ea.isIntersectionBox(Oa))
              if (C = W, G = N, J = A, A = F, n(A.opacity), s(A.blending), y.beginPath(), y.moveTo(C.positionScreen.x, C.positionScreen.y), y.lineTo(G.positionScreen.x, G.positionScreen.y), A instanceof THREE.LineBasicMaterial) {
                r(A.linewidth);
                q(A.linecap);
                u(A.linejoin);
                if (A.vertexColors !== THREE.VertexColors)
                  p(A.color.getStyle());
                else if (F = J.vertexColors[0].getStyle(), J = J.vertexColors[1].getStyle(), F === J)
                  p(F);
                else {
                  try {
                    var ga = y.createLinearGradient(C.positionScreen.x, C.positionScreen.y, G.positionScreen.x, G.positionScreen.y);
                    ga.addColorStop(0, F);
                    ga.addColorStop(1, J);
                  } catch (Nb) {
                    ga = F;
                  }
                  p(ga);
                }
                y.stroke();
                Oa.expandByScalar(2 * A.linewidth);
              } else
                A instanceof THREE.LineDashedMaterial && (r(A.linewidth), q(A.linecap), u(A.linejoin), p(A.color.getStyle()), w(A.dashSize, A.gapSize), y.stroke(), Oa.expandByScalar(2 * A.linewidth), w(null, null));
          } else if (A instanceof THREE.RenderableFace) {
            W = A.v1;
            N = A.v2;
            ca = A.v3;
            if (-1 > W.positionScreen.z || 1 < W.positionScreen.z)
              continue;
            if (-1 > N.positionScreen.z || 1 < N.positionScreen.z)
              continue;
            if (-1 > ca.positionScreen.z || 1 < ca.positionScreen.z)
              continue;
            W.positionScreen.x *= O;
            W.positionScreen.y *= K;
            N.positionScreen.x *= O;
            N.positionScreen.y *= K;
            ca.positionScreen.x *= O;
            ca.positionScreen.y *= K;
            0 < F.overdraw && (l(W.positionScreen, N.positionScreen, F.overdraw), l(N.positionScreen, ca.positionScreen, F.overdraw), l(ca.positionScreen, W.positionScreen, F.overdraw));
            Oa.setFromPoints([
              W.positionScreen,
              N.positionScreen,
              ca.positionScreen
            ]);
            if (!0 === Ea.isIntersectionBox(Oa)) {
              C = W;
              G = N;
              J = ca;
              x.info.render.vertices += 3;
              x.info.render.faces++;
              n(F.opacity);
              s(F.blending);
              sa = C.positionScreen.x;
              T = C.positionScreen.y;
              Ja = G.positionScreen.x;
              S = G.positionScreen.y;
              $ = J.positionScreen.x;
              Fa = J.positionScreen.y;
              var Y = sa, V = T, Q = Ja, R = S, fa = $, tc = Fa;
              y.beginPath();
              y.moveTo(Y, V);
              y.lineTo(Q, R);
              y.lineTo(fa, tc);
              y.closePath();
              (F instanceof THREE.MeshLambertMaterial || F instanceof THREE.MeshPhongMaterial) && null === F.map ? (Va.copy(F.color), ka.copy(F.emissive), F.vertexColors === THREE.FaceColors && Va.multiply(A.color), !1 === F.wireframe && F.shading === THREE.SmoothShading && 3 === A.vertexNormalsLength ? (oa.copy(hb), za.copy(hb), Aa.copy(hb), b(A.v1.positionWorld, A.vertexNormalsModel[0], oa), b(A.v2.positionWorld, A.vertexNormalsModel[1], za), b(A.v3.positionWorld, A.vertexNormalsModel[2], Aa), oa.multiply(Va).add(ka), za.multiply(Va).add(ka), Aa.multiply(Va).add(ka), Ua.addColors(za, Aa).multiplyScalar(0.5), ma = k(oa, za, Aa, Ua), h(sa, T, Ja, S, $, Fa, 0, 0, 1, 0, 0, 1, ma)) : (ta.copy(hb), b(A.centroidModel, A.normalModel, ta), ta.multiply(Va).add(ka), !0 === F.wireframe ? c(ta, F.wireframeLinewidth, F.wireframeLinecap, F.wireframeLinejoin) : d(ta))) : F instanceof THREE.MeshBasicMaterial || F instanceof THREE.MeshLambertMaterial || F instanceof THREE.MeshPhongMaterial ? null !== F.map ? F.map.mapping instanceof THREE.UVMapping && (Ca = A.uvs[0], g(sa, T, Ja, S, $, Fa, Ca[0].x, Ca[0].y, Ca[1].x, Ca[1].y, Ca[2].x, Ca[2].y, F.map)) : null !== F.envMap ? F.envMap.mapping instanceof THREE.SphericalReflectionMapping && (ha.copy(A.vertexNormalsModel[0]).applyMatrix3(m), ba = 0.5 * ha.x + 0.5, wa = 0.5 * ha.y + 0.5, ha.copy(A.vertexNormalsModel[1]).applyMatrix3(m), xa = 0.5 * ha.x + 0.5, Da = 0.5 * ha.y + 0.5, ha.copy(A.vertexNormalsModel[2]).applyMatrix3(m), Wa = 0.5 * ha.x + 0.5, La = 0.5 * ha.y + 0.5, g(sa, T, Ja, S, $, Fa, ba, wa, xa, Da, Wa, La, F.envMap)) : (ta.copy(F.color), F.vertexColors === THREE.FaceColors && ta.multiply(A.color), !0 === F.wireframe ? c(ta, F.wireframeLinewidth, F.wireframeLinecap, F.wireframeLinejoin) : d(ta)) : F instanceof THREE.MeshDepthMaterial ? (Ba = da.near, Ia = da.far, oa.r = oa.g = oa.b = 1 - t(C.positionScreen.z * C.positionScreen.w, Ba, Ia), za.r = za.g = za.b = 1 - t(G.positionScreen.z * G.positionScreen.w, Ba, Ia), Aa.r = Aa.g = Aa.b = 1 - t(J.positionScreen.z * J.positionScreen.w, Ba, Ia), Ua.addColors(za, Aa).multiplyScalar(0.5), ma = k(oa, za, Aa, Ua), h(sa, T, Ja, S, $, Fa, 0, 0, 1, 0, 0, 1, ma)) : F instanceof THREE.MeshNormalMaterial && (F.shading === THREE.FlatShading ? (ha.copy(A.normalModel).applyMatrix3(m), ta.setRGB(ha.x, ha.y, ha.z).multiplyScalar(0.5).addScalar(0.5), !0 === F.wireframe ? c(ta, F.wireframeLinewidth, F.wireframeLinecap, F.wireframeLinejoin) : d(ta)) : F.shading === THREE.SmoothShading && (ha.copy(A.vertexNormalsModel[0]).applyMatrix3(m), oa.setRGB(ha.x, ha.y, ha.z).multiplyScalar(0.5).addScalar(0.5), ha.copy(A.vertexNormalsModel[1]).applyMatrix3(m), za.setRGB(ha.x, ha.y, ha.z).multiplyScalar(0.5).addScalar(0.5), ha.copy(A.vertexNormalsModel[2]).applyMatrix3(m), Aa.setRGB(ha.x, ha.y, ha.z).multiplyScalar(0.5).addScalar(0.5), Ua.addColors(za, Aa).multiplyScalar(0.5), ma = k(oa, za, Aa, Ua), h(sa, T, Ja, S, $, Fa, 0, 0, 1, 0, 0, 1, ma)));
            }
          }
          na.union(Oa);
        }
      }
      y.setTransform(1, 0, 0, 1, 0, 0);
    }
  };
};
THREE.ShaderChunk = {
  fog_pars_fragment: '#ifdef USE_FOG\nuniform vec3 fogColor;\n#ifdef FOG_EXP2\nuniform float fogDensity;\n#else\nuniform float fogNear;\nuniform float fogFar;\n#endif\n#endif',
  fog_fragment: '#ifdef USE_FOG\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n#ifdef FOG_EXP2\nconst float LOG2 = 1.442695;\nfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n#else\nfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n#endif\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n#endif',
  envmap_pars_fragment: '#ifdef USE_ENVMAP\nuniform float reflectivity;\nuniform samplerCube envMap;\nuniform float flipEnvMap;\nuniform int combine;\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nuniform bool useRefract;\nuniform float refractionRatio;\n#else\nvarying vec3 vReflect;\n#endif\n#endif',
  envmap_fragment: '#ifdef USE_ENVMAP\nvec3 reflectVec;\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\nif ( useRefract ) {\nreflectVec = refract( cameraToVertex, normal, refractionRatio );\n} else { \nreflectVec = reflect( cameraToVertex, normal );\n}\n#else\nreflectVec = vReflect;\n#endif\n#ifdef DOUBLE_SIDED\nfloat flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\nvec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n#else\nvec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n#endif\n#ifdef GAMMA_INPUT\ncubeColor.xyz *= cubeColor.xyz;\n#endif\nif ( combine == 1 ) {\ngl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );\n} else if ( combine == 2 ) {\ngl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;\n} else {\ngl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );\n}\n#endif',
  envmap_pars_vertex: '#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\nvarying vec3 vReflect;\nuniform float refractionRatio;\nuniform bool useRefract;\n#endif',
  worldpos_vertex: '#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n#ifdef USE_SKINNING\nvec4 worldPosition = modelMatrix * skinned;\n#endif\n#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\nvec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n#endif\n#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\nvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n#endif\n#endif',
  envmap_vertex: '#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\nvec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\nworldNormal = normalize( worldNormal );\nvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\nif ( useRefract ) {\nvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n} else {\nvReflect = reflect( cameraToVertex, worldNormal );\n}\n#endif',
  map_particle_pars_fragment: '#ifdef USE_MAP\nuniform sampler2D map;\n#endif',
  map_particle_fragment: '#ifdef USE_MAP\ngl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\n#endif',
  map_pars_vertex: '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\nvarying vec2 vUv;\nuniform vec4 offsetRepeat;\n#endif',
  map_pars_fragment: '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\nvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\nuniform sampler2D map;\n#endif',
  map_vertex: '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\nvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif',
  map_fragment: '#ifdef USE_MAP\nvec4 texelColor = texture2D( map, vUv );\n#ifdef GAMMA_INPUT\ntexelColor.xyz *= texelColor.xyz;\n#endif\ngl_FragColor = gl_FragColor * texelColor;\n#endif',
  lightmap_pars_fragment: '#ifdef USE_LIGHTMAP\nvarying vec2 vUv2;\nuniform sampler2D lightMap;\n#endif',
  lightmap_pars_vertex: '#ifdef USE_LIGHTMAP\nvarying vec2 vUv2;\n#endif',
  lightmap_fragment: '#ifdef USE_LIGHTMAP\ngl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\n#endif',
  lightmap_vertex: '#ifdef USE_LIGHTMAP\nvUv2 = uv2;\n#endif',
  bumpmap_pars_fragment: '#ifdef USE_BUMPMAP\nuniform sampler2D bumpMap;\nuniform float bumpScale;\nvec2 dHdxy_fwd() {\nvec2 dSTdx = dFdx( vUv );\nvec2 dSTdy = dFdy( vUv );\nfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\nfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\nfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\nreturn vec2( dBx, dBy );\n}\nvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\nvec3 vSigmaX = dFdx( surf_pos );\nvec3 vSigmaY = dFdy( surf_pos );\nvec3 vN = surf_norm;\nvec3 R1 = cross( vSigmaY, vN );\nvec3 R2 = cross( vN, vSigmaX );\nfloat fDet = dot( vSigmaX, R1 );\nvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\nreturn normalize( abs( fDet ) * surf_norm - vGrad );\n}\n#endif',
  normalmap_pars_fragment: '#ifdef USE_NORMALMAP\nuniform sampler2D normalMap;\nuniform vec2 normalScale;\nvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\nvec3 q0 = dFdx( eye_pos.xyz );\nvec3 q1 = dFdy( eye_pos.xyz );\nvec2 st0 = dFdx( vUv.st );\nvec2 st1 = dFdy( vUv.st );\nvec3 S = normalize(  q0 * st1.t - q1 * st0.t );\nvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\nvec3 N = normalize( surf_norm );\nvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\nmapN.xy = normalScale * mapN.xy;\nmat3 tsn = mat3( S, T, N );\nreturn normalize( tsn * mapN );\n}\n#endif',
  specularmap_pars_fragment: '#ifdef USE_SPECULARMAP\nuniform sampler2D specularMap;\n#endif',
  specularmap_fragment: 'float specularStrength;\n#ifdef USE_SPECULARMAP\nvec4 texelSpecular = texture2D( specularMap, vUv );\nspecularStrength = texelSpecular.r;\n#else\nspecularStrength = 1.0;\n#endif',
  lights_lambert_pars_vertex: 'uniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_HEMI_LIGHTS > 0\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n#endif\n#ifdef WRAP_AROUND\nuniform vec3 wrapRGB;\n#endif',
  lights_lambert_vertex: 'vLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\nvLightBack = vec3( 0.0 );\n#endif\ntransformedNormal = normalize( transformedNormal );\n#if MAX_DIR_LIGHTS > 0\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\nvec3 dirVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( transformedNormal, dirVector );\nvec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n#ifdef DOUBLE_SIDED\nvec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n#ifdef WRAP_AROUND\nvec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n#endif\n#endif\n#ifdef WRAP_AROUND\nvec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\ndirectionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\n#ifdef DOUBLE_SIDED\ndirectionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\n#endif\n#endif\nvLightFront += directionalLightColor[ i ] * directionalLightWeighting;\n#ifdef DOUBLE_SIDED\nvLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\n#endif\n}\n#endif\n#if MAX_POINT_LIGHTS > 0\nfor( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\nfloat lDistance = 1.0;\nif ( pointLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\nfloat dotProduct = dot( transformedNormal, lVector );\nvec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\n#ifdef DOUBLE_SIDED\nvec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n#ifdef WRAP_AROUND\nvec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n#endif\n#endif\n#ifdef WRAP_AROUND\nvec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\npointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\n#ifdef DOUBLE_SIDED\npointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\n#endif\n#endif\nvLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\n#ifdef DOUBLE_SIDED\nvLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\n#endif\n}\n#endif\n#if MAX_SPOT_LIGHTS > 0\nfor( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\nif ( spotEffect > spotLightAngleCos[ i ] ) {\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\nfloat lDistance = 1.0;\nif ( spotLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\nfloat dotProduct = dot( transformedNormal, lVector );\nvec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\n#ifdef DOUBLE_SIDED\nvec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n#ifdef WRAP_AROUND\nvec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n#endif\n#endif\n#ifdef WRAP_AROUND\nvec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\nspotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\n#ifdef DOUBLE_SIDED\nspotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\n#endif\n#endif\nvLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\n#ifdef DOUBLE_SIDED\nvLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\n#endif\n}\n}\n#endif\n#if MAX_HEMI_LIGHTS > 0\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\nvec3 lVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( transformedNormal, lVector );\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\nfloat hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\nvLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n#ifdef DOUBLE_SIDED\nvLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n#endif\n}\n#endif\nvLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\n#ifdef DOUBLE_SIDED\nvLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\n#endif',
  lights_phong_pars_vertex: '#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\nvarying vec3 vWorldPosition;\n#endif',
  lights_phong_vertex: '#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\nvWorldPosition = worldPosition.xyz;\n#endif',
  lights_phong_pars_fragment: 'uniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_HEMI_LIGHTS > 0\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\nvarying vec3 vWorldPosition;\n#endif\n#ifdef WRAP_AROUND\nuniform vec3 wrapRGB;\n#endif\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;',
  lights_phong_fragment: 'vec3 normal = normalize( vNormal );\nvec3 viewPosition = normalize( vViewPosition );\n#ifdef DOUBLE_SIDED\nnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n#endif\n#ifdef USE_NORMALMAP\nnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\nnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n#if MAX_POINT_LIGHTS > 0\nvec3 pointDiffuse  = vec3( 0.0 );\nvec3 pointSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz + vViewPosition.xyz;\nfloat lDistance = 1.0;\nif ( pointLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\nfloat dotProduct = dot( normal, lVector );\n#ifdef WRAP_AROUND\nfloat pointDiffuseWeightFull = max( dotProduct, 0.0 );\nfloat pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\nvec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n#else\nfloat pointDiffuseWeight = max( dotProduct, 0.0 );\n#endif\npointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\nvec3 pointHalfVector = normalize( lVector + viewPosition );\nfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\nfloat pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\npointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\n}\n#endif\n#if MAX_SPOT_LIGHTS > 0\nvec3 spotDiffuse  = vec3( 0.0 );\nvec3 spotSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz + vViewPosition.xyz;\nfloat lDistance = 1.0;\nif ( spotLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\nif ( spotEffect > spotLightAngleCos[ i ] ) {\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\nfloat dotProduct = dot( normal, lVector );\n#ifdef WRAP_AROUND\nfloat spotDiffuseWeightFull = max( dotProduct, 0.0 );\nfloat spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\nvec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n#else\nfloat spotDiffuseWeight = max( dotProduct, 0.0 );\n#endif\nspotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\nvec3 spotHalfVector = normalize( lVector + viewPosition );\nfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\nfloat spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\nspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\n}\n}\n#endif\n#if MAX_DIR_LIGHTS > 0\nvec3 dirDiffuse  = vec3( 0.0 );\nvec3 dirSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\nvec3 dirVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( normal, dirVector );\n#ifdef WRAP_AROUND\nfloat dirDiffuseWeightFull = max( dotProduct, 0.0 );\nfloat dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\nvec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n#else\nfloat dirDiffuseWeight = max( dotProduct, 0.0 );\n#endif\ndirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\nvec3 dirHalfVector = normalize( dirVector + viewPosition );\nfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\nfloat dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\ndirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n}\n#endif\n#if MAX_HEMI_LIGHTS > 0\nvec3 hemiDiffuse  = vec3( 0.0 );\nvec3 hemiSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\nvec3 lVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( normal, lVector );\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\nvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\nhemiDiffuse += diffuse * hemiColor;\nvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\nfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\nfloat hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\nvec3 lVectorGround = -lVector;\nvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\nfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\nfloat hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\nfloat dotProductGround = dot( normal, lVectorGround );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\nvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\nhemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n}\n#endif\nvec3 totalDiffuse = vec3( 0.0 );\nvec3 totalSpecular = vec3( 0.0 );\n#if MAX_DIR_LIGHTS > 0\ntotalDiffuse += dirDiffuse;\ntotalSpecular += dirSpecular;\n#endif\n#if MAX_HEMI_LIGHTS > 0\ntotalDiffuse += hemiDiffuse;\ntotalSpecular += hemiSpecular;\n#endif\n#if MAX_POINT_LIGHTS > 0\ntotalDiffuse += pointDiffuse;\ntotalSpecular += pointSpecular;\n#endif\n#if MAX_SPOT_LIGHTS > 0\ntotalDiffuse += spotDiffuse;\ntotalSpecular += spotSpecular;\n#endif\n#ifdef METAL\ngl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\n#else\ngl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n#endif',
  color_pars_fragment: '#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif',
  color_fragment: '#ifdef USE_COLOR\ngl_FragColor = gl_FragColor * vec4( vColor, 1.0 );\n#endif',
  color_pars_vertex: '#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif',
  color_vertex: '#ifdef USE_COLOR\n#ifdef GAMMA_INPUT\nvColor = color * color;\n#else\nvColor = color;\n#endif\n#endif',
  skinning_pars_vertex: '#ifdef USE_SKINNING\n#ifdef BONE_TEXTURE\nuniform sampler2D boneTexture;\nuniform int boneTextureWidth;\nuniform int boneTextureHeight;\nmat4 getBoneMatrix( const in float i ) {\nfloat j = i * 4.0;\nfloat x = mod( j, float( boneTextureWidth ) );\nfloat y = floor( j / float( boneTextureWidth ) );\nfloat dx = 1.0 / float( boneTextureWidth );\nfloat dy = 1.0 / float( boneTextureHeight );\ny = dy * ( y + 0.5 );\nvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\nvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\nvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\nvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\nmat4 bone = mat4( v1, v2, v3, v4 );\nreturn bone;\n}\n#else\nuniform mat4 boneGlobalMatrices[ MAX_BONES ];\nmat4 getBoneMatrix( const in float i ) {\nmat4 bone = boneGlobalMatrices[ int(i) ];\nreturn bone;\n}\n#endif\n#endif',
  skinbase_vertex: '#ifdef USE_SKINNING\nmat4 boneMatX = getBoneMatrix( skinIndex.x );\nmat4 boneMatY = getBoneMatrix( skinIndex.y );\nmat4 boneMatZ = getBoneMatrix( skinIndex.z );\nmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif',
  skinning_vertex: '#ifdef USE_SKINNING\n#ifdef USE_MORPHTARGETS\nvec4 skinVertex = vec4( morphed, 1.0 );\n#else\nvec4 skinVertex = vec4( position, 1.0 );\n#endif\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\nskinned      += boneMatY * skinVertex * skinWeight.y;\nskinned      += boneMatZ * skinVertex * skinWeight.z;\nskinned      += boneMatW * skinVertex * skinWeight.w;\n#endif',
  morphtarget_pars_vertex: '#ifdef USE_MORPHTARGETS\n#ifndef USE_MORPHNORMALS\nuniform float morphTargetInfluences[ 8 ];\n#else\nuniform float morphTargetInfluences[ 4 ];\n#endif\n#endif',
  morphtarget_vertex: '#ifdef USE_MORPHTARGETS\nvec3 morphed = vec3( 0.0 );\nmorphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\nmorphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\nmorphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\nmorphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n#ifndef USE_MORPHNORMALS\nmorphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\nmorphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\nmorphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\nmorphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n#endif\nmorphed += position;\n#endif',
  default_vertex: 'vec4 mvPosition;\n#ifdef USE_SKINNING\nmvPosition = modelViewMatrix * skinned;\n#endif\n#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )\nmvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n#endif\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )\nmvPosition = modelViewMatrix * vec4( position, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;',
  morphnormal_vertex: '#ifdef USE_MORPHNORMALS\nvec3 morphedNormal = vec3( 0.0 );\nmorphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\nmorphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\nmorphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\nmorphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\nmorphedNormal += normal;\n#endif',
  skinnormal_vertex: '#ifdef USE_SKINNING\nmat4 skinMatrix = skinWeight.x * boneMatX;\nskinMatrix \t+= skinWeight.y * boneMatY;\n#ifdef USE_MORPHNORMALS\nvec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n#else\nvec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n#endif\n#endif',
  defaultnormal_vertex: 'vec3 objectNormal;\n#ifdef USE_SKINNING\nobjectNormal = skinnedNormal.xyz;\n#endif\n#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )\nobjectNormal = morphedNormal;\n#endif\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )\nobjectNormal = normal;\n#endif\n#ifdef FLIP_SIDED\nobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;',
  shadowmap_pars_fragment: '#ifdef USE_SHADOWMAP\nuniform sampler2D shadowMap[ MAX_SHADOWS ];\nuniform vec2 shadowMapSize[ MAX_SHADOWS ];\nuniform float shadowDarkness[ MAX_SHADOWS ];\nuniform float shadowBias[ MAX_SHADOWS ];\nvarying vec4 vShadowCoord[ MAX_SHADOWS ];\nfloat unpackDepth( const in vec4 rgba_depth ) {\nconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\nfloat depth = dot( rgba_depth, bit_shift );\nreturn depth;\n}\n#endif',
  shadowmap_fragment: '#ifdef USE_SHADOWMAP\n#ifdef SHADOWMAP_DEBUG\nvec3 frustumColors[3];\nfrustumColors[0] = vec3( 1.0, 0.5, 0.0 );\nfrustumColors[1] = vec3( 0.0, 1.0, 0.8 );\nfrustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n#endif\n#ifdef SHADOWMAP_CASCADE\nint inFrustumCount = 0;\n#endif\nfloat fDepth;\nvec3 shadowColor = vec3( 1.0 );\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\nvec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\nbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\nbool inFrustum = all( inFrustumVec );\n#ifdef SHADOWMAP_CASCADE\ninFrustumCount += int( inFrustum );\nbvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n#else\nbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n#endif\nbool frustumTest = all( frustumTestVec );\nif ( frustumTest ) {\nshadowCoord.z += shadowBias[ i ];\n#if defined( SHADOWMAP_TYPE_PCF )\nfloat shadow = 0.0;\nconst float shadowDelta = 1.0 / 9.0;\nfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\nfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\nfloat dx0 = -1.25 * xPixelOffset;\nfloat dy0 = -1.25 * yPixelOffset;\nfloat dx1 = 1.25 * xPixelOffset;\nfloat dy1 = 1.25 * yPixelOffset;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\nfloat shadow = 0.0;\nfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\nfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\nfloat dx0 = -1.0 * xPixelOffset;\nfloat dy0 = -1.0 * yPixelOffset;\nfloat dx1 = 1.0 * xPixelOffset;\nfloat dy1 = 1.0 * yPixelOffset;\nmat3 shadowKernel;\nmat3 depthKernel;\ndepthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\ndepthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\ndepthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\ndepthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\ndepthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\ndepthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\ndepthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\ndepthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\ndepthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\nvec3 shadowZ = vec3( shadowCoord.z );\nshadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\nshadowKernel[0] *= vec3(0.25);\nshadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\nshadowKernel[1] *= vec3(0.25);\nshadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\nshadowKernel[2] *= vec3(0.25);\nvec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\nshadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\nshadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\nvec4 shadowValues;\nshadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\nshadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\nshadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\nshadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\nshadow = dot( shadowValues, vec4( 1.0 ) );\nshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n#else\nvec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\nfloat fDepth = unpackDepth( rgbaDepth );\nif ( fDepth < shadowCoord.z )\nshadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n#endif\n}\n#ifdef SHADOWMAP_DEBUG\n#ifdef SHADOWMAP_CASCADE\nif ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\n#else\nif ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\n#endif\n#endif\n}\n#ifdef GAMMA_OUTPUT\nshadowColor *= shadowColor;\n#endif\ngl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\n#endif',
  shadowmap_pars_vertex: '#ifdef USE_SHADOWMAP\nvarying vec4 vShadowCoord[ MAX_SHADOWS ];\nuniform mat4 shadowMatrix[ MAX_SHADOWS ];\n#endif',
  shadowmap_vertex: '#ifdef USE_SHADOWMAP\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\nvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n}\n#endif',
  alphatest_fragment: '#ifdef ALPHATEST\nif ( gl_FragColor.a < ALPHATEST ) discard;\n#endif',
  linear_to_gamma_fragment: '#ifdef GAMMA_OUTPUT\ngl_FragColor.xyz = sqrt( gl_FragColor.xyz );\n#endif'
};
THREE.UniformsUtils = {
  merge: function (a) {
    var b, c, d, e = {};
    for (b = 0; b < a.length; b++)
      for (c in d = this.clone(a[b]), d)
        e[c] = d[c];
    return e;
  },
  clone: function (a) {
    var b, c, d, e = {};
    for (b in a)
      for (c in e[b] = {}, a[b])
        d = a[b][c], e[b][c] = d instanceof THREE.Color || d instanceof THREE.Vector2 || d instanceof THREE.Vector3 || d instanceof THREE.Vector4 || d instanceof THREE.Matrix4 || d instanceof THREE.Texture ? d.clone() : d instanceof Array ? d.slice() : d;
    return e;
  }
};
THREE.UniformsLib = {
  common: {
    diffuse: {
      type: 'c',
      value: new THREE.Color(15658734)
    },
    opacity: {
      type: 'f',
      value: 1
    },
    map: {
      type: 't',
      value: null
    },
    offsetRepeat: {
      type: 'v4',
      value: new THREE.Vector4(0, 0, 1, 1)
    },
    lightMap: {
      type: 't',
      value: null
    },
    specularMap: {
      type: 't',
      value: null
    },
    envMap: {
      type: 't',
      value: null
    },
    flipEnvMap: {
      type: 'f',
      value: -1
    },
    useRefract: {
      type: 'i',
      value: 0
    },
    reflectivity: {
      type: 'f',
      value: 1
    },
    refractionRatio: {
      type: 'f',
      value: 0.98
    },
    combine: {
      type: 'i',
      value: 0
    },
    morphTargetInfluences: {
      type: 'f',
      value: 0
    }
  },
  bump: {
    bumpMap: {
      type: 't',
      value: null
    },
    bumpScale: {
      type: 'f',
      value: 1
    }
  },
  normalmap: {
    normalMap: {
      type: 't',
      value: null
    },
    normalScale: {
      type: 'v2',
      value: new THREE.Vector2(1, 1)
    }
  },
  fog: {
    fogDensity: {
      type: 'f',
      value: 0.00025
    },
    fogNear: {
      type: 'f',
      value: 1
    },
    fogFar: {
      type: 'f',
      value: 2000
    },
    fogColor: {
      type: 'c',
      value: new THREE.Color(16777215)
    }
  },
  lights: {
    ambientLightColor: {
      type: 'fv',
      value: []
    },
    directionalLightDirection: {
      type: 'fv',
      value: []
    },
    directionalLightColor: {
      type: 'fv',
      value: []
    },
    hemisphereLightDirection: {
      type: 'fv',
      value: []
    },
    hemisphereLightSkyColor: {
      type: 'fv',
      value: []
    },
    hemisphereLightGroundColor: {
      type: 'fv',
      value: []
    },
    pointLightColor: {
      type: 'fv',
      value: []
    },
    pointLightPosition: {
      type: 'fv',
      value: []
    },
    pointLightDistance: {
      type: 'fv1',
      value: []
    },
    spotLightColor: {
      type: 'fv',
      value: []
    },
    spotLightPosition: {
      type: 'fv',
      value: []
    },
    spotLightDirection: {
      type: 'fv',
      value: []
    },
    spotLightDistance: {
      type: 'fv1',
      value: []
    },
    spotLightAngleCos: {
      type: 'fv1',
      value: []
    },
    spotLightExponent: {
      type: 'fv1',
      value: []
    }
  },
  particle: {
    psColor: {
      type: 'c',
      value: new THREE.Color(15658734)
    },
    opacity: {
      type: 'f',
      value: 1
    },
    size: {
      type: 'f',
      value: 1
    },
    scale: {
      type: 'f',
      value: 1
    },
    map: {
      type: 't',
      value: null
    },
    fogDensity: {
      type: 'f',
      value: 0.00025
    },
    fogNear: {
      type: 'f',
      value: 1
    },
    fogFar: {
      type: 'f',
      value: 2000
    },
    fogColor: {
      type: 'c',
      value: new THREE.Color(16777215)
    }
  },
  shadowmap: {
    shadowMap: {
      type: 'tv',
      value: []
    },
    shadowMapSize: {
      type: 'v2v',
      value: []
    },
    shadowBias: {
      type: 'fv1',
      value: []
    },
    shadowDarkness: {
      type: 'fv1',
      value: []
    },
    shadowMatrix: {
      type: 'm4v',
      value: []
    }
  }
};
THREE.ShaderLib = {
  basic: {
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib.common,
      THREE.UniformsLib.fog,
      THREE.UniformsLib.shadowmap
    ]),
    vertexShader: [
      THREE.ShaderChunk.map_pars_vertex,
      THREE.ShaderChunk.lightmap_pars_vertex,
      THREE.ShaderChunk.envmap_pars_vertex,
      THREE.ShaderChunk.color_pars_vertex,
      THREE.ShaderChunk.morphtarget_pars_vertex,
      THREE.ShaderChunk.skinning_pars_vertex,
      THREE.ShaderChunk.shadowmap_pars_vertex,
      'void main() {',
      THREE.ShaderChunk.map_vertex,
      THREE.ShaderChunk.lightmap_vertex,
      THREE.ShaderChunk.color_vertex,
      THREE.ShaderChunk.skinbase_vertex,
      '#ifdef USE_ENVMAP',
      THREE.ShaderChunk.morphnormal_vertex,
      THREE.ShaderChunk.skinnormal_vertex,
      THREE.ShaderChunk.defaultnormal_vertex,
      '#endif',
      THREE.ShaderChunk.morphtarget_vertex,
      THREE.ShaderChunk.skinning_vertex,
      THREE.ShaderChunk.default_vertex,
      THREE.ShaderChunk.worldpos_vertex,
      THREE.ShaderChunk.envmap_vertex,
      THREE.ShaderChunk.shadowmap_vertex,
      '}'
    ].join('\n'),
    fragmentShader: [
      'uniform vec3 diffuse;\nuniform float opacity;',
      THREE.ShaderChunk.color_pars_fragment,
      THREE.ShaderChunk.map_pars_fragment,
      THREE.ShaderChunk.lightmap_pars_fragment,
      THREE.ShaderChunk.envmap_pars_fragment,
      THREE.ShaderChunk.fog_pars_fragment,
      THREE.ShaderChunk.shadowmap_pars_fragment,
      THREE.ShaderChunk.specularmap_pars_fragment,
      'void main() {\ngl_FragColor = vec4( diffuse, opacity );',
      THREE.ShaderChunk.map_fragment,
      THREE.ShaderChunk.alphatest_fragment,
      THREE.ShaderChunk.specularmap_fragment,
      THREE.ShaderChunk.lightmap_fragment,
      THREE.ShaderChunk.color_fragment,
      THREE.ShaderChunk.envmap_fragment,
      THREE.ShaderChunk.shadowmap_fragment,
      THREE.ShaderChunk.linear_to_gamma_fragment,
      THREE.ShaderChunk.fog_fragment,
      '}'
    ].join('\n')
  },
  lambert: {
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib.common,
      THREE.UniformsLib.fog,
      THREE.UniformsLib.lights,
      THREE.UniformsLib.shadowmap,
      {
        ambient: {
          type: 'c',
          value: new THREE.Color(16777215)
        },
        emissive: {
          type: 'c',
          value: new THREE.Color(0)
        },
        wrapRGB: {
          type: 'v3',
          value: new THREE.Vector3(1, 1, 1)
        }
      }
    ]),
    vertexShader: [
      '#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\nvarying vec3 vLightBack;\n#endif',
      THREE.ShaderChunk.map_pars_vertex,
      THREE.ShaderChunk.lightmap_pars_vertex,
      THREE.ShaderChunk.envmap_pars_vertex,
      THREE.ShaderChunk.lights_lambert_pars_vertex,
      THREE.ShaderChunk.color_pars_vertex,
      THREE.ShaderChunk.morphtarget_pars_vertex,
      THREE.ShaderChunk.skinning_pars_vertex,
      THREE.ShaderChunk.shadowmap_pars_vertex,
      'void main() {',
      THREE.ShaderChunk.map_vertex,
      THREE.ShaderChunk.lightmap_vertex,
      THREE.ShaderChunk.color_vertex,
      THREE.ShaderChunk.morphnormal_vertex,
      THREE.ShaderChunk.skinbase_vertex,
      THREE.ShaderChunk.skinnormal_vertex,
      THREE.ShaderChunk.defaultnormal_vertex,
      THREE.ShaderChunk.morphtarget_vertex,
      THREE.ShaderChunk.skinning_vertex,
      THREE.ShaderChunk.default_vertex,
      THREE.ShaderChunk.worldpos_vertex,
      THREE.ShaderChunk.envmap_vertex,
      THREE.ShaderChunk.lights_lambert_vertex,
      THREE.ShaderChunk.shadowmap_vertex,
      '}'
    ].join('\n'),
    fragmentShader: [
      'uniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\nvarying vec3 vLightBack;\n#endif',
      THREE.ShaderChunk.color_pars_fragment,
      THREE.ShaderChunk.map_pars_fragment,
      THREE.ShaderChunk.lightmap_pars_fragment,
      THREE.ShaderChunk.envmap_pars_fragment,
      THREE.ShaderChunk.fog_pars_fragment,
      THREE.ShaderChunk.shadowmap_pars_fragment,
      THREE.ShaderChunk.specularmap_pars_fragment,
      'void main() {\ngl_FragColor = vec4( vec3 ( 1.0 ), opacity );',
      THREE.ShaderChunk.map_fragment,
      THREE.ShaderChunk.alphatest_fragment,
      THREE.ShaderChunk.specularmap_fragment,
      '#ifdef DOUBLE_SIDED\nif ( gl_FrontFacing )\ngl_FragColor.xyz *= vLightFront;\nelse\ngl_FragColor.xyz *= vLightBack;\n#else\ngl_FragColor.xyz *= vLightFront;\n#endif',
      THREE.ShaderChunk.lightmap_fragment,
      THREE.ShaderChunk.color_fragment,
      THREE.ShaderChunk.envmap_fragment,
      THREE.ShaderChunk.shadowmap_fragment,
      THREE.ShaderChunk.linear_to_gamma_fragment,
      THREE.ShaderChunk.fog_fragment,
      '}'
    ].join('\n')
  },
  phong: {
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib.common,
      THREE.UniformsLib.bump,
      THREE.UniformsLib.normalmap,
      THREE.UniformsLib.fog,
      THREE.UniformsLib.lights,
      THREE.UniformsLib.shadowmap,
      {
        ambient: {
          type: 'c',
          value: new THREE.Color(16777215)
        },
        emissive: {
          type: 'c',
          value: new THREE.Color(0)
        },
        specular: {
          type: 'c',
          value: new THREE.Color(1118481)
        },
        shininess: {
          type: 'f',
          value: 30
        },
        wrapRGB: {
          type: 'v3',
          value: new THREE.Vector3(1, 1, 1)
        }
      }
    ]),
    vertexShader: [
      '#define PHONG\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;',
      THREE.ShaderChunk.map_pars_vertex,
      THREE.ShaderChunk.lightmap_pars_vertex,
      THREE.ShaderChunk.envmap_pars_vertex,
      THREE.ShaderChunk.lights_phong_pars_vertex,
      THREE.ShaderChunk.color_pars_vertex,
      THREE.ShaderChunk.morphtarget_pars_vertex,
      THREE.ShaderChunk.skinning_pars_vertex,
      THREE.ShaderChunk.shadowmap_pars_vertex,
      'void main() {',
      THREE.ShaderChunk.map_vertex,
      THREE.ShaderChunk.lightmap_vertex,
      THREE.ShaderChunk.color_vertex,
      THREE.ShaderChunk.morphnormal_vertex,
      THREE.ShaderChunk.skinbase_vertex,
      THREE.ShaderChunk.skinnormal_vertex,
      THREE.ShaderChunk.defaultnormal_vertex,
      'vNormal = normalize( transformedNormal );',
      THREE.ShaderChunk.morphtarget_vertex,
      THREE.ShaderChunk.skinning_vertex,
      THREE.ShaderChunk.default_vertex,
      'vViewPosition = -mvPosition.xyz;',
      THREE.ShaderChunk.worldpos_vertex,
      THREE.ShaderChunk.envmap_vertex,
      THREE.ShaderChunk.lights_phong_vertex,
      THREE.ShaderChunk.shadowmap_vertex,
      '}'
    ].join('\n'),
    fragmentShader: [
      'uniform vec3 diffuse;\nuniform float opacity;\nuniform vec3 ambient;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;',
      THREE.ShaderChunk.color_pars_fragment,
      THREE.ShaderChunk.map_pars_fragment,
      THREE.ShaderChunk.lightmap_pars_fragment,
      THREE.ShaderChunk.envmap_pars_fragment,
      THREE.ShaderChunk.fog_pars_fragment,
      THREE.ShaderChunk.lights_phong_pars_fragment,
      THREE.ShaderChunk.shadowmap_pars_fragment,
      THREE.ShaderChunk.bumpmap_pars_fragment,
      THREE.ShaderChunk.normalmap_pars_fragment,
      THREE.ShaderChunk.specularmap_pars_fragment,
      'void main() {\ngl_FragColor = vec4( vec3 ( 1.0 ), opacity );',
      THREE.ShaderChunk.map_fragment,
      THREE.ShaderChunk.alphatest_fragment,
      THREE.ShaderChunk.specularmap_fragment,
      THREE.ShaderChunk.lights_phong_fragment,
      THREE.ShaderChunk.lightmap_fragment,
      THREE.ShaderChunk.color_fragment,
      THREE.ShaderChunk.envmap_fragment,
      THREE.ShaderChunk.shadowmap_fragment,
      THREE.ShaderChunk.linear_to_gamma_fragment,
      THREE.ShaderChunk.fog_fragment,
      '}'
    ].join('\n')
  },
  particle_basic: {
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib.particle,
      THREE.UniformsLib.shadowmap
    ]),
    vertexShader: [
      'uniform float size;\nuniform float scale;',
      THREE.ShaderChunk.color_pars_vertex,
      THREE.ShaderChunk.shadowmap_pars_vertex,
      'void main() {',
      THREE.ShaderChunk.color_vertex,
      'vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n#ifdef USE_SIZEATTENUATION\ngl_PointSize = size * ( scale / length( mvPosition.xyz ) );\n#else\ngl_PointSize = size;\n#endif\ngl_Position = projectionMatrix * mvPosition;',
      THREE.ShaderChunk.worldpos_vertex,
      THREE.ShaderChunk.shadowmap_vertex,
      '}'
    ].join('\n'),
    fragmentShader: [
      'uniform vec3 psColor;\nuniform float opacity;',
      THREE.ShaderChunk.color_pars_fragment,
      THREE.ShaderChunk.map_particle_pars_fragment,
      THREE.ShaderChunk.fog_pars_fragment,
      THREE.ShaderChunk.shadowmap_pars_fragment,
      'void main() {\ngl_FragColor = vec4( psColor, opacity );',
      THREE.ShaderChunk.map_particle_fragment,
      THREE.ShaderChunk.alphatest_fragment,
      THREE.ShaderChunk.color_fragment,
      THREE.ShaderChunk.shadowmap_fragment,
      THREE.ShaderChunk.fog_fragment,
      '}'
    ].join('\n')
  },
  dashed: {
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib.common,
      THREE.UniformsLib.fog,
      {
        scale: {
          type: 'f',
          value: 1
        },
        dashSize: {
          type: 'f',
          value: 1
        },
        totalSize: {
          type: 'f',
          value: 2
        }
      }
    ]),
    vertexShader: [
      'uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;',
      THREE.ShaderChunk.color_pars_vertex,
      'void main() {',
      THREE.ShaderChunk.color_vertex,
      'vLineDistance = scale * lineDistance;\nvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n}'
    ].join('\n'),
    fragmentShader: [
      'uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;',
      THREE.ShaderChunk.color_pars_fragment,
      THREE.ShaderChunk.fog_pars_fragment,
      'void main() {\nif ( mod( vLineDistance, totalSize ) > dashSize ) {\ndiscard;\n}\ngl_FragColor = vec4( diffuse, opacity );',
      THREE.ShaderChunk.color_fragment,
      THREE.ShaderChunk.fog_fragment,
      '}'
    ].join('\n')
  },
  depth: {
    uniforms: {
      mNear: {
        type: 'f',
        value: 1
      },
      mFar: {
        type: 'f',
        value: 2000
      },
      opacity: {
        type: 'f',
        value: 1
      }
    },
    vertexShader: 'void main() {\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}',
    fragmentShader: 'uniform float mNear;\nuniform float mFar;\nuniform float opacity;\nvoid main() {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat color = 1.0 - smoothstep( mNear, mFar, depth );\ngl_FragColor = vec4( vec3( color ), opacity );\n}'
  },
  normal: {
    uniforms: {
      opacity: {
        type: 'f',
        value: 1
      }
    },
    vertexShader: [
      'varying vec3 vNormal;',
      THREE.ShaderChunk.morphtarget_pars_vertex,
      'void main() {\nvNormal = normalize( normalMatrix * normal );',
      THREE.ShaderChunk.morphtarget_vertex,
      THREE.ShaderChunk.default_vertex,
      '}'
    ].join('\n'),
    fragmentShader: 'uniform float opacity;\nvarying vec3 vNormal;\nvoid main() {\ngl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );\n}'
  },
  normalmap: {
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib.fog,
      THREE.UniformsLib.lights,
      THREE.UniformsLib.shadowmap,
      {
        enableAO: {
          type: 'i',
          value: 0
        },
        enableDiffuse: {
          type: 'i',
          value: 0
        },
        enableSpecular: {
          type: 'i',
          value: 0
        },
        enableReflection: {
          type: 'i',
          value: 0
        },
        enableDisplacement: {
          type: 'i',
          value: 0
        },
        tDisplacement: {
          type: 't',
          value: null
        },
        tDiffuse: {
          type: 't',
          value: null
        },
        tCube: {
          type: 't',
          value: null
        },
        tNormal: {
          type: 't',
          value: null
        },
        tSpecular: {
          type: 't',
          value: null
        },
        tAO: {
          type: 't',
          value: null
        },
        uNormalScale: {
          type: 'v2',
          value: new THREE.Vector2(1, 1)
        },
        uDisplacementBias: {
          type: 'f',
          value: 0
        },
        uDisplacementScale: {
          type: 'f',
          value: 1
        },
        diffuse: {
          type: 'c',
          value: new THREE.Color(16777215)
        },
        specular: {
          type: 'c',
          value: new THREE.Color(1118481)
        },
        ambient: {
          type: 'c',
          value: new THREE.Color(16777215)
        },
        shininess: {
          type: 'f',
          value: 30
        },
        opacity: {
          type: 'f',
          value: 1
        },
        useRefract: {
          type: 'i',
          value: 0
        },
        refractionRatio: {
          type: 'f',
          value: 0.98
        },
        reflectivity: {
          type: 'f',
          value: 0.5
        },
        uOffset: {
          type: 'v2',
          value: new THREE.Vector2(0, 0)
        },
        uRepeat: {
          type: 'v2',
          value: new THREE.Vector2(1, 1)
        },
        wrapRGB: {
          type: 'v3',
          value: new THREE.Vector3(1, 1, 1)
        }
      }
    ]),
    fragmentShader: [
      'uniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\nuniform bool enableDiffuse;\nuniform bool enableSpecular;\nuniform bool enableAO;\nuniform bool enableReflection;\nuniform sampler2D tDiffuse;\nuniform sampler2D tNormal;\nuniform sampler2D tSpecular;\nuniform sampler2D tAO;\nuniform samplerCube tCube;\nuniform vec2 uNormalScale;\nuniform bool useRefract;\nuniform float refractionRatio;\nuniform float reflectivity;\nvarying vec3 vTangent;\nvarying vec3 vBinormal;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nuniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_HEMI_LIGHTS > 0\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n#endif\n#ifdef WRAP_AROUND\nuniform vec3 wrapRGB;\n#endif\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;',
      THREE.ShaderChunk.shadowmap_pars_fragment,
      THREE.ShaderChunk.fog_pars_fragment,
      'void main() {\ngl_FragColor = vec4( vec3( 1.0 ), opacity );\nvec3 specularTex = vec3( 1.0 );\nvec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;\nnormalTex.xy *= uNormalScale;\nnormalTex = normalize( normalTex );\nif( enableDiffuse ) {\n#ifdef GAMMA_INPUT\nvec4 texelColor = texture2D( tDiffuse, vUv );\ntexelColor.xyz *= texelColor.xyz;\ngl_FragColor = gl_FragColor * texelColor;\n#else\ngl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );\n#endif\n}\nif( enableAO ) {\n#ifdef GAMMA_INPUT\nvec4 aoColor = texture2D( tAO, vUv );\naoColor.xyz *= aoColor.xyz;\ngl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;\n#else\ngl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;\n#endif\n}\nif( enableSpecular )\nspecularTex = texture2D( tSpecular, vUv ).xyz;\nmat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );\nvec3 finalNormal = tsb * normalTex;\n#ifdef FLIP_SIDED\nfinalNormal = -finalNormal;\n#endif\nvec3 normal = normalize( finalNormal );\nvec3 viewPosition = normalize( vViewPosition );\n#if MAX_POINT_LIGHTS > 0\nvec3 pointDiffuse = vec3( 0.0 );\nvec3 pointSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\nvec3 pointVector = lPosition.xyz + vViewPosition.xyz;\nfloat pointDistance = 1.0;\nif ( pointLightDistance[ i ] > 0.0 )\npointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );\npointVector = normalize( pointVector );\n#ifdef WRAP_AROUND\nfloat pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );\nfloat pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );\nvec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n#else\nfloat pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );\n#endif\npointDiffuse += pointDistance * pointLightColor[ i ] * diffuse * pointDiffuseWeight;\nvec3 pointHalfVector = normalize( pointVector + viewPosition );\nfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\nfloat pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( pointVector, pointHalfVector ), 5.0 );\npointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;\n}\n#endif\n#if MAX_SPOT_LIGHTS > 0\nvec3 spotDiffuse = vec3( 0.0 );\nvec3 spotSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\nvec3 spotVector = lPosition.xyz + vViewPosition.xyz;\nfloat spotDistance = 1.0;\nif ( spotLightDistance[ i ] > 0.0 )\nspotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );\nspotVector = normalize( spotVector );\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\nif ( spotEffect > spotLightAngleCos[ i ] ) {\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\n#ifdef WRAP_AROUND\nfloat spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );\nfloat spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );\nvec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n#else\nfloat spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );\n#endif\nspotDiffuse += spotDistance * spotLightColor[ i ] * diffuse * spotDiffuseWeight * spotEffect;\nvec3 spotHalfVector = normalize( spotVector + viewPosition );\nfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\nfloat spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( spotVector, spotHalfVector ), 5.0 );\nspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;\n}\n}\n#endif\n#if MAX_DIR_LIGHTS > 0\nvec3 dirDiffuse = vec3( 0.0 );\nvec3 dirSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\nvec3 dirVector = normalize( lDirection.xyz );\n#ifdef WRAP_AROUND\nfloat directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );\nfloat directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );\nvec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );\n#else\nfloat dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );\n#endif\ndirDiffuse += directionalLightColor[ i ] * diffuse * dirDiffuseWeight;\nvec3 dirHalfVector = normalize( dirVector + viewPosition );\nfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\nfloat dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\ndirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n}\n#endif\n#if MAX_HEMI_LIGHTS > 0\nvec3 hemiDiffuse  = vec3( 0.0 );\nvec3 hemiSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\nvec3 lVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( normal, lVector );\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\nvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\nhemiDiffuse += diffuse * hemiColor;\nvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\nfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\nfloat hemiSpecularWeightSky = specularTex.r * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\nvec3 lVectorGround = -lVector;\nvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\nfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\nfloat hemiSpecularWeightGround = specularTex.r * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\nfloat dotProductGround = dot( normal, lVectorGround );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\nvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\nhemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n}\n#endif\nvec3 totalDiffuse = vec3( 0.0 );\nvec3 totalSpecular = vec3( 0.0 );\n#if MAX_DIR_LIGHTS > 0\ntotalDiffuse += dirDiffuse;\ntotalSpecular += dirSpecular;\n#endif\n#if MAX_HEMI_LIGHTS > 0\ntotalDiffuse += hemiDiffuse;\ntotalSpecular += hemiSpecular;\n#endif\n#if MAX_POINT_LIGHTS > 0\ntotalDiffuse += pointDiffuse;\ntotalSpecular += pointSpecular;\n#endif\n#if MAX_SPOT_LIGHTS > 0\ntotalDiffuse += spotDiffuse;\ntotalSpecular += spotSpecular;\n#endif\n#ifdef METAL\ngl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient + totalSpecular );\n#else\ngl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n#endif\nif ( enableReflection ) {\nvec3 vReflect;\nvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\nif ( useRefract ) {\nvReflect = refract( cameraToVertex, normal, refractionRatio );\n} else {\nvReflect = reflect( cameraToVertex, normal );\n}\nvec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\n#ifdef GAMMA_INPUT\ncubeColor.xyz *= cubeColor.xyz;\n#endif\ngl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * reflectivity );\n}',
      THREE.ShaderChunk.shadowmap_fragment,
      THREE.ShaderChunk.linear_to_gamma_fragment,
      THREE.ShaderChunk.fog_fragment,
      '}'
    ].join('\n'),
    vertexShader: [
      'attribute vec4 tangent;\nuniform vec2 uOffset;\nuniform vec2 uRepeat;\nuniform bool enableDisplacement;\n#ifdef VERTEX_TEXTURES\nuniform sampler2D tDisplacement;\nuniform float uDisplacementScale;\nuniform float uDisplacementBias;\n#endif\nvarying vec3 vTangent;\nvarying vec3 vBinormal;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;',
      THREE.ShaderChunk.skinning_pars_vertex,
      THREE.ShaderChunk.shadowmap_pars_vertex,
      'void main() {',
      THREE.ShaderChunk.skinbase_vertex,
      THREE.ShaderChunk.skinnormal_vertex,
      '#ifdef USE_SKINNING\nvNormal = normalize( normalMatrix * skinnedNormal.xyz );\nvec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );\nvTangent = normalize( normalMatrix * skinnedTangent.xyz );\n#else\nvNormal = normalize( normalMatrix * normal );\nvTangent = normalize( normalMatrix * tangent.xyz );\n#endif\nvBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );\nvUv = uv * uRepeat + uOffset;\nvec3 displacedPosition;\n#ifdef VERTEX_TEXTURES\nif ( enableDisplacement ) {\nvec3 dv = texture2D( tDisplacement, uv ).xyz;\nfloat df = uDisplacementScale * dv.x + uDisplacementBias;\ndisplacedPosition = position + normalize( normal ) * df;\n} else {\n#ifdef USE_SKINNING\nvec4 skinVertex = vec4( position, 1.0 );\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\nskinned \t  += boneMatY * skinVertex * skinWeight.y;\ndisplacedPosition  = skinned.xyz;\n#else\ndisplacedPosition = position;\n#endif\n}\n#else\n#ifdef USE_SKINNING\nvec4 skinVertex = vec4( position, 1.0 );\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\nskinned \t  += boneMatY * skinVertex * skinWeight.y;\ndisplacedPosition  = skinned.xyz;\n#else\ndisplacedPosition = position;\n#endif\n#endif\nvec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );\nvec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\nvWorldPosition = worldPosition.xyz;\nvViewPosition = -mvPosition.xyz;\n#ifdef USE_SHADOWMAP\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\nvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n}\n#endif\n}'
    ].join('\n')
  },
  cube: {
    uniforms: {
      tCube: {
        type: 't',
        value: null
      },
      tFlip: {
        type: 'f',
        value: -1
      }
    },
    vertexShader: 'varying vec3 vWorldPosition;\nvoid main() {\nvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\nvWorldPosition = worldPosition.xyz;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}',
    fragmentShader: 'uniform samplerCube tCube;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\nvoid main() {\ngl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n}'
  },
  depthRGBA: {
    uniforms: {},
    vertexShader: [
      THREE.ShaderChunk.morphtarget_pars_vertex,
      THREE.ShaderChunk.skinning_pars_vertex,
      'void main() {',
      THREE.ShaderChunk.skinbase_vertex,
      THREE.ShaderChunk.morphtarget_vertex,
      THREE.ShaderChunk.skinning_vertex,
      THREE.ShaderChunk.default_vertex,
      '}'
    ].join('\n'),
    fragmentShader: 'vec4 pack_depth( const in float depth ) {\nconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\nconst vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\nvec4 res = fract( depth * bit_shift );\nres -= res.xxyz * bit_mask;\nreturn res;\n}\nvoid main() {\ngl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\n}'
  }
};
THREE.WebGLRenderer = function (a) {
  function b(a, b) {
    var c = a.vertices.length, d = b.material;
    if (d.attributes) {
      void 0 === a.__webglCustomAttributesList && (a.__webglCustomAttributesList = []);
      for (var e in d.attributes) {
        var f = d.attributes[e];
        if (!f.__webglInitialized || f.createUniqueBuffers) {
          f.__webglInitialized = !0;
          var g = 1;
          'v2' === f.type ? g = 2 : 'v3' === f.type ? g = 3 : 'v4' === f.type ? g = 4 : 'c' === f.type && (g = 3);
          f.size = g;
          f.array = new Float32Array(c * g);
          f.buffer = m.createBuffer();
          f.buffer.belongsToAttribute = e;
          f.needsUpdate = !0;
        }
        a.__webglCustomAttributesList.push(f);
      }
    }
  }
  function c(a, b) {
    var c = b.geometry, g = a.faces3, h = 3 * g.length, k = 1 * g.length, l = 3 * g.length, g = d(b, a), n = f(g), p = e(g), q = g.vertexColors ? g.vertexColors : !1;
    a.__vertexArray = new Float32Array(3 * h);
    p && (a.__normalArray = new Float32Array(3 * h));
    c.hasTangents && (a.__tangentArray = new Float32Array(4 * h));
    q && (a.__colorArray = new Float32Array(3 * h));
    n && (0 < c.faceVertexUvs.length && (a.__uvArray = new Float32Array(2 * h)), 1 < c.faceVertexUvs.length && (a.__uv2Array = new Float32Array(2 * h)));
    b.geometry.skinWeights.length && b.geometry.skinIndices.length && (a.__skinIndexArray = new Float32Array(4 * h), a.__skinWeightArray = new Float32Array(4 * h));
    a.__faceArray = new Uint16Array(3 * k);
    a.__lineArray = new Uint16Array(2 * l);
    if (a.numMorphTargets)
      for (a.__morphTargetsArrays = [], c = 0, n = a.numMorphTargets; c < n; c++)
        a.__morphTargetsArrays.push(new Float32Array(3 * h));
    if (a.numMorphNormals)
      for (a.__morphNormalsArrays = [], c = 0, n = a.numMorphNormals; c < n; c++)
        a.__morphNormalsArrays.push(new Float32Array(3 * h));
    a.__webglFaceCount = 3 * k;
    a.__webglLineCount = 2 * l;
    if (g.attributes) {
      void 0 === a.__webglCustomAttributesList && (a.__webglCustomAttributesList = []);
      for (var r in g.attributes) {
        var k = g.attributes[r], l = {}, s;
        for (s in k)
          l[s] = k[s];
        if (!l.__webglInitialized || l.createUniqueBuffers)
          l.__webglInitialized = !0, c = 1, 'v2' === l.type ? c = 2 : 'v3' === l.type ? c = 3 : 'v4' === l.type ? c = 4 : 'c' === l.type && (c = 3), l.size = c, l.array = new Float32Array(h * c), l.buffer = m.createBuffer(), l.buffer.belongsToAttribute = r, k.needsUpdate = !0, l.__original = k;
        a.__webglCustomAttributesList.push(l);
      }
    }
    a.__inittedArrays = !0;
  }
  function d(a, b) {
    return a.material instanceof THREE.MeshFaceMaterial ? a.material.materials[b.materialIndex] : a.material;
  }
  function e(a) {
    return a instanceof THREE.MeshBasicMaterial && !a.envMap || a instanceof THREE.MeshDepthMaterial ? !1 : a && void 0 !== a.shading && a.shading === THREE.SmoothShading ? THREE.SmoothShading : THREE.FlatShading;
  }
  function f(a) {
    return a.map || a.lightMap || a.bumpMap || a.normalMap || a.specularMap || a instanceof THREE.ShaderMaterial ? !0 : !1;
  }
  function g(a, b, c, d) {
    var e, f, g, k;
    for (f in b)
      g = b[f], e = c[f], 0 <= g && (e ? (k = e.itemSize, m.bindBuffer(m.ARRAY_BUFFER, e.buffer), h(g), m.vertexAttribPointer(g, k, m.FLOAT, !1, 0, d * k * 4)) : a.defaultAttributeValues && (2 === a.defaultAttributeValues[f].length ? m.vertexAttrib2fv(g, a.defaultAttributeValues[f]) : 3 === a.defaultAttributeValues[f].length && m.vertexAttrib3fv(g, a.defaultAttributeValues[f])));
  }
  function h(a) {
    0 === Ea[a] && (m.enableVertexAttribArray(a), Ea[a] = 1);
  }
  function k() {
    for (var a in Ea)
      1 === Ea[a] && (m.disableVertexAttribArray(a), Ea[a] = 0);
  }
  function l(a, b) {
    return a.z !== b.z ? b.z - a.z : a.id - b.id;
  }
  function n(a, b) {
    return b[0] - a[0];
  }
  function s(a, b, c) {
    if (a.length)
      for (var d = 0, e = a.length; d < e; d++)
        Fa = T = null, S = $ = za = oa = la = Ka = Aa = -1, Na = !0, a[d].render(b, c, Wa, La), Fa = T = null, S = $ = za = oa = la = Ka = Aa = -1, Na = !0;
  }
  function r(a, b, c, d, e, f, g, h) {
    var k, m, l, n;
    b ? (m = a.length - 1, n = b = -1) : (m = 0, b = a.length, n = 1);
    for (var p = m; p !== b; p += n)
      if (k = a[p], k.render) {
        m = k.object;
        l = k.buffer;
        if (h)
          k = h;
        else {
          k = k[c];
          if (!k)
            continue;
          g && N.setBlending(k.blending, k.blendEquation, k.blendSrc, k.blendDst);
          N.setDepthTest(k.depthTest);
          N.setDepthWrite(k.depthWrite);
          I(k.polygonOffset, k.polygonOffsetFactor, k.polygonOffsetUnits);
        }
        N.setMaterialFaces(k);
        l instanceof THREE.BufferGeometry ? N.renderBufferDirect(d, e, f, k, l, m) : N.renderBuffer(d, e, f, k, l, m);
      }
  }
  function q(a, b, c, d, e, f, g) {
    for (var h, k, m = 0, l = a.length; m < l; m++)
      if (h = a[m], k = h.object, k.visible) {
        if (g)
          h = g;
        else {
          h = h[b];
          if (!h)
            continue;
          f && N.setBlending(h.blending, h.blendEquation, h.blendSrc, h.blendDst);
          N.setDepthTest(h.depthTest);
          N.setDepthWrite(h.depthWrite);
          I(h.polygonOffset, h.polygonOffsetFactor, h.polygonOffsetUnits);
        }
        N.renderImmediateObject(c, d, e, h, k);
      }
  }
  function u(a, d) {
    var e, f, g;
    if (void 0 === a.__webglInit && (a.__webglInit = !0, a._modelViewMatrix = new THREE.Matrix4(), a._normalMatrix = new THREE.Matrix3(), void 0 !== a.geometry && void 0 === a.geometry.__webglInit && (a.geometry.__webglInit = !0, a.geometry.addEventListener('dispose', Kb)), f = a.geometry, void 0 !== f))
      if (f instanceof THREE.BufferGeometry) {
        var h, k;
        for (g in f.attributes)
          k = 'index' === g ? m.ELEMENT_ARRAY_BUFFER : m.ARRAY_BUFFER, h = f.attributes[g], h.buffer = m.createBuffer(), m.bindBuffer(k, h.buffer), m.bufferData(k, h.array, m.STATIC_DRAW);
      } else if (a instanceof THREE.Mesh)
        for (e in g = a.material, void 0 === f.geometryGroups && f.makeGroups(g instanceof THREE.MeshFaceMaterial), f.geometryGroups) {
          if (g = f.geometryGroups[e], !g.__webglVertexBuffer) {
            h = g;
            h.__webglVertexBuffer = m.createBuffer();
            h.__webglNormalBuffer = m.createBuffer();
            h.__webglTangentBuffer = m.createBuffer();
            h.__webglColorBuffer = m.createBuffer();
            h.__webglUVBuffer = m.createBuffer();
            h.__webglUV2Buffer = m.createBuffer();
            h.__webglSkinIndicesBuffer = m.createBuffer();
            h.__webglSkinWeightsBuffer = m.createBuffer();
            h.__webglFaceBuffer = m.createBuffer();
            h.__webglLineBuffer = m.createBuffer();
            var l = k = void 0;
            if (h.numMorphTargets)
              for (h.__webglMorphTargetsBuffers = [], k = 0, l = h.numMorphTargets; k < l; k++)
                h.__webglMorphTargetsBuffers.push(m.createBuffer());
            if (h.numMorphNormals)
              for (h.__webglMorphNormalsBuffers = [], k = 0, l = h.numMorphNormals; k < l; k++)
                h.__webglMorphNormalsBuffers.push(m.createBuffer());
            N.info.memory.geometries++;
            c(g, a);
            f.verticesNeedUpdate = !0;
            f.morphTargetsNeedUpdate = !0;
            f.elementsNeedUpdate = !0;
            f.uvsNeedUpdate = !0;
            f.normalsNeedUpdate = !0;
            f.tangentsNeedUpdate = !0;
            f.colorsNeedUpdate = !0;
          }
        }
      else
        a instanceof THREE.Line ? f.__webglVertexBuffer || (g = f, g.__webglVertexBuffer = m.createBuffer(), g.__webglColorBuffer = m.createBuffer(), g.__webglLineDistanceBuffer = m.createBuffer(), N.info.memory.geometries++, g = f, h = g.vertices.length, g.__vertexArray = new Float32Array(3 * h), g.__colorArray = new Float32Array(3 * h), g.__lineDistanceArray = new Float32Array(1 * h), g.__webglLineCount = h, b(g, a), f.verticesNeedUpdate = !0, f.colorsNeedUpdate = !0, f.lineDistancesNeedUpdate = !0) : a instanceof THREE.ParticleSystem && !f.__webglVertexBuffer && (g = f, g.__webglVertexBuffer = m.createBuffer(), g.__webglColorBuffer = m.createBuffer(), N.info.memory.geometries++, g = f, h = g.vertices.length, g.__vertexArray = new Float32Array(3 * h), g.__colorArray = new Float32Array(3 * h), g.__sortArray = [], g.__webglParticleCount = h, b(g, a), f.verticesNeedUpdate = !0, f.colorsNeedUpdate = !0);
    if (void 0 === a.__webglActive) {
      if (a instanceof THREE.Mesh)
        if (f = a.geometry, f instanceof THREE.BufferGeometry)
          p(d.__webglObjects, f, a);
        else {
          if (f instanceof THREE.Geometry)
            for (e in f.geometryGroups)
              g = f.geometryGroups[e], p(d.__webglObjects, g, a);
        }
      else
        a instanceof THREE.Line || a instanceof THREE.ParticleSystem ? (f = a.geometry, p(d.__webglObjects, f, a)) : a instanceof THREE.ImmediateRenderObject || a.immediateRenderCallback ? d.__webglObjectsImmediate.push({
          id: null,
          object: a,
          opaque: null,
          transparent: null,
          z: 0
        }) : a instanceof THREE.Sprite ? d.__webglSprites.push(a) : a instanceof THREE.LensFlare && d.__webglFlares.push(a);
      a.__webglActive = !0;
    }
  }
  function p(a, b, c) {
    a.push({
      id: null,
      buffer: b,
      object: c,
      opaque: null,
      transparent: null,
      z: 0
    });
  }
  function v(a) {
    for (var b in a.attributes)
      if (a.attributes[b].needsUpdate)
        return !0;
    return !1;
  }
  function w(a) {
    for (var b in a.attributes)
      a.attributes[b].needsUpdate = !1;
  }
  function t(a, b) {
    a instanceof THREE.Mesh || a instanceof THREE.ParticleSystem || a instanceof THREE.Line ? x(b.__webglObjects, a) : a instanceof THREE.Sprite ? z(b.__webglSprites, a) : a instanceof THREE.LensFlare ? z(b.__webglFlares, a) : (a instanceof THREE.ImmediateRenderObject || a.immediateRenderCallback) && x(b.__webglObjectsImmediate, a);
    delete a.__webglActive;
  }
  function x(a, b) {
    for (var c = a.length - 1; 0 <= c; c--)
      a[c].object === b && a.splice(c, 1);
  }
  function z(a, b) {
    for (var c = a.length - 1; 0 <= c; c--)
      a[c] === b && a.splice(c, 1);
  }
  function B(a, b, c, d, e) {
    ta = 0;
    d.needsUpdate && (d.program && Eb(d), N.initMaterial(d, b, c, e), d.needsUpdate = !1);
    d.morphTargets && !e.__webglMorphTargetInfluences && (e.__webglMorphTargetInfluences = new Float32Array(N.maxMorphTargets));
    var f = !1, g = d.program, h = g.uniforms, k = d.uniforms;
    g !== T && (m.useProgram(g), T = g, f = !0);
    d.id !== S && (S = d.id, f = !0);
    if (f || a !== Fa)
      m.uniformMatrix4fv(h.projectionMatrix, !1, a.projectionMatrix.elements), a !== Fa && (Fa = a);
    if (d.skinning)
      if (ub && e.useVertexTexture) {
        if (null !== h.boneTexture) {
          var l = E();
          m.uniform1i(h.boneTexture, l);
          N.setTexture(e.boneTexture, l);
        }
        null !== h.boneTextureWidth && m.uniform1i(h.boneTextureWidth, e.boneTextureWidth);
        null !== h.boneTextureHeight && m.uniform1i(h.boneTextureHeight, e.boneTextureHeight);
      } else
        null !== h.boneGlobalMatrices && m.uniformMatrix4fv(h.boneGlobalMatrices, !1, e.boneMatrices);
    if (f) {
      c && d.fog && (k.fogColor.value = c.color, c instanceof THREE.Fog ? (k.fogNear.value = c.near, k.fogFar.value = c.far) : c instanceof THREE.FogExp2 && (k.fogDensity.value = c.density));
      if (d instanceof THREE.MeshPhongMaterial || d instanceof THREE.MeshLambertMaterial || d.lights) {
        if (Na) {
          var n, p = l = 0, q = 0, r, s, u, t = ha, v = t.directional.colors, w = t.directional.positions, x = t.point.colors, z = t.point.positions, B = t.point.distances, I = t.spot.colors, C = t.spot.positions, F = t.spot.distances, G = t.spot.directions, O = t.spot.anglesCos, J = t.spot.exponents, Q = t.hemi.skyColors, K = t.hemi.groundColors, ca = t.hemi.positions, R = 0, Y = 0, W = 0, sa = 0, cc = 0, dc = 0, Z = 0, oa = 0, V = n = 0;
          c = u = V = 0;
          for (f = b.length; c < f; c++)
            if (n = b[c], !n.onlyShadow)
              if (r = n.color, s = n.intensity, u = n.distance, n instanceof THREE.AmbientLight)
                n.visible && (N.gammaInput ? (l += r.r * r.r, p += r.g * r.g, q += r.b * r.b) : (l += r.r, p += r.g, q += r.b));
              else if (n instanceof THREE.DirectionalLight) {
                if (cc += 1, n.visible && (ia.setFromMatrixPosition(n.matrixWorld), ya.setFromMatrixPosition(n.target.matrixWorld), ia.sub(ya), ia.normalize(), 0 !== ia.x || 0 !== ia.y || 0 !== ia.z))
                  n = 3 * R, w[n] = ia.x, w[n + 1] = ia.y, w[n + 2] = ia.z, N.gammaInput ? H(v, n, r, s * s) : D(v, n, r, s), R += 1;
              } else
                n instanceof THREE.PointLight ? (dc += 1, n.visible && (V = 3 * Y, N.gammaInput ? H(x, V, r, s * s) : D(x, V, r, s), ya.setFromMatrixPosition(n.matrixWorld), z[V] = ya.x, z[V + 1] = ya.y, z[V + 2] = ya.z, B[Y] = u, Y += 1)) : n instanceof THREE.SpotLight ? (Z += 1, n.visible && (V = 3 * W, N.gammaInput ? H(I, V, r, s * s) : D(I, V, r, s), ya.setFromMatrixPosition(n.matrixWorld), C[V] = ya.x, C[V + 1] = ya.y, C[V + 2] = ya.z, F[W] = u, ia.copy(ya), ya.setFromMatrixPosition(n.target.matrixWorld), ia.sub(ya), ia.normalize(), G[V] = ia.x, G[V + 1] = ia.y, G[V + 2] = ia.z, O[W] = Math.cos(n.angle), J[W] = n.exponent, W += 1)) : n instanceof THREE.HemisphereLight && (oa += 1, n.visible && (ia.setFromMatrixPosition(n.matrixWorld), ia.normalize(), 0 !== ia.x || 0 !== ia.y || 0 !== ia.z)) && (u = 3 * sa, ca[u] = ia.x, ca[u + 1] = ia.y, ca[u + 2] = ia.z, r = n.color, n = n.groundColor, N.gammaInput ? (s *= s, H(Q, u, r, s), H(K, u, n, s)) : (D(Q, u, r, s), D(K, u, n, s)), sa += 1);
          c = 3 * R;
          for (f = Math.max(v.length, 3 * cc); c < f; c++)
            v[c] = 0;
          c = 3 * Y;
          for (f = Math.max(x.length, 3 * dc); c < f; c++)
            x[c] = 0;
          c = 3 * W;
          for (f = Math.max(I.length, 3 * Z); c < f; c++)
            I[c] = 0;
          c = 3 * sa;
          for (f = Math.max(Q.length, 3 * oa); c < f; c++)
            Q[c] = 0;
          c = 3 * sa;
          for (f = Math.max(K.length, 3 * oa); c < f; c++)
            K[c] = 0;
          t.directional.length = R;
          t.point.length = Y;
          t.spot.length = W;
          t.hemi.length = sa;
          t.ambient[0] = l;
          t.ambient[1] = p;
          t.ambient[2] = q;
          Na = !1;
        }
        c = ha;
        k.ambientLightColor.value = c.ambient;
        k.directionalLightColor.value = c.directional.colors;
        k.directionalLightDirection.value = c.directional.positions;
        k.pointLightColor.value = c.point.colors;
        k.pointLightPosition.value = c.point.positions;
        k.pointLightDistance.value = c.point.distances;
        k.spotLightColor.value = c.spot.colors;
        k.spotLightPosition.value = c.spot.positions;
        k.spotLightDistance.value = c.spot.distances;
        k.spotLightDirection.value = c.spot.directions;
        k.spotLightAngleCos.value = c.spot.anglesCos;
        k.spotLightExponent.value = c.spot.exponents;
        k.hemisphereLightSkyColor.value = c.hemi.skyColors;
        k.hemisphereLightGroundColor.value = c.hemi.groundColors;
        k.hemisphereLightDirection.value = c.hemi.positions;
      }
      if (d instanceof THREE.MeshBasicMaterial || d instanceof THREE.MeshLambertMaterial || d instanceof THREE.MeshPhongMaterial) {
        k.opacity.value = d.opacity;
        N.gammaInput ? k.diffuse.value.copyGammaToLinear(d.color) : k.diffuse.value = d.color;
        k.map.value = d.map;
        k.lightMap.value = d.lightMap;
        k.specularMap.value = d.specularMap;
        d.bumpMap && (k.bumpMap.value = d.bumpMap, k.bumpScale.value = d.bumpScale);
        d.normalMap && (k.normalMap.value = d.normalMap, k.normalScale.value.copy(d.normalScale));
        var $;
        d.map ? $ = d.map : d.specularMap ? $ = d.specularMap : d.normalMap ? $ = d.normalMap : d.bumpMap && ($ = d.bumpMap);
        void 0 !== $ && (c = $.offset, $ = $.repeat, k.offsetRepeat.value.set(c.x, c.y, $.x, $.y));
        k.envMap.value = d.envMap;
        k.flipEnvMap.value = d.envMap instanceof THREE.WebGLRenderTargetCube ? 1 : -1;
        k.reflectivity.value = d.reflectivity;
        k.refractionRatio.value = d.refractionRatio;
        k.combine.value = d.combine;
        k.useRefract.value = d.envMap && d.envMap.mapping instanceof THREE.CubeRefractionMapping;
      }
      d instanceof THREE.LineBasicMaterial ? (k.diffuse.value = d.color, k.opacity.value = d.opacity) : d instanceof THREE.LineDashedMaterial ? (k.diffuse.value = d.color, k.opacity.value = d.opacity, k.dashSize.value = d.dashSize, k.totalSize.value = d.dashSize + d.gapSize, k.scale.value = d.scale) : d instanceof THREE.ParticleSystemMaterial ? (k.psColor.value = d.color, k.opacity.value = d.opacity, k.size.value = d.size, k.scale.value = L.height / 2, k.map.value = d.map) : d instanceof THREE.MeshPhongMaterial ? (k.shininess.value = d.shininess, N.gammaInput ? (k.ambient.value.copyGammaToLinear(d.ambient), k.emissive.value.copyGammaToLinear(d.emissive), k.specular.value.copyGammaToLinear(d.specular)) : (k.ambient.value = d.ambient, k.emissive.value = d.emissive, k.specular.value = d.specular), d.wrapAround && k.wrapRGB.value.copy(d.wrapRGB)) : d instanceof THREE.MeshLambertMaterial ? (N.gammaInput ? (k.ambient.value.copyGammaToLinear(d.ambient), k.emissive.value.copyGammaToLinear(d.emissive)) : (k.ambient.value = d.ambient, k.emissive.value = d.emissive), d.wrapAround && k.wrapRGB.value.copy(d.wrapRGB)) : d instanceof THREE.MeshDepthMaterial ? (k.mNear.value = a.near, k.mFar.value = a.far, k.opacity.value = d.opacity) : d instanceof THREE.MeshNormalMaterial && (k.opacity.value = d.opacity);
      if (e.receiveShadow && !d._shadowPass && k.shadowMatrix)
        for (c = $ = 0, f = b.length; c < f; c++)
          l = b[c], l.castShadow && (l instanceof THREE.SpotLight || l instanceof THREE.DirectionalLight && !l.shadowCascade) && (k.shadowMap.value[$] = l.shadowMap, k.shadowMapSize.value[$] = l.shadowMapSize, k.shadowMatrix.value[$] = l.shadowMatrix, k.shadowDarkness.value[$] = l.shadowDarkness, k.shadowBias.value[$] = l.shadowBias, $++);
      b = d.uniformsList;
      k = 0;
      for ($ = b.length; k < $; k++)
        if (f = g.uniforms[b[k][1]])
          if (c = b[k][0], p = c.type, l = c.value, 'i' === p)
            m.uniform1i(f, l);
          else if ('f' === p)
            m.uniform1f(f, l);
          else if ('v2' === p)
            m.uniform2f(f, l.x, l.y);
          else if ('v3' === p)
            m.uniform3f(f, l.x, l.y, l.z);
          else if ('v4' === p)
            m.uniform4f(f, l.x, l.y, l.z, l.w);
          else if ('c' === p)
            m.uniform3f(f, l.r, l.g, l.b);
          else if ('iv1' === p)
            m.uniform1iv(f, l);
          else if ('iv' === p)
            m.uniform3iv(f, l);
          else if ('fv1' === p)
            m.uniform1fv(f, l);
          else if ('fv' === p)
            m.uniform3fv(f, l);
          else if ('v2v' === p) {
            void 0 === c._array && (c._array = new Float32Array(2 * l.length));
            p = 0;
            for (q = l.length; p < q; p++)
              t = 2 * p, c._array[t] = l[p].x, c._array[t + 1] = l[p].y;
            m.uniform2fv(f, c._array);
          } else if ('v3v' === p) {
            void 0 === c._array && (c._array = new Float32Array(3 * l.length));
            p = 0;
            for (q = l.length; p < q; p++)
              t = 3 * p, c._array[t] = l[p].x, c._array[t + 1] = l[p].y, c._array[t + 2] = l[p].z;
            m.uniform3fv(f, c._array);
          } else if ('v4v' === p) {
            void 0 === c._array && (c._array = new Float32Array(4 * l.length));
            p = 0;
            for (q = l.length; p < q; p++)
              t = 4 * p, c._array[t] = l[p].x, c._array[t + 1] = l[p].y, c._array[t + 2] = l[p].z, c._array[t + 3] = l[p].w;
            m.uniform4fv(f, c._array);
          } else if ('m4' === p)
            void 0 === c._array && (c._array = new Float32Array(16)), l.flattenToArray(c._array), m.uniformMatrix4fv(f, !1, c._array);
          else if ('m4v' === p) {
            void 0 === c._array && (c._array = new Float32Array(16 * l.length));
            p = 0;
            for (q = l.length; p < q; p++)
              l[p].flattenToArrayOffset(c._array, 16 * p);
            m.uniformMatrix4fv(f, !1, c._array);
          } else if ('t' === p) {
            if (t = l, l = E(), m.uniform1i(f, l), t)
              if (t.image instanceof Array && 6 === t.image.length) {
                if (c = t, f = l, 6 === c.image.length)
                  if (c.needsUpdate) {
                    c.image.__webglTextureCube || (c.addEventListener('dispose', Cb), c.image.__webglTextureCube = m.createTexture(), N.info.memory.textures++);
                    m.activeTexture(m.TEXTURE0 + f);
                    m.bindTexture(m.TEXTURE_CUBE_MAP, c.image.__webglTextureCube);
                    m.pixelStorei(m.UNPACK_FLIP_Y_WEBGL, c.flipY);
                    f = c instanceof THREE.CompressedTexture;
                    l = [];
                    for (p = 0; 6 > p; p++)
                      N.autoScaleCubemaps && !f ? (q = l, t = p, v = c.image[p], x = db, v.width <= x && v.height <= x || (z = Math.max(v.width, v.height), w = Math.floor(v.width * x / z), x = Math.floor(v.height * x / z), z = document.createElement('canvas'), z.width = w, z.height = x, z.getContext('2d').drawImage(v, 0, 0, v.width, v.height, 0, 0, w, x), v = z), q[t] = v) : l[p] = c.image[p];
                    p = l[0];
                    q = THREE.Math.isPowerOfTwo(p.width) && THREE.Math.isPowerOfTwo(p.height);
                    t = A(c.format);
                    v = A(c.type);
                    y(m.TEXTURE_CUBE_MAP, c, q);
                    for (p = 0; 6 > p; p++)
                      if (f)
                        for (x = l[p].mipmaps, z = 0, B = x.length; z < B; z++)
                          w = x[z], c.format !== THREE.RGBAFormat ? m.compressedTexImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X + p, z, t, w.width, w.height, 0, w.data) : m.texImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X + p, z, t, w.width, w.height, 0, t, v, w.data);
                      else
                        m.texImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X + p, 0, t, t, v, l[p]);
                    c.generateMipmaps && q && m.generateMipmap(m.TEXTURE_CUBE_MAP);
                    c.needsUpdate = !1;
                    if (c.onUpdate)
                      c.onUpdate();
                  } else
                    m.activeTexture(m.TEXTURE0 + f), m.bindTexture(m.TEXTURE_CUBE_MAP, c.image.__webglTextureCube);
              } else
                t instanceof THREE.WebGLRenderTargetCube ? (c = t, m.activeTexture(m.TEXTURE0 + l), m.bindTexture(m.TEXTURE_CUBE_MAP, c.__webglTexture)) : N.setTexture(t, l);
          } else if ('tv' === p) {
            void 0 === c._array && (c._array = []);
            p = 0;
            for (q = c.value.length; p < q; p++)
              c._array[p] = E();
            m.uniform1iv(f, c._array);
            p = 0;
            for (q = c.value.length; p < q; p++)
              t = c.value[p], l = c._array[p], t && N.setTexture(t, l);
          } else
            console.warn('THREE.WebGLRenderer: Unknown uniform type: ' + p);
      (d instanceof THREE.ShaderMaterial || d instanceof THREE.MeshPhongMaterial || d.envMap) && null !== h.cameraPosition && (ya.setFromMatrixPosition(a.matrixWorld), m.uniform3f(h.cameraPosition, ya.x, ya.y, ya.z));
      (d instanceof THREE.MeshPhongMaterial || d instanceof THREE.MeshLambertMaterial || d instanceof THREE.ShaderMaterial || d.skinning) && null !== h.viewMatrix && m.uniformMatrix4fv(h.viewMatrix, !1, a.matrixWorldInverse.elements);
    }
    m.uniformMatrix4fv(h.modelViewMatrix, !1, e._modelViewMatrix.elements);
    h.normalMatrix && m.uniformMatrix3fv(h.normalMatrix, !1, e._normalMatrix.elements);
    null !== h.modelMatrix && m.uniformMatrix4fv(h.modelMatrix, !1, e.matrixWorld.elements);
    return g;
  }
  function E() {
    var a = ta;
    a >= cb && console.warn('WebGLRenderer: trying to use ' + a + ' texture units while this GPU supports only ' + cb);
    ta += 1;
    return a;
  }
  function H(a, b, c, d) {
    a[b] = c.r * c.r * d;
    a[b + 1] = c.g * c.g * d;
    a[b + 2] = c.b * c.b * d;
  }
  function D(a, b, c, d) {
    a[b] = c.r * d;
    a[b + 1] = c.g * d;
    a[b + 2] = c.b * d;
  }
  function G(a) {
    a !== Ca && (m.lineWidth(a), Ca = a);
  }
  function I(a, b, c) {
    Ba !== a && (a ? m.enable(m.POLYGON_OFFSET_FILL) : m.disable(m.POLYGON_OFFSET_FILL), Ba = a);
    !a || Ia === b && ma === c || (m.polygonOffset(b, c), Ia = b, ma = c);
  }
  function O(a) {
    a = a.split('\n');
    for (var b = 0, c = a.length; b < c; b++)
      a[b] = b + 1 + ': ' + a[b];
    return a.join('\n');
  }
  function K(a, b) {
    var c;
    'fragment' === a ? c = m.createShader(m.FRAGMENT_SHADER) : 'vertex' === a && (c = m.createShader(m.VERTEX_SHADER));
    m.shaderSource(c, b);
    m.compileShader(c);
    return m.getShaderParameter(c, m.COMPILE_STATUS) ? c : (console.error(m.getShaderInfoLog(c)), console.error(O(b)), null);
  }
  function y(a, b, c) {
    c ? (m.texParameteri(a, m.TEXTURE_WRAP_S, A(b.wrapS)), m.texParameteri(a, m.TEXTURE_WRAP_T, A(b.wrapT)), m.texParameteri(a, m.TEXTURE_MAG_FILTER, A(b.magFilter)), m.texParameteri(a, m.TEXTURE_MIN_FILTER, A(b.minFilter))) : (m.texParameteri(a, m.TEXTURE_WRAP_S, m.CLAMP_TO_EDGE), m.texParameteri(a, m.TEXTURE_WRAP_T, m.CLAMP_TO_EDGE), m.texParameteri(a, m.TEXTURE_MAG_FILTER, C(b.magFilter)), m.texParameteri(a, m.TEXTURE_MIN_FILTER, C(b.minFilter)));
    Pa && b.type !== THREE.FloatType && (1 < b.anisotropy || b.__oldAnisotropy) && (m.texParameterf(a, Pa.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(b.anisotropy, Bb)), b.__oldAnisotropy = b.anisotropy);
  }
  function F(a, b) {
    m.bindRenderbuffer(m.RENDERBUFFER, a);
    b.depthBuffer && !b.stencilBuffer ? (m.renderbufferStorage(m.RENDERBUFFER, m.DEPTH_COMPONENT16, b.width, b.height), m.framebufferRenderbuffer(m.FRAMEBUFFER, m.DEPTH_ATTACHMENT, m.RENDERBUFFER, a)) : b.depthBuffer && b.stencilBuffer ? (m.renderbufferStorage(m.RENDERBUFFER, m.DEPTH_STENCIL, b.width, b.height), m.framebufferRenderbuffer(m.FRAMEBUFFER, m.DEPTH_STENCIL_ATTACHMENT, m.RENDERBUFFER, a)) : m.renderbufferStorage(m.RENDERBUFFER, m.RGBA4, b.width, b.height);
  }
  function C(a) {
    return a === THREE.NearestFilter || a === THREE.NearestMipMapNearestFilter || a === THREE.NearestMipMapLinearFilter ? m.NEAREST : m.LINEAR;
  }
  function A(a) {
    if (a === THREE.RepeatWrapping)
      return m.REPEAT;
    if (a === THREE.ClampToEdgeWrapping)
      return m.CLAMP_TO_EDGE;
    if (a === THREE.MirroredRepeatWrapping)
      return m.MIRRORED_REPEAT;
    if (a === THREE.NearestFilter)
      return m.NEAREST;
    if (a === THREE.NearestMipMapNearestFilter)
      return m.NEAREST_MIPMAP_NEAREST;
    if (a === THREE.NearestMipMapLinearFilter)
      return m.NEAREST_MIPMAP_LINEAR;
    if (a === THREE.LinearFilter)
      return m.LINEAR;
    if (a === THREE.LinearMipMapNearestFilter)
      return m.LINEAR_MIPMAP_NEAREST;
    if (a === THREE.LinearMipMapLinearFilter)
      return m.LINEAR_MIPMAP_LINEAR;
    if (a === THREE.UnsignedByteType)
      return m.UNSIGNED_BYTE;
    if (a === THREE.UnsignedShort4444Type)
      return m.UNSIGNED_SHORT_4_4_4_4;
    if (a === THREE.UnsignedShort5551Type)
      return m.UNSIGNED_SHORT_5_5_5_1;
    if (a === THREE.UnsignedShort565Type)
      return m.UNSIGNED_SHORT_5_6_5;
    if (a === THREE.ByteType)
      return m.BYTE;
    if (a === THREE.ShortType)
      return m.SHORT;
    if (a === THREE.UnsignedShortType)
      return m.UNSIGNED_SHORT;
    if (a === THREE.IntType)
      return m.INT;
    if (a === THREE.UnsignedIntType)
      return m.UNSIGNED_INT;
    if (a === THREE.FloatType)
      return m.FLOAT;
    if (a === THREE.AlphaFormat)
      return m.ALPHA;
    if (a === THREE.RGBFormat)
      return m.RGB;
    if (a === THREE.RGBAFormat)
      return m.RGBA;
    if (a === THREE.LuminanceFormat)
      return m.LUMINANCE;
    if (a === THREE.LuminanceAlphaFormat)
      return m.LUMINANCE_ALPHA;
    if (a === THREE.AddEquation)
      return m.FUNC_ADD;
    if (a === THREE.SubtractEquation)
      return m.FUNC_SUBTRACT;
    if (a === THREE.ReverseSubtractEquation)
      return m.FUNC_REVERSE_SUBTRACT;
    if (a === THREE.ZeroFactor)
      return m.ZERO;
    if (a === THREE.OneFactor)
      return m.ONE;
    if (a === THREE.SrcColorFactor)
      return m.SRC_COLOR;
    if (a === THREE.OneMinusSrcColorFactor)
      return m.ONE_MINUS_SRC_COLOR;
    if (a === THREE.SrcAlphaFactor)
      return m.SRC_ALPHA;
    if (a === THREE.OneMinusSrcAlphaFactor)
      return m.ONE_MINUS_SRC_ALPHA;
    if (a === THREE.DstAlphaFactor)
      return m.DST_ALPHA;
    if (a === THREE.OneMinusDstAlphaFactor)
      return m.ONE_MINUS_DST_ALPHA;
    if (a === THREE.DstColorFactor)
      return m.DST_COLOR;
    if (a === THREE.OneMinusDstColorFactor)
      return m.ONE_MINUS_DST_COLOR;
    if (a === THREE.SrcAlphaSaturateFactor)
      return m.SRC_ALPHA_SATURATE;
    if (void 0 !== qa) {
      if (a === THREE.RGB_S3TC_DXT1_Format)
        return qa.COMPRESSED_RGB_S3TC_DXT1_EXT;
      if (a === THREE.RGBA_S3TC_DXT1_Format)
        return qa.COMPRESSED_RGBA_S3TC_DXT1_EXT;
      if (a === THREE.RGBA_S3TC_DXT3_Format)
        return qa.COMPRESSED_RGBA_S3TC_DXT3_EXT;
      if (a === THREE.RGBA_S3TC_DXT5_Format)
        return qa.COMPRESSED_RGBA_S3TC_DXT5_EXT;
    }
    return 0;
  }
  console.log('THREE.WebGLRenderer', THREE.REVISION);
  a = a || {};
  var L = void 0 !== a.canvas ? a.canvas : document.createElement('canvas'), Q = void 0 !== a.context ? a.context : null, Y = void 0 !== a.precision ? a.precision : 'highp', R = void 0 !== a.alpha ? a.alpha : !1, fa = void 0 !== a.premultipliedAlpha ? a.premultipliedAlpha : !0, V = void 0 !== a.antialias ? a.antialias : !1, ga = void 0 !== a.stencil ? a.stencil : !0, J = void 0 !== a.preserveDrawingBuffer ? a.preserveDrawingBuffer : !1, da = new THREE.Color(0), W = 0;
  this.domElement = L;
  this.context = null;
  this.devicePixelRatio = void 0 !== a.devicePixelRatio ? a.devicePixelRatio : void 0 !== self.devicePixelRatio ? self.devicePixelRatio : 1;
  this.autoUpdateObjects = this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0;
  this.shadowMapEnabled = this.gammaOutput = this.gammaInput = !1;
  this.shadowMapAutoUpdate = !0;
  this.shadowMapType = THREE.PCFShadowMap;
  this.shadowMapCullFace = THREE.CullFaceFront;
  this.shadowMapCascade = this.shadowMapDebug = !1;
  this.maxMorphTargets = 8;
  this.maxMorphNormals = 4;
  this.autoScaleCubemaps = !0;
  this.renderPluginsPre = [];
  this.renderPluginsPost = [];
  this.info = {
    memory: {
      programs: 0,
      geometries: 0,
      textures: 0
    },
    render: {
      calls: 0,
      vertices: 0,
      faces: 0,
      points: 0
    }
  };
  var N = this, ca = [], sa = 0, T = null, Ja = null, S = -1, $ = null, Fa = null, ta = 0, oa = -1, za = -1, Aa = -1, Ua = -1, Va = -1, ka = -1, Ka = -1, la = -1, Ba = null, Ia = null, ma = null, Ca = null, ba = 0, wa = 0, xa = L.width, Da = L.height, Wa = 0, La = 0, Ea = new Uint8Array(16), na = new THREE.Frustum(), Oa = new THREE.Matrix4(), hb = new THREE.Matrix4(), ya = new THREE.Vector3(), ia = new THREE.Vector3(), Na = !0, ha = {
      ambient: [
        0,
        0,
        0
      ],
      directional: {
        length: 0,
        colors: [],
        positions: []
      },
      point: {
        length: 0,
        colors: [],
        positions: [],
        distances: []
      },
      spot: {
        length: 0,
        colors: [],
        positions: [],
        distances: [],
        directions: [],
        anglesCos: [],
        exponents: []
      },
      hemi: {
        length: 0,
        skyColors: [],
        groundColors: [],
        positions: []
      }
    }, m, Qa, Ma, Pa, qa;
  (function () {
    try {
      var a = {
          alpha: R,
          premultipliedAlpha: fa,
          antialias: V,
          stencil: ga,
          preserveDrawingBuffer: J
        };
      m = Q || L.getContext('webgl', a) || L.getContext('experimental-webgl', a);
      if (null === m)
        throw 'Error creating WebGL context.';
    } catch (b) {
      console.error(b);
    }
    Qa = m.getExtension('OES_texture_float');
    m.getExtension('OES_texture_float_linear');
    Ma = m.getExtension('OES_standard_derivatives');
    Pa = m.getExtension('EXT_texture_filter_anisotropic') || m.getExtension('MOZ_EXT_texture_filter_anisotropic') || m.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
    qa = m.getExtension('WEBGL_compressed_texture_s3tc') || m.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || m.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
    Qa || console.log('THREE.WebGLRenderer: Float textures not supported.');
    Ma || console.log('THREE.WebGLRenderer: Standard derivatives not supported.');
    Pa || console.log('THREE.WebGLRenderer: Anisotropic texture filtering not supported.');
    qa || console.log('THREE.WebGLRenderer: S3TC compressed textures not supported.');
    void 0 === m.getShaderPrecisionFormat && (m.getShaderPrecisionFormat = function () {
      return {
        rangeMin: 1,
        rangeMax: 1,
        precision: 1
      };
    });
  }());
  m.clearColor(0, 0, 0, 1);
  m.clearDepth(1);
  m.clearStencil(0);
  m.enable(m.DEPTH_TEST);
  m.depthFunc(m.LEQUAL);
  m.frontFace(m.CCW);
  m.cullFace(m.BACK);
  m.enable(m.CULL_FACE);
  m.enable(m.BLEND);
  m.blendEquation(m.FUNC_ADD);
  m.blendFunc(m.SRC_ALPHA, m.ONE_MINUS_SRC_ALPHA);
  m.viewport(ba, wa, xa, Da);
  m.clearColor(da.r, da.g, da.b, W);
  this.context = m;
  var cb = m.getParameter(m.MAX_TEXTURE_IMAGE_UNITS), qb = m.getParameter(m.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
  m.getParameter(m.MAX_TEXTURE_SIZE);
  var db = m.getParameter(m.MAX_CUBE_MAP_TEXTURE_SIZE), Bb = Pa ? m.getParameter(Pa.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0, yb = 0 < qb, ub = yb && Qa;
  qa && m.getParameter(m.COMPRESSED_TEXTURE_FORMATS);
  var Yb = m.getShaderPrecisionFormat(m.VERTEX_SHADER, m.HIGH_FLOAT), Zb = m.getShaderPrecisionFormat(m.VERTEX_SHADER, m.MEDIUM_FLOAT);
  m.getShaderPrecisionFormat(m.VERTEX_SHADER, m.LOW_FLOAT);
  var $b = m.getShaderPrecisionFormat(m.FRAGMENT_SHADER, m.HIGH_FLOAT), ac = m.getShaderPrecisionFormat(m.FRAGMENT_SHADER, m.MEDIUM_FLOAT);
  m.getShaderPrecisionFormat(m.FRAGMENT_SHADER, m.LOW_FLOAT);
  m.getShaderPrecisionFormat(m.VERTEX_SHADER, m.HIGH_INT);
  m.getShaderPrecisionFormat(m.VERTEX_SHADER, m.MEDIUM_INT);
  m.getShaderPrecisionFormat(m.VERTEX_SHADER, m.LOW_INT);
  m.getShaderPrecisionFormat(m.FRAGMENT_SHADER, m.HIGH_INT);
  m.getShaderPrecisionFormat(m.FRAGMENT_SHADER, m.MEDIUM_INT);
  m.getShaderPrecisionFormat(m.FRAGMENT_SHADER, m.LOW_INT);
  var bc = 0 < Yb.precision && 0 < $b.precision, Jb = 0 < Zb.precision && 0 < ac.precision;
  'highp' !== Y || bc || (Jb ? (Y = 'mediump', console.warn('WebGLRenderer: highp not supported, using mediump')) : (Y = 'lowp', console.warn('WebGLRenderer: highp and mediump not supported, using lowp')));
  'mediump' !== Y || Jb || (Y = 'lowp', console.warn('WebGLRenderer: mediump not supported, using lowp'));
  this.getContext = function () {
    return m;
  };
  this.supportsVertexTextures = function () {
    return yb;
  };
  this.supportsFloatTextures = function () {
    return Qa;
  };
  this.supportsStandardDerivatives = function () {
    return Ma;
  };
  this.supportsCompressedTextureS3TC = function () {
    return qa;
  };
  this.getMaxAnisotropy = function () {
    return Bb;
  };
  this.getPrecision = function () {
    return Y;
  };
  this.setSize = function (a, b, c) {
    L.width = a * this.devicePixelRatio;
    L.height = b * this.devicePixelRatio;
    1 !== this.devicePixelRatio && !1 !== c && (L.style.width = a + 'px', L.style.height = b + 'px');
    this.setViewport(0, 0, a, b);
  };
  this.setViewport = function (a, b, c, d) {
    ba = a * this.devicePixelRatio;
    wa = b * this.devicePixelRatio;
    xa = c * this.devicePixelRatio;
    Da = d * this.devicePixelRatio;
    m.viewport(ba, wa, xa, Da);
  };
  this.setScissor = function (a, b, c, d) {
    m.scissor(a * this.devicePixelRatio, b * this.devicePixelRatio, c * this.devicePixelRatio, d * this.devicePixelRatio);
  };
  this.enableScissorTest = function (a) {
    a ? m.enable(m.SCISSOR_TEST) : m.disable(m.SCISSOR_TEST);
  };
  this.setClearColor = function (a, b) {
    da.set(a);
    W = void 0 !== b ? b : 1;
    m.clearColor(da.r, da.g, da.b, W);
  };
  this.setClearColorHex = function (a, b) {
    console.warn('DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.');
    this.setClearColor(a, b);
  };
  this.getClearColor = function () {
    return da;
  };
  this.getClearAlpha = function () {
    return W;
  };
  this.clear = function (a, b, c) {
    var d = 0;
    if (void 0 === a || a)
      d |= m.COLOR_BUFFER_BIT;
    if (void 0 === b || b)
      d |= m.DEPTH_BUFFER_BIT;
    if (void 0 === c || c)
      d |= m.STENCIL_BUFFER_BIT;
    m.clear(d);
  };
  this.clearColor = function () {
    m.clear(m.COLOR_BUFFER_BIT);
  };
  this.clearDepth = function () {
    m.clear(m.DEPTH_BUFFER_BIT);
  };
  this.clearStencil = function () {
    m.clear(m.STENCIL_BUFFER_BIT);
  };
  this.clearTarget = function (a, b, c, d) {
    this.setRenderTarget(a);
    this.clear(b, c, d);
  };
  this.addPostPlugin = function (a) {
    a.init(this);
    this.renderPluginsPost.push(a);
  };
  this.addPrePlugin = function (a) {
    a.init(this);
    this.renderPluginsPre.push(a);
  };
  this.updateShadowMap = function (a, b) {
    T = null;
    S = $ = la = Ka = Aa = -1;
    Na = !0;
    za = oa = -1;
    this.shadowMapPlugin.update(a, b);
  };
  var Kb = function (a) {
      a = a.target;
      a.removeEventListener('dispose', Kb);
      a.__webglInit = void 0;
      if (a instanceof THREE.BufferGeometry) {
        var b = a.attributes, c;
        for (c in b)
          void 0 !== b[c].buffer && m.deleteBuffer(b[c].buffer);
        N.info.memory.geometries--;
      } else if (void 0 !== a.geometryGroups)
        for (b in a.geometryGroups) {
          c = a.geometryGroups[b];
          if (void 0 !== c.numMorphTargets)
            for (var d = 0, e = c.numMorphTargets; d < e; d++)
              m.deleteBuffer(c.__webglMorphTargetsBuffers[d]);
          if (void 0 !== c.numMorphNormals)
            for (d = 0, e = c.numMorphNormals; d < e; d++)
              m.deleteBuffer(c.__webglMorphNormalsBuffers[d]);
          Db(c);
        }
      else
        Db(a);
    }, Cb = function (a) {
      a = a.target;
      a.removeEventListener('dispose', Cb);
      a.image && a.image.__webglTextureCube ? m.deleteTexture(a.image.__webglTextureCube) : a.__webglInit && (a.__webglInit = !1, m.deleteTexture(a.__webglTexture));
      N.info.memory.textures--;
    }, Lb = function (a) {
      a = a.target;
      a.removeEventListener('dispose', Lb);
      if (a && a.__webglTexture)
        if (m.deleteTexture(a.__webglTexture), a instanceof THREE.WebGLRenderTargetCube)
          for (var b = 0; 6 > b; b++)
            m.deleteFramebuffer(a.__webglFramebuffer[b]), m.deleteRenderbuffer(a.__webglRenderbuffer[b]);
        else
          m.deleteFramebuffer(a.__webglFramebuffer), m.deleteRenderbuffer(a.__webglRenderbuffer);
      N.info.memory.textures--;
    }, Mb = function (a) {
      a = a.target;
      a.removeEventListener('dispose', Mb);
      Eb(a);
    }, Db = function (a) {
      void 0 !== a.__webglVertexBuffer && m.deleteBuffer(a.__webglVertexBuffer);
      void 0 !== a.__webglNormalBuffer && m.deleteBuffer(a.__webglNormalBuffer);
      void 0 !== a.__webglTangentBuffer && m.deleteBuffer(a.__webglTangentBuffer);
      void 0 !== a.__webglColorBuffer && m.deleteBuffer(a.__webglColorBuffer);
      void 0 !== a.__webglUVBuffer && m.deleteBuffer(a.__webglUVBuffer);
      void 0 !== a.__webglUV2Buffer && m.deleteBuffer(a.__webglUV2Buffer);
      void 0 !== a.__webglSkinIndicesBuffer && m.deleteBuffer(a.__webglSkinIndicesBuffer);
      void 0 !== a.__webglSkinWeightsBuffer && m.deleteBuffer(a.__webglSkinWeightsBuffer);
      void 0 !== a.__webglFaceBuffer && m.deleteBuffer(a.__webglFaceBuffer);
      void 0 !== a.__webglLineBuffer && m.deleteBuffer(a.__webglLineBuffer);
      void 0 !== a.__webglLineDistanceBuffer && m.deleteBuffer(a.__webglLineDistanceBuffer);
      if (void 0 !== a.__webglCustomAttributesList)
        for (var b in a.__webglCustomAttributesList)
          m.deleteBuffer(a.__webglCustomAttributesList[b].buffer);
      N.info.memory.geometries--;
    }, Eb = function (a) {
      var b = a.program;
      if (void 0 !== b) {
        a.program = void 0;
        var c, d, e = !1;
        a = 0;
        for (c = ca.length; a < c; a++)
          if (d = ca[a], d.program === b) {
            d.usedTimes--;
            0 === d.usedTimes && (e = !0);
            break;
          }
        if (!0 === e) {
          e = [];
          a = 0;
          for (c = ca.length; a < c; a++)
            d = ca[a], d.program !== b && e.push(d);
          ca = e;
          m.deleteProgram(b);
          N.info.memory.programs--;
        }
      }
    };
  this.renderBufferImmediate = function (a, b, c) {
    a.hasPositions && !a.__webglVertexBuffer && (a.__webglVertexBuffer = m.createBuffer());
    a.hasNormals && !a.__webglNormalBuffer && (a.__webglNormalBuffer = m.createBuffer());
    a.hasUvs && !a.__webglUvBuffer && (a.__webglUvBuffer = m.createBuffer());
    a.hasColors && !a.__webglColorBuffer && (a.__webglColorBuffer = m.createBuffer());
    a.hasPositions && (m.bindBuffer(m.ARRAY_BUFFER, a.__webglVertexBuffer), m.bufferData(m.ARRAY_BUFFER, a.positionArray, m.DYNAMIC_DRAW), m.enableVertexAttribArray(b.attributes.position), m.vertexAttribPointer(b.attributes.position, 3, m.FLOAT, !1, 0, 0));
    if (a.hasNormals) {
      m.bindBuffer(m.ARRAY_BUFFER, a.__webglNormalBuffer);
      if (c.shading === THREE.FlatShading) {
        var d, e, f, g, h, k, l, n, p, q, r, s = 3 * a.count;
        for (r = 0; r < s; r += 9)
          q = a.normalArray, d = q[r], e = q[r + 1], f = q[r + 2], g = q[r + 3], k = q[r + 4], n = q[r + 5], h = q[r + 6], l = q[r + 7], p = q[r + 8], d = (d + g + h) / 3, e = (e + k + l) / 3, f = (f + n + p) / 3, q[r] = d, q[r + 1] = e, q[r + 2] = f, q[r + 3] = d, q[r + 4] = e, q[r + 5] = f, q[r + 6] = d, q[r + 7] = e, q[r + 8] = f;
      }
      m.bufferData(m.ARRAY_BUFFER, a.normalArray, m.DYNAMIC_DRAW);
      m.enableVertexAttribArray(b.attributes.normal);
      m.vertexAttribPointer(b.attributes.normal, 3, m.FLOAT, !1, 0, 0);
    }
    a.hasUvs && c.map && (m.bindBuffer(m.ARRAY_BUFFER, a.__webglUvBuffer), m.bufferData(m.ARRAY_BUFFER, a.uvArray, m.DYNAMIC_DRAW), m.enableVertexAttribArray(b.attributes.uv), m.vertexAttribPointer(b.attributes.uv, 2, m.FLOAT, !1, 0, 0));
    a.hasColors && c.vertexColors !== THREE.NoColors && (m.bindBuffer(m.ARRAY_BUFFER, a.__webglColorBuffer), m.bufferData(m.ARRAY_BUFFER, a.colorArray, m.DYNAMIC_DRAW), m.enableVertexAttribArray(b.attributes.color), m.vertexAttribPointer(b.attributes.color, 3, m.FLOAT, !1, 0, 0));
    m.drawArrays(m.TRIANGLES, 0, a.count);
    a.count = 0;
  };
  this.renderBufferDirect = function (a, b, c, d, e, f) {
    if (!1 !== d.visible) {
      var l, n, p, q;
      l = B(a, b, c, d, f);
      a = l.attributes;
      b = e.attributes;
      c = !1;
      l = 16777215 * e.id + 2 * l.id + (d.wireframe ? 1 : 0);
      l !== $ && ($ = l, c = !0);
      c && k();
      if (f instanceof THREE.Mesh)
        if (f = b.index) {
          e = e.offsets;
          1 < e.length && (c = !0);
          for (var r = 0, s = e.length; r < s; r++) {
            var t = e[r].index;
            if (c) {
              for (n in a)
                p = a[n], l = b[n], 0 <= p && (l ? (q = l.itemSize, m.bindBuffer(m.ARRAY_BUFFER, l.buffer), h(p), m.vertexAttribPointer(p, q, m.FLOAT, !1, 0, t * q * 4)) : d.defaultAttributeValues && (2 === d.defaultAttributeValues[n].length ? m.vertexAttrib2fv(p, d.defaultAttributeValues[n]) : 3 === d.defaultAttributeValues[n].length && m.vertexAttrib3fv(p, d.defaultAttributeValues[n])));
              m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, f.buffer);
            }
            m.drawElements(m.TRIANGLES, e[r].count, m.UNSIGNED_SHORT, 2 * e[r].start);
            N.info.render.calls++;
            N.info.render.vertices += e[r].count;
            N.info.render.faces += e[r].count / 3;
          }
        } else {
          if (c)
            for (n in a)
              'index' !== n && (p = a[n], l = b[n], 0 <= p && (l ? (q = l.itemSize, m.bindBuffer(m.ARRAY_BUFFER, l.buffer), h(p), m.vertexAttribPointer(p, q, m.FLOAT, !1, 0, 0)) : d.defaultAttributeValues && d.defaultAttributeValues[n] && (2 === d.defaultAttributeValues[n].length ? m.vertexAttrib2fv(p, d.defaultAttributeValues[n]) : 3 === d.defaultAttributeValues[n].length && m.vertexAttrib3fv(p, d.defaultAttributeValues[n]))));
          d = e.attributes.position;
          m.drawArrays(m.TRIANGLES, 0, d.array.length / 3);
          N.info.render.calls++;
          N.info.render.vertices += d.array.length / 3;
          N.info.render.faces += d.array.length / 3 / 3;
        }
      else if (f instanceof THREE.ParticleSystem) {
        if (c)
          for (n in a)
            p = a[n], l = b[n], 0 <= p && (l ? (q = l.itemSize, m.bindBuffer(m.ARRAY_BUFFER, l.buffer), h(p), m.vertexAttribPointer(p, q, m.FLOAT, !1, 0, 0)) : d.defaultAttributeValues && d.defaultAttributeValues[n] && (2 === d.defaultAttributeValues[n].length ? m.vertexAttrib2fv(p, d.defaultAttributeValues[n]) : 3 === d.defaultAttributeValues[n].length && m.vertexAttrib3fv(p, d.defaultAttributeValues[n])));
        d = b.position;
        m.drawArrays(m.POINTS, 0, d.array.length / 3);
        N.info.render.calls++;
        N.info.render.points += d.array.length / 3;
      } else if (f instanceof THREE.Line)
        if (n = f.type === THREE.LineStrip ? m.LINE_STRIP : m.LINES, G(d.linewidth), f = b.index)
          for (e = e.offsets, 1 < e.length && (c = !0), r = 0, s = e.length; r < s; r++)
            t = e[r].index, c && (g(d, a, b, t), m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, f.buffer)), m.drawElements(m.LINES, e[r].count, m.UNSIGNED_SHORT, 2 * e[r].start), N.info.render.calls++, N.info.render.vertices += e[r].count;
        else
          c && g(d, a, b, 0), d = b.position, m.drawArrays(n, 0, d.array.length / 3), N.info.render.calls++, N.info.render.points += d.array.length;
    }
  };
  this.renderBuffer = function (a, b, c, d, e, f) {
    if (!1 !== d.visible) {
      var g, l;
      c = B(a, b, c, d, f);
      a = c.attributes;
      b = !1;
      c = 16777215 * e.id + 2 * c.id + (d.wireframe ? 1 : 0);
      c !== $ && ($ = c, b = !0);
      b && k();
      if (!d.morphTargets && 0 <= a.position)
        b && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglVertexBuffer), h(a.position), m.vertexAttribPointer(a.position, 3, m.FLOAT, !1, 0, 0));
      else if (f.morphTargetBase) {
        c = d.program.attributes;
        -1 !== f.morphTargetBase && 0 <= c.position ? (m.bindBuffer(m.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[f.morphTargetBase]), h(c.position), m.vertexAttribPointer(c.position, 3, m.FLOAT, !1, 0, 0)) : 0 <= c.position && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglVertexBuffer), h(c.position), m.vertexAttribPointer(c.position, 3, m.FLOAT, !1, 0, 0));
        if (f.morphTargetForcedOrder.length) {
          var p = 0;
          l = f.morphTargetForcedOrder;
          for (g = f.morphTargetInfluences; p < d.numSupportedMorphTargets && p < l.length;)
            0 <= c['morphTarget' + p] && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[l[p]]), h(c['morphTarget' + p]), m.vertexAttribPointer(c['morphTarget' + p], 3, m.FLOAT, !1, 0, 0)), 0 <= c['morphNormal' + p] && d.morphNormals && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglMorphNormalsBuffers[l[p]]), h(c['morphNormal' + p]), m.vertexAttribPointer(c['morphNormal' + p], 3, m.FLOAT, !1, 0, 0)), f.__webglMorphTargetInfluences[p] = g[l[p]], p++;
        } else {
          l = [];
          g = f.morphTargetInfluences;
          var q, r = g.length;
          for (q = 0; q < r; q++)
            p = g[q], 0 < p && l.push([
              p,
              q
            ]);
          l.length > d.numSupportedMorphTargets ? (l.sort(n), l.length = d.numSupportedMorphTargets) : l.length > d.numSupportedMorphNormals ? l.sort(n) : 0 === l.length && l.push([
            0,
            0
          ]);
          for (p = 0; p < d.numSupportedMorphTargets;)
            l[p] ? (q = l[p][1], 0 <= c['morphTarget' + p] && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[q]), h(c['morphTarget' + p]), m.vertexAttribPointer(c['morphTarget' + p], 3, m.FLOAT, !1, 0, 0)), 0 <= c['morphNormal' + p] && d.morphNormals && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglMorphNormalsBuffers[q]), h(c['morphNormal' + p]), m.vertexAttribPointer(c['morphNormal' + p], 3, m.FLOAT, !1, 0, 0)), f.__webglMorphTargetInfluences[p] = g[q]) : f.__webglMorphTargetInfluences[p] = 0, p++;
        }
        null !== d.program.uniforms.morphTargetInfluences && m.uniform1fv(d.program.uniforms.morphTargetInfluences, f.__webglMorphTargetInfluences);
      }
      if (b) {
        if (e.__webglCustomAttributesList)
          for (g = 0, l = e.__webglCustomAttributesList.length; g < l; g++)
            c = e.__webglCustomAttributesList[g], 0 <= a[c.buffer.belongsToAttribute] && (m.bindBuffer(m.ARRAY_BUFFER, c.buffer), h(a[c.buffer.belongsToAttribute]), m.vertexAttribPointer(a[c.buffer.belongsToAttribute], c.size, m.FLOAT, !1, 0, 0));
        0 <= a.color && (0 < f.geometry.colors.length || 0 < f.geometry.faces.length ? (m.bindBuffer(m.ARRAY_BUFFER, e.__webglColorBuffer), h(a.color), m.vertexAttribPointer(a.color, 3, m.FLOAT, !1, 0, 0)) : d.defaultAttributeValues && m.vertexAttrib3fv(a.color, d.defaultAttributeValues.color));
        0 <= a.normal && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglNormalBuffer), h(a.normal), m.vertexAttribPointer(a.normal, 3, m.FLOAT, !1, 0, 0));
        0 <= a.tangent && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglTangentBuffer), h(a.tangent), m.vertexAttribPointer(a.tangent, 4, m.FLOAT, !1, 0, 0));
        0 <= a.uv && (f.geometry.faceVertexUvs[0] ? (m.bindBuffer(m.ARRAY_BUFFER, e.__webglUVBuffer), h(a.uv), m.vertexAttribPointer(a.uv, 2, m.FLOAT, !1, 0, 0)) : d.defaultAttributeValues && m.vertexAttrib2fv(a.uv, d.defaultAttributeValues.uv));
        0 <= a.uv2 && (f.geometry.faceVertexUvs[1] ? (m.bindBuffer(m.ARRAY_BUFFER, e.__webglUV2Buffer), h(a.uv2), m.vertexAttribPointer(a.uv2, 2, m.FLOAT, !1, 0, 0)) : d.defaultAttributeValues && m.vertexAttrib2fv(a.uv2, d.defaultAttributeValues.uv2));
        d.skinning && 0 <= a.skinIndex && 0 <= a.skinWeight && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglSkinIndicesBuffer), h(a.skinIndex), m.vertexAttribPointer(a.skinIndex, 4, m.FLOAT, !1, 0, 0), m.bindBuffer(m.ARRAY_BUFFER, e.__webglSkinWeightsBuffer), h(a.skinWeight), m.vertexAttribPointer(a.skinWeight, 4, m.FLOAT, !1, 0, 0));
        0 <= a.lineDistance && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglLineDistanceBuffer), h(a.lineDistance), m.vertexAttribPointer(a.lineDistance, 1, m.FLOAT, !1, 0, 0));
      }
      f instanceof THREE.Mesh ? (d.wireframe ? (G(d.wireframeLinewidth), b && m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, e.__webglLineBuffer), m.drawElements(m.LINES, e.__webglLineCount, m.UNSIGNED_SHORT, 0)) : (b && m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, e.__webglFaceBuffer), m.drawElements(m.TRIANGLES, e.__webglFaceCount, m.UNSIGNED_SHORT, 0)), N.info.render.calls++, N.info.render.vertices += e.__webglFaceCount, N.info.render.faces += e.__webglFaceCount / 3) : f instanceof THREE.Line ? (f = f.type === THREE.LineStrip ? m.LINE_STRIP : m.LINES, G(d.linewidth), m.drawArrays(f, 0, e.__webglLineCount), N.info.render.calls++) : f instanceof THREE.ParticleSystem && (m.drawArrays(m.POINTS, 0, e.__webglParticleCount), N.info.render.calls++, N.info.render.points += e.__webglParticleCount);
    }
  };
  this.render = function (a, b, c, d) {
    if (!1 === b instanceof THREE.Camera)
      console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
    else {
      var e, f, g, h, k = a.__lights, p = a.fog;
      S = -1;
      Na = !0;
      !0 === a.autoUpdate && a.updateMatrixWorld();
      void 0 === b.parent && b.updateMatrixWorld();
      b.matrixWorldInverse.getInverse(b.matrixWorld);
      Oa.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse);
      na.setFromMatrix(Oa);
      this.autoUpdateObjects && this.initWebGLObjects(a);
      s(this.renderPluginsPre, a, b);
      N.info.render.calls = 0;
      N.info.render.vertices = 0;
      N.info.render.faces = 0;
      N.info.render.points = 0;
      this.setRenderTarget(c);
      (this.autoClear || d) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
      h = a.__webglObjects;
      d = 0;
      for (e = h.length; d < e; d++)
        if (f = h[d], g = f.object, f.id = d, f.render = !1, g.visible && (!(g instanceof THREE.Mesh || g instanceof THREE.ParticleSystem) || !g.frustumCulled || na.intersectsObject(g))) {
          var n = g;
          n._modelViewMatrix.multiplyMatrices(b.matrixWorldInverse, n.matrixWorld);
          n._normalMatrix.getNormalMatrix(n._modelViewMatrix);
          var n = f, t = n.object, u = n.buffer, v = t.geometry, t = t.material;
          t instanceof THREE.MeshFaceMaterial ? (t = t.materials[v instanceof THREE.BufferGeometry ? 0 : u.materialIndex], t.transparent ? (n.transparent = t, n.opaque = null) : (n.opaque = t, n.transparent = null)) : t && (t.transparent ? (n.transparent = t, n.opaque = null) : (n.opaque = t, n.transparent = null));
          f.render = !0;
          !0 === this.sortObjects && (null !== g.renderDepth ? f.z = g.renderDepth : (ya.setFromMatrixPosition(g.matrixWorld), ya.applyProjection(Oa), f.z = ya.z));
        }
      this.sortObjects && h.sort(l);
      h = a.__webglObjectsImmediate;
      d = 0;
      for (e = h.length; d < e; d++)
        f = h[d], g = f.object, g.visible && (g._modelViewMatrix.multiplyMatrices(b.matrixWorldInverse, g.matrixWorld), g._normalMatrix.getNormalMatrix(g._modelViewMatrix), g = f.object.material, g.transparent ? (f.transparent = g, f.opaque = null) : (f.opaque = g, f.transparent = null));
      a.overrideMaterial ? (d = a.overrideMaterial, this.setBlending(d.blending, d.blendEquation, d.blendSrc, d.blendDst), this.setDepthTest(d.depthTest), this.setDepthWrite(d.depthWrite), I(d.polygonOffset, d.polygonOffsetFactor, d.polygonOffsetUnits), r(a.__webglObjects, !1, '', b, k, p, !0, d), q(a.__webglObjectsImmediate, '', b, k, p, !1, d)) : (d = null, this.setBlending(THREE.NoBlending), r(a.__webglObjects, !0, 'opaque', b, k, p, !1, d), q(a.__webglObjectsImmediate, 'opaque', b, k, p, !1, d), r(a.__webglObjects, !1, 'transparent', b, k, p, !0, d), q(a.__webglObjectsImmediate, 'transparent', b, k, p, !0, d));
      s(this.renderPluginsPost, a, b);
      c && c.generateMipmaps && c.minFilter !== THREE.NearestFilter && c.minFilter !== THREE.LinearFilter && (c instanceof THREE.WebGLRenderTargetCube ? (m.bindTexture(m.TEXTURE_CUBE_MAP, c.__webglTexture), m.generateMipmap(m.TEXTURE_CUBE_MAP), m.bindTexture(m.TEXTURE_CUBE_MAP, null)) : (m.bindTexture(m.TEXTURE_2D, c.__webglTexture), m.generateMipmap(m.TEXTURE_2D), m.bindTexture(m.TEXTURE_2D, null)));
      this.setDepthTest(!0);
      this.setDepthWrite(!0);
    }
  };
  this.renderImmediateObject = function (a, b, c, d, e) {
    var f = B(a, b, c, d, e);
    $ = -1;
    N.setMaterialFaces(d);
    e.immediateRenderCallback ? e.immediateRenderCallback(f, m, na) : e.render(function (a) {
      N.renderBufferImmediate(a, f, d);
    });
  };
  this.initWebGLObjects = function (a) {
    a.__webglObjects || (a.__webglObjects = [], a.__webglObjectsImmediate = [], a.__webglSprites = [], a.__webglFlares = []);
    for (; a.__objectsAdded.length;)
      u(a.__objectsAdded[0], a), a.__objectsAdded.splice(0, 1);
    for (; a.__objectsRemoved.length;)
      t(a.__objectsRemoved[0], a), a.__objectsRemoved.splice(0, 1);
    for (var b = 0, g = a.__webglObjects.length; b < g; b++) {
      var h = a.__webglObjects[b].object;
      void 0 === h.__webglInit && (void 0 !== h.__webglActive && t(h, a), u(h, a));
      var k = h, l = k.geometry, p = void 0, q = void 0, r = void 0;
      if (l instanceof THREE.BufferGeometry) {
        var s = m.DYNAMIC_DRAW, x = l.attributes, z = void 0, y = void 0;
        for (z in x)
          y = x[z], y.needsUpdate && ('index' === z ? (m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, y.buffer), m.bufferData(m.ELEMENT_ARRAY_BUFFER, y.array, s)) : (m.bindBuffer(m.ARRAY_BUFFER, y.buffer), m.bufferData(m.ARRAY_BUFFER, y.array, s)), y.needsUpdate = !1);
      } else if (k instanceof THREE.Mesh) {
        for (var B = 0, I = l.geometryGroupsList.length; B < I; B++)
          if (p = l.geometryGroupsList[B], r = d(k, p), l.buffersNeedUpdate && c(p, k), q = r.attributes && v(r), l.verticesNeedUpdate || l.morphTargetsNeedUpdate || l.elementsNeedUpdate || l.uvsNeedUpdate || l.normalsNeedUpdate || l.colorsNeedUpdate || l.tangentsNeedUpdate || q) {
            var A = p, D = k, C = m.DYNAMIC_DRAW, F = !l.dynamic, G = r;
            if (A.__inittedArrays) {
              var H = e(G), O = G.vertexColors ? G.vertexColors : !1, L = f(G), N = H === THREE.SmoothShading, E = void 0, J = void 0, Q = void 0, K = void 0, ca = void 0, R = void 0, Y = void 0, W = void 0, V = void 0, $ = void 0, sa = void 0, S = void 0, T = void 0, Z = void 0, oa = void 0, ta = void 0, Fa = void 0, da = void 0, Ja = void 0, fa = void 0, ga = void 0, ha = void 0, za = void 0, ka = void 0, ia = void 0, la = void 0, na = void 0, qa = void 0, Aa = void 0, ba = void 0, Ea = void 0, Ca = void 0, Ka = void 0, Ia = void 0, ma = void 0, La = void 0, wa = void 0, xa = void 0, Ua = void 0, Va = void 0, Ba = 0, Da = 0, Na = 0, Pa = 0, Qa = 0, ib = 0, Ya = 0, Ma = 0, eb = 0, va = 0, Ga = 0, P = 0, Xa = void 0, jb = A.__vertexArray, cb = A.__uvArray, db = A.__uv2Array, Wa = A.__normalArray, Za = A.__tangentArray, kb = A.__colorArray, $a = A.__skinIndexArray, ab = A.__skinWeightArray, qb = A.__morphTargetsArrays, yb = A.__morphNormalsArrays, ub = A.__webglCustomAttributesList, M = void 0, Ob = A.__faceArray, vb = A.__lineArray, Ra = D.geometry, Cb = Ra.elementsNeedUpdate, Bb = Ra.uvsNeedUpdate, Jb = Ra.normalsNeedUpdate, Kb = Ra.tangentsNeedUpdate, Lb = Ra.colorsNeedUpdate, Mb = Ra.morphTargetsNeedUpdate, ec = Ra.vertices, ea = A.faces3, lb = Ra.faces, Db = Ra.faceVertexUvs[0], Eb = Ra.faceVertexUvs[1], fc = Ra.skinIndices, Pb = Ra.skinWeights, Qb = Ra.morphTargets, kc = Ra.morphNormals;
              if (Ra.verticesNeedUpdate) {
                E = 0;
                for (J = ea.length; E < J; E++)
                  K = lb[ea[E]], S = ec[K.a], T = ec[K.b], Z = ec[K.c], jb[Da] = S.x, jb[Da + 1] = S.y, jb[Da + 2] = S.z, jb[Da + 3] = T.x, jb[Da + 4] = T.y, jb[Da + 5] = T.z, jb[Da + 6] = Z.x, jb[Da + 7] = Z.y, jb[Da + 8] = Z.z, Da += 9;
                m.bindBuffer(m.ARRAY_BUFFER, A.__webglVertexBuffer);
                m.bufferData(m.ARRAY_BUFFER, jb, C);
              }
              if (Mb)
                for (ma = 0, La = Qb.length; ma < La; ma++) {
                  E = Ga = 0;
                  for (J = ea.length; E < J; E++)
                    Ua = ea[E], K = lb[Ua], S = Qb[ma].vertices[K.a], T = Qb[ma].vertices[K.b], Z = Qb[ma].vertices[K.c], wa = qb[ma], wa[Ga] = S.x, wa[Ga + 1] = S.y, wa[Ga + 2] = S.z, wa[Ga + 3] = T.x, wa[Ga + 4] = T.y, wa[Ga + 5] = T.z, wa[Ga + 6] = Z.x, wa[Ga + 7] = Z.y, wa[Ga + 8] = Z.z, G.morphNormals && (N ? (Va = kc[ma].vertexNormals[Ua], da = Va.a, Ja = Va.b, fa = Va.c) : fa = Ja = da = kc[ma].faceNormals[Ua], xa = yb[ma], xa[Ga] = da.x, xa[Ga + 1] = da.y, xa[Ga + 2] = da.z, xa[Ga + 3] = Ja.x, xa[Ga + 4] = Ja.y, xa[Ga + 5] = Ja.z, xa[Ga + 6] = fa.x, xa[Ga + 7] = fa.y, xa[Ga + 8] = fa.z), Ga += 9;
                  m.bindBuffer(m.ARRAY_BUFFER, A.__webglMorphTargetsBuffers[ma]);
                  m.bufferData(m.ARRAY_BUFFER, qb[ma], C);
                  G.morphNormals && (m.bindBuffer(m.ARRAY_BUFFER, A.__webglMorphNormalsBuffers[ma]), m.bufferData(m.ARRAY_BUFFER, yb[ma], C));
                }
              if (Pb.length) {
                E = 0;
                for (J = ea.length; E < J; E++)
                  K = lb[ea[E]], ka = Pb[K.a], ia = Pb[K.b], la = Pb[K.c], ab[va] = ka.x, ab[va + 1] = ka.y, ab[va + 2] = ka.z, ab[va + 3] = ka.w, ab[va + 4] = ia.x, ab[va + 5] = ia.y, ab[va + 6] = ia.z, ab[va + 7] = ia.w, ab[va + 8] = la.x, ab[va + 9] = la.y, ab[va + 10] = la.z, ab[va + 11] = la.w, na = fc[K.a], qa = fc[K.b], Aa = fc[K.c], $a[va] = na.x, $a[va + 1] = na.y, $a[va + 2] = na.z, $a[va + 3] = na.w, $a[va + 4] = qa.x, $a[va + 5] = qa.y, $a[va + 6] = qa.z, $a[va + 7] = qa.w, $a[va + 8] = Aa.x, $a[va + 9] = Aa.y, $a[va + 10] = Aa.z, $a[va + 11] = Aa.w, va += 12;
                0 < va && (m.bindBuffer(m.ARRAY_BUFFER, A.__webglSkinIndicesBuffer), m.bufferData(m.ARRAY_BUFFER, $a, C), m.bindBuffer(m.ARRAY_BUFFER, A.__webglSkinWeightsBuffer), m.bufferData(m.ARRAY_BUFFER, ab, C));
              }
              if (Lb && O) {
                E = 0;
                for (J = ea.length; E < J; E++)
                  K = lb[ea[E]], Y = K.vertexColors, W = K.color, 3 === Y.length && O === THREE.VertexColors ? (ga = Y[0], ha = Y[1], za = Y[2]) : za = ha = ga = W, kb[eb] = ga.r, kb[eb + 1] = ga.g, kb[eb + 2] = ga.b, kb[eb + 3] = ha.r, kb[eb + 4] = ha.g, kb[eb + 5] = ha.b, kb[eb + 6] = za.r, kb[eb + 7] = za.g, kb[eb + 8] = za.b, eb += 9;
                0 < eb && (m.bindBuffer(m.ARRAY_BUFFER, A.__webglColorBuffer), m.bufferData(m.ARRAY_BUFFER, kb, C));
              }
              if (Kb && Ra.hasTangents) {
                E = 0;
                for (J = ea.length; E < J; E++)
                  K = lb[ea[E]], V = K.vertexTangents, oa = V[0], ta = V[1], Fa = V[2], Za[Ya] = oa.x, Za[Ya + 1] = oa.y, Za[Ya + 2] = oa.z, Za[Ya + 3] = oa.w, Za[Ya + 4] = ta.x, Za[Ya + 5] = ta.y, Za[Ya + 6] = ta.z, Za[Ya + 7] = ta.w, Za[Ya + 8] = Fa.x, Za[Ya + 9] = Fa.y, Za[Ya + 10] = Fa.z, Za[Ya + 11] = Fa.w, Ya += 12;
                m.bindBuffer(m.ARRAY_BUFFER, A.__webglTangentBuffer);
                m.bufferData(m.ARRAY_BUFFER, Za, C);
              }
              if (Jb && H) {
                E = 0;
                for (J = ea.length; E < J; E++)
                  if (K = lb[ea[E]], ca = K.vertexNormals, R = K.normal, 3 === ca.length && N)
                    for (ba = 0; 3 > ba; ba++)
                      Ca = ca[ba], Wa[ib] = Ca.x, Wa[ib + 1] = Ca.y, Wa[ib + 2] = Ca.z, ib += 3;
                  else
                    for (ba = 0; 3 > ba; ba++)
                      Wa[ib] = R.x, Wa[ib + 1] = R.y, Wa[ib + 2] = R.z, ib += 3;
                m.bindBuffer(m.ARRAY_BUFFER, A.__webglNormalBuffer);
                m.bufferData(m.ARRAY_BUFFER, Wa, C);
              }
              if (Bb && Db && L) {
                E = 0;
                for (J = ea.length; E < J; E++)
                  if (Q = ea[E], $ = Db[Q], void 0 !== $)
                    for (ba = 0; 3 > ba; ba++)
                      Ka = $[ba], cb[Na] = Ka.x, cb[Na + 1] = Ka.y, Na += 2;
                0 < Na && (m.bindBuffer(m.ARRAY_BUFFER, A.__webglUVBuffer), m.bufferData(m.ARRAY_BUFFER, cb, C));
              }
              if (Bb && Eb && L) {
                E = 0;
                for (J = ea.length; E < J; E++)
                  if (Q = ea[E], sa = Eb[Q], void 0 !== sa)
                    for (ba = 0; 3 > ba; ba++)
                      Ia = sa[ba], db[Pa] = Ia.x, db[Pa + 1] = Ia.y, Pa += 2;
                0 < Pa && (m.bindBuffer(m.ARRAY_BUFFER, A.__webglUV2Buffer), m.bufferData(m.ARRAY_BUFFER, db, C));
              }
              if (Cb) {
                E = 0;
                for (J = ea.length; E < J; E++)
                  Ob[Qa] = Ba, Ob[Qa + 1] = Ba + 1, Ob[Qa + 2] = Ba + 2, Qa += 3, vb[Ma] = Ba, vb[Ma + 1] = Ba + 1, vb[Ma + 2] = Ba, vb[Ma + 3] = Ba + 2, vb[Ma + 4] = Ba + 1, vb[Ma + 5] = Ba + 2, Ma += 6, Ba += 3;
                m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, A.__webglFaceBuffer);
                m.bufferData(m.ELEMENT_ARRAY_BUFFER, Ob, C);
                m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, A.__webglLineBuffer);
                m.bufferData(m.ELEMENT_ARRAY_BUFFER, vb, C);
              }
              if (ub)
                for (ba = 0, Ea = ub.length; ba < Ea; ba++)
                  if (M = ub[ba], M.__original.needsUpdate) {
                    P = 0;
                    if (1 === M.size)
                      if (void 0 === M.boundTo || 'vertices' === M.boundTo)
                        for (E = 0, J = ea.length; E < J; E++)
                          K = lb[ea[E]], M.array[P] = M.value[K.a], M.array[P + 1] = M.value[K.b], M.array[P + 2] = M.value[K.c], P += 3;
                      else {
                        if ('faces' === M.boundTo)
                          for (E = 0, J = ea.length; E < J; E++)
                            Xa = M.value[ea[E]], M.array[P] = Xa, M.array[P + 1] = Xa, M.array[P + 2] = Xa, P += 3;
                      }
                    else if (2 === M.size)
                      if (void 0 === M.boundTo || 'vertices' === M.boundTo)
                        for (E = 0, J = ea.length; E < J; E++)
                          K = lb[ea[E]], S = M.value[K.a], T = M.value[K.b], Z = M.value[K.c], M.array[P] = S.x, M.array[P + 1] = S.y, M.array[P + 2] = T.x, M.array[P + 3] = T.y, M.array[P + 4] = Z.x, M.array[P + 5] = Z.y, P += 6;
                      else {
                        if ('faces' === M.boundTo)
                          for (E = 0, J = ea.length; E < J; E++)
                            Z = T = S = Xa = M.value[ea[E]], M.array[P] = S.x, M.array[P + 1] = S.y, M.array[P + 2] = T.x, M.array[P + 3] = T.y, M.array[P + 4] = Z.x, M.array[P + 5] = Z.y, P += 6;
                      }
                    else if (3 === M.size) {
                      var ua;
                      ua = 'c' === M.type ? [
                        'r',
                        'g',
                        'b'
                      ] : [
                        'x',
                        'y',
                        'z'
                      ];
                      if (void 0 === M.boundTo || 'vertices' === M.boundTo)
                        for (E = 0, J = ea.length; E < J; E++)
                          K = lb[ea[E]], S = M.value[K.a], T = M.value[K.b], Z = M.value[K.c], M.array[P] = S[ua[0]], M.array[P + 1] = S[ua[1]], M.array[P + 2] = S[ua[2]], M.array[P + 3] = T[ua[0]], M.array[P + 4] = T[ua[1]], M.array[P + 5] = T[ua[2]], M.array[P + 6] = Z[ua[0]], M.array[P + 7] = Z[ua[1]], M.array[P + 8] = Z[ua[2]], P += 9;
                      else if ('faces' === M.boundTo)
                        for (E = 0, J = ea.length; E < J; E++)
                          Z = T = S = Xa = M.value[ea[E]], M.array[P] = S[ua[0]], M.array[P + 1] = S[ua[1]], M.array[P + 2] = S[ua[2]], M.array[P + 3] = T[ua[0]], M.array[P + 4] = T[ua[1]], M.array[P + 5] = T[ua[2]], M.array[P + 6] = Z[ua[0]], M.array[P + 7] = Z[ua[1]], M.array[P + 8] = Z[ua[2]], P += 9;
                      else if ('faceVertices' === M.boundTo)
                        for (E = 0, J = ea.length; E < J; E++)
                          Xa = M.value[ea[E]], S = Xa[0], T = Xa[1], Z = Xa[2], M.array[P] = S[ua[0]], M.array[P + 1] = S[ua[1]], M.array[P + 2] = S[ua[2]], M.array[P + 3] = T[ua[0]], M.array[P + 4] = T[ua[1]], M.array[P + 5] = T[ua[2]], M.array[P + 6] = Z[ua[0]], M.array[P + 7] = Z[ua[1]], M.array[P + 8] = Z[ua[2]], P += 9;
                    } else if (4 === M.size)
                      if (void 0 === M.boundTo || 'vertices' === M.boundTo)
                        for (E = 0, J = ea.length; E < J; E++)
                          K = lb[ea[E]], S = M.value[K.a], T = M.value[K.b], Z = M.value[K.c], M.array[P] = S.x, M.array[P + 1] = S.y, M.array[P + 2] = S.z, M.array[P + 3] = S.w, M.array[P + 4] = T.x, M.array[P + 5] = T.y, M.array[P + 6] = T.z, M.array[P + 7] = T.w, M.array[P + 8] = Z.x, M.array[P + 9] = Z.y, M.array[P + 10] = Z.z, M.array[P + 11] = Z.w, P += 12;
                      else if ('faces' === M.boundTo)
                        for (E = 0, J = ea.length; E < J; E++)
                          Z = T = S = Xa = M.value[ea[E]], M.array[P] = S.x, M.array[P + 1] = S.y, M.array[P + 2] = S.z, M.array[P + 3] = S.w, M.array[P + 4] = T.x, M.array[P + 5] = T.y, M.array[P + 6] = T.z, M.array[P + 7] = T.w, M.array[P + 8] = Z.x, M.array[P + 9] = Z.y, M.array[P + 10] = Z.z, M.array[P + 11] = Z.w, P += 12;
                      else if ('faceVertices' === M.boundTo)
                        for (E = 0, J = ea.length; E < J; E++)
                          Xa = M.value[ea[E]], S = Xa[0], T = Xa[1], Z = Xa[2], M.array[P] = S.x, M.array[P + 1] = S.y, M.array[P + 2] = S.z, M.array[P + 3] = S.w, M.array[P + 4] = T.x, M.array[P + 5] = T.y, M.array[P + 6] = T.z, M.array[P + 7] = T.w, M.array[P + 8] = Z.x, M.array[P + 9] = Z.y, M.array[P + 10] = Z.z, M.array[P + 11] = Z.w, P += 12;
                    m.bindBuffer(m.ARRAY_BUFFER, M.buffer);
                    m.bufferData(m.ARRAY_BUFFER, M.array, C);
                  }
              F && (delete A.__inittedArrays, delete A.__colorArray, delete A.__normalArray, delete A.__tangentArray, delete A.__uvArray, delete A.__uv2Array, delete A.__faceArray, delete A.__vertexArray, delete A.__lineArray, delete A.__skinIndexArray, delete A.__skinWeightArray);
            }
          }
        l.verticesNeedUpdate = !1;
        l.morphTargetsNeedUpdate = !1;
        l.elementsNeedUpdate = !1;
        l.uvsNeedUpdate = !1;
        l.normalsNeedUpdate = !1;
        l.colorsNeedUpdate = !1;
        l.tangentsNeedUpdate = !1;
        l.buffersNeedUpdate = !1;
        r.attributes && w(r);
      } else if (k instanceof THREE.Line) {
        r = d(k, l);
        q = r.attributes && v(r);
        if (l.verticesNeedUpdate || l.colorsNeedUpdate || l.lineDistancesNeedUpdate || q) {
          var bb = l, Rb = m.DYNAMIC_DRAW, Fb = void 0, Gb = void 0, Hb = void 0, Sb = void 0, ra = void 0, Tb = void 0, lc = bb.vertices, mc = bb.colors, nc = bb.lineDistances, Yb = lc.length, Zb = mc.length, $b = nc.length, Ub = bb.__vertexArray, Vb = bb.__colorArray, oc = bb.__lineDistanceArray, ac = bb.colorsNeedUpdate, bc = bb.lineDistancesNeedUpdate, gc = bb.__webglCustomAttributesList, Wb = void 0, pc = void 0, Ha = void 0, zb = void 0, Sa = void 0, pa = void 0;
          if (bb.verticesNeedUpdate) {
            for (Fb = 0; Fb < Yb; Fb++)
              Sb = lc[Fb], ra = 3 * Fb, Ub[ra] = Sb.x, Ub[ra + 1] = Sb.y, Ub[ra + 2] = Sb.z;
            m.bindBuffer(m.ARRAY_BUFFER, bb.__webglVertexBuffer);
            m.bufferData(m.ARRAY_BUFFER, Ub, Rb);
          }
          if (ac) {
            for (Gb = 0; Gb < Zb; Gb++)
              Tb = mc[Gb], ra = 3 * Gb, Vb[ra] = Tb.r, Vb[ra + 1] = Tb.g, Vb[ra + 2] = Tb.b;
            m.bindBuffer(m.ARRAY_BUFFER, bb.__webglColorBuffer);
            m.bufferData(m.ARRAY_BUFFER, Vb, Rb);
          }
          if (bc) {
            for (Hb = 0; Hb < $b; Hb++)
              oc[Hb] = nc[Hb];
            m.bindBuffer(m.ARRAY_BUFFER, bb.__webglLineDistanceBuffer);
            m.bufferData(m.ARRAY_BUFFER, oc, Rb);
          }
          if (gc)
            for (Wb = 0, pc = gc.length; Wb < pc; Wb++)
              if (pa = gc[Wb], pa.needsUpdate && (void 0 === pa.boundTo || 'vertices' === pa.boundTo)) {
                ra = 0;
                zb = pa.value.length;
                if (1 === pa.size)
                  for (Ha = 0; Ha < zb; Ha++)
                    pa.array[Ha] = pa.value[Ha];
                else if (2 === pa.size)
                  for (Ha = 0; Ha < zb; Ha++)
                    Sa = pa.value[Ha], pa.array[ra] = Sa.x, pa.array[ra + 1] = Sa.y, ra += 2;
                else if (3 === pa.size)
                  if ('c' === pa.type)
                    for (Ha = 0; Ha < zb; Ha++)
                      Sa = pa.value[Ha], pa.array[ra] = Sa.r, pa.array[ra + 1] = Sa.g, pa.array[ra + 2] = Sa.b, ra += 3;
                  else
                    for (Ha = 0; Ha < zb; Ha++)
                      Sa = pa.value[Ha], pa.array[ra] = Sa.x, pa.array[ra + 1] = Sa.y, pa.array[ra + 2] = Sa.z, ra += 3;
                else if (4 === pa.size)
                  for (Ha = 0; Ha < zb; Ha++)
                    Sa = pa.value[Ha], pa.array[ra] = Sa.x, pa.array[ra + 1] = Sa.y, pa.array[ra + 2] = Sa.z, pa.array[ra + 3] = Sa.w, ra += 4;
                m.bindBuffer(m.ARRAY_BUFFER, pa.buffer);
                m.bufferData(m.ARRAY_BUFFER, pa.array, Rb);
              }
        }
        l.verticesNeedUpdate = !1;
        l.colorsNeedUpdate = !1;
        l.lineDistancesNeedUpdate = !1;
        r.attributes && w(r);
      } else if (k instanceof THREE.ParticleSystem) {
        r = d(k, l);
        q = r.attributes && v(r);
        if (l.verticesNeedUpdate || l.colorsNeedUpdate || k.sortParticles || q) {
          var mb = l, hc = m.DYNAMIC_DRAW, Ib = k, Ta = void 0, nb = void 0, ob = void 0, X = void 0, pb = void 0, tb = void 0, Xb = mb.vertices, ic = Xb.length, jc = mb.colors, qc = jc.length, wb = mb.__vertexArray, xb = mb.__colorArray, rb = mb.__sortArray, rc = mb.verticesNeedUpdate, sc = mb.colorsNeedUpdate, sb = mb.__webglCustomAttributesList, fb = void 0, Ab = void 0, aa = void 0, gb = void 0, ja = void 0, U = void 0;
          if (Ib.sortParticles) {
            hb.copy(Oa);
            hb.multiply(Ib.matrixWorld);
            for (Ta = 0; Ta < ic; Ta++)
              ob = Xb[Ta], ya.copy(ob), ya.applyProjection(hb), rb[Ta] = [
                ya.z,
                Ta
              ];
            rb.sort(n);
            for (Ta = 0; Ta < ic; Ta++)
              ob = Xb[rb[Ta][1]], X = 3 * Ta, wb[X] = ob.x, wb[X + 1] = ob.y, wb[X + 2] = ob.z;
            for (nb = 0; nb < qc; nb++)
              X = 3 * nb, tb = jc[rb[nb][1]], xb[X] = tb.r, xb[X + 1] = tb.g, xb[X + 2] = tb.b;
            if (sb)
              for (fb = 0, Ab = sb.length; fb < Ab; fb++)
                if (U = sb[fb], void 0 === U.boundTo || 'vertices' === U.boundTo)
                  if (X = 0, gb = U.value.length, 1 === U.size)
                    for (aa = 0; aa < gb; aa++)
                      pb = rb[aa][1], U.array[aa] = U.value[pb];
                  else if (2 === U.size)
                    for (aa = 0; aa < gb; aa++)
                      pb = rb[aa][1], ja = U.value[pb], U.array[X] = ja.x, U.array[X + 1] = ja.y, X += 2;
                  else if (3 === U.size)
                    if ('c' === U.type)
                      for (aa = 0; aa < gb; aa++)
                        pb = rb[aa][1], ja = U.value[pb], U.array[X] = ja.r, U.array[X + 1] = ja.g, U.array[X + 2] = ja.b, X += 3;
                    else
                      for (aa = 0; aa < gb; aa++)
                        pb = rb[aa][1], ja = U.value[pb], U.array[X] = ja.x, U.array[X + 1] = ja.y, U.array[X + 2] = ja.z, X += 3;
                  else if (4 === U.size)
                    for (aa = 0; aa < gb; aa++)
                      pb = rb[aa][1], ja = U.value[pb], U.array[X] = ja.x, U.array[X + 1] = ja.y, U.array[X + 2] = ja.z, U.array[X + 3] = ja.w, X += 4;
          } else {
            if (rc)
              for (Ta = 0; Ta < ic; Ta++)
                ob = Xb[Ta], X = 3 * Ta, wb[X] = ob.x, wb[X + 1] = ob.y, wb[X + 2] = ob.z;
            if (sc)
              for (nb = 0; nb < qc; nb++)
                tb = jc[nb], X = 3 * nb, xb[X] = tb.r, xb[X + 1] = tb.g, xb[X + 2] = tb.b;
            if (sb)
              for (fb = 0, Ab = sb.length; fb < Ab; fb++)
                if (U = sb[fb], U.needsUpdate && (void 0 === U.boundTo || 'vertices' === U.boundTo))
                  if (gb = U.value.length, X = 0, 1 === U.size)
                    for (aa = 0; aa < gb; aa++)
                      U.array[aa] = U.value[aa];
                  else if (2 === U.size)
                    for (aa = 0; aa < gb; aa++)
                      ja = U.value[aa], U.array[X] = ja.x, U.array[X + 1] = ja.y, X += 2;
                  else if (3 === U.size)
                    if ('c' === U.type)
                      for (aa = 0; aa < gb; aa++)
                        ja = U.value[aa], U.array[X] = ja.r, U.array[X + 1] = ja.g, U.array[X + 2] = ja.b, X += 3;
                    else
                      for (aa = 0; aa < gb; aa++)
                        ja = U.value[aa], U.array[X] = ja.x, U.array[X + 1] = ja.y, U.array[X + 2] = ja.z, X += 3;
                  else if (4 === U.size)
                    for (aa = 0; aa < gb; aa++)
                      ja = U.value[aa], U.array[X] = ja.x, U.array[X + 1] = ja.y, U.array[X + 2] = ja.z, U.array[X + 3] = ja.w, X += 4;
          }
          if (rc || Ib.sortParticles)
            m.bindBuffer(m.ARRAY_BUFFER, mb.__webglVertexBuffer), m.bufferData(m.ARRAY_BUFFER, wb, hc);
          if (sc || Ib.sortParticles)
            m.bindBuffer(m.ARRAY_BUFFER, mb.__webglColorBuffer), m.bufferData(m.ARRAY_BUFFER, xb, hc);
          if (sb)
            for (fb = 0, Ab = sb.length; fb < Ab; fb++)
              if (U = sb[fb], U.needsUpdate || Ib.sortParticles)
                m.bindBuffer(m.ARRAY_BUFFER, U.buffer), m.bufferData(m.ARRAY_BUFFER, U.array, hc);
        }
        l.verticesNeedUpdate = !1;
        l.colorsNeedUpdate = !1;
        r.attributes && w(r);
      }
    }
  };
  this.initMaterial = function (a, b, c, d) {
    var e, f, g, h;
    a.addEventListener('dispose', Mb);
    var k, l, p, n, r;
    a instanceof THREE.MeshDepthMaterial ? r = 'depth' : a instanceof THREE.MeshNormalMaterial ? r = 'normal' : a instanceof THREE.MeshBasicMaterial ? r = 'basic' : a instanceof THREE.MeshLambertMaterial ? r = 'lambert' : a instanceof THREE.MeshPhongMaterial ? r = 'phong' : a instanceof THREE.LineBasicMaterial ? r = 'basic' : a instanceof THREE.LineDashedMaterial ? r = 'dashed' : a instanceof THREE.ParticleSystemMaterial && (r = 'particle_basic');
    if (r) {
      var q = THREE.ShaderLib[r];
      a.uniforms = THREE.UniformsUtils.clone(q.uniforms);
      a.vertexShader = q.vertexShader;
      a.fragmentShader = q.fragmentShader;
    }
    var s = e = 0, t = 0, u = q = 0;
    for (f = b.length; u < f; u++)
      g = b[u], g.onlyShadow || !1 === g.visible || (g instanceof THREE.DirectionalLight && e++, g instanceof THREE.PointLight && s++, g instanceof THREE.SpotLight && t++, g instanceof THREE.HemisphereLight && q++);
    f = s;
    g = t;
    h = q;
    t = q = 0;
    for (s = b.length; t < s; t++)
      u = b[t], u.castShadow && (u instanceof THREE.SpotLight && q++, u instanceof THREE.DirectionalLight && !u.shadowCascade && q++);
    n = q;
    ub && d && d.useVertexTexture ? p = 1024 : (b = m.getParameter(m.MAX_VERTEX_UNIFORM_VECTORS), b = Math.floor((b - 20) / 4), void 0 !== d && d instanceof THREE.SkinnedMesh && (b = Math.min(d.bones.length, b), b < d.bones.length && console.warn('WebGLRenderer: too many bones - ' + d.bones.length + ', this GPU supports just ' + b + ' (try OpenGL instead of ANGLE)')), p = b);
    a: {
      t = a.fragmentShader;
      s = a.vertexShader;
      q = a.uniforms;
      b = a.attributes;
      u = a.defines;
      c = {
        map: !!a.map,
        envMap: !!a.envMap,
        lightMap: !!a.lightMap,
        bumpMap: !!a.bumpMap,
        normalMap: !!a.normalMap,
        specularMap: !!a.specularMap,
        vertexColors: a.vertexColors,
        fog: c,
        useFog: a.fog,
        fogExp: c instanceof THREE.FogExp2,
        sizeAttenuation: a.sizeAttenuation,
        skinning: a.skinning,
        maxBones: p,
        useVertexTexture: ub && d && d.useVertexTexture,
        morphTargets: a.morphTargets,
        morphNormals: a.morphNormals,
        maxMorphTargets: this.maxMorphTargets,
        maxMorphNormals: this.maxMorphNormals,
        maxDirLights: e,
        maxPointLights: f,
        maxSpotLights: g,
        maxHemiLights: h,
        maxShadows: n,
        shadowMapEnabled: this.shadowMapEnabled && d.receiveShadow && 0 < n,
        shadowMapType: this.shadowMapType,
        shadowMapDebug: this.shadowMapDebug,
        shadowMapCascade: this.shadowMapCascade,
        alphaTest: a.alphaTest,
        metal: a.metal,
        wrapAround: a.wrapAround,
        doubleSided: a.side === THREE.DoubleSide,
        flipSided: a.side === THREE.BackSide
      };
      d = a.index0AttributeName;
      var v, w, x;
      e = [];
      r ? e.push(r) : (e.push(t), e.push(s));
      for (w in u)
        e.push(w), e.push(u[w]);
      for (v in c)
        e.push(v), e.push(c[v]);
      r = e.join();
      v = 0;
      for (w = ca.length; v < w; v++)
        if (e = ca[v], e.code === r) {
          e.usedTimes++;
          l = e.program;
          break a;
        }
      v = 'SHADOWMAP_TYPE_BASIC';
      c.shadowMapType === THREE.PCFShadowMap ? v = 'SHADOWMAP_TYPE_PCF' : c.shadowMapType === THREE.PCFSoftShadowMap && (v = 'SHADOWMAP_TYPE_PCF_SOFT');
      w = [];
      for (x in u)
        e = u[x], !1 !== e && (e = '#define ' + x + ' ' + e, w.push(e));
      e = w.join('\n');
      x = m.createProgram();
      w = [
        'precision ' + Y + ' float;',
        'precision ' + Y + ' int;',
        e,
        yb ? '#define VERTEX_TEXTURES' : '',
        N.gammaInput ? '#define GAMMA_INPUT' : '',
        N.gammaOutput ? '#define GAMMA_OUTPUT' : '',
        '#define MAX_DIR_LIGHTS ' + c.maxDirLights,
        '#define MAX_POINT_LIGHTS ' + c.maxPointLights,
        '#define MAX_SPOT_LIGHTS ' + c.maxSpotLights,
        '#define MAX_HEMI_LIGHTS ' + c.maxHemiLights,
        '#define MAX_SHADOWS ' + c.maxShadows,
        '#define MAX_BONES ' + c.maxBones,
        c.map ? '#define USE_MAP' : '',
        c.envMap ? '#define USE_ENVMAP' : '',
        c.lightMap ? '#define USE_LIGHTMAP' : '',
        c.bumpMap ? '#define USE_BUMPMAP' : '',
        c.normalMap ? '#define USE_NORMALMAP' : '',
        c.specularMap ? '#define USE_SPECULARMAP' : '',
        c.vertexColors ? '#define USE_COLOR' : '',
        c.skinning ? '#define USE_SKINNING' : '',
        c.useVertexTexture ? '#define BONE_TEXTURE' : '',
        c.morphTargets ? '#define USE_MORPHTARGETS' : '',
        c.morphNormals ? '#define USE_MORPHNORMALS' : '',
        c.wrapAround ? '#define WRAP_AROUND' : '',
        c.doubleSided ? '#define DOUBLE_SIDED' : '',
        c.flipSided ? '#define FLIP_SIDED' : '',
        c.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        c.shadowMapEnabled ? '#define ' + v : '',
        c.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
        c.shadowMapCascade ? '#define SHADOWMAP_CASCADE' : '',
        c.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
        'uniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\nattribute vec2 uv2;\n#ifdef USE_COLOR\nattribute vec3 color;\n#endif\n#ifdef USE_MORPHTARGETS\nattribute vec3 morphTarget0;\nattribute vec3 morphTarget1;\nattribute vec3 morphTarget2;\nattribute vec3 morphTarget3;\n#ifdef USE_MORPHNORMALS\nattribute vec3 morphNormal0;\nattribute vec3 morphNormal1;\nattribute vec3 morphNormal2;\nattribute vec3 morphNormal3;\n#else\nattribute vec3 morphTarget4;\nattribute vec3 morphTarget5;\nattribute vec3 morphTarget6;\nattribute vec3 morphTarget7;\n#endif\n#endif\n#ifdef USE_SKINNING\nattribute vec4 skinIndex;\nattribute vec4 skinWeight;\n#endif\n'
      ].join('\n');
      v = [
        'precision ' + Y + ' float;',
        'precision ' + Y + ' int;',
        c.bumpMap || c.normalMap ? '#extension GL_OES_standard_derivatives : enable' : '',
        e,
        '#define MAX_DIR_LIGHTS ' + c.maxDirLights,
        '#define MAX_POINT_LIGHTS ' + c.maxPointLights,
        '#define MAX_SPOT_LIGHTS ' + c.maxSpotLights,
        '#define MAX_HEMI_LIGHTS ' + c.maxHemiLights,
        '#define MAX_SHADOWS ' + c.maxShadows,
        c.alphaTest ? '#define ALPHATEST ' + c.alphaTest : '',
        N.gammaInput ? '#define GAMMA_INPUT' : '',
        N.gammaOutput ? '#define GAMMA_OUTPUT' : '',
        c.useFog && c.fog ? '#define USE_FOG' : '',
        c.useFog && c.fogExp ? '#define FOG_EXP2' : '',
        c.map ? '#define USE_MAP' : '',
        c.envMap ? '#define USE_ENVMAP' : '',
        c.lightMap ? '#define USE_LIGHTMAP' : '',
        c.bumpMap ? '#define USE_BUMPMAP' : '',
        c.normalMap ? '#define USE_NORMALMAP' : '',
        c.specularMap ? '#define USE_SPECULARMAP' : '',
        c.vertexColors ? '#define USE_COLOR' : '',
        c.metal ? '#define METAL' : '',
        c.wrapAround ? '#define WRAP_AROUND' : '',
        c.doubleSided ? '#define DOUBLE_SIDED' : '',
        c.flipSided ? '#define FLIP_SIDED' : '',
        c.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        c.shadowMapEnabled ? '#define ' + v : '',
        c.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
        c.shadowMapCascade ? '#define SHADOWMAP_CASCADE' : '',
        'uniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\n'
      ].join('\n');
      w = K('vertex', w + s);
      v = K('fragment', v + t);
      m.attachShader(x, w);
      m.attachShader(x, v);
      void 0 !== d && m.bindAttribLocation(x, 0, d);
      m.linkProgram(x);
      !1 === m.getProgramParameter(x, m.LINK_STATUS) && (console.error('Could not initialise shader'), console.error('gl.VALIDATE_STATUS', m.getProgramParameter(x, m.VALIDATE_STATUS)), console.error('gl.getError()', m.getError()));
      '' !== m.getProgramInfoLog(x) && console.error('gl.getProgramInfoLog()', m.getProgramInfoLog(x));
      m.deleteShader(v);
      m.deleteShader(w);
      x.uniforms = {};
      x.attributes = {};
      var z;
      v = 'viewMatrix modelViewMatrix projectionMatrix normalMatrix modelMatrix cameraPosition morphTargetInfluences'.split(' ');
      c.useVertexTexture ? (v.push('boneTexture'), v.push('boneTextureWidth'), v.push('boneTextureHeight')) : v.push('boneGlobalMatrices');
      for (z in q)
        v.push(z);
      z = v;
      v = 0;
      for (w = z.length; v < w; v++)
        q = z[v], x.uniforms[q] = m.getUniformLocation(x, q);
      v = 'position normal uv uv2 tangent color skinIndex skinWeight lineDistance'.split(' ');
      for (z = 0; z < c.maxMorphTargets; z++)
        v.push('morphTarget' + z);
      for (z = 0; z < c.maxMorphNormals; z++)
        v.push('morphNormal' + z);
      for (l in b)
        v.push(l);
      l = v;
      z = 0;
      for (b = l.length; z < b; z++)
        v = l[z], x.attributes[v] = m.getAttribLocation(x, v);
      x.id = sa++;
      ca.push({
        program: x,
        code: r,
        usedTimes: 1
      });
      N.info.memory.programs = ca.length;
      l = x;
    }
    a.program = l;
    z = a.program.attributes;
    if (a.morphTargets)
      for (a.numSupportedMorphTargets = 0, b = 'morphTarget', l = 0; l < this.maxMorphTargets; l++)
        x = b + l, 0 <= z[x] && a.numSupportedMorphTargets++;
    if (a.morphNormals)
      for (a.numSupportedMorphNormals = 0, b = 'morphNormal', l = 0; l < this.maxMorphNormals; l++)
        x = b + l, 0 <= z[x] && a.numSupportedMorphNormals++;
    a.uniformsList = [];
    for (k in a.uniforms)
      a.uniformsList.push([
        a.uniforms[k],
        k
      ]);
  };
  this.setFaceCulling = function (a, b) {
    a === THREE.CullFaceNone ? m.disable(m.CULL_FACE) : (b === THREE.FrontFaceDirectionCW ? m.frontFace(m.CW) : m.frontFace(m.CCW), a === THREE.CullFaceBack ? m.cullFace(m.BACK) : a === THREE.CullFaceFront ? m.cullFace(m.FRONT) : m.cullFace(m.FRONT_AND_BACK), m.enable(m.CULL_FACE));
  };
  this.setMaterialFaces = function (a) {
    var b = a.side === THREE.DoubleSide;
    a = a.side === THREE.BackSide;
    oa !== b && (b ? m.disable(m.CULL_FACE) : m.enable(m.CULL_FACE), oa = b);
    za !== a && (a ? m.frontFace(m.CW) : m.frontFace(m.CCW), za = a);
  };
  this.setDepthTest = function (a) {
    Ka !== a && (a ? m.enable(m.DEPTH_TEST) : m.disable(m.DEPTH_TEST), Ka = a);
  };
  this.setDepthWrite = function (a) {
    la !== a && (m.depthMask(a), la = a);
  };
  this.setBlending = function (a, b, c, d) {
    a !== Aa && (a === THREE.NoBlending ? m.disable(m.BLEND) : a === THREE.AdditiveBlending ? (m.enable(m.BLEND), m.blendEquation(m.FUNC_ADD), m.blendFunc(m.SRC_ALPHA, m.ONE)) : a === THREE.SubtractiveBlending ? (m.enable(m.BLEND), m.blendEquation(m.FUNC_ADD), m.blendFunc(m.ZERO, m.ONE_MINUS_SRC_COLOR)) : a === THREE.MultiplyBlending ? (m.enable(m.BLEND), m.blendEquation(m.FUNC_ADD), m.blendFunc(m.ZERO, m.SRC_COLOR)) : a === THREE.CustomBlending ? m.enable(m.BLEND) : (m.enable(m.BLEND), m.blendEquationSeparate(m.FUNC_ADD, m.FUNC_ADD), m.blendFuncSeparate(m.SRC_ALPHA, m.ONE_MINUS_SRC_ALPHA, m.ONE, m.ONE_MINUS_SRC_ALPHA)), Aa = a);
    if (a === THREE.CustomBlending) {
      if (b !== Ua && (m.blendEquation(A(b)), Ua = b), c !== Va || d !== ka)
        m.blendFunc(A(c), A(d)), Va = c, ka = d;
    } else
      ka = Va = Ua = null;
  };
  this.setTexture = function (a, b) {
    if (a.needsUpdate) {
      a.__webglInit || (a.__webglInit = !0, a.addEventListener('dispose', Cb), a.__webglTexture = m.createTexture(), N.info.memory.textures++);
      m.activeTexture(m.TEXTURE0 + b);
      m.bindTexture(m.TEXTURE_2D, a.__webglTexture);
      m.pixelStorei(m.UNPACK_FLIP_Y_WEBGL, a.flipY);
      m.pixelStorei(m.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha);
      m.pixelStorei(m.UNPACK_ALIGNMENT, a.unpackAlignment);
      var c = a.image, d = THREE.Math.isPowerOfTwo(c.width) && THREE.Math.isPowerOfTwo(c.height), e = A(a.format), f = A(a.type);
      y(m.TEXTURE_2D, a, d);
      var g = a.mipmaps;
      if (a instanceof THREE.DataTexture)
        if (0 < g.length && d) {
          for (var h = 0, k = g.length; h < k; h++)
            c = g[h], m.texImage2D(m.TEXTURE_2D, h, e, c.width, c.height, 0, e, f, c.data);
          a.generateMipmaps = !1;
        } else
          m.texImage2D(m.TEXTURE_2D, 0, e, c.width, c.height, 0, e, f, c.data);
      else if (a instanceof THREE.CompressedTexture)
        for (h = 0, k = g.length; h < k; h++)
          c = g[h], a.format !== THREE.RGBAFormat ? m.compressedTexImage2D(m.TEXTURE_2D, h, e, c.width, c.height, 0, c.data) : m.texImage2D(m.TEXTURE_2D, h, e, c.width, c.height, 0, e, f, c.data);
      else if (0 < g.length && d) {
        h = 0;
        for (k = g.length; h < k; h++)
          c = g[h], m.texImage2D(m.TEXTURE_2D, h, e, e, f, c);
        a.generateMipmaps = !1;
      } else
        m.texImage2D(m.TEXTURE_2D, 0, e, e, f, a.image);
      a.generateMipmaps && d && m.generateMipmap(m.TEXTURE_2D);
      a.needsUpdate = !1;
      if (a.onUpdate)
        a.onUpdate();
    } else
      m.activeTexture(m.TEXTURE0 + b), m.bindTexture(m.TEXTURE_2D, a.__webglTexture);
  };
  this.setRenderTarget = function (a) {
    var b = a instanceof THREE.WebGLRenderTargetCube;
    if (a && !a.__webglFramebuffer) {
      void 0 === a.depthBuffer && (a.depthBuffer = !0);
      void 0 === a.stencilBuffer && (a.stencilBuffer = !0);
      a.addEventListener('dispose', Lb);
      a.__webglTexture = m.createTexture();
      N.info.memory.textures++;
      var c = THREE.Math.isPowerOfTwo(a.width) && THREE.Math.isPowerOfTwo(a.height), d = A(a.format), e = A(a.type);
      if (b) {
        a.__webglFramebuffer = [];
        a.__webglRenderbuffer = [];
        m.bindTexture(m.TEXTURE_CUBE_MAP, a.__webglTexture);
        y(m.TEXTURE_CUBE_MAP, a, c);
        for (var f = 0; 6 > f; f++) {
          a.__webglFramebuffer[f] = m.createFramebuffer();
          a.__webglRenderbuffer[f] = m.createRenderbuffer();
          m.texImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X + f, 0, d, a.width, a.height, 0, d, e, null);
          var g = a, h = m.TEXTURE_CUBE_MAP_POSITIVE_X + f;
          m.bindFramebuffer(m.FRAMEBUFFER, a.__webglFramebuffer[f]);
          m.framebufferTexture2D(m.FRAMEBUFFER, m.COLOR_ATTACHMENT0, h, g.__webglTexture, 0);
          F(a.__webglRenderbuffer[f], a);
        }
        c && m.generateMipmap(m.TEXTURE_CUBE_MAP);
      } else
        a.__webglFramebuffer = m.createFramebuffer(), a.__webglRenderbuffer = a.shareDepthFrom ? a.shareDepthFrom.__webglRenderbuffer : m.createRenderbuffer(), m.bindTexture(m.TEXTURE_2D, a.__webglTexture), y(m.TEXTURE_2D, a, c), m.texImage2D(m.TEXTURE_2D, 0, d, a.width, a.height, 0, d, e, null), d = m.TEXTURE_2D, m.bindFramebuffer(m.FRAMEBUFFER, a.__webglFramebuffer), m.framebufferTexture2D(m.FRAMEBUFFER, m.COLOR_ATTACHMENT0, d, a.__webglTexture, 0), a.shareDepthFrom ? a.depthBuffer && !a.stencilBuffer ? m.framebufferRenderbuffer(m.FRAMEBUFFER, m.DEPTH_ATTACHMENT, m.RENDERBUFFER, a.__webglRenderbuffer) : a.depthBuffer && a.stencilBuffer && m.framebufferRenderbuffer(m.FRAMEBUFFER, m.DEPTH_STENCIL_ATTACHMENT, m.RENDERBUFFER, a.__webglRenderbuffer) : F(a.__webglRenderbuffer, a), c && m.generateMipmap(m.TEXTURE_2D);
      b ? m.bindTexture(m.TEXTURE_CUBE_MAP, null) : m.bindTexture(m.TEXTURE_2D, null);
      m.bindRenderbuffer(m.RENDERBUFFER, null);
      m.bindFramebuffer(m.FRAMEBUFFER, null);
    }
    a ? (b = b ? a.__webglFramebuffer[a.activeCubeFace] : a.__webglFramebuffer, c = a.width, a = a.height, e = d = 0) : (b = null, c = xa, a = Da, d = ba, e = wa);
    b !== Ja && (m.bindFramebuffer(m.FRAMEBUFFER, b), m.viewport(d, e, c, a), Ja = b);
    Wa = c;
    La = a;
  };
  this.shadowMapPlugin = new THREE.ShadowMapPlugin();
  this.addPrePlugin(this.shadowMapPlugin);
  this.addPostPlugin(new THREE.SpritePlugin());
  this.addPostPlugin(new THREE.LensFlarePlugin());
};
THREE.WebGLRenderTarget = function (a, b, c) {
  this.width = a;
  this.height = b;
  c = c || {};
  this.wrapS = void 0 !== c.wrapS ? c.wrapS : THREE.ClampToEdgeWrapping;
  this.wrapT = void 0 !== c.wrapT ? c.wrapT : THREE.ClampToEdgeWrapping;
  this.magFilter = void 0 !== c.magFilter ? c.magFilter : THREE.LinearFilter;
  this.minFilter = void 0 !== c.minFilter ? c.minFilter : THREE.LinearMipMapLinearFilter;
  this.anisotropy = void 0 !== c.anisotropy ? c.anisotropy : 1;
  this.offset = new THREE.Vector2(0, 0);
  this.repeat = new THREE.Vector2(1, 1);
  this.format = void 0 !== c.format ? c.format : THREE.RGBAFormat;
  this.type = void 0 !== c.type ? c.type : THREE.UnsignedByteType;
  this.depthBuffer = void 0 !== c.depthBuffer ? c.depthBuffer : !0;
  this.stencilBuffer = void 0 !== c.stencilBuffer ? c.stencilBuffer : !0;
  this.generateMipmaps = !0;
  this.shareDepthFrom = null;
};
THREE.WebGLRenderTarget.prototype = {
  constructor: THREE.WebGLRenderTarget,
  clone: function () {
    var a = new THREE.WebGLRenderTarget(this.width, this.height);
    a.wrapS = this.wrapS;
    a.wrapT = this.wrapT;
    a.magFilter = this.magFilter;
    a.minFilter = this.minFilter;
    a.anisotropy = this.anisotropy;
    a.offset.copy(this.offset);
    a.repeat.copy(this.repeat);
    a.format = this.format;
    a.type = this.type;
    a.depthBuffer = this.depthBuffer;
    a.stencilBuffer = this.stencilBuffer;
    a.generateMipmaps = this.generateMipmaps;
    a.shareDepthFrom = this.shareDepthFrom;
    return a;
  },
  dispose: function () {
    this.dispatchEvent({ type: 'dispose' });
  }
};
THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype);
THREE.WebGLRenderTargetCube = function (a, b, c) {
  THREE.WebGLRenderTarget.call(this, a, b, c);
  this.activeCubeFace = 0;
};
THREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype);
THREE.RenderableVertex = function () {
  this.position = new THREE.Vector3();
  this.positionWorld = new THREE.Vector3();
  this.positionScreen = new THREE.Vector4();
  this.visible = !0;
};
THREE.RenderableVertex.prototype.copy = function (a) {
  this.positionWorld.copy(a.positionWorld);
  this.positionScreen.copy(a.positionScreen);
};
THREE.RenderableFace = function () {
  this.id = 0;
  this.v1 = new THREE.RenderableVertex();
  this.v2 = new THREE.RenderableVertex();
  this.v3 = new THREE.RenderableVertex();
  this.centroidModel = new THREE.Vector3();
  this.normalModel = new THREE.Vector3();
  this.vertexNormalsModel = [
    new THREE.Vector3(),
    new THREE.Vector3(),
    new THREE.Vector3()
  ];
  this.vertexNormalsLength = 0;
  this.material = this.color = null;
  this.uvs = [[]];
  this.z = 0;
};
THREE.RenderableObject = function () {
  this.id = 0;
  this.object = null;
  this.z = 0;
};
THREE.RenderableSprite = function () {
  this.id = 0;
  this.object = null;
  this.rotation = this.z = this.y = this.x = 0;
  this.scale = new THREE.Vector2();
  this.material = null;
};
THREE.RenderableLine = function () {
  this.id = 0;
  this.v1 = new THREE.RenderableVertex();
  this.v2 = new THREE.RenderableVertex();
  this.vertexColors = [
    new THREE.Color(),
    new THREE.Color()
  ];
  this.material = null;
  this.z = 0;
};
THREE.GeometryUtils = {
  merge: function (a, b, c) {
    var d, e, f = a.vertices.length, g = b instanceof THREE.Mesh ? b.geometry : b, h = a.vertices, k = g.vertices, l = a.faces, n = g.faces;
    a = a.faceVertexUvs[0];
    g = g.faceVertexUvs[0];
    void 0 === c && (c = 0);
    b instanceof THREE.Mesh && (b.matrixAutoUpdate && b.updateMatrix(), d = b.matrix, e = new THREE.Matrix3().getNormalMatrix(d));
    b = 0;
    for (var s = k.length; b < s; b++) {
      var r = k[b].clone();
      d && r.applyMatrix4(d);
      h.push(r);
    }
    b = 0;
    for (s = n.length; b < s; b++) {
      var r = n[b], q, u, p = r.vertexNormals, v = r.vertexColors;
      q = new THREE.Face3(r.a + f, r.b + f, r.c + f);
      q.normal.copy(r.normal);
      e && q.normal.applyMatrix3(e).normalize();
      h = 0;
      for (k = p.length; h < k; h++)
        u = p[h].clone(), e && u.applyMatrix3(e).normalize(), q.vertexNormals.push(u);
      q.color.copy(r.color);
      h = 0;
      for (k = v.length; h < k; h++)
        u = v[h], q.vertexColors.push(u.clone());
      q.materialIndex = r.materialIndex + c;
      q.centroid.copy(r.centroid);
      d && q.centroid.applyMatrix4(d);
      l.push(q);
    }
    b = 0;
    for (s = g.length; b < s; b++) {
      c = g[b];
      d = [];
      h = 0;
      for (k = c.length; h < k; h++)
        d.push(new THREE.Vector2(c[h].x, c[h].y));
      a.push(d);
    }
  },
  randomPointInTriangle: function () {
    var a = new THREE.Vector3();
    return function (b, c, d) {
      var e = new THREE.Vector3(), f = THREE.Math.random16(), g = THREE.Math.random16();
      1 < f + g && (f = 1 - f, g = 1 - g);
      var h = 1 - f - g;
      e.copy(b);
      e.multiplyScalar(f);
      a.copy(c);
      a.multiplyScalar(g);
      e.add(a);
      a.copy(d);
      a.multiplyScalar(h);
      e.add(a);
      return e;
    };
  }(),
  randomPointInFace: function (a, b, c) {
    return THREE.GeometryUtils.randomPointInTriangle(b.vertices[a.a], b.vertices[a.b], b.vertices[a.c]);
  },
  randomPointsInGeometry: function (a, b) {
    function c(a) {
      function b(c, d) {
        if (d < c)
          return c;
        var e = c + Math.floor((d - c) / 2);
        return l[e] > a ? b(c, e - 1) : l[e] < a ? b(e + 1, d) : e;
      }
      return b(0, l.length - 1);
    }
    var d, e, f = a.faces, g = a.vertices, h = f.length, k = 0, l = [], n, s, r;
    for (e = 0; e < h; e++)
      d = f[e], n = g[d.a], s = g[d.b], r = g[d.c], d._area = THREE.GeometryUtils.triangleArea(n, s, r), k += d._area, l[e] = k;
    d = [];
    for (e = 0; e < b; e++)
      g = THREE.Math.random16() * k, g = c(g), d[e] = THREE.GeometryUtils.randomPointInFace(f[g], a, !0);
    return d;
  },
  triangleArea: function () {
    var a = new THREE.Vector3(), b = new THREE.Vector3();
    return function (c, d, e) {
      a.subVectors(d, c);
      b.subVectors(e, c);
      a.cross(b);
      return 0.5 * a.length();
    };
  }(),
  center: function (a) {
    a.computeBoundingBox();
    var b = a.boundingBox, c = new THREE.Vector3();
    c.addVectors(b.min, b.max);
    c.multiplyScalar(-0.5);
    a.applyMatrix(new THREE.Matrix4().makeTranslation(c.x, c.y, c.z));
    a.computeBoundingBox();
    return c;
  },
  triangulateQuads: function (a) {
    var b, c, d, e, f = [], g = [];
    b = 0;
    for (c = a.faceVertexUvs.length; b < c; b++)
      g[b] = [];
    b = 0;
    for (c = a.faces.length; b < c; b++)
      for (f.push(a.faces[b]), d = 0, e = a.faceVertexUvs.length; d < e; d++)
        g[d].push(a.faceVertexUvs[d][b]);
    a.faces = f;
    a.faceVertexUvs = g;
    a.computeCentroids();
    a.computeFaceNormals();
    a.computeVertexNormals();
    a.hasTangents && a.computeTangents();
  }
};
THREE.ImageUtils = {
  crossOrigin: void 0,
  loadTexture: function (a, b, c, d) {
    d = new THREE.ImageLoader();
    d.crossOrigin = this.crossOrigin;
    var e = new THREE.Texture(void 0, b);
    b = d.load(a, function () {
      e.needsUpdate = !0;
      c && c(e);
    });
    e.image = b;
    e.sourceFile = a;
    return e;
  },
  loadCompressedTexture: function (a, b, c, d) {
    var e = new THREE.CompressedTexture();
    e.mapping = b;
    var f = new XMLHttpRequest();
    f.onload = function () {
      var a = THREE.ImageUtils.parseDDS(f.response, !0);
      e.format = a.format;
      e.mipmaps = a.mipmaps;
      e.image.width = a.width;
      e.image.height = a.height;
      e.generateMipmaps = !1;
      e.needsUpdate = !0;
      c && c(e);
    };
    f.onerror = d;
    f.open('GET', a, !0);
    f.responseType = 'arraybuffer';
    f.send(null);
    return e;
  },
  loadTextureCube: function (a, b, c, d) {
    var e = [];
    e.loadCount = 0;
    var f = new THREE.Texture();
    f.image = e;
    void 0 !== b && (f.mapping = b);
    f.flipY = !1;
    b = 0;
    for (var g = a.length; b < g; ++b) {
      var h = new Image();
      e[b] = h;
      h.onload = function () {
        e.loadCount += 1;
        6 === e.loadCount && (f.needsUpdate = !0, c && c(f));
      };
      h.onerror = d;
      h.crossOrigin = this.crossOrigin;
      h.src = a[b];
    }
    return f;
  },
  loadCompressedTextureCube: function (a, b, c, d) {
    var e = [];
    e.loadCount = 0;
    var f = new THREE.CompressedTexture();
    f.image = e;
    void 0 !== b && (f.mapping = b);
    f.flipY = !1;
    f.generateMipmaps = !1;
    b = function (a, b) {
      return function () {
        var d = THREE.ImageUtils.parseDDS(a.response, !0);
        b.format = d.format;
        b.mipmaps = d.mipmaps;
        b.width = d.width;
        b.height = d.height;
        e.loadCount += 1;
        6 === e.loadCount && (f.format = d.format, f.needsUpdate = !0, c && c(f));
      };
    };
    if (a instanceof Array)
      for (var g = 0, h = a.length; g < h; ++g) {
        var k = {};
        e[g] = k;
        var l = new XMLHttpRequest();
        l.onload = b(l, k);
        l.onerror = d;
        k = a[g];
        l.open('GET', k, !0);
        l.responseType = 'arraybuffer';
        l.send(null);
      }
    else
      l = new XMLHttpRequest(), l.onload = function () {
        var a = THREE.ImageUtils.parseDDS(l.response, !0);
        if (a.isCubemap) {
          for (var b = a.mipmaps.length / a.mipmapCount, d = 0; d < b; d++) {
            e[d] = { mipmaps: [] };
            for (var g = 0; g < a.mipmapCount; g++)
              e[d].mipmaps.push(a.mipmaps[d * a.mipmapCount + g]), e[d].format = a.format, e[d].width = a.width, e[d].height = a.height;
          }
          f.format = a.format;
          f.needsUpdate = !0;
          c && c(f);
        }
      }, l.onerror = d, l.open('GET', a, !0), l.responseType = 'arraybuffer', l.send(null);
    return f;
  },
  loadDDSTexture: function (a, b, c, d) {
    var e = [];
    e.loadCount = 0;
    var f = new THREE.CompressedTexture();
    f.image = e;
    void 0 !== b && (f.mapping = b);
    f.flipY = !1;
    f.generateMipmaps = !1;
    var g = new XMLHttpRequest();
    g.onload = function () {
      var a = THREE.ImageUtils.parseDDS(g.response, !0);
      if (a.isCubemap)
        for (var b = a.mipmaps.length / a.mipmapCount, d = 0; d < b; d++) {
          e[d] = { mipmaps: [] };
          for (var n = 0; n < a.mipmapCount; n++)
            e[d].mipmaps.push(a.mipmaps[d * a.mipmapCount + n]), e[d].format = a.format, e[d].width = a.width, e[d].height = a.height;
        }
      else
        f.image.width = a.width, f.image.height = a.height, f.mipmaps = a.mipmaps;
      f.format = a.format;
      f.needsUpdate = !0;
      c && c(f);
    };
    g.onerror = d;
    g.open('GET', a, !0);
    g.responseType = 'arraybuffer';
    g.send(null);
    return f;
  },
  parseDDS: function (a, b) {
    function c(a) {
      return a.charCodeAt(0) + (a.charCodeAt(1) << 8) + (a.charCodeAt(2) << 16) + (a.charCodeAt(3) << 24);
    }
    function d(a, b, c, d) {
      var e = c * d * 4;
      a = new Uint8Array(a, b, e);
      for (var e = new Uint8Array(e), f = b = 0, g = 0; g < d; g++)
        for (var h = 0; h < c; h++) {
          var k = a[f];
          f++;
          var l = a[f];
          f++;
          var n = a[f];
          f++;
          var q = a[f];
          f++;
          e[b] = n;
          b++;
          e[b] = l;
          b++;
          e[b] = k;
          b++;
          e[b] = q;
          b++;
        }
      return e;
    }
    var e = {
        mipmaps: [],
        width: 0,
        height: 0,
        format: null,
        mipmapCount: 1
      }, f = c('DXT1'), g = c('DXT3'), h = c('DXT5'), k = new Int32Array(a, 0, 31);
    if (542327876 !== k[0])
      return console.error('ImageUtils.parseDDS(): Invalid magic number in DDS header'), e;
    if (!k[20] & 4)
      return console.error('ImageUtils.parseDDS(): Unsupported format, must contain a FourCC code'), e;
    var l = k[21], n = !1;
    switch (l) {
    case f:
      f = 8;
      e.format = THREE.RGB_S3TC_DXT1_Format;
      break;
    case g:
      f = 16;
      e.format = THREE.RGBA_S3TC_DXT3_Format;
      break;
    case h:
      f = 16;
      e.format = THREE.RGBA_S3TC_DXT5_Format;
      break;
    default:
      if (32 == k[22] && k[23] & 16711680 && k[24] & 65280 && k[25] & 255 && k[26] & 4278190080)
        n = !0, f = 64, e.format = THREE.RGBAFormat;
      else
        return console.error('ImageUtils.parseDDS(): Unsupported FourCC code: ', String.fromCharCode(l & 255, l >> 8 & 255, l >> 16 & 255, l >> 24 & 255)), e;
    }
    e.mipmapCount = 1;
    k[2] & 131072 && !1 !== b && (e.mipmapCount = Math.max(1, k[7]));
    e.isCubemap = k[28] & 512 ? !0 : !1;
    e.width = k[4];
    e.height = k[3];
    for (var k = k[1] + 4, g = e.width, h = e.height, l = e.isCubemap ? 6 : 1, s = 0; s < l; s++) {
      for (var r = 0; r < e.mipmapCount; r++) {
        if (n)
          var q = d(a, k, g, h), u = q.length;
        else
          u = Math.max(4, g) / 4 * Math.max(4, h) / 4 * f, q = new Uint8Array(a, k, u);
        e.mipmaps.push({
          data: q,
          width: g,
          height: h
        });
        k += u;
        g = Math.max(0.5 * g, 1);
        h = Math.max(0.5 * h, 1);
      }
      g = e.width;
      h = e.height;
    }
    return e;
  },
  getNormalMap: function (a, b) {
    var c = function (a) {
      var b = Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
      return [
        a[0] / b,
        a[1] / b,
        a[2] / b
      ];
    };
    b |= 1;
    var d = a.width, e = a.height, f = document.createElement('canvas');
    f.width = d;
    f.height = e;
    var g = f.getContext('2d');
    g.drawImage(a, 0, 0);
    for (var h = g.getImageData(0, 0, d, e).data, k = g.createImageData(d, e), l = k.data, n = 0; n < d; n++)
      for (var s = 0; s < e; s++) {
        var r = 0 > s - 1 ? 0 : s - 1, q = s + 1 > e - 1 ? e - 1 : s + 1, u = 0 > n - 1 ? 0 : n - 1, p = n + 1 > d - 1 ? d - 1 : n + 1, v = [], w = [
            0,
            0,
            h[4 * (s * d + n)] / 255 * b
          ];
        v.push([
          -1,
          0,
          h[4 * (s * d + u)] / 255 * b
        ]);
        v.push([
          -1,
          -1,
          h[4 * (r * d + u)] / 255 * b
        ]);
        v.push([
          0,
          -1,
          h[4 * (r * d + n)] / 255 * b
        ]);
        v.push([
          1,
          -1,
          h[4 * (r * d + p)] / 255 * b
        ]);
        v.push([
          1,
          0,
          h[4 * (s * d + p)] / 255 * b
        ]);
        v.push([
          1,
          1,
          h[4 * (q * d + p)] / 255 * b
        ]);
        v.push([
          0,
          1,
          h[4 * (q * d + n)] / 255 * b
        ]);
        v.push([
          -1,
          1,
          h[4 * (q * d + u)] / 255 * b
        ]);
        r = [];
        u = v.length;
        for (q = 0; q < u; q++) {
          var p = v[q], t = v[(q + 1) % u], p = [
              p[0] - w[0],
              p[1] - w[1],
              p[2] - w[2]
            ], t = [
              t[0] - w[0],
              t[1] - w[1],
              t[2] - w[2]
            ];
          r.push(c([
            p[1] * t[2] - p[2] * t[1],
            p[2] * t[0] - p[0] * t[2],
            p[0] * t[1] - p[1] * t[0]
          ]));
        }
        v = [
          0,
          0,
          0
        ];
        for (q = 0; q < r.length; q++)
          v[0] += r[q][0], v[1] += r[q][1], v[2] += r[q][2];
        v[0] /= r.length;
        v[1] /= r.length;
        v[2] /= r.length;
        w = 4 * (s * d + n);
        l[w] = (v[0] + 1) / 2 * 255 | 0;
        l[w + 1] = (v[1] + 1) / 2 * 255 | 0;
        l[w + 2] = 255 * v[2] | 0;
        l[w + 3] = 255;
      }
    g.putImageData(k, 0, 0);
    return f;
  },
  generateDataTexture: function (a, b, c) {
    var d = a * b, e = new Uint8Array(3 * d), f = Math.floor(255 * c.r), g = Math.floor(255 * c.g);
    c = Math.floor(255 * c.b);
    for (var h = 0; h < d; h++)
      e[3 * h] = f, e[3 * h + 1] = g, e[3 * h + 2] = c;
    a = new THREE.DataTexture(e, a, b, THREE.RGBFormat);
    a.needsUpdate = !0;
    return a;
  }
};
THREE.SceneUtils = {
  createMultiMaterialObject: function (a, b) {
    for (var c = new THREE.Object3D(), d = 0, e = b.length; d < e; d++)
      c.add(new THREE.Mesh(a, b[d]));
    return c;
  },
  detach: function (a, b, c) {
    a.applyMatrix(b.matrixWorld);
    b.remove(a);
    c.add(a);
  },
  attach: function (a, b, c) {
    var d = new THREE.Matrix4();
    d.getInverse(c.matrixWorld);
    a.applyMatrix(d);
    b.remove(a);
    c.add(a);
  }
};
THREE.FontUtils = {
  faces: {},
  face: 'helvetiker',
  weight: 'normal',
  style: 'normal',
  size: 150,
  divisions: 10,
  getFace: function () {
    return this.faces[this.face][this.weight][this.style];
  },
  loadFace: function (a) {
    var b = a.familyName.toLowerCase();
    this.faces[b] = this.faces[b] || {};
    this.faces[b][a.cssFontWeight] = this.faces[b][a.cssFontWeight] || {};
    this.faces[b][a.cssFontWeight][a.cssFontStyle] = a;
    return this.faces[b][a.cssFontWeight][a.cssFontStyle] = a;
  },
  drawText: function (a) {
    var b = this.getFace(), c = this.size / b.resolution, d = 0, e = String(a).split(''), f = e.length, g = [];
    for (a = 0; a < f; a++) {
      var h = new THREE.Path(), h = this.extractGlyphPoints(e[a], b, c, d, h), d = d + h.offset;
      g.push(h.path);
    }
    return {
      paths: g,
      offset: d / 2
    };
  },
  extractGlyphPoints: function (a, b, c, d, e) {
    var f = [], g, h, k, l, n, s, r, q, u, p, v, w = b.glyphs[a] || b.glyphs['?'];
    if (w) {
      if (w.o)
        for (b = w._cachedOutline || (w._cachedOutline = w.o.split(' ')), l = b.length, a = 0; a < l;)
          switch (k = b[a++], k) {
          case 'm':
            k = b[a++] * c + d;
            n = b[a++] * c;
            e.moveTo(k, n);
            break;
          case 'l':
            k = b[a++] * c + d;
            n = b[a++] * c;
            e.lineTo(k, n);
            break;
          case 'q':
            k = b[a++] * c + d;
            n = b[a++] * c;
            q = b[a++] * c + d;
            u = b[a++] * c;
            e.quadraticCurveTo(q, u, k, n);
            if (g = f[f.length - 1])
              for (s = g.x, r = g.y, g = 1, h = this.divisions; g <= h; g++) {
                var t = g / h;
                THREE.Shape.Utils.b2(t, s, q, k);
                THREE.Shape.Utils.b2(t, r, u, n);
              }
            break;
          case 'b':
            if (k = b[a++] * c + d, n = b[a++] * c, q = b[a++] * c + d, u = b[a++] * -c, p = b[a++] * c + d, v = b[a++] * -c, e.bezierCurveTo(k, n, q, u, p, v), g = f[f.length - 1])
              for (s = g.x, r = g.y, g = 1, h = this.divisions; g <= h; g++)
                t = g / h, THREE.Shape.Utils.b3(t, s, q, p, k), THREE.Shape.Utils.b3(t, r, u, v, n);
          }
      return {
        offset: w.ha * c,
        path: e
      };
    }
  }
};
THREE.FontUtils.generateShapes = function (a, b) {
  b = b || {};
  var c = void 0 !== b.curveSegments ? b.curveSegments : 4, d = void 0 !== b.font ? b.font : 'helvetiker', e = void 0 !== b.weight ? b.weight : 'normal', f = void 0 !== b.style ? b.style : 'normal';
  THREE.FontUtils.size = void 0 !== b.size ? b.size : 100;
  THREE.FontUtils.divisions = c;
  THREE.FontUtils.face = d;
  THREE.FontUtils.weight = e;
  THREE.FontUtils.style = f;
  c = THREE.FontUtils.drawText(a).paths;
  d = [];
  e = 0;
  for (f = c.length; e < f; e++)
    Array.prototype.push.apply(d, c[e].toShapes());
  return d;
};
(function (a) {
  var b = function (a) {
    for (var b = a.length, e = 0, f = b - 1, g = 0; g < b; f = g++)
      e += a[f].x * a[g].y - a[g].x * a[f].y;
    return 0.5 * e;
  };
  a.Triangulate = function (a, d) {
    var e = a.length;
    if (3 > e)
      return null;
    var f = [], g = [], h = [], k, l, n;
    if (0 < b(a))
      for (l = 0; l < e; l++)
        g[l] = l;
    else
      for (l = 0; l < e; l++)
        g[l] = e - 1 - l;
    var s = 2 * e;
    for (l = e - 1; 2 < e;) {
      if (0 >= s--) {
        console.log('Warning, unable to triangulate polygon!');
        break;
      }
      k = l;
      e <= k && (k = 0);
      l = k + 1;
      e <= l && (l = 0);
      n = l + 1;
      e <= n && (n = 0);
      var r;
      a: {
        var q = r = void 0, u = void 0, p = void 0, v = void 0, w = void 0, t = void 0, x = void 0, z = void 0, q = a[g[k]].x, u = a[g[k]].y, p = a[g[l]].x, v = a[g[l]].y, w = a[g[n]].x, t = a[g[n]].y;
        if (1e-10 > (p - q) * (t - u) - (v - u) * (w - q))
          r = !1;
        else {
          var B = void 0, E = void 0, H = void 0, D = void 0, G = void 0, I = void 0, O = void 0, K = void 0, y = void 0, F = void 0, y = K = O = z = x = void 0, B = w - p, E = t - v, H = q - w, D = u - t, G = p - q, I = v - u;
          for (r = 0; r < e; r++)
            if (x = a[g[r]].x, z = a[g[r]].y, !(x === q && z === u || x === p && z === v || x === w && z === t) && (O = x - q, K = z - u, y = x - p, F = z - v, x -= w, z -= t, y = B * F - E * y, O = G * K - I * O, K = H * z - D * x, -1e-10 <= y && -1e-10 <= K && -1e-10 <= O)) {
              r = !1;
              break a;
            }
          r = !0;
        }
      }
      if (r) {
        f.push([
          a[g[k]],
          a[g[l]],
          a[g[n]]
        ]);
        h.push([
          g[k],
          g[l],
          g[n]
        ]);
        k = l;
        for (n = l + 1; n < e; k++, n++)
          g[k] = g[n];
        e--;
        s = 2 * e;
      }
    }
    return d ? h : f;
  };
  a.Triangulate.area = b;
  return a;
}(THREE.FontUtils));
self._typeface_js = {
  faces: THREE.FontUtils.faces,
  loadFace: THREE.FontUtils.loadFace
};
THREE.typeface_js = self._typeface_js;
THREE.Curve = function () {
};
THREE.Curve.prototype.getPoint = function (a) {
  console.log('Warning, getPoint() not implemented!');
  return null;
};
THREE.Curve.prototype.getPointAt = function (a) {
  a = this.getUtoTmapping(a);
  return this.getPoint(a);
};
THREE.Curve.prototype.getPoints = function (a) {
  a || (a = 5);
  var b, c = [];
  for (b = 0; b <= a; b++)
    c.push(this.getPoint(b / a));
  return c;
};
THREE.Curve.prototype.getSpacedPoints = function (a) {
  a || (a = 5);
  var b, c = [];
  for (b = 0; b <= a; b++)
    c.push(this.getPointAt(b / a));
  return c;
};
THREE.Curve.prototype.getLength = function () {
  var a = this.getLengths();
  return a[a.length - 1];
};
THREE.Curve.prototype.getLengths = function (a) {
  a || (a = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200);
  if (this.cacheArcLengths && this.cacheArcLengths.length == a + 1 && !this.needsUpdate)
    return this.cacheArcLengths;
  this.needsUpdate = !1;
  var b = [], c, d = this.getPoint(0), e, f = 0;
  b.push(0);
  for (e = 1; e <= a; e++)
    c = this.getPoint(e / a), f += c.distanceTo(d), b.push(f), d = c;
  return this.cacheArcLengths = b;
};
THREE.Curve.prototype.updateArcLengths = function () {
  this.needsUpdate = !0;
  this.getLengths();
};
THREE.Curve.prototype.getUtoTmapping = function (a, b) {
  var c = this.getLengths(), d = 0, e = c.length, f;
  f = b ? b : a * c[e - 1];
  for (var g = 0, h = e - 1, k; g <= h;)
    if (d = Math.floor(g + (h - g) / 2), k = c[d] - f, 0 > k)
      g = d + 1;
    else if (0 < k)
      h = d - 1;
    else {
      h = d;
      break;
    }
  d = h;
  if (c[d] == f)
    return d / (e - 1);
  g = c[d];
  return c = (d + (f - g) / (c[d + 1] - g)) / (e - 1);
};
THREE.Curve.prototype.getTangent = function (a) {
  var b = a - 0.0001;
  a += 0.0001;
  0 > b && (b = 0);
  1 < a && (a = 1);
  b = this.getPoint(b);
  return this.getPoint(a).clone().sub(b).normalize();
};
THREE.Curve.prototype.getTangentAt = function (a) {
  a = this.getUtoTmapping(a);
  return this.getTangent(a);
};
THREE.Curve.Utils = {
  tangentQuadraticBezier: function (a, b, c, d) {
    return 2 * (1 - a) * (c - b) + 2 * a * (d - c);
  },
  tangentCubicBezier: function (a, b, c, d, e) {
    return -3 * b * (1 - a) * (1 - a) + 3 * c * (1 - a) * (1 - a) - 6 * a * c * (1 - a) + 6 * a * d * (1 - a) - 3 * a * a * d + 3 * a * a * e;
  },
  tangentSpline: function (a, b, c, d, e) {
    return 6 * a * a - 6 * a + (3 * a * a - 4 * a + 1) + (-6 * a * a + 6 * a) + (3 * a * a - 2 * a);
  },
  interpolate: function (a, b, c, d, e) {
    a = 0.5 * (c - a);
    d = 0.5 * (d - b);
    var f = e * e;
    return (2 * b - 2 * c + a + d) * e * f + (-3 * b + 3 * c - 2 * a - d) * f + a * e + b;
  }
};
THREE.Curve.create = function (a, b) {
  a.prototype = Object.create(THREE.Curve.prototype);
  a.prototype.getPoint = b;
  return a;
};
THREE.CurvePath = function () {
  this.curves = [];
  this.bends = [];
  this.autoClose = !1;
};
THREE.CurvePath.prototype = Object.create(THREE.Curve.prototype);
THREE.CurvePath.prototype.add = function (a) {
  this.curves.push(a);
};
THREE.CurvePath.prototype.checkConnection = function () {
};
THREE.CurvePath.prototype.closePath = function () {
  var a = this.curves[0].getPoint(0), b = this.curves[this.curves.length - 1].getPoint(1);
  a.equals(b) || this.curves.push(new THREE.LineCurve(b, a));
};
THREE.CurvePath.prototype.getPoint = function (a) {
  var b = a * this.getLength(), c = this.getCurveLengths();
  for (a = 0; a < c.length;) {
    if (c[a] >= b)
      return b = c[a] - b, a = this.curves[a], b = 1 - b / a.getLength(), a.getPointAt(b);
    a++;
  }
  return null;
};
THREE.CurvePath.prototype.getLength = function () {
  var a = this.getCurveLengths();
  return a[a.length - 1];
};
THREE.CurvePath.prototype.getCurveLengths = function () {
  if (this.cacheLengths && this.cacheLengths.length == this.curves.length)
    return this.cacheLengths;
  var a = [], b = 0, c, d = this.curves.length;
  for (c = 0; c < d; c++)
    b += this.curves[c].getLength(), a.push(b);
  return this.cacheLengths = a;
};
THREE.CurvePath.prototype.getBoundingBox = function () {
  var a = this.getPoints(), b, c, d, e, f, g;
  b = c = Number.NEGATIVE_INFINITY;
  e = f = Number.POSITIVE_INFINITY;
  var h, k, l, n, s = a[0] instanceof THREE.Vector3;
  n = s ? new THREE.Vector3() : new THREE.Vector2();
  k = 0;
  for (l = a.length; k < l; k++)
    h = a[k], h.x > b ? b = h.x : h.x < e && (e = h.x), h.y > c ? c = h.y : h.y < f && (f = h.y), s && (h.z > d ? d = h.z : h.z < g && (g = h.z)), n.add(h);
  a = {
    minX: e,
    minY: f,
    maxX: b,
    maxY: c,
    centroid: n.divideScalar(l)
  };
  s && (a.maxZ = d, a.minZ = g);
  return a;
};
THREE.CurvePath.prototype.createPointsGeometry = function (a) {
  a = this.getPoints(a, !0);
  return this.createGeometry(a);
};
THREE.CurvePath.prototype.createSpacedPointsGeometry = function (a) {
  a = this.getSpacedPoints(a, !0);
  return this.createGeometry(a);
};
THREE.CurvePath.prototype.createGeometry = function (a) {
  for (var b = new THREE.Geometry(), c = 0; c < a.length; c++)
    b.vertices.push(new THREE.Vector3(a[c].x, a[c].y, a[c].z || 0));
  return b;
};
THREE.CurvePath.prototype.addWrapPath = function (a) {
  this.bends.push(a);
};
THREE.CurvePath.prototype.getTransformedPoints = function (a, b) {
  var c = this.getPoints(a), d, e;
  b || (b = this.bends);
  d = 0;
  for (e = b.length; d < e; d++)
    c = this.getWrapPoints(c, b[d]);
  return c;
};
THREE.CurvePath.prototype.getTransformedSpacedPoints = function (a, b) {
  var c = this.getSpacedPoints(a), d, e;
  b || (b = this.bends);
  d = 0;
  for (e = b.length; d < e; d++)
    c = this.getWrapPoints(c, b[d]);
  return c;
};
THREE.CurvePath.prototype.getWrapPoints = function (a, b) {
  var c = this.getBoundingBox(), d, e, f, g, h, k;
  d = 0;
  for (e = a.length; d < e; d++)
    f = a[d], g = f.x, h = f.y, k = g / c.maxX, k = b.getUtoTmapping(k, g), g = b.getPoint(k), k = b.getTangent(k), k.set(-k.y, k.x).multiplyScalar(h), f.x = g.x + k.x, f.y = g.y + k.y;
  return a;
};
THREE.Gyroscope = function () {
  THREE.Object3D.call(this);
};
THREE.Gyroscope.prototype = Object.create(THREE.Object3D.prototype);
THREE.Gyroscope.prototype.updateMatrixWorld = function (a) {
  this.matrixAutoUpdate && this.updateMatrix();
  if (this.matrixWorldNeedsUpdate || a)
    this.parent ? (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorld.decompose(this.translationWorld, this.quaternionWorld, this.scaleWorld), this.matrix.decompose(this.translationObject, this.quaternionObject, this.scaleObject), this.matrixWorld.compose(this.translationWorld, this.quaternionObject, this.scaleWorld)) : this.matrixWorld.copy(this.matrix), this.matrixWorldNeedsUpdate = !1, a = !0;
  for (var b = 0, c = this.children.length; b < c; b++)
    this.children[b].updateMatrixWorld(a);
};
THREE.Gyroscope.prototype.translationWorld = new THREE.Vector3();
THREE.Gyroscope.prototype.translationObject = new THREE.Vector3();
THREE.Gyroscope.prototype.quaternionWorld = new THREE.Quaternion();
THREE.Gyroscope.prototype.quaternionObject = new THREE.Quaternion();
THREE.Gyroscope.prototype.scaleWorld = new THREE.Vector3();
THREE.Gyroscope.prototype.scaleObject = new THREE.Vector3();
THREE.Path = function (a) {
  THREE.CurvePath.call(this);
  this.actions = [];
  a && this.fromPoints(a);
};
THREE.Path.prototype = Object.create(THREE.CurvePath.prototype);
THREE.PathActions = {
  MOVE_TO: 'moveTo',
  LINE_TO: 'lineTo',
  QUADRATIC_CURVE_TO: 'quadraticCurveTo',
  BEZIER_CURVE_TO: 'bezierCurveTo',
  CSPLINE_THRU: 'splineThru',
  ARC: 'arc',
  ELLIPSE: 'ellipse'
};
THREE.Path.prototype.fromPoints = function (a) {
  this.moveTo(a[0].x, a[0].y);
  for (var b = 1, c = a.length; b < c; b++)
    this.lineTo(a[b].x, a[b].y);
};
THREE.Path.prototype.moveTo = function (a, b) {
  var c = Array.prototype.slice.call(arguments);
  this.actions.push({
    action: THREE.PathActions.MOVE_TO,
    args: c
  });
};
THREE.Path.prototype.lineTo = function (a, b) {
  var c = Array.prototype.slice.call(arguments), d = this.actions[this.actions.length - 1].args, d = new THREE.LineCurve(new THREE.Vector2(d[d.length - 2], d[d.length - 1]), new THREE.Vector2(a, b));
  this.curves.push(d);
  this.actions.push({
    action: THREE.PathActions.LINE_TO,
    args: c
  });
};
THREE.Path.prototype.quadraticCurveTo = function (a, b, c, d) {
  var e = Array.prototype.slice.call(arguments), f = this.actions[this.actions.length - 1].args, f = new THREE.QuadraticBezierCurve(new THREE.Vector2(f[f.length - 2], f[f.length - 1]), new THREE.Vector2(a, b), new THREE.Vector2(c, d));
  this.curves.push(f);
  this.actions.push({
    action: THREE.PathActions.QUADRATIC_CURVE_TO,
    args: e
  });
};
THREE.Path.prototype.bezierCurveTo = function (a, b, c, d, e, f) {
  var g = Array.prototype.slice.call(arguments), h = this.actions[this.actions.length - 1].args, h = new THREE.CubicBezierCurve(new THREE.Vector2(h[h.length - 2], h[h.length - 1]), new THREE.Vector2(a, b), new THREE.Vector2(c, d), new THREE.Vector2(e, f));
  this.curves.push(h);
  this.actions.push({
    action: THREE.PathActions.BEZIER_CURVE_TO,
    args: g
  });
};
THREE.Path.prototype.splineThru = function (a) {
  var b = Array.prototype.slice.call(arguments), c = this.actions[this.actions.length - 1].args, c = [new THREE.Vector2(c[c.length - 2], c[c.length - 1])];
  Array.prototype.push.apply(c, a);
  c = new THREE.SplineCurve(c);
  this.curves.push(c);
  this.actions.push({
    action: THREE.PathActions.CSPLINE_THRU,
    args: b
  });
};
THREE.Path.prototype.arc = function (a, b, c, d, e, f) {
  var g = this.actions[this.actions.length - 1].args;
  this.absarc(a + g[g.length - 2], b + g[g.length - 1], c, d, e, f);
};
THREE.Path.prototype.absarc = function (a, b, c, d, e, f) {
  this.absellipse(a, b, c, c, d, e, f);
};
THREE.Path.prototype.ellipse = function (a, b, c, d, e, f, g) {
  var h = this.actions[this.actions.length - 1].args;
  this.absellipse(a + h[h.length - 2], b + h[h.length - 1], c, d, e, f, g);
};
THREE.Path.prototype.absellipse = function (a, b, c, d, e, f, g) {
  var h = Array.prototype.slice.call(arguments), k = new THREE.EllipseCurve(a, b, c, d, e, f, g);
  this.curves.push(k);
  k = k.getPoint(1);
  h.push(k.x);
  h.push(k.y);
  this.actions.push({
    action: THREE.PathActions.ELLIPSE,
    args: h
  });
};
THREE.Path.prototype.getSpacedPoints = function (a, b) {
  a || (a = 40);
  for (var c = [], d = 0; d < a; d++)
    c.push(this.getPoint(d / a));
  return c;
};
THREE.Path.prototype.getPoints = function (a, b) {
  if (this.useSpacedPoints)
    return console.log('tata'), this.getSpacedPoints(a, b);
  a = a || 12;
  var c = [], d, e, f, g, h, k, l, n, s, r, q, u, p;
  d = 0;
  for (e = this.actions.length; d < e; d++)
    switch (f = this.actions[d], g = f.action, f = f.args, g) {
    case THREE.PathActions.MOVE_TO:
      c.push(new THREE.Vector2(f[0], f[1]));
      break;
    case THREE.PathActions.LINE_TO:
      c.push(new THREE.Vector2(f[0], f[1]));
      break;
    case THREE.PathActions.QUADRATIC_CURVE_TO:
      h = f[2];
      k = f[3];
      s = f[0];
      r = f[1];
      0 < c.length ? (g = c[c.length - 1], q = g.x, u = g.y) : (g = this.actions[d - 1].args, q = g[g.length - 2], u = g[g.length - 1]);
      for (f = 1; f <= a; f++)
        p = f / a, g = THREE.Shape.Utils.b2(p, q, s, h), p = THREE.Shape.Utils.b2(p, u, r, k), c.push(new THREE.Vector2(g, p));
      break;
    case THREE.PathActions.BEZIER_CURVE_TO:
      h = f[4];
      k = f[5];
      s = f[0];
      r = f[1];
      l = f[2];
      n = f[3];
      0 < c.length ? (g = c[c.length - 1], q = g.x, u = g.y) : (g = this.actions[d - 1].args, q = g[g.length - 2], u = g[g.length - 1]);
      for (f = 1; f <= a; f++)
        p = f / a, g = THREE.Shape.Utils.b3(p, q, s, l, h), p = THREE.Shape.Utils.b3(p, u, r, n, k), c.push(new THREE.Vector2(g, p));
      break;
    case THREE.PathActions.CSPLINE_THRU:
      g = this.actions[d - 1].args;
      p = [new THREE.Vector2(g[g.length - 2], g[g.length - 1])];
      g = a * f[0].length;
      p = p.concat(f[0]);
      p = new THREE.SplineCurve(p);
      for (f = 1; f <= g; f++)
        c.push(p.getPointAt(f / g));
      break;
    case THREE.PathActions.ARC:
      h = f[0];
      k = f[1];
      r = f[2];
      l = f[3];
      g = f[4];
      s = !!f[5];
      q = g - l;
      u = 2 * a;
      for (f = 1; f <= u; f++)
        p = f / u, s || (p = 1 - p), p = l + p * q, g = h + r * Math.cos(p), p = k + r * Math.sin(p), c.push(new THREE.Vector2(g, p));
      break;
    case THREE.PathActions.ELLIPSE:
      for (h = f[0], k = f[1], r = f[2], n = f[3], l = f[4], g = f[5], s = !!f[6], q = g - l, u = 2 * a, f = 1; f <= u; f++)
        p = f / u, s || (p = 1 - p), p = l + p * q, g = h + r * Math.cos(p), p = k + n * Math.sin(p), c.push(new THREE.Vector2(g, p));
    }
  d = c[c.length - 1];
  1e-10 > Math.abs(d.x - c[0].x) && 1e-10 > Math.abs(d.y - c[0].y) && c.splice(c.length - 1, 1);
  b && c.push(c[0]);
  return c;
};
THREE.Path.prototype.toShapes = function (a) {
  function b(a, b) {
    for (var c = b.length, d = !1, e = c - 1, f = 0; f < c; e = f++) {
      var g = b[e], h = b[f], k = h.x - g.x, l = h.y - g.y;
      if (1e-10 < Math.abs(l)) {
        if (0 > l && (g = b[f], k = -k, h = b[e], l = -l), !(a.y < g.y || a.y > h.y))
          if (a.y == g.y) {
            if (a.x == g.x)
              return !0;
          } else {
            e = l * (a.x - g.x) - k * (a.y - g.y);
            if (0 == e)
              return !0;
            0 > e || (d = !d);
          }
      } else if (a.y == g.y && (h.x <= a.x && a.x <= g.x || g.x <= a.x && a.x <= h.x))
        return !0;
    }
    return d;
  }
  var c, d, e, f, g = [], h = new THREE.Path();
  c = 0;
  for (d = this.actions.length; c < d; c++)
    e = this.actions[c], f = e.args, e = e.action, e == THREE.PathActions.MOVE_TO && 0 != h.actions.length && (g.push(h), h = new THREE.Path()), h[e].apply(h, f);
  0 != h.actions.length && g.push(h);
  if (0 == g.length)
    return [];
  var k, l, n;
  f = [];
  if (1 == g.length)
    return l = g[0], n = new THREE.Shape(), n.actions = l.actions, n.curves = l.curves, f.push(n), f;
  var s = !THREE.Shape.Utils.isClockWise(g[0].getPoints()), s = a ? !s : s;
  n = [];
  h = [];
  e = [];
  var r = 0, q;
  h[r] = void 0;
  e[r] = [];
  c = 0;
  for (d = g.length; c < d; c++)
    l = g[c], q = l.getPoints(), k = THREE.Shape.Utils.isClockWise(q), (k = a ? !k : k) ? (!s && h[r] && r++, h[r] = {
      s: new THREE.Shape(),
      p: q
    }, h[r].s.actions = l.actions, h[r].s.curves = l.curves, s && r++, e[r] = []) : e[r].push({
      h: l,
      p: q[0]
    });
  if (1 < h.length) {
    c = !1;
    d = [];
    a = 0;
    for (g = h.length; a < g; a++)
      n[a] = [];
    a = 0;
    for (g = h.length; a < g; a++)
      for (l = e[a], k = 0; k < l.length; k++) {
        s = l[k];
        r = !0;
        for (q = 0; q < h.length; q++)
          b(s.p, h[q].p) && (a != q && d.push({
            froms: a,
            tos: q,
            hole: k
          }), r ? (r = !1, n[q].push(s)) : c = !0);
        r && n[a].push(s);
      }
    0 < d.length && (c || (e = n));
  }
  c = 0;
  for (d = h.length; c < d; c++)
    for (n = h[c].s, f.push(n), a = e[c], g = 0, l = a.length; g < l; g++)
      n.holes.push(a[g].h);
  return f;
};
THREE.Shape = function () {
  THREE.Path.apply(this, arguments);
  this.holes = [];
};
THREE.Shape.prototype = Object.create(THREE.Path.prototype);
THREE.Shape.prototype.extrude = function (a) {
  return new THREE.ExtrudeGeometry(this, a);
};
THREE.Shape.prototype.makeGeometry = function (a) {
  return new THREE.ShapeGeometry(this, a);
};
THREE.Shape.prototype.getPointsHoles = function (a) {
  var b, c = this.holes.length, d = [];
  for (b = 0; b < c; b++)
    d[b] = this.holes[b].getTransformedPoints(a, this.bends);
  return d;
};
THREE.Shape.prototype.getSpacedPointsHoles = function (a) {
  var b, c = this.holes.length, d = [];
  for (b = 0; b < c; b++)
    d[b] = this.holes[b].getTransformedSpacedPoints(a, this.bends);
  return d;
};
THREE.Shape.prototype.extractAllPoints = function (a) {
  return {
    shape: this.getTransformedPoints(a),
    holes: this.getPointsHoles(a)
  };
};
THREE.Shape.prototype.extractPoints = function (a) {
  return this.useSpacedPoints ? this.extractAllSpacedPoints(a) : this.extractAllPoints(a);
};
THREE.Shape.prototype.extractAllSpacedPoints = function (a) {
  return {
    shape: this.getTransformedSpacedPoints(a),
    holes: this.getSpacedPointsHoles(a)
  };
};
THREE.Shape.Utils = {
  triangulateShape: function (a, b) {
    function c(a, b, c) {
      return a.x != b.x ? a.x < b.x ? a.x <= c.x && c.x <= b.x : b.x <= c.x && c.x <= a.x : a.y < b.y ? a.y <= c.y && c.y <= b.y : b.y <= c.y && c.y <= a.y;
    }
    function d(a, b, d, e, f) {
      var g = b.x - a.x, h = b.y - a.y, k = e.x - d.x, l = e.y - d.y, n = a.x - d.x, s = a.y - d.y, H = h * k - g * l, D = h * n - g * s;
      if (1e-10 < Math.abs(H)) {
        if (0 < H) {
          if (0 > D || D > H)
            return [];
          k = l * n - k * s;
          if (0 > k || k > H)
            return [];
        } else {
          if (0 < D || D < H)
            return [];
          k = l * n - k * s;
          if (0 < k || k < H)
            return [];
        }
        if (0 == k)
          return !f || 0 != D && D != H ? [a] : [];
        if (k == H)
          return !f || 0 != D && D != H ? [b] : [];
        if (0 == D)
          return [d];
        if (D == H)
          return [e];
        f = k / H;
        return [{
            x: a.x + f * g,
            y: a.y + f * h
          }];
      }
      if (0 != D || l * n != k * s)
        return [];
      h = 0 == g && 0 == h;
      k = 0 == k && 0 == l;
      if (h && k)
        return a.x != d.x || a.y != d.y ? [] : [a];
      if (h)
        return c(d, e, a) ? [a] : [];
      if (k)
        return c(a, b, d) ? [d] : [];
      0 != g ? (a.x < b.x ? (g = a, k = a.x, h = b, a = b.x) : (g = b, k = b.x, h = a, a = a.x), d.x < e.x ? (b = d, H = d.x, l = e, d = e.x) : (b = e, H = e.x, l = d, d = d.x)) : (a.y < b.y ? (g = a, k = a.y, h = b, a = b.y) : (g = b, k = b.y, h = a, a = a.y), d.y < e.y ? (b = d, H = d.y, l = e, d = e.y) : (b = e, H = e.y, l = d, d = d.y));
      return k <= H ? a < H ? [] : a == H ? f ? [] : [b] : a <= d ? [
        b,
        h
      ] : [
        b,
        l
      ] : k > d ? [] : k == d ? f ? [] : [g] : a <= d ? [
        g,
        h
      ] : [
        g,
        l
      ];
    }
    function e(a, b, c, d) {
      var e = b.x - a.x, f = b.y - a.y;
      b = c.x - a.x;
      c = c.y - a.y;
      var g = d.x - a.x;
      d = d.y - a.y;
      a = e * c - f * b;
      e = e * d - f * g;
      return 1e-10 < Math.abs(a) ? (b = g * c - d * b, 0 < a ? 0 <= e && 0 <= b : 0 <= e || 0 <= b) : 0 < e;
    }
    var f, g, h, k, l, n = {};
    h = a.concat();
    f = 0;
    for (g = b.length; f < g; f++)
      Array.prototype.push.apply(h, b[f]);
    f = 0;
    for (g = h.length; f < g; f++)
      l = h[f].x + ':' + h[f].y, void 0 !== n[l] && console.log('Duplicate point', l), n[l] = f;
    f = function (a, b) {
      function c(a, b) {
        var d = h.length - 1, f = a - 1;
        0 > f && (f = d);
        var g = a + 1;
        g > d && (g = 0);
        d = e(h[a], h[f], h[g], k[b]);
        if (!d)
          return !1;
        d = k.length - 1;
        f = b - 1;
        0 > f && (f = d);
        g = b + 1;
        g > d && (g = 0);
        return (d = e(k[b], k[f], k[g], h[a])) ? !0 : !1;
      }
      function f(a, b) {
        var c, e;
        for (c = 0; c < h.length; c++)
          if (e = c + 1, e %= h.length, e = d(a, b, h[c], h[e], !0), 0 < e.length)
            return !0;
        return !1;
      }
      function g(a, c) {
        var e, f, h, k;
        for (e = 0; e < l.length; e++)
          for (f = b[l[e]], h = 0; h < f.length; h++)
            if (k = h + 1, k %= f.length, k = d(a, c, f[h], f[k], !0), 0 < k.length)
              return !0;
        return !1;
      }
      var h = a.concat(), k, l = [], n, s, E, H, D, G = [], I, O, K, y = 0;
      for (n = b.length; y < n; y++)
        l.push(y);
      for (var F = 2 * l.length; 0 < l.length;) {
        F--;
        if (0 > F) {
          console.log('Infinite Loop! Holes left:' + l.length + ', Probably Hole outside Shape!');
          break;
        }
        for (s = 0; s < h.length; s++) {
          E = h[s];
          n = -1;
          for (y = 0; y < l.length; y++)
            if (H = l[y], D = E.x + ':' + E.y + ':' + H, void 0 === G[D]) {
              k = b[H];
              for (I = 0; I < k.length; I++)
                if (H = k[I], c(s, I) && !f(E, H) && !g(E, H)) {
                  n = I;
                  l.splice(y, 1);
                  H = h.slice(0, s + 1);
                  I = h.slice(s);
                  O = k.slice(n);
                  K = k.slice(0, n + 1);
                  h = H.concat(O).concat(K).concat(I);
                  break;
                }
              if (0 <= n)
                break;
              G[D] = !0;
            }
          if (0 <= n)
            break;
        }
      }
      return h;
    }(a, b);
    var s = THREE.FontUtils.Triangulate(f, !1);
    f = 0;
    for (g = s.length; f < g; f++)
      for (k = s[f], h = 0; 3 > h; h++)
        l = k[h].x + ':' + k[h].y, l = n[l], void 0 !== l && (k[h] = l);
    return s.concat();
  },
  isClockWise: function (a) {
    return 0 > THREE.FontUtils.Triangulate.area(a);
  },
  b2p0: function (a, b) {
    var c = 1 - a;
    return c * c * b;
  },
  b2p1: function (a, b) {
    return 2 * (1 - a) * a * b;
  },
  b2p2: function (a, b) {
    return a * a * b;
  },
  b2: function (a, b, c, d) {
    return this.b2p0(a, b) + this.b2p1(a, c) + this.b2p2(a, d);
  },
  b3p0: function (a, b) {
    var c = 1 - a;
    return c * c * c * b;
  },
  b3p1: function (a, b) {
    var c = 1 - a;
    return 3 * c * c * a * b;
  },
  b3p2: function (a, b) {
    return 3 * (1 - a) * a * a * b;
  },
  b3p3: function (a, b) {
    return a * a * a * b;
  },
  b3: function (a, b, c, d, e) {
    return this.b3p0(a, b) + this.b3p1(a, c) + this.b3p2(a, d) + this.b3p3(a, e);
  }
};
THREE.LineCurve = function (a, b) {
  this.v1 = a;
  this.v2 = b;
};
THREE.LineCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.LineCurve.prototype.getPoint = function (a) {
  var b = this.v2.clone().sub(this.v1);
  b.multiplyScalar(a).add(this.v1);
  return b;
};
THREE.LineCurve.prototype.getPointAt = function (a) {
  return this.getPoint(a);
};
THREE.LineCurve.prototype.getTangent = function (a) {
  return this.v2.clone().sub(this.v1).normalize();
};
THREE.QuadraticBezierCurve = function (a, b, c) {
  this.v0 = a;
  this.v1 = b;
  this.v2 = c;
};
THREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.QuadraticBezierCurve.prototype.getPoint = function (a) {
  var b;
  b = THREE.Shape.Utils.b2(a, this.v0.x, this.v1.x, this.v2.x);
  a = THREE.Shape.Utils.b2(a, this.v0.y, this.v1.y, this.v2.y);
  return new THREE.Vector2(b, a);
};
THREE.QuadraticBezierCurve.prototype.getTangent = function (a) {
  var b;
  b = THREE.Curve.Utils.tangentQuadraticBezier(a, this.v0.x, this.v1.x, this.v2.x);
  a = THREE.Curve.Utils.tangentQuadraticBezier(a, this.v0.y, this.v1.y, this.v2.y);
  b = new THREE.Vector2(b, a);
  b.normalize();
  return b;
};
THREE.CubicBezierCurve = function (a, b, c, d) {
  this.v0 = a;
  this.v1 = b;
  this.v2 = c;
  this.v3 = d;
};
THREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.CubicBezierCurve.prototype.getPoint = function (a) {
  var b;
  b = THREE.Shape.Utils.b3(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x);
  a = THREE.Shape.Utils.b3(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
  return new THREE.Vector2(b, a);
};
THREE.CubicBezierCurve.prototype.getTangent = function (a) {
  var b;
  b = THREE.Curve.Utils.tangentCubicBezier(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x);
  a = THREE.Curve.Utils.tangentCubicBezier(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
  b = new THREE.Vector2(b, a);
  b.normalize();
  return b;
};
THREE.SplineCurve = function (a) {
  this.points = void 0 == a ? [] : a;
};
THREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.SplineCurve.prototype.getPoint = function (a) {
  var b = new THREE.Vector2(), c = [], d = this.points, e;
  e = (d.length - 1) * a;
  a = Math.floor(e);
  e -= a;
  c[0] = 0 == a ? a : a - 1;
  c[1] = a;
  c[2] = a > d.length - 2 ? d.length - 1 : a + 1;
  c[3] = a > d.length - 3 ? d.length - 1 : a + 2;
  b.x = THREE.Curve.Utils.interpolate(d[c[0]].x, d[c[1]].x, d[c[2]].x, d[c[3]].x, e);
  b.y = THREE.Curve.Utils.interpolate(d[c[0]].y, d[c[1]].y, d[c[2]].y, d[c[3]].y, e);
  return b;
};
THREE.EllipseCurve = function (a, b, c, d, e, f, g) {
  this.aX = a;
  this.aY = b;
  this.xRadius = c;
  this.yRadius = d;
  this.aStartAngle = e;
  this.aEndAngle = f;
  this.aClockwise = g;
};
THREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.EllipseCurve.prototype.getPoint = function (a) {
  var b;
  b = this.aEndAngle - this.aStartAngle;
  0 > b && (b += 2 * Math.PI);
  b > 2 * Math.PI && (b -= 2 * Math.PI);
  b = !0 === this.aClockwise ? this.aEndAngle + (1 - a) * (2 * Math.PI - b) : this.aStartAngle + a * b;
  a = this.aX + this.xRadius * Math.cos(b);
  b = this.aY + this.yRadius * Math.sin(b);
  return new THREE.Vector2(a, b);
};
THREE.ArcCurve = function (a, b, c, d, e, f) {
  THREE.EllipseCurve.call(this, a, b, c, c, d, e, f);
};
THREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype);
THREE.LineCurve3 = THREE.Curve.create(function (a, b) {
  this.v1 = a;
  this.v2 = b;
}, function (a) {
  var b = new THREE.Vector3();
  b.subVectors(this.v2, this.v1);
  b.multiplyScalar(a);
  b.add(this.v1);
  return b;
});
THREE.QuadraticBezierCurve3 = THREE.Curve.create(function (a, b, c) {
  this.v0 = a;
  this.v1 = b;
  this.v2 = c;
}, function (a) {
  var b, c;
  b = THREE.Shape.Utils.b2(a, this.v0.x, this.v1.x, this.v2.x);
  c = THREE.Shape.Utils.b2(a, this.v0.y, this.v1.y, this.v2.y);
  a = THREE.Shape.Utils.b2(a, this.v0.z, this.v1.z, this.v2.z);
  return new THREE.Vector3(b, c, a);
});
THREE.CubicBezierCurve3 = THREE.Curve.create(function (a, b, c, d) {
  this.v0 = a;
  this.v1 = b;
  this.v2 = c;
  this.v3 = d;
}, function (a) {
  var b, c;
  b = THREE.Shape.Utils.b3(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x);
  c = THREE.Shape.Utils.b3(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
  a = THREE.Shape.Utils.b3(a, this.v0.z, this.v1.z, this.v2.z, this.v3.z);
  return new THREE.Vector3(b, c, a);
});
THREE.SplineCurve3 = THREE.Curve.create(function (a) {
  this.points = void 0 == a ? [] : a;
}, function (a) {
  var b = new THREE.Vector3(), c = [], d = this.points, e;
  a *= d.length - 1;
  e = Math.floor(a);
  a -= e;
  c[0] = 0 == e ? e : e - 1;
  c[1] = e;
  c[2] = e > d.length - 2 ? d.length - 1 : e + 1;
  c[3] = e > d.length - 3 ? d.length - 1 : e + 2;
  e = d[c[0]];
  var f = d[c[1]], g = d[c[2]], c = d[c[3]];
  b.x = THREE.Curve.Utils.interpolate(e.x, f.x, g.x, c.x, a);
  b.y = THREE.Curve.Utils.interpolate(e.y, f.y, g.y, c.y, a);
  b.z = THREE.Curve.Utils.interpolate(e.z, f.z, g.z, c.z, a);
  return b;
});
THREE.ClosedSplineCurve3 = THREE.Curve.create(function (a) {
  this.points = void 0 == a ? [] : a;
}, function (a) {
  var b = new THREE.Vector3(), c = [], d = this.points, e;
  e = (d.length - 0) * a;
  a = Math.floor(e);
  e -= a;
  a += 0 < a ? 0 : (Math.floor(Math.abs(a) / d.length) + 1) * d.length;
  c[0] = (a - 1) % d.length;
  c[1] = a % d.length;
  c[2] = (a + 1) % d.length;
  c[3] = (a + 2) % d.length;
  b.x = THREE.Curve.Utils.interpolate(d[c[0]].x, d[c[1]].x, d[c[2]].x, d[c[3]].x, e);
  b.y = THREE.Curve.Utils.interpolate(d[c[0]].y, d[c[1]].y, d[c[2]].y, d[c[3]].y, e);
  b.z = THREE.Curve.Utils.interpolate(d[c[0]].z, d[c[1]].z, d[c[2]].z, d[c[3]].z, e);
  return b;
});
THREE.AnimationHandler = function () {
  var a = [], b = {}, c = {
      update: function (b) {
        for (var c = 0; c < a.length; c++)
          a[c].update(b);
      },
      addToUpdate: function (b) {
        -1 === a.indexOf(b) && a.push(b);
      },
      removeFromUpdate: function (b) {
        b = a.indexOf(b);
        -1 !== b && a.splice(b, 1);
      },
      add: function (a) {
        void 0 !== b[a.name] && console.log('THREE.AnimationHandler.add: Warning! ' + a.name + ' already exists in library. Overwriting.');
        b[a.name] = a;
        if (!0 !== a.initialized) {
          for (var c = 0; c < a.hierarchy.length; c++) {
            for (var d = 0; d < a.hierarchy[c].keys.length; d++)
              if (0 > a.hierarchy[c].keys[d].time && (a.hierarchy[c].keys[d].time = 0), void 0 !== a.hierarchy[c].keys[d].rot && !(a.hierarchy[c].keys[d].rot instanceof THREE.Quaternion)) {
                var h = a.hierarchy[c].keys[d].rot;
                a.hierarchy[c].keys[d].rot = new THREE.Quaternion(h[0], h[1], h[2], h[3]);
              }
            if (a.hierarchy[c].keys.length && void 0 !== a.hierarchy[c].keys[0].morphTargets) {
              h = {};
              for (d = 0; d < a.hierarchy[c].keys.length; d++)
                for (var k = 0; k < a.hierarchy[c].keys[d].morphTargets.length; k++) {
                  var l = a.hierarchy[c].keys[d].morphTargets[k];
                  h[l] = -1;
                }
              a.hierarchy[c].usedMorphTargets = h;
              for (d = 0; d < a.hierarchy[c].keys.length; d++) {
                var n = {};
                for (l in h) {
                  for (k = 0; k < a.hierarchy[c].keys[d].morphTargets.length; k++)
                    if (a.hierarchy[c].keys[d].morphTargets[k] === l) {
                      n[l] = a.hierarchy[c].keys[d].morphTargetsInfluences[k];
                      break;
                    }
                  k === a.hierarchy[c].keys[d].morphTargets.length && (n[l] = 0);
                }
                a.hierarchy[c].keys[d].morphTargetsInfluences = n;
              }
            }
            for (d = 1; d < a.hierarchy[c].keys.length; d++)
              a.hierarchy[c].keys[d].time === a.hierarchy[c].keys[d - 1].time && (a.hierarchy[c].keys.splice(d, 1), d--);
            for (d = 0; d < a.hierarchy[c].keys.length; d++)
              a.hierarchy[c].keys[d].index = d;
          }
          a.initialized = !0;
        }
      },
      get: function (a) {
        if ('string' === typeof a) {
          if (b[a])
            return b[a];
          console.log('THREE.AnimationHandler.get: Couldn\'t find animation ' + a);
          return null;
        }
      },
      parse: function (a) {
        var b = [];
        if (a instanceof THREE.SkinnedMesh)
          for (var c = 0; c < a.bones.length; c++)
            b.push(a.bones[c]);
        else
          d(a, b);
        return b;
      }
    }, d = function (a, b) {
      b.push(a);
      for (var c = 0; c < a.children.length; c++)
        d(a.children[c], b);
    };
  c.LINEAR = 0;
  c.CATMULLROM = 1;
  c.CATMULLROM_FORWARD = 2;
  return c;
}();
THREE.Animation = function (a, b) {
  this.root = a;
  this.data = THREE.AnimationHandler.get(b);
  this.hierarchy = THREE.AnimationHandler.parse(a);
  this.currentTime = 0;
  this.timeScale = 1;
  this.isPlaying = !1;
  this.loop = this.isPaused = !0;
  this.interpolationType = THREE.AnimationHandler.LINEAR;
};
THREE.Animation.prototype.play = function (a) {
  this.currentTime = void 0 !== a ? a : 0;
  !1 === this.isPlaying && (this.isPlaying = !0, this.reset(), this.update(0));
  this.isPaused = !1;
  THREE.AnimationHandler.addToUpdate(this);
};
THREE.Animation.prototype.pause = function () {
  !0 === this.isPaused ? THREE.AnimationHandler.addToUpdate(this) : THREE.AnimationHandler.removeFromUpdate(this);
  this.isPaused = !this.isPaused;
};
THREE.Animation.prototype.stop = function () {
  this.isPaused = this.isPlaying = !1;
  THREE.AnimationHandler.removeFromUpdate(this);
};
THREE.Animation.prototype.reset = function () {
  for (var a = 0, b = this.hierarchy.length; a < b; a++) {
    var c = this.hierarchy[a];
    c.matrixAutoUpdate = !0;
    void 0 === c.animationCache && (c.animationCache = {}, c.animationCache.prevKey = {
      pos: 0,
      rot: 0,
      scl: 0
    }, c.animationCache.nextKey = {
      pos: 0,
      rot: 0,
      scl: 0
    }, c.animationCache.originalMatrix = c instanceof THREE.Bone ? c.skinMatrix : c.matrix);
    var d = c.animationCache.prevKey, c = c.animationCache.nextKey;
    d.pos = this.data.hierarchy[a].keys[0];
    d.rot = this.data.hierarchy[a].keys[0];
    d.scl = this.data.hierarchy[a].keys[0];
    c.pos = this.getNextKeyWith('pos', a, 1);
    c.rot = this.getNextKeyWith('rot', a, 1);
    c.scl = this.getNextKeyWith('scl', a, 1);
  }
};
THREE.Animation.prototype.update = function () {
  var a = [], b = new THREE.Vector3(), c = function (a, b) {
      var c = [], h = [], k, l, n, s, r, q;
      k = (a.length - 1) * b;
      l = Math.floor(k);
      k -= l;
      c[0] = 0 === l ? l : l - 1;
      c[1] = l;
      c[2] = l > a.length - 2 ? l : l + 1;
      c[3] = l > a.length - 3 ? l : l + 2;
      l = a[c[0]];
      s = a[c[1]];
      r = a[c[2]];
      q = a[c[3]];
      c = k * k;
      n = k * c;
      h[0] = d(l[0], s[0], r[0], q[0], k, c, n);
      h[1] = d(l[1], s[1], r[1], q[1], k, c, n);
      h[2] = d(l[2], s[2], r[2], q[2], k, c, n);
      return h;
    }, d = function (a, b, c, d, k, l, n) {
      a = 0.5 * (c - a);
      d = 0.5 * (d - b);
      return (2 * (b - c) + a + d) * n + (-3 * (b - c) - 2 * a - d) * l + a * k + b;
    };
  return function (d) {
    if (!1 !== this.isPlaying) {
      this.currentTime += d * this.timeScale;
      var f;
      d = [
        'pos',
        'rot',
        'scl'
      ];
      var g = this.data.length;
      if (!0 === this.loop && this.currentTime > g)
        this.currentTime %= g, this.reset();
      else if (!1 === this.loop && this.currentTime > g) {
        this.stop();
        return;
      }
      this.currentTime = Math.min(this.currentTime, g);
      for (var g = 0, h = this.hierarchy.length; g < h; g++)
        for (var k = this.hierarchy[g], l = k.animationCache, n = 0; 3 > n; n++) {
          f = d[n];
          var s = l.prevKey[f], r = l.nextKey[f];
          if (r.time <= this.currentTime) {
            s = this.data.hierarchy[g].keys[0];
            for (r = this.getNextKeyWith(f, g, 1); r.time < this.currentTime && r.index > s.index;)
              s = r, r = this.getNextKeyWith(f, g, r.index + 1);
            l.prevKey[f] = s;
            l.nextKey[f] = r;
          }
          k.matrixAutoUpdate = !0;
          k.matrixWorldNeedsUpdate = !0;
          var q = (this.currentTime - s.time) / (r.time - s.time), u = s[f], p = r[f];
          0 > q && (q = 0);
          1 < q && (q = 1);
          if ('pos' === f)
            if (f = k.position, this.interpolationType === THREE.AnimationHandler.LINEAR)
              f.x = u[0] + (p[0] - u[0]) * q, f.y = u[1] + (p[1] - u[1]) * q, f.z = u[2] + (p[2] - u[2]) * q;
            else {
              if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD)
                a[0] = this.getPrevKeyWith('pos', g, s.index - 1).pos, a[1] = u, a[2] = p, a[3] = this.getNextKeyWith('pos', g, r.index + 1).pos, q = 0.33 * q + 0.33, s = c(a, q), f.x = s[0], f.y = s[1], f.z = s[2], this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD && (q = c(a, 1.01 * q), b.set(q[0], q[1], q[2]), b.sub(f), b.y = 0, b.normalize(), f = Math.atan2(b.x, b.z), k.rotation.set(0, f, 0));
            }
          else
            'rot' === f ? THREE.Quaternion.slerp(u, p, k.quaternion, q) : 'scl' === f && (f = k.scale, f.x = u[0] + (p[0] - u[0]) * q, f.y = u[1] + (p[1] - u[1]) * q, f.z = u[2] + (p[2] - u[2]) * q);
        }
    }
  };
}();
THREE.Animation.prototype.getNextKeyWith = function (a, b, c) {
  var d = this.data.hierarchy[b].keys;
  for (c = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? c < d.length - 1 ? c : d.length - 1 : c % d.length; c < d.length; c++)
    if (void 0 !== d[c][a])
      return d[c];
  return this.data.hierarchy[b].keys[0];
};
THREE.Animation.prototype.getPrevKeyWith = function (a, b, c) {
  var d = this.data.hierarchy[b].keys;
  for (c = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? 0 < c ? c : 0 : 0 <= c ? c : c + d.length; 0 <= c; c--)
    if (void 0 !== d[c][a])
      return d[c];
  return this.data.hierarchy[b].keys[d.length - 1];
};
THREE.KeyFrameAnimation = function (a, b) {
  this.root = a;
  this.data = THREE.AnimationHandler.get(b);
  this.hierarchy = THREE.AnimationHandler.parse(a);
  this.currentTime = 0;
  this.timeScale = 0.001;
  this.isPlaying = !1;
  this.loop = this.isPaused = !0;
  for (var c = 0, d = this.hierarchy.length; c < d; c++) {
    var e = this.data.hierarchy[c].sids, f = this.hierarchy[c];
    if (this.data.hierarchy[c].keys.length && e) {
      for (var g = 0; g < e.length; g++) {
        var h = e[g], k = this.getNextKeyWith(h, c, 0);
        k && k.apply(h);
      }
      f.matrixAutoUpdate = !1;
      this.data.hierarchy[c].node.updateMatrix();
      f.matrixWorldNeedsUpdate = !0;
    }
  }
};
THREE.KeyFrameAnimation.prototype.play = function (a) {
  this.currentTime = void 0 !== a ? a : 0;
  if (!1 === this.isPlaying) {
    this.isPlaying = !0;
    var b = this.hierarchy.length, c, d;
    for (a = 0; a < b; a++)
      c = this.hierarchy[a], d = this.data.hierarchy[a], void 0 === d.animationCache && (d.animationCache = {}, d.animationCache.prevKey = null, d.animationCache.nextKey = null, d.animationCache.originalMatrix = c instanceof THREE.Bone ? c.skinMatrix : c.matrix), c = this.data.hierarchy[a].keys, c.length && (d.animationCache.prevKey = c[0], d.animationCache.nextKey = c[1], this.startTime = Math.min(c[0].time, this.startTime), this.endTime = Math.max(c[c.length - 1].time, this.endTime));
    this.update(0);
  }
  this.isPaused = !1;
  THREE.AnimationHandler.addToUpdate(this);
};
THREE.KeyFrameAnimation.prototype.pause = function () {
  this.isPaused ? THREE.AnimationHandler.addToUpdate(this) : THREE.AnimationHandler.removeFromUpdate(this);
  this.isPaused = !this.isPaused;
};
THREE.KeyFrameAnimation.prototype.stop = function () {
  this.isPaused = this.isPlaying = !1;
  THREE.AnimationHandler.removeFromUpdate(this);
  for (var a = 0; a < this.data.hierarchy.length; a++) {
    var b = this.hierarchy[a], c = this.data.hierarchy[a];
    if (void 0 !== c.animationCache) {
      var d = c.animationCache.originalMatrix;
      b instanceof THREE.Bone ? (d.copy(b.skinMatrix), b.skinMatrix = d) : (d.copy(b.matrix), b.matrix = d);
      delete c.animationCache;
    }
  }
};
THREE.KeyFrameAnimation.prototype.update = function (a) {
  if (!1 !== this.isPlaying) {
    this.currentTime += a * this.timeScale;
    a = this.data.length;
    !0 === this.loop && this.currentTime > a && (this.currentTime %= a);
    this.currentTime = Math.min(this.currentTime, a);
    a = 0;
    for (var b = this.hierarchy.length; a < b; a++) {
      var c = this.hierarchy[a], d = this.data.hierarchy[a], e = d.keys, d = d.animationCache;
      if (e.length) {
        var f = d.prevKey, g = d.nextKey;
        if (g.time <= this.currentTime) {
          for (; g.time < this.currentTime && g.index > f.index;)
            f = g, g = e[f.index + 1];
          d.prevKey = f;
          d.nextKey = g;
        }
        g.time >= this.currentTime ? f.interpolate(g, this.currentTime) : f.interpolate(g, g.time);
        this.data.hierarchy[a].node.updateMatrix();
        c.matrixWorldNeedsUpdate = !0;
      }
    }
  }
};
THREE.KeyFrameAnimation.prototype.getNextKeyWith = function (a, b, c) {
  b = this.data.hierarchy[b].keys;
  for (c %= b.length; c < b.length; c++)
    if (b[c].hasTarget(a))
      return b[c];
  return b[0];
};
THREE.KeyFrameAnimation.prototype.getPrevKeyWith = function (a, b, c) {
  b = this.data.hierarchy[b].keys;
  for (c = 0 <= c ? c : c + b.length; 0 <= c; c--)
    if (b[c].hasTarget(a))
      return b[c];
  return b[b.length - 1];
};
THREE.MorphAnimation = function (a) {
  this.mesh = a;
  this.frames = a.morphTargetInfluences.length;
  this.currentTime = 0;
  this.duration = 1000;
  this.loop = !0;
  this.isPlaying = !1;
};
THREE.MorphAnimation.prototype = {
  play: function () {
    this.isPlaying = !0;
  },
  pause: function () {
    this.isPlaying = !1;
  },
  update: function () {
    var a = 0, b = 0;
    return function (c) {
      if (!1 !== this.isPlaying) {
        this.currentTime += c;
        !0 === this.loop && this.currentTime > this.duration && (this.currentTime %= this.duration);
        this.currentTime = Math.min(this.currentTime, this.duration);
        c = this.duration / this.frames;
        var d = Math.floor(this.currentTime / c);
        d != b && (this.mesh.morphTargetInfluences[a] = 0, this.mesh.morphTargetInfluences[b] = 1, this.mesh.morphTargetInfluences[d] = 0, a = b, b = d);
        this.mesh.morphTargetInfluences[d] = this.currentTime % c / c;
        this.mesh.morphTargetInfluences[a] = 1 - this.mesh.morphTargetInfluences[d];
      }
    };
  }()
};
THREE.CubeCamera = function (a, b, c) {
  THREE.Object3D.call(this);
  var d = new THREE.PerspectiveCamera(90, 1, a, b);
  d.up.set(0, -1, 0);
  d.lookAt(new THREE.Vector3(1, 0, 0));
  this.add(d);
  var e = new THREE.PerspectiveCamera(90, 1, a, b);
  e.up.set(0, -1, 0);
  e.lookAt(new THREE.Vector3(-1, 0, 0));
  this.add(e);
  var f = new THREE.PerspectiveCamera(90, 1, a, b);
  f.up.set(0, 0, 1);
  f.lookAt(new THREE.Vector3(0, 1, 0));
  this.add(f);
  var g = new THREE.PerspectiveCamera(90, 1, a, b);
  g.up.set(0, 0, -1);
  g.lookAt(new THREE.Vector3(0, -1, 0));
  this.add(g);
  var h = new THREE.PerspectiveCamera(90, 1, a, b);
  h.up.set(0, -1, 0);
  h.lookAt(new THREE.Vector3(0, 0, 1));
  this.add(h);
  var k = new THREE.PerspectiveCamera(90, 1, a, b);
  k.up.set(0, -1, 0);
  k.lookAt(new THREE.Vector3(0, 0, -1));
  this.add(k);
  this.renderTarget = new THREE.WebGLRenderTargetCube(c, c, {
    format: THREE.RGBFormat,
    magFilter: THREE.LinearFilter,
    minFilter: THREE.LinearFilter
  });
  this.updateCubeMap = function (a, b) {
    var c = this.renderTarget, r = c.generateMipmaps;
    c.generateMipmaps = !1;
    c.activeCubeFace = 0;
    a.render(b, d, c);
    c.activeCubeFace = 1;
    a.render(b, e, c);
    c.activeCubeFace = 2;
    a.render(b, f, c);
    c.activeCubeFace = 3;
    a.render(b, g, c);
    c.activeCubeFace = 4;
    a.render(b, h, c);
    c.generateMipmaps = r;
    c.activeCubeFace = 5;
    a.render(b, k, c);
  };
};
THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype);
THREE.CombinedCamera = function (a, b, c, d, e, f, g) {
  THREE.Camera.call(this);
  this.fov = c;
  this.left = -a / 2;
  this.right = a / 2;
  this.top = b / 2;
  this.bottom = -b / 2;
  this.cameraO = new THREE.OrthographicCamera(a / -2, a / 2, b / 2, b / -2, f, g);
  this.cameraP = new THREE.PerspectiveCamera(c, a / b, d, e);
  this.zoom = 1;
  this.toPerspective();
};
THREE.CombinedCamera.prototype = Object.create(THREE.Camera.prototype);
THREE.CombinedCamera.prototype.toPerspective = function () {
  this.near = this.cameraP.near;
  this.far = this.cameraP.far;
  this.cameraP.fov = this.fov / this.zoom;
  this.cameraP.updateProjectionMatrix();
  this.projectionMatrix = this.cameraP.projectionMatrix;
  this.inPerspectiveMode = !0;
  this.inOrthographicMode = !1;
};
THREE.CombinedCamera.prototype.toOrthographic = function () {
  var a = this.cameraP.aspect, b = (this.cameraP.near + this.cameraP.far) / 2, b = Math.tan(this.fov / 2) * b, a = 2 * b * a / 2, b = b / this.zoom, a = a / this.zoom;
  this.cameraO.left = -a;
  this.cameraO.right = a;
  this.cameraO.top = b;
  this.cameraO.bottom = -b;
  this.cameraO.updateProjectionMatrix();
  this.near = this.cameraO.near;
  this.far = this.cameraO.far;
  this.projectionMatrix = this.cameraO.projectionMatrix;
  this.inPerspectiveMode = !1;
  this.inOrthographicMode = !0;
};
THREE.CombinedCamera.prototype.setSize = function (a, b) {
  this.cameraP.aspect = a / b;
  this.left = -a / 2;
  this.right = a / 2;
  this.top = b / 2;
  this.bottom = -b / 2;
};
THREE.CombinedCamera.prototype.setFov = function (a) {
  this.fov = a;
  this.inPerspectiveMode ? this.toPerspective() : this.toOrthographic();
};
THREE.CombinedCamera.prototype.updateProjectionMatrix = function () {
  this.inPerspectiveMode ? this.toPerspective() : (this.toPerspective(), this.toOrthographic());
};
THREE.CombinedCamera.prototype.setLens = function (a, b) {
  void 0 === b && (b = 24);
  var c = 2 * THREE.Math.radToDeg(Math.atan(b / (2 * a)));
  this.setFov(c);
  return c;
};
THREE.CombinedCamera.prototype.setZoom = function (a) {
  this.zoom = a;
  this.inPerspectiveMode ? this.toPerspective() : this.toOrthographic();
};
THREE.CombinedCamera.prototype.toFrontView = function () {
  this.rotation.x = 0;
  this.rotation.y = 0;
  this.rotation.z = 0;
  this.rotationAutoUpdate = !1;
};
THREE.CombinedCamera.prototype.toBackView = function () {
  this.rotation.x = 0;
  this.rotation.y = Math.PI;
  this.rotation.z = 0;
  this.rotationAutoUpdate = !1;
};
THREE.CombinedCamera.prototype.toLeftView = function () {
  this.rotation.x = 0;
  this.rotation.y = -Math.PI / 2;
  this.rotation.z = 0;
  this.rotationAutoUpdate = !1;
};
THREE.CombinedCamera.prototype.toRightView = function () {
  this.rotation.x = 0;
  this.rotation.y = Math.PI / 2;
  this.rotation.z = 0;
  this.rotationAutoUpdate = !1;
};
THREE.CombinedCamera.prototype.toTopView = function () {
  this.rotation.x = -Math.PI / 2;
  this.rotation.y = 0;
  this.rotation.z = 0;
  this.rotationAutoUpdate = !1;
};
THREE.CombinedCamera.prototype.toBottomView = function () {
  this.rotation.x = Math.PI / 2;
  this.rotation.y = 0;
  this.rotation.z = 0;
  this.rotationAutoUpdate = !1;
};
THREE.BoxGeometry = function (a, b, c, d, e, f) {
  function g(a, b, c, d, e, f, g, p) {
    var v, w = h.widthSegments, t = h.heightSegments, x = e / 2, z = f / 2, B = h.vertices.length;
    if ('x' === a && 'y' === b || 'y' === a && 'x' === b)
      v = 'z';
    else if ('x' === a && 'z' === b || 'z' === a && 'x' === b)
      v = 'y', t = h.depthSegments;
    else if ('z' === a && 'y' === b || 'y' === a && 'z' === b)
      v = 'x', w = h.depthSegments;
    var E = w + 1, H = t + 1, D = e / w, G = f / t, I = new THREE.Vector3();
    I[v] = 0 < g ? 1 : -1;
    for (e = 0; e < H; e++)
      for (f = 0; f < E; f++) {
        var O = new THREE.Vector3();
        O[a] = (f * D - x) * c;
        O[b] = (e * G - z) * d;
        O[v] = g;
        h.vertices.push(O);
      }
    for (e = 0; e < t; e++)
      for (f = 0; f < w; f++)
        z = f + E * e, a = f + E * (e + 1), b = f + 1 + E * (e + 1), c = f + 1 + E * e, d = new THREE.Vector2(f / w, 1 - e / t), g = new THREE.Vector2(f / w, 1 - (e + 1) / t), v = new THREE.Vector2((f + 1) / w, 1 - (e + 1) / t), x = new THREE.Vector2((f + 1) / w, 1 - e / t), z = new THREE.Face3(z + B, a + B, c + B), z.normal.copy(I), z.vertexNormals.push(I.clone(), I.clone(), I.clone()), z.materialIndex = p, h.faces.push(z), h.faceVertexUvs[0].push([
          d,
          g,
          x
        ]), z = new THREE.Face3(a + B, b + B, c + B), z.normal.copy(I), z.vertexNormals.push(I.clone(), I.clone(), I.clone()), z.materialIndex = p, h.faces.push(z), h.faceVertexUvs[0].push([
          g.clone(),
          v,
          x.clone()
        ]);
  }
  THREE.Geometry.call(this);
  var h = this;
  this.width = a;
  this.height = b;
  this.depth = c;
  this.widthSegments = d || 1;
  this.heightSegments = e || 1;
  this.depthSegments = f || 1;
  a = this.width / 2;
  b = this.height / 2;
  c = this.depth / 2;
  g('z', 'y', -1, -1, this.depth, this.height, a, 0);
  g('z', 'y', 1, -1, this.depth, this.height, -a, 1);
  g('x', 'z', 1, 1, this.width, this.depth, b, 2);
  g('x', 'z', 1, -1, this.width, this.depth, -b, 3);
  g('x', 'y', 1, -1, this.width, this.height, c, 4);
  g('x', 'y', -1, -1, this.width, this.height, -c, 5);
  this.computeCentroids();
  this.mergeVertices();
};
THREE.BoxGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.CircleGeometry = function (a, b, c, d) {
  THREE.Geometry.call(this);
  this.radius = a = a || 50;
  this.segments = b = void 0 !== b ? Math.max(3, b) : 8;
  this.thetaStart = c = void 0 !== c ? c : 0;
  this.thetaLength = d = void 0 !== d ? d : 2 * Math.PI;
  var e, f = [];
  e = new THREE.Vector3();
  var g = new THREE.Vector2(0.5, 0.5);
  this.vertices.push(e);
  f.push(g);
  for (e = 0; e <= b; e++) {
    var h = new THREE.Vector3(), k = c + e / b * d;
    h.x = a * Math.cos(k);
    h.y = a * Math.sin(k);
    this.vertices.push(h);
    f.push(new THREE.Vector2((h.x / a + 1) / 2, (h.y / a + 1) / 2));
  }
  c = new THREE.Vector3(0, 0, 1);
  for (e = 1; e <= b; e++)
    this.faces.push(new THREE.Face3(e, e + 1, 0, [
      c.clone(),
      c.clone(),
      c.clone()
    ])), this.faceVertexUvs[0].push([
      f[e].clone(),
      f[e + 1].clone(),
      g.clone()
    ]);
  this.computeCentroids();
  this.computeFaceNormals();
  this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), a);
};
THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.CubeGeometry = THREE.BoxGeometry;
THREE.CylinderGeometry = function (a, b, c, d, e, f) {
  THREE.Geometry.call(this);
  this.radiusTop = a = void 0 !== a ? a : 20;
  this.radiusBottom = b = void 0 !== b ? b : 20;
  this.height = c = void 0 !== c ? c : 100;
  this.radialSegments = d = d || 8;
  this.heightSegments = e = e || 1;
  this.openEnded = f = void 0 !== f ? f : !1;
  var g = c / 2, h, k, l = [], n = [];
  for (k = 0; k <= e; k++) {
    var s = [], r = [], q = k / e, u = q * (b - a) + a;
    for (h = 0; h <= d; h++) {
      var p = h / d, v = new THREE.Vector3();
      v.x = u * Math.sin(p * Math.PI * 2);
      v.y = -q * c + g;
      v.z = u * Math.cos(p * Math.PI * 2);
      this.vertices.push(v);
      s.push(this.vertices.length - 1);
      r.push(new THREE.Vector2(p, 1 - q));
    }
    l.push(s);
    n.push(r);
  }
  c = (b - a) / c;
  for (h = 0; h < d; h++)
    for (0 !== a ? (s = this.vertices[l[0][h]].clone(), r = this.vertices[l[0][h + 1]].clone()) : (s = this.vertices[l[1][h]].clone(), r = this.vertices[l[1][h + 1]].clone()), s.setY(Math.sqrt(s.x * s.x + s.z * s.z) * c).normalize(), r.setY(Math.sqrt(r.x * r.x + r.z * r.z) * c).normalize(), k = 0; k < e; k++) {
      var q = l[k][h], u = l[k + 1][h], p = l[k + 1][h + 1], v = l[k][h + 1], w = s.clone(), t = s.clone(), x = r.clone(), z = r.clone(), B = n[k][h].clone(), E = n[k + 1][h].clone(), H = n[k + 1][h + 1].clone(), D = n[k][h + 1].clone();
      this.faces.push(new THREE.Face3(q, u, v, [
        w,
        t,
        z
      ]));
      this.faceVertexUvs[0].push([
        B,
        E,
        D
      ]);
      this.faces.push(new THREE.Face3(u, p, v, [
        t.clone(),
        x,
        z.clone()
      ]));
      this.faceVertexUvs[0].push([
        E.clone(),
        H,
        D.clone()
      ]);
    }
  if (!1 === f && 0 < a)
    for (this.vertices.push(new THREE.Vector3(0, g, 0)), h = 0; h < d; h++)
      q = l[0][h], u = l[0][h + 1], p = this.vertices.length - 1, w = new THREE.Vector3(0, 1, 0), t = new THREE.Vector3(0, 1, 0), x = new THREE.Vector3(0, 1, 0), B = n[0][h].clone(), E = n[0][h + 1].clone(), H = new THREE.Vector2(E.x, 0), this.faces.push(new THREE.Face3(q, u, p, [
        w,
        t,
        x
      ])), this.faceVertexUvs[0].push([
        B,
        E,
        H
      ]);
  if (!1 === f && 0 < b)
    for (this.vertices.push(new THREE.Vector3(0, -g, 0)), h = 0; h < d; h++)
      q = l[k][h + 1], u = l[k][h], p = this.vertices.length - 1, w = new THREE.Vector3(0, -1, 0), t = new THREE.Vector3(0, -1, 0), x = new THREE.Vector3(0, -1, 0), B = n[k][h + 1].clone(), E = n[k][h].clone(), H = new THREE.Vector2(E.x, 1), this.faces.push(new THREE.Face3(q, u, p, [
        w,
        t,
        x
      ])), this.faceVertexUvs[0].push([
        B,
        E,
        H
      ]);
  this.computeCentroids();
  this.computeFaceNormals();
};
THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ExtrudeGeometry = function (a, b) {
  'undefined' !== typeof a && (THREE.Geometry.call(this), a = a instanceof Array ? a : [a], this.shapebb = a[a.length - 1].getBoundingBox(), this.addShapeList(a, b), this.computeCentroids(), this.computeFaceNormals());
};
THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ExtrudeGeometry.prototype.addShapeList = function (a, b) {
  for (var c = a.length, d = 0; d < c; d++)
    this.addShape(a[d], b);
};
THREE.ExtrudeGeometry.prototype.addShape = function (a, b) {
  function c(a, b, c) {
    b || console.log('die');
    return b.clone().multiplyScalar(c).add(a);
  }
  function d(a, b, c) {
    var d = THREE.Math.sign, e = 1, e = a.x - b.x, f = a.y - b.y, g = c.x - a.x, h = c.y - a.y, k = e * e + f * f;
    if (1e-10 < Math.abs(e * h - f * g)) {
      var l = Math.sqrt(k), d = Math.sqrt(g * g + h * h), k = b.x - f / l;
      b = b.y + e / l;
      g = ((c.x - h / d - k) * h - (c.y + g / d - b) * g) / (e * h - f * g);
      c = k + e * g - a.x;
      a = b + f * g - a.y;
      e = c * c + a * a;
      if (2 >= e)
        return new THREE.Vector2(c, a);
      e = Math.sqrt(e / 2);
    } else
      a = !1, 1e-10 < e ? 1e-10 < g && (a = !0) : -1e-10 > e ? -1e-10 > g && (a = !0) : d(f) == d(h) && (a = !0), a ? (c = -f, a = e, e = Math.sqrt(k)) : (c = e, a = f, e = Math.sqrt(k / 2));
    return new THREE.Vector2(c / e, a / e);
  }
  function e(c, d) {
    var e, f;
    for (J = c.length; 0 <= --J;) {
      e = J;
      f = J - 1;
      0 > f && (f = c.length - 1);
      for (var g = 0, h = q + 2 * n, g = 0; g < h; g++) {
        var k = fa * g, l = fa * (g + 1), p = d + e + k, k = d + f + k, r = d + f + l, l = d + e + l, s = c, u = g, v = h, w = e, y = f, p = p + K, k = k + K, r = r + K, l = l + K;
        O.faces.push(new THREE.Face3(p, k, l, null, null, t));
        O.faces.push(new THREE.Face3(k, r, l, null, null, t));
        p = x.generateSideWallUV(O, a, s, b, p, k, r, l, u, v, w, y);
        O.faceVertexUvs[0].push([
          p[0],
          p[1],
          p[3]
        ]);
        O.faceVertexUvs[0].push([
          p[1],
          p[2],
          p[3]
        ]);
      }
    }
  }
  function f(a, b, c) {
    O.vertices.push(new THREE.Vector3(a, b, c));
  }
  function g(c, d, e, f) {
    c += K;
    d += K;
    e += K;
    O.faces.push(new THREE.Face3(c, d, e, null, null, w));
    c = f ? x.generateBottomUV(O, a, b, c, d, e) : x.generateTopUV(O, a, b, c, d, e);
    O.faceVertexUvs[0].push(c);
  }
  var h = void 0 !== b.amount ? b.amount : 100, k = void 0 !== b.bevelThickness ? b.bevelThickness : 6, l = void 0 !== b.bevelSize ? b.bevelSize : k - 2, n = void 0 !== b.bevelSegments ? b.bevelSegments : 3, s = void 0 !== b.bevelEnabled ? b.bevelEnabled : !0, r = void 0 !== b.curveSegments ? b.curveSegments : 12, q = void 0 !== b.steps ? b.steps : 1, u = b.extrudePath, p, v = !1, w = b.material, t = b.extrudeMaterial, x = void 0 !== b.UVGenerator ? b.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator, z, B, E, H;
  u && (p = u.getSpacedPoints(q), v = !0, s = !1, z = void 0 !== b.frames ? b.frames : new THREE.TubeGeometry.FrenetFrames(u, q, !1), B = new THREE.Vector3(), E = new THREE.Vector3(), H = new THREE.Vector3());
  s || (l = k = n = 0);
  var D, G, I, O = this, K = this.vertices.length, u = a.extractPoints(r), r = u.shape, y = u.holes;
  if (u = !THREE.Shape.Utils.isClockWise(r)) {
    r = r.reverse();
    G = 0;
    for (I = y.length; G < I; G++)
      D = y[G], THREE.Shape.Utils.isClockWise(D) && (y[G] = D.reverse());
    u = !1;
  }
  var F = THREE.Shape.Utils.triangulateShape(r, y), C = r;
  G = 0;
  for (I = y.length; G < I; G++)
    D = y[G], r = r.concat(D);
  var A, L, Q, Y, R, fa = r.length, V, ga = F.length, u = [], J = 0;
  Q = C.length;
  A = Q - 1;
  for (L = J + 1; J < Q; J++, A++, L++)
    A === Q && (A = 0), L === Q && (L = 0), u[J] = d(C[J], C[A], C[L]);
  var da = [], W, N = u.concat();
  G = 0;
  for (I = y.length; G < I; G++) {
    D = y[G];
    W = [];
    J = 0;
    Q = D.length;
    A = Q - 1;
    for (L = J + 1; J < Q; J++, A++, L++)
      A === Q && (A = 0), L === Q && (L = 0), W[J] = d(D[J], D[A], D[L]);
    da.push(W);
    N = N.concat(W);
  }
  for (A = 0; A < n; A++) {
    Q = A / n;
    Y = k * (1 - Q);
    L = l * Math.sin(Q * Math.PI / 2);
    J = 0;
    for (Q = C.length; J < Q; J++)
      R = c(C[J], u[J], L), f(R.x, R.y, -Y);
    G = 0;
    for (I = y.length; G < I; G++)
      for (D = y[G], W = da[G], J = 0, Q = D.length; J < Q; J++)
        R = c(D[J], W[J], L), f(R.x, R.y, -Y);
  }
  L = l;
  for (J = 0; J < fa; J++)
    R = s ? c(r[J], N[J], L) : r[J], v ? (E.copy(z.normals[0]).multiplyScalar(R.x), B.copy(z.binormals[0]).multiplyScalar(R.y), H.copy(p[0]).add(E).add(B), f(H.x, H.y, H.z)) : f(R.x, R.y, 0);
  for (Q = 1; Q <= q; Q++)
    for (J = 0; J < fa; J++)
      R = s ? c(r[J], N[J], L) : r[J], v ? (E.copy(z.normals[Q]).multiplyScalar(R.x), B.copy(z.binormals[Q]).multiplyScalar(R.y), H.copy(p[Q]).add(E).add(B), f(H.x, H.y, H.z)) : f(R.x, R.y, h / q * Q);
  for (A = n - 1; 0 <= A; A--) {
    Q = A / n;
    Y = k * (1 - Q);
    L = l * Math.sin(Q * Math.PI / 2);
    J = 0;
    for (Q = C.length; J < Q; J++)
      R = c(C[J], u[J], L), f(R.x, R.y, h + Y);
    G = 0;
    for (I = y.length; G < I; G++)
      for (D = y[G], W = da[G], J = 0, Q = D.length; J < Q; J++)
        R = c(D[J], W[J], L), v ? f(R.x, R.y + p[q - 1].y, p[q - 1].x + Y) : f(R.x, R.y, h + Y);
  }
  (function () {
    if (s) {
      var a;
      a = 0 * fa;
      for (J = 0; J < ga; J++)
        V = F[J], g(V[2] + a, V[1] + a, V[0] + a, !0);
      a = q + 2 * n;
      a *= fa;
      for (J = 0; J < ga; J++)
        V = F[J], g(V[0] + a, V[1] + a, V[2] + a, !1);
    } else {
      for (J = 0; J < ga; J++)
        V = F[J], g(V[2], V[1], V[0], !0);
      for (J = 0; J < ga; J++)
        V = F[J], g(V[0] + fa * q, V[1] + fa * q, V[2] + fa * q, !1);
    }
  }());
  (function () {
    var a = 0;
    e(C, a);
    a += C.length;
    G = 0;
    for (I = y.length; G < I; G++)
      D = y[G], e(D, a), a += D.length;
  }());
};
THREE.ExtrudeGeometry.WorldUVGenerator = {
  generateTopUV: function (a, b, c, d, e, f) {
    b = a.vertices[e].x;
    e = a.vertices[e].y;
    c = a.vertices[f].x;
    f = a.vertices[f].y;
    return [
      new THREE.Vector2(a.vertices[d].x, a.vertices[d].y),
      new THREE.Vector2(b, e),
      new THREE.Vector2(c, f)
    ];
  },
  generateBottomUV: function (a, b, c, d, e, f) {
    return this.generateTopUV(a, b, c, d, e, f);
  },
  generateSideWallUV: function (a, b, c, d, e, f, g, h, k, l, n, s) {
    b = a.vertices[e].x;
    c = a.vertices[e].y;
    e = a.vertices[e].z;
    d = a.vertices[f].x;
    k = a.vertices[f].y;
    f = a.vertices[f].z;
    l = a.vertices[g].x;
    n = a.vertices[g].y;
    g = a.vertices[g].z;
    s = a.vertices[h].x;
    var r = a.vertices[h].y;
    a = a.vertices[h].z;
    return 0.01 > Math.abs(c - k) ? [
      new THREE.Vector2(b, 1 - e),
      new THREE.Vector2(d, 1 - f),
      new THREE.Vector2(l, 1 - g),
      new THREE.Vector2(s, 1 - a)
    ] : [
      new THREE.Vector2(c, 1 - e),
      new THREE.Vector2(k, 1 - f),
      new THREE.Vector2(n, 1 - g),
      new THREE.Vector2(r, 1 - a)
    ];
  }
};
THREE.ExtrudeGeometry.__v1 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v2 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v3 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v4 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v5 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v6 = new THREE.Vector2();
THREE.ShapeGeometry = function (a, b) {
  THREE.Geometry.call(this);
  !1 === a instanceof Array && (a = [a]);
  this.shapebb = a[a.length - 1].getBoundingBox();
  this.addShapeList(a, b);
  this.computeCentroids();
  this.computeFaceNormals();
};
THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ShapeGeometry.prototype.addShapeList = function (a, b) {
  for (var c = 0, d = a.length; c < d; c++)
    this.addShape(a[c], b);
  return this;
};
THREE.ShapeGeometry.prototype.addShape = function (a, b) {
  void 0 === b && (b = {});
  var c = b.material, d = void 0 === b.UVGenerator ? THREE.ExtrudeGeometry.WorldUVGenerator : b.UVGenerator, e, f, g, h = this.vertices.length;
  e = a.extractPoints(void 0 !== b.curveSegments ? b.curveSegments : 12);
  var k = e.shape, l = e.holes;
  if (!THREE.Shape.Utils.isClockWise(k))
    for (k = k.reverse(), e = 0, f = l.length; e < f; e++)
      g = l[e], THREE.Shape.Utils.isClockWise(g) && (l[e] = g.reverse());
  var n = THREE.Shape.Utils.triangulateShape(k, l);
  e = 0;
  for (f = l.length; e < f; e++)
    g = l[e], k = k.concat(g);
  l = k.length;
  f = n.length;
  for (e = 0; e < l; e++)
    g = k[e], this.vertices.push(new THREE.Vector3(g.x, g.y, 0));
  for (e = 0; e < f; e++)
    l = n[e], k = l[0] + h, g = l[1] + h, l = l[2] + h, this.faces.push(new THREE.Face3(k, g, l, null, null, c)), this.faceVertexUvs[0].push(d.generateBottomUV(this, a, b, k, g, l));
};
THREE.LatheGeometry = function (a, b, c, d) {
  THREE.Geometry.call(this);
  b = b || 12;
  c = c || 0;
  d = d || 2 * Math.PI;
  for (var e = 1 / (a.length - 1), f = 1 / b, g = 0, h = b; g <= h; g++)
    for (var k = c + g * f * d, l = Math.cos(k), n = Math.sin(k), k = 0, s = a.length; k < s; k++) {
      var r = a[k], q = new THREE.Vector3();
      q.x = l * r.x - n * r.y;
      q.y = n * r.x + l * r.y;
      q.z = r.z;
      this.vertices.push(q);
    }
  c = a.length;
  g = 0;
  for (h = b; g < h; g++)
    for (k = 0, s = a.length - 1; k < s; k++) {
      b = n = k + c * g;
      d = n + c;
      var l = n + 1 + c, n = n + 1, r = g * f, q = k * e, u = r + f, p = q + e;
      this.faces.push(new THREE.Face3(b, d, n));
      this.faceVertexUvs[0].push([
        new THREE.Vector2(r, q),
        new THREE.Vector2(u, q),
        new THREE.Vector2(r, p)
      ]);
      this.faces.push(new THREE.Face3(d, l, n));
      this.faceVertexUvs[0].push([
        new THREE.Vector2(u, q),
        new THREE.Vector2(u, p),
        new THREE.Vector2(r, p)
      ]);
    }
  this.mergeVertices();
  this.computeCentroids();
  this.computeFaceNormals();
  this.computeVertexNormals();
};
THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.PlaneGeometry = function (a, b, c, d) {
  THREE.Geometry.call(this);
  this.width = a;
  this.height = b;
  this.widthSegments = c || 1;
  this.heightSegments = d || 1;
  var e = a / 2, f = b / 2;
  c = this.widthSegments;
  d = this.heightSegments;
  var g = c + 1, h = d + 1, k = this.width / c, l = this.height / d, n = new THREE.Vector3(0, 0, 1);
  for (a = 0; a < h; a++)
    for (b = 0; b < g; b++)
      this.vertices.push(new THREE.Vector3(b * k - e, -(a * l - f), 0));
  for (a = 0; a < d; a++)
    for (b = 0; b < c; b++) {
      var s = b + g * a, e = b + g * (a + 1), f = b + 1 + g * (a + 1), h = b + 1 + g * a, k = new THREE.Vector2(b / c, 1 - a / d), l = new THREE.Vector2(b / c, 1 - (a + 1) / d), r = new THREE.Vector2((b + 1) / c, 1 - (a + 1) / d), q = new THREE.Vector2((b + 1) / c, 1 - a / d), s = new THREE.Face3(s, e, h);
      s.normal.copy(n);
      s.vertexNormals.push(n.clone(), n.clone(), n.clone());
      this.faces.push(s);
      this.faceVertexUvs[0].push([
        k,
        l,
        q
      ]);
      s = new THREE.Face3(e, f, h);
      s.normal.copy(n);
      s.vertexNormals.push(n.clone(), n.clone(), n.clone());
      this.faces.push(s);
      this.faceVertexUvs[0].push([
        l.clone(),
        r,
        q.clone()
      ]);
    }
  this.computeCentroids();
};
THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.RingGeometry = function (a, b, c, d, e, f) {
  THREE.Geometry.call(this);
  a = a || 0;
  b = b || 50;
  e = void 0 !== e ? e : 0;
  f = void 0 !== f ? f : 2 * Math.PI;
  c = void 0 !== c ? Math.max(3, c) : 8;
  d = void 0 !== d ? Math.max(3, d) : 8;
  var g, h = [], k = a, l = (b - a) / d;
  for (a = 0; a <= d; a++) {
    for (g = 0; g <= c; g++) {
      var n = new THREE.Vector3(), s = e + g / c * f;
      n.x = k * Math.cos(s);
      n.y = k * Math.sin(s);
      this.vertices.push(n);
      h.push(new THREE.Vector2((n.x / b + 1) / 2, (n.y / b + 1) / 2));
    }
    k += l;
  }
  b = new THREE.Vector3(0, 0, 1);
  for (a = 0; a < d; a++)
    for (e = a * c, g = 0; g <= c; g++)
      s = g + e, f = s + a, l = s + c + a, n = s + c + 1 + a, this.faces.push(new THREE.Face3(f, l, n, [
        b.clone(),
        b.clone(),
        b.clone()
      ])), this.faceVertexUvs[0].push([
        h[f].clone(),
        h[l].clone(),
        h[n].clone()
      ]), f = s + a, l = s + c + 1 + a, n = s + 1 + a, this.faces.push(new THREE.Face3(f, l, n, [
        b.clone(),
        b.clone(),
        b.clone()
      ])), this.faceVertexUvs[0].push([
        h[f].clone(),
        h[l].clone(),
        h[n].clone()
      ]);
  this.computeCentroids();
  this.computeFaceNormals();
  this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), k);
};
THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.SphereGeometry = function (a, b, c, d, e, f, g) {
  THREE.Geometry.call(this);
  this.radius = a = a || 50;
  this.widthSegments = b = Math.max(3, Math.floor(b) || 8);
  this.heightSegments = c = Math.max(2, Math.floor(c) || 6);
  this.phiStart = d = void 0 !== d ? d : 0;
  this.phiLength = e = void 0 !== e ? e : 2 * Math.PI;
  this.thetaStart = f = void 0 !== f ? f : 0;
  this.thetaLength = g = void 0 !== g ? g : Math.PI;
  var h, k, l = [], n = [];
  for (k = 0; k <= c; k++) {
    var s = [], r = [];
    for (h = 0; h <= b; h++) {
      var q = h / b, u = k / c, p = new THREE.Vector3();
      p.x = -a * Math.cos(d + q * e) * Math.sin(f + u * g);
      p.y = a * Math.cos(f + u * g);
      p.z = a * Math.sin(d + q * e) * Math.sin(f + u * g);
      this.vertices.push(p);
      s.push(this.vertices.length - 1);
      r.push(new THREE.Vector2(q, 1 - u));
    }
    l.push(s);
    n.push(r);
  }
  for (k = 0; k < this.heightSegments; k++)
    for (h = 0; h < this.widthSegments; h++) {
      b = l[k][h + 1];
      c = l[k][h];
      d = l[k + 1][h];
      e = l[k + 1][h + 1];
      f = this.vertices[b].clone().normalize();
      g = this.vertices[c].clone().normalize();
      var s = this.vertices[d].clone().normalize(), r = this.vertices[e].clone().normalize(), q = n[k][h + 1].clone(), u = n[k][h].clone(), p = n[k + 1][h].clone(), v = n[k + 1][h + 1].clone();
      Math.abs(this.vertices[b].y) === this.radius ? (q.x = (q.x + u.x) / 2, this.faces.push(new THREE.Face3(b, d, e, [
        f,
        s,
        r
      ])), this.faceVertexUvs[0].push([
        q,
        p,
        v
      ])) : Math.abs(this.vertices[d].y) === this.radius ? (p.x = (p.x + v.x) / 2, this.faces.push(new THREE.Face3(b, c, d, [
        f,
        g,
        s
      ])), this.faceVertexUvs[0].push([
        q,
        u,
        p
      ])) : (this.faces.push(new THREE.Face3(b, c, e, [
        f,
        g,
        r
      ])), this.faceVertexUvs[0].push([
        q,
        u,
        v
      ]), this.faces.push(new THREE.Face3(c, d, e, [
        g.clone(),
        s,
        r.clone()
      ])), this.faceVertexUvs[0].push([
        u.clone(),
        p,
        v.clone()
      ]));
    }
  this.computeCentroids();
  this.computeFaceNormals();
  this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), a);
};
THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TextGeometry = function (a, b) {
  b = b || {};
  var c = THREE.FontUtils.generateShapes(a, b);
  b.amount = void 0 !== b.height ? b.height : 50;
  void 0 === b.bevelThickness && (b.bevelThickness = 10);
  void 0 === b.bevelSize && (b.bevelSize = 8);
  void 0 === b.bevelEnabled && (b.bevelEnabled = !1);
  THREE.ExtrudeGeometry.call(this, c, b);
};
THREE.TextGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype);
THREE.TorusGeometry = function (a, b, c, d, e) {
  THREE.Geometry.call(this);
  this.radius = a || 100;
  this.tube = b || 40;
  this.radialSegments = c || 8;
  this.tubularSegments = d || 6;
  this.arc = e || 2 * Math.PI;
  e = new THREE.Vector3();
  a = [];
  b = [];
  for (c = 0; c <= this.radialSegments; c++)
    for (d = 0; d <= this.tubularSegments; d++) {
      var f = d / this.tubularSegments * this.arc, g = c / this.radialSegments * Math.PI * 2;
      e.x = this.radius * Math.cos(f);
      e.y = this.radius * Math.sin(f);
      var h = new THREE.Vector3();
      h.x = (this.radius + this.tube * Math.cos(g)) * Math.cos(f);
      h.y = (this.radius + this.tube * Math.cos(g)) * Math.sin(f);
      h.z = this.tube * Math.sin(g);
      this.vertices.push(h);
      a.push(new THREE.Vector2(d / this.tubularSegments, c / this.radialSegments));
      b.push(h.clone().sub(e).normalize());
    }
  for (c = 1; c <= this.radialSegments; c++)
    for (d = 1; d <= this.tubularSegments; d++) {
      e = (this.tubularSegments + 1) * c + d - 1;
      var f = (this.tubularSegments + 1) * (c - 1) + d - 1, g = (this.tubularSegments + 1) * (c - 1) + d, h = (this.tubularSegments + 1) * c + d, k = new THREE.Face3(e, f, h, [
          b[e].clone(),
          b[f].clone(),
          b[h].clone()
        ]);
      this.faces.push(k);
      this.faceVertexUvs[0].push([
        a[e].clone(),
        a[f].clone(),
        a[h].clone()
      ]);
      k = new THREE.Face3(f, g, h, [
        b[f].clone(),
        b[g].clone(),
        b[h].clone()
      ]);
      this.faces.push(k);
      this.faceVertexUvs[0].push([
        a[f].clone(),
        a[g].clone(),
        a[h].clone()
      ]);
    }
  this.computeCentroids();
  this.computeFaceNormals();
};
THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TorusKnotGeometry = function (a, b, c, d, e, f, g) {
  function h(a, b, c, d, e) {
    var f = Math.cos(a), g = Math.sin(a);
    a *= b / c;
    b = Math.cos(a);
    f *= d * (2 + b) * 0.5;
    g = d * (2 + b) * g * 0.5;
    d = e * d * Math.sin(a) * 0.5;
    return new THREE.Vector3(f, g, d);
  }
  THREE.Geometry.call(this);
  this.radius = a || 100;
  this.tube = b || 40;
  this.radialSegments = c || 64;
  this.tubularSegments = d || 8;
  this.p = e || 2;
  this.q = f || 3;
  this.heightScale = g || 1;
  this.grid = Array(this.radialSegments);
  c = new THREE.Vector3();
  d = new THREE.Vector3();
  e = new THREE.Vector3();
  for (a = 0; a < this.radialSegments; ++a)
    for (this.grid[a] = Array(this.tubularSegments), b = a / this.radialSegments * 2 * this.p * Math.PI, f = h(b, this.q, this.p, this.radius, this.heightScale), b = h(b + 0.01, this.q, this.p, this.radius, this.heightScale), c.subVectors(b, f), d.addVectors(b, f), e.crossVectors(c, d), d.crossVectors(e, c), e.normalize(), d.normalize(), b = 0; b < this.tubularSegments; ++b) {
      var k = b / this.tubularSegments * 2 * Math.PI;
      g = -this.tube * Math.cos(k);
      var k = this.tube * Math.sin(k), l = new THREE.Vector3();
      l.x = f.x + g * d.x + k * e.x;
      l.y = f.y + g * d.y + k * e.y;
      l.z = f.z + g * d.z + k * e.z;
      this.grid[a][b] = this.vertices.push(l) - 1;
    }
  for (a = 0; a < this.radialSegments; ++a)
    for (b = 0; b < this.tubularSegments; ++b) {
      e = (a + 1) % this.radialSegments;
      f = (b + 1) % this.tubularSegments;
      c = this.grid[a][b];
      d = this.grid[e][b];
      e = this.grid[e][f];
      f = this.grid[a][f];
      g = new THREE.Vector2(a / this.radialSegments, b / this.tubularSegments);
      var k = new THREE.Vector2((a + 1) / this.radialSegments, b / this.tubularSegments), l = new THREE.Vector2((a + 1) / this.radialSegments, (b + 1) / this.tubularSegments), n = new THREE.Vector2(a / this.radialSegments, (b + 1) / this.tubularSegments);
      this.faces.push(new THREE.Face3(c, d, f));
      this.faceVertexUvs[0].push([
        g,
        k,
        n
      ]);
      this.faces.push(new THREE.Face3(d, e, f));
      this.faceVertexUvs[0].push([
        k.clone(),
        l,
        n.clone()
      ]);
    }
  this.computeCentroids();
  this.computeFaceNormals();
  this.computeVertexNormals();
};
THREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TubeGeometry = function (a, b, c, d, e) {
  THREE.Geometry.call(this);
  this.path = a;
  this.segments = b || 64;
  this.radius = c || 1;
  this.radialSegments = d || 8;
  this.closed = e || !1;
  this.grid = [];
  var f, g;
  d = this.segments + 1;
  var h, k, l;
  e = new THREE.Vector3();
  var n, s;
  b = new THREE.TubeGeometry.FrenetFrames(this.path, this.segments, this.closed);
  n = b.normals;
  s = b.binormals;
  this.tangents = b.tangents;
  this.normals = n;
  this.binormals = s;
  for (b = 0; b < d; b++)
    for (this.grid[b] = [], c = b / (d - 1), l = a.getPointAt(c), f = n[b], g = s[b], c = 0; c < this.radialSegments; c++)
      h = c / this.radialSegments * 2 * Math.PI, k = -this.radius * Math.cos(h), h = this.radius * Math.sin(h), e.copy(l), e.x += k * f.x + h * g.x, e.y += k * f.y + h * g.y, e.z += k * f.z + h * g.z, this.grid[b][c] = this.vertices.push(new THREE.Vector3(e.x, e.y, e.z)) - 1;
  for (b = 0; b < this.segments; b++)
    for (c = 0; c < this.radialSegments; c++)
      e = this.closed ? (b + 1) % this.segments : b + 1, n = (c + 1) % this.radialSegments, a = this.grid[b][c], d = this.grid[e][c], e = this.grid[e][n], n = this.grid[b][n], s = new THREE.Vector2(b / this.segments, c / this.radialSegments), f = new THREE.Vector2((b + 1) / this.segments, c / this.radialSegments), g = new THREE.Vector2((b + 1) / this.segments, (c + 1) / this.radialSegments), k = new THREE.Vector2(b / this.segments, (c + 1) / this.radialSegments), this.faces.push(new THREE.Face3(a, d, n)), this.faceVertexUvs[0].push([
        s,
        f,
        k
      ]), this.faces.push(new THREE.Face3(d, e, n)), this.faceVertexUvs[0].push([
        f.clone(),
        g,
        k.clone()
      ]);
  this.computeCentroids();
  this.computeFaceNormals();
  this.computeVertexNormals();
};
THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TubeGeometry.FrenetFrames = function (a, b, c) {
  new THREE.Vector3();
  var d = new THREE.Vector3();
  new THREE.Vector3();
  var e = [], f = [], g = [], h = new THREE.Vector3(), k = new THREE.Matrix4();
  b += 1;
  var l, n, s;
  this.tangents = e;
  this.normals = f;
  this.binormals = g;
  for (l = 0; l < b; l++)
    n = l / (b - 1), e[l] = a.getTangentAt(n), e[l].normalize();
  f[0] = new THREE.Vector3();
  g[0] = new THREE.Vector3();
  a = Number.MAX_VALUE;
  l = Math.abs(e[0].x);
  n = Math.abs(e[0].y);
  s = Math.abs(e[0].z);
  l <= a && (a = l, d.set(1, 0, 0));
  n <= a && (a = n, d.set(0, 1, 0));
  s <= a && d.set(0, 0, 1);
  h.crossVectors(e[0], d).normalize();
  f[0].crossVectors(e[0], h);
  g[0].crossVectors(e[0], f[0]);
  for (l = 1; l < b; l++)
    f[l] = f[l - 1].clone(), g[l] = g[l - 1].clone(), h.crossVectors(e[l - 1], e[l]), 0.0001 < h.length() && (h.normalize(), d = Math.acos(THREE.Math.clamp(e[l - 1].dot(e[l]), -1, 1)), f[l].applyMatrix4(k.makeRotationAxis(h, d))), g[l].crossVectors(e[l], f[l]);
  if (c)
    for (d = Math.acos(THREE.Math.clamp(f[0].dot(f[b - 1]), -1, 1)), d /= b - 1, 0 < e[0].dot(h.crossVectors(f[0], f[b - 1])) && (d = -d), l = 1; l < b; l++)
      f[l].applyMatrix4(k.makeRotationAxis(e[l], d * l)), g[l].crossVectors(e[l], f[l]);
};
THREE.PolyhedronGeometry = function (a, b, c, d) {
  function e(a) {
    var b = a.normalize().clone();
    b.index = k.vertices.push(b) - 1;
    var c = Math.atan2(a.z, -a.x) / 2 / Math.PI + 0.5;
    a = Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + 0.5;
    b.uv = new THREE.Vector2(c, 1 - a);
    return b;
  }
  function f(a, b, c) {
    var d = new THREE.Face3(a.index, b.index, c.index, [
        a.clone(),
        b.clone(),
        c.clone()
      ]);
    d.centroid.add(a).add(b).add(c).divideScalar(3);
    k.faces.push(d);
    d = d.centroid;
    d = Math.atan2(d.z, -d.x);
    k.faceVertexUvs[0].push([
      h(a.uv, a, d),
      h(b.uv, b, d),
      h(c.uv, c, d)
    ]);
  }
  function g(a, b) {
    var c = Math.pow(2, b);
    Math.pow(4, b);
    for (var d = e(k.vertices[a.a]), g = e(k.vertices[a.b]), h = e(k.vertices[a.c]), l = [], n = 0; n <= c; n++) {
      l[n] = [];
      for (var q = e(d.clone().lerp(h, n / c)), r = e(g.clone().lerp(h, n / c)), s = c - n, u = 0; u <= s; u++)
        l[n][u] = 0 == u && n == c ? q : e(q.clone().lerp(r, u / s));
    }
    for (n = 0; n < c; n++)
      for (u = 0; u < 2 * (c - n) - 1; u++)
        d = Math.floor(u / 2), 0 == u % 2 ? f(l[n][d + 1], l[n + 1][d], l[n][d]) : f(l[n][d + 1], l[n + 1][d + 1], l[n + 1][d]);
  }
  function h(a, b, c) {
    0 > c && 1 === a.x && (a = new THREE.Vector2(a.x - 1, a.y));
    0 === b.x && 0 === b.z && (a = new THREE.Vector2(c / 2 / Math.PI + 0.5, a.y));
    return a.clone();
  }
  THREE.Geometry.call(this);
  c = c || 1;
  d = d || 0;
  for (var k = this, l = 0, n = a.length; l < n; l++)
    e(new THREE.Vector3(a[l][0], a[l][1], a[l][2]));
  a = this.vertices;
  for (var s = [], l = 0, n = b.length; l < n; l++) {
    var r = a[b[l][0]], q = a[b[l][1]], u = a[b[l][2]];
    s[l] = new THREE.Face3(r.index, q.index, u.index, [
      r.clone(),
      q.clone(),
      u.clone()
    ]);
  }
  l = 0;
  for (n = s.length; l < n; l++)
    g(s[l], d);
  l = 0;
  for (n = this.faceVertexUvs[0].length; l < n; l++)
    b = this.faceVertexUvs[0][l], d = b[0].x, a = b[1].x, s = b[2].x, r = Math.max(d, Math.max(a, s)), q = Math.min(d, Math.min(a, s)), 0.9 < r && 0.1 > q && (0.2 > d && (b[0].x += 1), 0.2 > a && (b[1].x += 1), 0.2 > s && (b[2].x += 1));
  l = 0;
  for (n = this.vertices.length; l < n; l++)
    this.vertices[l].multiplyScalar(c);
  this.mergeVertices();
  this.computeCentroids();
  this.computeFaceNormals();
  this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), c);
};
THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.IcosahedronGeometry = function (a, b) {
  this.radius = a;
  this.detail = b;
  var c = (1 + Math.sqrt(5)) / 2;
  THREE.PolyhedronGeometry.call(this, [
    [
      -1,
      c,
      0
    ],
    [
      1,
      c,
      0
    ],
    [
      -1,
      -c,
      0
    ],
    [
      1,
      -c,
      0
    ],
    [
      0,
      -1,
      c
    ],
    [
      0,
      1,
      c
    ],
    [
      0,
      -1,
      -c
    ],
    [
      0,
      1,
      -c
    ],
    [
      c,
      0,
      -1
    ],
    [
      c,
      0,
      1
    ],
    [
      -c,
      0,
      -1
    ],
    [
      -c,
      0,
      1
    ]
  ], [
    [
      0,
      11,
      5
    ],
    [
      0,
      5,
      1
    ],
    [
      0,
      1,
      7
    ],
    [
      0,
      7,
      10
    ],
    [
      0,
      10,
      11
    ],
    [
      1,
      5,
      9
    ],
    [
      5,
      11,
      4
    ],
    [
      11,
      10,
      2
    ],
    [
      10,
      7,
      6
    ],
    [
      7,
      1,
      8
    ],
    [
      3,
      9,
      4
    ],
    [
      3,
      4,
      2
    ],
    [
      3,
      2,
      6
    ],
    [
      3,
      6,
      8
    ],
    [
      3,
      8,
      9
    ],
    [
      4,
      9,
      5
    ],
    [
      2,
      4,
      11
    ],
    [
      6,
      2,
      10
    ],
    [
      8,
      6,
      7
    ],
    [
      9,
      8,
      1
    ]
  ], a, b);
};
THREE.IcosahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.OctahedronGeometry = function (a, b) {
  THREE.PolyhedronGeometry.call(this, [
    [
      1,
      0,
      0
    ],
    [
      -1,
      0,
      0
    ],
    [
      0,
      1,
      0
    ],
    [
      0,
      -1,
      0
    ],
    [
      0,
      0,
      1
    ],
    [
      0,
      0,
      -1
    ]
  ], [
    [
      0,
      2,
      4
    ],
    [
      0,
      4,
      3
    ],
    [
      0,
      3,
      5
    ],
    [
      0,
      5,
      2
    ],
    [
      1,
      2,
      5
    ],
    [
      1,
      5,
      3
    ],
    [
      1,
      3,
      4
    ],
    [
      1,
      4,
      2
    ]
  ], a, b);
};
THREE.OctahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TetrahedronGeometry = function (a, b) {
  THREE.PolyhedronGeometry.call(this, [
    [
      1,
      1,
      1
    ],
    [
      -1,
      -1,
      1
    ],
    [
      -1,
      1,
      -1
    ],
    [
      1,
      -1,
      -1
    ]
  ], [
    [
      2,
      1,
      0
    ],
    [
      0,
      3,
      2
    ],
    [
      1,
      3,
      0
    ],
    [
      2,
      3,
      1
    ]
  ], a, b);
};
THREE.TetrahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ParametricGeometry = function (a, b, c) {
  THREE.Geometry.call(this);
  var d = this.vertices, e = this.faces, f = this.faceVertexUvs[0], g, h, k, l, n = b + 1;
  for (g = 0; g <= c; g++)
    for (l = g / c, h = 0; h <= b; h++)
      k = h / b, k = a(k, l), d.push(k);
  var s, r, q, u;
  for (g = 0; g < c; g++)
    for (h = 0; h < b; h++)
      a = g * n + h, d = g * n + h + 1, l = (g + 1) * n + h + 1, k = (g + 1) * n + h, s = new THREE.Vector2(h / b, g / c), r = new THREE.Vector2((h + 1) / b, g / c), q = new THREE.Vector2((h + 1) / b, (g + 1) / c), u = new THREE.Vector2(h / b, (g + 1) / c), e.push(new THREE.Face3(a, d, k)), f.push([
        s,
        r,
        u
      ]), e.push(new THREE.Face3(d, l, k)), f.push([
        r.clone(),
        q,
        u.clone()
      ]);
  this.computeCentroids();
  this.computeFaceNormals();
  this.computeVertexNormals();
};
THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.AxisHelper = function (a) {
  a = a || 1;
  var b = new THREE.Geometry();
  b.vertices.push(new THREE.Vector3(), new THREE.Vector3(a, 0, 0), new THREE.Vector3(), new THREE.Vector3(0, a, 0), new THREE.Vector3(), new THREE.Vector3(0, 0, a));
  b.colors.push(new THREE.Color(16711680), new THREE.Color(16755200), new THREE.Color(65280), new THREE.Color(11206400), new THREE.Color(255), new THREE.Color(43775));
  a = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors });
  THREE.Line.call(this, b, a, THREE.LinePieces);
};
THREE.AxisHelper.prototype = Object.create(THREE.Line.prototype);
THREE.ArrowHelper = function (a, b, c, d, e, f) {
  THREE.Object3D.call(this);
  void 0 === d && (d = 16776960);
  void 0 === c && (c = 1);
  void 0 === e && (e = 0.2 * c);
  void 0 === f && (f = 0.2 * e);
  this.position = b;
  b = new THREE.Geometry();
  b.vertices.push(new THREE.Vector3(0, 0, 0));
  b.vertices.push(new THREE.Vector3(0, 1, 0));
  this.line = new THREE.Line(b, new THREE.LineBasicMaterial({ color: d }));
  this.line.matrixAutoUpdate = !1;
  this.add(this.line);
  b = new THREE.CylinderGeometry(0, 0.5, 1, 5, 1);
  b.applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.5, 0));
  this.cone = new THREE.Mesh(b, new THREE.MeshBasicMaterial({ color: d }));
  this.cone.matrixAutoUpdate = !1;
  this.add(this.cone);
  this.setDirection(a);
  this.setLength(c, e, f);
};
THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.ArrowHelper.prototype.setDirection = function () {
  var a = new THREE.Vector3(), b;
  return function (c) {
    0.99999 < c.y ? this.quaternion.set(0, 0, 0, 1) : -0.99999 > c.y ? this.quaternion.set(1, 0, 0, 0) : (a.set(c.z, 0, -c.x).normalize(), b = Math.acos(c.y), this.quaternion.setFromAxisAngle(a, b));
  };
}();
THREE.ArrowHelper.prototype.setLength = function (a, b, c) {
  void 0 === b && (b = 0.2 * a);
  void 0 === c && (c = 0.2 * b);
  this.line.scale.set(1, a, 1);
  this.line.updateMatrix();
  this.cone.scale.set(c, b, c);
  this.cone.position.y = a;
  this.cone.updateMatrix();
};
THREE.ArrowHelper.prototype.setColor = function (a) {
  this.line.material.color.setHex(a);
  this.cone.material.color.setHex(a);
};
THREE.BoxHelper = function (a) {
  var b = [
      new THREE.Vector3(1, 1, 1),
      new THREE.Vector3(-1, 1, 1),
      new THREE.Vector3(-1, -1, 1),
      new THREE.Vector3(1, -1, 1),
      new THREE.Vector3(1, 1, -1),
      new THREE.Vector3(-1, 1, -1),
      new THREE.Vector3(-1, -1, -1),
      new THREE.Vector3(1, -1, -1)
    ];
  this.vertices = b;
  var c = new THREE.Geometry();
  c.vertices.push(b[0], b[1], b[1], b[2], b[2], b[3], b[3], b[0], b[4], b[5], b[5], b[6], b[6], b[7], b[7], b[4], b[0], b[4], b[1], b[5], b[2], b[6], b[3], b[7]);
  THREE.Line.call(this, c, new THREE.LineBasicMaterial({ color: 16776960 }), THREE.LinePieces);
  void 0 !== a && this.update(a);
};
THREE.BoxHelper.prototype = Object.create(THREE.Line.prototype);
THREE.BoxHelper.prototype.update = function (a) {
  var b = a.geometry;
  null === b.boundingBox && b.computeBoundingBox();
  var c = b.boundingBox.min, b = b.boundingBox.max, d = this.vertices;
  d[0].set(b.x, b.y, b.z);
  d[1].set(c.x, b.y, b.z);
  d[2].set(c.x, c.y, b.z);
  d[3].set(b.x, c.y, b.z);
  d[4].set(b.x, b.y, c.z);
  d[5].set(c.x, b.y, c.z);
  d[6].set(c.x, c.y, c.z);
  d[7].set(b.x, c.y, c.z);
  this.geometry.computeBoundingSphere();
  this.geometry.verticesNeedUpdate = !0;
  this.matrixAutoUpdate = !1;
  this.matrixWorld = a.matrixWorld;
};
THREE.BoundingBoxHelper = function (a, b) {
  var c = void 0 !== b ? b : 8947848;
  this.object = a;
  this.box = new THREE.Box3();
  THREE.Mesh.call(this, new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({
    color: c,
    wireframe: !0
  }));
};
THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype);
THREE.BoundingBoxHelper.prototype.update = function () {
  this.box.setFromObject(this.object);
  this.box.size(this.scale);
  this.box.center(this.position);
};
THREE.CameraHelper = function (a) {
  function b(a, b, d) {
    c(a, d);
    c(b, d);
  }
  function c(a, b) {
    d.vertices.push(new THREE.Vector3());
    d.colors.push(new THREE.Color(b));
    void 0 === f[a] && (f[a] = []);
    f[a].push(d.vertices.length - 1);
  }
  var d = new THREE.Geometry(), e = new THREE.LineBasicMaterial({
      color: 16777215,
      vertexColors: THREE.FaceColors
    }), f = {};
  b('n1', 'n2', 16755200);
  b('n2', 'n4', 16755200);
  b('n4', 'n3', 16755200);
  b('n3', 'n1', 16755200);
  b('f1', 'f2', 16755200);
  b('f2', 'f4', 16755200);
  b('f4', 'f3', 16755200);
  b('f3', 'f1', 16755200);
  b('n1', 'f1', 16755200);
  b('n2', 'f2', 16755200);
  b('n3', 'f3', 16755200);
  b('n4', 'f4', 16755200);
  b('p', 'n1', 16711680);
  b('p', 'n2', 16711680);
  b('p', 'n3', 16711680);
  b('p', 'n4', 16711680);
  b('u1', 'u2', 43775);
  b('u2', 'u3', 43775);
  b('u3', 'u1', 43775);
  b('c', 't', 16777215);
  b('p', 'c', 3355443);
  b('cn1', 'cn2', 3355443);
  b('cn3', 'cn4', 3355443);
  b('cf1', 'cf2', 3355443);
  b('cf3', 'cf4', 3355443);
  THREE.Line.call(this, d, e, THREE.LinePieces);
  this.camera = a;
  this.matrixWorld = a.matrixWorld;
  this.matrixAutoUpdate = !1;
  this.pointMap = f;
  this.update();
};
THREE.CameraHelper.prototype = Object.create(THREE.Line.prototype);
THREE.CameraHelper.prototype.update = function () {
  var a = new THREE.Vector3(), b = new THREE.Camera(), c = new THREE.Projector();
  return function () {
    function d(d, g, h, k) {
      a.set(g, h, k);
      c.unprojectVector(a, b);
      d = e.pointMap[d];
      if (void 0 !== d)
        for (g = 0, h = d.length; g < h; g++)
          e.geometry.vertices[d[g]].copy(a);
    }
    var e = this;
    b.projectionMatrix.copy(this.camera.projectionMatrix);
    d('c', 0, 0, -1);
    d('t', 0, 0, 1);
    d('n1', -1, -1, -1);
    d('n2', 1, -1, -1);
    d('n3', -1, 1, -1);
    d('n4', 1, 1, -1);
    d('f1', -1, -1, 1);
    d('f2', 1, -1, 1);
    d('f3', -1, 1, 1);
    d('f4', 1, 1, 1);
    d('u1', 0.7, 1.1, -1);
    d('u2', -0.7, 1.1, -1);
    d('u3', 0, 2, -1);
    d('cf1', -1, 0, 1);
    d('cf2', 1, 0, 1);
    d('cf3', 0, -1, 1);
    d('cf4', 0, 1, 1);
    d('cn1', -1, 0, -1);
    d('cn2', 1, 0, -1);
    d('cn3', 0, -1, -1);
    d('cn4', 0, 1, -1);
    this.geometry.verticesNeedUpdate = !0;
  };
}();
THREE.DirectionalLightHelper = function (a, b) {
  THREE.Object3D.call(this);
  this.light = a;
  this.light.updateMatrixWorld();
  this.matrixWorld = a.matrixWorld;
  this.matrixAutoUpdate = !1;
  b = b || 1;
  var c = new THREE.PlaneGeometry(b, b), d = new THREE.MeshBasicMaterial({
      wireframe: !0,
      fog: !1
    });
  d.color.copy(this.light.color).multiplyScalar(this.light.intensity);
  this.lightPlane = new THREE.Mesh(c, d);
  this.add(this.lightPlane);
  c = new THREE.Geometry();
  c.vertices.push(new THREE.Vector3());
  c.vertices.push(new THREE.Vector3());
  d = new THREE.LineBasicMaterial({ fog: !1 });
  d.color.copy(this.light.color).multiplyScalar(this.light.intensity);
  this.targetLine = new THREE.Line(c, d);
  this.add(this.targetLine);
  this.update();
};
THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.DirectionalLightHelper.prototype.dispose = function () {
  this.lightPlane.geometry.dispose();
  this.lightPlane.material.dispose();
  this.targetLine.geometry.dispose();
  this.targetLine.material.dispose();
};
THREE.DirectionalLightHelper.prototype.update = function () {
  var a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Vector3();
  return function () {
    a.setFromMatrixPosition(this.light.matrixWorld);
    b.setFromMatrixPosition(this.light.target.matrixWorld);
    c.subVectors(b, a);
    this.lightPlane.lookAt(c);
    this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    this.targetLine.geometry.vertices[1].copy(c);
    this.targetLine.geometry.verticesNeedUpdate = !0;
    this.targetLine.material.color.copy(this.lightPlane.material.color);
  };
}();
THREE.EdgesHelper = function (a, b) {
  var c = void 0 !== b ? b : 16777215, d = [
      0,
      0
    ], e = {}, f = function (a, b) {
      return a - b;
    }, g = [
      'a',
      'b',
      'c'
    ], h = new THREE.BufferGeometry(), k = a.geometry.clone();
  k.mergeVertices();
  k.computeFaceNormals();
  for (var l = k.vertices, k = k.faces, n = 0, s = 0, r = k.length; s < r; s++)
    for (var q = k[s], u = 0; 3 > u; u++) {
      d[0] = q[g[u]];
      d[1] = q[g[(u + 1) % 3]];
      d.sort(f);
      var p = d.toString();
      void 0 === e[p] ? (e[p] = {
        vert1: d[0],
        vert2: d[1],
        face1: s,
        face2: void 0
      }, n++) : e[p].face2 = s;
    }
  h.addAttribute('position', Float32Array, 2 * n, 3);
  d = h.attributes.position.array;
  f = 0;
  for (p in e)
    if (g = e[p], void 0 === g.face2 || 0.9999 > k[g.face1].normal.dot(k[g.face2].normal))
      n = l[g.vert1], d[f++] = n.x, d[f++] = n.y, d[f++] = n.z, n = l[g.vert2], d[f++] = n.x, d[f++] = n.y, d[f++] = n.z;
  THREE.Line.call(this, h, new THREE.LineBasicMaterial({ color: c }), THREE.LinePieces);
  this.matrixAutoUpdate = !1;
  this.matrixWorld = a.matrixWorld;
};
THREE.EdgesHelper.prototype = Object.create(THREE.Line.prototype);
THREE.FaceNormalsHelper = function (a, b, c, d) {
  this.object = a;
  this.size = void 0 !== b ? b : 1;
  a = void 0 !== c ? c : 16776960;
  d = void 0 !== d ? d : 1;
  b = new THREE.Geometry();
  c = 0;
  for (var e = this.object.geometry.faces.length; c < e; c++)
    b.vertices.push(new THREE.Vector3()), b.vertices.push(new THREE.Vector3());
  THREE.Line.call(this, b, new THREE.LineBasicMaterial({
    color: a,
    linewidth: d
  }), THREE.LinePieces);
  this.matrixAutoUpdate = !1;
  this.normalMatrix = new THREE.Matrix3();
  this.update();
};
THREE.FaceNormalsHelper.prototype = Object.create(THREE.Line.prototype);
THREE.FaceNormalsHelper.prototype.update = function (a) {
  var b = new THREE.Vector3();
  return function (a) {
    this.object.updateMatrixWorld(!0);
    this.normalMatrix.getNormalMatrix(this.object.matrixWorld);
    a = this.geometry.vertices;
    for (var d = this.object.geometry.faces, e = this.object.matrixWorld, f = 0, g = d.length; f < g; f++) {
      var h = d[f];
      b.copy(h.normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);
      var k = 2 * f;
      a[k].copy(h.centroid).applyMatrix4(e);
      a[k + 1].addVectors(a[k], b);
    }
    this.geometry.verticesNeedUpdate = !0;
    return this;
  };
}();
THREE.GridHelper = function (a, b) {
  var c = new THREE.Geometry(), d = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors });
  this.color1 = new THREE.Color(4473924);
  this.color2 = new THREE.Color(8947848);
  for (var e = -a; e <= a; e += b) {
    c.vertices.push(new THREE.Vector3(-a, 0, e), new THREE.Vector3(a, 0, e), new THREE.Vector3(e, 0, -a), new THREE.Vector3(e, 0, a));
    var f = 0 === e ? this.color1 : this.color2;
    c.colors.push(f, f, f, f);
  }
  THREE.Line.call(this, c, d, THREE.LinePieces);
};
THREE.GridHelper.prototype = Object.create(THREE.Line.prototype);
THREE.GridHelper.prototype.setColors = function (a, b) {
  this.color1.set(a);
  this.color2.set(b);
  this.geometry.colorsNeedUpdate = !0;
};
THREE.HemisphereLightHelper = function (a, b, c, d) {
  THREE.Object3D.call(this);
  this.light = a;
  this.light.updateMatrixWorld();
  this.matrixWorld = a.matrixWorld;
  this.matrixAutoUpdate = !1;
  this.colors = [
    new THREE.Color(),
    new THREE.Color()
  ];
  a = new THREE.SphereGeometry(b, 4, 2);
  a.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
  for (b = 0; 8 > b; b++)
    a.faces[b].color = this.colors[4 > b ? 0 : 1];
  b = new THREE.MeshBasicMaterial({
    vertexColors: THREE.FaceColors,
    wireframe: !0
  });
  this.lightSphere = new THREE.Mesh(a, b);
  this.add(this.lightSphere);
  this.update();
};
THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.HemisphereLightHelper.prototype.dispose = function () {
  this.lightSphere.geometry.dispose();
  this.lightSphere.material.dispose();
};
THREE.HemisphereLightHelper.prototype.update = function () {
  var a = new THREE.Vector3();
  return function () {
    this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity);
    this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity);
    this.lightSphere.lookAt(a.setFromMatrixPosition(this.light.matrixWorld).negate());
    this.lightSphere.geometry.colorsNeedUpdate = !0;
  };
}();
THREE.PointLightHelper = function (a, b) {
  this.light = a;
  this.light.updateMatrixWorld();
  var c = new THREE.SphereGeometry(b, 4, 2), d = new THREE.MeshBasicMaterial({
      wireframe: !0,
      fog: !1
    });
  d.color.copy(this.light.color).multiplyScalar(this.light.intensity);
  THREE.Mesh.call(this, c, d);
  this.matrixWorld = this.light.matrixWorld;
  this.matrixAutoUpdate = !1;
};
THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype);
THREE.PointLightHelper.prototype.dispose = function () {
  this.geometry.dispose();
  this.material.dispose();
};
THREE.PointLightHelper.prototype.update = function () {
  this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
};
THREE.SpotLightHelper = function (a) {
  THREE.Object3D.call(this);
  this.light = a;
  this.light.updateMatrixWorld();
  this.matrixWorld = a.matrixWorld;
  this.matrixAutoUpdate = !1;
  a = new THREE.CylinderGeometry(0, 1, 1, 8, 1, !0);
  a.applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.5, 0));
  a.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
  var b = new THREE.MeshBasicMaterial({
      wireframe: !0,
      fog: !1
    });
  this.cone = new THREE.Mesh(a, b);
  this.add(this.cone);
  this.update();
};
THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.SpotLightHelper.prototype.dispose = function () {
  this.cone.geometry.dispose();
  this.cone.material.dispose();
};
THREE.SpotLightHelper.prototype.update = function () {
  var a = new THREE.Vector3(), b = new THREE.Vector3();
  return function () {
    var c = this.light.distance ? this.light.distance : 10000, d = c * Math.tan(this.light.angle);
    this.cone.scale.set(d, d, c);
    a.setFromMatrixPosition(this.light.matrixWorld);
    b.setFromMatrixPosition(this.light.target.matrixWorld);
    this.cone.lookAt(b.sub(a));
    this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
  };
}();
THREE.VertexNormalsHelper = function (a, b, c, d) {
  this.object = a;
  this.size = void 0 !== b ? b : 1;
  b = void 0 !== c ? c : 16711680;
  d = void 0 !== d ? d : 1;
  c = new THREE.Geometry();
  a = a.geometry.faces;
  for (var e = 0, f = a.length; e < f; e++)
    for (var g = 0, h = a[e].vertexNormals.length; g < h; g++)
      c.vertices.push(new THREE.Vector3()), c.vertices.push(new THREE.Vector3());
  THREE.Line.call(this, c, new THREE.LineBasicMaterial({
    color: b,
    linewidth: d
  }), THREE.LinePieces);
  this.matrixAutoUpdate = !1;
  this.normalMatrix = new THREE.Matrix3();
  this.update();
};
THREE.VertexNormalsHelper.prototype = Object.create(THREE.Line.prototype);
THREE.VertexNormalsHelper.prototype.update = function (a) {
  var b = new THREE.Vector3();
  return function (a) {
    a = [
      'a',
      'b',
      'c',
      'd'
    ];
    this.object.updateMatrixWorld(!0);
    this.normalMatrix.getNormalMatrix(this.object.matrixWorld);
    for (var d = this.geometry.vertices, e = this.object.geometry.vertices, f = this.object.geometry.faces, g = this.object.matrixWorld, h = 0, k = 0, l = f.length; k < l; k++)
      for (var n = f[k], s = 0, r = n.vertexNormals.length; s < r; s++) {
        var q = n.vertexNormals[s];
        d[h].copy(e[n[a[s]]]).applyMatrix4(g);
        b.copy(q).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);
        b.add(d[h]);
        h += 1;
        d[h].copy(b);
        h += 1;
      }
    this.geometry.verticesNeedUpdate = !0;
    return this;
  };
}();
THREE.VertexTangentsHelper = function (a, b, c, d) {
  this.object = a;
  this.size = void 0 !== b ? b : 1;
  b = void 0 !== c ? c : 255;
  d = void 0 !== d ? d : 1;
  c = new THREE.Geometry();
  a = a.geometry.faces;
  for (var e = 0, f = a.length; e < f; e++)
    for (var g = 0, h = a[e].vertexTangents.length; g < h; g++)
      c.vertices.push(new THREE.Vector3()), c.vertices.push(new THREE.Vector3());
  THREE.Line.call(this, c, new THREE.LineBasicMaterial({
    color: b,
    linewidth: d
  }), THREE.LinePieces);
  this.matrixAutoUpdate = !1;
  this.update();
};
THREE.VertexTangentsHelper.prototype = Object.create(THREE.Line.prototype);
THREE.VertexTangentsHelper.prototype.update = function (a) {
  var b = new THREE.Vector3();
  return function (a) {
    a = [
      'a',
      'b',
      'c',
      'd'
    ];
    this.object.updateMatrixWorld(!0);
    for (var d = this.geometry.vertices, e = this.object.geometry.vertices, f = this.object.geometry.faces, g = this.object.matrixWorld, h = 0, k = 0, l = f.length; k < l; k++)
      for (var n = f[k], s = 0, r = n.vertexTangents.length; s < r; s++) {
        var q = n.vertexTangents[s];
        d[h].copy(e[n[a[s]]]).applyMatrix4(g);
        b.copy(q).transformDirection(g).multiplyScalar(this.size);
        b.add(d[h]);
        h += 1;
        d[h].copy(b);
        h += 1;
      }
    this.geometry.verticesNeedUpdate = !0;
    return this;
  };
}();
THREE.WireframeHelper = function (a, b) {
  var c = void 0 !== b ? b : 16777215, d = [
      0,
      0
    ], e = {}, f = function (a, b) {
      return a - b;
    }, g = [
      'a',
      'b',
      'c'
    ], h = new THREE.BufferGeometry();
  if (a.geometry instanceof THREE.Geometry) {
    for (var k = a.geometry.vertices, l = a.geometry.faces, n = 0, s = new Uint32Array(6 * l.length), r = 0, q = l.length; r < q; r++)
      for (var u = l[r], p = 0; 3 > p; p++) {
        d[0] = u[g[p]];
        d[1] = u[g[(p + 1) % 3]];
        d.sort(f);
        var v = d.toString();
        void 0 === e[v] && (s[2 * n] = d[0], s[2 * n + 1] = d[1], e[v] = !0, n++);
      }
    h.addAttribute('position', Float32Array, 2 * n, 3);
    d = h.attributes.position.array;
    r = 0;
    for (q = n; r < q; r++)
      for (p = 0; 2 > p; p++)
        n = k[s[2 * r + p]], g = 6 * r + 3 * p, d[g + 0] = n.x, d[g + 1] = n.y, d[g + 2] = n.z;
  } else if (a.geometry instanceof THREE.BufferGeometry && void 0 !== a.geometry.attributes.index) {
    for (var k = a.geometry.attributes.position.array, q = a.geometry.attributes.index.array, l = a.geometry.offsets, n = 0, s = new Uint32Array(2 * q.length), u = 0, w = l.length; u < w; ++u)
      for (var p = l[u].start, v = l[u].count, g = l[u].index, r = p, t = p + v; r < t; r += 3)
        for (p = 0; 3 > p; p++)
          d[0] = g + q[r + p], d[1] = g + q[r + (p + 1) % 3], d.sort(f), v = d.toString(), void 0 === e[v] && (s[2 * n] = d[0], s[2 * n + 1] = d[1], e[v] = !0, n++);
    h.addAttribute('position', Float32Array, 2 * n, 3);
    d = h.attributes.position.array;
    r = 0;
    for (q = n; r < q; r++)
      for (p = 0; 2 > p; p++)
        g = 6 * r + 3 * p, n = 3 * s[2 * r + p], d[g + 0] = k[n], d[g + 1] = k[n + 1], d[g + 2] = k[n + 2];
  } else if (a.geometry instanceof THREE.BufferGeometry)
    for (k = a.geometry.attributes.position.array, n = k.length / 3, s = n / 3, h.addAttribute('position', Float32Array, 2 * n, 3), d = h.attributes.position.array, r = 0, q = s; r < q; r++)
      for (p = 0; 3 > p; p++)
        g = 18 * r + 6 * p, s = 9 * r + 3 * p, d[g + 0] = k[s], d[g + 1] = k[s + 1], d[g + 2] = k[s + 2], n = 9 * r + (p + 1) % 3 * 3, d[g + 3] = k[n], d[g + 4] = k[n + 1], d[g + 5] = k[n + 2];
  THREE.Line.call(this, h, new THREE.LineBasicMaterial({ color: c }), THREE.LinePieces);
  this.matrixAutoUpdate = !1;
  this.matrixWorld = a.matrixWorld;
};
THREE.WireframeHelper.prototype = Object.create(THREE.Line.prototype);
THREE.ImmediateRenderObject = function () {
  THREE.Object3D.call(this);
  this.render = function (a) {
  };
};
THREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype);
THREE.LensFlare = function (a, b, c, d, e) {
  THREE.Object3D.call(this);
  this.lensFlares = [];
  this.positionScreen = new THREE.Vector3();
  this.customUpdateCallback = void 0;
  void 0 !== a && this.add(a, b, c, d, e);
};
THREE.LensFlare.prototype = Object.create(THREE.Object3D.prototype);
THREE.LensFlare.prototype.add = function (a, b, c, d, e, f) {
  void 0 === b && (b = -1);
  void 0 === c && (c = 0);
  void 0 === f && (f = 1);
  void 0 === e && (e = new THREE.Color(16777215));
  void 0 === d && (d = THREE.NormalBlending);
  c = Math.min(c, Math.max(0, c));
  this.lensFlares.push({
    texture: a,
    size: b,
    distance: c,
    x: 0,
    y: 0,
    z: 0,
    scale: 1,
    rotation: 1,
    opacity: f,
    color: e,
    blending: d
  });
};
THREE.LensFlare.prototype.updateLensFlares = function () {
  var a, b = this.lensFlares.length, c, d = 2 * -this.positionScreen.x, e = 2 * -this.positionScreen.y;
  for (a = 0; a < b; a++)
    c = this.lensFlares[a], c.x = this.positionScreen.x + d * c.distance, c.y = this.positionScreen.y + e * c.distance, c.wantedRotation = c.x * Math.PI * 0.25, c.rotation += 0.25 * (c.wantedRotation - c.rotation);
};
THREE.MorphBlendMesh = function (a, b) {
  THREE.Mesh.call(this, a, b);
  this.animationsMap = {};
  this.animationsList = [];
  var c = this.geometry.morphTargets.length;
  this.createAnimation('__default', 0, c - 1, c / 1);
  this.setAnimationWeight('__default', 1);
};
THREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype);
THREE.MorphBlendMesh.prototype.createAnimation = function (a, b, c, d) {
  b = {
    startFrame: b,
    endFrame: c,
    length: c - b + 1,
    fps: d,
    duration: (c - b) / d,
    lastFrame: 0,
    currentFrame: 0,
    active: !1,
    time: 0,
    direction: 1,
    weight: 1,
    directionBackwards: !1,
    mirroredLoop: !1
  };
  this.animationsMap[a] = b;
  this.animationsList.push(b);
};
THREE.MorphBlendMesh.prototype.autoCreateAnimations = function (a) {
  for (var b = /([a-z]+)(\d+)/, c, d = {}, e = this.geometry, f = 0, g = e.morphTargets.length; f < g; f++) {
    var h = e.morphTargets[f].name.match(b);
    if (h && 1 < h.length) {
      var k = h[1];
      d[k] || (d[k] = {
        start: Infinity,
        end: -Infinity
      });
      h = d[k];
      f < h.start && (h.start = f);
      f > h.end && (h.end = f);
      c || (c = k);
    }
  }
  for (k in d)
    h = d[k], this.createAnimation(k, h.start, h.end, a);
  this.firstAnimation = c;
};
THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function (a) {
  if (a = this.animationsMap[a])
    a.direction = 1, a.directionBackwards = !1;
};
THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function (a) {
  if (a = this.animationsMap[a])
    a.direction = -1, a.directionBackwards = !0;
};
THREE.MorphBlendMesh.prototype.setAnimationFPS = function (a, b) {
  var c = this.animationsMap[a];
  c && (c.fps = b, c.duration = (c.end - c.start) / c.fps);
};
THREE.MorphBlendMesh.prototype.setAnimationDuration = function (a, b) {
  var c = this.animationsMap[a];
  c && (c.duration = b, c.fps = (c.end - c.start) / c.duration);
};
THREE.MorphBlendMesh.prototype.setAnimationWeight = function (a, b) {
  var c = this.animationsMap[a];
  c && (c.weight = b);
};
THREE.MorphBlendMesh.prototype.setAnimationTime = function (a, b) {
  var c = this.animationsMap[a];
  c && (c.time = b);
};
THREE.MorphBlendMesh.prototype.getAnimationTime = function (a) {
  var b = 0;
  if (a = this.animationsMap[a])
    b = a.time;
  return b;
};
THREE.MorphBlendMesh.prototype.getAnimationDuration = function (a) {
  var b = -1;
  if (a = this.animationsMap[a])
    b = a.duration;
  return b;
};
THREE.MorphBlendMesh.prototype.playAnimation = function (a) {
  var b = this.animationsMap[a];
  b ? (b.time = 0, b.active = !0) : console.warn('animation[' + a + '] undefined');
};
THREE.MorphBlendMesh.prototype.stopAnimation = function (a) {
  if (a = this.animationsMap[a])
    a.active = !1;
};
THREE.MorphBlendMesh.prototype.update = function (a) {
  for (var b = 0, c = this.animationsList.length; b < c; b++) {
    var d = this.animationsList[b];
    if (d.active) {
      var e = d.duration / d.length;
      d.time += d.direction * a;
      if (d.mirroredLoop) {
        if (d.time > d.duration || 0 > d.time)
          d.direction *= -1, d.time > d.duration && (d.time = d.duration, d.directionBackwards = !0), 0 > d.time && (d.time = 0, d.directionBackwards = !1);
      } else
        d.time %= d.duration, 0 > d.time && (d.time += d.duration);
      var f = d.startFrame + THREE.Math.clamp(Math.floor(d.time / e), 0, d.length - 1), g = d.weight;
      f !== d.currentFrame && (this.morphTargetInfluences[d.lastFrame] = 0, this.morphTargetInfluences[d.currentFrame] = 1 * g, this.morphTargetInfluences[f] = 0, d.lastFrame = d.currentFrame, d.currentFrame = f);
      e = d.time % e / e;
      d.directionBackwards && (e = 1 - e);
      this.morphTargetInfluences[d.currentFrame] = e * g;
      this.morphTargetInfluences[d.lastFrame] = (1 - e) * g;
    }
  }
};
THREE.LensFlarePlugin = function () {
  function a(a, c) {
    var d = b.createProgram(), e = b.createShader(b.FRAGMENT_SHADER), f = b.createShader(b.VERTEX_SHADER), g = 'precision ' + c + ' float;\n';
    b.shaderSource(e, g + a.fragmentShader);
    b.shaderSource(f, g + a.vertexShader);
    b.compileShader(e);
    b.compileShader(f);
    b.attachShader(d, e);
    b.attachShader(d, f);
    b.linkProgram(d);
    return d;
  }
  var b, c, d, e, f, g, h, k, l, n, s, r, q;
  this.init = function (u) {
    b = u.context;
    c = u;
    d = u.getPrecision();
    e = new Float32Array(16);
    f = new Uint16Array(6);
    u = 0;
    e[u++] = -1;
    e[u++] = -1;
    e[u++] = 0;
    e[u++] = 0;
    e[u++] = 1;
    e[u++] = -1;
    e[u++] = 1;
    e[u++] = 0;
    e[u++] = 1;
    e[u++] = 1;
    e[u++] = 1;
    e[u++] = 1;
    e[u++] = -1;
    e[u++] = 1;
    e[u++] = 0;
    e[u++] = 1;
    u = 0;
    f[u++] = 0;
    f[u++] = 1;
    f[u++] = 2;
    f[u++] = 0;
    f[u++] = 2;
    f[u++] = 3;
    g = b.createBuffer();
    h = b.createBuffer();
    b.bindBuffer(b.ARRAY_BUFFER, g);
    b.bufferData(b.ARRAY_BUFFER, e, b.STATIC_DRAW);
    b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, h);
    b.bufferData(b.ELEMENT_ARRAY_BUFFER, f, b.STATIC_DRAW);
    k = b.createTexture();
    l = b.createTexture();
    b.bindTexture(b.TEXTURE_2D, k);
    b.texImage2D(b.TEXTURE_2D, 0, b.RGB, 16, 16, 0, b.RGB, b.UNSIGNED_BYTE, null);
    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE);
    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE);
    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.NEAREST);
    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.NEAREST);
    b.bindTexture(b.TEXTURE_2D, l);
    b.texImage2D(b.TEXTURE_2D, 0, b.RGBA, 16, 16, 0, b.RGBA, b.UNSIGNED_BYTE, null);
    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE);
    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE);
    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.NEAREST);
    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.NEAREST);
    0 >= b.getParameter(b.MAX_VERTEX_TEXTURE_IMAGE_UNITS) ? (n = !1, s = a(THREE.ShaderFlares.lensFlare, d)) : (n = !0, s = a(THREE.ShaderFlares.lensFlareVertexTexture, d));
    r = {};
    q = {};
    r.vertex = b.getAttribLocation(s, 'position');
    r.uv = b.getAttribLocation(s, 'uv');
    q.renderType = b.getUniformLocation(s, 'renderType');
    q.map = b.getUniformLocation(s, 'map');
    q.occlusionMap = b.getUniformLocation(s, 'occlusionMap');
    q.opacity = b.getUniformLocation(s, 'opacity');
    q.color = b.getUniformLocation(s, 'color');
    q.scale = b.getUniformLocation(s, 'scale');
    q.rotation = b.getUniformLocation(s, 'rotation');
    q.screenPosition = b.getUniformLocation(s, 'screenPosition');
  };
  this.render = function (a, d, e, f) {
    a = a.__webglFlares;
    var t = a.length;
    if (t) {
      var x = new THREE.Vector3(), z = f / e, B = 0.5 * e, E = 0.5 * f, H = 16 / f, D = new THREE.Vector2(H * z, H), G = new THREE.Vector3(1, 1, 0), I = new THREE.Vector2(1, 1), O = q, H = r;
      b.useProgram(s);
      b.enableVertexAttribArray(r.vertex);
      b.enableVertexAttribArray(r.uv);
      b.uniform1i(O.occlusionMap, 0);
      b.uniform1i(O.map, 1);
      b.bindBuffer(b.ARRAY_BUFFER, g);
      b.vertexAttribPointer(H.vertex, 2, b.FLOAT, !1, 16, 0);
      b.vertexAttribPointer(H.uv, 2, b.FLOAT, !1, 16, 8);
      b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, h);
      b.disable(b.CULL_FACE);
      b.depthMask(!1);
      var K, y, F, C, A;
      for (K = 0; K < t; K++)
        if (H = 16 / f, D.set(H * z, H), C = a[K], x.set(C.matrixWorld.elements[12], C.matrixWorld.elements[13], C.matrixWorld.elements[14]), x.applyMatrix4(d.matrixWorldInverse), x.applyProjection(d.projectionMatrix), G.copy(x), I.x = G.x * B + B, I.y = G.y * E + E, n || 0 < I.x && I.x < e && 0 < I.y && I.y < f)
          for (b.activeTexture(b.TEXTURE1), b.bindTexture(b.TEXTURE_2D, k), b.copyTexImage2D(b.TEXTURE_2D, 0, b.RGB, I.x - 8, I.y - 8, 16, 16, 0), b.uniform1i(O.renderType, 0), b.uniform2f(O.scale, D.x, D.y), b.uniform3f(O.screenPosition, G.x, G.y, G.z), b.disable(b.BLEND), b.enable(b.DEPTH_TEST), b.drawElements(b.TRIANGLES, 6, b.UNSIGNED_SHORT, 0), b.activeTexture(b.TEXTURE0), b.bindTexture(b.TEXTURE_2D, l), b.copyTexImage2D(b.TEXTURE_2D, 0, b.RGBA, I.x - 8, I.y - 8, 16, 16, 0), b.uniform1i(O.renderType, 1), b.disable(b.DEPTH_TEST), b.activeTexture(b.TEXTURE1), b.bindTexture(b.TEXTURE_2D, k), b.drawElements(b.TRIANGLES, 6, b.UNSIGNED_SHORT, 0), C.positionScreen.copy(G), C.customUpdateCallback ? C.customUpdateCallback(C) : C.updateLensFlares(), b.uniform1i(O.renderType, 2), b.enable(b.BLEND), y = 0, F = C.lensFlares.length; y < F; y++)
            A = C.lensFlares[y], 0.001 < A.opacity && 0.001 < A.scale && (G.x = A.x, G.y = A.y, G.z = A.z, H = A.size * A.scale / f, D.x = H * z, D.y = H, b.uniform3f(O.screenPosition, G.x, G.y, G.z), b.uniform2f(O.scale, D.x, D.y), b.uniform1f(O.rotation, A.rotation), b.uniform1f(O.opacity, A.opacity), b.uniform3f(O.color, A.color.r, A.color.g, A.color.b), c.setBlending(A.blending, A.blendEquation, A.blendSrc, A.blendDst), c.setTexture(A.texture, 1), b.drawElements(b.TRIANGLES, 6, b.UNSIGNED_SHORT, 0));
      b.enable(b.CULL_FACE);
      b.enable(b.DEPTH_TEST);
      b.depthMask(!0);
    }
  };
};
THREE.ShadowMapPlugin = function () {
  var a, b, c, d, e, f, g = new THREE.Frustum(), h = new THREE.Matrix4(), k = new THREE.Vector3(), l = new THREE.Vector3(), n = new THREE.Vector3();
  this.init = function (g) {
    a = g.context;
    b = g;
    g = THREE.ShaderLib.depthRGBA;
    var h = THREE.UniformsUtils.clone(g.uniforms);
    c = new THREE.ShaderMaterial({
      fragmentShader: g.fragmentShader,
      vertexShader: g.vertexShader,
      uniforms: h
    });
    d = new THREE.ShaderMaterial({
      fragmentShader: g.fragmentShader,
      vertexShader: g.vertexShader,
      uniforms: h,
      morphTargets: !0
    });
    e = new THREE.ShaderMaterial({
      fragmentShader: g.fragmentShader,
      vertexShader: g.vertexShader,
      uniforms: h,
      skinning: !0
    });
    f = new THREE.ShaderMaterial({
      fragmentShader: g.fragmentShader,
      vertexShader: g.vertexShader,
      uniforms: h,
      morphTargets: !0,
      skinning: !0
    });
    c._shadowPass = !0;
    d._shadowPass = !0;
    e._shadowPass = !0;
    f._shadowPass = !0;
  };
  this.render = function (a, c) {
    b.shadowMapEnabled && b.shadowMapAutoUpdate && this.update(a, c);
  };
  this.update = function (s, r) {
    var q, u, p, v, w, t, x, z, B, E = [];
    v = 0;
    a.clearColor(1, 1, 1, 1);
    a.disable(a.BLEND);
    a.enable(a.CULL_FACE);
    a.frontFace(a.CCW);
    b.shadowMapCullFace === THREE.CullFaceFront ? a.cullFace(a.FRONT) : a.cullFace(a.BACK);
    b.setDepthTest(!0);
    q = 0;
    for (u = s.__lights.length; q < u; q++)
      if (p = s.__lights[q], p.castShadow)
        if (p instanceof THREE.DirectionalLight && p.shadowCascade)
          for (w = 0; w < p.shadowCascadeCount; w++) {
            var H;
            if (p.shadowCascadeArray[w])
              H = p.shadowCascadeArray[w];
            else {
              B = p;
              x = w;
              H = new THREE.DirectionalLight();
              H.isVirtual = !0;
              H.onlyShadow = !0;
              H.castShadow = !0;
              H.shadowCameraNear = B.shadowCameraNear;
              H.shadowCameraFar = B.shadowCameraFar;
              H.shadowCameraLeft = B.shadowCameraLeft;
              H.shadowCameraRight = B.shadowCameraRight;
              H.shadowCameraBottom = B.shadowCameraBottom;
              H.shadowCameraTop = B.shadowCameraTop;
              H.shadowCameraVisible = B.shadowCameraVisible;
              H.shadowDarkness = B.shadowDarkness;
              H.shadowBias = B.shadowCascadeBias[x];
              H.shadowMapWidth = B.shadowCascadeWidth[x];
              H.shadowMapHeight = B.shadowCascadeHeight[x];
              H.pointsWorld = [];
              H.pointsFrustum = [];
              z = H.pointsWorld;
              t = H.pointsFrustum;
              for (var D = 0; 8 > D; D++)
                z[D] = new THREE.Vector3(), t[D] = new THREE.Vector3();
              z = B.shadowCascadeNearZ[x];
              B = B.shadowCascadeFarZ[x];
              t[0].set(-1, -1, z);
              t[1].set(1, -1, z);
              t[2].set(-1, 1, z);
              t[3].set(1, 1, z);
              t[4].set(-1, -1, B);
              t[5].set(1, -1, B);
              t[6].set(-1, 1, B);
              t[7].set(1, 1, B);
              H.originalCamera = r;
              t = new THREE.Gyroscope();
              t.position = p.shadowCascadeOffset;
              t.add(H);
              t.add(H.target);
              r.add(t);
              p.shadowCascadeArray[w] = H;
              console.log('Created virtualLight', H);
            }
            x = p;
            z = w;
            B = x.shadowCascadeArray[z];
            B.position.copy(x.position);
            B.target.position.copy(x.target.position);
            B.lookAt(B.target);
            B.shadowCameraVisible = x.shadowCameraVisible;
            B.shadowDarkness = x.shadowDarkness;
            B.shadowBias = x.shadowCascadeBias[z];
            t = x.shadowCascadeNearZ[z];
            x = x.shadowCascadeFarZ[z];
            B = B.pointsFrustum;
            B[0].z = t;
            B[1].z = t;
            B[2].z = t;
            B[3].z = t;
            B[4].z = x;
            B[5].z = x;
            B[6].z = x;
            B[7].z = x;
            E[v] = H;
            v++;
          }
        else
          E[v] = p, v++;
    q = 0;
    for (u = E.length; q < u; q++) {
      p = E[q];
      p.shadowMap || (w = THREE.LinearFilter, b.shadowMapType === THREE.PCFSoftShadowMap && (w = THREE.NearestFilter), p.shadowMap = new THREE.WebGLRenderTarget(p.shadowMapWidth, p.shadowMapHeight, {
        minFilter: w,
        magFilter: w,
        format: THREE.RGBAFormat
      }), p.shadowMapSize = new THREE.Vector2(p.shadowMapWidth, p.shadowMapHeight), p.shadowMatrix = new THREE.Matrix4());
      if (!p.shadowCamera) {
        if (p instanceof THREE.SpotLight)
          p.shadowCamera = new THREE.PerspectiveCamera(p.shadowCameraFov, p.shadowMapWidth / p.shadowMapHeight, p.shadowCameraNear, p.shadowCameraFar);
        else if (p instanceof THREE.DirectionalLight)
          p.shadowCamera = new THREE.OrthographicCamera(p.shadowCameraLeft, p.shadowCameraRight, p.shadowCameraTop, p.shadowCameraBottom, p.shadowCameraNear, p.shadowCameraFar);
        else {
          console.error('Unsupported light type for shadow');
          continue;
        }
        s.add(p.shadowCamera);
        !0 === s.autoUpdate && s.updateMatrixWorld();
      }
      p.shadowCameraVisible && !p.cameraHelper && (p.cameraHelper = new THREE.CameraHelper(p.shadowCamera), p.shadowCamera.add(p.cameraHelper));
      if (p.isVirtual && H.originalCamera == r) {
        w = r;
        v = p.shadowCamera;
        t = p.pointsFrustum;
        B = p.pointsWorld;
        k.set(Infinity, Infinity, Infinity);
        l.set(-Infinity, -Infinity, -Infinity);
        for (x = 0; 8 > x; x++)
          z = B[x], z.copy(t[x]), THREE.ShadowMapPlugin.__projector.unprojectVector(z, w), z.applyMatrix4(v.matrixWorldInverse), z.x < k.x && (k.x = z.x), z.x > l.x && (l.x = z.x), z.y < k.y && (k.y = z.y), z.y > l.y && (l.y = z.y), z.z < k.z && (k.z = z.z), z.z > l.z && (l.z = z.z);
        v.left = k.x;
        v.right = l.x;
        v.top = l.y;
        v.bottom = k.y;
        v.updateProjectionMatrix();
      }
      v = p.shadowMap;
      t = p.shadowMatrix;
      w = p.shadowCamera;
      w.position.setFromMatrixPosition(p.matrixWorld);
      n.setFromMatrixPosition(p.target.matrixWorld);
      w.lookAt(n);
      w.updateMatrixWorld();
      w.matrixWorldInverse.getInverse(w.matrixWorld);
      p.cameraHelper && (p.cameraHelper.visible = p.shadowCameraVisible);
      p.shadowCameraVisible && p.cameraHelper.update();
      t.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
      t.multiply(w.projectionMatrix);
      t.multiply(w.matrixWorldInverse);
      h.multiplyMatrices(w.projectionMatrix, w.matrixWorldInverse);
      g.setFromMatrix(h);
      b.setRenderTarget(v);
      b.clear();
      B = s.__webglObjects;
      p = 0;
      for (v = B.length; p < v; p++)
        x = B[p], t = x.object, x.render = !1, !t.visible || !t.castShadow || (t instanceof THREE.Mesh || t instanceof THREE.ParticleSystem) && t.frustumCulled && !g.intersectsObject(t) || (t._modelViewMatrix.multiplyMatrices(w.matrixWorldInverse, t.matrixWorld), x.render = !0);
      p = 0;
      for (v = B.length; p < v; p++)
        x = B[p], x.render && (t = x.object, x = x.buffer, D = t.material instanceof THREE.MeshFaceMaterial ? t.material.materials[0] : t.material, z = void 0 !== t.geometry.morphTargets && 0 < t.geometry.morphTargets.length && D.morphTargets, D = t instanceof THREE.SkinnedMesh && D.skinning, z = t.customDepthMaterial ? t.customDepthMaterial : D ? z ? f : e : z ? d : c, x instanceof THREE.BufferGeometry ? b.renderBufferDirect(w, s.__lights, null, z, x, t) : b.renderBuffer(w, s.__lights, null, z, x, t));
      B = s.__webglObjectsImmediate;
      p = 0;
      for (v = B.length; p < v; p++)
        x = B[p], t = x.object, t.visible && t.castShadow && (t._modelViewMatrix.multiplyMatrices(w.matrixWorldInverse, t.matrixWorld), b.renderImmediateObject(w, s.__lights, null, c, t));
    }
    q = b.getClearColor();
    u = b.getClearAlpha();
    a.clearColor(q.r, q.g, q.b, u);
    a.enable(a.BLEND);
    b.shadowMapCullFace === THREE.CullFaceFront && a.cullFace(a.BACK);
  };
};
THREE.ShadowMapPlugin.__projector = new THREE.Projector();
THREE.SpritePlugin = function () {
  var a, b, c, d, e, f, g, h, k, l, n, s, r, q, u, p, v;
  function w(a, b) {
    return a.z !== b.z ? b.z - a.z : b.id - a.id;
  }
  var t, x, z, B, E, H, D, G;
  this.init = function (w) {
    t = w.context;
    x = w;
    B = new Float32Array([
      -0.5,
      -0.5,
      0,
      0,
      0.5,
      -0.5,
      1,
      0,
      0.5,
      0.5,
      1,
      1,
      -0.5,
      0.5,
      0,
      1
    ]);
    E = new Uint16Array([
      0,
      1,
      2,
      0,
      2,
      3
    ]);
    H = t.createBuffer();
    D = t.createBuffer();
    t.bindBuffer(t.ARRAY_BUFFER, H);
    t.bufferData(t.ARRAY_BUFFER, B, t.STATIC_DRAW);
    t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, D);
    t.bufferData(t.ELEMENT_ARRAY_BUFFER, E, t.STATIC_DRAW);
    w = t.createProgram();
    var O = t.createShader(t.VERTEX_SHADER), K = t.createShader(t.FRAGMENT_SHADER);
    t.shaderSource(O, [
      'precision ' + x.getPrecision() + ' float;',
      'uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 scale;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uvOffset + uv * uvScale;\nvec2 alignedPosition = position * scale;\nvec2 rotatedPosition;\nrotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\nrotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\nvec4 finalPosition;\nfinalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\nfinalPosition.xy += rotatedPosition;\nfinalPosition = projectionMatrix * finalPosition;\ngl_Position = finalPosition;\n}'
    ].join('\n'));
    t.shaderSource(K, [
      'precision ' + x.getPrecision() + ' float;',
      'uniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nuniform int fogType;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\nvarying vec2 vUV;\nvoid main() {\nvec4 texture = texture2D( map, vUV );\nif ( texture.a < alphaTest ) discard;\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\nif ( fogType > 0 ) {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat fogFactor = 0.0;\nif ( fogType == 1 ) {\nfogFactor = smoothstep( fogNear, fogFar, depth );\n} else {\nconst float LOG2 = 1.442695;\nfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n}\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n}\n}'
    ].join('\n'));
    t.compileShader(O);
    t.compileShader(K);
    t.attachShader(w, O);
    t.attachShader(w, K);
    t.linkProgram(w);
    G = w;
    p = t.getAttribLocation(G, 'position');
    v = t.getAttribLocation(G, 'uv');
    a = t.getUniformLocation(G, 'uvOffset');
    b = t.getUniformLocation(G, 'uvScale');
    c = t.getUniformLocation(G, 'rotation');
    d = t.getUniformLocation(G, 'scale');
    e = t.getUniformLocation(G, 'color');
    f = t.getUniformLocation(G, 'map');
    g = t.getUniformLocation(G, 'opacity');
    h = t.getUniformLocation(G, 'modelViewMatrix');
    k = t.getUniformLocation(G, 'projectionMatrix');
    l = t.getUniformLocation(G, 'fogType');
    n = t.getUniformLocation(G, 'fogDensity');
    s = t.getUniformLocation(G, 'fogNear');
    r = t.getUniformLocation(G, 'fogFar');
    q = t.getUniformLocation(G, 'fogColor');
    u = t.getUniformLocation(G, 'alphaTest');
    w = document.createElement('canvas');
    w.width = 8;
    w.height = 8;
    O = w.getContext('2d');
    O.fillStyle = '#ffffff';
    O.fillRect(0, 0, w.width, w.height);
    z = new THREE.Texture(w);
    z.needsUpdate = !0;
  };
  this.render = function (E, B, K, y) {
    K = E.__webglSprites;
    if (y = K.length) {
      t.useProgram(G);
      t.enableVertexAttribArray(p);
      t.enableVertexAttribArray(v);
      t.disable(t.CULL_FACE);
      t.enable(t.BLEND);
      t.bindBuffer(t.ARRAY_BUFFER, H);
      t.vertexAttribPointer(p, 2, t.FLOAT, !1, 16, 0);
      t.vertexAttribPointer(v, 2, t.FLOAT, !1, 16, 8);
      t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, D);
      t.uniformMatrix4fv(k, !1, B.projectionMatrix.elements);
      t.activeTexture(t.TEXTURE0);
      t.uniform1i(f, 0);
      var F = 0, C = 0, A = E.fog;
      A ? (t.uniform3f(q, A.color.r, A.color.g, A.color.b), A instanceof THREE.Fog ? (t.uniform1f(s, A.near), t.uniform1f(r, A.far), t.uniform1i(l, 1), C = F = 1) : A instanceof THREE.FogExp2 && (t.uniform1f(n, A.density), t.uniform1i(l, 2), C = F = 2)) : (t.uniform1i(l, 0), C = F = 0);
      for (var L, Q = [], A = 0; A < y; A++)
        L = K[A], !1 !== L.visible && (L._modelViewMatrix.multiplyMatrices(B.matrixWorldInverse, L.matrixWorld), L.z = -L._modelViewMatrix.elements[14]);
      K.sort(w);
      for (A = 0; A < y; A++)
        L = K[A], !1 !== L.visible && (B = L.material, t.uniform1f(u, B.alphaTest), t.uniformMatrix4fv(h, !1, L._modelViewMatrix.elements), Q[0] = L.scale.x, Q[1] = L.scale.y, L = E.fog && B.fog ? C : 0, F !== L && (t.uniform1i(l, L), F = L), null !== B.map ? (t.uniform2f(a, B.map.offset.x, B.map.offset.y), t.uniform2f(b, B.map.repeat.x, B.map.repeat.y)) : (t.uniform2f(a, 0, 0), t.uniform2f(b, 1, 1)), t.uniform1f(g, B.opacity), t.uniform3f(e, B.color.r, B.color.g, B.color.b), t.uniform1f(c, B.rotation), t.uniform2fv(d, Q), x.setBlending(B.blending, B.blendEquation, B.blendSrc, B.blendDst), x.setDepthTest(B.depthTest), x.setDepthWrite(B.depthWrite), B.map && B.map.image && B.map.image.width ? x.setTexture(B.map, 0) : x.setTexture(z, 0), t.drawElements(t.TRIANGLES, 6, t.UNSIGNED_SHORT, 0));
      t.enable(t.CULL_FACE);
    }
  };
};
THREE.DepthPassPlugin = function () {
  this.enabled = !1;
  this.renderTarget = null;
  var a, b, c, d, e, f, g = new THREE.Frustum(), h = new THREE.Matrix4();
  this.init = function (g) {
    a = g.context;
    b = g;
    g = THREE.ShaderLib.depthRGBA;
    var h = THREE.UniformsUtils.clone(g.uniforms);
    c = new THREE.ShaderMaterial({
      fragmentShader: g.fragmentShader,
      vertexShader: g.vertexShader,
      uniforms: h
    });
    d = new THREE.ShaderMaterial({
      fragmentShader: g.fragmentShader,
      vertexShader: g.vertexShader,
      uniforms: h,
      morphTargets: !0
    });
    e = new THREE.ShaderMaterial({
      fragmentShader: g.fragmentShader,
      vertexShader: g.vertexShader,
      uniforms: h,
      skinning: !0
    });
    f = new THREE.ShaderMaterial({
      fragmentShader: g.fragmentShader,
      vertexShader: g.vertexShader,
      uniforms: h,
      morphTargets: !0,
      skinning: !0
    });
    c._shadowPass = !0;
    d._shadowPass = !0;
    e._shadowPass = !0;
    f._shadowPass = !0;
  };
  this.render = function (a, b) {
    this.enabled && this.update(a, b);
  };
  this.update = function (k, l) {
    var n, s, r, q, u, p;
    a.clearColor(1, 1, 1, 1);
    a.disable(a.BLEND);
    b.setDepthTest(!0);
    !0 === k.autoUpdate && k.updateMatrixWorld();
    l.matrixWorldInverse.getInverse(l.matrixWorld);
    h.multiplyMatrices(l.projectionMatrix, l.matrixWorldInverse);
    g.setFromMatrix(h);
    b.setRenderTarget(this.renderTarget);
    b.clear();
    p = k.__webglObjects;
    n = 0;
    for (s = p.length; n < s; n++)
      r = p[n], u = r.object, r.render = !1, !u.visible || (u instanceof THREE.Mesh || u instanceof THREE.ParticleSystem) && u.frustumCulled && !g.intersectsObject(u) || (u._modelViewMatrix.multiplyMatrices(l.matrixWorldInverse, u.matrixWorld), r.render = !0);
    var v;
    n = 0;
    for (s = p.length; n < s; n++)
      r = p[n], r.render && (u = r.object, r = r.buffer, u instanceof THREE.ParticleSystem && !u.customDepthMaterial || ((v = u.material instanceof THREE.MeshFaceMaterial ? u.material.materials[0] : u.material) && b.setMaterialFaces(u.material), q = 0 < u.geometry.morphTargets.length && v.morphTargets, v = u instanceof THREE.SkinnedMesh && v.skinning, q = u.customDepthMaterial ? u.customDepthMaterial : v ? q ? f : e : q ? d : c, r instanceof THREE.BufferGeometry ? b.renderBufferDirect(l, k.__lights, null, q, r, u) : b.renderBuffer(l, k.__lights, null, q, r, u)));
    p = k.__webglObjectsImmediate;
    n = 0;
    for (s = p.length; n < s; n++)
      r = p[n], u = r.object, u.visible && (u._modelViewMatrix.multiplyMatrices(l.matrixWorldInverse, u.matrixWorld), b.renderImmediateObject(l, k.__lights, null, c, u));
    n = b.getClearColor();
    s = b.getClearAlpha();
    a.clearColor(n.r, n.g, n.b, s);
    a.enable(a.BLEND);
  };
};
THREE.ShaderFlares = {
  lensFlareVertexTexture: {
    vertexShader: 'uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nuniform sampler2D occlusionMap;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif( renderType == 2 ) {\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\nvVisibility =        visibility.r / 9.0;\nvVisibility *= 1.0 - visibility.g / 9.0;\nvVisibility *=       visibility.b / 9.0;\nvVisibility *= 1.0 - visibility.a / 9.0;\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}',
    fragmentShader: 'uniform lowp int renderType;\nuniform sampler2D map;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nif( renderType == 0 ) {\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\n} else if( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * vVisibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}'
  },
  lensFlare: {
    vertexShader: 'uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif( renderType == 2 ) {\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}',
    fragmentShader: 'precision mediump float;\nuniform lowp int renderType;\nuniform sampler2D map;\nuniform sampler2D occlusionMap;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvoid main() {\nif( renderType == 0 ) {\ngl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\n} else if( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nfloat visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\nvisibility = ( 1.0 - visibility / 4.0 );\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * visibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}'
  }
};
'use strict';
void 0 === Date.now && (Date.now = function () {
  return new Date().valueOf();
});
var TWEEN = TWEEN || function () {
    var a = [];
    return {
      REVISION: '12',
      getAll: function () {
        return a;
      },
      removeAll: function () {
        a = [];
      },
      add: function (c) {
        a.push(c);
      },
      remove: function (c) {
        c = a.indexOf(c);
        -1 !== c && a.splice(c, 1);
      },
      update: function (c) {
        if (0 === a.length)
          return !1;
        for (var b = 0, c = void 0 !== c ? c : 'undefined' !== typeof window && void 0 !== window.performance && void 0 !== window.performance.now ? window.performance.now() : Date.now(); b < a.length;)
          a[b].update(c) ? b++ : a.splice(b, 1);
        return !0;
      }
    };
  }();
TWEEN.Tween = function (a) {
  var c = {}, b = {}, d = {}, e = 1000, g = 0, h = !1, j = !1, q = 0, m = null, v = TWEEN.Easing.Linear.None, w = TWEEN.Interpolation.Linear, n = [], r = null, s = !1, t = null, u = null, k;
  for (k in a)
    c[k] = parseFloat(a[k], 10);
  this.to = function (a, c) {
    void 0 !== c && (e = c);
    b = a;
    return this;
  };
  this.start = function (e) {
    TWEEN.add(this);
    j = !0;
    s = !1;
    m = void 0 !== e ? e : 'undefined' !== typeof window && void 0 !== window.performance && void 0 !== window.performance.now ? window.performance.now() : Date.now();
    m += q;
    for (var f in b) {
      if (b[f] instanceof Array) {
        if (0 === b[f].length)
          continue;
        b[f] = [a[f]].concat(b[f]);
      }
      c[f] = a[f];
      !1 === c[f] instanceof Array && (c[f] *= 1);
      d[f] = c[f] || 0;
    }
    return this;
  };
  this.stop = function () {
    if (!j)
      return this;
    TWEEN.remove(this);
    j = !1;
    this.stopChainedTweens();
    return this;
  };
  this.stopChainedTweens = function () {
    for (var a = 0, b = n.length; a < b; a++)
      n[a].stop();
  };
  this.delay = function (a) {
    q = a;
    return this;
  };
  this.repeat = function (a) {
    g = a;
    return this;
  };
  this.yoyo = function (a) {
    h = a;
    return this;
  };
  this.easing = function (a) {
    v = a;
    return this;
  };
  this.interpolation = function (a) {
    w = a;
    return this;
  };
  this.chain = function () {
    n = arguments;
    return this;
  };
  this.onStart = function (a) {
    r = a;
    return this;
  };
  this.onUpdate = function (a) {
    t = a;
    return this;
  };
  this.onComplete = function (a) {
    u = a;
    return this;
  };
  this.update = function (p) {
    var f;
    if (p < m)
      return !0;
    !1 === s && (null !== r && r.call(a), s = !0);
    var i = (p - m) / e, i = 1 < i ? 1 : i, j = v(i);
    for (f in b) {
      var k = c[f] || 0, l = b[f];
      l instanceof Array ? a[f] = w(l, j) : ('string' === typeof l && (l = k + parseFloat(l, 10)), 'number' === typeof l && (a[f] = k + (l - k) * j));
    }
    null !== t && t.call(a, j);
    if (1 == i)
      if (0 < g) {
        isFinite(g) && g--;
        for (f in d)
          'string' === typeof b[f] && (d[f] += parseFloat(b[f], 10)), h && (i = d[f], d[f] = b[f], b[f] = i), c[f] = d[f];
        m = p + q;
      } else {
        null !== u && u.call(a);
        f = 0;
        for (i = n.length; f < i; f++)
          n[f].start(p);
        return !1;
      }
    return !0;
  };
};
TWEEN.Easing = {
  Linear: {
    None: function (a) {
      return a;
    }
  },
  Quadratic: {
    In: function (a) {
      return a * a;
    },
    Out: function (a) {
      return a * (2 - a);
    },
    InOut: function (a) {
      return 1 > (a *= 2) ? 0.5 * a * a : -0.5 * (--a * (a - 2) - 1);
    }
  },
  Cubic: {
    In: function (a) {
      return a * a * a;
    },
    Out: function (a) {
      return --a * a * a + 1;
    },
    InOut: function (a) {
      return 1 > (a *= 2) ? 0.5 * a * a * a : 0.5 * ((a -= 2) * a * a + 2);
    }
  },
  Quartic: {
    In: function (a) {
      return a * a * a * a;
    },
    Out: function (a) {
      return 1 - --a * a * a * a;
    },
    InOut: function (a) {
      return 1 > (a *= 2) ? 0.5 * a * a * a * a : -0.5 * ((a -= 2) * a * a * a - 2);
    }
  },
  Quintic: {
    In: function (a) {
      return a * a * a * a * a;
    },
    Out: function (a) {
      return --a * a * a * a * a + 1;
    },
    InOut: function (a) {
      return 1 > (a *= 2) ? 0.5 * a * a * a * a * a : 0.5 * ((a -= 2) * a * a * a * a + 2);
    }
  },
  Sinusoidal: {
    In: function (a) {
      return 1 - Math.cos(a * Math.PI / 2);
    },
    Out: function (a) {
      return Math.sin(a * Math.PI / 2);
    },
    InOut: function (a) {
      return 0.5 * (1 - Math.cos(Math.PI * a));
    }
  },
  Exponential: {
    In: function (a) {
      return 0 === a ? 0 : Math.pow(1024, a - 1);
    },
    Out: function (a) {
      return 1 === a ? 1 : 1 - Math.pow(2, -10 * a);
    },
    InOut: function (a) {
      return 0 === a ? 0 : 1 === a ? 1 : 1 > (a *= 2) ? 0.5 * Math.pow(1024, a - 1) : 0.5 * (-Math.pow(2, -10 * (a - 1)) + 2);
    }
  },
  Circular: {
    In: function (a) {
      return 1 - Math.sqrt(1 - a * a);
    },
    Out: function (a) {
      return Math.sqrt(1 - --a * a);
    },
    InOut: function (a) {
      return 1 > (a *= 2) ? -0.5 * (Math.sqrt(1 - a * a) - 1) : 0.5 * (Math.sqrt(1 - (a -= 2) * a) + 1);
    }
  },
  Elastic: {
    In: function (a) {
      var c, b = 0.1;
      if (0 === a)
        return 0;
      if (1 === a)
        return 1;
      !b || 1 > b ? (b = 1, c = 0.1) : c = 0.4 * Math.asin(1 / b) / (2 * Math.PI);
      return -(b * Math.pow(2, 10 * (a -= 1)) * Math.sin((a - c) * 2 * Math.PI / 0.4));
    },
    Out: function (a) {
      var c, b = 0.1;
      if (0 === a)
        return 0;
      if (1 === a)
        return 1;
      !b || 1 > b ? (b = 1, c = 0.1) : c = 0.4 * Math.asin(1 / b) / (2 * Math.PI);
      return b * Math.pow(2, -10 * a) * Math.sin((a - c) * 2 * Math.PI / 0.4) + 1;
    },
    InOut: function (a) {
      var c, b = 0.1;
      if (0 === a)
        return 0;
      if (1 === a)
        return 1;
      !b || 1 > b ? (b = 1, c = 0.1) : c = 0.4 * Math.asin(1 / b) / (2 * Math.PI);
      return 1 > (a *= 2) ? -0.5 * b * Math.pow(2, 10 * (a -= 1)) * Math.sin((a - c) * 2 * Math.PI / 0.4) : 0.5 * b * Math.pow(2, -10 * (a -= 1)) * Math.sin((a - c) * 2 * Math.PI / 0.4) + 1;
    }
  },
  Back: {
    In: function (a) {
      return a * a * (2.70158 * a - 1.70158);
    },
    Out: function (a) {
      return --a * a * (2.70158 * a + 1.70158) + 1;
    },
    InOut: function (a) {
      return 1 > (a *= 2) ? 0.5 * a * a * (3.5949095 * a - 2.5949095) : 0.5 * ((a -= 2) * a * (3.5949095 * a + 2.5949095) + 2);
    }
  },
  Bounce: {
    In: function (a) {
      return 1 - TWEEN.Easing.Bounce.Out(1 - a);
    },
    Out: function (a) {
      return a < 1 / 2.75 ? 7.5625 * a * a : a < 2 / 2.75 ? 7.5625 * (a -= 1.5 / 2.75) * a + 0.75 : a < 2.5 / 2.75 ? 7.5625 * (a -= 2.25 / 2.75) * a + 0.9375 : 7.5625 * (a -= 2.625 / 2.75) * a + 0.984375;
    },
    InOut: function (a) {
      return 0.5 > a ? 0.5 * TWEEN.Easing.Bounce.In(2 * a) : 0.5 * TWEEN.Easing.Bounce.Out(2 * a - 1) + 0.5;
    }
  }
};
TWEEN.Interpolation = {
  Linear: function (a, c) {
    var b = a.length - 1, d = b * c, e = Math.floor(d), g = TWEEN.Interpolation.Utils.Linear;
    return 0 > c ? g(a[0], a[1], d) : 1 < c ? g(a[b], a[b - 1], b - d) : g(a[e], a[e + 1 > b ? b : e + 1], d - e);
  },
  Bezier: function (a, c) {
    var b = 0, d = a.length - 1, e = Math.pow, g = TWEEN.Interpolation.Utils.Bernstein, h;
    for (h = 0; h <= d; h++)
      b += e(1 - c, d - h) * e(c, h) * a[h] * g(d, h);
    return b;
  },
  CatmullRom: function (a, c) {
    var b = a.length - 1, d = b * c, e = Math.floor(d), g = TWEEN.Interpolation.Utils.CatmullRom;
    return a[0] === a[b] ? (0 > c && (e = Math.floor(d = b * (1 + c))), g(a[(e - 1 + b) % b], a[e], a[(e + 1) % b], a[(e + 2) % b], d - e)) : 0 > c ? a[0] - (g(a[0], a[0], a[1], a[1], -d) - a[0]) : 1 < c ? a[b] - (g(a[b], a[b], a[b - 1], a[b - 1], d - b) - a[b]) : g(a[e ? e - 1 : 0], a[e], a[b < e + 1 ? b : e + 1], a[b < e + 2 ? b : e + 2], d - e);
  },
  Utils: {
    Linear: function (a, c, b) {
      return (c - a) * b + a;
    },
    Bernstein: function (a, c) {
      var b = TWEEN.Interpolation.Utils.Factorial;
      return b(a) / b(c) / b(a - c);
    },
    Factorial: function () {
      var a = [1];
      return function (c) {
        var b = 1, d;
        if (a[c])
          return a[c];
        for (d = c; 1 < d; d--)
          b *= d;
        return a[c] = b;
      };
    }(),
    CatmullRom: function (a, c, b, d, e) {
      var a = 0.5 * (b - a), d = 0.5 * (d - c), g = e * e;
      return (2 * c - 2 * b + a + d) * e * g + (-3 * c + 3 * b - 2 * a - d) * g + a * e + c;
    }
  }
};
(function ($window, $document, tagName, url, namespace, a, m) {
  $window['GoogleAnalyticsObject'] = namespace;
  $window[namespace] = $window[namespace] || function () {
    ($window[namespace].q = $window[namespace].q || []).push(arguments);
  }, $window[namespace].l = 1 * new Date();
  a = $document.createElement(tagName), m = $document.getElementsByTagName(tagName)[0];
  a.async = 1;
  a.src = url;
  m.parentNode.insertBefore(a, m);
}(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga'));
var Stats = function () {
  var startTime = Date.now(), prevTime = startTime;
  var ms = 0, msMin = Infinity, msMax = 0;
  var fps = 0, fpsMin = Infinity, fpsMax = 0;
  var frames = 0, mode = 0;
  var container = document.createElement('div');
  container.id = 'stats';
  container.addEventListener('mousedown', function (event) {
    event.preventDefault();
    setMode(++mode % 2);
  }, false);
  container.style.cssText = 'width:80px;opacity:0.9;cursor:pointer';
  var fpsDiv = document.createElement('div');
  fpsDiv.id = 'fps';
  fpsDiv.style.cssText = 'padding:0 0 3px 3px;text-align:left;background-color:#002';
  container.appendChild(fpsDiv);
  var fpsText = document.createElement('div');
  fpsText.id = 'fpsText';
  fpsText.style.cssText = 'color:#0ff;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px';
  fpsText.innerHTML = 'FPS';
  fpsDiv.appendChild(fpsText);
  var fpsGraph = document.createElement('div');
  fpsGraph.id = 'fpsGraph';
  fpsGraph.style.cssText = 'position:relative;width:74px;height:30px;background-color:#0ff';
  fpsDiv.appendChild(fpsGraph);
  while (fpsGraph.children.length < 74) {
    var bar = document.createElement('span');
    bar.style.cssText = 'width:1px;height:30px;float:left;background-color:#113';
    fpsGraph.appendChild(bar);
  }
  var msDiv = document.createElement('div');
  msDiv.id = 'ms';
  msDiv.style.cssText = 'padding:0 0 3px 3px;text-align:left;background-color:#020;display:none';
  container.appendChild(msDiv);
  var msText = document.createElement('div');
  msText.id = 'msText';
  msText.style.cssText = 'color:#0f0;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px';
  msText.innerHTML = 'MS';
  msDiv.appendChild(msText);
  var msGraph = document.createElement('div');
  msGraph.id = 'msGraph';
  msGraph.style.cssText = 'position:relative;width:74px;height:30px;background-color:#0f0';
  msDiv.appendChild(msGraph);
  while (msGraph.children.length < 74) {
    var bar = document.createElement('span');
    bar.style.cssText = 'width:1px;height:30px;float:left;background-color:#131';
    msGraph.appendChild(bar);
  }
  var setMode = function (value) {
    mode = value;
    switch (mode) {
    case 0:
      fpsDiv.style.display = 'block';
      msDiv.style.display = 'none';
      break;
    case 1:
      fpsDiv.style.display = 'none';
      msDiv.style.display = 'block';
      break;
    }
  };
  var updateGraph = function (dom, value) {
    var child = dom.appendChild(dom.firstChild);
    child.style.height = value + 'px';
  };
  return {
    REVISION: 11,
    domElement: container,
    setMode: setMode,
    begin: function () {
      startTime = Date.now();
    },
    end: function () {
      var time = Date.now();
      ms = time - startTime;
      msMin = Math.min(msMin, ms);
      msMax = Math.max(msMax, ms);
      msText.textContent = ms + ' MS (' + msMin + '-' + msMax + ')';
      updateGraph(msGraph, Math.min(30, 30 - ms / 200 * 30));
      frames++;
      if (time > prevTime + 1000) {
        fps = Math.round(frames * 1000 / (time - prevTime));
        fpsMin = Math.min(fpsMin, fps);
        fpsMax = Math.max(fpsMax, fps);
        fpsText.textContent = fps + ' FPS (' + fpsMin + '-' + fpsMax + ')';
        updateGraph(fpsGraph, Math.min(30, 30 - fps / 100 * 30));
        prevTime = time;
        frames = 0;
      }
      return time;
    },
    update: function () {
      startTime = this.end();
    }
  };
};
(function () {
  var app;
  app = angular.module('app', [
    'async',
    'jed',
    'jquery',
    'underscore'
  ]);
  app.run([
    '$rootScope',
    '$window',
    '$location',
    'cookie',
    'i18n',
    function ($rootScope, $window, $location, cookie, i18n) {
      var GITHUB_APPLICATION_CLIENT_ID_COOKIE_NAME, GITHUB_LOGIN_COOKIE_NAME, GITHUB_TOKEN_COOKIE_NAME, isMenuLocation;
      GITHUB_APPLICATION_CLIENT_ID_COOKIE_NAME = 'github-application-client-id';
      GITHUB_TOKEN_COOKIE_NAME = 'github-token';
      GITHUB_LOGIN_COOKIE_NAME = 'github-login';
      $rootScope.i18n = i18n;
      $rootScope.breadcrumbStrategy = { progressive: false };
      $rootScope.clientId = function () {
        return cookie.getItem(GITHUB_APPLICATION_CLIENT_ID_COOKIE_NAME);
      };
      $rootScope.log = function (thing) {
      };
      $rootScope.alert = function (thing) {
        return alert(thing);
      };
      $rootScope.isLoggedIn = function () {
        return cookie.hasItem(GITHUB_TOKEN_COOKIE_NAME);
      };
      $rootScope.loginEnabled = function () {
        return !cookie.hasItem(GITHUB_TOKEN_COOKIE_NAME);
      };
      $rootScope.logout = function () {
        cookie.removeItem(GITHUB_TOKEN_COOKIE_NAME);
        return cookie.removeItem(GITHUB_LOGIN_COOKIE_NAME);
      };
      $rootScope.login = function () {
        var clientId;
        clientId = cookie.getItem(GITHUB_APPLICATION_CLIENT_ID_COOKIE_NAME);
        return $window.location.href = 'https://github.com/login/oauth/authorize?client_id=' + clientId + '&amp;scope=repo,user,gist';
      };
      $rootScope.userLogin = function () {
        return cookie.getItem(GITHUB_LOGIN_COOKIE_NAME);
      };
      isMenuLocation = function () {
        if ($window.location && $window.location.href) {
          return !$window.location.href.match(new RegExp('/workbench$')) && !$window.location.href.match(new RegExp('/users/')) && !$window.location.href.match(new RegExp('/gists/'));
        } else {
          return false;
        }
      };
      $rootScope.isHomePage = function () {
        return true;
      };
      $rootScope.jumpIcon = function () {
        if (isMenuLocation()) {
          return 'icon-edit';
        } else {
          return 'icon-home';
        }
      };
      $rootScope.jumpText = function () {
        if (isMenuLocation()) {
          return 'Workbench';
        } else {
          return 'Home';
        }
      };
      return $rootScope.jumpHRef = function () {
        if (isMenuLocation()) {
          return '/workbench';
        } else {
          return '/';
        }
      };
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('HomeCtrl', [
    '$rootScope',
    '$scope',
    '$http',
    '$location',
    '$window',
    'GitHubAuthManager',
    function ($rootScope, $scope, $http, $location, $window, authManager) {
      var EVENT_CATEGORY;
      EVENT_CATEGORY = 'home';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/home');
      ga('send', 'pageview');
      authManager.handleLoginCallback(function (err, token) {
        if (err) {
          return $window.alert(err.message);
        }
      });
      $scope.work = function () {
        ga('send', 'event', EVENT_CATEGORY, 'work');
        $location.path('/work');
      };
      $scope.browse = function () {
        ga('send', 'event', EVENT_CATEGORY, 'browse');
        $location.path('/browse');
      };
      return $scope.user = function () {
        var path;
        ga('send', 'event', EVENT_CATEGORY, 'user');
        path = '/users/' + $scope.userLogin();
        $location.path(path);
      };
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('NewFileCtrl', [
    '$scope',
    'GitHub',
    'Base64',
    'cookie',
    '$',
    '_',
    function ($scope, github, base64, cookie, $, _) {
      var EVENT_CATEGORY, GITHUB_TOKEN_COOKIE_NAME, token;
      EVENT_CATEGORY = 'new-file';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/new-file');
      ga('send', 'pageview');
      GITHUB_TOKEN_COOKIE_NAME = 'github-token';
      token = cookie.getItem(GITHUB_TOKEN_COOKIE_NAME);
      $('#new-file-dialog').on('show', function () {
        return $scope.file = {
          name: '',
          message: ''
        };
      });
      $('#new-file-dialog').on('shown', function () {
      });
      $('#new-file-dialog').on('hide', function () {
      });
      $('#new-file-dialog').on('hidden', function () {
      });
      return $scope.createFile = function () {
        var content, path;
        ga('send', 'event', EVENT_CATEGORY, 'createFile');
        content = base64.encode('# ' + $scope.file.name + '\n');
        path = $scope.path ? '' + $scope.path + '/' + $scope.file.name : $scope.file.name;
        return github.putFile(token, $scope.user.login, $scope.repo.name, path, $scope.file.message, content, void 0, function (err, response, status, headers, config) {
          var messages;
          if (!err) {
            $scope.$emit('createdFile', $scope.user, $scope.repo, response.content, response.commit);
            return $('#new-file-dialog').modal('hide');
          } else {
            messages = _.map(response.errors, function (error) {
              return error.message;
            }).join();
            return alert(messages);
          }
        });
      };
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('NewGistCtrl', [
    '$scope',
    'GitHub',
    'cookie',
    '$',
    '_',
    function ($scope, github, cookie, $, _) {
      var EVENT_CATEGORY, GITHUB_TOKEN_COOKIE_NAME, token;
      EVENT_CATEGORY = 'new-gist';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/new-gist');
      ga('send', 'pageview');
      GITHUB_TOKEN_COOKIE_NAME = 'github-token';
      token = cookie.getItem(GITHUB_TOKEN_COOKIE_NAME);
      $('#new-gist-dialog').on('show', function () {
        return $scope.gist = {
          path: '',
          description: '',
          'private': 'false',
          markdownReadme: true,
          pythonReadme: true
        };
      });
      $('#new-gist-dialog').on('shown', function () {
      });
      $('#new-gist-dialog').on('hide', function () {
      });
      $('#new-gist-dialog').on('hidden', function () {
      });
      return $scope.createGist = function () {
        var data;
        ga('send', 'event', EVENT_CATEGORY, 'createGist');
        data = {};
        data.description = $scope.gist.description;
        data['public'] = true;
        data.files = { 'main.py': { 'content': '# main.py' } };
        return github.postGist(token, data, function (err, response, status, headers, config) {
          var messages;
          if (!err) {
            $scope.$emit('createdGist', $scope.user, response);
            return $('#new-gist-dialog').modal('hide');
          } else {
            messages = _.map(response.errors, function (error) {
              return error.message;
            }).join();
            return alert(messages);
          }
        });
      };
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('NewRepoCtrl', [
    '$scope',
    'GitHub',
    'cookie',
    '$',
    '_',
    function ($scope, github, cookie, $, _) {
      var EVENT_CATEGORY, GITHUB_TOKEN_COOKIE_NAME, token;
      EVENT_CATEGORY = 'new-repo';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/new-repo');
      ga('send', 'pageview');
      GITHUB_TOKEN_COOKIE_NAME = 'github-token';
      token = cookie.getItem(GITHUB_TOKEN_COOKIE_NAME);
      $('#new-repo-dialog').on('show', function () {
        return $scope.repo = {
          path: '',
          description: '',
          'private': 'false',
          markdownReadme: true,
          pythonReadme: true
        };
      });
      $('#new-repo-dialog').on('shown', function () {
      });
      $('#new-repo-dialog').on('hide', function () {
      });
      $('#new-repo-dialog').on('hidden', function () {
      });
      return $scope.createRepo = function () {
        ga('send', 'event', EVENT_CATEGORY, 'createRepo');
        return github.postRepo(token, $scope.repo.name, $scope.repo.description, false, $scope.repo.markdownReadme, function (err, repo) {
          var messages;
          if (!err) {
            $scope.$emit('createdRepo', $scope.user, repo);
            return $('#new-repo-dialog').modal('hide');
          } else {
            messages = _.map(response.errors, function (error) {
              return error.message;
            }).join();
            return alert(messages);
          }
        });
      };
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('PrinterCtrl', [
    '$scope',
    function ($scope) {
      var EVENT_CATEGORY, PRESERVE_ELEMENT_ID, escapeHtml;
      EVENT_CATEGORY = 'printer';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/printer');
      ga('send', 'pageview');
      PRESERVE_ELEMENT_ID = 'a5f435e0-c92e-11e2-8b8b-0800200c9a66';
      escapeHtml = function (s) {
        return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
      };
      $scope.$on('reset', function (e) {
        var elem;
        elem = document.getElementById(PRESERVE_ELEMENT_ID);
        if (elem) {
          return elem.innerHTML = '';
        } else {
          return console.log('Unable to find element with Id ' + PRESERVE_ELEMENT_ID);
        }
      });
      return $scope.$on('print', function (e, text) {
        var elem;
        elem = document.getElementById(PRESERVE_ELEMENT_ID);
        if (elem) {
          return elem.innerHTML = elem.innerHTML + escapeHtml(text);
        } else {
          return console.log('Unable to find element with Id ' + PRESERVE_ELEMENT_ID);
        }
      });
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('TreeCtrl', [
    '$rootScope',
    '$scope',
    '$window',
    '$routeParams',
    '$',
    '_',
    'GitHub',
    'Base64',
    'cookie',
    function ($rootScope, $scope, $window, $routeParams, $, _, github, base64, cookie) {
      var EVENT_CATEGORY, GITHUB_TOKEN_COOKIE_NAME, n, steps, token, _i;
      EVENT_CATEGORY = 'tree';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/tree');
      ga('send', 'pageview');
      GITHUB_TOKEN_COOKIE_NAME = 'github-token';
      token = cookie.getItem(GITHUB_TOKEN_COOKIE_NAME);
      $scope.messages = [];
      $('.carousel').carousel({ interval: false });
      $scope.contextItem = {};
      if ($routeParams.user && $routeParams.repo) {
        $scope.user = { login: $routeParams.user };
        $scope.repo = { name: $routeParams.repo };
        $scope.branch = { name: $routeParams.branch };
        steps = [];
        for (n = _i = 0; _i <= 6; n = ++_i) {
          if ($routeParams['step' + n]) {
            steps.push($routeParams['step' + n]);
          }
        }
        $scope.path = steps.join('/');
        $scope.contextItem.name = $scope.repo.name;
        $scope.contextItem.type = 'repo';
        github.getPathContents(token, $scope.user.login, $scope.repo.name, $scope.path, function (err, response, status, headers, config) {
          if (!err) {
            return $scope.contextItem.childItems = response;
          } else {
            console.log('err: ' + err + ', reponse: ' + response + ', status ' + status);
            return alert('' + err.message + '. Cause: ' + response.message + '.');
          }
        });
      } else {
        $scope.contextItem.name = '';
        $scope.contextItem.type = void 0;
      }
      $scope.isNewFileEnabled = function () {
        return $scope.isLoggedIn() && $scope.userLogin() === $scope.user.login;
      };
      $scope.newFile = function () {
        if ($scope.isNewFileEnabled()) {
          return $('#new-file-dialog').modal({
            show: true,
            backdrop: true
          });
        } else {
          return alert('Create a New File is not enabled.');
        }
      };
      $scope.$on('createdFile', function (e, user, repo, item, commit) {
        return $scope.contextItem.childItems.push(item);
      });
      $scope.isDeleteItemEnabled = function () {
        return $scope.isLoggedIn() && $scope.userLogin() === $scope.user.login;
      };
      $scope.deleteItem = function (idx) {
        var childItem;
        ga('send', 'event', EVENT_CATEGORY, 'deleteItem');
        childItem = $scope.contextItem.childItems[idx];
        return github.deleteFile(token, $scope.user.login, $scope.repo.name, childItem.path, 'Delete item.', childItem.sha, function (err, response, status, headers, config) {
          if (!err) {
            return $scope.contextItem.childItems.splice(idx, 1);
          } else {
            return alert('Error deleting item: ' + err);
          }
        });
      };
      $scope.homeBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active';
        } else {
          return '';
        }
      };
      $scope.userBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active';
        } else {
          return '';
        }
      };
      $scope.repoBreadcrumbClass = function () {
        return 'active';
      };
      $scope.hrefFromItem = function (item) {
        var collectionName;
        collectionName = item.type === 'file' ? 'blob' : item.type === 'dir' ? 'tree' : 'unknown';
        return '/users/' + $scope.user.login + '/repos/' + $scope.repo.name + '/' + collectionName + '/' + $scope.branch.name + '/' + item.path;
      };
      $scope.iconFromItem = function (item) {
        switch (item.type) {
        case 'file':
          return 'icon-file';
        case 'dir':
          return 'icon-dir';
        default:
          return 'icon-question';
        }
      };
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('UserCtrl', [
    '$rootScope',
    '$scope',
    '$routeParams',
    'GitHub',
    'cookie',
    '$',
    '_',
    'async',
    function ($rootScope, $scope, $routeParams, github, cookie, $, _, async) {
      var EVENT_CATEGORY, GITHUB_TOKEN_COOKIE_NAME, findIndex, loadGists, loadRepos, token;
      EVENT_CATEGORY = 'user';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/user');
      ga('send', 'pageview');
      GITHUB_TOKEN_COOKIE_NAME = 'github-token';
      token = cookie.getItem(GITHUB_TOKEN_COOKIE_NAME);
      loadGists = function (callback) {
        return github.getGists(token, function (err, gists) {
          if (!err) {
            $scope.gists = _.filter(_.map(gists, function (gist) {
              return {
                'id': gist.id,
                'description': gist.description,
                'html_url': gist.html_url
              };
            }), function (gist) {
              return true;
            });
          } else {
            alert('Error retrieving user Gists');
          }
          return callback(err, gists);
        });
      };
      loadRepos = function (callback) {
        return github.getUserRepos(token, function (err, repos) {
          if (!err) {
            $scope.repos = _.filter(repos, function (repo) {
              return repo.language === 'Python';
            });
          } else {
            alert('Error retrieving user Repositories');
          }
          return callback(err, repos);
        });
      };
      async.parallel([
        function (callback) {
          return github.getUser(token, function (err, user) {
            if (!err) {
              $scope.user = user;
            } else {
              alert('Error retrieving user profile');
            }
            return callback(err, user);
          });
        },
        function (callback) {
          return loadRepos(callback);
        },
        function (callback) {
          return loadGists(callback);
        }
      ], function (err, results) {
      });
      $scope.homeBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active distance-1';
        } else {
          return '';
        }
      };
      $scope.userBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active distance-0';
        } else {
          return 'active distance-0';
        }
      };
      $scope.newGist = function () {
        return $('#new-gist-dialog').modal({
          show: true,
          backdrop: true
        });
      };
      findIndex = function (xs, match) {
        var i, length, x, _i, _ref;
        length = xs;
        for (i = _i = 0, _ref = length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          x = xs[i];
          if (match(x)) {
            return x;
          }
        }
        return -1;
      };
      $scope.deleteGist = function (owner, id) {
        ga('send', 'event', EVENT_CATEGORY, 'deleteGist');
        return github.deleteGist(token, owner, id, function (err, response, status, headers, config) {
          var index;
          if (!err) {
            index = findIndex($scope.gists, function (gist) {
              return gist.id === id;
            });
            return $scope.gists.splice(index, 1);
          } else {
            return alert('Error deleting gist: ' + err);
          }
        });
      };
      $scope.$on('createdGist', function (e, user, gist) {
        return $scope.gists.push(gist);
      });
      $scope.newRepo = function (owner) {
        return $('#new-repo-dialog').modal({
          show: true,
          backdrop: true
        });
      };
      $scope.deleteRepo = function (owner, repo) {
        ga('send', 'event', EVENT_CATEGORY, 'deleteRepo');
        return github.deleteRepo(token, owner, repo, function (err, response, status, headers, config) {
          if (!err) {
          } else {
            return alert('Error deleting repo: ' + err);
          }
        });
      };
      return $scope.$on('createdRepo', function (e, user, repo) {
        return $scope.repos.push(repo);
      });
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('WorkCtrl', [
    '$rootScope',
    '$scope',
    '$location',
    '$window',
    '$routeParams',
    '$',
    '_',
    'GitHub',
    'Base64',
    'cookie',
    'GitHubAuthManager',
    function ($rootScope, $scope, $location, $window, $routeParams, $, _, github, base64, cookie, authManager) {
      var EVENT_CATEGORY, GITHUB_TOKEN_COOKIE_NAME, code, editor, isFullScreen, n, setFullScreen, steps, token, winHeight, winWidth, _i;
      EVENT_CATEGORY = 'work';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/work');
      ga('send', 'pageview');
      authManager.handleLoginCallback(function (err, token) {
        if (err) {
          return $window.alert(err.message);
        }
      });
      GITHUB_TOKEN_COOKIE_NAME = 'github-token';
      token = cookie.getItem(GITHUB_TOKEN_COOKIE_NAME);
      $scope.messages = [];
      $scope.contextItem = {};
      $scope.contextGist = {};
      if ($routeParams.user && $routeParams.repo) {
        $scope.user = { login: $routeParams.user };
        $scope.repo = { name: $routeParams.repo };
        $scope.branch = { name: $routeParams.branch };
        steps = [];
        for (n = _i = 0; _i <= 6; n = ++_i) {
          if ($routeParams['step' + n]) {
            steps.push($routeParams['step' + n]);
          }
        }
        $scope.path = steps.join('/');
        $scope.contextItem.name = $routeParams.repo;
        $scope.contextItem.type = 'repo';
        github.getPathContents(token, $scope.user.login, $scope.repo.name, $scope.path, function (err, file) {
          var contextItem;
          if (!err) {
            contextItem = {
              name: file.name,
              path: file.path,
              sha: file.sha,
              type: file.type,
              parentItem: $scope.contextItem,
              childItems: []
            };
            $scope.contextItem = contextItem;
            if (file.encoding === 'base64') {
              return editor.setValue(base64.decode(file.content));
            } else {
              return alert('Unknown encoding: ' + file.encoding);
            }
          } else {
            return alert('Error retrieving the page');
          }
        });
      } else if ($routeParams.gistId) {
        github.getGist(token, $routeParams.gistId, function (err, gist) {
          if (!err) {
            $scope.contextGist = gist;
            $scope.contextItem.name = 'main.py';
            return editor.setValue(gist.files['main.py'].content);
          } else {
            return alert('Error retrieving the Gist.');
          }
        });
      } else {
        $scope.contextItem.name = 'Untitled';
        $scope.contextItem.type = void 0;
      }
      winHeight = function () {
        return $window.innerHeight || ($window.document.documentElement || $window.document.body).clientHeight;
      };
      winWidth = function () {
        return $window.innerWidth || ($window.document.documentElement || $window.document.body).clientWidth;
      };
      isFullScreen = function (cm) {
        return /\bCodeMirror-fullscreen\b/.test(cm.getWrapperElement().className);
      };
      setFullScreen = function (cm, full) {
        var wrapperElement;
        wrapperElement = cm.getWrapperElement();
        if (full) {
          wrapperElement.className += ' CodeMirror-fullscreen';
          wrapperElement.style.height = winHeight() + 'px';
          document.documentElement.style.overflow = 'hidden';
        } else {
          wrapperElement.className = wrapperElement.className.replace(' CodeMirror-fullscreen', '');
          wrapperElement.style.height = '600px';
          document.documentElement.style.overflow = '';
        }
        return cm.refresh();
      };
      code = document.getElementById('code');
      if (code) {
        editor = CodeMirror.fromTextArea(code, {
          'autofocus': false,
          'indentUnit': 4,
          'lineNumbers': true,
          'lineWrapping': true,
          'autoMatchParens': true,
          'parserConfig': {
            'pythonVersion': 2,
            'strictErrors': true
          },
          'theme': 'twilight',
          'extraKeys': {
            'Tab': function (cm) {
              var spaces;
              spaces = Array(cm.getOption('indentUnit') + 1).join(' ');
              return cm.replaceSelection(spaces, 'end', '+input');
            },
            'Ctrl-S': function (cm) {
              return $scope.saveFile();
            },
            'Ctrl-Enter': function (cm) {
              return $scope.run();
            }
          }
        });
      } else {
        alert('The code element could not be found');
      }
      $scope.run = function () {
        var e, message, name, prog, text;
        ga('send', 'event', EVENT_CATEGORY, 'run');
        $rootScope.$broadcast('reset');
        $scope.messages.length = 0;
        prog = editor.getValue();
        Sk.canvas = 'canvas';
        Sk.configure({
          'output': function (text) {
            return $rootScope.$broadcast('print', text);
          },
          'debugout': function (arg) {
            return console.log('' + JSON.stringify(arg, null, 2));
          },
          'read': function (searchPath) {
            if (Sk.builtinFiles === void 0 || Sk.builtinFiles['files'][searchPath] === void 0) {
              throw new Error('File not found: \'' + searchPath + '\'');
            } else {
              return Sk.builtinFiles['files'][searchPath];
            }
          }
        });
        if (prog.trim().length > 0) {
          try {
            return eval(Sk.importMainWithBody('<stdin>', false, prog.trim()));
          } catch (_error) {
            e = _error;
            if (typeof e !== 'undefined') {
              if (typeof e.toString === 'function') {
                message = e.toString();
                name = message.substring(0, message.indexOf(':'));
                text = message.substring(message.indexOf(':') + 1);
                return $scope.messages.push({
                  name: name,
                  text: text,
                  severity: 'error'
                });
              } else {
                return console.log(JSON.stringify(e, null, 2));
              }
            }
          }
        }
      };
      $scope.saveFile = function () {
        var content, data, description, files;
        ga('send', 'event', EVENT_CATEGORY, 'savePage');
        content = base64.encode(editor.getValue());
        if ($scope.user) {
          return github.putFile(token, $scope.user.login, $scope.repo.name, $scope.contextItem.path, 'Save file.', content, $scope.contextItem.sha, function (err, response, status, headers, config) {
            if (!err) {
              return $scope.contextItem.sha = response.content.sha;
            } else {
              return alert('Error saving file to repository. Cause: ' + err.message);
            }
          });
        } else {
          if ($scope.contextGist.id) {
            description = $scope.contextGist.description;
            files = { 'main.py': { content: editor.getValue() } };
            return github.patchGist(token, $scope.contextGist.id, {
              description: description,
              files: files
            }, function (err, response, status, headers, config) {
              if (!err) {
              } else {
                return alert('Error patching Gist. Cause: ' + err.message);
              }
            });
          } else {
            files = { 'main.py': { content: editor.getValue() } };
            data = {};
            data.description = 'GeometryZen Gist';
            data['public'] = true;
            data.files = files;
            return github.postGist(token, data, function (err, response, status, headers, config) {
              if (!err) {
                return $location.path('/gists/' + response.id);
              } else {
                return alert('Error posting Gist. Cause: ' + err.message);
              }
            });
          }
        }
      };
      $scope.homeBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active';
        } else {
          return '';
        }
      };
      $scope.userBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active';
        } else {
          return '';
        }
      };
      $scope.repoBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active';
        } else {
          if ($scope.workEnabled()) {
            return '';
          } else {
            return 'active';
          }
        }
      };
      $scope.repoEnabled = function () {
        return $scope.repo && $scope.repo.name;
      };
      $scope.workEnabled = function () {
        return $scope.contextItem && $scope.contextItem.type === 'file' || !($scope.repo && $scope.repo.name);
      };
      $scope.saveEnabled = function () {
        if ($scope.user) {
          return $scope.isLoggedIn() && $scope.userLogin() === $scope.user.login && $scope.contextItem && $scope.contextItem.type === 'file';
        } else {
          return true;
        }
      };
      $scope.runEnabled = function () {
        return $scope.workEnabled();
      };
      $scope.iconFromItem = function (item) {
        switch (item.type) {
        case 'file':
          return 'icon-file';
        case 'dir':
          return 'icon-dir';
        default:
          return 'icon-question';
        }
      };
      if (editor) {
        setFullScreen(editor, false);
      }
      CodeMirror.on($window, 'resize', function () {
        var showing;
        showing = $window.document.body.getElementsByClassName('CodeMirror-fullscreen')[0];
        if (showing) {
          return showing.CodeMirror.getWrapperElement().style.height = winHeight() + 'px';
        } else {
        }
      });
    }
  ]);
}.call(this));
(function () {
  var module;
  module = angular.module('app');
  module.directive('aHome', function () {
    return {
      restrict: 'E',
      replace: true,
      templateUrl: 'angular/a-home.html'
    };
  });
}.call(this));
(function () {
  angular.module('app').directive('githubAuthorize', function () {
    return {
      restrict: 'E',
      replace: true,
      templateUrl: 'angular/github-authorize.html'
    };
  });
}.call(this));
(function () {
  angular.module('app').directive('printer', function () {
    return {
      restrict: 'E',
      templateUrl: 'angular/printer.html'
    };
  });
}.call(this));
(function () {
  var module;
  module = angular.module('app');
  module.directive('userLinks', function () {
    return {
      restrict: 'E',
      replace: true,
      template: '<div class="user-links">\n  <a class="btn btn-secondary" ng-href="{{jumpHRef()}}">\n    <i class="{{jumpIcon()}}"/>\n    <span>{{jumpText()}}</span>\n  </a>\n  <button class="btn btn-secondary" ng-click="logout()" href="#" ng-show="isLoggedIn()">\n    <i class="icon-signout"></i>\n    <span>{{userLogin()}}</span>\n  </button>\n  <a class="btn btn-secondary" ng-hide="isLoggedIn()" ng-click="login()">\n    <i class="icon-signin"/>\n    <span>Sign in</span>\n  </a>\n</div>'
    };
  });
}.call(this));
(function () {
  var app;
  app = angular.module('app');
  app.config([
    '$routeProvider',
    '$locationProvider',
    function ($routeProvider, $locationProvider) {
      $routeProvider.when('/', {
        templateUrl: 'angular/home.html',
        controller: 'HomeCtrl'
      });
      $routeProvider.when('/workbench', {
        templateUrl: 'angular/work.html',
        controller: 'WorkCtrl'
      });
      $routeProvider.when('/gists/:gistId', {
        templateUrl: 'angular/work.html',
        controller: 'WorkCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/blob/:branch/:step0/:step1/:step2', {
        templateUrl: 'angular/work.html',
        controller: 'WorkCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/blob/:branch/:step0/:step1', {
        templateUrl: 'angular/work.html',
        controller: 'WorkCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/blob/:branch/:step0', {
        templateUrl: 'angular/work.html',
        controller: 'WorkCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/tree/:branch/:step0/:step1', {
        templateUrl: 'angular/tree.html',
        controller: 'TreeCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/tree/:branch/:step0', {
        templateUrl: 'angular/tree.html',
        controller: 'TreeCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/tree/:branch', {
        templateUrl: 'angular/tree.html',
        controller: 'TreeCtrl'
      });
      $routeProvider.when('/users/:user', {
        templateUrl: 'angular/user.html',
        controller: 'UserCtrl'
      });
      $routeProvider.otherwise({ redirectTo: '/' });
      return $locationProvider.html5Mode(true);
    }
  ]);
}.call(this));
(function () {
  var _keyStr, _utf8_decode, _utf8_encode;
  _keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
  _utf8_decode = function (utftext) {
    var c, c1, c2, c3, i, string;
    string = '';
    i = 0;
    c = c1 = c2 = 0;
    while (i < utftext.length) {
      c = utftext.charCodeAt(i);
      if (c < 128) {
        string += String.fromCharCode(c);
        i++;
      } else if (c > 191 && c < 224) {
        c2 = utftext.charCodeAt(i + 1);
        string += String.fromCharCode((c & 31) << 6 | c2 & 63);
        i += 2;
      } else {
        c2 = utftext.charCodeAt(i + 1);
        c3 = utftext.charCodeAt(i + 2);
        string += String.fromCharCode((c & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
        i += 3;
      }
    }
    return string;
  };
  _utf8_encode = function (string) {
    var c, n, utftext, _i, _ref;
    string = string.replace(/\r\n/g, '\n');
    utftext = '';
    for (n = _i = 0, _ref = string.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; n = 0 <= _ref ? ++_i : --_i) {
      c = string.charCodeAt(n);
      if (c < 128) {
        utftext += String.fromCharCode(c);
      } else if (c > 127 && c < 2048) {
        utftext += String.fromCharCode(c >> 6 | 192);
        utftext += String.fromCharCode(c & 63 | 128);
      } else {
        utftext += String.fromCharCode(c >> 12 | 224);
        utftext += String.fromCharCode(c >> 6 & 63 | 128);
        utftext += String.fromCharCode(c & 63 | 128);
      }
    }
    return utftext;
  };
  angular.module('app').factory('Base64', [
    '$window',
    function ($window) {
      return {
        decode: function (input) {
          var chr1, chr2, chr3, enc1, enc2, enc3, enc4, i, output;
          output = '';
          i = 0;
          input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
          while (i < input.length) {
            enc1 = _keyStr.indexOf(input.charAt(i++));
            enc2 = _keyStr.indexOf(input.charAt(i++));
            enc3 = _keyStr.indexOf(input.charAt(i++));
            enc4 = _keyStr.indexOf(input.charAt(i++));
            chr1 = enc1 << 2 | enc2 >> 4;
            chr2 = (enc2 & 15) << 4 | enc3 >> 2;
            chr3 = (enc3 & 3) << 6 | enc4;
            output = output + String.fromCharCode(chr1);
            if (enc3 !== 64) {
              output = output + String.fromCharCode(chr2);
            }
            if (enc4 !== 64) {
              output = output + String.fromCharCode(chr3);
            }
          }
          output = _utf8_decode(output);
          return output;
        },
        encode: function (input) {
          var chr1, chr2, chr3, enc1, enc2, enc3, enc4, i, output;
          output = '';
          i = 0;
          input = _utf8_encode(input);
          while (i < input.length) {
            chr1 = input.charCodeAt(i++);
            chr2 = input.charCodeAt(i++);
            chr3 = input.charCodeAt(i++);
            enc1 = chr1 >> 2;
            enc2 = (chr1 & 3) << 4 | chr2 >> 4;
            enc3 = (chr2 & 15) << 2 | chr3 >> 6;
            enc4 = chr3 & 63;
            if (isNaN(chr2)) {
              enc3 = enc4 = 64;
            } else if (isNaN(chr3)) {
              enc4 = 64;
            }
            output = output + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4);
          }
          return output;
        }
      };
    }
  ]);
}.call(this));
(function () {
  angular.module('app').factory('GitHub', [
    '$http',
    function ($http) {
      var GITHUB_DOMAIN, GITHUB_PROTOCOL, Gist, HTTP_METHOD_DELETE, HTTP_METHOD_GET, HTTP_METHOD_PATCH, HTTP_METHOD_POST, HTTP_METHOD_PUT, Repo, User;
      GITHUB_PROTOCOL = 'https';
      GITHUB_DOMAIN = 'api.github.com';
      HTTP_METHOD_DELETE = 'DELETE';
      HTTP_METHOD_GET = 'GET';
      HTTP_METHOD_PATCH = 'PATCH';
      HTTP_METHOD_POST = 'POST';
      HTTP_METHOD_PUT = 'PUT';
      User = function () {
        function User(name, login) {
          this.name = name;
          this.login = login;
        }
        return User;
      }();
      Gist = function () {
        function Gist(id, description, isPublic, files, html_url) {
          this.id = id;
          this.description = description;
          this['public'] = isPublic;
          this.files = files;
          this.html_url = html_url;
        }
        return Gist;
      }();
      Repo = function () {
        function Repo(name, description, language, html_url) {
          this.name = name;
          this.description = description;
          this.language = language;
          this.html_url = html_url;
        }
        return Repo;
      }();
      return {
        getUser: function (token, done) {
          var headers;
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            method: HTTP_METHOD_GET,
            url: '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/user',
            headers: headers
          }).success(function (user, status, headers, config) {
            return done(null, new User(user.name, user.login), status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        getUserRepos: function (token, done) {
          var headers;
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            method: HTTP_METHOD_GET,
            url: '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/user/repos',
            headers: headers
          }).success(function (repos, status, headers, config) {
            repos = _.map(repos, function (repo) {
              return new Repo(repo.name, repo.description, repo.language, repo.html_url);
            });
            return done(null, repos, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        getRepoContents: function (token, user, repo, done) {
          var url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/repos/' + user + '/' + repo + '/contents';
          return $http({
            'method': HTTP_METHOD_GET,
            'url': url,
            'headers': { Authorization: 'token ' + token }
          }).success(function (contents, status, headers, config) {
            return done(null, contents, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        getPathContents: function (token, user, repo, path, done) {
          var headers, url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/repos/' + user + '/' + repo + '/contents';
          if (path) {
            url = '' + url + '/' + path;
          }
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            'method': HTTP_METHOD_GET,
            'url': url,
            'headers': headers
          }).success(function (contents, status, headers, config) {
            return done(null, contents, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        putFile: function (token, owner, repo, path, message, content, sha, done) {
          var data, headers, url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/repos/' + owner + '/' + repo + '/contents/' + path;
          data = {
            message: message,
            content: content
          };
          if (sha) {
            data.sha = sha;
          }
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            method: HTTP_METHOD_PUT,
            url: url,
            data: data,
            headers: headers
          }).success(function (file, status, headers, config) {
            return done(null, file, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        deleteFile: function (token, owner, repo, path, message, sha, done) {
          var data, url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/repos/' + owner + '/' + repo + '/contents/' + path;
          data = {
            message: message,
            sha: sha
          };
          return $http({
            method: HTTP_METHOD_DELETE,
            url: url,
            data: data,
            headers: { Authorization: 'token ' + token }
          }).success(function (file, status, headers, config) {
            return done(null, file, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        postRepo: function (token, name, description, priv, autoInit, done) {
          var data, headers, url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/user/repos';
          data = {
            name: name,
            description: description,
            'private': priv,
            auto_init: autoInit
          };
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            method: HTTP_METHOD_POST,
            url: url,
            data: data,
            headers: headers
          }).success(function (repo, status, headers, config) {
            return done(null, repo, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        deleteRepo: function (token, owner, repo, done) {
          var url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/repos/' + owner + '/' + repo;
          return $http({
            method: HTTP_METHOD_DELETE,
            url: url,
            headers: { Authorization: 'token ' + token }
          }).success(function (repo, status, headers, config) {
            return done(null, repo, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        getGist: function (token, id, done) {
          var headers, url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/gists/' + id;
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            'method': HTTP_METHOD_GET,
            'url': url,
            'headers': headers
          }).success(function (contents, status, headers, config) {
            return done(null, contents, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        patchGist: function (token, gistId, data, done) {
          var headers, url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/gists/' + gistId;
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            method: HTTP_METHOD_PATCH,
            url: url,
            data: data,
            headers: headers
          }).success(function (file, status, headers, config) {
            return done(null, file, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        postGist: function (token, data, done) {
          var headers, url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/gists';
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            method: HTTP_METHOD_POST,
            url: url,
            data: data,
            headers: headers
          }).success(function (response, status, headers, config) {
            return done(null, response, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        deleteGist: function (token, owner, id, done) {
          var url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/gists/' + id;
          return $http({
            method: HTTP_METHOD_DELETE,
            url: url,
            headers: { Authorization: 'token ' + token }
          }).success(function (response, status, headers, config) {
            return done(null, response, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        getUserGists: function (token, user, done) {
          var headers;
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            method: HTTP_METHOD_GET,
            url: '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/users/' + user + '/gists',
            headers: headers
          }).success(function (gists, status, headers, config) {
            gists = _.map(gists, function (gist) {
              return gist;
            });
            return done(null, gists, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        getGists: function (token, done) {
          var headers;
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            method: HTTP_METHOD_GET,
            url: '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/gists',
            headers: headers
          }).success(function (gists, status, headers, config) {
            console.log;
            gists = _.map(gists, function (gist) {
              return new Gist(gist.id, gist.description, gist['public'], gist.files, gist.html_url);
            });
            return done(null, gists, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        }
      };
    }
  ]);
}.call(this));
(function () {
  var module;
  module = angular.module('app');
  module.service('GitHubAuthManager', [
    '$http',
    '$location',
    '$window',
    'cookie',
    'GitHub',
    function ($http, $location, $window, cookie, github) {
      return this.handleLoginCallback = function (done) {
        var GATEKEEPER_DOMAIN, GITHUB_LOGIN_COOKIE_NAME, GITHUB_TOKEN_COOKIE_NAME, code, match;
        GATEKEEPER_DOMAIN = '' + $location.protocol() + '://' + $location.host() + ':' + $location.port();
        GITHUB_TOKEN_COOKIE_NAME = 'github-token';
        GITHUB_LOGIN_COOKIE_NAME = 'github-login';
        match = $window.location.href.match(/\?code=([a-z0-9]*)/);
        if (match) {
          $location.search({});
          code = match[1];
          return $http.get('' + GATEKEEPER_DOMAIN + '/authenticate/' + code).success(function (data, status, headers, config) {
            var token;
            token = data.token;
            cookie.setItem(GITHUB_TOKEN_COOKIE_NAME, token);
            return github.getUser(token, function (error, user) {
              if (!error) {
                cookie.setItem(GITHUB_LOGIN_COOKIE_NAME, user.login);
                return done(null, token);
              } else {
                return done(new Error('Unable to retrieve your user information.'));
              }
            });
          }).error(function (data, status, headers, config) {
            return done(new Error('Unable to retrieve your authentication token.'));
          });
        } else if ($window.location.href.match(/\?error=access_denied/)) {
          return $location.search({});
        }
      };
    }
  ]);
}.call(this));
(function () {
  var module;
  module = angular.module('async', []);
  module.factory('async', [
    '$window',
    function ($window) {
      return $window.async;
    }
  ]);
}.call(this));
(function () {
  angular.module('app').factory('cookie', [function () {
      return {
        getItem: function (name) {
          var escapedName;
          escapedName = escape(name).replace(/[\-\.\+\*]/g, '\\$&');
          return unescape(document.cookie.replace(new RegExp('(?:(?:^|.*;)\\s*' + escapedName + '\\s*\\=\\s*([^;]*).*$)|^.*$'), '$1')) || null;
        },
        setItem: function (name, value, end, path, domain, secure) {
          var cookie, expires;
          if (!name || /^(?:expires|max\-age|path|domain|secure)$/i.test(name)) {
            throw new Error('Illegal name');
          }
          if (end) {
            switch (end.constructor) {
            case Number:
              expires = end === Infinity ? '; expires=Fri, 31 Dec 9999 23:59:59 GMT' : '; max-age=' + end;
              break;
            case String:
              expires = '; expires=' + end;
              break;
            case Date:
              expires = '; expires=' + end.toGMTString();
              break;
            default:
              expires = '';
            }
          } else {
            expires = '';
          }
          domain = domain ? '; domain=' + domain : '';
          path = path ? '; path=' + path : '';
          secure = secure ? '; secure' : '';
          cookie = '' + escape(name) + '=' + escape(value) + expires + domain + path + secure;
          document.cookie = cookie;
        },
        removeItem: function (name, path) {
          if (!name || !this.hasItem(name)) {
            return false;
          }
          return this.setItem(name, '', new Date(0), path);
        },
        hasItem: function (name) {
          return new RegExp('(?:^|;\\s*)' + escape(name).replace(/[\-\.\+\*]/g, '\\$&') + '\\s*\\=').test(document.cookie);
        }
      };
    }]);
}.call(this));
(function () {
  var locale_data_multi;
  locale_data_multi = {
    'messages_3': {
      '': {
        domain: 'messages_3',
        lang: 'en',
        'plural-forms': 'nplurals=2; plural=(n != 1);'
      },
      'test': [
        null,
        'test_1'
      ],
      'test singular': [
        'test plural',
        'test_1 singular',
        'test_1 plural'
      ],
      'context\x04test': [
        null,
        'test_1 context'
      ],
      'context\x04test singular': [
        'test context plural',
        'test_1 context singular',
        'test_1 context plural'
      ]
    },
    'messages_4': {
      '': {
        domain: 'messages_4',
        lang: 'en',
        'plural-forms': 'nplurals=2; plural=(n != 1);'
      },
      'test': [
        null,
        'test_2'
      ],
      'test singular': [
        'test plural',
        'test_2 singular',
        'test_2 plural'
      ],
      'context\x04test': [
        null,
        'test_2 context'
      ],
      'context\x04test singular': [
        'test context plural',
        'test_2 context singular',
        'test_2 context plural'
      ]
    }
  };
  angular.module('jed', []).factory('i18n', [
    '$window',
    function (w) {
      return new w.Jed({
        domain: 'the_domain',
        missing_key_callback: function (key) {
          return console.log(key);
        },
        locale_data: {
          'the_domain': {
            '': {
              domain: 'the_domain',
              lang: 'en',
              'plural-forms': 'nplurals=2; plural=(n != 1);'
            },
            'Create a New Gist': [
              null,
              'Create a New Gist'
            ],
            'Create gist': [
              null,
              'Create gist'
            ],
            'Gist': [
              null,
              'Gist',
              'Gists'
            ],
            'Gist name': [
              null,
              'Gist name'
            ],
            'My Gist': [
              null,
              'My Gist',
              'My Gists'
            ],
            'Great gist names are short and memorable.': [
              null,
              'Great gist names are short and memorable.'
            ],
            'Initialize this gist with a README.md': [
              null,
              'Initialize this gist with a README.md'
            ],
            'This will allow you to clone the gist immediately in GitHub.': [
              null,
              'This will allow you to clone the gist immediately in GitHub.'
            ],
            'Create a New Repo': [
              null,
              'Create a New Repository'
            ],
            'Create repo': [
              null,
              'Create repository'
            ],
            'Repo': [
              null,
              'Repository',
              'Repositories'
            ],
            'Repo name': [
              null,
              'Repository name'
            ],
            'My Repo': [
              null,
              'My Repository',
              'My Repository'
            ],
            'Great repo names are short and memorable.': [
              null,
              'Great repository names are short and memorable.'
            ],
            'Initialize this repo with a README.md': [
              null,
              'Initialize this repository with a README.md'
            ],
            'This will allow you to clone the repo immediately in GitHub.': [
              null,
              'This will allow you to clone the repository immediately in GitHub.'
            ],
            'Create a New File': [
              null,
              'Create a New File'
            ],
            'Create file': [
              null,
              'Create file'
            ],
            'File': [
              null,
              'File',
              'Files'
            ],
            'File name': [
              null,
              'File name'
            ],
            'My Space': [
              null,
              'My Universe'
            ],
            'icon-gist': [
              null,
              'icon-briefcase'
            ],
            'icon-repo': [
              null,
              'icon-briefcase'
            ],
            'icon-dir': [
              null,
              'icon-book'
            ],
            'icon-file': [
              null,
              'icon-file-alt'
            ],
            'icon-question': [
              null,
              'icon-question'
            ]
          }
        }
      });
    }
  ]);
}.call(this));
(function () {
  angular.module('jquery', []).factory('$', [
    '$window',
    function ($window) {
      return $window.$;
    }
  ]);
}.call(this));
(function () {
  angular.module('underscore', []).factory('_', [
    '$window',
    function ($window) {
      return $window._;
    }
  ]);
}.call(this));
angular.module('app').run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('angular/a-home.html', '<a href="/">\n' + '  <i class="icon-home"></i>\n' + '  <span>Home</span>\n' + '</a>\n');
    $templateCache.put('angular/github-authorize.html', '<li>\n' + '  <!-- When logged out, present the user with an OAuth link-->\n' + '  <a ng-hide="isLoggedIn()" ng-href="https://github.com/login/oauth/authorize?client_id={{clientId()}}&amp;scope=repo,user,gist">\n' + '    <i class="icon-signin"></i>\n' + '    <span>Log In</span>\n' + '  </a>\n' + '\n' + '  <!-- TODO: When logged in, we would like to have a dropdown menu-->\n' + '  <a ng-show="isLoggedIn()" ng-click="logout()" href="#">\n' + '    <i class="icon-signout icon-white"></i>\n' + '    <span>{{userLogin()}}</span>\n' + '  </a>\n' + '</li>');
    $templateCache.put('angular/home.html', '<div id="home-view">\n' + '  <div class="subnavbar">\n' + '    <div class="subnavbar-inner">\n' + '      <div class="container">\n' + '        <a class="btn-subnavbar collapsed" data-toggle="collapse" data-target=".subnav-collapse">\n' + '          <i class="icon-reorder"></i>\n' + '        </a>\n' + '        <div class="subnav-collapse collapse">\n' + '          <ul class="mainnav">\n' + '            <li class="active">\n' + '              <a-home></a-home>\n' + '            </li>\n' + '            <li ng-show="isLoggedIn()">\n' + '              <a ng-href="/users/{{userLogin()}}">\n' + '                <i class="icon-user"></i>\n' + '                <span>{{i18n.translate("My Space").fetch()}}</span>\n' + '              </a>\n' + '            </li>\n' + '            <li class="dropdown">\n' + '              <a href="javascript:;" class="dropdown-toggle" data-toggle="dropdown">\n' + '                <i class="icon-eye-open"></i>\n' + '                <span>Learn</span>\n' + '                <b class="caret"></b>\n' + '              </a>\n' + '              <ul class="dropdown-menu">\n' + '                <li><a href="http://geometryzen.github.io/mission/" target="_blank">Our Mission</a></li>\n' + '                <li><a href="/users/geometryzen/repos/demos/tree/master">Browse Examples</a></li>\n' + '                <li><a href="http://geometryzen.github.io/start/" target="_blank">Getting Started</a></li>\n' + '              </ul>\n' + '            </li>\n' + '            <li class="dropdown">\n' + '              <a href="javascript:;" class="dropdown-toggle" data-toggle="dropdown">\n' + '                <i class="icon-external-link"></i>\n' + '                <span>Discuss</span>\n' + '                <b class="caret"></b>\n' + '              </a>\n' + '              <ul class="dropdown-menu">\n' + '                <li><a href="http://groups.google.com/group/geometryzen?src=email&amp;hl=en" target="_blank">Mailing List</a></li>\n' + '                <li><a href="http://webchat.freenode.net/?channels=geometryzen&amp;uio=d4" target="_blank">Web Chat</a></li>\n' + '                <li class="divider"></li>\n' + '                <li><a href="https://twitter.com/#!/geometryzen" target="_blank">Twitter</a></li>\n' + '                <li><a href="https://plus.google.com/u/0/s/Geometry%20Zen/communities" target="_blank">Google+</a></li>\n' + '                <li class="divider"></li>\n' + '                <li class="dropdown-submenu">\n' + '                  <a href="#">Source Code</a>\n' + '                  <ul class="dropdown-menu">\n' + '                    <li><a href="https://github.com/david-geo-holmes/geometry-zen" target="_blank">Application Repository</a></li>\n' + '                    <li><a href="https://github.com/geometryzen/geometryzen.github.io" target="_blank">Documentation Repository</a></li>\n' + '                  </ul>\n' + '                </li>\n' + '                <li class="divider"></li>\n' + '                <li><a href="https://github.com/geometryzen/geometryzen/issues" target="_blank">Issue Tracker</a></li>\n' + '              </ul>\n' + '            </li>\n' + '            <li>\n' + '              <a href="http://geometryzen.github.io/faq/" target="_blank" style="text-decoration: none">\n' + '                <i class="icon-question-sign"></i>\n' + '                <span>FAQ</span>\n' + '              </a>\n' + '            </li>\n' + '            <li>\n' + '              <a href="http://geometryzen.github.io/" target="_blank" style="text-decoration: none">\n' + '                <i class="icon-book"></i>\n' + '                <span>Pages</span>\n' + '              </a>\n' + '            </li>\n' + '          </ul>\n' + '        </div>\n' + '      </div>\n' + '    </div>\n' + '  </div>\n' + '\n' + '  <div class="container-fluid">\n' + '    <div class="row-fluid">\n' + '      <div class="span12">\n' + '        <div class="widget">\n' + '          <div class="widget-content">\n' + '            <div class="text-center">\n' + '              <h1>\n' + '                <large>Geometry Zen</large>\n' + '              </h1>\n' + '              <h1>\n' + '                <small><em>Looking at the multiverse from a Geometric Algebra perspective</em></small>\n' + '              </h1>\n' + '              <br/>\n' + '              <p><em>Geometry Zen</em> is a free, online, open-source, and collaborative tool for <em>Computational Modeling</em> combining the <em>Python</em> programming language, <em>3D visualization</em> (WebGL), <em>Physical Units</em>, and <em>Geometric Algebra</em>, the <em>Unified Mathematical Language for Physics and Engineering in the 21st Century</em>.</p>\n' + '              <p></p>\n' + '              <br/>\n' + '            </div>\n' + '            <div class="text-right">\n' + '              <blockquote>\n' + '                <p class="muted">...for geometry, you know, is the gate of science,<br/>and the gate is so low and small<br/>that one can only enter it as a little child.</p>\n' + '                <small>William K. Clifford</small>\n' + '              </blockquote>\n' + '              <blockquote>\n' + '                <p class="muted">Geometry without algebra is dumb!<br/>Algebra without geometry is blind!</p>\n' + '                <small>David O. Hestenes</small>\n' + '              </blockquote>\n' + '            </div>\n' + '            <div class="text-center">\n' + '              <a href="/users/geometryzen/repos/demos/tree/master" class="btn btn-primary">\n' + '                <i class="icon-th"></i>\n' + '                <span>Browse Examples</span>\n' + '              </a>\n' + '              <a href="{{jumpHRef()}}" class="btn btn-secondary">\n' + '                <i class="{{jumpIcon()}}"></i>\n' + '                <span>{{jumpText()}}</span>\n' + '              </a>\n' + '            </div>\n' + '          </div>\n' + '        </div>\n' + '      </div>\n' + '    </div>\n' + '  </div>\n' + '</div>\n');
    $templateCache.put('angular/printer.html', '<div ng-controller="PrinterCtrl" class="container-fluid">\n' + '  <div class="row-fluid">\n' + '    <div class="span12">\n' + '      <!-- Using anything other than a pre(serve) element is likely too be slow -->\n' + '      <!-- PRESERVE_ELEMENT_ID is defined in the printer controller -->\n' + '      <pre id="a5f435e0-c92e-11e2-8b8b-0800200c9a66" class="printer"></pre>\n' + '    </div>\n' + '  </div>\n' + '</div>\n' + '\n');
    $templateCache.put('angular/tree.html', '<div id="repo-view">\n' + '\n' + '  <div class="subnavbar">\n' + '    <div class="subnavbar-inner">\n' + '      <div class="container">\n' + '        <a class="btn-subnavbar collapsed" data-toggle="collapse" data-target=".subnav-collapse">\n' + '          <i class="icon-reorder"></i>\n' + '        </a>\n' + '        <div class="subnav-collapse collapse">\n' + '          <ul class="mainnav">\n' + '            <li ng-show="isLoggedIn()" class="{{userBreadcrumbClass()}}">\n' + '              <a ng-href="/users/{{user.login}}">\n' + '                <i class="icon-user"></i>\n' + '                <span>{{i18n.translate("My Space").fetch()}}</span>\n' + '              </a>\n' + '            </li>\n' + '            <li class="{{repoBreadcrumbClass()}}">\n' + '              <a ng-click="bookView()" href="#">\n' + '                <i class="{{i18n.translate(\'icon-repo\').fetch()}}"></i>\n' + '                <span>{{i18n.translate("Repo").fetch()}}</span>\n' + '              </a>\n' + '            </li>\n' + '          </ul>\n' + '        </div>\n' + '      </div>\n' + '    </div>\n' + '  </div>\n' + '  \n' + '  <div id="work-layout" class="container-fluid">\n' + '    <div class="row-fluid">\n' + '      <div class="widget">\n' + '        <div class="widget-header">\n' + '          <i class="{{i18n.translate(\'icon-repo\').fetch()}}"></i>\n' + '          <h3>{{repo.name}}</h3>\n' + '        </div>\n' + '        <div class="widget-content">\n' + '          <div>\n' + '            <!--\n' + '            <i class="icon-user muted"></i>\n' + '            <span><a ng-href="/users/{{user.login}}">{{user.login}}</a></span>\n' + '            -->\n' + '            <!--\n' + '            <a ng-href="https://github.com/{{user.login}}" target="_blank" class="muted">\n' + '              <i class="icon-github"></i>\n' + '            </a>\n' + '            -->\n' + '            <span>{{repo.description}}</span>\n' + '          </div>\n' + '          <ul class="nav nav-tabs" id="myTab">\n' + '            <li><a data-target="#items" data-toggle="tab">{{i18n.translate(\'File\').ifPlural(2, \'Files\').fetch()}}</a></li>\n' + '            <!--li><a data-target="#commits" data-toggle="tab">Commits</a></li-->\n' + '            <!--li><a data-target="#branches" data-toggle="tab">Branches</a></li-->\n' + '          </ul>\n' + '          <div class="tab-content">\n' + '            <div class="tab-pane" id="items">\n' + '              <div class ="row-fluid">\n' + '                <table class="table table-condensed">\n' + '                  <tbody>\n' + '                    <tr ng-show="isNewFileEnabled()">\n' + '                      <td nowrap=nowrap>\n' + '                        <!--input type="text" placeHolder="Filter..."></input-->\n' + '                      </td>\n' + '                      <td nowrap=nowrap>\n' + '                        <button ng-click="newFile()" ng-show="isNewFileEnabled()" class="btn btn-primary">\n' + '                          <i class="icon-plus-sign-alt"></i> <i class="{{i18n.translate(\'icon-file\').fetch()}}"></i>\n' + '                          <span>{{i18n.translate("Create a New File").fetch()}}</span>\n' + '                        </button>\n' + '                      </td>\n' + '                    </tr>\n' + '                    <!-- Reminder: An item is a book or a page -->\n' + '                    <tr ng-repeat="item in contextItem.childItems">\n' + '                      <td nowrap=nowrap>\n' + '                        <h3>\n' + '                          <i class="{{i18n.translate(iconFromItem(item)).fetch()}} muted"></i>\n' + '                          <a href="{{hrefFromItem(item)}}" class="btn btn-link">\n' + '                            <span>{{item.name}}</span>\n' + '                          </a>\n' + '                        </h3>\n' + '                      </td>\n' + '                      <td nowrap=nowrap>\n' + '                        <a href="{{item.html_url}}" target="_blank" class="btn btn-secondary">\n' + '                          <i class="icon-github"></i>\n' + '                          <span>GitHub</span>\n' + '                        </a>\n' + '                      </td>\n' + '                    </tr>\n' + '                  </tbody>\n' + '                </table>\n' + '              </div>\n' + '            </div>\n' + '            <div class="tab-pane" id="commits">\n' + '              <p>Under Construction: Commits</p>\n' + '            </div>\n' + '            <div class="tab-pane" id="branches">\n' + '              <p>Under Construction: Branches</p>\n' + '            </div>\n' + '          </div>\n' + '          <script>\n' + '            $(function () {\n' + '              $(\'#myTab a[data-target="#items"]\').tab(\'show\');\n' + '            })\n' + '          </script>\n' + '          <script>\n' + '            $(\'#myTab a[data-target="#items"]\').click(function(e) {\n' + '              e.preventDefault();\n' + '              $(this).tab(\'show\');\n' + '            });\n' + '          </script>\n' + '          <script>\n' + '            $(\'#myTab a[data-target="#commits"]\').click(function(e) {\n' + '              e.preventDefault();\n' + '              $(this).tab(\'show\');\n' + '            });\n' + '          </script>\n' + '          <script>\n' + '            $(\'#myTab a[data-target="#branches"]\').click(function(e) {\n' + '              e.preventDefault();\n' + '              $(this).tab(\'show\');\n' + '            });\n' + '          </script>\n' + '        </div> <!-- div.widget-content -->\n' + '      </div> <!-- div.widget -->\n' + '    </div> <!-- div.row-fluid -->\n' + '  </div> <!-- div.container-fluid -->\n' + '  <div id="new-file-dialog" class="modal hide fade" tabindex="-1" role="dialog" aria-labelledby="new-file-dialog-label" aria-hidden="true">\n' + '    <div class="modal-header">\n' + '      <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>\n' + '      <h3 id="new-file-dialog-label"><i class="icon-plus-sign-alt muted"></i> <i class="{{i18n.translate(\'icon-file\').fetch()}} muted"></i> {{i18n.translate("Create a New File").fetch()}}</h3>\n' + '    </div>\n' + '    <form ng-controller="NewFileCtrl">\n' + '      <fieldset>\n' + '        <div class="modal-body">\n' + '          <label>{{i18n.translate(\'File name\').fetch()}}</label>\n' + '          <input type="text" name="name" ng-model="file.name"></input>\n' + '          <label>Commit message:</label>\n' + '          <input type="text" name="message" ng-model="file.message" placeholder="{{i18n.translate(\'Create file\').fetch()}}"></input>\n' + '        </div>\n' + '        <div class="modal-footer">\n' + '          <button id="btnCancel" class="btn" data-dismiss="modal" aria-hidden="true">Close</button>\n' + '          <button type="submit" ng-click="createFile()" id="btnOK" class="btn btn-primary">{{i18n.translate("Create file").fetch()}}</button>\n' + '        </div>\n' + '      </fieldset>\n' + '    </form>\n' + '  </div>\n' + '</div>\n');
    $templateCache.put('angular/user.html', '<div id="user-view">\n' + '  <div class="subnavbar">\n' + '    <div class="subnavbar-inner">\n' + '      <div class="container">\n' + '        <a class="btn-subnavbar collapsed" data-toggle="collapse" data-target=".subnav-collapse">\n' + '          <i class="icon-reorder"></i>\n' + '        </a>\n' + '        <div class="subnav-collapse collapse">\n' + '          <ul class="mainnav">\n' + '            <li class="{{userBreadcrumbClass()}}">\n' + '              <a ng-href="/users/{{user.login}}">\n' + '                <i class="icon-user"></i>\n' + '                <span>{{i18n.translate("My Space").fetch()}}</span>\n' + '              </a>\n' + '            </li>\n' + '            <li>\n' + '              <a ng-href="/workbench" href="#">\n' + '                <i class="icon-edit"></i>\n' + '                <span>Workbench</span>\n' + '              </a>\n' + '            </li>\n' + '          </ul>\n' + '        </div> <!-- /.subnav-collapse -->\n' + '      </div> <!-- /container -->\n' + '    </div> <!-- /subnavbar-inner -->\n' + '  </div> <!-- /subnavbar -->\n' + '\n' + '  <div class="container-fluid">\n' + '    <div class="row-fluid">\n' + '      <div class="span4">\n' + '        <div class="widget">\n' + '          <div class="widget-header">\n' + '              <i class="icon-user"></i>\n' + '              <h3>Profile</h3>\n' + '          </div>\n' + '          <div class="widget-content">\n' + '            <h3>\n' + '              <span>{{user.name}}</span>\n' + '            </h3>\n' + '            <h4>\n' + '              <span>{{user.login}}</span>\n' + '            </h4>\n' + '            <!-- HATEOAS GitHub link? -->\n' + '            <!--\n' + '            <a href="https://github.com/{{user.login}}?tab=repositories" target="_blank" class="btn btn-secondary">\n' + '              <i class="icon-github"></i>\n' + '              <span>GitHub</span>\n' + '            </a>\n' + '            -->\n' + '          </div>\n' + '        </div>\n' + '      </div>\n' + '      <div class="span8">\n' + '        <div class="widget stacked">\n' + '          <div class="widget-content">\n' + '            <ul class="nav nav-tabs" id="myTab">\n' + '              <li><a data-target="#gists" data-toggle="tab">{{i18n.translate("Gist").ifPlural(2, "Gists").fetch()}}</a></li>\n' + '              <li><a data-target="#repos" data-toggle="tab">{{i18n.translate("Repo").ifPlural(2, "Repos").fetch()}}</a></li>\n' + '            </ul>\n' + '            <div class="tab-content">\n' + '              <div class="tab-pane" id="gists">\n' + '                <div class ="row-fluid">\n' + '                  <table class="table table-condensed">\n' + '                    <tbody>\n' + '                      <tr>\n' + '                        <td nowrap=nowrap>\n' + '                          <!--input type="text" placeHolder="Filter..."></input-->\n' + '                        </td>\n' + '                        <td nowrap=nowrap>\n' + '                          <button ng-click="newGist()" class="btn btn-primary">\n' + '                            <i class="icon-plus-sign-alt"></i> <i class="{{i18n.translate(\'icon-gist\').fetch()}}"></i>\n' + '                            <span>{{i18n.translate("Create a New Gist").fetch()}}</span>\n' + '                          </button>\n' + '                        </td>\n' + '                      </tr>\n' + '                      <tr ng-repeat="gist in gists">\n' + '                        <td nowrap=nowrap>\n' + '                          <h3>\n' + '                            <i class="{{i18n.translate(\'icon-gist\').fetch()}} muted"></i>\n' + '                            <a href="/gists/{{gist.id}}" class="btn btn-link">\n' + '                              <span>{{gist.id}}</span>\n' + '                            </a>\n' + '                          </h3>\n' + '                          <p>{{gist.description}}</p>\n' + '                        </td>\n' + '                        <td nowrap=nowrap>\n' + '                          <a href="{{gist.html_url}}" target="_blank" class="btn btn-secondary">\n' + '                            <i class="icon-github"></i>\n' + '                            <span>GitHub</span>\n' + '                          </a>\n' + '                          <!--\n' + '                          <button ng-click="deleteGist(user.login, gist.id)" class="btn btn-tertiary">\n' + '                            <i class="icon-minus-sign-alt"></i>\n' + '                            <span>Delete</span>\n' + '                          </button>\n' + '                          -->\n' + '                        </td>\n' + '                      </tr>\n' + '                    </tbody>\n' + '                  </table>\n' + '                </div>\n' + '              </div>\n' + '              <div class="tab-pane" id="repos">\n' + '                <div class ="row-fluid">\n' + '                  <table class="table table-condensed">\n' + '                    <tbody>\n' + '                      <tr>\n' + '                        <td nowrap=nowrap>\n' + '                          <!--input type="text" placeHolder="Filter..."></input-->\n' + '                        </td>\n' + '                        <td nowrap=nowrap>\n' + '                          <button ng-click="newRepo(user.login)" class="btn btn-primary">\n' + '                            <i class="icon-plus-sign-alt"></i> <i class="{{i18n.translate(\'icon-repo\').fetch()}}"></i>\n' + '                            <span>{{i18n.translate("Create a New Repo").fetch()}}</span>\n' + '                          </button>\n' + '                        </td>\n' + '                      </tr>\n' + '                      <tr ng-repeat="repo in repos">\n' + '                        <td nowrap=nowrap>\n' + '                          <h3>\n' + '                            <i class="{{i18n.translate(\'icon-repo\').fetch()}} muted"></i>\n' + '                            <a href="/users/{{user.login}}/repos/{{repo.name}}/tree/master" class="btn btn-link">\n' + '                              <span>{{repo.name}}</span>\n' + '                            </a>\n' + '                          </h3>\n' + '                          <p>{{repo.description}}</p>\n' + '                        </td>\n' + '                        <td nowrap=nowrap>\n' + '                          <a href="{{repo.html_url}}" target="_blank" class="btn btn-secondary">\n' + '                            <i class="icon-github"></i>\n' + '                            <span>GitHub</span>\n' + '                          </a>\n' + '                          <!--\n' + '                          <button ng-click="deleteRepo(user.login, repo.name)" class="btn btn-tertiary">\n' + '                            <i class="icon-minus-sign-alt"></i>\n' + '                            <span>Delete</span>\n' + '                          </button>\n' + '                          -->\n' + '                        </td>\n' + '                      </tr>\n' + '                    </tbody>\n' + '                  </table>\n' + '                </div>\n' + '              </div>\n' + '            </div>\n' + '            <script>\n' + '              $(function () {\n' + '                $(\'#myTab a[data-target="#gists"]\').tab(\'show\');\n' + '              })\n' + '            </script>\n' + '            <script>\n' + '              $(\'#myTab a[data-target="#gists"]\').click(function(e) {\n' + '                e.preventDefault();\n' + '                $(this).tab(\'show\');\n' + '              });\n' + '            </script>\n' + '            <script>\n' + '              $(\'#myTab a[data-target="#repos"]\').click(function(e) {\n' + '                e.preventDefault();\n' + '                $(this).tab(\'show\');\n' + '              });\n' + '            </script>\n' + '          </div>\n' + '        </div>\n' + '\n' + '        <div id="new-gist-dialog" class="modal hide fade" tabindex="-1" role="dialog" aria-labelledby="new-gist-dialog-label" aria-hidden="true">\n' + '          <div class="modal-header">\n' + '            <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>\n' + '            <h3 id="new-gist-dialog-label"><i class="icon-plus-sign-alt muted"></i> <i class="{{i18n.translate(\'icon-gist\').fetch()}} muted"></i> {{i18n.translate("Create a New Gist").fetch()}}</h3>\n' + '          </div>\n' + '          <form ng-controller="NewGistCtrl">\n' + '            <fieldset>\n' + '              <div class="modal-body">\n' + '                <label>Description<span class="muted"> (optional)</span></label>\n' + '                <input type="text" name="description" ng-model="gist.description"></input>\n' + '              </div>\n' + '              <div class="modal-footer">\n' + '                <button id="btnCancel" class="btn" data-dismiss="modal" aria-hidden="true">Close</button>\n' + '                <button type="submit" ng-click="createGist()" id="btnOK" class="btn btn-primary">{{i18n.translate("Create gist").fetch()}}</button>\n' + '              </div>\n' + '            </fieldset>\n' + '          </form>\n' + '        </div>\n' + '\n' + '        <div id="new-repo-dialog" class="modal hide fade" tabindex="-1" role="dialog" aria-labelledby="new-repo-dialog-label" aria-hidden="true">\n' + '          <div class="modal-header">\n' + '            <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>\n' + '            <h3 id="new-repo-dialog-label"><i class="icon-plus-sign-alt muted"></i> <i class="{{i18n.translate(\'icon-repo\').fetch()}} muted"></i> {{i18n.translate("Create a New Repo").fetch()}}</h3>\n' + '          </div>\n' + '          <form ng-controller="NewRepoCtrl">\n' + '            <fieldset>\n' + '              <div class="modal-body">\n' + '                <label>{{i18n.translate("Repo name").fetch()}}</label>\n' + '                <input type="text" name="repo" ng-model="repo.name"></input>\n' + '                <span class="help-block">{{i18n.translate("Great repo names are short and memorable.").fetch()}}</span>\n' + '                <label>Description<span class="muted"> (optional)</span></label>\n' + '                <input type="text" name="description" ng-model="repo.description"></input>\n' + '                <!--\n' + '                <hr/>\n' + '                <input type="radio" ng-model="repo.private" value="false"> <i class="{{i18n.translate(\'icon-repo\').fetch()}} muted"></i> Public<br/>\n' + '                <span class="help-block">Anyone can see this repository. You choose who can commit.</span>\n' + '                <input type="radio" ng-model="repo.private" value="true"> Private <br/>\n' + '                <span class="help-block">You choose who can see and commit to this repository.</span>\n' + '                -->\n' + '                <hr/>\n' + '                <label class="checkbox">\n' + '                  <input type="checkbox" name="markdown-readme" ng-model="repo.markdownReadme"> {{i18n.translate("Initialize this repo with a README.md").fetch()}}</input>\n' + '                </label>\n' + '                <span class="help-block">{{i18n.translate("This will allow you to clone the repo immediately in GitHub.").fetch()}}</span>\n' + '                <!--\n' + '                <label class="checkbox">\n' + '                  <input type="checkbox" name="python-readme" ng-model="repo.pythonReadme"> Initialize this book with a README.py</input>\n' + '                </label>\n' + '                <span class="help-block">Having at least one Python file will ensure that the GitHub repository is visible to Geometry Zen.</span>\n' + '                -->\n' + '              </div>\n' + '              <div class="modal-footer">\n' + '                <button id="btnCancel" class="btn" data-dismiss="modal" aria-hidden="true">Close</button>\n' + '                <button type="submit" ng-click="createRepo()" id="btnOK" class="btn btn-primary">{{i18n.translate("Create repo").fetch()}}</button>\n' + '              </div>\n' + '            </fieldset>\n' + '          </form>\n' + '        </div>\n' + '\n' + '      </div>\n' + '    </div>\n' + '  </div>\n' + '</div>');
    $templateCache.put('angular/work.html', '<div id="work-view">\n' + '  <div class="subnavbar">\n' + '    <div class="subnavbar-inner">\n' + '      <div class="container">\n' + '        <a class="btn-subnavbar collapsed" data-toggle="collapse" data-target=".subnav-collapse">\n' + '          <i class="icon-reorder"></i>\n' + '        </a>\n' + '        <div class="subnav-collapse collapse">\n' + '          <ul class="mainnav">\n' + '            <li ng-show="isLoggedIn()" class="{{userBreadcrumbClass()}}">\n' + '              <a ng-href="/users/{{user.name}}">\n' + '                <i class="icon-user"></i>\n' + '                <span>{{i18n.translate("My Space").fetch()}}</span>\n' + '              </a>\n' + '            </li>\n' + '            <li class="active">\n' + '              <a ng-click="reload()" href="#">\n' + '                <i class="icon-edit"></i>\n' + '                <span>Workbench</span>\n' + '              </a>\n' + '            </li>\n' + '            <li ng-show="saveEnabled()">\n' + '              <a ng-click="saveFile()" href="#">\n' + '                <i class="icon-save"></i>\n' + '                <span>Save</span>\n' + '              </a>\n' + '            </li>\n' + '            <li ng-show="runEnabled()">\n' + '              <a ng-click="run()" href="#">\n' + '                <i class="icon-cogs"></i>\n' + '                <span>Run</span>\n' + '              </a>\n' + '            </li>\n' + '          </ul>\n' + '        </div>\n' + '      </div>\n' + '    </div>\n' + '  </div>\n' + '  \n' + '  <div id="work-layout" class="container-fluid">\n' + '\n' + '    <div class="row-fluid">\n' + '      <div class="span6">\n' + '        <div class="alert alert-block alert-{{message.severity}}" ng-repeat="message in messages"  ng-show="messages.length &gt; 0">\n' + '          <button type="button" class="close" data-dismiss="alert">&times;</button>\n' + '          <h4>{{message.name}}</h4>\n' + '          {{message.text}}\n' + '        </div>\n' + '        <div id="textarea-container">\n' + '          <textarea id="code"></textarea>\n' + '        </div>\n' + '      </div>\n' + '      <div class="span6">\n' + '        <div id="printer-container">\n' + '          <printer></printer>\n' + '        </div>\n' + '        <div id="graph-container">\n' + '        </div>\n' + '        <div id="canvas-container">\n' + '        </div>\n' + '      </div>\n' + '    </div>\n' + '\n' + '  </div>\n' + '</div>');
  }
]);