(function () {
  var async = {};
  var root, previous_async;
  root = this;
  if (root != null) {
    previous_async = root.async;
  }
  async.noConflict = function () {
    root.async = previous_async;
    return async;
  };
  function only_once(fn) {
    var called = false;
    return function () {
      if (called)
        throw new Error('Callback was already called.');
      called = true;
      fn.apply(root, arguments);
    };
  }
  var _each = function (arr, iterator) {
    if (arr.forEach) {
      return arr.forEach(iterator);
    }
    for (var i = 0; i < arr.length; i += 1) {
      iterator(arr[i], i, arr);
    }
  };
  var _map = function (arr, iterator) {
    if (arr.map) {
      return arr.map(iterator);
    }
    var results = [];
    _each(arr, function (x, i, a) {
      results.push(iterator(x, i, a));
    });
    return results;
  };
  var _reduce = function (arr, iterator, memo) {
    if (arr.reduce) {
      return arr.reduce(iterator, memo);
    }
    _each(arr, function (x, i, a) {
      memo = iterator(memo, x, i, a);
    });
    return memo;
  };
  var _keys = function (obj) {
    if (Object.keys) {
      return Object.keys(obj);
    }
    var keys = [];
    for (var k in obj) {
      if (obj.hasOwnProperty(k)) {
        keys.push(k);
      }
    }
    return keys;
  };
  if (typeof process === 'undefined' || !process.nextTick) {
    if (typeof setImmediate === 'function') {
      async.nextTick = function (fn) {
        setImmediate(fn);
      };
    } else {
      async.nextTick = function (fn) {
        setTimeout(fn, 0);
      };
    }
  } else {
    async.nextTick = process.nextTick;
  }
  async.each = function (arr, iterator, callback) {
    callback = callback || function () {
    };
    if (!arr.length) {
      return callback();
    }
    var completed = 0;
    _each(arr, function (x) {
      iterator(x, only_once(function (err) {
        if (err) {
          callback(err);
          callback = function () {
          };
        } else {
          completed += 1;
          if (completed >= arr.length) {
            callback(null);
          }
        }
      }));
    });
  };
  async.forEach = async.each;
  async.eachSeries = function (arr, iterator, callback) {
    callback = callback || function () {
    };
    if (!arr.length) {
      return callback();
    }
    var completed = 0;
    var iterate = function () {
      var sync = true;
      iterator(arr[completed], function (err) {
        if (err) {
          callback(err);
          callback = function () {
          };
        } else {
          completed += 1;
          if (completed >= arr.length) {
            callback(null);
          } else {
            if (sync) {
              async.nextTick(iterate);
            } else {
              iterate();
            }
          }
        }
      });
      sync = false;
    };
    iterate();
  };
  async.forEachSeries = async.eachSeries;
  async.eachLimit = function (arr, limit, iterator, callback) {
    var fn = _eachLimit(limit);
    fn.apply(null, [
      arr,
      iterator,
      callback
    ]);
  };
  async.forEachLimit = async.eachLimit;
  var _eachLimit = function (limit) {
    return function (arr, iterator, callback) {
      callback = callback || function () {
      };
      if (!arr.length || limit <= 0) {
        return callback();
      }
      var completed = 0;
      var started = 0;
      var running = 0;
      (function replenish() {
        if (completed >= arr.length) {
          return callback();
        }
        while (running < limit && started < arr.length) {
          started += 1;
          running += 1;
          iterator(arr[started - 1], function (err) {
            if (err) {
              callback(err);
              callback = function () {
              };
            } else {
              completed += 1;
              running -= 1;
              if (completed >= arr.length) {
                callback();
              } else {
                replenish();
              }
            }
          });
        }
      }());
    };
  };
  var doParallel = function (fn) {
    return function () {
      var args = Array.prototype.slice.call(arguments);
      return fn.apply(null, [async.each].concat(args));
    };
  };
  var doParallelLimit = function (limit, fn) {
    return function () {
      var args = Array.prototype.slice.call(arguments);
      return fn.apply(null, [_eachLimit(limit)].concat(args));
    };
  };
  var doSeries = function (fn) {
    return function () {
      var args = Array.prototype.slice.call(arguments);
      return fn.apply(null, [async.eachSeries].concat(args));
    };
  };
  var _asyncMap = function (eachfn, arr, iterator, callback) {
    var results = [];
    arr = _map(arr, function (x, i) {
      return {
        index: i,
        value: x
      };
    });
    eachfn(arr, function (x, callback) {
      iterator(x.value, function (err, v) {
        results[x.index] = v;
        callback(err);
      });
    }, function (err) {
      callback(err, results);
    });
  };
  async.map = doParallel(_asyncMap);
  async.mapSeries = doSeries(_asyncMap);
  async.mapLimit = function (arr, limit, iterator, callback) {
    return _mapLimit(limit)(arr, iterator, callback);
  };
  var _mapLimit = function (limit) {
    return doParallelLimit(limit, _asyncMap);
  };
  async.reduce = function (arr, memo, iterator, callback) {
    async.eachSeries(arr, function (x, callback) {
      iterator(memo, x, function (err, v) {
        memo = v;
        callback(err);
      });
    }, function (err) {
      callback(err, memo);
    });
  };
  async.inject = async.reduce;
  async.foldl = async.reduce;
  async.reduceRight = function (arr, memo, iterator, callback) {
    var reversed = _map(arr, function (x) {
        return x;
      }).reverse();
    async.reduce(reversed, memo, iterator, callback);
  };
  async.foldr = async.reduceRight;
  var _filter = function (eachfn, arr, iterator, callback) {
    var results = [];
    arr = _map(arr, function (x, i) {
      return {
        index: i,
        value: x
      };
    });
    eachfn(arr, function (x, callback) {
      iterator(x.value, function (v) {
        if (v) {
          results.push(x);
        }
        callback();
      });
    }, function (err) {
      callback(_map(results.sort(function (a, b) {
        return a.index - b.index;
      }), function (x) {
        return x.value;
      }));
    });
  };
  async.filter = doParallel(_filter);
  async.filterSeries = doSeries(_filter);
  async.select = async.filter;
  async.selectSeries = async.filterSeries;
  var _reject = function (eachfn, arr, iterator, callback) {
    var results = [];
    arr = _map(arr, function (x, i) {
      return {
        index: i,
        value: x
      };
    });
    eachfn(arr, function (x, callback) {
      iterator(x.value, function (v) {
        if (!v) {
          results.push(x);
        }
        callback();
      });
    }, function (err) {
      callback(_map(results.sort(function (a, b) {
        return a.index - b.index;
      }), function (x) {
        return x.value;
      }));
    });
  };
  async.reject = doParallel(_reject);
  async.rejectSeries = doSeries(_reject);
  var _detect = function (eachfn, arr, iterator, main_callback) {
    eachfn(arr, function (x, callback) {
      iterator(x, function (result) {
        if (result) {
          main_callback(x);
          main_callback = function () {
          };
        } else {
          callback();
        }
      });
    }, function (err) {
      main_callback();
    });
  };
  async.detect = doParallel(_detect);
  async.detectSeries = doSeries(_detect);
  async.some = function (arr, iterator, main_callback) {
    async.each(arr, function (x, callback) {
      iterator(x, function (v) {
        if (v) {
          main_callback(true);
          main_callback = function () {
          };
        }
        callback();
      });
    }, function (err) {
      main_callback(false);
    });
  };
  async.any = async.some;
  async.every = function (arr, iterator, main_callback) {
    async.each(arr, function (x, callback) {
      iterator(x, function (v) {
        if (!v) {
          main_callback(false);
          main_callback = function () {
          };
        }
        callback();
      });
    }, function (err) {
      main_callback(true);
    });
  };
  async.all = async.every;
  async.sortBy = function (arr, iterator, callback) {
    async.map(arr, function (x, callback) {
      iterator(x, function (err, criteria) {
        if (err) {
          callback(err);
        } else {
          callback(null, {
            value: x,
            criteria: criteria
          });
        }
      });
    }, function (err, results) {
      if (err) {
        return callback(err);
      } else {
        var fn = function (left, right) {
          var a = left.criteria, b = right.criteria;
          return a < b ? -1 : a > b ? 1 : 0;
        };
        callback(null, _map(results.sort(fn), function (x) {
          return x.value;
        }));
      }
    });
  };
  async.auto = function (tasks, callback) {
    callback = callback || function () {
    };
    var keys = _keys(tasks);
    if (!keys.length) {
      return callback(null);
    }
    var results = {};
    var listeners = [];
    var addListener = function (fn) {
      listeners.unshift(fn);
    };
    var removeListener = function (fn) {
      for (var i = 0; i < listeners.length; i += 1) {
        if (listeners[i] === fn) {
          listeners.splice(i, 1);
          return;
        }
      }
    };
    var taskComplete = function () {
      _each(listeners.slice(0), function (fn) {
        fn();
      });
    };
    addListener(function () {
      if (_keys(results).length === keys.length) {
        callback(null, results);
        callback = function () {
        };
      }
    });
    _each(keys, function (k) {
      var task = tasks[k] instanceof Function ? [tasks[k]] : tasks[k];
      var taskCallback = function (err) {
        if (err) {
          callback(err);
          callback = function () {
          };
        } else {
          var args = Array.prototype.slice.call(arguments, 1);
          if (args.length <= 1) {
            args = args[0];
          }
          results[k] = args;
          async.nextTick(taskComplete);
        }
      };
      var requires = task.slice(0, Math.abs(task.length - 1)) || [];
      var ready = function () {
        return _reduce(requires, function (a, x) {
          return a && results.hasOwnProperty(x);
        }, true) && !results.hasOwnProperty(k);
      };
      if (ready()) {
        task[task.length - 1](taskCallback, results);
      } else {
        var listener = function () {
          if (ready()) {
            removeListener(listener);
            task[task.length - 1](taskCallback, results);
          }
        };
        addListener(listener);
      }
    });
  };
  async.waterfall = function (tasks, callback) {
    callback = callback || function () {
    };
    if (!tasks.length) {
      return callback();
    }
    var wrapIterator = function (iterator) {
      return function (err) {
        if (err) {
          callback.apply(null, arguments);
          callback = function () {
          };
        } else {
          var args = Array.prototype.slice.call(arguments, 1);
          var next = iterator.next();
          if (next) {
            args.push(wrapIterator(next));
          } else {
            args.push(callback);
          }
          async.nextTick(function () {
            iterator.apply(null, args);
          });
        }
      };
    };
    wrapIterator(async.iterator(tasks))();
  };
  var _parallel = function (eachfn, tasks, callback) {
    callback = callback || function () {
    };
    if (tasks.constructor === Array) {
      eachfn.map(tasks, function (fn, callback) {
        if (fn) {
          fn(function (err) {
            var args = Array.prototype.slice.call(arguments, 1);
            if (args.length <= 1) {
              args = args[0];
            }
            callback.call(null, err, args);
          });
        }
      }, callback);
    } else {
      var results = {};
      eachfn.each(_keys(tasks), function (k, callback) {
        tasks[k](function (err) {
          var args = Array.prototype.slice.call(arguments, 1);
          if (args.length <= 1) {
            args = args[0];
          }
          results[k] = args;
          callback(err);
        });
      }, function (err) {
        callback(err, results);
      });
    }
  };
  async.parallel = function (tasks, callback) {
    _parallel({
      map: async.map,
      each: async.each
    }, tasks, callback);
  };
  async.parallelLimit = function (tasks, limit, callback) {
    _parallel({
      map: _mapLimit(limit),
      each: _eachLimit(limit)
    }, tasks, callback);
  };
  async.series = function (tasks, callback) {
    callback = callback || function () {
    };
    if (tasks.constructor === Array) {
      async.mapSeries(tasks, function (fn, callback) {
        if (fn) {
          fn(function (err) {
            var args = Array.prototype.slice.call(arguments, 1);
            if (args.length <= 1) {
              args = args[0];
            }
            callback.call(null, err, args);
          });
        }
      }, callback);
    } else {
      var results = {};
      async.eachSeries(_keys(tasks), function (k, callback) {
        tasks[k](function (err) {
          var args = Array.prototype.slice.call(arguments, 1);
          if (args.length <= 1) {
            args = args[0];
          }
          results[k] = args;
          callback(err);
        });
      }, function (err) {
        callback(err, results);
      });
    }
  };
  async.iterator = function (tasks) {
    var makeCallback = function (index) {
      var fn = function () {
        if (tasks.length) {
          tasks[index].apply(null, arguments);
        }
        return fn.next();
      };
      fn.next = function () {
        return index < tasks.length - 1 ? makeCallback(index + 1) : null;
      };
      return fn;
    };
    return makeCallback(0);
  };
  async.apply = function (fn) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function () {
      return fn.apply(null, args.concat(Array.prototype.slice.call(arguments)));
    };
  };
  var _concat = function (eachfn, arr, fn, callback) {
    var r = [];
    eachfn(arr, function (x, cb) {
      fn(x, function (err, y) {
        r = r.concat(y || []);
        cb(err);
      });
    }, function (err) {
      callback(err, r);
    });
  };
  async.concat = doParallel(_concat);
  async.concatSeries = doSeries(_concat);
  async.whilst = function (test, iterator, callback) {
    if (test()) {
      var sync = true;
      iterator(function (err) {
        if (err) {
          return callback(err);
        }
        if (sync) {
          async.nextTick(function () {
            async.whilst(test, iterator, callback);
          });
        } else {
          async.whilst(test, iterator, callback);
        }
      });
      sync = false;
    } else {
      callback();
    }
  };
  async.doWhilst = function (iterator, test, callback) {
    var sync = true;
    iterator(function (err) {
      if (err) {
        return callback(err);
      }
      if (test()) {
        if (sync) {
          async.nextTick(function () {
            async.doWhilst(iterator, test, callback);
          });
        } else {
          async.doWhilst(iterator, test, callback);
        }
      } else {
        callback();
      }
    });
    sync = false;
  };
  async.until = function (test, iterator, callback) {
    if (!test()) {
      var sync = true;
      iterator(function (err) {
        if (err) {
          return callback(err);
        }
        if (sync) {
          async.nextTick(function () {
            async.until(test, iterator, callback);
          });
        } else {
          async.until(test, iterator, callback);
        }
      });
      sync = false;
    } else {
      callback();
    }
  };
  async.doUntil = function (iterator, test, callback) {
    var sync = true;
    iterator(function (err) {
      if (err) {
        return callback(err);
      }
      if (!test()) {
        if (sync) {
          async.nextTick(function () {
            async.doUntil(iterator, test, callback);
          });
        } else {
          async.doUntil(iterator, test, callback);
        }
      } else {
        callback();
      }
    });
    sync = false;
  };
  async.queue = function (worker, concurrency) {
    function _insert(q, data, pos, callback) {
      if (data.constructor !== Array) {
        data = [data];
      }
      _each(data, function (task) {
        var item = {
            data: task,
            callback: typeof callback === 'function' ? callback : null
          };
        if (pos) {
          q.tasks.unshift(item);
        } else {
          q.tasks.push(item);
        }
        if (q.saturated && q.tasks.length === concurrency) {
          q.saturated();
        }
        async.nextTick(q.process);
      });
    }
    var workers = 0;
    var q = {
        tasks: [],
        concurrency: concurrency,
        saturated: null,
        empty: null,
        drain: null,
        push: function (data, callback) {
          _insert(q, data, false, callback);
        },
        unshift: function (data, callback) {
          _insert(q, data, true, callback);
        },
        process: function () {
          if (workers < q.concurrency && q.tasks.length) {
            var task = q.tasks.shift();
            if (q.empty && q.tasks.length === 0) {
              q.empty();
            }
            workers += 1;
            var sync = true;
            var next = function () {
              workers -= 1;
              if (task.callback) {
                task.callback.apply(task, arguments);
              }
              if (q.drain && q.tasks.length + workers === 0) {
                q.drain();
              }
              q.process();
            };
            var cb = only_once(function () {
                var cbArgs = arguments;
                if (sync) {
                  async.nextTick(function () {
                    next.apply(null, cbArgs);
                  });
                } else {
                  next.apply(null, arguments);
                }
              });
            worker(task.data, cb);
            sync = false;
          }
        },
        length: function () {
          return q.tasks.length;
        },
        running: function () {
          return workers;
        }
      };
    return q;
  };
  async.cargo = function (worker, payload) {
    var working = false, tasks = [];
    var cargo = {
        tasks: tasks,
        payload: payload,
        saturated: null,
        empty: null,
        drain: null,
        push: function (data, callback) {
          if (data.constructor !== Array) {
            data = [data];
          }
          _each(data, function (task) {
            tasks.push({
              data: task,
              callback: typeof callback === 'function' ? callback : null
            });
            if (cargo.saturated && tasks.length === payload) {
              cargo.saturated();
            }
          });
          async.nextTick(cargo.process);
        },
        process: function process() {
          if (working)
            return;
          if (tasks.length === 0) {
            if (cargo.drain)
              cargo.drain();
            return;
          }
          var ts = typeof payload === 'number' ? tasks.splice(0, payload) : tasks.splice(0);
          var ds = _map(ts, function (task) {
              return task.data;
            });
          if (cargo.empty)
            cargo.empty();
          working = true;
          worker(ds, function () {
            working = false;
            var args = arguments;
            _each(ts, function (data) {
              if (data.callback) {
                data.callback.apply(null, args);
              }
            });
            process();
          });
        },
        length: function () {
          return tasks.length;
        },
        running: function () {
          return working;
        }
      };
    return cargo;
  };
  var _console_fn = function (name) {
    return function (fn) {
      var args = Array.prototype.slice.call(arguments, 1);
      fn.apply(null, args.concat([function (err) {
          var args = Array.prototype.slice.call(arguments, 1);
          if (typeof console !== 'undefined') {
            if (err) {
              if (console.error) {
                console.error(err);
              }
            } else if (console[name]) {
              _each(args, function (x) {
                console[name](x);
              });
            }
          }
        }]));
    };
  };
  async.log = _console_fn('log');
  async.dir = _console_fn('dir');
  async.memoize = function (fn, hasher) {
    var memo = {};
    var queues = {};
    hasher = hasher || function (x) {
      return x;
    };
    var memoized = function () {
      var args = Array.prototype.slice.call(arguments);
      var callback = args.pop();
      var key = hasher.apply(null, args);
      if (key in memo) {
        callback.apply(null, memo[key]);
      } else if (key in queues) {
        queues[key].push(callback);
      } else {
        queues[key] = [callback];
        fn.apply(null, args.concat([function () {
            memo[key] = arguments;
            var q = queues[key];
            delete queues[key];
            for (var i = 0, l = q.length; i < l; i++) {
              q[i].apply(null, arguments);
            }
          }]));
      }
    };
    memoized.memo = memo;
    memoized.unmemoized = fn;
    return memoized;
  };
  async.unmemoize = function (fn) {
    return function () {
      return (fn.unmemoized || fn).apply(null, arguments);
    };
  };
  async.times = function (count, iterator, callback) {
    var counter = [];
    for (var i = 0; i < count; i++) {
      counter.push(i);
    }
    return async.map(counter, iterator, callback);
  };
  async.timesSeries = function (count, iterator, callback) {
    var counter = [];
    for (var i = 0; i < count; i++) {
      counter.push(i);
    }
    return async.mapSeries(counter, iterator, callback);
  };
  async.compose = function () {
    var fns = Array.prototype.reverse.call(arguments);
    return function () {
      var that = this;
      var args = Array.prototype.slice.call(arguments);
      var callback = args.pop();
      async.reduce(fns, args, function (newargs, fn, cb) {
        fn.apply(that, newargs.concat([function () {
            var err = arguments[0];
            var nextargs = Array.prototype.slice.call(arguments, 1);
            cb(err, nextargs);
          }]));
      }, function (err, results) {
        callback.apply(that, [err].concat(results));
      });
    };
  };
  if (typeof define !== 'undefined' && define.amd) {
    define([], function () {
      return async;
    });
  } else if (typeof module !== 'undefined' && module.exports) {
    module.exports = async;
  } else {
    root.async = async;
  }
}());
(function (window, undefined) {
  var rootjQuery, readyList, core_strundefined = typeof undefined, location = window.location, document = window.document, docElem = document.documentElement, _jQuery = window.jQuery, _$ = window.$, class2type = {}, core_deletedIds = [], core_version = '2.0.3', core_concat = core_deletedIds.concat, core_push = core_deletedIds.push, core_slice = core_deletedIds.slice, core_indexOf = core_deletedIds.indexOf, core_toString = class2type.toString, core_hasOwn = class2type.hasOwnProperty, core_trim = core_version.trim, jQuery = function (selector, context) {
      return new jQuery.fn.init(selector, context, rootjQuery);
    }, core_pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, core_rnotwhite = /\S+/g, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, rmsPrefix = /^-ms-/, rdashAlpha = /-([\da-z])/gi, fcamelCase = function (all, letter) {
      return letter.toUpperCase();
    }, completed = function () {
      document.removeEventListener('DOMContentLoaded', completed, false);
      window.removeEventListener('load', completed, false);
      jQuery.ready();
    };
  jQuery.fn = jQuery.prototype = {
    jquery: core_version,
    constructor: jQuery,
    init: function (selector, context, rootjQuery) {
      var match, elem;
      if (!selector) {
        return this;
      }
      if (typeof selector === 'string') {
        if (selector.charAt(0) === '<' && selector.charAt(selector.length - 1) === '>' && selector.length >= 3) {
          match = [
            null,
            selector,
            null
          ];
        } else {
          match = rquickExpr.exec(selector);
        }
        if (match && (match[1] || !context)) {
          if (match[1]) {
            context = context instanceof jQuery ? context[0] : context;
            jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
            if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
              for (match in context) {
                if (jQuery.isFunction(this[match])) {
                  this[match](context[match]);
                } else {
                  this.attr(match, context[match]);
                }
              }
            }
            return this;
          } else {
            elem = document.getElementById(match[2]);
            if (elem && elem.parentNode) {
              this.length = 1;
              this[0] = elem;
            }
            this.context = document;
            this.selector = selector;
            return this;
          }
        } else if (!context || context.jquery) {
          return (context || rootjQuery).find(selector);
        } else {
          return this.constructor(context).find(selector);
        }
      } else if (selector.nodeType) {
        this.context = this[0] = selector;
        this.length = 1;
        return this;
      } else if (jQuery.isFunction(selector)) {
        return rootjQuery.ready(selector);
      }
      if (selector.selector !== undefined) {
        this.selector = selector.selector;
        this.context = selector.context;
      }
      return jQuery.makeArray(selector, this);
    },
    selector: '',
    length: 0,
    toArray: function () {
      return core_slice.call(this);
    },
    get: function (num) {
      return num == null ? this.toArray() : num < 0 ? this[this.length + num] : this[num];
    },
    pushStack: function (elems) {
      var ret = jQuery.merge(this.constructor(), elems);
      ret.prevObject = this;
      ret.context = this.context;
      return ret;
    },
    each: function (callback, args) {
      return jQuery.each(this, callback, args);
    },
    ready: function (fn) {
      jQuery.ready.promise().done(fn);
      return this;
    },
    slice: function () {
      return this.pushStack(core_slice.apply(this, arguments));
    },
    first: function () {
      return this.eq(0);
    },
    last: function () {
      return this.eq(-1);
    },
    eq: function (i) {
      var len = this.length, j = +i + (i < 0 ? len : 0);
      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
    },
    map: function (callback) {
      return this.pushStack(jQuery.map(this, function (elem, i) {
        return callback.call(elem, i, elem);
      }));
    },
    end: function () {
      return this.prevObject || this.constructor(null);
    },
    push: core_push,
    sort: [].sort,
    splice: [].splice
  };
  jQuery.fn.init.prototype = jQuery.fn;
  jQuery.extend = jQuery.fn.extend = function () {
    var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
    if (typeof target === 'boolean') {
      deep = target;
      target = arguments[1] || {};
      i = 2;
    }
    if (typeof target !== 'object' && !jQuery.isFunction(target)) {
      target = {};
    }
    if (length === i) {
      target = this;
      --i;
    }
    for (; i < length; i++) {
      if ((options = arguments[i]) != null) {
        for (name in options) {
          src = target[name];
          copy = options[name];
          if (target === copy) {
            continue;
          }
          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && jQuery.isArray(src) ? src : [];
            } else {
              clone = src && jQuery.isPlainObject(src) ? src : {};
            }
            target[name] = jQuery.extend(deep, clone, copy);
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    }
    return target;
  };
  jQuery.extend({
    expando: 'jQuery' + (core_version + Math.random()).replace(/\D/g, ''),
    noConflict: function (deep) {
      if (window.$ === jQuery) {
        window.$ = _$;
      }
      if (deep && window.jQuery === jQuery) {
        window.jQuery = _jQuery;
      }
      return jQuery;
    },
    isReady: false,
    readyWait: 1,
    holdReady: function (hold) {
      if (hold) {
        jQuery.readyWait++;
      } else {
        jQuery.ready(true);
      }
    },
    ready: function (wait) {
      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
        return;
      }
      jQuery.isReady = true;
      if (wait !== true && --jQuery.readyWait > 0) {
        return;
      }
      readyList.resolveWith(document, [jQuery]);
      if (jQuery.fn.trigger) {
        jQuery(document).trigger('ready').off('ready');
      }
    },
    isFunction: function (obj) {
      return jQuery.type(obj) === 'function';
    },
    isArray: Array.isArray,
    isWindow: function (obj) {
      return obj != null && obj === obj.window;
    },
    isNumeric: function (obj) {
      return !isNaN(parseFloat(obj)) && isFinite(obj);
    },
    type: function (obj) {
      if (obj == null) {
        return String(obj);
      }
      return typeof obj === 'object' || typeof obj === 'function' ? class2type[core_toString.call(obj)] || 'object' : typeof obj;
    },
    isPlainObject: function (obj) {
      if (jQuery.type(obj) !== 'object' || obj.nodeType || jQuery.isWindow(obj)) {
        return false;
      }
      try {
        if (obj.constructor && !core_hasOwn.call(obj.constructor.prototype, 'isPrototypeOf')) {
          return false;
        }
      } catch (e) {
        return false;
      }
      return true;
    },
    isEmptyObject: function (obj) {
      var name;
      for (name in obj) {
        return false;
      }
      return true;
    },
    error: function (msg) {
      throw new Error(msg);
    },
    parseHTML: function (data, context, keepScripts) {
      if (!data || typeof data !== 'string') {
        return null;
      }
      if (typeof context === 'boolean') {
        keepScripts = context;
        context = false;
      }
      context = context || document;
      var parsed = rsingleTag.exec(data), scripts = !keepScripts && [];
      if (parsed) {
        return [context.createElement(parsed[1])];
      }
      parsed = jQuery.buildFragment([data], context, scripts);
      if (scripts) {
        jQuery(scripts).remove();
      }
      return jQuery.merge([], parsed.childNodes);
    },
    parseJSON: JSON.parse,
    parseXML: function (data) {
      var xml, tmp;
      if (!data || typeof data !== 'string') {
        return null;
      }
      try {
        tmp = new DOMParser();
        xml = tmp.parseFromString(data, 'text/xml');
      } catch (e) {
        xml = undefined;
      }
      if (!xml || xml.getElementsByTagName('parsererror').length) {
        jQuery.error('Invalid XML: ' + data);
      }
      return xml;
    },
    noop: function () {
    },
    globalEval: function (code) {
      var script, indirect = eval;
      code = jQuery.trim(code);
      if (code) {
        if (code.indexOf('use strict') === 1) {
          script = document.createElement('script');
          script.text = code;
          document.head.appendChild(script).parentNode.removeChild(script);
        } else {
          indirect(code);
        }
      }
    },
    camelCase: function (string) {
      return string.replace(rmsPrefix, 'ms-').replace(rdashAlpha, fcamelCase);
    },
    nodeName: function (elem, name) {
      return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    },
    each: function (obj, callback, args) {
      var value, i = 0, length = obj.length, isArray = isArraylike(obj);
      if (args) {
        if (isArray) {
          for (; i < length; i++) {
            value = callback.apply(obj[i], args);
            if (value === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            value = callback.apply(obj[i], args);
            if (value === false) {
              break;
            }
          }
        }
      } else {
        if (isArray) {
          for (; i < length; i++) {
            value = callback.call(obj[i], i, obj[i]);
            if (value === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            value = callback.call(obj[i], i, obj[i]);
            if (value === false) {
              break;
            }
          }
        }
      }
      return obj;
    },
    trim: function (text) {
      return text == null ? '' : core_trim.call(text);
    },
    makeArray: function (arr, results) {
      var ret = results || [];
      if (arr != null) {
        if (isArraylike(Object(arr))) {
          jQuery.merge(ret, typeof arr === 'string' ? [arr] : arr);
        } else {
          core_push.call(ret, arr);
        }
      }
      return ret;
    },
    inArray: function (elem, arr, i) {
      return arr == null ? -1 : core_indexOf.call(arr, elem, i);
    },
    merge: function (first, second) {
      var l = second.length, i = first.length, j = 0;
      if (typeof l === 'number') {
        for (; j < l; j++) {
          first[i++] = second[j];
        }
      } else {
        while (second[j] !== undefined) {
          first[i++] = second[j++];
        }
      }
      first.length = i;
      return first;
    },
    grep: function (elems, callback, inv) {
      var retVal, ret = [], i = 0, length = elems.length;
      inv = !!inv;
      for (; i < length; i++) {
        retVal = !!callback(elems[i], i);
        if (inv !== retVal) {
          ret.push(elems[i]);
        }
      }
      return ret;
    },
    map: function (elems, callback, arg) {
      var value, i = 0, length = elems.length, isArray = isArraylike(elems), ret = [];
      if (isArray) {
        for (; i < length; i++) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret[ret.length] = value;
          }
        }
      } else {
        for (i in elems) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret[ret.length] = value;
          }
        }
      }
      return core_concat.apply([], ret);
    },
    guid: 1,
    proxy: function (fn, context) {
      var tmp, args, proxy;
      if (typeof context === 'string') {
        tmp = fn[context];
        context = fn;
        fn = tmp;
      }
      if (!jQuery.isFunction(fn)) {
        return undefined;
      }
      args = core_slice.call(arguments, 2);
      proxy = function () {
        return fn.apply(context || this, args.concat(core_slice.call(arguments)));
      };
      proxy.guid = fn.guid = fn.guid || jQuery.guid++;
      return proxy;
    },
    access: function (elems, fn, key, value, chainable, emptyGet, raw) {
      var i = 0, length = elems.length, bulk = key == null;
      if (jQuery.type(key) === 'object') {
        chainable = true;
        for (i in key) {
          jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
        }
      } else if (value !== undefined) {
        chainable = true;
        if (!jQuery.isFunction(value)) {
          raw = true;
        }
        if (bulk) {
          if (raw) {
            fn.call(elems, value);
            fn = null;
          } else {
            bulk = fn;
            fn = function (elem, key, value) {
              return bulk.call(jQuery(elem), value);
            };
          }
        }
        if (fn) {
          for (; i < length; i++) {
            fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
          }
        }
      }
      return chainable ? elems : bulk ? fn.call(elems) : length ? fn(elems[0], key) : emptyGet;
    },
    now: Date.now,
    swap: function (elem, options, callback, args) {
      var ret, name, old = {};
      for (name in options) {
        old[name] = elem.style[name];
        elem.style[name] = options[name];
      }
      ret = callback.apply(elem, args || []);
      for (name in options) {
        elem.style[name] = old[name];
      }
      return ret;
    }
  });
  jQuery.ready.promise = function (obj) {
    if (!readyList) {
      readyList = jQuery.Deferred();
      if (document.readyState === 'complete') {
        setTimeout(jQuery.ready);
      } else {
        document.addEventListener('DOMContentLoaded', completed, false);
        window.addEventListener('load', completed, false);
      }
    }
    return readyList.promise(obj);
  };
  jQuery.each('Boolean Number String Function Array Date RegExp Object Error'.split(' '), function (i, name) {
    class2type['[object ' + name + ']'] = name.toLowerCase();
  });
  function isArraylike(obj) {
    var length = obj.length, type = jQuery.type(obj);
    if (jQuery.isWindow(obj)) {
      return false;
    }
    if (obj.nodeType === 1 && length) {
      return true;
    }
    return type === 'array' || type !== 'function' && (length === 0 || typeof length === 'number' && length > 0 && length - 1 in obj);
  }
  rootjQuery = jQuery(document);
  (function (window, undefined) {
    var i, support, cachedruns, Expr, getText, isXML, compile, outermostContext, sortInput, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = 'sizzle' + -new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), hasDuplicate = false, sortOrder = function (a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        return 0;
      }, strundefined = typeof undefined, MAX_NEGATIVE = 1 << 31, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = arr.indexOf || function (elem) {
        var i = 0, len = this.length;
        for (; i < len; i++) {
          if (this[i] === elem) {
            return i;
          }
        }
        return -1;
      }, booleans = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped', whitespace = '[\\x20\\t\\r\\n\\f]', characterEncoding = '(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+', identifier = characterEncoding.replace('w', 'w#'), attributes = '\\[' + whitespace + '*(' + characterEncoding + ')' + whitespace + '*(?:([*^$|!~]?=)' + whitespace + '*(?:([\'"])((?:\\\\.|[^\\\\])*?)\\3|(' + identifier + ')|)|)' + whitespace + '*\\]', pseudos = ':(' + characterEncoding + ')(?:\\((([\'"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|' + attributes.replace(3, 8) + ')*)|.*)\\)|)', rtrim = new RegExp('^' + whitespace + '+|((?:^|[^\\\\])(?:\\\\.)*)' + whitespace + '+$', 'g'), rcomma = new RegExp('^' + whitespace + '*,' + whitespace + '*'), rcombinators = new RegExp('^' + whitespace + '*([>+~]|' + whitespace + ')' + whitespace + '*'), rsibling = new RegExp(whitespace + '*[+~]'), rattributeQuotes = new RegExp('=' + whitespace + '*([^\\]\'"]*)' + whitespace + '*\\]', 'g'), rpseudo = new RegExp(pseudos), ridentifier = new RegExp('^' + identifier + '$'), matchExpr = {
        'ID': new RegExp('^#(' + characterEncoding + ')'),
        'CLASS': new RegExp('^\\.(' + characterEncoding + ')'),
        'TAG': new RegExp('^(' + characterEncoding.replace('w', 'w*') + ')'),
        'ATTR': new RegExp('^' + attributes),
        'PSEUDO': new RegExp('^' + pseudos),
        'CHILD': new RegExp('^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' + whitespace + '*(even|odd|(([+-]|)(\\d*)n|)' + whitespace + '*(?:([+-]|)' + whitespace + '*(\\d+)|))' + whitespace + '*\\)|)', 'i'),
        'bool': new RegExp('^(?:' + booleans + ')$', 'i'),
        'needsContext': new RegExp('^' + whitespace + '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' + whitespace + '*((?:-\\d)?\\d*)' + whitespace + '*\\)|)(?=[^-]|$)', 'i')
      }, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rescape = /'|\\/g, runescape = new RegExp('\\\\([\\da-f]{1,6}' + whitespace + '?|(' + whitespace + ')|.)', 'ig'), funescape = function (_, escaped, escapedWhitespace) {
        var high = '0x' + escaped - 65536;
        return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
      };
    try {
      push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
      arr[preferredDoc.childNodes.length].nodeType;
    } catch (e) {
      push = {
        apply: arr.length ? function (target, els) {
          push_native.apply(target, slice.call(els));
        } : function (target, els) {
          var j = target.length, i = 0;
          while (target[j++] = els[i++]) {
          }
          target.length = j - 1;
        }
      };
    }
    function Sizzle(selector, context, results, seed) {
      var match, elem, m, nodeType, i, groups, old, nid, newContext, newSelector;
      if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
        setDocument(context);
      }
      context = context || document;
      results = results || [];
      if (!selector || typeof selector !== 'string') {
        return results;
      }
      if ((nodeType = context.nodeType) !== 1 && nodeType !== 9) {
        return [];
      }
      if (documentIsHTML && !seed) {
        if (match = rquickExpr.exec(selector)) {
          if (m = match[1]) {
            if (nodeType === 9) {
              elem = context.getElementById(m);
              if (elem && elem.parentNode) {
                if (elem.id === m) {
                  results.push(elem);
                  return results;
                }
              } else {
                return results;
              }
            } else {
              if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                results.push(elem);
                return results;
              }
            }
          } else if (match[2]) {
            push.apply(results, context.getElementsByTagName(selector));
            return results;
          } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
            push.apply(results, context.getElementsByClassName(m));
            return results;
          }
        }
        if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
          nid = old = expando;
          newContext = context;
          newSelector = nodeType === 9 && selector;
          if (nodeType === 1 && context.nodeName.toLowerCase() !== 'object') {
            groups = tokenize(selector);
            if (old = context.getAttribute('id')) {
              nid = old.replace(rescape, '\\$&');
            } else {
              context.setAttribute('id', nid);
            }
            nid = '[id=\'' + nid + '\'] ';
            i = groups.length;
            while (i--) {
              groups[i] = nid + toSelector(groups[i]);
            }
            newContext = rsibling.test(selector) && context.parentNode || context;
            newSelector = groups.join(',');
          }
          if (newSelector) {
            try {
              push.apply(results, newContext.querySelectorAll(newSelector));
              return results;
            } catch (qsaError) {
            } finally {
              if (!old) {
                context.removeAttribute('id');
              }
            }
          }
        }
      }
      return select(selector.replace(rtrim, '$1'), context, results, seed);
    }
    function createCache() {
      var keys = [];
      function cache(key, value) {
        if (keys.push(key += ' ') > Expr.cacheLength) {
          delete cache[keys.shift()];
        }
        return cache[key] = value;
      }
      return cache;
    }
    function markFunction(fn) {
      fn[expando] = true;
      return fn;
    }
    function assert(fn) {
      var div = document.createElement('div');
      try {
        return !!fn(div);
      } catch (e) {
        return false;
      } finally {
        if (div.parentNode) {
          div.parentNode.removeChild(div);
        }
        div = null;
      }
    }
    function addHandle(attrs, handler) {
      var arr = attrs.split('|'), i = attrs.length;
      while (i--) {
        Expr.attrHandle[arr[i]] = handler;
      }
    }
    function siblingCheck(a, b) {
      var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
      if (diff) {
        return diff;
      }
      if (cur) {
        while (cur = cur.nextSibling) {
          if (cur === b) {
            return -1;
          }
        }
      }
      return a ? 1 : -1;
    }
    function createInputPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return name === 'input' && elem.type === type;
      };
    }
    function createButtonPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return (name === 'input' || name === 'button') && elem.type === type;
      };
    }
    function createPositionalPseudo(fn) {
      return markFunction(function (argument) {
        argument = +argument;
        return markFunction(function (seed, matches) {
          var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
          while (i--) {
            if (seed[j = matchIndexes[i]]) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }
    isXML = Sizzle.isXML = function (elem) {
      var documentElement = elem && (elem.ownerDocument || elem).documentElement;
      return documentElement ? documentElement.nodeName !== 'HTML' : false;
    };
    support = Sizzle.support = {};
    setDocument = Sizzle.setDocument = function (node) {
      var doc = node ? node.ownerDocument || node : preferredDoc, parent = doc.defaultView;
      if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
        return document;
      }
      document = doc;
      docElem = doc.documentElement;
      documentIsHTML = !isXML(doc);
      if (parent && parent.attachEvent && parent !== parent.top) {
        parent.attachEvent('onbeforeunload', function () {
          setDocument();
        });
      }
      support.attributes = assert(function (div) {
        div.className = 'i';
        return !div.getAttribute('className');
      });
      support.getElementsByTagName = assert(function (div) {
        div.appendChild(doc.createComment(''));
        return !div.getElementsByTagName('*').length;
      });
      support.getElementsByClassName = assert(function (div) {
        div.innerHTML = '<div class=\'a\'></div><div class=\'a i\'></div>';
        div.firstChild.className = 'i';
        return div.getElementsByClassName('i').length === 2;
      });
      support.getById = assert(function (div) {
        docElem.appendChild(div).id = expando;
        return !doc.getElementsByName || !doc.getElementsByName(expando).length;
      });
      if (support.getById) {
        Expr.find['ID'] = function (id, context) {
          if (typeof context.getElementById !== strundefined && documentIsHTML) {
            var m = context.getElementById(id);
            return m && m.parentNode ? [m] : [];
          }
        };
        Expr.filter['ID'] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            return elem.getAttribute('id') === attrId;
          };
        };
      } else {
        delete Expr.find['ID'];
        Expr.filter['ID'] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode('id');
            return node && node.value === attrId;
          };
        };
      }
      Expr.find['TAG'] = support.getElementsByTagName ? function (tag, context) {
        if (typeof context.getElementsByTagName !== strundefined) {
          return context.getElementsByTagName(tag);
        }
      } : function (tag, context) {
        var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
        if (tag === '*') {
          while (elem = results[i++]) {
            if (elem.nodeType === 1) {
              tmp.push(elem);
            }
          }
          return tmp;
        }
        return results;
      };
      Expr.find['CLASS'] = support.getElementsByClassName && function (className, context) {
        if (typeof context.getElementsByClassName !== strundefined && documentIsHTML) {
          return context.getElementsByClassName(className);
        }
      };
      rbuggyMatches = [];
      rbuggyQSA = [];
      if (support.qsa = rnative.test(doc.querySelectorAll)) {
        assert(function (div) {
          div.innerHTML = '<select><option selected=\'\'></option></select>';
          if (!div.querySelectorAll('[selected]').length) {
            rbuggyQSA.push('\\[' + whitespace + '*(?:value|' + booleans + ')');
          }
          if (!div.querySelectorAll(':checked').length) {
            rbuggyQSA.push(':checked');
          }
        });
        assert(function (div) {
          var input = doc.createElement('input');
          input.setAttribute('type', 'hidden');
          div.appendChild(input).setAttribute('t', '');
          if (div.querySelectorAll('[t^=\'\']').length) {
            rbuggyQSA.push('[*^$]=' + whitespace + '*(?:\'\'|"")');
          }
          if (!div.querySelectorAll(':enabled').length) {
            rbuggyQSA.push(':enabled', ':disabled');
          }
          div.querySelectorAll('*,:x');
          rbuggyQSA.push(',.*:');
        });
      }
      if (support.matchesSelector = rnative.test(matches = docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
        assert(function (div) {
          support.disconnectedMatch = matches.call(div, 'div');
          matches.call(div, '[s!=\'\']:x');
          rbuggyMatches.push('!=', pseudos);
        });
      }
      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join('|'));
      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join('|'));
      contains = rnative.test(docElem.contains) || docElem.compareDocumentPosition ? function (a, b) {
        var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
      } : function (a, b) {
        if (b) {
          while (b = b.parentNode) {
            if (b === a) {
              return true;
            }
          }
        }
        return false;
      };
      sortOrder = docElem.compareDocumentPosition ? function (a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var compare = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition(b);
        if (compare) {
          if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
            if (a === doc || contains(preferredDoc, a)) {
              return -1;
            }
            if (b === doc || contains(preferredDoc, b)) {
              return 1;
            }
            return sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
          }
          return compare & 4 ? -1 : 1;
        }
        return a.compareDocumentPosition ? -1 : 1;
      } : function (a, b) {
        var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
        if (a === b) {
          hasDuplicate = true;
          return 0;
        } else if (!aup || !bup) {
          return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
        } else if (aup === bup) {
          return siblingCheck(a, b);
        }
        cur = a;
        while (cur = cur.parentNode) {
          ap.unshift(cur);
        }
        cur = b;
        while (cur = cur.parentNode) {
          bp.unshift(cur);
        }
        while (ap[i] === bp[i]) {
          i++;
        }
        return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
      };
      return doc;
    };
    Sizzle.matches = function (expr, elements) {
      return Sizzle(expr, null, null, elements);
    };
    Sizzle.matchesSelector = function (elem, expr) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      expr = expr.replace(rattributeQuotes, '=\'$1\']');
      if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
        try {
          var ret = matches.call(elem, expr);
          if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
            return ret;
          }
        } catch (e) {
        }
      }
      return Sizzle(expr, document, null, [elem]).length > 0;
    };
    Sizzle.contains = function (context, elem) {
      if ((context.ownerDocument || context) !== document) {
        setDocument(context);
      }
      return contains(context, elem);
    };
    Sizzle.attr = function (elem, name) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
      return val === undefined ? support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null : val;
    };
    Sizzle.error = function (msg) {
      throw new Error('Syntax error, unrecognized expression: ' + msg);
    };
    Sizzle.uniqueSort = function (results) {
      var elem, duplicates = [], j = 0, i = 0;
      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable && results.slice(0);
      results.sort(sortOrder);
      if (hasDuplicate) {
        while (elem = results[i++]) {
          if (elem === results[i]) {
            j = duplicates.push(i);
          }
        }
        while (j--) {
          results.splice(duplicates[j], 1);
        }
      }
      return results;
    };
    getText = Sizzle.getText = function (elem) {
      var node, ret = '', i = 0, nodeType = elem.nodeType;
      if (!nodeType) {
        for (; node = elem[i]; i++) {
          ret += getText(node);
        }
      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
        if (typeof elem.textContent === 'string') {
          return elem.textContent;
        } else {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            ret += getText(elem);
          }
        }
      } else if (nodeType === 3 || nodeType === 4) {
        return elem.nodeValue;
      }
      return ret;
    };
    Expr = Sizzle.selectors = {
      cacheLength: 50,
      createPseudo: markFunction,
      match: matchExpr,
      attrHandle: {},
      find: {},
      relative: {
        '>': {
          dir: 'parentNode',
          first: true
        },
        ' ': { dir: 'parentNode' },
        '+': {
          dir: 'previousSibling',
          first: true
        },
        '~': { dir: 'previousSibling' }
      },
      preFilter: {
        'ATTR': function (match) {
          match[1] = match[1].replace(runescape, funescape);
          match[3] = (match[4] || match[5] || '').replace(runescape, funescape);
          if (match[2] === '~=') {
            match[3] = ' ' + match[3] + ' ';
          }
          return match.slice(0, 4);
        },
        'CHILD': function (match) {
          match[1] = match[1].toLowerCase();
          if (match[1].slice(0, 3) === 'nth') {
            if (!match[3]) {
              Sizzle.error(match[0]);
            }
            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === 'even' || match[3] === 'odd'));
            match[5] = +(match[7] + match[8] || match[3] === 'odd');
          } else if (match[3]) {
            Sizzle.error(match[0]);
          }
          return match;
        },
        'PSEUDO': function (match) {
          var excess, unquoted = !match[5] && match[2];
          if (matchExpr['CHILD'].test(match[0])) {
            return null;
          }
          if (match[3] && match[4] !== undefined) {
            match[2] = match[4];
          } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(')', unquoted.length - excess) - unquoted.length)) {
            match[0] = match[0].slice(0, excess);
            match[2] = unquoted.slice(0, excess);
          }
          return match.slice(0, 3);
        }
      },
      filter: {
        'TAG': function (nodeNameSelector) {
          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
          return nodeNameSelector === '*' ? function () {
            return true;
          } : function (elem) {
            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
          };
        },
        'CLASS': function (className) {
          var pattern = classCache[className + ' '];
          return pattern || (pattern = new RegExp('(^|' + whitespace + ')' + className + '(' + whitespace + '|$)')) && classCache(className, function (elem) {
            return pattern.test(typeof elem.className === 'string' && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute('class') || '');
          });
        },
        'ATTR': function (name, operator, check) {
          return function (elem) {
            var result = Sizzle.attr(elem, name);
            if (result == null) {
              return operator === '!=';
            }
            if (!operator) {
              return true;
            }
            result += '';
            return operator === '=' ? result === check : operator === '!=' ? result !== check : operator === '^=' ? check && result.indexOf(check) === 0 : operator === '*=' ? check && result.indexOf(check) > -1 : operator === '$=' ? check && result.slice(-check.length) === check : operator === '~=' ? (' ' + result + ' ').indexOf(check) > -1 : operator === '|=' ? result === check || result.slice(0, check.length + 1) === check + '-' : false;
          };
        },
        'CHILD': function (type, what, argument, first, last) {
          var simple = type.slice(0, 3) !== 'nth', forward = type.slice(-4) !== 'last', ofType = what === 'of-type';
          return first === 1 && last === 0 ? function (elem) {
            return !!elem.parentNode;
          } : function (elem, context, xml) {
            var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? 'nextSibling' : 'previousSibling', parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType;
            if (parent) {
              if (simple) {
                while (dir) {
                  node = elem;
                  while (node = node[dir]) {
                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                      return false;
                    }
                  }
                  start = dir = type === 'only' && !start && 'nextSibling';
                }
                return true;
              }
              start = [forward ? parent.firstChild : parent.lastChild];
              if (forward && useCache) {
                outerCache = parent[expando] || (parent[expando] = {});
                cache = outerCache[type] || [];
                nodeIndex = cache[0] === dirruns && cache[1];
                diff = cache[0] === dirruns && cache[2];
                node = nodeIndex && parent.childNodes[nodeIndex];
                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                  if (node.nodeType === 1 && ++diff && node === elem) {
                    outerCache[type] = [
                      dirruns,
                      nodeIndex,
                      diff
                    ];
                    break;
                  }
                }
              } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                diff = cache[1];
              } else {
                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                  if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                    if (useCache) {
                      (node[expando] || (node[expando] = {}))[type] = [
                        dirruns,
                        diff
                      ];
                    }
                    if (node === elem) {
                      break;
                    }
                  }
                }
              }
              diff -= last;
              return diff === first || diff % first === 0 && diff / first >= 0;
            }
          };
        },
        'PSEUDO': function (pseudo, argument) {
          var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error('unsupported pseudo: ' + pseudo);
          if (fn[expando]) {
            return fn(argument);
          }
          if (fn.length > 1) {
            args = [
              pseudo,
              pseudo,
              '',
              argument
            ];
            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
              var idx, matched = fn(seed, argument), i = matched.length;
              while (i--) {
                idx = indexOf.call(seed, matched[i]);
                seed[idx] = !(matches[idx] = matched[i]);
              }
            }) : function (elem) {
              return fn(elem, 0, args);
            };
          }
          return fn;
        }
      },
      pseudos: {
        'not': markFunction(function (selector) {
          var input = [], results = [], matcher = compile(selector.replace(rtrim, '$1'));
          return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
            var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
            while (i--) {
              if (elem = unmatched[i]) {
                seed[i] = !(matches[i] = elem);
              }
            }
          }) : function (elem, context, xml) {
            input[0] = elem;
            matcher(input, null, xml, results);
            return !results.pop();
          };
        }),
        'has': markFunction(function (selector) {
          return function (elem) {
            return Sizzle(selector, elem).length > 0;
          };
        }),
        'contains': markFunction(function (text) {
          return function (elem) {
            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
          };
        }),
        'lang': markFunction(function (lang) {
          if (!ridentifier.test(lang || '')) {
            Sizzle.error('unsupported lang: ' + lang);
          }
          lang = lang.replace(runescape, funescape).toLowerCase();
          return function (elem) {
            var elemLang;
            do {
              if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute('xml:lang') || elem.getAttribute('lang')) {
                elemLang = elemLang.toLowerCase();
                return elemLang === lang || elemLang.indexOf(lang + '-') === 0;
              }
            } while ((elem = elem.parentNode) && elem.nodeType === 1);
            return false;
          };
        }),
        'target': function (elem) {
          var hash = window.location && window.location.hash;
          return hash && hash.slice(1) === elem.id;
        },
        'root': function (elem) {
          return elem === docElem;
        },
        'focus': function (elem) {
          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },
        'enabled': function (elem) {
          return elem.disabled === false;
        },
        'disabled': function (elem) {
          return elem.disabled === true;
        },
        'checked': function (elem) {
          var nodeName = elem.nodeName.toLowerCase();
          return nodeName === 'input' && !!elem.checked || nodeName === 'option' && !!elem.selected;
        },
        'selected': function (elem) {
          if (elem.parentNode) {
            elem.parentNode.selectedIndex;
          }
          return elem.selected === true;
        },
        'empty': function (elem) {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            if (elem.nodeName > '@' || elem.nodeType === 3 || elem.nodeType === 4) {
              return false;
            }
          }
          return true;
        },
        'parent': function (elem) {
          return !Expr.pseudos['empty'](elem);
        },
        'header': function (elem) {
          return rheader.test(elem.nodeName);
        },
        'input': function (elem) {
          return rinputs.test(elem.nodeName);
        },
        'button': function (elem) {
          var name = elem.nodeName.toLowerCase();
          return name === 'input' && elem.type === 'button' || name === 'button';
        },
        'text': function (elem) {
          var attr;
          return elem.nodeName.toLowerCase() === 'input' && elem.type === 'text' && ((attr = elem.getAttribute('type')) == null || attr.toLowerCase() === elem.type);
        },
        'first': createPositionalPseudo(function () {
          return [0];
        }),
        'last': createPositionalPseudo(function (matchIndexes, length) {
          return [length - 1];
        }),
        'eq': createPositionalPseudo(function (matchIndexes, length, argument) {
          return [argument < 0 ? argument + length : argument];
        }),
        'even': createPositionalPseudo(function (matchIndexes, length) {
          var i = 0;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        'odd': createPositionalPseudo(function (matchIndexes, length) {
          var i = 1;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        'lt': createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; --i >= 0;) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        'gt': createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; ++i < length;) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        })
      }
    };
    Expr.pseudos['nth'] = Expr.pseudos['eq'];
    for (i in {
        radio: true,
        checkbox: true,
        file: true,
        password: true,
        image: true
      }) {
      Expr.pseudos[i] = createInputPseudo(i);
    }
    for (i in {
        submit: true,
        reset: true
      }) {
      Expr.pseudos[i] = createButtonPseudo(i);
    }
    function setFilters() {
    }
    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();
    function tokenize(selector, parseOnly) {
      var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + ' '];
      if (cached) {
        return parseOnly ? 0 : cached.slice(0);
      }
      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;
      while (soFar) {
        if (!matched || (match = rcomma.exec(soFar))) {
          if (match) {
            soFar = soFar.slice(match[0].length) || soFar;
          }
          groups.push(tokens = []);
        }
        matched = false;
        if (match = rcombinators.exec(soFar)) {
          matched = match.shift();
          tokens.push({
            value: matched,
            type: match[0].replace(rtrim, ' ')
          });
          soFar = soFar.slice(matched.length);
        }
        for (type in Expr.filter) {
          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: type,
              matches: match
            });
            soFar = soFar.slice(matched.length);
          }
        }
        if (!matched) {
          break;
        }
      }
      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
    }
    function toSelector(tokens) {
      var i = 0, len = tokens.length, selector = '';
      for (; i < len; i++) {
        selector += tokens[i].value;
      }
      return selector;
    }
    function addCombinator(matcher, combinator, base) {
      var dir = combinator.dir, checkNonElements = base && dir === 'parentNode', doneName = done++;
      return combinator.first ? function (elem, context, xml) {
        while (elem = elem[dir]) {
          if (elem.nodeType === 1 || checkNonElements) {
            return matcher(elem, context, xml);
          }
        }
      } : function (elem, context, xml) {
        var data, cache, outerCache, dirkey = dirruns + ' ' + doneName;
        if (xml) {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              if (matcher(elem, context, xml)) {
                return true;
              }
            }
          }
        } else {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              outerCache = elem[expando] || (elem[expando] = {});
              if ((cache = outerCache[dir]) && cache[0] === dirkey) {
                if ((data = cache[1]) === true || data === cachedruns) {
                  return data === true;
                }
              } else {
                cache = outerCache[dir] = [dirkey];
                cache[1] = matcher(elem, context, xml) || cachedruns;
                if (cache[1] === true) {
                  return true;
                }
              }
            }
          }
        }
      };
    }
    function elementMatcher(matchers) {
      return matchers.length > 1 ? function (elem, context, xml) {
        var i = matchers.length;
        while (i--) {
          if (!matchers[i](elem, context, xml)) {
            return false;
          }
        }
        return true;
      } : matchers[0];
    }
    function condense(unmatched, map, filter, context, xml) {
      var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
      for (; i < len; i++) {
        if (elem = unmatched[i]) {
          if (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);
            if (mapped) {
              map.push(i);
            }
          }
        }
      }
      return newUnmatched;
    }
    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
      if (postFilter && !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }
      if (postFinder && !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }
      return markFunction(function (seed, results, context, xml) {
        var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || '*', context.nodeType ? [context] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
        if (matcher) {
          matcher(matcherIn, matcherOut, context, xml);
        }
        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml);
          i = temp.length;
          while (i--) {
            if (elem = temp[i]) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }
        if (seed) {
          if (postFinder || preFilter) {
            if (postFinder) {
              temp = [];
              i = matcherOut.length;
              while (i--) {
                if (elem = matcherOut[i]) {
                  temp.push(matcherIn[i] = elem);
                }
              }
              postFinder(null, matcherOut = [], temp, xml);
            }
            i = matcherOut.length;
            while (i--) {
              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {
                seed[temp] = !(results[temp] = elem);
              }
            }
          }
        } else {
          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
          if (postFinder) {
            postFinder(null, results, matcherOut, xml);
          } else {
            push.apply(results, matcherOut);
          }
        }
      });
    }
    function matcherFromTokens(tokens) {
      var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[' '], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function (elem) {
          return elem === checkContext;
        }, implicitRelative, true), matchAnyContext = addCombinator(function (elem) {
          return indexOf.call(checkContext, elem) > -1;
        }, implicitRelative, true), matchers = [function (elem, context, xml) {
            return !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
          }];
      for (; i < len; i++) {
        if (matcher = Expr.relative[tokens[i].type]) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
          if (matcher[expando]) {
            j = ++i;
            for (; j < len; j++) {
              if (Expr.relative[tokens[j].type]) {
                break;
              }
            }
            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === ' ' ? '*' : '' })).replace(rtrim, '$1'), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
          }
          matchers.push(matcher);
        }
      }
      return elementMatcher(matchers);
    }
    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      var matcherCachedRuns = 0, bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function (seed, context, xml, results, expandContext) {
          var elem, j, matcher, setMatched = [], matchedCount = 0, i = '0', unmatched = seed && [], outermost = expandContext != null, contextBackup = outermostContext, elems = seed || byElement && Expr.find['TAG']('*', expandContext && context.parentNode || context), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1;
          if (outermost) {
            outermostContext = context !== document && context;
            cachedruns = matcherCachedRuns;
          }
          for (; (elem = elems[i]) != null; i++) {
            if (byElement && elem) {
              j = 0;
              while (matcher = elementMatchers[j++]) {
                if (matcher(elem, context, xml)) {
                  results.push(elem);
                  break;
                }
              }
              if (outermost) {
                dirruns = dirrunsUnique;
                cachedruns = ++matcherCachedRuns;
              }
            }
            if (bySet) {
              if (elem = !matcher && elem) {
                matchedCount--;
              }
              if (seed) {
                unmatched.push(elem);
              }
            }
          }
          matchedCount += i;
          if (bySet && i !== matchedCount) {
            j = 0;
            while (matcher = setMatchers[j++]) {
              matcher(unmatched, setMatched, context, xml);
            }
            if (seed) {
              if (matchedCount > 0) {
                while (i--) {
                  if (!(unmatched[i] || setMatched[i])) {
                    setMatched[i] = pop.call(results);
                  }
                }
              }
              setMatched = condense(setMatched);
            }
            push.apply(results, setMatched);
            if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
              Sizzle.uniqueSort(results);
            }
          }
          if (outermost) {
            dirruns = dirrunsUnique;
            outermostContext = contextBackup;
          }
          return unmatched;
        };
      return bySet ? markFunction(superMatcher) : superMatcher;
    }
    compile = Sizzle.compile = function (selector, group) {
      var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + ' '];
      if (!cached) {
        if (!group) {
          group = tokenize(selector);
        }
        i = group.length;
        while (i--) {
          cached = matcherFromTokens(group[i]);
          if (cached[expando]) {
            setMatchers.push(cached);
          } else {
            elementMatchers.push(cached);
          }
        }
        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
      }
      return cached;
    };
    function multipleContexts(selector, contexts, results) {
      var i = 0, len = contexts.length;
      for (; i < len; i++) {
        Sizzle(selector, contexts[i], results);
      }
      return results;
    }
    function select(selector, context, results, seed) {
      var i, tokens, token, type, find, match = tokenize(selector);
      if (!seed) {
        if (match.length === 1) {
          tokens = match[0] = match[0].slice(0);
          if (tokens.length > 2 && (token = tokens[0]).type === 'ID' && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
            context = (Expr.find['ID'](token.matches[0].replace(runescape, funescape), context) || [])[0];
            if (!context) {
              return results;
            }
            selector = selector.slice(tokens.shift().value.length);
          }
          i = matchExpr['needsContext'].test(selector) ? 0 : tokens.length;
          while (i--) {
            token = tokens[i];
            if (Expr.relative[type = token.type]) {
              break;
            }
            if (find = Expr.find[type]) {
              if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && context.parentNode || context)) {
                tokens.splice(i, 1);
                selector = seed.length && toSelector(tokens);
                if (!selector) {
                  push.apply(results, seed);
                  return results;
                }
                break;
              }
            }
          }
        }
      }
      compile(selector, match)(seed, context, !documentIsHTML, results, rsibling.test(selector));
      return results;
    }
    support.sortStable = expando.split('').sort(sortOrder).join('') === expando;
    support.detectDuplicates = hasDuplicate;
    setDocument();
    support.sortDetached = assert(function (div1) {
      return div1.compareDocumentPosition(document.createElement('div')) & 1;
    });
    if (!assert(function (div) {
        div.innerHTML = '<a href=\'#\'></a>';
        return div.firstChild.getAttribute('href') === '#';
      })) {
      addHandle('type|href|height|width', function (elem, name, isXML) {
        if (!isXML) {
          return elem.getAttribute(name, name.toLowerCase() === 'type' ? 1 : 2);
        }
      });
    }
    if (!support.attributes || !assert(function (div) {
        div.innerHTML = '<input/>';
        div.firstChild.setAttribute('value', '');
        return div.firstChild.getAttribute('value') === '';
      })) {
      addHandle('value', function (elem, name, isXML) {
        if (!isXML && elem.nodeName.toLowerCase() === 'input') {
          return elem.defaultValue;
        }
      });
    }
    if (!assert(function (div) {
        return div.getAttribute('disabled') == null;
      })) {
      addHandle(booleans, function (elem, name, isXML) {
        var val;
        if (!isXML) {
          return (val = elem.getAttributeNode(name)) && val.specified ? val.value : elem[name] === true ? name.toLowerCase() : null;
        }
      });
    }
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[':'] = jQuery.expr.pseudos;
    jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
  }(window));
  var optionsCache = {};
  function createOptions(options) {
    var object = optionsCache[options] = {};
    jQuery.each(options.match(core_rnotwhite) || [], function (_, flag) {
      object[flag] = true;
    });
    return object;
  }
  jQuery.Callbacks = function (options) {
    options = typeof options === 'string' ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);
    var memory, fired, firing, firingStart, firingLength, firingIndex, list = [], stack = !options.once && [], fire = function (data) {
        memory = options.memory && data;
        fired = true;
        firingIndex = firingStart || 0;
        firingStart = 0;
        firingLength = list.length;
        firing = true;
        for (; list && firingIndex < firingLength; firingIndex++) {
          if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
            memory = false;
            break;
          }
        }
        firing = false;
        if (list) {
          if (stack) {
            if (stack.length) {
              fire(stack.shift());
            }
          } else if (memory) {
            list = [];
          } else {
            self.disable();
          }
        }
      }, self = {
        add: function () {
          if (list) {
            var start = list.length;
            (function add(args) {
              jQuery.each(args, function (_, arg) {
                var type = jQuery.type(arg);
                if (type === 'function') {
                  if (!options.unique || !self.has(arg)) {
                    list.push(arg);
                  }
                } else if (arg && arg.length && type !== 'string') {
                  add(arg);
                }
              });
            }(arguments));
            if (firing) {
              firingLength = list.length;
            } else if (memory) {
              firingStart = start;
              fire(memory);
            }
          }
          return this;
        },
        remove: function () {
          if (list) {
            jQuery.each(arguments, function (_, arg) {
              var index;
              while ((index = jQuery.inArray(arg, list, index)) > -1) {
                list.splice(index, 1);
                if (firing) {
                  if (index <= firingLength) {
                    firingLength--;
                  }
                  if (index <= firingIndex) {
                    firingIndex--;
                  }
                }
              }
            });
          }
          return this;
        },
        has: function (fn) {
          return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
        },
        empty: function () {
          list = [];
          firingLength = 0;
          return this;
        },
        disable: function () {
          list = stack = memory = undefined;
          return this;
        },
        disabled: function () {
          return !list;
        },
        lock: function () {
          stack = undefined;
          if (!memory) {
            self.disable();
          }
          return this;
        },
        locked: function () {
          return !stack;
        },
        fireWith: function (context, args) {
          if (list && (!fired || stack)) {
            args = args || [];
            args = [
              context,
              args.slice ? args.slice() : args
            ];
            if (firing) {
              stack.push(args);
            } else {
              fire(args);
            }
          }
          return this;
        },
        fire: function () {
          self.fireWith(this, arguments);
          return this;
        },
        fired: function () {
          return !!fired;
        }
      };
    return self;
  };
  jQuery.extend({
    Deferred: function (func) {
      var tuples = [
          [
            'resolve',
            'done',
            jQuery.Callbacks('once memory'),
            'resolved'
          ],
          [
            'reject',
            'fail',
            jQuery.Callbacks('once memory'),
            'rejected'
          ],
          [
            'notify',
            'progress',
            jQuery.Callbacks('memory')
          ]
        ], state = 'pending', promise = {
          state: function () {
            return state;
          },
          always: function () {
            deferred.done(arguments).fail(arguments);
            return this;
          },
          then: function () {
            var fns = arguments;
            return jQuery.Deferred(function (newDefer) {
              jQuery.each(tuples, function (i, tuple) {
                var action = tuple[0], fn = jQuery.isFunction(fns[i]) && fns[i];
                deferred[tuple[1]](function () {
                  var returned = fn && fn.apply(this, arguments);
                  if (returned && jQuery.isFunction(returned.promise)) {
                    returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
                  } else {
                    newDefer[action + 'With'](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                  }
                });
              });
              fns = null;
            }).promise();
          },
          promise: function (obj) {
            return obj != null ? jQuery.extend(obj, promise) : promise;
          }
        }, deferred = {};
      promise.pipe = promise.then;
      jQuery.each(tuples, function (i, tuple) {
        var list = tuple[2], stateString = tuple[3];
        promise[tuple[1]] = list.add;
        if (stateString) {
          list.add(function () {
            state = stateString;
          }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
        }
        deferred[tuple[0]] = function () {
          deferred[tuple[0] + 'With'](this === deferred ? promise : this, arguments);
          return this;
        };
        deferred[tuple[0] + 'With'] = list.fireWith;
      });
      promise.promise(deferred);
      if (func) {
        func.call(deferred, deferred);
      }
      return deferred;
    },
    when: function (subordinate) {
      var i = 0, resolveValues = core_slice.call(arguments), length = resolveValues.length, remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0, deferred = remaining === 1 ? subordinate : jQuery.Deferred(), updateFunc = function (i, contexts, values) {
          return function (value) {
            contexts[i] = this;
            values[i] = arguments.length > 1 ? core_slice.call(arguments) : value;
            if (values === progressValues) {
              deferred.notifyWith(contexts, values);
            } else if (!--remaining) {
              deferred.resolveWith(contexts, values);
            }
          };
        }, progressValues, progressContexts, resolveContexts;
      if (length > 1) {
        progressValues = new Array(length);
        progressContexts = new Array(length);
        resolveContexts = new Array(length);
        for (; i < length; i++) {
          if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
            resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));
          } else {
            --remaining;
          }
        }
      }
      if (!remaining) {
        deferred.resolveWith(resolveContexts, resolveValues);
      }
      return deferred.promise();
    }
  });
  jQuery.support = function (support) {
    var input = document.createElement('input'), fragment = document.createDocumentFragment(), div = document.createElement('div'), select = document.createElement('select'), opt = select.appendChild(document.createElement('option'));
    if (!input.type) {
      return support;
    }
    input.type = 'checkbox';
    support.checkOn = input.value !== '';
    support.optSelected = opt.selected;
    support.reliableMarginRight = true;
    support.boxSizingReliable = true;
    support.pixelPosition = false;
    input.checked = true;
    support.noCloneChecked = input.cloneNode(true).checked;
    select.disabled = true;
    support.optDisabled = !opt.disabled;
    input = document.createElement('input');
    input.value = 't';
    input.type = 'radio';
    support.radioValue = input.value === 't';
    input.setAttribute('checked', 't');
    input.setAttribute('name', 't');
    fragment.appendChild(input);
    support.checkClone = fragment.cloneNode(true).cloneNode(true).lastChild.checked;
    support.focusinBubbles = 'onfocusin' in window;
    div.style.backgroundClip = 'content-box';
    div.cloneNode(true).style.backgroundClip = '';
    support.clearCloneStyle = div.style.backgroundClip === 'content-box';
    jQuery(function () {
      var container, marginDiv, divReset = 'padding:0;margin:0;border:0;display:block;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box', body = document.getElementsByTagName('body')[0];
      if (!body) {
        return;
      }
      container = document.createElement('div');
      container.style.cssText = 'border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px';
      body.appendChild(container).appendChild(div);
      div.innerHTML = '';
      div.style.cssText = '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%';
      jQuery.swap(body, body.style.zoom != null ? { zoom: 1 } : {}, function () {
        support.boxSizing = div.offsetWidth === 4;
      });
      if (window.getComputedStyle) {
        support.pixelPosition = (window.getComputedStyle(div, null) || {}).top !== '1%';
        support.boxSizingReliable = (window.getComputedStyle(div, null) || { width: '4px' }).width === '4px';
        marginDiv = div.appendChild(document.createElement('div'));
        marginDiv.style.cssText = div.style.cssText = divReset;
        marginDiv.style.marginRight = marginDiv.style.width = '0';
        div.style.width = '1px';
        support.reliableMarginRight = !parseFloat((window.getComputedStyle(marginDiv, null) || {}).marginRight);
      }
      body.removeChild(container);
    });
    return support;
  }({});
  var data_user, data_priv, rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/, rmultiDash = /([A-Z])/g;
  function Data() {
    Object.defineProperty(this.cache = {}, 0, {
      get: function () {
        return {};
      }
    });
    this.expando = jQuery.expando + Math.random();
  }
  Data.uid = 1;
  Data.accepts = function (owner) {
    return owner.nodeType ? owner.nodeType === 1 || owner.nodeType === 9 : true;
  };
  Data.prototype = {
    key: function (owner) {
      if (!Data.accepts(owner)) {
        return 0;
      }
      var descriptor = {}, unlock = owner[this.expando];
      if (!unlock) {
        unlock = Data.uid++;
        try {
          descriptor[this.expando] = { value: unlock };
          Object.defineProperties(owner, descriptor);
        } catch (e) {
          descriptor[this.expando] = unlock;
          jQuery.extend(owner, descriptor);
        }
      }
      if (!this.cache[unlock]) {
        this.cache[unlock] = {};
      }
      return unlock;
    },
    set: function (owner, data, value) {
      var prop, unlock = this.key(owner), cache = this.cache[unlock];
      if (typeof data === 'string') {
        cache[data] = value;
      } else {
        if (jQuery.isEmptyObject(cache)) {
          jQuery.extend(this.cache[unlock], data);
        } else {
          for (prop in data) {
            cache[prop] = data[prop];
          }
        }
      }
      return cache;
    },
    get: function (owner, key) {
      var cache = this.cache[this.key(owner)];
      return key === undefined ? cache : cache[key];
    },
    access: function (owner, key, value) {
      var stored;
      if (key === undefined || key && typeof key === 'string' && value === undefined) {
        stored = this.get(owner, key);
        return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
      }
      this.set(owner, key, value);
      return value !== undefined ? value : key;
    },
    remove: function (owner, key) {
      var i, name, camel, unlock = this.key(owner), cache = this.cache[unlock];
      if (key === undefined) {
        this.cache[unlock] = {};
      } else {
        if (jQuery.isArray(key)) {
          name = key.concat(key.map(jQuery.camelCase));
        } else {
          camel = jQuery.camelCase(key);
          if (key in cache) {
            name = [
              key,
              camel
            ];
          } else {
            name = camel;
            name = name in cache ? [name] : name.match(core_rnotwhite) || [];
          }
        }
        i = name.length;
        while (i--) {
          delete cache[name[i]];
        }
      }
    },
    hasData: function (owner) {
      return !jQuery.isEmptyObject(this.cache[owner[this.expando]] || {});
    },
    discard: function (owner) {
      if (owner[this.expando]) {
        delete this.cache[owner[this.expando]];
      }
    }
  };
  data_user = new Data();
  data_priv = new Data();
  jQuery.extend({
    acceptData: Data.accepts,
    hasData: function (elem) {
      return data_user.hasData(elem) || data_priv.hasData(elem);
    },
    data: function (elem, name, data) {
      return data_user.access(elem, name, data);
    },
    removeData: function (elem, name) {
      data_user.remove(elem, name);
    },
    _data: function (elem, name, data) {
      return data_priv.access(elem, name, data);
    },
    _removeData: function (elem, name) {
      data_priv.remove(elem, name);
    }
  });
  jQuery.fn.extend({
    data: function (key, value) {
      var attrs, name, elem = this[0], i = 0, data = null;
      if (key === undefined) {
        if (this.length) {
          data = data_user.get(elem);
          if (elem.nodeType === 1 && !data_priv.get(elem, 'hasDataAttrs')) {
            attrs = elem.attributes;
            for (; i < attrs.length; i++) {
              name = attrs[i].name;
              if (name.indexOf('data-') === 0) {
                name = jQuery.camelCase(name.slice(5));
                dataAttr(elem, name, data[name]);
              }
            }
            data_priv.set(elem, 'hasDataAttrs', true);
          }
        }
        return data;
      }
      if (typeof key === 'object') {
        return this.each(function () {
          data_user.set(this, key);
        });
      }
      return jQuery.access(this, function (value) {
        var data, camelKey = jQuery.camelCase(key);
        if (elem && value === undefined) {
          data = data_user.get(elem, key);
          if (data !== undefined) {
            return data;
          }
          data = data_user.get(elem, camelKey);
          if (data !== undefined) {
            return data;
          }
          data = dataAttr(elem, camelKey, undefined);
          if (data !== undefined) {
            return data;
          }
          return;
        }
        this.each(function () {
          var data = data_user.get(this, camelKey);
          data_user.set(this, camelKey, value);
          if (key.indexOf('-') !== -1 && data !== undefined) {
            data_user.set(this, key, value);
          }
        });
      }, null, value, arguments.length > 1, null, true);
    },
    removeData: function (key) {
      return this.each(function () {
        data_user.remove(this, key);
      });
    }
  });
  function dataAttr(elem, key, data) {
    var name;
    if (data === undefined && elem.nodeType === 1) {
      name = 'data-' + key.replace(rmultiDash, '-$1').toLowerCase();
      data = elem.getAttribute(name);
      if (typeof data === 'string') {
        try {
          data = data === 'true' ? true : data === 'false' ? false : data === 'null' ? null : +data + '' === data ? +data : rbrace.test(data) ? JSON.parse(data) : data;
        } catch (e) {
        }
        data_user.set(elem, key, data);
      } else {
        data = undefined;
      }
    }
    return data;
  }
  jQuery.extend({
    queue: function (elem, type, data) {
      var queue;
      if (elem) {
        type = (type || 'fx') + 'queue';
        queue = data_priv.get(elem, type);
        if (data) {
          if (!queue || jQuery.isArray(data)) {
            queue = data_priv.access(elem, type, jQuery.makeArray(data));
          } else {
            queue.push(data);
          }
        }
        return queue || [];
      }
    },
    dequeue: function (elem, type) {
      type = type || 'fx';
      var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function () {
          jQuery.dequeue(elem, type);
        };
      if (fn === 'inprogress') {
        fn = queue.shift();
        startLength--;
      }
      if (fn) {
        if (type === 'fx') {
          queue.unshift('inprogress');
        }
        delete hooks.stop;
        fn.call(elem, next, hooks);
      }
      if (!startLength && hooks) {
        hooks.empty.fire();
      }
    },
    _queueHooks: function (elem, type) {
      var key = type + 'queueHooks';
      return data_priv.get(elem, key) || data_priv.access(elem, key, {
        empty: jQuery.Callbacks('once memory').add(function () {
          data_priv.remove(elem, [
            type + 'queue',
            key
          ]);
        })
      });
    }
  });
  jQuery.fn.extend({
    queue: function (type, data) {
      var setter = 2;
      if (typeof type !== 'string') {
        data = type;
        type = 'fx';
        setter--;
      }
      if (arguments.length < setter) {
        return jQuery.queue(this[0], type);
      }
      return data === undefined ? this : this.each(function () {
        var queue = jQuery.queue(this, type, data);
        jQuery._queueHooks(this, type);
        if (type === 'fx' && queue[0] !== 'inprogress') {
          jQuery.dequeue(this, type);
        }
      });
    },
    dequeue: function (type) {
      return this.each(function () {
        jQuery.dequeue(this, type);
      });
    },
    delay: function (time, type) {
      time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
      type = type || 'fx';
      return this.queue(type, function (next, hooks) {
        var timeout = setTimeout(next, time);
        hooks.stop = function () {
          clearTimeout(timeout);
        };
      });
    },
    clearQueue: function (type) {
      return this.queue(type || 'fx', []);
    },
    promise: function (type, obj) {
      var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function () {
          if (!--count) {
            defer.resolveWith(elements, [elements]);
          }
        };
      if (typeof type !== 'string') {
        obj = type;
        type = undefined;
      }
      type = type || 'fx';
      while (i--) {
        tmp = data_priv.get(elements[i], type + 'queueHooks');
        if (tmp && tmp.empty) {
          count++;
          tmp.empty.add(resolve);
        }
      }
      resolve();
      return defer.promise(obj);
    }
  });
  var nodeHook, boolHook, rclass = /[\t\r\n\f]/g, rreturn = /\r/g, rfocusable = /^(?:input|select|textarea|button)$/i;
  jQuery.fn.extend({
    attr: function (name, value) {
      return jQuery.access(this, jQuery.attr, name, value, arguments.length > 1);
    },
    removeAttr: function (name) {
      return this.each(function () {
        jQuery.removeAttr(this, name);
      });
    },
    prop: function (name, value) {
      return jQuery.access(this, jQuery.prop, name, value, arguments.length > 1);
    },
    removeProp: function (name) {
      return this.each(function () {
        delete this[jQuery.propFix[name] || name];
      });
    },
    addClass: function (value) {
      var classes, elem, cur, clazz, j, i = 0, len = this.length, proceed = typeof value === 'string' && value;
      if (jQuery.isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).addClass(value.call(this, j, this.className));
        });
      }
      if (proceed) {
        classes = (value || '').match(core_rnotwhite) || [];
        for (; i < len; i++) {
          elem = this[i];
          cur = elem.nodeType === 1 && (elem.className ? (' ' + elem.className + ' ').replace(rclass, ' ') : ' ');
          if (cur) {
            j = 0;
            while (clazz = classes[j++]) {
              if (cur.indexOf(' ' + clazz + ' ') < 0) {
                cur += clazz + ' ';
              }
            }
            elem.className = jQuery.trim(cur);
          }
        }
      }
      return this;
    },
    removeClass: function (value) {
      var classes, elem, cur, clazz, j, i = 0, len = this.length, proceed = arguments.length === 0 || typeof value === 'string' && value;
      if (jQuery.isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).removeClass(value.call(this, j, this.className));
        });
      }
      if (proceed) {
        classes = (value || '').match(core_rnotwhite) || [];
        for (; i < len; i++) {
          elem = this[i];
          cur = elem.nodeType === 1 && (elem.className ? (' ' + elem.className + ' ').replace(rclass, ' ') : '');
          if (cur) {
            j = 0;
            while (clazz = classes[j++]) {
              while (cur.indexOf(' ' + clazz + ' ') >= 0) {
                cur = cur.replace(' ' + clazz + ' ', ' ');
              }
            }
            elem.className = value ? jQuery.trim(cur) : '';
          }
        }
      }
      return this;
    },
    toggleClass: function (value, stateVal) {
      var type = typeof value;
      if (typeof stateVal === 'boolean' && type === 'string') {
        return stateVal ? this.addClass(value) : this.removeClass(value);
      }
      if (jQuery.isFunction(value)) {
        return this.each(function (i) {
          jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
        });
      }
      return this.each(function () {
        if (type === 'string') {
          var className, i = 0, self = jQuery(this), classNames = value.match(core_rnotwhite) || [];
          while (className = classNames[i++]) {
            if (self.hasClass(className)) {
              self.removeClass(className);
            } else {
              self.addClass(className);
            }
          }
        } else if (type === core_strundefined || type === 'boolean') {
          if (this.className) {
            data_priv.set(this, '__className__', this.className);
          }
          this.className = this.className || value === false ? '' : data_priv.get(this, '__className__') || '';
        }
      });
    },
    hasClass: function (selector) {
      var className = ' ' + selector + ' ', i = 0, l = this.length;
      for (; i < l; i++) {
        if (this[i].nodeType === 1 && (' ' + this[i].className + ' ').replace(rclass, ' ').indexOf(className) >= 0) {
          return true;
        }
      }
      return false;
    },
    val: function (value) {
      var hooks, ret, isFunction, elem = this[0];
      if (!arguments.length) {
        if (elem) {
          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
          if (hooks && 'get' in hooks && (ret = hooks.get(elem, 'value')) !== undefined) {
            return ret;
          }
          ret = elem.value;
          return typeof ret === 'string' ? ret.replace(rreturn, '') : ret == null ? '' : ret;
        }
        return;
      }
      isFunction = jQuery.isFunction(value);
      return this.each(function (i) {
        var val;
        if (this.nodeType !== 1) {
          return;
        }
        if (isFunction) {
          val = value.call(this, i, jQuery(this).val());
        } else {
          val = value;
        }
        if (val == null) {
          val = '';
        } else if (typeof val === 'number') {
          val += '';
        } else if (jQuery.isArray(val)) {
          val = jQuery.map(val, function (value) {
            return value == null ? '' : value + '';
          });
        }
        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
        if (!hooks || !('set' in hooks) || hooks.set(this, val, 'value') === undefined) {
          this.value = val;
        }
      });
    }
  });
  jQuery.extend({
    valHooks: {
      option: {
        get: function (elem) {
          var val = elem.attributes.value;
          return !val || val.specified ? elem.value : elem.text;
        }
      },
      select: {
        get: function (elem) {
          var value, option, options = elem.options, index = elem.selectedIndex, one = elem.type === 'select-one' || index < 0, values = one ? null : [], max = one ? index + 1 : options.length, i = index < 0 ? max : one ? index : 0;
          for (; i < max; i++) {
            option = options[i];
            if ((option.selected || i === index) && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute('disabled') === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, 'optgroup'))) {
              value = jQuery(option).val();
              if (one) {
                return value;
              }
              values.push(value);
            }
          }
          return values;
        },
        set: function (elem, value) {
          var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
          while (i--) {
            option = options[i];
            if (option.selected = jQuery.inArray(jQuery(option).val(), values) >= 0) {
              optionSet = true;
            }
          }
          if (!optionSet) {
            elem.selectedIndex = -1;
          }
          return values;
        }
      }
    },
    attr: function (elem, name, value) {
      var hooks, ret, nType = elem.nodeType;
      if (!elem || nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      if (typeof elem.getAttribute === core_strundefined) {
        return jQuery.prop(elem, name, value);
      }
      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        name = name.toLowerCase();
        hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
      }
      if (value !== undefined) {
        if (value === null) {
          jQuery.removeAttr(elem, name);
        } else if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        } else {
          elem.setAttribute(name, value + '');
          return value;
        }
      } else if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      } else {
        ret = jQuery.find.attr(elem, name);
        return ret == null ? undefined : ret;
      }
    },
    removeAttr: function (elem, value) {
      var name, propName, i = 0, attrNames = value && value.match(core_rnotwhite);
      if (attrNames && elem.nodeType === 1) {
        while (name = attrNames[i++]) {
          propName = jQuery.propFix[name] || name;
          if (jQuery.expr.match.bool.test(name)) {
            elem[propName] = false;
          }
          elem.removeAttribute(name);
        }
      }
    },
    attrHooks: {
      type: {
        set: function (elem, value) {
          if (!jQuery.support.radioValue && value === 'radio' && jQuery.nodeName(elem, 'input')) {
            var val = elem.value;
            elem.setAttribute('type', value);
            if (val) {
              elem.value = val;
            }
            return value;
          }
        }
      }
    },
    propFix: {
      'for': 'htmlFor',
      'class': 'className'
    },
    prop: function (elem, name, value) {
      var ret, hooks, notxml, nType = elem.nodeType;
      if (!elem || nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
      if (notxml) {
        name = jQuery.propFix[name] || name;
        hooks = jQuery.propHooks[name];
      }
      if (value !== undefined) {
        return hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : elem[name] = value;
      } else {
        return hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];
      }
    },
    propHooks: {
      tabIndex: {
        get: function (elem) {
          return elem.hasAttribute('tabindex') || rfocusable.test(elem.nodeName) || elem.href ? elem.tabIndex : -1;
        }
      }
    }
  });
  boolHook = {
    set: function (elem, value, name) {
      if (value === false) {
        jQuery.removeAttr(elem, name);
      } else {
        elem.setAttribute(name, name);
      }
      return name;
    }
  };
  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
    var getter = jQuery.expr.attrHandle[name] || jQuery.find.attr;
    jQuery.expr.attrHandle[name] = function (elem, name, isXML) {
      var fn = jQuery.expr.attrHandle[name], ret = isXML ? undefined : (jQuery.expr.attrHandle[name] = undefined) != getter(elem, name, isXML) ? name.toLowerCase() : null;
      jQuery.expr.attrHandle[name] = fn;
      return ret;
    };
  });
  if (!jQuery.support.optSelected) {
    jQuery.propHooks.selected = {
      get: function (elem) {
        var parent = elem.parentNode;
        if (parent && parent.parentNode) {
          parent.parentNode.selectedIndex;
        }
        return null;
      }
    };
  }
  jQuery.each([
    'tabIndex',
    'readOnly',
    'maxLength',
    'cellSpacing',
    'cellPadding',
    'rowSpan',
    'colSpan',
    'useMap',
    'frameBorder',
    'contentEditable'
  ], function () {
    jQuery.propFix[this.toLowerCase()] = this;
  });
  jQuery.each([
    'radio',
    'checkbox'
  ], function () {
    jQuery.valHooks[this] = {
      set: function (elem, value) {
        if (jQuery.isArray(value)) {
          return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0;
        }
      }
    };
    if (!jQuery.support.checkOn) {
      jQuery.valHooks[this].get = function (elem) {
        return elem.getAttribute('value') === null ? 'on' : elem.value;
      };
    }
  });
  var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|contextmenu)|click/, rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
  function returnTrue() {
    return true;
  }
  function returnFalse() {
    return false;
  }
  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch (err) {
    }
  }
  jQuery.event = {
    global: {},
    add: function (elem, types, handler, data, selector) {
      var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.get(elem);
      if (!elemData) {
        return;
      }
      if (handler.handler) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      }
      if (!handler.guid) {
        handler.guid = jQuery.guid++;
      }
      if (!(events = elemData.events)) {
        events = elemData.events = {};
      }
      if (!(eventHandle = elemData.handle)) {
        eventHandle = elemData.handle = function (e) {
          return typeof jQuery !== core_strundefined && (!e || jQuery.event.triggered !== e.type) ? jQuery.event.dispatch.apply(eventHandle.elem, arguments) : undefined;
        };
        eventHandle.elem = elem;
      }
      types = (types || '').match(core_rnotwhite) || [''];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || '').split('.').sort();
        if (!type) {
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        special = jQuery.event.special[type] || {};
        handleObj = jQuery.extend({
          type: type,
          origType: origType,
          data: data,
          handler: handler,
          guid: handler.guid,
          selector: selector,
          needsContext: selector && jQuery.expr.match.needsContext.test(selector),
          namespace: namespaces.join('.')
        }, handleObjIn);
        if (!(handlers = events[type])) {
          handlers = events[type] = [];
          handlers.delegateCount = 0;
          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
            if (elem.addEventListener) {
              elem.addEventListener(type, eventHandle, false);
            }
          }
        }
        if (special.add) {
          special.add.call(elem, handleObj);
          if (!handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        }
        if (selector) {
          handlers.splice(handlers.delegateCount++, 0, handleObj);
        } else {
          handlers.push(handleObj);
        }
        jQuery.event.global[type] = true;
      }
      elem = null;
    },
    remove: function (elem, types, handler, selector, mappedTypes) {
      var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.hasData(elem) && data_priv.get(elem);
      if (!elemData || !(events = elemData.events)) {
        return;
      }
      types = (types || '').match(core_rnotwhite) || [''];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || '').split('.').sort();
        if (!type) {
          for (type in events) {
            jQuery.event.remove(elem, type + types[t], handler, selector, true);
          }
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        handlers = events[type] || [];
        tmp = tmp[2] && new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)');
        origCount = j = handlers.length;
        while (j--) {
          handleObj = handlers[j];
          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === '**' && handleObj.selector)) {
            handlers.splice(j, 1);
            if (handleObj.selector) {
              handlers.delegateCount--;
            }
            if (special.remove) {
              special.remove.call(elem, handleObj);
            }
          }
        }
        if (origCount && !handlers.length) {
          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
            jQuery.removeEvent(elem, type, elemData.handle);
          }
          delete events[type];
        }
      }
      if (jQuery.isEmptyObject(events)) {
        delete elemData.handle;
        data_priv.remove(elem, 'events');
      }
    },
    trigger: function (event, data, elem, onlyHandlers) {
      var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [elem || document], type = core_hasOwn.call(event, 'type') ? event.type : event, namespaces = core_hasOwn.call(event, 'namespace') ? event.namespace.split('.') : [];
      cur = tmp = elem = elem || document;
      if (elem.nodeType === 3 || elem.nodeType === 8) {
        return;
      }
      if (rfocusMorph.test(type + jQuery.event.triggered)) {
        return;
      }
      if (type.indexOf('.') >= 0) {
        namespaces = type.split('.');
        type = namespaces.shift();
        namespaces.sort();
      }
      ontype = type.indexOf(':') < 0 && 'on' + type;
      event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === 'object' && event);
      event.isTrigger = onlyHandlers ? 2 : 3;
      event.namespace = namespaces.join('.');
      event.namespace_re = event.namespace ? new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)') : null;
      event.result = undefined;
      if (!event.target) {
        event.target = elem;
      }
      data = data == null ? [event] : jQuery.makeArray(data, [event]);
      special = jQuery.event.special[type] || {};
      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
        return;
      }
      if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
        bubbleType = special.delegateType || type;
        if (!rfocusMorph.test(bubbleType + type)) {
          cur = cur.parentNode;
        }
        for (; cur; cur = cur.parentNode) {
          eventPath.push(cur);
          tmp = cur;
        }
        if (tmp === (elem.ownerDocument || document)) {
          eventPath.push(tmp.defaultView || tmp.parentWindow || window);
        }
      }
      i = 0;
      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
        event.type = i > 1 ? bubbleType : special.bindType || type;
        handle = (data_priv.get(cur, 'events') || {})[event.type] && data_priv.get(cur, 'handle');
        if (handle) {
          handle.apply(cur, data);
        }
        handle = ontype && cur[ontype];
        if (handle && jQuery.acceptData(cur) && handle.apply && handle.apply(cur, data) === false) {
          event.preventDefault();
        }
      }
      event.type = type;
      if (!onlyHandlers && !event.isDefaultPrevented()) {
        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {
          if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
            tmp = elem[ontype];
            if (tmp) {
              elem[ontype] = null;
            }
            jQuery.event.triggered = type;
            elem[type]();
            jQuery.event.triggered = undefined;
            if (tmp) {
              elem[ontype] = tmp;
            }
          }
        }
      }
      return event.result;
    },
    dispatch: function (event) {
      event = jQuery.event.fix(event);
      var i, j, ret, matched, handleObj, handlerQueue = [], args = core_slice.call(arguments), handlers = (data_priv.get(this, 'events') || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
      args[0] = event;
      event.delegateTarget = this;
      if (special.preDispatch && special.preDispatch.call(this, event) === false) {
        return;
      }
      handlerQueue = jQuery.event.handlers.call(this, event, handlers);
      i = 0;
      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
        event.currentTarget = matched.elem;
        j = 0;
        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
          if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
            if (ret !== undefined) {
              if ((event.result = ret) === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      }
      if (special.postDispatch) {
        special.postDispatch.call(this, event);
      }
      return event.result;
    },
    handlers: function (event, handlers) {
      var i, matches, sel, handleObj, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
      if (delegateCount && cur.nodeType && (!event.button || event.type !== 'click')) {
        for (; cur !== this; cur = cur.parentNode || this) {
          if (cur.disabled !== true || event.type !== 'click') {
            matches = [];
            for (i = 0; i < delegateCount; i++) {
              handleObj = handlers[i];
              sel = handleObj.selector + ' ';
              if (matches[sel] === undefined) {
                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length;
              }
              if (matches[sel]) {
                matches.push(handleObj);
              }
            }
            if (matches.length) {
              handlerQueue.push({
                elem: cur,
                handlers: matches
              });
            }
          }
        }
      }
      if (delegateCount < handlers.length) {
        handlerQueue.push({
          elem: this,
          handlers: handlers.slice(delegateCount)
        });
      }
      return handlerQueue;
    },
    props: 'altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which'.split(' '),
    fixHooks: {},
    keyHooks: {
      props: 'char charCode key keyCode'.split(' '),
      filter: function (event, original) {
        if (event.which == null) {
          event.which = original.charCode != null ? original.charCode : original.keyCode;
        }
        return event;
      }
    },
    mouseHooks: {
      props: 'button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement'.split(' '),
      filter: function (event, original) {
        var eventDoc, doc, body, button = original.button;
        if (event.pageX == null && original.clientX != null) {
          eventDoc = event.target.ownerDocument || document;
          doc = eventDoc.documentElement;
          body = eventDoc.body;
          event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
          event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
        }
        if (!event.which && button !== undefined) {
          event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
        }
        return event;
      }
    },
    fix: function (event) {
      if (event[jQuery.expando]) {
        return event;
      }
      var i, prop, copy, type = event.type, originalEvent = event, fixHook = this.fixHooks[type];
      if (!fixHook) {
        this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
      }
      copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
      event = new jQuery.Event(originalEvent);
      i = copy.length;
      while (i--) {
        prop = copy[i];
        event[prop] = originalEvent[prop];
      }
      if (!event.target) {
        event.target = document;
      }
      if (event.target.nodeType === 3) {
        event.target = event.target.parentNode;
      }
      return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
    },
    special: {
      load: { noBubble: true },
      focus: {
        trigger: function () {
          if (this !== safeActiveElement() && this.focus) {
            this.focus();
            return false;
          }
        },
        delegateType: 'focusin'
      },
      blur: {
        trigger: function () {
          if (this === safeActiveElement() && this.blur) {
            this.blur();
            return false;
          }
        },
        delegateType: 'focusout'
      },
      click: {
        trigger: function () {
          if (this.type === 'checkbox' && this.click && jQuery.nodeName(this, 'input')) {
            this.click();
            return false;
          }
        },
        _default: function (event) {
          return jQuery.nodeName(event.target, 'a');
        }
      },
      beforeunload: {
        postDispatch: function (event) {
          if (event.result !== undefined) {
            event.originalEvent.returnValue = event.result;
          }
        }
      }
    },
    simulate: function (type, elem, event, bubble) {
      var e = jQuery.extend(new jQuery.Event(), event, {
          type: type,
          isSimulated: true,
          originalEvent: {}
        });
      if (bubble) {
        jQuery.event.trigger(e, null, elem);
      } else {
        jQuery.event.dispatch.call(elem, e);
      }
      if (e.isDefaultPrevented()) {
        event.preventDefault();
      }
    }
  };
  jQuery.removeEvent = function (elem, type, handle) {
    if (elem.removeEventListener) {
      elem.removeEventListener(type, handle, false);
    }
  };
  jQuery.Event = function (src, props) {
    if (!(this instanceof jQuery.Event)) {
      return new jQuery.Event(src, props);
    }
    if (src && src.type) {
      this.originalEvent = src;
      this.type = src.type;
      this.isDefaultPrevented = src.defaultPrevented || src.getPreventDefault && src.getPreventDefault() ? returnTrue : returnFalse;
    } else {
      this.type = src;
    }
    if (props) {
      jQuery.extend(this, props);
    }
    this.timeStamp = src && src.timeStamp || jQuery.now();
    this[jQuery.expando] = true;
  };
  jQuery.Event.prototype = {
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,
    preventDefault: function () {
      var e = this.originalEvent;
      this.isDefaultPrevented = returnTrue;
      if (e && e.preventDefault) {
        e.preventDefault();
      }
    },
    stopPropagation: function () {
      var e = this.originalEvent;
      this.isPropagationStopped = returnTrue;
      if (e && e.stopPropagation) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function () {
      this.isImmediatePropagationStopped = returnTrue;
      this.stopPropagation();
    }
  };
  jQuery.each({
    mouseenter: 'mouseover',
    mouseleave: 'mouseout'
  }, function (orig, fix) {
    jQuery.event.special[orig] = {
      delegateType: fix,
      bindType: fix,
      handle: function (event) {
        var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
        if (!related || related !== target && !jQuery.contains(target, related)) {
          event.type = handleObj.origType;
          ret = handleObj.handler.apply(this, arguments);
          event.type = fix;
        }
        return ret;
      }
    };
  });
  if (!jQuery.support.focusinBubbles) {
    jQuery.each({
      focus: 'focusin',
      blur: 'focusout'
    }, function (orig, fix) {
      var attaches = 0, handler = function (event) {
          jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
        };
      jQuery.event.special[fix] = {
        setup: function () {
          if (attaches++ === 0) {
            document.addEventListener(orig, handler, true);
          }
        },
        teardown: function () {
          if (--attaches === 0) {
            document.removeEventListener(orig, handler, true);
          }
        }
      };
    });
  }
  jQuery.fn.extend({
    on: function (types, selector, data, fn, one) {
      var origFn, type;
      if (typeof types === 'object') {
        if (typeof selector !== 'string') {
          data = data || selector;
          selector = undefined;
        }
        for (type in types) {
          this.on(type, selector, data, types[type], one);
        }
        return this;
      }
      if (data == null && fn == null) {
        fn = selector;
        data = selector = undefined;
      } else if (fn == null) {
        if (typeof selector === 'string') {
          fn = data;
          data = undefined;
        } else {
          fn = data;
          data = selector;
          selector = undefined;
        }
      }
      if (fn === false) {
        fn = returnFalse;
      } else if (!fn) {
        return this;
      }
      if (one === 1) {
        origFn = fn;
        fn = function (event) {
          jQuery().off(event);
          return origFn.apply(this, arguments);
        };
        fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
      }
      return this.each(function () {
        jQuery.event.add(this, types, fn, data, selector);
      });
    },
    one: function (types, selector, data, fn) {
      return this.on(types, selector, data, fn, 1);
    },
    off: function (types, selector, fn) {
      var handleObj, type;
      if (types && types.preventDefault && types.handleObj) {
        handleObj = types.handleObj;
        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + '.' + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
        return this;
      }
      if (typeof types === 'object') {
        for (type in types) {
          this.off(type, selector, types[type]);
        }
        return this;
      }
      if (selector === false || typeof selector === 'function') {
        fn = selector;
        selector = undefined;
      }
      if (fn === false) {
        fn = returnFalse;
      }
      return this.each(function () {
        jQuery.event.remove(this, types, fn, selector);
      });
    },
    trigger: function (type, data) {
      return this.each(function () {
        jQuery.event.trigger(type, data, this);
      });
    },
    triggerHandler: function (type, data) {
      var elem = this[0];
      if (elem) {
        return jQuery.event.trigger(type, data, elem, true);
      }
    }
  });
  var isSimple = /^.[^:#\[\.,]*$/, rparentsprev = /^(?:parents|prev(?:Until|All))/, rneedsContext = jQuery.expr.match.needsContext, guaranteedUnique = {
      children: true,
      contents: true,
      next: true,
      prev: true
    };
  jQuery.fn.extend({
    find: function (selector) {
      var i, ret = [], self = this, len = self.length;
      if (typeof selector !== 'string') {
        return this.pushStack(jQuery(selector).filter(function () {
          for (i = 0; i < len; i++) {
            if (jQuery.contains(self[i], this)) {
              return true;
            }
          }
        }));
      }
      for (i = 0; i < len; i++) {
        jQuery.find(selector, self[i], ret);
      }
      ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
      ret.selector = this.selector ? this.selector + ' ' + selector : selector;
      return ret;
    },
    has: function (target) {
      var targets = jQuery(target, this), l = targets.length;
      return this.filter(function () {
        var i = 0;
        for (; i < l; i++) {
          if (jQuery.contains(this, targets[i])) {
            return true;
          }
        }
      });
    },
    not: function (selector) {
      return this.pushStack(winnow(this, selector || [], true));
    },
    filter: function (selector) {
      return this.pushStack(winnow(this, selector || [], false));
    },
    is: function (selector) {
      return !!winnow(this, typeof selector === 'string' && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
    },
    closest: function (selectors, context) {
      var cur, i = 0, l = this.length, matched = [], pos = rneedsContext.test(selectors) || typeof selectors !== 'string' ? jQuery(selectors, context || this.context) : 0;
      for (; i < l; i++) {
        for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
          if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
            cur = matched.push(cur);
            break;
          }
        }
      }
      return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
    },
    index: function (elem) {
      if (!elem) {
        return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
      }
      if (typeof elem === 'string') {
        return core_indexOf.call(jQuery(elem), this[0]);
      }
      return core_indexOf.call(this, elem.jquery ? elem[0] : elem);
    },
    add: function (selector, context) {
      var set = typeof selector === 'string' ? jQuery(selector, context) : jQuery.makeArray(selector && selector.nodeType ? [selector] : selector), all = jQuery.merge(this.get(), set);
      return this.pushStack(jQuery.unique(all));
    },
    addBack: function (selector) {
      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
    }
  });
  function sibling(cur, dir) {
    while ((cur = cur[dir]) && cur.nodeType !== 1) {
    }
    return cur;
  }
  jQuery.each({
    parent: function (elem) {
      var parent = elem.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function (elem) {
      return jQuery.dir(elem, 'parentNode');
    },
    parentsUntil: function (elem, i, until) {
      return jQuery.dir(elem, 'parentNode', until);
    },
    next: function (elem) {
      return sibling(elem, 'nextSibling');
    },
    prev: function (elem) {
      return sibling(elem, 'previousSibling');
    },
    nextAll: function (elem) {
      return jQuery.dir(elem, 'nextSibling');
    },
    prevAll: function (elem) {
      return jQuery.dir(elem, 'previousSibling');
    },
    nextUntil: function (elem, i, until) {
      return jQuery.dir(elem, 'nextSibling', until);
    },
    prevUntil: function (elem, i, until) {
      return jQuery.dir(elem, 'previousSibling', until);
    },
    siblings: function (elem) {
      return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
    },
    children: function (elem) {
      return jQuery.sibling(elem.firstChild);
    },
    contents: function (elem) {
      return elem.contentDocument || jQuery.merge([], elem.childNodes);
    }
  }, function (name, fn) {
    jQuery.fn[name] = function (until, selector) {
      var matched = jQuery.map(this, fn, until);
      if (name.slice(-5) !== 'Until') {
        selector = until;
      }
      if (selector && typeof selector === 'string') {
        matched = jQuery.filter(selector, matched);
      }
      if (this.length > 1) {
        if (!guaranteedUnique[name]) {
          jQuery.unique(matched);
        }
        if (rparentsprev.test(name)) {
          matched.reverse();
        }
      }
      return this.pushStack(matched);
    };
  });
  jQuery.extend({
    filter: function (expr, elems, not) {
      var elem = elems[0];
      if (not) {
        expr = ':not(' + expr + ')';
      }
      return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
        return elem.nodeType === 1;
      }));
    },
    dir: function (elem, dir, until) {
      var matched = [], truncate = until !== undefined;
      while ((elem = elem[dir]) && elem.nodeType !== 9) {
        if (elem.nodeType === 1) {
          if (truncate && jQuery(elem).is(until)) {
            break;
          }
          matched.push(elem);
        }
      }
      return matched;
    },
    sibling: function (n, elem) {
      var matched = [];
      for (; n; n = n.nextSibling) {
        if (n.nodeType === 1 && n !== elem) {
          matched.push(n);
        }
      }
      return matched;
    }
  });
  function winnow(elements, qualifier, not) {
    if (jQuery.isFunction(qualifier)) {
      return jQuery.grep(elements, function (elem, i) {
        return !!qualifier.call(elem, i, elem) !== not;
      });
    }
    if (qualifier.nodeType) {
      return jQuery.grep(elements, function (elem) {
        return elem === qualifier !== not;
      });
    }
    if (typeof qualifier === 'string') {
      if (isSimple.test(qualifier)) {
        return jQuery.filter(qualifier, elements, not);
      }
      qualifier = jQuery.filter(qualifier, elements);
    }
    return jQuery.grep(elements, function (elem) {
      return core_indexOf.call(qualifier, elem) >= 0 !== not;
    });
  }
  var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, rtagName = /<([\w:]+)/, rhtml = /<|&#?\w+;/, rnoInnerhtml = /<(?:script|style|link)/i, manipulation_rcheckableType = /^(?:checkbox|radio)$/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptType = /^$|\/(?:java|ecma)script/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, wrapMap = {
      option: [
        1,
        '<select multiple=\'multiple\'>',
        '</select>'
      ],
      thead: [
        1,
        '<table>',
        '</table>'
      ],
      col: [
        2,
        '<table><colgroup>',
        '</colgroup></table>'
      ],
      tr: [
        2,
        '<table><tbody>',
        '</tbody></table>'
      ],
      td: [
        3,
        '<table><tbody><tr>',
        '</tr></tbody></table>'
      ],
      _default: [
        0,
        '',
        ''
      ]
    };
  wrapMap.optgroup = wrapMap.option;
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;
  jQuery.fn.extend({
    text: function (value) {
      return jQuery.access(this, function (value) {
        return value === undefined ? jQuery.text(this) : this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(value));
      }, null, value, arguments.length);
    },
    append: function () {
      return this.domManip(arguments, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.appendChild(elem);
        }
      });
    },
    prepend: function () {
      return this.domManip(arguments, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.insertBefore(elem, target.firstChild);
        }
      });
    },
    before: function () {
      return this.domManip(arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this);
        }
      });
    },
    after: function () {
      return this.domManip(arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this.nextSibling);
        }
      });
    },
    remove: function (selector, keepData) {
      var elem, elems = selector ? jQuery.filter(selector, this) : this, i = 0;
      for (; (elem = elems[i]) != null; i++) {
        if (!keepData && elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem));
        }
        if (elem.parentNode) {
          if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
            setGlobalEval(getAll(elem, 'script'));
          }
          elem.parentNode.removeChild(elem);
        }
      }
      return this;
    },
    empty: function () {
      var elem, i = 0;
      for (; (elem = this[i]) != null; i++) {
        if (elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem, false));
          elem.textContent = '';
        }
      }
      return this;
    },
    clone: function (dataAndEvents, deepDataAndEvents) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
      return this.map(function () {
        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
      });
    },
    html: function (value) {
      return jQuery.access(this, function (value) {
        var elem = this[0] || {}, i = 0, l = this.length;
        if (value === undefined && elem.nodeType === 1) {
          return elem.innerHTML;
        }
        if (typeof value === 'string' && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [
            '',
            ''
          ])[1].toLowerCase()]) {
          value = value.replace(rxhtmlTag, '<$1></$2>');
          try {
            for (; i < l; i++) {
              elem = this[i] || {};
              if (elem.nodeType === 1) {
                jQuery.cleanData(getAll(elem, false));
                elem.innerHTML = value;
              }
            }
            elem = 0;
          } catch (e) {
          }
        }
        if (elem) {
          this.empty().append(value);
        }
      }, null, value, arguments.length);
    },
    replaceWith: function () {
      var args = jQuery.map(this, function (elem) {
          return [
            elem.nextSibling,
            elem.parentNode
          ];
        }), i = 0;
      this.domManip(arguments, function (elem) {
        var next = args[i++], parent = args[i++];
        if (parent) {
          if (next && next.parentNode !== parent) {
            next = this.nextSibling;
          }
          jQuery(this).remove();
          parent.insertBefore(elem, next);
        }
      }, true);
      return i ? this : this.remove();
    },
    detach: function (selector) {
      return this.remove(selector, true);
    },
    domManip: function (args, callback, allowIntersection) {
      args = core_concat.apply([], args);
      var fragment, first, scripts, hasScripts, node, doc, i = 0, l = this.length, set = this, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
      if (isFunction || !(l <= 1 || typeof value !== 'string' || jQuery.support.checkClone || !rchecked.test(value))) {
        return this.each(function (index) {
          var self = set.eq(index);
          if (isFunction) {
            args[0] = value.call(this, index, self.html());
          }
          self.domManip(args, callback, allowIntersection);
        });
      }
      if (l) {
        fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, !allowIntersection && this);
        first = fragment.firstChild;
        if (fragment.childNodes.length === 1) {
          fragment = first;
        }
        if (first) {
          scripts = jQuery.map(getAll(fragment, 'script'), disableScript);
          hasScripts = scripts.length;
          for (; i < l; i++) {
            node = fragment;
            if (i !== iNoClone) {
              node = jQuery.clone(node, true, true);
              if (hasScripts) {
                jQuery.merge(scripts, getAll(node, 'script'));
              }
            }
            callback.call(this[i], node, i);
          }
          if (hasScripts) {
            doc = scripts[scripts.length - 1].ownerDocument;
            jQuery.map(scripts, restoreScript);
            for (i = 0; i < hasScripts; i++) {
              node = scripts[i];
              if (rscriptType.test(node.type || '') && !data_priv.access(node, 'globalEval') && jQuery.contains(doc, node)) {
                if (node.src) {
                  jQuery._evalUrl(node.src);
                } else {
                  jQuery.globalEval(node.textContent.replace(rcleanScript, ''));
                }
              }
            }
          }
        }
      }
      return this;
    }
  });
  jQuery.each({
    appendTo: 'append',
    prependTo: 'prepend',
    insertBefore: 'before',
    insertAfter: 'after',
    replaceAll: 'replaceWith'
  }, function (name, original) {
    jQuery.fn[name] = function (selector) {
      var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;
      for (; i <= last; i++) {
        elems = i === last ? this : this.clone(true);
        jQuery(insert[i])[original](elems);
        core_push.apply(ret, elems.get());
      }
      return this.pushStack(ret);
    };
  });
  jQuery.extend({
    clone: function (elem, dataAndEvents, deepDataAndEvents) {
      var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = jQuery.contains(elem.ownerDocument, elem);
      if (!jQuery.support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
        destElements = getAll(clone);
        srcElements = getAll(elem);
        for (i = 0, l = srcElements.length; i < l; i++) {
          fixInput(srcElements[i], destElements[i]);
        }
      }
      if (dataAndEvents) {
        if (deepDataAndEvents) {
          srcElements = srcElements || getAll(elem);
          destElements = destElements || getAll(clone);
          for (i = 0, l = srcElements.length; i < l; i++) {
            cloneCopyEvent(srcElements[i], destElements[i]);
          }
        } else {
          cloneCopyEvent(elem, clone);
        }
      }
      destElements = getAll(clone, 'script');
      if (destElements.length > 0) {
        setGlobalEval(destElements, !inPage && getAll(elem, 'script'));
      }
      return clone;
    },
    buildFragment: function (elems, context, scripts, selection) {
      var elem, tmp, tag, wrap, contains, j, i = 0, l = elems.length, fragment = context.createDocumentFragment(), nodes = [];
      for (; i < l; i++) {
        elem = elems[i];
        if (elem || elem === 0) {
          if (jQuery.type(elem) === 'object') {
            jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
          } else if (!rhtml.test(elem)) {
            nodes.push(context.createTextNode(elem));
          } else {
            tmp = tmp || fragment.appendChild(context.createElement('div'));
            tag = (rtagName.exec(elem) || [
              '',
              ''
            ])[1].toLowerCase();
            wrap = wrapMap[tag] || wrapMap._default;
            tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, '<$1></$2>') + wrap[2];
            j = wrap[0];
            while (j--) {
              tmp = tmp.lastChild;
            }
            jQuery.merge(nodes, tmp.childNodes);
            tmp = fragment.firstChild;
            tmp.textContent = '';
          }
        }
      }
      fragment.textContent = '';
      i = 0;
      while (elem = nodes[i++]) {
        if (selection && jQuery.inArray(elem, selection) !== -1) {
          continue;
        }
        contains = jQuery.contains(elem.ownerDocument, elem);
        tmp = getAll(fragment.appendChild(elem), 'script');
        if (contains) {
          setGlobalEval(tmp);
        }
        if (scripts) {
          j = 0;
          while (elem = tmp[j++]) {
            if (rscriptType.test(elem.type || '')) {
              scripts.push(elem);
            }
          }
        }
      }
      return fragment;
    },
    cleanData: function (elems) {
      var data, elem, events, type, key, j, special = jQuery.event.special, i = 0;
      for (; (elem = elems[i]) !== undefined; i++) {
        if (Data.accepts(elem)) {
          key = elem[data_priv.expando];
          if (key && (data = data_priv.cache[key])) {
            events = Object.keys(data.events || {});
            if (events.length) {
              for (j = 0; (type = events[j]) !== undefined; j++) {
                if (special[type]) {
                  jQuery.event.remove(elem, type);
                } else {
                  jQuery.removeEvent(elem, type, data.handle);
                }
              }
            }
            if (data_priv.cache[key]) {
              delete data_priv.cache[key];
            }
          }
        }
        delete data_user.cache[elem[data_user.expando]];
      }
    },
    _evalUrl: function (url) {
      return jQuery.ajax({
        url: url,
        type: 'GET',
        dataType: 'script',
        async: false,
        global: false,
        'throws': true
      });
    }
  });
  function manipulationTarget(elem, content) {
    return jQuery.nodeName(elem, 'table') && jQuery.nodeName(content.nodeType === 1 ? content : content.firstChild, 'tr') ? elem.getElementsByTagName('tbody')[0] || elem.appendChild(elem.ownerDocument.createElement('tbody')) : elem;
  }
  function disableScript(elem) {
    elem.type = (elem.getAttribute('type') !== null) + '/' + elem.type;
    return elem;
  }
  function restoreScript(elem) {
    var match = rscriptTypeMasked.exec(elem.type);
    if (match) {
      elem.type = match[1];
    } else {
      elem.removeAttribute('type');
    }
    return elem;
  }
  function setGlobalEval(elems, refElements) {
    var l = elems.length, i = 0;
    for (; i < l; i++) {
      data_priv.set(elems[i], 'globalEval', !refElements || data_priv.get(refElements[i], 'globalEval'));
    }
  }
  function cloneCopyEvent(src, dest) {
    var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
    if (dest.nodeType !== 1) {
      return;
    }
    if (data_priv.hasData(src)) {
      pdataOld = data_priv.access(src);
      pdataCur = data_priv.set(dest, pdataOld);
      events = pdataOld.events;
      if (events) {
        delete pdataCur.handle;
        pdataCur.events = {};
        for (type in events) {
          for (i = 0, l = events[type].length; i < l; i++) {
            jQuery.event.add(dest, type, events[type][i]);
          }
        }
      }
    }
    if (data_user.hasData(src)) {
      udataOld = data_user.access(src);
      udataCur = jQuery.extend({}, udataOld);
      data_user.set(dest, udataCur);
    }
  }
  function getAll(context, tag) {
    var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || '*') : context.querySelectorAll ? context.querySelectorAll(tag || '*') : [];
    return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret;
  }
  function fixInput(src, dest) {
    var nodeName = dest.nodeName.toLowerCase();
    if (nodeName === 'input' && manipulation_rcheckableType.test(src.type)) {
      dest.checked = src.checked;
    } else if (nodeName === 'input' || nodeName === 'textarea') {
      dest.defaultValue = src.defaultValue;
    }
  }
  jQuery.fn.extend({
    wrapAll: function (html) {
      var wrap;
      if (jQuery.isFunction(html)) {
        return this.each(function (i) {
          jQuery(this).wrapAll(html.call(this, i));
        });
      }
      if (this[0]) {
        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
        if (this[0].parentNode) {
          wrap.insertBefore(this[0]);
        }
        wrap.map(function () {
          var elem = this;
          while (elem.firstElementChild) {
            elem = elem.firstElementChild;
          }
          return elem;
        }).append(this);
      }
      return this;
    },
    wrapInner: function (html) {
      if (jQuery.isFunction(html)) {
        return this.each(function (i) {
          jQuery(this).wrapInner(html.call(this, i));
        });
      }
      return this.each(function () {
        var self = jQuery(this), contents = self.contents();
        if (contents.length) {
          contents.wrapAll(html);
        } else {
          self.append(html);
        }
      });
    },
    wrap: function (html) {
      var isFunction = jQuery.isFunction(html);
      return this.each(function (i) {
        jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
      });
    },
    unwrap: function () {
      return this.parent().each(function () {
        if (!jQuery.nodeName(this, 'body')) {
          jQuery(this).replaceWith(this.childNodes);
        }
      }).end();
    }
  });
  var curCSS, iframe, rdisplayswap = /^(none|table(?!-c[ea]).+)/, rmargin = /^margin/, rnumsplit = new RegExp('^(' + core_pnum + ')(.*)$', 'i'), rnumnonpx = new RegExp('^(' + core_pnum + ')(?!px)[a-z%]+$', 'i'), rrelNum = new RegExp('^([+-])=(' + core_pnum + ')', 'i'), elemdisplay = { BODY: 'block' }, cssShow = {
      position: 'absolute',
      visibility: 'hidden',
      display: 'block'
    }, cssNormalTransform = {
      letterSpacing: 0,
      fontWeight: 400
    }, cssExpand = [
      'Top',
      'Right',
      'Bottom',
      'Left'
    ], cssPrefixes = [
      'Webkit',
      'O',
      'Moz',
      'ms'
    ];
  function vendorPropName(style, name) {
    if (name in style) {
      return name;
    }
    var capName = name.charAt(0).toUpperCase() + name.slice(1), origName = name, i = cssPrefixes.length;
    while (i--) {
      name = cssPrefixes[i] + capName;
      if (name in style) {
        return name;
      }
    }
    return origName;
  }
  function isHidden(elem, el) {
    elem = el || elem;
    return jQuery.css(elem, 'display') === 'none' || !jQuery.contains(elem.ownerDocument, elem);
  }
  function getStyles(elem) {
    return window.getComputedStyle(elem, null);
  }
  function showHide(elements, show) {
    var display, elem, hidden, values = [], index = 0, length = elements.length;
    for (; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      values[index] = data_priv.get(elem, 'olddisplay');
      display = elem.style.display;
      if (show) {
        if (!values[index] && display === 'none') {
          elem.style.display = '';
        }
        if (elem.style.display === '' && isHidden(elem)) {
          values[index] = data_priv.access(elem, 'olddisplay', css_defaultDisplay(elem.nodeName));
        }
      } else {
        if (!values[index]) {
          hidden = isHidden(elem);
          if (display && display !== 'none' || !hidden) {
            data_priv.set(elem, 'olddisplay', hidden ? display : jQuery.css(elem, 'display'));
          }
        }
      }
    }
    for (index = 0; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      if (!show || elem.style.display === 'none' || elem.style.display === '') {
        elem.style.display = show ? values[index] || '' : 'none';
      }
    }
    return elements;
  }
  jQuery.fn.extend({
    css: function (name, value) {
      return jQuery.access(this, function (elem, name, value) {
        var styles, len, map = {}, i = 0;
        if (jQuery.isArray(name)) {
          styles = getStyles(elem);
          len = name.length;
          for (; i < len; i++) {
            map[name[i]] = jQuery.css(elem, name[i], false, styles);
          }
          return map;
        }
        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
      }, name, value, arguments.length > 1);
    },
    show: function () {
      return showHide(this, true);
    },
    hide: function () {
      return showHide(this);
    },
    toggle: function (state) {
      if (typeof state === 'boolean') {
        return state ? this.show() : this.hide();
      }
      return this.each(function () {
        if (isHidden(this)) {
          jQuery(this).show();
        } else {
          jQuery(this).hide();
        }
      });
    }
  });
  jQuery.extend({
    cssHooks: {
      opacity: {
        get: function (elem, computed) {
          if (computed) {
            var ret = curCSS(elem, 'opacity');
            return ret === '' ? '1' : ret;
          }
        }
      }
    },
    cssNumber: {
      'columnCount': true,
      'fillOpacity': true,
      'fontWeight': true,
      'lineHeight': true,
      'opacity': true,
      'order': true,
      'orphans': true,
      'widows': true,
      'zIndex': true,
      'zoom': true
    },
    cssProps: { 'float': 'cssFloat' },
    style: function (elem, name, value, extra) {
      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
        return;
      }
      var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (value !== undefined) {
        type = typeof value;
        if (type === 'string' && (ret = rrelNum.exec(value))) {
          value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
          type = 'number';
        }
        if (value == null || type === 'number' && isNaN(value)) {
          return;
        }
        if (type === 'number' && !jQuery.cssNumber[origName]) {
          value += 'px';
        }
        if (!jQuery.support.clearCloneStyle && value === '' && name.indexOf('background') === 0) {
          style[name] = 'inherit';
        }
        if (!hooks || !('set' in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
          style[name] = value;
        }
      } else {
        if (hooks && 'get' in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
          return ret;
        }
        return style[name];
      }
    },
    css: function (elem, name, extra, styles) {
      var val, num, hooks, origName = jQuery.camelCase(name);
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (hooks && 'get' in hooks) {
        val = hooks.get(elem, true, extra);
      }
      if (val === undefined) {
        val = curCSS(elem, name, styles);
      }
      if (val === 'normal' && name in cssNormalTransform) {
        val = cssNormalTransform[name];
      }
      if (extra === '' || extra) {
        num = parseFloat(val);
        return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
      }
      return val;
    }
  });
  curCSS = function (elem, name, _computed) {
    var width, minWidth, maxWidth, computed = _computed || getStyles(elem), ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined, style = elem.style;
    if (computed) {
      if (ret === '' && !jQuery.contains(elem.ownerDocument, elem)) {
        ret = jQuery.style(elem, name);
      }
      if (rnumnonpx.test(ret) && rmargin.test(name)) {
        width = style.width;
        minWidth = style.minWidth;
        maxWidth = style.maxWidth;
        style.minWidth = style.maxWidth = style.width = ret;
        ret = computed.width;
        style.width = width;
        style.minWidth = minWidth;
        style.maxWidth = maxWidth;
      }
    }
    return ret;
  };
  function setPositiveNumber(elem, value, subtract) {
    var matches = rnumsplit.exec(value);
    return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || 'px') : value;
  }
  function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
    var i = extra === (isBorderBox ? 'border' : 'content') ? 4 : name === 'width' ? 1 : 0, val = 0;
    for (; i < 4; i += 2) {
      if (extra === 'margin') {
        val += jQuery.css(elem, extra + cssExpand[i], true, styles);
      }
      if (isBorderBox) {
        if (extra === 'content') {
          val -= jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
        }
        if (extra !== 'margin') {
          val -= jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
        }
      } else {
        val += jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
        if (extra !== 'padding') {
          val += jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
        }
      }
    }
    return val;
  }
  function getWidthOrHeight(elem, name, extra) {
    var valueIsBorderBox = true, val = name === 'width' ? elem.offsetWidth : elem.offsetHeight, styles = getStyles(elem), isBorderBox = jQuery.support.boxSizing && jQuery.css(elem, 'boxSizing', false, styles) === 'border-box';
    if (val <= 0 || val == null) {
      val = curCSS(elem, name, styles);
      if (val < 0 || val == null) {
        val = elem.style[name];
      }
      if (rnumnonpx.test(val)) {
        return val;
      }
      valueIsBorderBox = isBorderBox && (jQuery.support.boxSizingReliable || val === elem.style[name]);
      val = parseFloat(val) || 0;
    }
    return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? 'border' : 'content'), valueIsBorderBox, styles) + 'px';
  }
  function css_defaultDisplay(nodeName) {
    var doc = document, display = elemdisplay[nodeName];
    if (!display) {
      display = actualDisplay(nodeName, doc);
      if (display === 'none' || !display) {
        iframe = (iframe || jQuery('<iframe frameborder=\'0\' width=\'0\' height=\'0\'/>').css('cssText', 'display:block !important')).appendTo(doc.documentElement);
        doc = (iframe[0].contentWindow || iframe[0].contentDocument).document;
        doc.write('<!doctype html><html><body>');
        doc.close();
        display = actualDisplay(nodeName, doc);
        iframe.detach();
      }
      elemdisplay[nodeName] = display;
    }
    return display;
  }
  function actualDisplay(name, doc) {
    var elem = jQuery(doc.createElement(name)).appendTo(doc.body), display = jQuery.css(elem[0], 'display');
    elem.remove();
    return display;
  }
  jQuery.each([
    'height',
    'width'
  ], function (i, name) {
    jQuery.cssHooks[name] = {
      get: function (elem, computed, extra) {
        if (computed) {
          return elem.offsetWidth === 0 && rdisplayswap.test(jQuery.css(elem, 'display')) ? jQuery.swap(elem, cssShow, function () {
            return getWidthOrHeight(elem, name, extra);
          }) : getWidthOrHeight(elem, name, extra);
        }
      },
      set: function (elem, value, extra) {
        var styles = extra && getStyles(elem);
        return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, jQuery.support.boxSizing && jQuery.css(elem, 'boxSizing', false, styles) === 'border-box', styles) : 0);
      }
    };
  });
  jQuery(function () {
    if (!jQuery.support.reliableMarginRight) {
      jQuery.cssHooks.marginRight = {
        get: function (elem, computed) {
          if (computed) {
            return jQuery.swap(elem, { 'display': 'inline-block' }, curCSS, [
              elem,
              'marginRight'
            ]);
          }
        }
      };
    }
    if (!jQuery.support.pixelPosition && jQuery.fn.position) {
      jQuery.each([
        'top',
        'left'
      ], function (i, prop) {
        jQuery.cssHooks[prop] = {
          get: function (elem, computed) {
            if (computed) {
              computed = curCSS(elem, prop);
              return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + 'px' : computed;
            }
          }
        };
      });
    }
  });
  if (jQuery.expr && jQuery.expr.filters) {
    jQuery.expr.filters.hidden = function (elem) {
      return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
    };
    jQuery.expr.filters.visible = function (elem) {
      return !jQuery.expr.filters.hidden(elem);
    };
  }
  jQuery.each({
    margin: '',
    padding: '',
    border: 'Width'
  }, function (prefix, suffix) {
    jQuery.cssHooks[prefix + suffix] = {
      expand: function (value) {
        var i = 0, expanded = {}, parts = typeof value === 'string' ? value.split(' ') : [value];
        for (; i < 4; i++) {
          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
        }
        return expanded;
      }
    };
    if (!rmargin.test(prefix)) {
      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    }
  });
  var r20 = /%20/g, rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
  jQuery.fn.extend({
    serialize: function () {
      return jQuery.param(this.serializeArray());
    },
    serializeArray: function () {
      return this.map(function () {
        var elements = jQuery.prop(this, 'elements');
        return elements ? jQuery.makeArray(elements) : this;
      }).filter(function () {
        var type = this.type;
        return this.name && !jQuery(this).is(':disabled') && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !manipulation_rcheckableType.test(type));
      }).map(function (i, elem) {
        var val = jQuery(this).val();
        return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {
          return {
            name: elem.name,
            value: val.replace(rCRLF, '\r\n')
          };
        }) : {
          name: elem.name,
          value: val.replace(rCRLF, '\r\n')
        };
      }).get();
    }
  });
  jQuery.param = function (a, traditional) {
    var prefix, s = [], add = function (key, value) {
        value = jQuery.isFunction(value) ? value() : value == null ? '' : value;
        s[s.length] = encodeURIComponent(key) + '=' + encodeURIComponent(value);
      };
    if (traditional === undefined) {
      traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
    }
    if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
      jQuery.each(a, function () {
        add(this.name, this.value);
      });
    } else {
      for (prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    }
    return s.join('&').replace(r20, '+');
  };
  function buildParams(prefix, obj, traditional, add) {
    var name;
    if (jQuery.isArray(obj)) {
      jQuery.each(obj, function (i, v) {
        if (traditional || rbracket.test(prefix)) {
          add(prefix, v);
        } else {
          buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add);
        }
      });
    } else if (!traditional && jQuery.type(obj) === 'object') {
      for (name in obj) {
        buildParams(prefix + '[' + name + ']', obj[name], traditional, add);
      }
    } else {
      add(prefix, obj);
    }
  }
  jQuery.each(('blur focus focusin focusout load resize scroll unload click dblclick ' + 'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' + 'change select submit keydown keypress keyup error contextmenu').split(' '), function (i, name) {
    jQuery.fn[name] = function (data, fn) {
      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
    };
  });
  jQuery.fn.extend({
    hover: function (fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    },
    bind: function (types, data, fn) {
      return this.on(types, null, data, fn);
    },
    unbind: function (types, fn) {
      return this.off(types, null, fn);
    },
    delegate: function (selector, types, data, fn) {
      return this.on(types, selector, data, fn);
    },
    undelegate: function (selector, types, fn) {
      return arguments.length === 1 ? this.off(selector, '**') : this.off(types, selector || '**', fn);
    }
  });
  var ajaxLocParts, ajaxLocation, ajax_nonce = jQuery.now(), ajax_rquery = /\?/, rhash = /#.*$/, rts = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, rurl = /^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/, _load = jQuery.fn.load, prefilters = {}, transports = {}, allTypes = '*/'.concat('*');
  try {
    ajaxLocation = location.href;
  } catch (e) {
    ajaxLocation = document.createElement('a');
    ajaxLocation.href = '';
    ajaxLocation = ajaxLocation.href;
  }
  ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
  function addToPrefiltersOrTransports(structure) {
    return function (dataTypeExpression, func) {
      if (typeof dataTypeExpression !== 'string') {
        func = dataTypeExpression;
        dataTypeExpression = '*';
      }
      var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(core_rnotwhite) || [];
      if (jQuery.isFunction(func)) {
        while (dataType = dataTypes[i++]) {
          if (dataType[0] === '+') {
            dataType = dataType.slice(1) || '*';
            (structure[dataType] = structure[dataType] || []).unshift(func);
          } else {
            (structure[dataType] = structure[dataType] || []).push(func);
          }
        }
      }
    };
  }
  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
    var inspected = {}, seekingTransport = structure === transports;
    function inspect(dataType) {
      var selected;
      inspected[dataType] = true;
      jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
        if (typeof dataTypeOrTransport === 'string' && !seekingTransport && !inspected[dataTypeOrTransport]) {
          options.dataTypes.unshift(dataTypeOrTransport);
          inspect(dataTypeOrTransport);
          return false;
        } else if (seekingTransport) {
          return !(selected = dataTypeOrTransport);
        }
      });
      return selected;
    }
    return inspect(options.dataTypes[0]) || !inspected['*'] && inspect('*');
  }
  function ajaxExtend(target, src) {
    var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
    for (key in src) {
      if (src[key] !== undefined) {
        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
      }
    }
    if (deep) {
      jQuery.extend(true, target, deep);
    }
    return target;
  }
  jQuery.fn.load = function (url, params, callback) {
    if (typeof url !== 'string' && _load) {
      return _load.apply(this, arguments);
    }
    var selector, type, response, self = this, off = url.indexOf(' ');
    if (off >= 0) {
      selector = url.slice(off);
      url = url.slice(0, off);
    }
    if (jQuery.isFunction(params)) {
      callback = params;
      params = undefined;
    } else if (params && typeof params === 'object') {
      type = 'POST';
    }
    if (self.length > 0) {
      jQuery.ajax({
        url: url,
        type: type,
        dataType: 'html',
        data: params
      }).done(function (responseText) {
        response = arguments;
        self.html(selector ? jQuery('<div>').append(jQuery.parseHTML(responseText)).find(selector) : responseText);
      }).complete(callback && function (jqXHR, status) {
        self.each(callback, response || [
          jqXHR.responseText,
          status,
          jqXHR
        ]);
      });
    }
    return this;
  };
  jQuery.each([
    'ajaxStart',
    'ajaxStop',
    'ajaxComplete',
    'ajaxError',
    'ajaxSuccess',
    'ajaxSend'
  ], function (i, type) {
    jQuery.fn[type] = function (fn) {
      return this.on(type, fn);
    };
  });
  jQuery.extend({
    active: 0,
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: ajaxLocation,
      type: 'GET',
      isLocal: rlocalProtocol.test(ajaxLocParts[1]),
      global: true,
      processData: true,
      async: true,
      contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
      accepts: {
        '*': allTypes,
        text: 'text/plain',
        html: 'text/html',
        xml: 'application/xml, text/xml',
        json: 'application/json, text/javascript'
      },
      contents: {
        xml: /xml/,
        html: /html/,
        json: /json/
      },
      responseFields: {
        xml: 'responseXML',
        text: 'responseText',
        json: 'responseJSON'
      },
      converters: {
        '* text': String,
        'text html': true,
        'text json': jQuery.parseJSON,
        'text xml': jQuery.parseXML
      },
      flatOptions: {
        url: true,
        context: true
      }
    },
    ajaxSetup: function (target, settings) {
      return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
    },
    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    ajaxTransport: addToPrefiltersOrTransports(transports),
    ajax: function (url, options) {
      if (typeof url === 'object') {
        options = url;
        url = undefined;
      }
      options = options || {};
      var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, parts, fireGlobals, i, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks('once memory'), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, state = 0, strAbort = 'canceled', jqXHR = {
          readyState: 0,
          getResponseHeader: function (key) {
            var match;
            if (state === 2) {
              if (!responseHeaders) {
                responseHeaders = {};
                while (match = rheaders.exec(responseHeadersString)) {
                  responseHeaders[match[1].toLowerCase()] = match[2];
                }
              }
              match = responseHeaders[key.toLowerCase()];
            }
            return match == null ? null : match;
          },
          getAllResponseHeaders: function () {
            return state === 2 ? responseHeadersString : null;
          },
          setRequestHeader: function (name, value) {
            var lname = name.toLowerCase();
            if (!state) {
              name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
              requestHeaders[name] = value;
            }
            return this;
          },
          overrideMimeType: function (type) {
            if (!state) {
              s.mimeType = type;
            }
            return this;
          },
          statusCode: function (map) {
            var code;
            if (map) {
              if (state < 2) {
                for (code in map) {
                  statusCode[code] = [
                    statusCode[code],
                    map[code]
                  ];
                }
              } else {
                jqXHR.always(map[jqXHR.status]);
              }
            }
            return this;
          },
          abort: function (statusText) {
            var finalText = statusText || strAbort;
            if (transport) {
              transport.abort(finalText);
            }
            done(0, finalText);
            return this;
          }
        };
      deferred.promise(jqXHR).complete = completeDeferred.add;
      jqXHR.success = jqXHR.done;
      jqXHR.error = jqXHR.fail;
      s.url = ((url || s.url || ajaxLocation) + '').replace(rhash, '').replace(rprotocol, ajaxLocParts[1] + '//');
      s.type = options.method || options.type || s.method || s.type;
      s.dataTypes = jQuery.trim(s.dataType || '*').toLowerCase().match(core_rnotwhite) || [''];
      if (s.crossDomain == null) {
        parts = rurl.exec(s.url.toLowerCase());
        s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === 'http:' ? '80' : '443')) !== (ajaxLocParts[3] || (ajaxLocParts[1] === 'http:' ? '80' : '443'))));
      }
      if (s.data && s.processData && typeof s.data !== 'string') {
        s.data = jQuery.param(s.data, s.traditional);
      }
      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
      if (state === 2) {
        return jqXHR;
      }
      fireGlobals = s.global;
      if (fireGlobals && jQuery.active++ === 0) {
        jQuery.event.trigger('ajaxStart');
      }
      s.type = s.type.toUpperCase();
      s.hasContent = !rnoContent.test(s.type);
      cacheURL = s.url;
      if (!s.hasContent) {
        if (s.data) {
          cacheURL = s.url += (ajax_rquery.test(cacheURL) ? '&' : '?') + s.data;
          delete s.data;
        }
        if (s.cache === false) {
          s.url = rts.test(cacheURL) ? cacheURL.replace(rts, '$1_=' + ajax_nonce++) : cacheURL + (ajax_rquery.test(cacheURL) ? '&' : '?') + '_=' + ajax_nonce++;
        }
      }
      if (s.ifModified) {
        if (jQuery.lastModified[cacheURL]) {
          jqXHR.setRequestHeader('If-Modified-Since', jQuery.lastModified[cacheURL]);
        }
        if (jQuery.etag[cacheURL]) {
          jqXHR.setRequestHeader('If-None-Match', jQuery.etag[cacheURL]);
        }
      }
      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
        jqXHR.setRequestHeader('Content-Type', s.contentType);
      }
      jqXHR.setRequestHeader('Accept', s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== '*' ? ', ' + allTypes + '; q=0.01' : '') : s.accepts['*']);
      for (i in s.headers) {
        jqXHR.setRequestHeader(i, s.headers[i]);
      }
      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
        return jqXHR.abort();
      }
      strAbort = 'abort';
      for (i in {
          success: 1,
          error: 1,
          complete: 1
        }) {
        jqXHR[i](s[i]);
      }
      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
      if (!transport) {
        done(-1, 'No Transport');
      } else {
        jqXHR.readyState = 1;
        if (fireGlobals) {
          globalEventContext.trigger('ajaxSend', [
            jqXHR,
            s
          ]);
        }
        if (s.async && s.timeout > 0) {
          timeoutTimer = setTimeout(function () {
            jqXHR.abort('timeout');
          }, s.timeout);
        }
        try {
          state = 1;
          transport.send(requestHeaders, done);
        } catch (e) {
          if (state < 2) {
            done(-1, e);
          } else {
            throw e;
          }
        }
      }
      function done(status, nativeStatusText, responses, headers) {
        var isSuccess, success, error, response, modified, statusText = nativeStatusText;
        if (state === 2) {
          return;
        }
        state = 2;
        if (timeoutTimer) {
          clearTimeout(timeoutTimer);
        }
        transport = undefined;
        responseHeadersString = headers || '';
        jqXHR.readyState = status > 0 ? 4 : 0;
        isSuccess = status >= 200 && status < 300 || status === 304;
        if (responses) {
          response = ajaxHandleResponses(s, jqXHR, responses);
        }
        response = ajaxConvert(s, response, jqXHR, isSuccess);
        if (isSuccess) {
          if (s.ifModified) {
            modified = jqXHR.getResponseHeader('Last-Modified');
            if (modified) {
              jQuery.lastModified[cacheURL] = modified;
            }
            modified = jqXHR.getResponseHeader('etag');
            if (modified) {
              jQuery.etag[cacheURL] = modified;
            }
          }
          if (status === 204 || s.type === 'HEAD') {
            statusText = 'nocontent';
          } else if (status === 304) {
            statusText = 'notmodified';
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        } else {
          error = statusText;
          if (status || !statusText) {
            statusText = 'error';
            if (status < 0) {
              status = 0;
            }
          }
        }
        jqXHR.status = status;
        jqXHR.statusText = (nativeStatusText || statusText) + '';
        if (isSuccess) {
          deferred.resolveWith(callbackContext, [
            success,
            statusText,
            jqXHR
          ]);
        } else {
          deferred.rejectWith(callbackContext, [
            jqXHR,
            statusText,
            error
          ]);
        }
        jqXHR.statusCode(statusCode);
        statusCode = undefined;
        if (fireGlobals) {
          globalEventContext.trigger(isSuccess ? 'ajaxSuccess' : 'ajaxError', [
            jqXHR,
            s,
            isSuccess ? success : error
          ]);
        }
        completeDeferred.fireWith(callbackContext, [
          jqXHR,
          statusText
        ]);
        if (fireGlobals) {
          globalEventContext.trigger('ajaxComplete', [
            jqXHR,
            s
          ]);
          if (!--jQuery.active) {
            jQuery.event.trigger('ajaxStop');
          }
        }
      }
      return jqXHR;
    },
    getJSON: function (url, data, callback) {
      return jQuery.get(url, data, callback, 'json');
    },
    getScript: function (url, callback) {
      return jQuery.get(url, undefined, callback, 'script');
    }
  });
  jQuery.each([
    'get',
    'post'
  ], function (i, method) {
    jQuery[method] = function (url, data, callback, type) {
      if (jQuery.isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      }
      return jQuery.ajax({
        url: url,
        type: method,
        dataType: type,
        data: data,
        success: callback
      });
    };
  });
  function ajaxHandleResponses(s, jqXHR, responses) {
    var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
    while (dataTypes[0] === '*') {
      dataTypes.shift();
      if (ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader('Content-Type');
      }
    }
    if (ct) {
      for (type in contents) {
        if (contents[type] && contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    }
    if (dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      for (type in responses) {
        if (!dataTypes[0] || s.converters[type + ' ' + dataTypes[0]]) {
          finalDataType = type;
          break;
        }
        if (!firstDataType) {
          firstDataType = type;
        }
      }
      finalDataType = finalDataType || firstDataType;
    }
    if (finalDataType) {
      if (finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }
      return responses[finalDataType];
    }
  }
  function ajaxConvert(s, response, jqXHR, isSuccess) {
    var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
    if (dataTypes[1]) {
      for (conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    }
    current = dataTypes.shift();
    while (current) {
      if (s.responseFields[current]) {
        jqXHR[s.responseFields[current]] = response;
      }
      if (!prev && isSuccess && s.dataFilter) {
        response = s.dataFilter(response, s.dataType);
      }
      prev = current;
      current = dataTypes.shift();
      if (current) {
        if (current === '*') {
          current = prev;
        } else if (prev !== '*' && prev !== current) {
          conv = converters[prev + ' ' + current] || converters['* ' + current];
          if (!conv) {
            for (conv2 in converters) {
              tmp = conv2.split(' ');
              if (tmp[1] === current) {
                conv = converters[prev + ' ' + tmp[0]] || converters['* ' + tmp[0]];
                if (conv) {
                  if (conv === true) {
                    conv = converters[conv2];
                  } else if (converters[conv2] !== true) {
                    current = tmp[0];
                    dataTypes.unshift(tmp[1]);
                  }
                  break;
                }
              }
            }
          }
          if (conv !== true) {
            if (conv && s['throws']) {
              response = conv(response);
            } else {
              try {
                response = conv(response);
              } catch (e) {
                return {
                  state: 'parsererror',
                  error: conv ? e : 'No conversion from ' + prev + ' to ' + current
                };
              }
            }
          }
        }
      }
    }
    return {
      state: 'success',
      data: response
    };
  }
  jQuery.ajaxSetup({
    accepts: { script: 'text/javascript, application/javascript, application/ecmascript, application/x-ecmascript' },
    contents: { script: /(?:java|ecma)script/ },
    converters: {
      'text script': function (text) {
        jQuery.globalEval(text);
        return text;
      }
    }
  });
  jQuery.ajaxPrefilter('script', function (s) {
    if (s.cache === undefined) {
      s.cache = false;
    }
    if (s.crossDomain) {
      s.type = 'GET';
    }
  });
  jQuery.ajaxTransport('script', function (s) {
    if (s.crossDomain) {
      var script, callback;
      return {
        send: function (_, complete) {
          script = jQuery('<script>').prop({
            async: true,
            charset: s.scriptCharset,
            src: s.url
          }).on('load error', callback = function (evt) {
            script.remove();
            callback = null;
            if (evt) {
              complete(evt.type === 'error' ? 404 : 200, evt.type);
            }
          });
          document.head.appendChild(script[0]);
        },
        abort: function () {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
  jQuery.ajaxSetup({
    jsonp: 'callback',
    jsonpCallback: function () {
      var callback = oldCallbacks.pop() || jQuery.expando + '_' + ajax_nonce++;
      this[callback] = true;
      return callback;
    }
  });
  jQuery.ajaxPrefilter('json jsonp', function (s, originalSettings, jqXHR) {
    var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? 'url' : typeof s.data === 'string' && !(s.contentType || '').indexOf('application/x-www-form-urlencoded') && rjsonp.test(s.data) && 'data');
    if (jsonProp || s.dataTypes[0] === 'jsonp') {
      callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
      if (jsonProp) {
        s[jsonProp] = s[jsonProp].replace(rjsonp, '$1' + callbackName);
      } else if (s.jsonp !== false) {
        s.url += (ajax_rquery.test(s.url) ? '&' : '?') + s.jsonp + '=' + callbackName;
      }
      s.converters['script json'] = function () {
        if (!responseContainer) {
          jQuery.error(callbackName + ' was not called');
        }
        return responseContainer[0];
      };
      s.dataTypes[0] = 'json';
      overwritten = window[callbackName];
      window[callbackName] = function () {
        responseContainer = arguments;
      };
      jqXHR.always(function () {
        window[callbackName] = overwritten;
        if (s[callbackName]) {
          s.jsonpCallback = originalSettings.jsonpCallback;
          oldCallbacks.push(callbackName);
        }
        if (responseContainer && jQuery.isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }
        responseContainer = overwritten = undefined;
      });
      return 'script';
    }
  });
  jQuery.ajaxSettings.xhr = function () {
    try {
      return new XMLHttpRequest();
    } catch (e) {
    }
  };
  var xhrSupported = jQuery.ajaxSettings.xhr(), xhrSuccessStatus = {
      0: 200,
      1223: 204
    }, xhrId = 0, xhrCallbacks = {};
  if (window.ActiveXObject) {
    jQuery(window).on('unload', function () {
      for (var key in xhrCallbacks) {
        xhrCallbacks[key]();
      }
      xhrCallbacks = undefined;
    });
  }
  jQuery.support.cors = !!xhrSupported && 'withCredentials' in xhrSupported;
  jQuery.support.ajax = xhrSupported = !!xhrSupported;
  jQuery.ajaxTransport(function (options) {
    var callback;
    if (jQuery.support.cors || xhrSupported && !options.crossDomain) {
      return {
        send: function (headers, complete) {
          var i, id, xhr = options.xhr();
          xhr.open(options.type, options.url, options.async, options.username, options.password);
          if (options.xhrFields) {
            for (i in options.xhrFields) {
              xhr[i] = options.xhrFields[i];
            }
          }
          if (options.mimeType && xhr.overrideMimeType) {
            xhr.overrideMimeType(options.mimeType);
          }
          if (!options.crossDomain && !headers['X-Requested-With']) {
            headers['X-Requested-With'] = 'XMLHttpRequest';
          }
          for (i in headers) {
            xhr.setRequestHeader(i, headers[i]);
          }
          callback = function (type) {
            return function () {
              if (callback) {
                delete xhrCallbacks[id];
                callback = xhr.onload = xhr.onerror = null;
                if (type === 'abort') {
                  xhr.abort();
                } else if (type === 'error') {
                  complete(xhr.status || 404, xhr.statusText);
                } else {
                  complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, typeof xhr.responseText === 'string' ? { text: xhr.responseText } : undefined, xhr.getAllResponseHeaders());
                }
              }
            };
          };
          xhr.onload = callback();
          xhr.onerror = callback('error');
          callback = xhrCallbacks[id = xhrId++] = callback('abort');
          xhr.send(options.hasContent && options.data || null);
        },
        abort: function () {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rfxnum = new RegExp('^(?:([+-])=|)(' + core_pnum + ')([a-z%]*)$', 'i'), rrun = /queueHooks$/, animationPrefilters = [defaultPrefilter], tweeners = {
      '*': [function (prop, value) {
          var tween = this.createTween(prop, value), target = tween.cur(), parts = rfxnum.exec(value), unit = parts && parts[3] || (jQuery.cssNumber[prop] ? '' : 'px'), start = (jQuery.cssNumber[prop] || unit !== 'px' && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)), scale = 1, maxIterations = 20;
          if (start && start[3] !== unit) {
            unit = unit || start[3];
            parts = parts || [];
            start = +target || 1;
            do {
              scale = scale || '.5';
              start = start / scale;
              jQuery.style(tween.elem, prop, start + unit);
            } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
          }
          if (parts) {
            start = tween.start = +start || +target || 0;
            tween.unit = unit;
            tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];
          }
          return tween;
        }]
    };
  function createFxNow() {
    setTimeout(function () {
      fxNow = undefined;
    });
    return fxNow = jQuery.now();
  }
  function createTween(value, prop, animation) {
    var tween, collection = (tweeners[prop] || []).concat(tweeners['*']), index = 0, length = collection.length;
    for (; index < length; index++) {
      if (tween = collection[index].call(animation, prop, value)) {
        return tween;
      }
    }
  }
  function Animation(elem, properties, options) {
    var result, stopped, index = 0, length = animationPrefilters.length, deferred = jQuery.Deferred().always(function () {
        delete tick.elem;
      }), tick = function () {
        if (stopped) {
          return false;
        }
        var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
        for (; index < length; index++) {
          animation.tweens[index].run(percent);
        }
        deferred.notifyWith(elem, [
          animation,
          percent,
          remaining
        ]);
        if (percent < 1 && length) {
          return remaining;
        } else {
          deferred.resolveWith(elem, [animation]);
          return false;
        }
      }, animation = deferred.promise({
        elem: elem,
        props: jQuery.extend({}, properties),
        opts: jQuery.extend(true, { specialEasing: {} }, options),
        originalProperties: properties,
        originalOptions: options,
        startTime: fxNow || createFxNow(),
        duration: options.duration,
        tweens: [],
        createTween: function (prop, end) {
          var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
          animation.tweens.push(tween);
          return tween;
        },
        stop: function (gotoEnd) {
          var index = 0, length = gotoEnd ? animation.tweens.length : 0;
          if (stopped) {
            return this;
          }
          stopped = true;
          for (; index < length; index++) {
            animation.tweens[index].run(1);
          }
          if (gotoEnd) {
            deferred.resolveWith(elem, [
              animation,
              gotoEnd
            ]);
          } else {
            deferred.rejectWith(elem, [
              animation,
              gotoEnd
            ]);
          }
          return this;
        }
      }), props = animation.props;
    propFilter(props, animation.opts.specialEasing);
    for (; index < length; index++) {
      result = animationPrefilters[index].call(animation, elem, props, animation.opts);
      if (result) {
        return result;
      }
    }
    jQuery.map(props, createTween, animation);
    if (jQuery.isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    }
    jQuery.fx.timer(jQuery.extend(tick, {
      elem: elem,
      anim: animation,
      queue: animation.opts.queue
    }));
    return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
  }
  function propFilter(props, specialEasing) {
    var index, name, easing, value, hooks;
    for (index in props) {
      name = jQuery.camelCase(index);
      easing = specialEasing[name];
      value = props[index];
      if (jQuery.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }
      if (index !== name) {
        props[name] = value;
        delete props[index];
      }
      hooks = jQuery.cssHooks[name];
      if (hooks && 'expand' in hooks) {
        value = hooks.expand(value);
        delete props[name];
        for (index in value) {
          if (!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }
  jQuery.Animation = jQuery.extend(Animation, {
    tweener: function (props, callback) {
      if (jQuery.isFunction(props)) {
        callback = props;
        props = ['*'];
      } else {
        props = props.split(' ');
      }
      var prop, index = 0, length = props.length;
      for (; index < length; index++) {
        prop = props[index];
        tweeners[prop] = tweeners[prop] || [];
        tweeners[prop].unshift(callback);
      }
    },
    prefilter: function (callback, prepend) {
      if (prepend) {
        animationPrefilters.unshift(callback);
      } else {
        animationPrefilters.push(callback);
      }
    }
  });
  function defaultPrefilter(elem, props, opts) {
    var prop, value, toggle, tween, hooks, oldfire, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHidden(elem), dataShow = data_priv.get(elem, 'fxshow');
    if (!opts.queue) {
      hooks = jQuery._queueHooks(elem, 'fx');
      if (hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;
        hooks.empty.fire = function () {
          if (!hooks.unqueued) {
            oldfire();
          }
        };
      }
      hooks.unqueued++;
      anim.always(function () {
        anim.always(function () {
          hooks.unqueued--;
          if (!jQuery.queue(elem, 'fx').length) {
            hooks.empty.fire();
          }
        });
      });
    }
    if (elem.nodeType === 1 && ('height' in props || 'width' in props)) {
      opts.overflow = [
        style.overflow,
        style.overflowX,
        style.overflowY
      ];
      if (jQuery.css(elem, 'display') === 'inline' && jQuery.css(elem, 'float') === 'none') {
        style.display = 'inline-block';
      }
    }
    if (opts.overflow) {
      style.overflow = 'hidden';
      anim.always(function () {
        style.overflow = opts.overflow[0];
        style.overflowX = opts.overflow[1];
        style.overflowY = opts.overflow[2];
      });
    }
    for (prop in props) {
      value = props[prop];
      if (rfxtypes.exec(value)) {
        delete props[prop];
        toggle = toggle || value === 'toggle';
        if (value === (hidden ? 'hide' : 'show')) {
          if (value === 'show' && dataShow && dataShow[prop] !== undefined) {
            hidden = true;
          } else {
            continue;
          }
        }
        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
      }
    }
    if (!jQuery.isEmptyObject(orig)) {
      if (dataShow) {
        if ('hidden' in dataShow) {
          hidden = dataShow.hidden;
        }
      } else {
        dataShow = data_priv.access(elem, 'fxshow', {});
      }
      if (toggle) {
        dataShow.hidden = !hidden;
      }
      if (hidden) {
        jQuery(elem).show();
      } else {
        anim.done(function () {
          jQuery(elem).hide();
        });
      }
      anim.done(function () {
        var prop;
        data_priv.remove(elem, 'fxshow');
        for (prop in orig) {
          jQuery.style(elem, prop, orig[prop]);
        }
      });
      for (prop in orig) {
        tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
        if (!(prop in dataShow)) {
          dataShow[prop] = tween.start;
          if (hidden) {
            tween.end = tween.start;
            tween.start = prop === 'width' || prop === 'height' ? 1 : 0;
          }
        }
      }
    }
  }
  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }
  jQuery.Tween = Tween;
  Tween.prototype = {
    constructor: Tween,
    init: function (elem, options, prop, end, easing, unit) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || 'swing';
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || (jQuery.cssNumber[prop] ? '' : 'px');
    },
    cur: function () {
      var hooks = Tween.propHooks[this.prop];
      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
    },
    run: function (percent) {
      var eased, hooks = Tween.propHooks[this.prop];
      if (this.options.duration) {
        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
      } else {
        this.pos = eased = percent;
      }
      this.now = (this.end - this.start) * eased + this.start;
      if (this.options.step) {
        this.options.step.call(this.elem, this.now, this);
      }
      if (hooks && hooks.set) {
        hooks.set(this);
      } else {
        Tween.propHooks._default.set(this);
      }
      return this;
    }
  };
  Tween.prototype.init.prototype = Tween.prototype;
  Tween.propHooks = {
    _default: {
      get: function (tween) {
        var result;
        if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
          return tween.elem[tween.prop];
        }
        result = jQuery.css(tween.elem, tween.prop, '');
        return !result || result === 'auto' ? 0 : result;
      },
      set: function (tween) {
        if (jQuery.fx.step[tween.prop]) {
          jQuery.fx.step[tween.prop](tween);
        } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
        } else {
          tween.elem[tween.prop] = tween.now;
        }
      }
    }
  };
  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
    set: function (tween) {
      if (tween.elem.nodeType && tween.elem.parentNode) {
        tween.elem[tween.prop] = tween.now;
      }
    }
  };
  jQuery.each([
    'toggle',
    'show',
    'hide'
  ], function (i, name) {
    var cssFn = jQuery.fn[name];
    jQuery.fn[name] = function (speed, easing, callback) {
      return speed == null || typeof speed === 'boolean' ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
    };
  });
  jQuery.fn.extend({
    fadeTo: function (speed, to, easing, callback) {
      return this.filter(isHidden).css('opacity', 0).show().end().animate({ opacity: to }, speed, easing, callback);
    },
    animate: function (prop, speed, easing, callback) {
      var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function () {
          var anim = Animation(this, jQuery.extend({}, prop), optall);
          if (empty || data_priv.get(this, 'finish')) {
            anim.stop(true);
          }
        };
      doAnimation.finish = doAnimation;
      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
    },
    stop: function (type, clearQueue, gotoEnd) {
      var stopQueue = function (hooks) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop(gotoEnd);
      };
      if (typeof type !== 'string') {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }
      if (clearQueue && type !== false) {
        this.queue(type || 'fx', []);
      }
      return this.each(function () {
        var dequeue = true, index = type != null && type + 'queueHooks', timers = jQuery.timers, data = data_priv.get(this);
        if (index) {
          if (data[index] && data[index].stop) {
            stopQueue(data[index]);
          }
        } else {
          for (index in data) {
            if (data[index] && data[index].stop && rrun.test(index)) {
              stopQueue(data[index]);
            }
          }
        }
        for (index = timers.length; index--;) {
          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
            timers[index].anim.stop(gotoEnd);
            dequeue = false;
            timers.splice(index, 1);
          }
        }
        if (dequeue || !gotoEnd) {
          jQuery.dequeue(this, type);
        }
      });
    },
    finish: function (type) {
      if (type !== false) {
        type = type || 'fx';
      }
      return this.each(function () {
        var index, data = data_priv.get(this), queue = data[type + 'queue'], hooks = data[type + 'queueHooks'], timers = jQuery.timers, length = queue ? queue.length : 0;
        data.finish = true;
        jQuery.queue(this, type, []);
        if (hooks && hooks.stop) {
          hooks.stop.call(this, true);
        }
        for (index = timers.length; index--;) {
          if (timers[index].elem === this && timers[index].queue === type) {
            timers[index].anim.stop(true);
            timers.splice(index, 1);
          }
        }
        for (index = 0; index < length; index++) {
          if (queue[index] && queue[index].finish) {
            queue[index].finish.call(this);
          }
        }
        delete data.finish;
      });
    }
  });
  function genFx(type, includeWidth) {
    var which, attrs = { height: type }, i = 0;
    includeWidth = includeWidth ? 1 : 0;
    for (; i < 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs['margin' + which] = attrs['padding' + which] = type;
    }
    if (includeWidth) {
      attrs.opacity = attrs.width = type;
    }
    return attrs;
  }
  jQuery.each({
    slideDown: genFx('show'),
    slideUp: genFx('hide'),
    slideToggle: genFx('toggle'),
    fadeIn: { opacity: 'show' },
    fadeOut: { opacity: 'hide' },
    fadeToggle: { opacity: 'toggle' }
  }, function (name, props) {
    jQuery.fn[name] = function (speed, easing, callback) {
      return this.animate(props, speed, easing, callback);
    };
  });
  jQuery.speed = function (speed, easing, fn) {
    var opt = speed && typeof speed === 'object' ? jQuery.extend({}, speed) : {
        complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
        duration: speed,
        easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
      };
    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === 'number' ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
    if (opt.queue == null || opt.queue === true) {
      opt.queue = 'fx';
    }
    opt.old = opt.complete;
    opt.complete = function () {
      if (jQuery.isFunction(opt.old)) {
        opt.old.call(this);
      }
      if (opt.queue) {
        jQuery.dequeue(this, opt.queue);
      }
    };
    return opt;
  };
  jQuery.easing = {
    linear: function (p) {
      return p;
    },
    swing: function (p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    }
  };
  jQuery.timers = [];
  jQuery.fx = Tween.prototype.init;
  jQuery.fx.tick = function () {
    var timer, timers = jQuery.timers, i = 0;
    fxNow = jQuery.now();
    for (; i < timers.length; i++) {
      timer = timers[i];
      if (!timer() && timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }
    if (!timers.length) {
      jQuery.fx.stop();
    }
    fxNow = undefined;
  };
  jQuery.fx.timer = function (timer) {
    if (timer() && jQuery.timers.push(timer)) {
      jQuery.fx.start();
    }
  };
  jQuery.fx.interval = 13;
  jQuery.fx.start = function () {
    if (!timerId) {
      timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
    }
  };
  jQuery.fx.stop = function () {
    clearInterval(timerId);
    timerId = null;
  };
  jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    _default: 400
  };
  jQuery.fx.step = {};
  if (jQuery.expr && jQuery.expr.filters) {
    jQuery.expr.filters.animated = function (elem) {
      return jQuery.grep(jQuery.timers, function (fn) {
        return elem === fn.elem;
      }).length;
    };
  }
  jQuery.fn.offset = function (options) {
    if (arguments.length) {
      return options === undefined ? this : this.each(function (i) {
        jQuery.offset.setOffset(this, options, i);
      });
    }
    var docElem, win, elem = this[0], box = {
        top: 0,
        left: 0
      }, doc = elem && elem.ownerDocument;
    if (!doc) {
      return;
    }
    docElem = doc.documentElement;
    if (!jQuery.contains(docElem, elem)) {
      return box;
    }
    if (typeof elem.getBoundingClientRect !== core_strundefined) {
      box = elem.getBoundingClientRect();
    }
    win = getWindow(doc);
    return {
      top: box.top + win.pageYOffset - docElem.clientTop,
      left: box.left + win.pageXOffset - docElem.clientLeft
    };
  };
  jQuery.offset = {
    setOffset: function (elem, options, i) {
      var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, 'position'), curElem = jQuery(elem), props = {};
      if (position === 'static') {
        elem.style.position = 'relative';
      }
      curOffset = curElem.offset();
      curCSSTop = jQuery.css(elem, 'top');
      curCSSLeft = jQuery.css(elem, 'left');
      calculatePosition = (position === 'absolute' || position === 'fixed') && (curCSSTop + curCSSLeft).indexOf('auto') > -1;
      if (calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }
      if (jQuery.isFunction(options)) {
        options = options.call(elem, i, curOffset);
      }
      if (options.top != null) {
        props.top = options.top - curOffset.top + curTop;
      }
      if (options.left != null) {
        props.left = options.left - curOffset.left + curLeft;
      }
      if ('using' in options) {
        options.using.call(elem, props);
      } else {
        curElem.css(props);
      }
    }
  };
  jQuery.fn.extend({
    position: function () {
      if (!this[0]) {
        return;
      }
      var offsetParent, offset, elem = this[0], parentOffset = {
          top: 0,
          left: 0
        };
      if (jQuery.css(elem, 'position') === 'fixed') {
        offset = elem.getBoundingClientRect();
      } else {
        offsetParent = this.offsetParent();
        offset = this.offset();
        if (!jQuery.nodeName(offsetParent[0], 'html')) {
          parentOffset = offsetParent.offset();
        }
        parentOffset.top += jQuery.css(offsetParent[0], 'borderTopWidth', true);
        parentOffset.left += jQuery.css(offsetParent[0], 'borderLeftWidth', true);
      }
      return {
        top: offset.top - parentOffset.top - jQuery.css(elem, 'marginTop', true),
        left: offset.left - parentOffset.left - jQuery.css(elem, 'marginLeft', true)
      };
    },
    offsetParent: function () {
      return this.map(function () {
        var offsetParent = this.offsetParent || docElem;
        while (offsetParent && (!jQuery.nodeName(offsetParent, 'html') && jQuery.css(offsetParent, 'position') === 'static')) {
          offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || docElem;
      });
    }
  });
  jQuery.each({
    scrollLeft: 'pageXOffset',
    scrollTop: 'pageYOffset'
  }, function (method, prop) {
    var top = 'pageYOffset' === prop;
    jQuery.fn[method] = function (val) {
      return jQuery.access(this, function (elem, method, val) {
        var win = getWindow(elem);
        if (val === undefined) {
          return win ? win[prop] : elem[method];
        }
        if (win) {
          win.scrollTo(!top ? val : window.pageXOffset, top ? val : window.pageYOffset);
        } else {
          elem[method] = val;
        }
      }, method, val, arguments.length, null);
    };
  });
  function getWindow(elem) {
    return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
  }
  jQuery.each({
    Height: 'height',
    Width: 'width'
  }, function (name, type) {
    jQuery.each({
      padding: 'inner' + name,
      content: type,
      '': 'outer' + name
    }, function (defaultExtra, funcName) {
      jQuery.fn[funcName] = function (margin, value) {
        var chainable = arguments.length && (defaultExtra || typeof margin !== 'boolean'), extra = defaultExtra || (margin === true || value === true ? 'margin' : 'border');
        return jQuery.access(this, function (elem, type, value) {
          var doc;
          if (jQuery.isWindow(elem)) {
            return elem.document.documentElement['client' + name];
          }
          if (elem.nodeType === 9) {
            doc = elem.documentElement;
            return Math.max(elem.body['scroll' + name], doc['scroll' + name], elem.body['offset' + name], doc['offset' + name], doc['client' + name]);
          }
          return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
        }, type, chainable ? margin : undefined, chainable, null);
      };
    });
  });
  jQuery.fn.size = function () {
    return this.length;
  };
  jQuery.fn.andSelf = jQuery.fn.addBack;
  if (typeof module === 'object' && module && typeof module.exports === 'object') {
    module.exports = jQuery;
  } else {
    if (typeof define === 'function' && define.amd) {
      define('jquery', [], function () {
        return jQuery;
      });
    }
  }
  if (typeof window === 'object' && typeof window.document === 'object') {
    window.jQuery = window.$ = jQuery;
  }
}(window));
var COMPILED = false;
var goog = goog || {};
goog.global = this;
goog.global.CLOSURE_DEFINES;
goog.exportPath_ = function (name, opt_object, opt_objectToExportTo) {
  var parts = name.split('.');
  var cur = opt_objectToExportTo || goog.global;
  if (!(parts[0] in cur) && cur.execScript) {
    cur.execScript('var ' + parts[0]);
  }
  for (var part; parts.length && (part = parts.shift());) {
    if (!parts.length && opt_object !== undefined) {
      cur[part] = opt_object;
    } else if (cur[part]) {
      cur = cur[part];
    } else {
      cur = cur[part] = {};
    }
  }
};
goog.define = function (name, defaultValue) {
  var value = defaultValue;
  if (!COMPILED) {
    if (goog.global.CLOSURE_DEFINES && Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_DEFINES, name)) {
      value = goog.global.CLOSURE_DEFINES[name];
    }
  }
  goog.exportPath_(name, value);
};
goog.DEBUG = true;
goog.define('goog.LOCALE', 'en');
goog.define('goog.TRUSTED_SITE', true);
goog.provide = function (name) {
  if (!COMPILED) {
    if (goog.isProvided_(name)) {
      throw Error('Namespace "' + name + '" already declared.');
    }
    delete goog.implicitNamespaces_[name];
    var namespace = name;
    while (namespace = namespace.substring(0, namespace.lastIndexOf('.'))) {
      if (goog.getObjectByName(namespace)) {
        break;
      }
      goog.implicitNamespaces_[namespace] = true;
    }
  }
  goog.exportPath_(name);
};
goog.setTestOnly = function (opt_message) {
  if (COMPILED && !goog.DEBUG) {
    opt_message = opt_message || '';
    throw Error('Importing test-only code into non-debug environment' + opt_message ? ': ' + opt_message : '.');
  }
};
if (!COMPILED) {
  goog.isProvided_ = function (name) {
    return !goog.implicitNamespaces_[name] && !!goog.getObjectByName(name);
  };
  goog.implicitNamespaces_ = {};
}
goog.getObjectByName = function (name, opt_obj) {
  var parts = name.split('.');
  var cur = opt_obj || goog.global;
  for (var part; part = parts.shift();) {
    if (goog.isDefAndNotNull(cur[part])) {
      cur = cur[part];
    } else {
      return null;
    }
  }
  return cur;
};
goog.globalize = function (obj, opt_global) {
  var global = opt_global || goog.global;
  for (var x in obj) {
    global[x] = obj[x];
  }
};
goog.addDependency = function (relPath, provides, requires) {
  if (goog.DEPENDENCIES_ENABLED) {
    var provide, require;
    var path = relPath.replace(/\\/g, '/');
    var deps = goog.dependencies_;
    for (var i = 0; provide = provides[i]; i++) {
      deps.nameToPath[provide] = path;
      if (!(path in deps.pathToNames)) {
        deps.pathToNames[path] = {};
      }
      deps.pathToNames[path][provide] = true;
    }
    for (var j = 0; require = requires[j]; j++) {
      if (!(path in deps.requires)) {
        deps.requires[path] = {};
      }
      deps.requires[path][require] = true;
    }
  }
};
goog.define('goog.ENABLE_DEBUG_LOADER', true);
goog.require = function (name) {
  if (!COMPILED) {
    if (goog.isProvided_(name)) {
      return;
    }
    if (goog.ENABLE_DEBUG_LOADER) {
      var path = goog.getPathFromDeps_(name);
      if (path) {
        goog.included_[path] = true;
        goog.writeScripts_();
        return;
      }
    }
    var errorMessage = 'goog.require could not find: ' + name;
    if (goog.global.console) {
      goog.global.console['error'](errorMessage);
    }
    throw Error(errorMessage);
  }
};
goog.basePath = '';
goog.global.CLOSURE_BASE_PATH;
goog.global.CLOSURE_NO_DEPS;
goog.global.CLOSURE_IMPORT_SCRIPT;
goog.nullFunction = function () {
};
goog.identityFunction = function (opt_returnValue, var_args) {
  return opt_returnValue;
};
goog.abstractMethod = function () {
  throw Error('unimplemented abstract method');
};
goog.addSingletonGetter = function (ctor) {
  ctor.getInstance = function () {
    if (ctor.instance_) {
      return ctor.instance_;
    }
    if (goog.DEBUG) {
      goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = ctor;
    }
    return ctor.instance_ = new ctor();
  };
};
goog.instantiatedSingletons_ = [];
goog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;
if (goog.DEPENDENCIES_ENABLED) {
  goog.included_ = {};
  goog.dependencies_ = {
    pathToNames: {},
    nameToPath: {},
    requires: {},
    visited: {},
    written: {}
  };
  goog.inHtmlDocument_ = function () {
    var doc = goog.global.document;
    return typeof doc != 'undefined' && 'write' in doc;
  };
  goog.findBasePath_ = function () {
    if (goog.global.CLOSURE_BASE_PATH) {
      goog.basePath = goog.global.CLOSURE_BASE_PATH;
      return;
    } else if (!goog.inHtmlDocument_()) {
      return;
    }
    var doc = goog.global.document;
    var scripts = doc.getElementsByTagName('script');
    for (var i = scripts.length - 1; i >= 0; --i) {
      var src = scripts[i].src;
      var qmark = src.lastIndexOf('?');
      var l = qmark == -1 ? src.length : qmark;
      if (src.substr(l - 7, 7) == 'base.js') {
        goog.basePath = src.substr(0, l - 7);
        return;
      }
    }
  };
  goog.importScript_ = function (src) {
    var importScript = goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_;
    if (!goog.dependencies_.written[src] && importScript(src)) {
      goog.dependencies_.written[src] = true;
    }
  };
  goog.writeScriptTag_ = function (src) {
    if (goog.inHtmlDocument_()) {
      var doc = goog.global.document;
      if (doc.readyState == 'complete') {
        var isDeps = /\bdeps.js$/.test(src);
        if (isDeps) {
          return false;
        } else {
          throw Error('Cannot write "' + src + '" after document load');
        }
      }
      doc.write('<script type="text/javascript" src="' + src + '"></' + 'script>');
      return true;
    } else {
      return false;
    }
  };
  goog.writeScripts_ = function () {
    var scripts = [];
    var seenScript = {};
    var deps = goog.dependencies_;
    function visitNode(path) {
      if (path in deps.written) {
        return;
      }
      if (path in deps.visited) {
        if (!(path in seenScript)) {
          seenScript[path] = true;
          scripts.push(path);
        }
        return;
      }
      deps.visited[path] = true;
      if (path in deps.requires) {
        for (var requireName in deps.requires[path]) {
          if (!goog.isProvided_(requireName)) {
            if (requireName in deps.nameToPath) {
              visitNode(deps.nameToPath[requireName]);
            } else {
              throw Error('Undefined nameToPath for ' + requireName);
            }
          }
        }
      }
      if (!(path in seenScript)) {
        seenScript[path] = true;
        scripts.push(path);
      }
    }
    for (var path in goog.included_) {
      if (!deps.written[path]) {
        visitNode(path);
      }
    }
    for (var i = 0; i < scripts.length; i++) {
      if (scripts[i]) {
        goog.importScript_(goog.basePath + scripts[i]);
      } else {
        throw Error('Undefined script input');
      }
    }
  };
  goog.getPathFromDeps_ = function (rule) {
    if (rule in goog.dependencies_.nameToPath) {
      return goog.dependencies_.nameToPath[rule];
    } else {
      return null;
    }
  };
  goog.findBasePath_();
  if (!goog.global.CLOSURE_NO_DEPS) {
    goog.importScript_(goog.basePath + 'deps.js');
  }
}
goog.typeOf = function (value) {
  var s = typeof value;
  if (s == 'object') {
    if (value) {
      if (value instanceof Array) {
        return 'array';
      } else if (value instanceof Object) {
        return s;
      }
      var className = Object.prototype.toString.call(value);
      if (className == '[object Window]') {
        return 'object';
      }
      if (className == '[object Array]' || typeof value.length == 'number' && typeof value.splice != 'undefined' && typeof value.propertyIsEnumerable != 'undefined' && !value.propertyIsEnumerable('splice')) {
        return 'array';
      }
      if (className == '[object Function]' || typeof value.call != 'undefined' && typeof value.propertyIsEnumerable != 'undefined' && !value.propertyIsEnumerable('call')) {
        return 'function';
      }
    } else {
      return 'null';
    }
  } else if (s == 'function' && typeof value.call == 'undefined') {
    return 'object';
  }
  return s;
};
goog.isDef = function (val) {
  return val !== undefined;
};
goog.isNull = function (val) {
  return val === null;
};
goog.isDefAndNotNull = function (val) {
  return val != null;
};
goog.isArray = function (val) {
  return goog.typeOf(val) == 'array';
};
goog.isArrayLike = function (val) {
  var type = goog.typeOf(val);
  return type == 'array' || type == 'object' && typeof val.length == 'number';
};
goog.isDateLike = function (val) {
  return goog.isObject(val) && typeof val.getFullYear == 'function';
};
goog.isString = function (val) {
  return typeof val == 'string';
};
goog.isBoolean = function (val) {
  return typeof val == 'boolean';
};
goog.isNumber = function (val) {
  return typeof val == 'number';
};
goog.isFunction = function (val) {
  return goog.typeOf(val) == 'function';
};
goog.isObject = function (val) {
  var type = typeof val;
  return type == 'object' && val != null || type == 'function';
};
goog.getUid = function (obj) {
  return obj[goog.UID_PROPERTY_] || (obj[goog.UID_PROPERTY_] = ++goog.uidCounter_);
};
goog.removeUid = function (obj) {
  if ('removeAttribute' in obj) {
    obj.removeAttribute(goog.UID_PROPERTY_);
  }
  try {
    delete obj[goog.UID_PROPERTY_];
  } catch (ex) {
  }
};
goog.UID_PROPERTY_ = 'closure_uid_' + (Math.random() * 1000000000 >>> 0);
goog.uidCounter_ = 0;
goog.getHashCode = goog.getUid;
goog.removeHashCode = goog.removeUid;
goog.cloneObject = function (obj) {
  var type = goog.typeOf(obj);
  if (type == 'object' || type == 'array') {
    if (obj.clone) {
      return obj.clone();
    }
    var clone = type == 'array' ? [] : {};
    for (var key in obj) {
      clone[key] = goog.cloneObject(obj[key]);
    }
    return clone;
  }
  return obj;
};
goog.bindNative_ = function (fn, selfObj, var_args) {
  return fn.call.apply(fn.bind, arguments);
};
goog.bindJs_ = function (fn, selfObj, var_args) {
  if (!fn) {
    throw new Error();
  }
  if (arguments.length > 2) {
    var boundArgs = Array.prototype.slice.call(arguments, 2);
    return function () {
      var newArgs = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(newArgs, boundArgs);
      return fn.apply(selfObj, newArgs);
    };
  } else {
    return function () {
      return fn.apply(selfObj, arguments);
    };
  }
};
goog.bind = function (fn, selfObj, var_args) {
  if (Function.prototype.bind && Function.prototype.bind.toString().indexOf('native code') != -1) {
    goog.bind = goog.bindNative_;
  } else {
    goog.bind = goog.bindJs_;
  }
  return goog.bind.apply(null, arguments);
};
goog.partial = function (fn, var_args) {
  var args = Array.prototype.slice.call(arguments, 1);
  return function () {
    var newArgs = Array.prototype.slice.call(arguments);
    newArgs.unshift.apply(newArgs, args);
    return fn.apply(this, newArgs);
  };
};
goog.mixin = function (target, source) {
  for (var x in source) {
    target[x] = source[x];
  }
};
goog.now = goog.TRUSTED_SITE && Date.now || function () {
  return +new Date();
};
goog.globalEval = function (script) {
  if (goog.global.execScript) {
    goog.global.execScript(script, 'JavaScript');
  } else if (goog.global.eval) {
    if (goog.evalWorksForGlobals_ == null) {
      goog.global.eval('var _et_ = 1;');
      if (typeof goog.global['_et_'] != 'undefined') {
        delete goog.global['_et_'];
        goog.evalWorksForGlobals_ = true;
      } else {
        goog.evalWorksForGlobals_ = false;
      }
    }
    if (goog.evalWorksForGlobals_) {
      goog.global.eval(script);
    } else {
      var doc = goog.global.document;
      var scriptElt = doc.createElement('script');
      scriptElt.type = 'text/javascript';
      scriptElt.defer = false;
      scriptElt.appendChild(doc.createTextNode(script));
      doc.body.appendChild(scriptElt);
      doc.body.removeChild(scriptElt);
    }
  } else {
    throw Error('goog.globalEval not available');
  }
};
goog.evalWorksForGlobals_ = null;
goog.cssNameMapping_;
goog.cssNameMappingStyle_;
goog.getCssName = function (className, opt_modifier) {
  var getMapping = function (cssName) {
    return goog.cssNameMapping_[cssName] || cssName;
  };
  var renameByParts = function (cssName) {
    var parts = cssName.split('-');
    var mapped = [];
    for (var i = 0; i < parts.length; i++) {
      mapped.push(getMapping(parts[i]));
    }
    return mapped.join('-');
  };
  var rename;
  if (goog.cssNameMapping_) {
    rename = goog.cssNameMappingStyle_ == 'BY_WHOLE' ? getMapping : renameByParts;
  } else {
    rename = function (a) {
      return a;
    };
  }
  if (opt_modifier) {
    return className + '-' + rename(opt_modifier);
  } else {
    return rename(className);
  }
};
goog.setCssNameMapping = function (mapping, opt_style) {
  goog.cssNameMapping_ = mapping;
  goog.cssNameMappingStyle_ = opt_style;
};
goog.global.CLOSURE_CSS_NAME_MAPPING;
if (!COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING) {
  goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING;
}
goog.getMsg = function (str, opt_values) {
  var values = opt_values || {};
  for (var key in values) {
    var value = ('' + values[key]).replace(/\$/g, '$$$$');
    str = str.replace(new RegExp('\\{\\$' + key + '\\}', 'gi'), value);
  }
  return str;
};
goog.getMsgWithFallback = function (a, b) {
  return a;
};
goog.exportSymbol = function (publicPath, object, opt_objectToExportTo) {
  goog.exportPath_(publicPath, object, opt_objectToExportTo);
};
goog.exportProperty = function (object, publicName, symbol) {
  object[publicName] = symbol;
};
goog.inherits = function (childCtor, parentCtor) {
  function tempCtor() {
  }
  ;
  tempCtor.prototype = parentCtor.prototype;
  childCtor.superClass_ = parentCtor.prototype;
  childCtor.prototype = new tempCtor();
  childCtor.prototype.constructor = childCtor;
};
goog.base = function (me, opt_methodName, var_args) {
  var caller = arguments.callee.caller;
  if (goog.DEBUG) {
    if (!caller) {
      throw Error('arguments.caller not defined.  goog.base() expects not ' + 'to be running in strict mode. See ' + 'http://www.ecma-international.org/ecma-262/5.1/#sec-C');
    }
  }
  if (caller.superClass_) {
    return caller.superClass_.constructor.apply(me, Array.prototype.slice.call(arguments, 1));
  }
  var args = Array.prototype.slice.call(arguments, 2);
  var foundCaller = false;
  for (var ctor = me.constructor; ctor; ctor = ctor.superClass_ && ctor.superClass_.constructor) {
    if (ctor.prototype[opt_methodName] === caller) {
      foundCaller = true;
    } else if (foundCaller) {
      return ctor.prototype[opt_methodName].apply(me, args);
    }
  }
  if (me[opt_methodName] === caller) {
    return me.constructor.prototype[opt_methodName].apply(me, args);
  } else {
    throw Error('goog.base called from a method of one name ' + 'to a method of a different name');
  }
};
goog.scope = function (fn) {
  fn.call(goog.global);
};
goog.addDependency('../../third_party/closure/goog/caja/string/html/htmlparser.js', [
  'goog.string.html.HtmlParser',
  'goog.string.html.HtmlParser.EFlags',
  'goog.string.html.HtmlParser.Elements',
  'goog.string.html.HtmlParser.Entities',
  'goog.string.html.HtmlSaxHandler'
], []);
goog.addDependency('../../third_party/closure/goog/caja/string/html/htmlsanitizer.js', [
  'goog.string.html.HtmlSanitizer',
  'goog.string.html.HtmlSanitizer.AttributeType',
  'goog.string.html.HtmlSanitizer.Attributes',
  'goog.string.html.htmlSanitize'
], [
  'goog.string.StringBuffer',
  'goog.string.html.HtmlParser',
  'goog.string.html.HtmlParser.EFlags',
  'goog.string.html.HtmlParser.Elements',
  'goog.string.html.HtmlSaxHandler'
]);
goog.addDependency('../../third_party/closure/goog/dojo/dom/query.js', ['goog.dom.query'], [
  'goog.array',
  'goog.dom',
  'goog.functions',
  'goog.string',
  'goog.userAgent'
]);
goog.addDependency('../../third_party/closure/goog/jpeg_encoder/jpeg_encoder_basic.js', ['goog.crypt.JpegEncoder'], ['goog.crypt.base64']);
goog.addDependency('../../third_party/closure/goog/loremipsum/text/loremipsum.js', ['goog.text.LoremIpsum'], [
  'goog.array',
  'goog.math',
  'goog.string',
  'goog.structs.Map',
  'goog.structs.Set'
]);
goog.addDependency('../../third_party/closure/goog/mochikit/async/deferred.js', [
  'goog.async.Deferred',
  'goog.async.Deferred.AlreadyCalledError',
  'goog.async.Deferred.CanceledError'
], [
  'goog.array',
  'goog.asserts',
  'goog.debug.Error',
  'goog.functions'
]);
goog.addDependency('../../third_party/closure/goog/mochikit/async/deferredlist.js', ['goog.async.DeferredList'], ['goog.async.Deferred']);
goog.addDependency('../../third_party/closure/goog/osapi/osapi.js', ['goog.osapi'], []);
goog.addDependency('a11y/aria/announcer.js', ['goog.a11y.aria.Announcer'], [
  'goog.Disposable',
  'goog.a11y.aria',
  'goog.a11y.aria.LivePriority',
  'goog.a11y.aria.State',
  'goog.dom',
  'goog.object'
]);
goog.addDependency('a11y/aria/aria.js', ['goog.a11y.aria'], [
  'goog.a11y.aria.Role',
  'goog.a11y.aria.State',
  'goog.a11y.aria.datatables',
  'goog.array',
  'goog.asserts',
  'goog.dom',
  'goog.dom.TagName',
  'goog.object',
  'goog.string'
]);
goog.addDependency('a11y/aria/attributes.js', [
  'goog.a11y.aria.AutoCompleteValues',
  'goog.a11y.aria.CheckedValues',
  'goog.a11y.aria.DropEffectValues',
  'goog.a11y.aria.ExpandedValues',
  'goog.a11y.aria.GrabbedValues',
  'goog.a11y.aria.InvalidValues',
  'goog.a11y.aria.LivePriority',
  'goog.a11y.aria.OrientationValues',
  'goog.a11y.aria.PressedValues',
  'goog.a11y.aria.RelevantValues',
  'goog.a11y.aria.SelectedValues',
  'goog.a11y.aria.SortValues',
  'goog.a11y.aria.State'
], []);
goog.addDependency('a11y/aria/datatables.js', ['goog.a11y.aria.datatables'], [
  'goog.a11y.aria.State',
  'goog.object'
]);
goog.addDependency('a11y/aria/roles.js', ['goog.a11y.aria.Role'], []);
goog.addDependency('array/array.js', [
  'goog.array',
  'goog.array.ArrayLike'
], ['goog.asserts']);
goog.addDependency('asserts/asserts.js', [
  'goog.asserts',
  'goog.asserts.AssertionError'
], [
  'goog.debug.Error',
  'goog.string'
]);
goog.addDependency('async/animationdelay.js', ['goog.async.AnimationDelay'], [
  'goog.Disposable',
  'goog.events',
  'goog.functions'
]);
goog.addDependency('async/conditionaldelay.js', ['goog.async.ConditionalDelay'], [
  'goog.Disposable',
  'goog.async.Delay'
]);
goog.addDependency('async/delay.js', [
  'goog.Delay',
  'goog.async.Delay'
], [
  'goog.Disposable',
  'goog.Timer'
]);
goog.addDependency('async/nexttick.js', ['goog.async.nextTick'], [
  'goog.debug.entryPointRegistry',
  'goog.functions'
]);
goog.addDependency('async/throttle.js', [
  'goog.Throttle',
  'goog.async.Throttle'
], [
  'goog.Disposable',
  'goog.Timer'
]);
goog.addDependency('base.js', ['goog'], []);
goog.addDependency('color/alpha.js', ['goog.color.alpha'], ['goog.color']);
goog.addDependency('color/color.js', ['goog.color'], [
  'goog.color.names',
  'goog.math'
]);
goog.addDependency('color/names.js', ['goog.color.names'], []);
goog.addDependency('crypt/aes.js', ['goog.crypt.Aes'], [
  'goog.asserts',
  'goog.crypt.BlockCipher'
]);
goog.addDependency('crypt/arc4.js', ['goog.crypt.Arc4'], ['goog.asserts']);
goog.addDependency('crypt/base64.js', ['goog.crypt.base64'], [
  'goog.crypt',
  'goog.userAgent'
]);
goog.addDependency('crypt/basen.js', ['goog.crypt.baseN'], []);
goog.addDependency('crypt/blobhasher.js', [
  'goog.crypt.BlobHasher',
  'goog.crypt.BlobHasher.EventType'
], [
  'goog.asserts',
  'goog.crypt',
  'goog.crypt.Hash',
  'goog.events.EventTarget',
  'goog.fs',
  'goog.log'
]);
goog.addDependency('crypt/blockcipher.js', ['goog.crypt.BlockCipher'], []);
goog.addDependency('crypt/cbc.js', ['goog.crypt.Cbc'], [
  'goog.array',
  'goog.crypt'
]);
goog.addDependency('crypt/cbc_test.js', ['goog.crypt.CbcTest'], [
  'goog.crypt',
  'goog.crypt.Aes',
  'goog.crypt.Cbc',
  'goog.testing.jsunit'
]);
goog.addDependency('crypt/crypt.js', ['goog.crypt'], ['goog.array']);
goog.addDependency('crypt/hash.js', ['goog.crypt.Hash'], []);
goog.addDependency('crypt/hash32.js', ['goog.crypt.hash32'], ['goog.crypt']);
goog.addDependency('crypt/hashtester.js', ['goog.crypt.hashTester'], [
  'goog.array',
  'goog.crypt',
  'goog.testing.PerformanceTable',
  'goog.testing.PseudoRandom',
  'goog.testing.asserts'
]);
goog.addDependency('crypt/hmac.js', ['goog.crypt.Hmac'], [
  'goog.asserts',
  'goog.crypt.Hash'
]);
goog.addDependency('crypt/md5.js', ['goog.crypt.Md5'], ['goog.crypt.Hash']);
goog.addDependency('crypt/pbkdf2.js', ['goog.crypt.pbkdf2'], [
  'goog.asserts',
  'goog.crypt',
  'goog.crypt.Hmac',
  'goog.crypt.Sha1'
]);
goog.addDependency('crypt/sha1.js', ['goog.crypt.Sha1'], ['goog.crypt.Hash']);
goog.addDependency('crypt/sha2.js', ['goog.crypt.Sha2'], [
  'goog.array',
  'goog.asserts',
  'goog.crypt.Hash'
]);
goog.addDependency('crypt/sha224.js', ['goog.crypt.Sha224'], ['goog.crypt.Sha2']);
goog.addDependency('crypt/sha256.js', ['goog.crypt.Sha256'], ['goog.crypt.Sha2']);
goog.addDependency('cssom/cssom.js', [
  'goog.cssom',
  'goog.cssom.CssRuleType'
], [
  'goog.array',
  'goog.dom'
]);
goog.addDependency('cssom/iframe/style.js', ['goog.cssom.iframe.style'], [
  'goog.cssom',
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.TagName',
  'goog.dom.classes',
  'goog.string',
  'goog.style',
  'goog.userAgent'
]);
goog.addDependency('datasource/datamanager.js', ['goog.ds.DataManager'], [
  'goog.ds.BasicNodeList',
  'goog.ds.DataNode',
  'goog.ds.Expr',
  'goog.string',
  'goog.structs',
  'goog.structs.Map'
]);
goog.addDependency('datasource/datasource.js', [
  'goog.ds.BaseDataNode',
  'goog.ds.BasicNodeList',
  'goog.ds.DataNode',
  'goog.ds.DataNodeList',
  'goog.ds.EmptyNodeList',
  'goog.ds.LoadState',
  'goog.ds.SortedNodeList',
  'goog.ds.Util',
  'goog.ds.logger'
], [
  'goog.array',
  'goog.log'
]);
goog.addDependency('datasource/expr.js', ['goog.ds.Expr'], [
  'goog.ds.BasicNodeList',
  'goog.ds.EmptyNodeList',
  'goog.string'
]);
goog.addDependency('datasource/fastdatanode.js', [
  'goog.ds.AbstractFastDataNode',
  'goog.ds.FastDataNode',
  'goog.ds.FastListNode',
  'goog.ds.PrimitiveFastDataNode'
], [
  'goog.ds.DataManager',
  'goog.ds.EmptyNodeList',
  'goog.string'
]);
goog.addDependency('datasource/jsdatasource.js', [
  'goog.ds.JsDataSource',
  'goog.ds.JsPropertyDataSource'
], [
  'goog.ds.BaseDataNode',
  'goog.ds.BasicNodeList',
  'goog.ds.DataManager',
  'goog.ds.EmptyNodeList',
  'goog.ds.LoadState'
]);
goog.addDependency('datasource/jsondatasource.js', ['goog.ds.JsonDataSource'], [
  'goog.Uri',
  'goog.dom',
  'goog.ds.DataManager',
  'goog.ds.JsDataSource',
  'goog.ds.LoadState',
  'goog.ds.logger'
]);
goog.addDependency('datasource/jsxmlhttpdatasource.js', ['goog.ds.JsXmlHttpDataSource'], [
  'goog.Uri',
  'goog.ds.DataManager',
  'goog.ds.FastDataNode',
  'goog.ds.LoadState',
  'goog.ds.logger',
  'goog.events',
  'goog.log',
  'goog.net.EventType',
  'goog.net.XhrIo'
]);
goog.addDependency('datasource/xmldatasource.js', [
  'goog.ds.XmlDataSource',
  'goog.ds.XmlHttpDataSource'
], [
  'goog.Uri',
  'goog.dom.NodeType',
  'goog.dom.xml',
  'goog.ds.BasicNodeList',
  'goog.ds.DataManager',
  'goog.ds.LoadState',
  'goog.ds.logger',
  'goog.net.XhrIo',
  'goog.string'
]);
goog.addDependency('date/date.js', [
  'goog.date',
  'goog.date.Date',
  'goog.date.DateTime',
  'goog.date.Interval',
  'goog.date.month',
  'goog.date.weekDay'
], [
  'goog.asserts',
  'goog.date.DateLike',
  'goog.i18n.DateTimeSymbols',
  'goog.string'
]);
goog.addDependency('date/datelike.js', ['goog.date.DateLike'], []);
goog.addDependency('date/daterange.js', [
  'goog.date.DateRange',
  'goog.date.DateRange.Iterator',
  'goog.date.DateRange.StandardDateRangeKeys'
], [
  'goog.date.Date',
  'goog.date.Interval',
  'goog.iter.Iterator',
  'goog.iter.StopIteration'
]);
goog.addDependency('date/relative.js', ['goog.date.relative'], ['goog.i18n.DateTimeFormat']);
goog.addDependency('date/utcdatetime.js', ['goog.date.UtcDateTime'], [
  'goog.date',
  'goog.date.Date',
  'goog.date.DateTime',
  'goog.date.Interval'
]);
goog.addDependency('db/cursor.js', ['goog.db.Cursor'], [
  'goog.async.Deferred',
  'goog.db.Error',
  'goog.debug',
  'goog.events.EventTarget'
]);
goog.addDependency('db/db.js', ['goog.db'], [
  'goog.async.Deferred',
  'goog.db.Error',
  'goog.db.IndexedDb',
  'goog.db.Transaction'
]);
goog.addDependency('db/error.js', [
  'goog.db.Error',
  'goog.db.Error.ErrorCode',
  'goog.db.Error.ErrorName',
  'goog.db.Error.VersionChangeBlockedError'
], ['goog.debug.Error']);
goog.addDependency('db/index.js', ['goog.db.Index'], [
  'goog.async.Deferred',
  'goog.db.Cursor',
  'goog.db.Error',
  'goog.debug'
]);
goog.addDependency('db/indexeddb.js', ['goog.db.IndexedDb'], [
  'goog.async.Deferred',
  'goog.db.Error',
  'goog.db.Error.VersionChangeBlockedError',
  'goog.db.ObjectStore',
  'goog.db.Transaction',
  'goog.db.Transaction.TransactionMode',
  'goog.events.Event',
  'goog.events.EventHandler',
  'goog.events.EventTarget'
]);
goog.addDependency('db/keyrange.js', ['goog.db.KeyRange'], []);
goog.addDependency('db/objectstore.js', ['goog.db.ObjectStore'], [
  'goog.async.Deferred',
  'goog.db.Cursor',
  'goog.db.Error',
  'goog.db.Index',
  'goog.debug',
  'goog.events'
]);
goog.addDependency('db/transaction.js', [
  'goog.db.Transaction',
  'goog.db.Transaction.TransactionMode'
], [
  'goog.async.Deferred',
  'goog.db.Error',
  'goog.db.ObjectStore',
  'goog.events.EventHandler',
  'goog.events.EventTarget'
]);
goog.addDependency('debug/console.js', ['goog.debug.Console'], [
  'goog.debug.LogManager',
  'goog.debug.Logger.Level',
  'goog.debug.TextFormatter'
]);
goog.addDependency('debug/debug.js', ['goog.debug'], [
  'goog.array',
  'goog.string',
  'goog.structs.Set',
  'goog.userAgent'
]);
goog.addDependency('debug/debugwindow.js', ['goog.debug.DebugWindow'], [
  'goog.debug.HtmlFormatter',
  'goog.debug.LogManager',
  'goog.debug.Logger',
  'goog.structs.CircularBuffer',
  'goog.userAgent'
]);
goog.addDependency('debug/devcss/devcss.js', [
  'goog.debug.DevCss',
  'goog.debug.DevCss.UserAgent'
], [
  'goog.cssom',
  'goog.dom.classes',
  'goog.events',
  'goog.events.EventType',
  'goog.string',
  'goog.userAgent'
]);
goog.addDependency('debug/devcss/devcssrunner.js', ['goog.debug.devCssRunner'], ['goog.debug.DevCss']);
goog.addDependency('debug/divconsole.js', ['goog.debug.DivConsole'], [
  'goog.debug.HtmlFormatter',
  'goog.debug.LogManager',
  'goog.style'
]);
goog.addDependency('debug/entrypointregistry.js', [
  'goog.debug.EntryPointMonitor',
  'goog.debug.entryPointRegistry'
], ['goog.asserts']);
goog.addDependency('debug/error.js', ['goog.debug.Error'], []);
goog.addDependency('debug/errorhandler.js', [
  'goog.debug.ErrorHandler',
  'goog.debug.ErrorHandler.ProtectedFunctionError'
], [
  'goog.asserts',
  'goog.debug',
  'goog.debug.EntryPointMonitor',
  'goog.debug.Trace'
]);
goog.addDependency('debug/errorhandlerweakdep.js', ['goog.debug.errorHandlerWeakDep'], []);
goog.addDependency('debug/errorreporter.js', [
  'goog.debug.ErrorReporter',
  'goog.debug.ErrorReporter.ExceptionEvent'
], [
  'goog.asserts',
  'goog.debug',
  'goog.debug.ErrorHandler',
  'goog.debug.entryPointRegistry',
  'goog.events',
  'goog.events.Event',
  'goog.events.EventTarget',
  'goog.log',
  'goog.net.XhrIo',
  'goog.object',
  'goog.string',
  'goog.uri.utils',
  'goog.userAgent'
]);
goog.addDependency('debug/fancywindow.js', ['goog.debug.FancyWindow'], [
  'goog.debug.DebugWindow',
  'goog.debug.LogManager',
  'goog.debug.Logger',
  'goog.dom.DomHelper',
  'goog.object',
  'goog.string',
  'goog.userAgent'
]);
goog.addDependency('debug/formatter.js', [
  'goog.debug.Formatter',
  'goog.debug.HtmlFormatter',
  'goog.debug.TextFormatter'
], [
  'goog.debug.RelativeTimeProvider',
  'goog.string'
]);
goog.addDependency('debug/fpsdisplay.js', ['goog.debug.FpsDisplay'], [
  'goog.asserts',
  'goog.async.AnimationDelay',
  'goog.ui.Component'
]);
goog.addDependency('debug/gcdiagnostics.js', ['goog.debug.GcDiagnostics'], [
  'goog.debug.Trace',
  'goog.log',
  'goog.userAgent'
]);
goog.addDependency('debug/logbuffer.js', ['goog.debug.LogBuffer'], [
  'goog.asserts',
  'goog.debug.LogRecord'
]);
goog.addDependency('debug/logger.js', [
  'goog.debug.LogManager',
  'goog.debug.Logger',
  'goog.debug.Logger.Level'
], [
  'goog.array',
  'goog.asserts',
  'goog.debug',
  'goog.debug.LogBuffer',
  'goog.debug.LogRecord'
]);
goog.addDependency('debug/logrecord.js', ['goog.debug.LogRecord'], []);
goog.addDependency('debug/logrecordserializer.js', ['goog.debug.logRecordSerializer'], [
  'goog.debug.LogRecord',
  'goog.debug.Logger.Level',
  'goog.json',
  'goog.object'
]);
goog.addDependency('debug/reflect.js', ['goog.debug.reflect'], []);
goog.addDependency('debug/relativetimeprovider.js', ['goog.debug.RelativeTimeProvider'], []);
goog.addDependency('debug/tracer.js', ['goog.debug.Trace'], [
  'goog.array',
  'goog.iter',
  'goog.log',
  'goog.structs.Map',
  'goog.structs.SimplePool'
]);
goog.addDependency('disposable/disposable.js', [
  'goog.Disposable',
  'goog.dispose'
], ['goog.disposable.IDisposable']);
goog.addDependency('disposable/idisposable.js', ['goog.disposable.IDisposable'], []);
goog.addDependency('dom/a11y.js', [
  'goog.dom.a11y',
  'goog.dom.a11y.Announcer',
  'goog.dom.a11y.LivePriority',
  'goog.dom.a11y.Role',
  'goog.dom.a11y.State'
], [
  'goog.a11y.aria',
  'goog.a11y.aria.Announcer',
  'goog.a11y.aria.LivePriority',
  'goog.a11y.aria.Role',
  'goog.a11y.aria.State'
]);
goog.addDependency('dom/abstractmultirange.js', ['goog.dom.AbstractMultiRange'], [
  'goog.array',
  'goog.dom',
  'goog.dom.AbstractRange'
]);
goog.addDependency('dom/abstractrange.js', [
  'goog.dom.AbstractRange',
  'goog.dom.RangeIterator',
  'goog.dom.RangeType'
], [
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.SavedCaretRange',
  'goog.dom.TagIterator',
  'goog.userAgent'
]);
goog.addDependency('dom/annotate.js', ['goog.dom.annotate'], [
  'goog.array',
  'goog.dom',
  'goog.dom.NodeType',
  'goog.string'
]);
goog.addDependency('dom/browserfeature.js', ['goog.dom.BrowserFeature'], ['goog.userAgent']);
goog.addDependency('dom/browserrange/abstractrange.js', ['goog.dom.browserrange.AbstractRange'], [
  'goog.array',
  'goog.asserts',
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.RangeEndpoint',
  'goog.dom.TagName',
  'goog.dom.TextRangeIterator',
  'goog.iter',
  'goog.math.Coordinate',
  'goog.string',
  'goog.string.StringBuffer',
  'goog.userAgent'
]);
goog.addDependency('dom/browserrange/browserrange.js', [
  'goog.dom.browserrange',
  'goog.dom.browserrange.Error'
], [
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.browserrange.GeckoRange',
  'goog.dom.browserrange.IeRange',
  'goog.dom.browserrange.OperaRange',
  'goog.dom.browserrange.W3cRange',
  'goog.dom.browserrange.WebKitRange',
  'goog.userAgent'
]);
goog.addDependency('dom/browserrange/geckorange.js', ['goog.dom.browserrange.GeckoRange'], ['goog.dom.browserrange.W3cRange']);
goog.addDependency('dom/browserrange/ierange.js', ['goog.dom.browserrange.IeRange'], [
  'goog.array',
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.RangeEndpoint',
  'goog.dom.TagName',
  'goog.dom.browserrange.AbstractRange',
  'goog.log',
  'goog.string'
]);
goog.addDependency('dom/browserrange/operarange.js', ['goog.dom.browserrange.OperaRange'], ['goog.dom.browserrange.W3cRange']);
goog.addDependency('dom/browserrange/w3crange.js', ['goog.dom.browserrange.W3cRange'], [
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.RangeEndpoint',
  'goog.dom.browserrange.AbstractRange',
  'goog.string'
]);
goog.addDependency('dom/browserrange/webkitrange.js', ['goog.dom.browserrange.WebKitRange'], [
  'goog.dom.RangeEndpoint',
  'goog.dom.browserrange.W3cRange',
  'goog.userAgent'
]);
goog.addDependency('dom/bufferedviewportsizemonitor.js', ['goog.dom.BufferedViewportSizeMonitor'], [
  'goog.asserts',
  'goog.async.Delay',
  'goog.events',
  'goog.events.EventTarget',
  'goog.events.EventType'
]);
goog.addDependency('dom/bufferedviewportsizemonitor_test.js', ['goog.dom.BufferedViewportSizeMonitorTest'], [
  'goog.dom.BufferedViewportSizeMonitor',
  'goog.dom.ViewportSizeMonitor',
  'goog.events',
  'goog.events.EventType',
  'goog.math.Size',
  'goog.testing.MockClock',
  'goog.testing.events',
  'goog.testing.events.Event',
  'goog.testing.jsunit'
]);
goog.addDependency('dom/classes.js', ['goog.dom.classes'], ['goog.array']);
goog.addDependency('dom/classes_test.js', ['goog.dom.classes_test'], [
  'goog.dom',
  'goog.dom.classes',
  'goog.testing.jsunit'
]);
goog.addDependency('dom/classlist.js', ['goog.dom.classlist'], [
  'goog.array',
  'goog.asserts'
]);
goog.addDependency('dom/classlist_test.js', ['goog.dom.classlist_test'], [
  'goog.dom',
  'goog.dom.classlist',
  'goog.testing.jsunit'
]);
goog.addDependency('dom/controlrange.js', [
  'goog.dom.ControlRange',
  'goog.dom.ControlRangeIterator'
], [
  'goog.array',
  'goog.dom',
  'goog.dom.AbstractMultiRange',
  'goog.dom.AbstractRange',
  'goog.dom.RangeIterator',
  'goog.dom.RangeType',
  'goog.dom.SavedRange',
  'goog.dom.TagWalkType',
  'goog.dom.TextRange',
  'goog.iter.StopIteration',
  'goog.userAgent'
]);
goog.addDependency('dom/dataset.js', ['goog.dom.dataset'], ['goog.string']);
goog.addDependency('dom/dom.js', [
  'goog.dom',
  'goog.dom.Appendable',
  'goog.dom.DomHelper',
  'goog.dom.NodeType'
], [
  'goog.array',
  'goog.dom.BrowserFeature',
  'goog.dom.TagName',
  'goog.dom.classes',
  'goog.math.Coordinate',
  'goog.math.Size',
  'goog.object',
  'goog.string',
  'goog.userAgent'
]);
goog.addDependency('dom/dom_test.js', ['goog.dom.dom_test'], [
  'goog.dom',
  'goog.dom.BrowserFeature',
  'goog.dom.DomHelper',
  'goog.dom.NodeType',
  'goog.dom.TagName',
  'goog.object',
  'goog.string.Unicode',
  'goog.testing.asserts',
  'goog.userAgent',
  'goog.userAgent.product',
  'goog.userAgent.product.isVersion'
]);
goog.addDependency('dom/fontsizemonitor.js', [
  'goog.dom.FontSizeMonitor',
  'goog.dom.FontSizeMonitor.EventType'
], [
  'goog.dom',
  'goog.events',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.userAgent'
]);
goog.addDependency('dom/forms.js', ['goog.dom.forms'], ['goog.structs.Map']);
goog.addDependency('dom/fullscreen.js', [
  'goog.dom.fullscreen',
  'goog.dom.fullscreen.EventType'
], [
  'goog.dom',
  'goog.userAgent',
  'goog.userAgent.product'
]);
goog.addDependency('dom/iframe.js', ['goog.dom.iframe'], [
  'goog.dom',
  'goog.userAgent'
]);
goog.addDependency('dom/iter.js', [
  'goog.dom.iter.AncestorIterator',
  'goog.dom.iter.ChildIterator',
  'goog.dom.iter.SiblingIterator'
], [
  'goog.iter.Iterator',
  'goog.iter.StopIteration'
]);
goog.addDependency('dom/multirange.js', [
  'goog.dom.MultiRange',
  'goog.dom.MultiRangeIterator'
], [
  'goog.array',
  'goog.dom.AbstractMultiRange',
  'goog.dom.AbstractRange',
  'goog.dom.RangeIterator',
  'goog.dom.RangeType',
  'goog.dom.SavedRange',
  'goog.dom.TextRange',
  'goog.iter.StopIteration',
  'goog.log'
]);
goog.addDependency('dom/nodeiterator.js', ['goog.dom.NodeIterator'], ['goog.dom.TagIterator']);
goog.addDependency('dom/nodeoffset.js', ['goog.dom.NodeOffset'], [
  'goog.Disposable',
  'goog.dom.TagName'
]);
goog.addDependency('dom/pattern/abstractpattern.js', ['goog.dom.pattern.AbstractPattern'], ['goog.dom.pattern.MatchType']);
goog.addDependency('dom/pattern/allchildren.js', ['goog.dom.pattern.AllChildren'], [
  'goog.dom.pattern.AbstractPattern',
  'goog.dom.pattern.MatchType'
]);
goog.addDependency('dom/pattern/callback/callback.js', ['goog.dom.pattern.callback'], [
  'goog.dom',
  'goog.dom.TagWalkType',
  'goog.iter'
]);
goog.addDependency('dom/pattern/callback/counter.js', ['goog.dom.pattern.callback.Counter'], []);
goog.addDependency('dom/pattern/callback/test.js', ['goog.dom.pattern.callback.Test'], ['goog.iter.StopIteration']);
goog.addDependency('dom/pattern/childmatches.js', ['goog.dom.pattern.ChildMatches'], [
  'goog.dom.pattern.AllChildren',
  'goog.dom.pattern.MatchType'
]);
goog.addDependency('dom/pattern/endtag.js', ['goog.dom.pattern.EndTag'], [
  'goog.dom.TagWalkType',
  'goog.dom.pattern.Tag'
]);
goog.addDependency('dom/pattern/fulltag.js', ['goog.dom.pattern.FullTag'], [
  'goog.dom.pattern.MatchType',
  'goog.dom.pattern.StartTag',
  'goog.dom.pattern.Tag'
]);
goog.addDependency('dom/pattern/matcher.js', ['goog.dom.pattern.Matcher'], [
  'goog.dom.TagIterator',
  'goog.dom.pattern.MatchType',
  'goog.iter'
]);
goog.addDependency('dom/pattern/nodetype.js', ['goog.dom.pattern.NodeType'], [
  'goog.dom.pattern.AbstractPattern',
  'goog.dom.pattern.MatchType'
]);
goog.addDependency('dom/pattern/pattern.js', [
  'goog.dom.pattern',
  'goog.dom.pattern.MatchType'
], []);
goog.addDependency('dom/pattern/repeat.js', ['goog.dom.pattern.Repeat'], [
  'goog.dom.NodeType',
  'goog.dom.pattern.AbstractPattern',
  'goog.dom.pattern.MatchType'
]);
goog.addDependency('dom/pattern/sequence.js', ['goog.dom.pattern.Sequence'], [
  'goog.dom.NodeType',
  'goog.dom.pattern.AbstractPattern',
  'goog.dom.pattern.MatchType'
]);
goog.addDependency('dom/pattern/starttag.js', ['goog.dom.pattern.StartTag'], [
  'goog.dom.TagWalkType',
  'goog.dom.pattern.Tag'
]);
goog.addDependency('dom/pattern/tag.js', ['goog.dom.pattern.Tag'], [
  'goog.dom.pattern',
  'goog.dom.pattern.AbstractPattern',
  'goog.dom.pattern.MatchType',
  'goog.object'
]);
goog.addDependency('dom/pattern/text.js', ['goog.dom.pattern.Text'], [
  'goog.dom.NodeType',
  'goog.dom.pattern',
  'goog.dom.pattern.AbstractPattern',
  'goog.dom.pattern.MatchType'
]);
goog.addDependency('dom/range.js', ['goog.dom.Range'], [
  'goog.dom',
  'goog.dom.AbstractRange',
  'goog.dom.ControlRange',
  'goog.dom.MultiRange',
  'goog.dom.NodeType',
  'goog.dom.TextRange',
  'goog.userAgent'
]);
goog.addDependency('dom/rangeendpoint.js', ['goog.dom.RangeEndpoint'], []);
goog.addDependency('dom/savedcaretrange.js', ['goog.dom.SavedCaretRange'], [
  'goog.array',
  'goog.dom',
  'goog.dom.SavedRange',
  'goog.dom.TagName',
  'goog.string'
]);
goog.addDependency('dom/savedrange.js', ['goog.dom.SavedRange'], [
  'goog.Disposable',
  'goog.log'
]);
goog.addDependency('dom/selection.js', ['goog.dom.selection'], [
  'goog.string',
  'goog.userAgent'
]);
goog.addDependency('dom/tagiterator.js', [
  'goog.dom.TagIterator',
  'goog.dom.TagWalkType'
], [
  'goog.dom.NodeType',
  'goog.iter.Iterator',
  'goog.iter.StopIteration'
]);
goog.addDependency('dom/tagname.js', ['goog.dom.TagName'], []);
goog.addDependency('dom/textrange.js', ['goog.dom.TextRange'], [
  'goog.array',
  'goog.dom',
  'goog.dom.AbstractRange',
  'goog.dom.RangeType',
  'goog.dom.SavedRange',
  'goog.dom.TagName',
  'goog.dom.TextRangeIterator',
  'goog.dom.browserrange',
  'goog.string',
  'goog.userAgent'
]);
goog.addDependency('dom/textrangeiterator.js', ['goog.dom.TextRangeIterator'], [
  'goog.array',
  'goog.dom.NodeType',
  'goog.dom.RangeIterator',
  'goog.dom.TagName',
  'goog.iter.StopIteration'
]);
goog.addDependency('dom/vendor.js', ['goog.dom.vendor'], ['goog.userAgent']);
goog.addDependency('dom/viewportsizemonitor.js', ['goog.dom.ViewportSizeMonitor'], [
  'goog.dom',
  'goog.events',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.math.Size'
]);
goog.addDependency('dom/xml.js', ['goog.dom.xml'], [
  'goog.dom',
  'goog.dom.NodeType'
]);
goog.addDependency('editor/browserfeature.js', ['goog.editor.BrowserFeature'], [
  'goog.editor.defines',
  'goog.userAgent',
  'goog.userAgent.product',
  'goog.userAgent.product.isVersion'
]);
goog.addDependency('editor/clicktoeditwrapper.js', ['goog.editor.ClickToEditWrapper'], [
  'goog.Disposable',
  'goog.asserts',
  'goog.dom',
  'goog.dom.Range',
  'goog.dom.TagName',
  'goog.editor.BrowserFeature',
  'goog.editor.Command',
  'goog.editor.Field.EventType',
  'goog.editor.range',
  'goog.events.BrowserEvent.MouseButton',
  'goog.events.EventHandler',
  'goog.events.EventType',
  'goog.log'
]);
goog.addDependency('editor/command.js', ['goog.editor.Command'], []);
goog.addDependency('editor/contenteditablefield.js', ['goog.editor.ContentEditableField'], [
  'goog.asserts',
  'goog.editor.Field',
  'goog.log'
]);
goog.addDependency('editor/defines.js', ['goog.editor.defines'], []);
goog.addDependency('editor/field.js', [
  'goog.editor.Field',
  'goog.editor.Field.EventType'
], [
  'goog.a11y.aria',
  'goog.a11y.aria.Role',
  'goog.array',
  'goog.asserts',
  'goog.async.Delay',
  'goog.dom',
  'goog.dom.Range',
  'goog.dom.TagName',
  'goog.editor.BrowserFeature',
  'goog.editor.Command',
  'goog.editor.Plugin',
  'goog.editor.icontent',
  'goog.editor.icontent.FieldFormatInfo',
  'goog.editor.icontent.FieldStyleInfo',
  'goog.editor.node',
  'goog.editor.range',
  'goog.events',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.functions',
  'goog.log',
  'goog.string',
  'goog.string.Unicode',
  'goog.style',
  'goog.userAgent',
  'goog.userAgent.product'
]);
goog.addDependency('editor/field_test.js', ['goog.editor.field_test'], [
  'goog.dom',
  'goog.dom.Range',
  'goog.editor.BrowserFeature',
  'goog.editor.Field',
  'goog.editor.Plugin',
  'goog.editor.range',
  'goog.events',
  'goog.events.BrowserEvent',
  'goog.events.KeyCodes',
  'goog.functions',
  'goog.testing.LooseMock',
  'goog.testing.MockClock',
  'goog.testing.dom',
  'goog.testing.events',
  'goog.testing.events.Event',
  'goog.testing.recordFunction',
  'goog.userAgent'
]);
goog.addDependency('editor/focus.js', ['goog.editor.focus'], ['goog.dom.selection']);
goog.addDependency('editor/icontent.js', [
  'goog.editor.icontent',
  'goog.editor.icontent.FieldFormatInfo',
  'goog.editor.icontent.FieldStyleInfo'
], [
  'goog.editor.BrowserFeature',
  'goog.style',
  'goog.userAgent'
]);
goog.addDependency('editor/link.js', ['goog.editor.Link'], [
  'goog.array',
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.Range',
  'goog.editor.BrowserFeature',
  'goog.editor.Command',
  'goog.editor.node',
  'goog.editor.range',
  'goog.string',
  'goog.string.Unicode',
  'goog.uri.utils',
  'goog.uri.utils.ComponentIndex'
]);
goog.addDependency('editor/node.js', ['goog.editor.node'], [
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.TagName',
  'goog.dom.iter.ChildIterator',
  'goog.dom.iter.SiblingIterator',
  'goog.iter',
  'goog.object',
  'goog.string',
  'goog.string.Unicode',
  'goog.userAgent'
]);
goog.addDependency('editor/plugin.js', ['goog.editor.Plugin'], [
  'goog.editor.Command',
  'goog.events.EventTarget',
  'goog.functions',
  'goog.log',
  'goog.object',
  'goog.reflect'
]);
goog.addDependency('editor/plugins/abstractbubbleplugin.js', ['goog.editor.plugins.AbstractBubblePlugin'], [
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.Range',
  'goog.dom.TagName',
  'goog.editor.Plugin',
  'goog.editor.style',
  'goog.events',
  'goog.events.EventHandler',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.events.actionEventWrapper',
  'goog.functions',
  'goog.string.Unicode',
  'goog.ui.Component.EventType',
  'goog.ui.editor.Bubble',
  'goog.userAgent'
]);
goog.addDependency('editor/plugins/abstractdialogplugin.js', [
  'goog.editor.plugins.AbstractDialogPlugin',
  'goog.editor.plugins.AbstractDialogPlugin.EventType'
], [
  'goog.dom',
  'goog.dom.Range',
  'goog.editor.Field.EventType',
  'goog.editor.Plugin',
  'goog.editor.range',
  'goog.events',
  'goog.ui.editor.AbstractDialog.EventType'
]);
goog.addDependency('editor/plugins/abstracttabhandler.js', ['goog.editor.plugins.AbstractTabHandler'], [
  'goog.editor.Plugin',
  'goog.events.KeyCodes'
]);
goog.addDependency('editor/plugins/basictextformatter.js', [
  'goog.editor.plugins.BasicTextFormatter',
  'goog.editor.plugins.BasicTextFormatter.COMMAND'
], [
  'goog.array',
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.Range',
  'goog.dom.TagName',
  'goog.editor.BrowserFeature',
  'goog.editor.Command',
  'goog.editor.Link',
  'goog.editor.Plugin',
  'goog.editor.node',
  'goog.editor.range',
  'goog.editor.style',
  'goog.iter',
  'goog.iter.StopIteration',
  'goog.log',
  'goog.object',
  'goog.string',
  'goog.string.Unicode',
  'goog.style',
  'goog.ui.editor.messages',
  'goog.userAgent'
]);
goog.addDependency('editor/plugins/blockquote.js', ['goog.editor.plugins.Blockquote'], [
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.TagName',
  'goog.dom.classes',
  'goog.editor.BrowserFeature',
  'goog.editor.Command',
  'goog.editor.Plugin',
  'goog.editor.node',
  'goog.functions',
  'goog.log'
]);
goog.addDependency('editor/plugins/emoticons.js', ['goog.editor.plugins.Emoticons'], [
  'goog.dom.TagName',
  'goog.editor.Plugin',
  'goog.editor.range',
  'goog.functions',
  'goog.ui.emoji.Emoji',
  'goog.userAgent'
]);
goog.addDependency('editor/plugins/enterhandler.js', ['goog.editor.plugins.EnterHandler'], [
  'goog.dom',
  'goog.dom.NodeOffset',
  'goog.dom.NodeType',
  'goog.dom.Range',
  'goog.dom.TagName',
  'goog.editor.BrowserFeature',
  'goog.editor.Plugin',
  'goog.editor.node',
  'goog.editor.plugins.Blockquote',
  'goog.editor.range',
  'goog.editor.style',
  'goog.events.KeyCodes',
  'goog.functions',
  'goog.object',
  'goog.string',
  'goog.userAgent'
]);
goog.addDependency('editor/plugins/equationeditorbubble.js', ['goog.editor.plugins.equation.EquationBubble'], [
  'goog.dom',
  'goog.dom.TagName',
  'goog.editor.Command',
  'goog.editor.plugins.AbstractBubblePlugin',
  'goog.string.Unicode',
  'goog.ui.editor.Bubble',
  'goog.ui.equation.ImageRenderer'
]);
goog.addDependency('editor/plugins/equationeditorplugin.js', ['goog.editor.plugins.EquationEditorPlugin'], [
  'goog.dom',
  'goog.editor.Command',
  'goog.editor.plugins.AbstractDialogPlugin',
  'goog.editor.range',
  'goog.events',
  'goog.events.EventType',
  'goog.functions',
  'goog.log',
  'goog.ui.editor.AbstractDialog',
  'goog.ui.editor.EquationEditorDialog',
  'goog.ui.equation.ImageRenderer',
  'goog.ui.equation.PaletteManager'
]);
goog.addDependency('editor/plugins/firststrong.js', ['goog.editor.plugins.FirstStrong'], [
  'goog.dom.NodeType',
  'goog.dom.TagIterator',
  'goog.dom.TagName',
  'goog.editor.Command',
  'goog.editor.Plugin',
  'goog.editor.node',
  'goog.editor.range',
  'goog.i18n.bidi',
  'goog.i18n.uChar',
  'goog.iter',
  'goog.userAgent'
]);
goog.addDependency('editor/plugins/headerformatter.js', ['goog.editor.plugins.HeaderFormatter'], [
  'goog.editor.Command',
  'goog.editor.Plugin',
  'goog.userAgent'
]);
goog.addDependency('editor/plugins/linkbubble.js', [
  'goog.editor.plugins.LinkBubble',
  'goog.editor.plugins.LinkBubble.Action'
], [
  'goog.array',
  'goog.dom',
  'goog.editor.BrowserFeature',
  'goog.editor.Command',
  'goog.editor.Link',
  'goog.editor.plugins.AbstractBubblePlugin',
  'goog.editor.range',
  'goog.string',
  'goog.style',
  'goog.ui.editor.messages',
  'goog.uri.utils',
  'goog.window'
]);
goog.addDependency('editor/plugins/linkdialogplugin.js', ['goog.editor.plugins.LinkDialogPlugin'], [
  'goog.array',
  'goog.dom',
  'goog.editor.Command',
  'goog.editor.plugins.AbstractDialogPlugin',
  'goog.events.EventHandler',
  'goog.functions',
  'goog.ui.editor.AbstractDialog.EventType',
  'goog.ui.editor.LinkDialog',
  'goog.ui.editor.LinkDialog.EventType',
  'goog.ui.editor.LinkDialog.OkEvent',
  'goog.uri.utils'
]);
goog.addDependency('editor/plugins/linkshortcutplugin.js', ['goog.editor.plugins.LinkShortcutPlugin'], [
  'goog.editor.Command',
  'goog.editor.Link',
  'goog.editor.Plugin',
  'goog.string'
]);
goog.addDependency('editor/plugins/listtabhandler.js', ['goog.editor.plugins.ListTabHandler'], [
  'goog.dom.TagName',
  'goog.editor.Command',
  'goog.editor.plugins.AbstractTabHandler'
]);
goog.addDependency('editor/plugins/loremipsum.js', ['goog.editor.plugins.LoremIpsum'], [
  'goog.asserts',
  'goog.dom',
  'goog.editor.Command',
  'goog.editor.Plugin',
  'goog.editor.node',
  'goog.functions'
]);
goog.addDependency('editor/plugins/removeformatting.js', ['goog.editor.plugins.RemoveFormatting'], [
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.Range',
  'goog.dom.TagName',
  'goog.editor.BrowserFeature',
  'goog.editor.Plugin',
  'goog.editor.node',
  'goog.editor.range',
  'goog.string',
  'goog.userAgent'
]);
goog.addDependency('editor/plugins/spacestabhandler.js', ['goog.editor.plugins.SpacesTabHandler'], [
  'goog.dom',
  'goog.dom.TagName',
  'goog.editor.plugins.AbstractTabHandler',
  'goog.editor.range'
]);
goog.addDependency('editor/plugins/tableeditor.js', ['goog.editor.plugins.TableEditor'], [
  'goog.array',
  'goog.dom',
  'goog.dom.TagName',
  'goog.editor.Plugin',
  'goog.editor.Table',
  'goog.editor.node',
  'goog.editor.range',
  'goog.object'
]);
goog.addDependency('editor/plugins/tagonenterhandler.js', ['goog.editor.plugins.TagOnEnterHandler'], [
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.Range',
  'goog.dom.TagName',
  'goog.editor.Command',
  'goog.editor.node',
  'goog.editor.plugins.EnterHandler',
  'goog.editor.range',
  'goog.editor.style',
  'goog.events.KeyCodes',
  'goog.string',
  'goog.style',
  'goog.userAgent'
]);
goog.addDependency('editor/plugins/undoredo.js', ['goog.editor.plugins.UndoRedo'], [
  'goog.dom',
  'goog.dom.NodeOffset',
  'goog.dom.Range',
  'goog.editor.BrowserFeature',
  'goog.editor.Command',
  'goog.editor.Field.EventType',
  'goog.editor.Plugin',
  'goog.editor.node',
  'goog.editor.plugins.UndoRedoManager',
  'goog.editor.plugins.UndoRedoState',
  'goog.events',
  'goog.events.EventHandler',
  'goog.log'
]);
goog.addDependency('editor/plugins/undoredomanager.js', [
  'goog.editor.plugins.UndoRedoManager',
  'goog.editor.plugins.UndoRedoManager.EventType'
], [
  'goog.editor.plugins.UndoRedoState',
  'goog.events.EventTarget'
]);
goog.addDependency('editor/plugins/undoredostate.js', ['goog.editor.plugins.UndoRedoState'], ['goog.events.EventTarget']);
goog.addDependency('editor/range.js', [
  'goog.editor.range',
  'goog.editor.range.Point'
], [
  'goog.array',
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.Range',
  'goog.dom.RangeEndpoint',
  'goog.dom.SavedCaretRange',
  'goog.editor.node',
  'goog.editor.style',
  'goog.iter',
  'goog.userAgent'
]);
goog.addDependency('editor/seamlessfield.js', ['goog.editor.SeamlessField'], [
  'goog.cssom.iframe.style',
  'goog.dom',
  'goog.dom.Range',
  'goog.dom.TagName',
  'goog.editor.BrowserFeature',
  'goog.editor.Field',
  'goog.editor.icontent',
  'goog.editor.icontent.FieldFormatInfo',
  'goog.editor.icontent.FieldStyleInfo',
  'goog.editor.node',
  'goog.events',
  'goog.events.EventType',
  'goog.log',
  'goog.style'
]);
goog.addDependency('editor/seamlessfield_test.js', ['goog.editor.seamlessfield_test'], [
  'goog.dom',
  'goog.dom.DomHelper',
  'goog.dom.Range',
  'goog.editor.BrowserFeature',
  'goog.editor.Field',
  'goog.editor.SeamlessField',
  'goog.events',
  'goog.functions',
  'goog.style',
  'goog.testing.MockClock',
  'goog.testing.MockRange',
  'goog.testing.jsunit'
]);
goog.addDependency('editor/style.js', ['goog.editor.style'], [
  'goog.dom',
  'goog.dom.NodeType',
  'goog.editor.BrowserFeature',
  'goog.events.EventType',
  'goog.object',
  'goog.style',
  'goog.userAgent'
]);
goog.addDependency('editor/table.js', [
  'goog.editor.Table',
  'goog.editor.TableCell',
  'goog.editor.TableRow'
], [
  'goog.dom',
  'goog.dom.DomHelper',
  'goog.dom.NodeType',
  'goog.dom.TagName',
  'goog.log',
  'goog.string.Unicode',
  'goog.style'
]);
goog.addDependency('events/actioneventwrapper.js', ['goog.events.actionEventWrapper'], [
  'goog.events',
  'goog.events.EventHandler',
  'goog.events.EventType',
  'goog.events.EventWrapper',
  'goog.events.KeyCodes'
]);
goog.addDependency('events/actionhandler.js', [
  'goog.events.ActionEvent',
  'goog.events.ActionHandler',
  'goog.events.ActionHandler.EventType',
  'goog.events.BeforeActionEvent'
], [
  'goog.events',
  'goog.events.BrowserEvent',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.userAgent'
]);
goog.addDependency('events/browserevent.js', [
  'goog.events.BrowserEvent',
  'goog.events.BrowserEvent.MouseButton'
], [
  'goog.events.BrowserFeature',
  'goog.events.Event',
  'goog.events.EventType',
  'goog.reflect',
  'goog.userAgent'
]);
goog.addDependency('events/browserfeature.js', ['goog.events.BrowserFeature'], ['goog.userAgent']);
goog.addDependency('events/event.js', [
  'goog.events.Event',
  'goog.events.EventLike'
], ['goog.Disposable']);
goog.addDependency('events/eventhandler.js', ['goog.events.EventHandler'], [
  'goog.Disposable',
  'goog.events',
  'goog.object'
]);
goog.addDependency('events/events.js', [
  'goog.events',
  'goog.events.Key',
  'goog.events.ListenableType'
], [
  'goog.array',
  'goog.asserts',
  'goog.debug.entryPointRegistry',
  'goog.events.BrowserEvent',
  'goog.events.BrowserFeature',
  'goog.events.Listenable',
  'goog.events.Listener',
  'goog.object'
]);
goog.addDependency('events/eventtarget.js', ['goog.events.EventTarget'], [
  'goog.Disposable',
  'goog.array',
  'goog.asserts',
  'goog.events',
  'goog.events.Event',
  'goog.events.Listenable',
  'goog.events.ListenerMap',
  'goog.object'
]);
goog.addDependency('events/eventtargettester.js', [
  'goog.events.eventTargetTester',
  'goog.events.eventTargetTester.KeyType',
  'goog.events.eventTargetTester.UnlistenReturnType'
], [
  'goog.array',
  'goog.events',
  'goog.events.Event',
  'goog.events.EventTarget',
  'goog.testing.asserts',
  'goog.testing.recordFunction'
]);
goog.addDependency('events/eventtype.js', ['goog.events.EventType'], ['goog.userAgent']);
goog.addDependency('events/eventwrapper.js', ['goog.events.EventWrapper'], []);
goog.addDependency('events/filedrophandler.js', [
  'goog.events.FileDropHandler',
  'goog.events.FileDropHandler.EventType'
], [
  'goog.array',
  'goog.dom',
  'goog.events',
  'goog.events.BrowserEvent',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.log'
]);
goog.addDependency('events/focushandler.js', [
  'goog.events.FocusHandler',
  'goog.events.FocusHandler.EventType'
], [
  'goog.events',
  'goog.events.BrowserEvent',
  'goog.events.EventTarget',
  'goog.userAgent'
]);
goog.addDependency('events/imehandler.js', [
  'goog.events.ImeHandler',
  'goog.events.ImeHandler.Event',
  'goog.events.ImeHandler.EventType'
], [
  'goog.events.Event',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.userAgent'
]);
goog.addDependency('events/inputhandler.js', [
  'goog.events.InputHandler',
  'goog.events.InputHandler.EventType'
], [
  'goog.Timer',
  'goog.dom',
  'goog.events.BrowserEvent',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.events.KeyCodes',
  'goog.userAgent'
]);
goog.addDependency('events/keycodes.js', ['goog.events.KeyCodes'], ['goog.userAgent']);
goog.addDependency('events/keyhandler.js', [
  'goog.events.KeyEvent',
  'goog.events.KeyHandler',
  'goog.events.KeyHandler.EventType'
], [
  'goog.events',
  'goog.events.BrowserEvent',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.userAgent'
]);
goog.addDependency('events/keynames.js', ['goog.events.KeyNames'], []);
goog.addDependency('events/listenable.js', [
  'goog.events.Listenable',
  'goog.events.ListenableKey'
], []);
goog.addDependency('events/listener.js', ['goog.events.Listener'], ['goog.events.ListenableKey']);
goog.addDependency('events/listenermap.js', ['goog.events.ListenerMap'], [
  'goog.array',
  'goog.events.Listener',
  'goog.object'
]);
goog.addDependency('events/listenermap_test.js', ['goog.events.ListenerMapTest'], [
  'goog.dispose',
  'goog.events.EventTarget',
  'goog.events.ListenerMap',
  'goog.testing.jsunit'
]);
goog.addDependency('events/mousewheelhandler.js', [
  'goog.events.MouseWheelEvent',
  'goog.events.MouseWheelHandler',
  'goog.events.MouseWheelHandler.EventType'
], [
  'goog.dom',
  'goog.events',
  'goog.events.BrowserEvent',
  'goog.events.EventTarget',
  'goog.math',
  'goog.style',
  'goog.userAgent'
]);
goog.addDependency('events/onlinehandler.js', [
  'goog.events.OnlineHandler',
  'goog.events.OnlineHandler.EventType'
], [
  'goog.Timer',
  'goog.events.BrowserFeature',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.net.NetworkStatusMonitor',
  'goog.userAgent'
]);
goog.addDependency('events/pastehandler.js', [
  'goog.events.PasteHandler',
  'goog.events.PasteHandler.EventType',
  'goog.events.PasteHandler.State'
], [
  'goog.Timer',
  'goog.async.ConditionalDelay',
  'goog.events.BrowserEvent',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.log',
  'goog.userAgent'
]);
goog.addDependency('format/emailaddress.js', ['goog.format.EmailAddress'], ['goog.string']);
goog.addDependency('format/format.js', ['goog.format'], [
  'goog.i18n.GraphemeBreak',
  'goog.string',
  'goog.userAgent'
]);
goog.addDependency('format/htmlprettyprinter.js', [
  'goog.format.HtmlPrettyPrinter',
  'goog.format.HtmlPrettyPrinter.Buffer'
], [
  'goog.object',
  'goog.string.StringBuffer'
]);
goog.addDependency('format/jsonprettyprinter.js', [
  'goog.format.JsonPrettyPrinter',
  'goog.format.JsonPrettyPrinter.HtmlDelimiters',
  'goog.format.JsonPrettyPrinter.TextDelimiters'
], [
  'goog.json',
  'goog.json.Serializer',
  'goog.string',
  'goog.string.StringBuffer',
  'goog.string.format'
]);
goog.addDependency('fs/entry.js', [
  'goog.fs.DirectoryEntry',
  'goog.fs.DirectoryEntry.Behavior',
  'goog.fs.Entry',
  'goog.fs.FileEntry'
], []);
goog.addDependency('fs/entryimpl.js', [
  'goog.fs.DirectoryEntryImpl',
  'goog.fs.EntryImpl',
  'goog.fs.FileEntryImpl'
], [
  'goog.array',
  'goog.async.Deferred',
  'goog.fs.DirectoryEntry',
  'goog.fs.Entry',
  'goog.fs.Error',
  'goog.fs.FileEntry',
  'goog.fs.FileWriter',
  'goog.functions',
  'goog.string'
]);
goog.addDependency('fs/error.js', [
  'goog.fs.Error',
  'goog.fs.Error.ErrorCode'
], [
  'goog.debug.Error',
  'goog.string'
]);
goog.addDependency('fs/filereader.js', [
  'goog.fs.FileReader',
  'goog.fs.FileReader.EventType',
  'goog.fs.FileReader.ReadyState'
], [
  'goog.async.Deferred',
  'goog.events.Event',
  'goog.events.EventTarget',
  'goog.fs.Error',
  'goog.fs.ProgressEvent'
]);
goog.addDependency('fs/filesaver.js', [
  'goog.fs.FileSaver',
  'goog.fs.FileSaver.EventType',
  'goog.fs.FileSaver.ProgressEvent',
  'goog.fs.FileSaver.ReadyState'
], [
  'goog.events.Event',
  'goog.events.EventTarget',
  'goog.fs.Error',
  'goog.fs.ProgressEvent'
]);
goog.addDependency('fs/filesystem.js', ['goog.fs.FileSystem'], []);
goog.addDependency('fs/filesystemimpl.js', ['goog.fs.FileSystemImpl'], [
  'goog.fs.DirectoryEntryImpl',
  'goog.fs.FileSystem'
]);
goog.addDependency('fs/filewriter.js', ['goog.fs.FileWriter'], [
  'goog.fs.Error',
  'goog.fs.FileSaver'
]);
goog.addDependency('fs/fs.js', ['goog.fs'], [
  'goog.array',
  'goog.async.Deferred',
  'goog.fs.Error',
  'goog.fs.FileReader',
  'goog.fs.FileSystemImpl',
  'goog.userAgent'
]);
goog.addDependency('fs/progressevent.js', ['goog.fs.ProgressEvent'], ['goog.events.Event']);
goog.addDependency('functions/functions.js', ['goog.functions'], []);
goog.addDependency('fx/abstractdragdrop.js', [
  'goog.fx.AbstractDragDrop',
  'goog.fx.AbstractDragDrop.EventType',
  'goog.fx.DragDropEvent',
  'goog.fx.DragDropItem'
], [
  'goog.dom',
  'goog.dom.classes',
  'goog.events',
  'goog.events.Event',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.fx.Dragger',
  'goog.fx.Dragger.EventType',
  'goog.math.Box',
  'goog.math.Coordinate',
  'goog.style'
]);
goog.addDependency('fx/anim/anim.js', [
  'goog.fx.anim',
  'goog.fx.anim.Animated'
], [
  'goog.async.AnimationDelay',
  'goog.async.Delay',
  'goog.object'
]);
goog.addDependency('fx/animation.js', [
  'goog.fx.Animation',
  'goog.fx.Animation.EventType',
  'goog.fx.Animation.State',
  'goog.fx.AnimationEvent'
], [
  'goog.array',
  'goog.events.Event',
  'goog.fx.Transition',
  'goog.fx.Transition.EventType',
  'goog.fx.TransitionBase.State',
  'goog.fx.anim',
  'goog.fx.anim.Animated'
]);
goog.addDependency('fx/animationqueue.js', [
  'goog.fx.AnimationParallelQueue',
  'goog.fx.AnimationQueue',
  'goog.fx.AnimationSerialQueue'
], [
  'goog.array',
  'goog.asserts',
  'goog.events.EventHandler',
  'goog.fx.Transition.EventType',
  'goog.fx.TransitionBase',
  'goog.fx.TransitionBase.State'
]);
goog.addDependency('fx/css3/fx.js', ['goog.fx.css3'], ['goog.fx.css3.Transition']);
goog.addDependency('fx/css3/transition.js', ['goog.fx.css3.Transition'], [
  'goog.Timer',
  'goog.fx.TransitionBase',
  'goog.style',
  'goog.style.transition'
]);
goog.addDependency('fx/cssspriteanimation.js', ['goog.fx.CssSpriteAnimation'], ['goog.fx.Animation']);
goog.addDependency('fx/dom.js', [
  'goog.fx.dom',
  'goog.fx.dom.BgColorTransform',
  'goog.fx.dom.ColorTransform',
  'goog.fx.dom.Fade',
  'goog.fx.dom.FadeIn',
  'goog.fx.dom.FadeInAndShow',
  'goog.fx.dom.FadeOut',
  'goog.fx.dom.FadeOutAndHide',
  'goog.fx.dom.PredefinedEffect',
  'goog.fx.dom.Resize',
  'goog.fx.dom.ResizeHeight',
  'goog.fx.dom.ResizeWidth',
  'goog.fx.dom.Scroll',
  'goog.fx.dom.Slide',
  'goog.fx.dom.SlideFrom',
  'goog.fx.dom.Swipe'
], [
  'goog.color',
  'goog.events',
  'goog.fx.Animation',
  'goog.fx.Transition.EventType',
  'goog.style',
  'goog.style.bidi'
]);
goog.addDependency('fx/dragdrop.js', ['goog.fx.DragDrop'], [
  'goog.fx.AbstractDragDrop',
  'goog.fx.DragDropItem'
]);
goog.addDependency('fx/dragdropgroup.js', ['goog.fx.DragDropGroup'], [
  'goog.dom',
  'goog.fx.AbstractDragDrop',
  'goog.fx.DragDropItem'
]);
goog.addDependency('fx/dragger.js', [
  'goog.fx.DragEvent',
  'goog.fx.Dragger',
  'goog.fx.Dragger.EventType'
], [
  'goog.dom',
  'goog.events',
  'goog.events.Event',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.math.Coordinate',
  'goog.math.Rect',
  'goog.style',
  'goog.style.bidi',
  'goog.userAgent'
]);
goog.addDependency('fx/draglistgroup.js', [
  'goog.fx.DragListDirection',
  'goog.fx.DragListGroup',
  'goog.fx.DragListGroup.EventType',
  'goog.fx.DragListGroupEvent'
], [
  'goog.asserts',
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.classes',
  'goog.events.Event',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.fx.Dragger',
  'goog.fx.Dragger.EventType',
  'goog.math.Coordinate',
  'goog.style'
]);
goog.addDependency('fx/dragscrollsupport.js', ['goog.fx.DragScrollSupport'], [
  'goog.Disposable',
  'goog.Timer',
  'goog.dom',
  'goog.events.EventHandler',
  'goog.events.EventType',
  'goog.math.Coordinate',
  'goog.style'
]);
goog.addDependency('fx/easing.js', ['goog.fx.easing'], []);
goog.addDependency('fx/fx.js', ['goog.fx'], [
  'goog.asserts',
  'goog.fx.Animation',
  'goog.fx.Animation.EventType',
  'goog.fx.Animation.State',
  'goog.fx.AnimationEvent',
  'goog.fx.Transition.EventType',
  'goog.fx.easing'
]);
goog.addDependency('fx/transition.js', [
  'goog.fx.Transition',
  'goog.fx.Transition.EventType'
], []);
goog.addDependency('fx/transitionbase.js', [
  'goog.fx.TransitionBase',
  'goog.fx.TransitionBase.State'
], [
  'goog.events.EventTarget',
  'goog.fx.Transition',
  'goog.fx.Transition.EventType'
]);
goog.addDependency('gears/basestore.js', [
  'goog.gears.BaseStore',
  'goog.gears.BaseStore.SchemaType'
], ['goog.Disposable']);
goog.addDependency('gears/database.js', [
  'goog.gears.Database',
  'goog.gears.Database.EventType',
  'goog.gears.Database.TransactionEvent'
], [
  'goog.array',
  'goog.debug',
  'goog.events.Event',
  'goog.events.EventTarget',
  'goog.gears',
  'goog.json',
  'goog.log'
]);
goog.addDependency('gears/gears.js', ['goog.gears'], ['goog.string']);
goog.addDependency('gears/httprequest.js', ['goog.gears.HttpRequest'], [
  'goog.Timer',
  'goog.gears',
  'goog.net.WrapperXmlHttpFactory',
  'goog.net.XmlHttp'
]);
goog.addDependency('gears/loggerclient.js', ['goog.gears.LoggerClient'], [
  'goog.Disposable',
  'goog.debug',
  'goog.debug.Logger'
]);
goog.addDependency('gears/loggerserver.js', ['goog.gears.LoggerServer'], [
  'goog.Disposable',
  'goog.gears.Worker.EventType',
  'goog.log',
  'goog.log.Level'
]);
goog.addDependency('gears/logstore.js', [
  'goog.gears.LogStore',
  'goog.gears.LogStore.Query'
], [
  'goog.async.Delay',
  'goog.debug.LogManager',
  'goog.gears.BaseStore',
  'goog.gears.BaseStore.SchemaType',
  'goog.json',
  'goog.log',
  'goog.log.Level',
  'goog.log.LogRecord'
]);
goog.addDependency('gears/managedresourcestore.js', [
  'goog.gears.ManagedResourceStore',
  'goog.gears.ManagedResourceStore.EventType',
  'goog.gears.ManagedResourceStore.UpdateStatus',
  'goog.gears.ManagedResourceStoreEvent'
], [
  'goog.events.Event',
  'goog.events.EventTarget',
  'goog.gears',
  'goog.log',
  'goog.string'
]);
goog.addDependency('gears/multipartformdata.js', ['goog.gears.MultipartFormData'], [
  'goog.asserts',
  'goog.gears',
  'goog.string'
]);
goog.addDependency('gears/statustype.js', ['goog.gears.StatusType'], []);
goog.addDependency('gears/urlcapture.js', [
  'goog.gears.UrlCapture',
  'goog.gears.UrlCapture.Event',
  'goog.gears.UrlCapture.EventType'
], [
  'goog.Uri',
  'goog.events.Event',
  'goog.events.EventTarget',
  'goog.gears',
  'goog.log'
]);
goog.addDependency('gears/worker.js', [
  'goog.gears.Worker',
  'goog.gears.Worker.EventType',
  'goog.gears.WorkerEvent'
], [
  'goog.events.Event',
  'goog.events.EventTarget'
]);
goog.addDependency('gears/workerchannel.js', ['goog.gears.WorkerChannel'], [
  'goog.Disposable',
  'goog.debug',
  'goog.events',
  'goog.gears.Worker',
  'goog.gears.Worker.EventType',
  'goog.gears.WorkerEvent',
  'goog.json',
  'goog.log',
  'goog.messaging.AbstractChannel'
]);
goog.addDependency('gears/workerpool.js', [
  'goog.gears.WorkerPool',
  'goog.gears.WorkerPool.Event',
  'goog.gears.WorkerPool.EventType'
], [
  'goog.events.Event',
  'goog.events.EventTarget',
  'goog.gears',
  'goog.gears.Worker'
]);
goog.addDependency('graphics/abstractgraphics.js', ['goog.graphics.AbstractGraphics'], [
  'goog.dom',
  'goog.graphics.Path',
  'goog.math.Coordinate',
  'goog.math.Size',
  'goog.style',
  'goog.ui.Component'
]);
goog.addDependency('graphics/affinetransform.js', ['goog.graphics.AffineTransform'], ['goog.math']);
goog.addDependency('graphics/canvaselement.js', [
  'goog.graphics.CanvasEllipseElement',
  'goog.graphics.CanvasGroupElement',
  'goog.graphics.CanvasImageElement',
  'goog.graphics.CanvasPathElement',
  'goog.graphics.CanvasRectElement',
  'goog.graphics.CanvasTextElement'
], [
  'goog.array',
  'goog.dom',
  'goog.dom.TagName',
  'goog.graphics.EllipseElement',
  'goog.graphics.GroupElement',
  'goog.graphics.ImageElement',
  'goog.graphics.Path',
  'goog.graphics.PathElement',
  'goog.graphics.RectElement',
  'goog.graphics.TextElement',
  'goog.math',
  'goog.string'
]);
goog.addDependency('graphics/canvasgraphics.js', ['goog.graphics.CanvasGraphics'], [
  'goog.events.EventType',
  'goog.graphics.AbstractGraphics',
  'goog.graphics.CanvasEllipseElement',
  'goog.graphics.CanvasGroupElement',
  'goog.graphics.CanvasImageElement',
  'goog.graphics.CanvasPathElement',
  'goog.graphics.CanvasRectElement',
  'goog.graphics.CanvasTextElement',
  'goog.graphics.SolidFill',
  'goog.math.Size',
  'goog.style'
]);
goog.addDependency('graphics/element.js', ['goog.graphics.Element'], [
  'goog.events',
  'goog.events.EventTarget',
  'goog.events.Listenable',
  'goog.graphics.AffineTransform',
  'goog.math'
]);
goog.addDependency('graphics/ellipseelement.js', ['goog.graphics.EllipseElement'], ['goog.graphics.StrokeAndFillElement']);
goog.addDependency('graphics/ext/coordinates.js', ['goog.graphics.ext.coordinates'], ['goog.string']);
goog.addDependency('graphics/ext/element.js', ['goog.graphics.ext.Element'], [
  'goog.events',
  'goog.events.EventTarget',
  'goog.functions',
  'goog.graphics',
  'goog.graphics.ext.coordinates'
]);
goog.addDependency('graphics/ext/ellipse.js', ['goog.graphics.ext.Ellipse'], ['goog.graphics.ext.StrokeAndFillElement']);
goog.addDependency('graphics/ext/ext.js', ['goog.graphics.ext'], [
  'goog.graphics.ext.Ellipse',
  'goog.graphics.ext.Graphics',
  'goog.graphics.ext.Group',
  'goog.graphics.ext.Image',
  'goog.graphics.ext.Rectangle',
  'goog.graphics.ext.Shape',
  'goog.graphics.ext.coordinates'
]);
goog.addDependency('graphics/ext/graphics.js', ['goog.graphics.ext.Graphics'], [
  'goog.events.EventType',
  'goog.graphics.ext.Group'
]);
goog.addDependency('graphics/ext/group.js', ['goog.graphics.ext.Group'], ['goog.graphics.ext.Element']);
goog.addDependency('graphics/ext/image.js', ['goog.graphics.ext.Image'], ['goog.graphics.ext.Element']);
goog.addDependency('graphics/ext/path.js', ['goog.graphics.ext.Path'], [
  'goog.graphics.AffineTransform',
  'goog.graphics.Path',
  'goog.math',
  'goog.math.Rect'
]);
goog.addDependency('graphics/ext/rectangle.js', ['goog.graphics.ext.Rectangle'], ['goog.graphics.ext.StrokeAndFillElement']);
goog.addDependency('graphics/ext/shape.js', ['goog.graphics.ext.Shape'], [
  'goog.graphics.ext.Path',
  'goog.graphics.ext.StrokeAndFillElement',
  'goog.math.Rect'
]);
goog.addDependency('graphics/ext/strokeandfillelement.js', ['goog.graphics.ext.StrokeAndFillElement'], ['goog.graphics.ext.Element']);
goog.addDependency('graphics/fill.js', ['goog.graphics.Fill'], []);
goog.addDependency('graphics/font.js', ['goog.graphics.Font'], []);
goog.addDependency('graphics/graphics.js', ['goog.graphics'], [
  'goog.graphics.CanvasGraphics',
  'goog.graphics.SvgGraphics',
  'goog.graphics.VmlGraphics',
  'goog.userAgent'
]);
goog.addDependency('graphics/groupelement.js', ['goog.graphics.GroupElement'], ['goog.graphics.Element']);
goog.addDependency('graphics/imageelement.js', ['goog.graphics.ImageElement'], ['goog.graphics.Element']);
goog.addDependency('graphics/lineargradient.js', ['goog.graphics.LinearGradient'], [
  'goog.asserts',
  'goog.graphics.Fill'
]);
goog.addDependency('graphics/path.js', [
  'goog.graphics.Path',
  'goog.graphics.Path.Segment'
], [
  'goog.array',
  'goog.math'
]);
goog.addDependency('graphics/pathelement.js', ['goog.graphics.PathElement'], ['goog.graphics.StrokeAndFillElement']);
goog.addDependency('graphics/paths.js', ['goog.graphics.paths'], [
  'goog.graphics.Path',
  'goog.math.Coordinate'
]);
goog.addDependency('graphics/rectelement.js', ['goog.graphics.RectElement'], ['goog.graphics.StrokeAndFillElement']);
goog.addDependency('graphics/solidfill.js', ['goog.graphics.SolidFill'], ['goog.graphics.Fill']);
goog.addDependency('graphics/stroke.js', ['goog.graphics.Stroke'], []);
goog.addDependency('graphics/strokeandfillelement.js', ['goog.graphics.StrokeAndFillElement'], ['goog.graphics.Element']);
goog.addDependency('graphics/svgelement.js', [
  'goog.graphics.SvgEllipseElement',
  'goog.graphics.SvgGroupElement',
  'goog.graphics.SvgImageElement',
  'goog.graphics.SvgPathElement',
  'goog.graphics.SvgRectElement',
  'goog.graphics.SvgTextElement'
], [
  'goog.dom',
  'goog.graphics.EllipseElement',
  'goog.graphics.GroupElement',
  'goog.graphics.ImageElement',
  'goog.graphics.PathElement',
  'goog.graphics.RectElement',
  'goog.graphics.TextElement'
]);
goog.addDependency('graphics/svggraphics.js', ['goog.graphics.SvgGraphics'], [
  'goog.Timer',
  'goog.dom',
  'goog.events.EventHandler',
  'goog.events.EventType',
  'goog.graphics.AbstractGraphics',
  'goog.graphics.LinearGradient',
  'goog.graphics.Path',
  'goog.graphics.SolidFill',
  'goog.graphics.Stroke',
  'goog.graphics.SvgEllipseElement',
  'goog.graphics.SvgGroupElement',
  'goog.graphics.SvgImageElement',
  'goog.graphics.SvgPathElement',
  'goog.graphics.SvgRectElement',
  'goog.graphics.SvgTextElement',
  'goog.math',
  'goog.math.Size',
  'goog.style',
  'goog.userAgent'
]);
goog.addDependency('graphics/textelement.js', ['goog.graphics.TextElement'], ['goog.graphics.StrokeAndFillElement']);
goog.addDependency('graphics/vmlelement.js', [
  'goog.graphics.VmlEllipseElement',
  'goog.graphics.VmlGroupElement',
  'goog.graphics.VmlImageElement',
  'goog.graphics.VmlPathElement',
  'goog.graphics.VmlRectElement',
  'goog.graphics.VmlTextElement'
], [
  'goog.dom',
  'goog.graphics.EllipseElement',
  'goog.graphics.GroupElement',
  'goog.graphics.ImageElement',
  'goog.graphics.PathElement',
  'goog.graphics.RectElement',
  'goog.graphics.TextElement'
]);
goog.addDependency('graphics/vmlgraphics.js', ['goog.graphics.VmlGraphics'], [
  'goog.array',
  'goog.events',
  'goog.events.EventHandler',
  'goog.events.EventType',
  'goog.graphics.AbstractGraphics',
  'goog.graphics.LinearGradient',
  'goog.graphics.Path',
  'goog.graphics.SolidFill',
  'goog.graphics.VmlEllipseElement',
  'goog.graphics.VmlGroupElement',
  'goog.graphics.VmlImageElement',
  'goog.graphics.VmlPathElement',
  'goog.graphics.VmlRectElement',
  'goog.graphics.VmlTextElement',
  'goog.math',
  'goog.math.Size',
  'goog.string',
  'goog.style'
]);
goog.addDependency('history/event.js', ['goog.history.Event'], [
  'goog.events.Event',
  'goog.history.EventType'
]);
goog.addDependency('history/eventtype.js', ['goog.history.EventType'], []);
goog.addDependency('history/history.js', [
  'goog.History',
  'goog.History.Event',
  'goog.History.EventType'
], [
  'goog.Timer',
  'goog.dom',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.history.Event',
  'goog.history.EventType',
  'goog.memoize',
  'goog.string',
  'goog.userAgent'
]);
goog.addDependency('history/history_test.js', ['goog.HistoryTest'], [
  'goog.History',
  'goog.testing.jsunit',
  'goog.userAgent'
]);
goog.addDependency('history/html5history.js', [
  'goog.history.Html5History',
  'goog.history.Html5History.TokenTransformer'
], [
  'goog.asserts',
  'goog.events',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.history.Event',
  'goog.history.EventType'
]);
goog.addDependency('i18n/bidi.js', ['goog.i18n.bidi'], []);
goog.addDependency('i18n/bidiformatter.js', ['goog.i18n.BidiFormatter'], [
  'goog.i18n.bidi',
  'goog.string'
]);
goog.addDependency('i18n/charlistdecompressor.js', ['goog.i18n.CharListDecompressor'], [
  'goog.array',
  'goog.i18n.uChar'
]);
goog.addDependency('i18n/charpickerdata.js', ['goog.i18n.CharPickerData'], []);
goog.addDependency('i18n/collation.js', ['goog.i18n.collation'], []);
goog.addDependency('i18n/compactnumberformatsymbols.js', [
  'goog.i18n.CompactNumberFormatSymbols',
  'goog.i18n.CompactNumberFormatSymbols_af',
  'goog.i18n.CompactNumberFormatSymbols_af_ZA',
  'goog.i18n.CompactNumberFormatSymbols_am',
  'goog.i18n.CompactNumberFormatSymbols_am_ET',
  'goog.i18n.CompactNumberFormatSymbols_ar',
  'goog.i18n.CompactNumberFormatSymbols_ar_001',
  'goog.i18n.CompactNumberFormatSymbols_ar_EG',
  'goog.i18n.CompactNumberFormatSymbols_bg',
  'goog.i18n.CompactNumberFormatSymbols_bg_BG',
  'goog.i18n.CompactNumberFormatSymbols_bn',
  'goog.i18n.CompactNumberFormatSymbols_bn_BD',
  'goog.i18n.CompactNumberFormatSymbols_br',
  'goog.i18n.CompactNumberFormatSymbols_br_FR',
  'goog.i18n.CompactNumberFormatSymbols_ca',
  'goog.i18n.CompactNumberFormatSymbols_ca_AD',
  'goog.i18n.CompactNumberFormatSymbols_ca_ES',
  'goog.i18n.CompactNumberFormatSymbols_chr',
  'goog.i18n.CompactNumberFormatSymbols_chr_US',
  'goog.i18n.CompactNumberFormatSymbols_cs',
  'goog.i18n.CompactNumberFormatSymbols_cs_CZ',
  'goog.i18n.CompactNumberFormatSymbols_cy',
  'goog.i18n.CompactNumberFormatSymbols_cy_GB',
  'goog.i18n.CompactNumberFormatSymbols_da',
  'goog.i18n.CompactNumberFormatSymbols_da_DK',
  'goog.i18n.CompactNumberFormatSymbols_de',
  'goog.i18n.CompactNumberFormatSymbols_de_AT',
  'goog.i18n.CompactNumberFormatSymbols_de_BE',
  'goog.i18n.CompactNumberFormatSymbols_de_CH',
  'goog.i18n.CompactNumberFormatSymbols_de_DE',
  'goog.i18n.CompactNumberFormatSymbols_de_LU',
  'goog.i18n.CompactNumberFormatSymbols_el',
  'goog.i18n.CompactNumberFormatSymbols_el_GR',
  'goog.i18n.CompactNumberFormatSymbols_en',
  'goog.i18n.CompactNumberFormatSymbols_en_AS',
  'goog.i18n.CompactNumberFormatSymbols_en_AU',
  'goog.i18n.CompactNumberFormatSymbols_en_Dsrt_US',
  'goog.i18n.CompactNumberFormatSymbols_en_FM',
  'goog.i18n.CompactNumberFormatSymbols_en_GB',
  'goog.i18n.CompactNumberFormatSymbols_en_GU',
  'goog.i18n.CompactNumberFormatSymbols_en_IE',
  'goog.i18n.CompactNumberFormatSymbols_en_IN',
  'goog.i18n.CompactNumberFormatSymbols_en_MH',
  'goog.i18n.CompactNumberFormatSymbols_en_MP',
  'goog.i18n.CompactNumberFormatSymbols_en_PR',
  'goog.i18n.CompactNumberFormatSymbols_en_PW',
  'goog.i18n.CompactNumberFormatSymbols_en_SG',
  'goog.i18n.CompactNumberFormatSymbols_en_TC',
  'goog.i18n.CompactNumberFormatSymbols_en_UM',
  'goog.i18n.CompactNumberFormatSymbols_en_US',
  'goog.i18n.CompactNumberFormatSymbols_en_VG',
  'goog.i18n.CompactNumberFormatSymbols_en_VI',
  'goog.i18n.CompactNumberFormatSymbols_en_ZA',
  'goog.i18n.CompactNumberFormatSymbols_es',
  'goog.i18n.CompactNumberFormatSymbols_es_419',
  'goog.i18n.CompactNumberFormatSymbols_es_EA',
  'goog.i18n.CompactNumberFormatSymbols_es_ES',
  'goog.i18n.CompactNumberFormatSymbols_es_IC',
  'goog.i18n.CompactNumberFormatSymbols_et',
  'goog.i18n.CompactNumberFormatSymbols_et_EE',
  'goog.i18n.CompactNumberFormatSymbols_eu',
  'goog.i18n.CompactNumberFormatSymbols_eu_ES',
  'goog.i18n.CompactNumberFormatSymbols_fa',
  'goog.i18n.CompactNumberFormatSymbols_fa_IR',
  'goog.i18n.CompactNumberFormatSymbols_fi',
  'goog.i18n.CompactNumberFormatSymbols_fi_FI',
  'goog.i18n.CompactNumberFormatSymbols_fil',
  'goog.i18n.CompactNumberFormatSymbols_fil_PH',
  'goog.i18n.CompactNumberFormatSymbols_fr',
  'goog.i18n.CompactNumberFormatSymbols_fr_BL',
  'goog.i18n.CompactNumberFormatSymbols_fr_CA',
  'goog.i18n.CompactNumberFormatSymbols_fr_FR',
  'goog.i18n.CompactNumberFormatSymbols_fr_GF',
  'goog.i18n.CompactNumberFormatSymbols_fr_GP',
  'goog.i18n.CompactNumberFormatSymbols_fr_MC',
  'goog.i18n.CompactNumberFormatSymbols_fr_MF',
  'goog.i18n.CompactNumberFormatSymbols_fr_MQ',
  'goog.i18n.CompactNumberFormatSymbols_fr_RE',
  'goog.i18n.CompactNumberFormatSymbols_fr_YT',
  'goog.i18n.CompactNumberFormatSymbols_gl',
  'goog.i18n.CompactNumberFormatSymbols_gl_ES',
  'goog.i18n.CompactNumberFormatSymbols_gsw',
  'goog.i18n.CompactNumberFormatSymbols_gsw_CH',
  'goog.i18n.CompactNumberFormatSymbols_gu',
  'goog.i18n.CompactNumberFormatSymbols_gu_IN',
  'goog.i18n.CompactNumberFormatSymbols_haw',
  'goog.i18n.CompactNumberFormatSymbols_haw_US',
  'goog.i18n.CompactNumberFormatSymbols_he',
  'goog.i18n.CompactNumberFormatSymbols_he_IL',
  'goog.i18n.CompactNumberFormatSymbols_hi',
  'goog.i18n.CompactNumberFormatSymbols_hi_IN',
  'goog.i18n.CompactNumberFormatSymbols_hr',
  'goog.i18n.CompactNumberFormatSymbols_hr_HR',
  'goog.i18n.CompactNumberFormatSymbols_hu',
  'goog.i18n.CompactNumberFormatSymbols_hu_HU',
  'goog.i18n.CompactNumberFormatSymbols_id',
  'goog.i18n.CompactNumberFormatSymbols_id_ID',
  'goog.i18n.CompactNumberFormatSymbols_in',
  'goog.i18n.CompactNumberFormatSymbols_is',
  'goog.i18n.CompactNumberFormatSymbols_is_IS',
  'goog.i18n.CompactNumberFormatSymbols_it',
  'goog.i18n.CompactNumberFormatSymbols_it_IT',
  'goog.i18n.CompactNumberFormatSymbols_it_SM',
  'goog.i18n.CompactNumberFormatSymbols_iw',
  'goog.i18n.CompactNumberFormatSymbols_ja',
  'goog.i18n.CompactNumberFormatSymbols_ja_JP',
  'goog.i18n.CompactNumberFormatSymbols_kn',
  'goog.i18n.CompactNumberFormatSymbols_kn_IN',
  'goog.i18n.CompactNumberFormatSymbols_ko',
  'goog.i18n.CompactNumberFormatSymbols_ko_KR',
  'goog.i18n.CompactNumberFormatSymbols_ln',
  'goog.i18n.CompactNumberFormatSymbols_ln_CD',
  'goog.i18n.CompactNumberFormatSymbols_lt',
  'goog.i18n.CompactNumberFormatSymbols_lt_LT',
  'goog.i18n.CompactNumberFormatSymbols_lv',
  'goog.i18n.CompactNumberFormatSymbols_lv_LV',
  'goog.i18n.CompactNumberFormatSymbols_ml',
  'goog.i18n.CompactNumberFormatSymbols_ml_IN',
  'goog.i18n.CompactNumberFormatSymbols_mr',
  'goog.i18n.CompactNumberFormatSymbols_mr_IN',
  'goog.i18n.CompactNumberFormatSymbols_ms',
  'goog.i18n.CompactNumberFormatSymbols_ms_Latn_MY',
  'goog.i18n.CompactNumberFormatSymbols_mt',
  'goog.i18n.CompactNumberFormatSymbols_mt_MT',
  'goog.i18n.CompactNumberFormatSymbols_nb',
  'goog.i18n.CompactNumberFormatSymbols_nb_NO',
  'goog.i18n.CompactNumberFormatSymbols_nl',
  'goog.i18n.CompactNumberFormatSymbols_nl_NL',
  'goog.i18n.CompactNumberFormatSymbols_no',
  'goog.i18n.CompactNumberFormatSymbols_or',
  'goog.i18n.CompactNumberFormatSymbols_or_IN',
  'goog.i18n.CompactNumberFormatSymbols_pl',
  'goog.i18n.CompactNumberFormatSymbols_pl_PL',
  'goog.i18n.CompactNumberFormatSymbols_pt',
  'goog.i18n.CompactNumberFormatSymbols_pt_BR',
  'goog.i18n.CompactNumberFormatSymbols_pt_PT',
  'goog.i18n.CompactNumberFormatSymbols_ro',
  'goog.i18n.CompactNumberFormatSymbols_ro_RO',
  'goog.i18n.CompactNumberFormatSymbols_ru',
  'goog.i18n.CompactNumberFormatSymbols_ru_RU',
  'goog.i18n.CompactNumberFormatSymbols_sk',
  'goog.i18n.CompactNumberFormatSymbols_sk_SK',
  'goog.i18n.CompactNumberFormatSymbols_sl',
  'goog.i18n.CompactNumberFormatSymbols_sl_SI',
  'goog.i18n.CompactNumberFormatSymbols_sq',
  'goog.i18n.CompactNumberFormatSymbols_sq_AL',
  'goog.i18n.CompactNumberFormatSymbols_sr',
  'goog.i18n.CompactNumberFormatSymbols_sr_Cyrl_RS',
  'goog.i18n.CompactNumberFormatSymbols_sv',
  'goog.i18n.CompactNumberFormatSymbols_sv_SE',
  'goog.i18n.CompactNumberFormatSymbols_sw',
  'goog.i18n.CompactNumberFormatSymbols_sw_TZ',
  'goog.i18n.CompactNumberFormatSymbols_ta',
  'goog.i18n.CompactNumberFormatSymbols_ta_IN',
  'goog.i18n.CompactNumberFormatSymbols_te',
  'goog.i18n.CompactNumberFormatSymbols_te_IN',
  'goog.i18n.CompactNumberFormatSymbols_th',
  'goog.i18n.CompactNumberFormatSymbols_th_TH',
  'goog.i18n.CompactNumberFormatSymbols_tl',
  'goog.i18n.CompactNumberFormatSymbols_tr',
  'goog.i18n.CompactNumberFormatSymbols_tr_TR',
  'goog.i18n.CompactNumberFormatSymbols_uk',
  'goog.i18n.CompactNumberFormatSymbols_uk_UA',
  'goog.i18n.CompactNumberFormatSymbols_ur',
  'goog.i18n.CompactNumberFormatSymbols_ur_PK',
  'goog.i18n.CompactNumberFormatSymbols_vi',
  'goog.i18n.CompactNumberFormatSymbols_vi_VN',
  'goog.i18n.CompactNumberFormatSymbols_zh',
  'goog.i18n.CompactNumberFormatSymbols_zh_CN',
  'goog.i18n.CompactNumberFormatSymbols_zh_HK',
  'goog.i18n.CompactNumberFormatSymbols_zh_Hans_CN',
  'goog.i18n.CompactNumberFormatSymbols_zh_TW',
  'goog.i18n.CompactNumberFormatSymbols_zu',
  'goog.i18n.CompactNumberFormatSymbols_zu_ZA'
], []);
goog.addDependency('i18n/compactnumberformatsymbols_ext.js', [
  'goog.i18n.CompactNumberFormatSymbolsExt',
  'goog.i18n.CompactNumberFormatSymbols_aa',
  'goog.i18n.CompactNumberFormatSymbols_aa_DJ',
  'goog.i18n.CompactNumberFormatSymbols_aa_ER',
  'goog.i18n.CompactNumberFormatSymbols_aa_ET',
  'goog.i18n.CompactNumberFormatSymbols_af_NA',
  'goog.i18n.CompactNumberFormatSymbols_agq',
  'goog.i18n.CompactNumberFormatSymbols_agq_CM',
  'goog.i18n.CompactNumberFormatSymbols_ak',
  'goog.i18n.CompactNumberFormatSymbols_ak_GH',
  'goog.i18n.CompactNumberFormatSymbols_ar_AE',
  'goog.i18n.CompactNumberFormatSymbols_ar_BH',
  'goog.i18n.CompactNumberFormatSymbols_ar_DJ',
  'goog.i18n.CompactNumberFormatSymbols_ar_DZ',
  'goog.i18n.CompactNumberFormatSymbols_ar_EH',
  'goog.i18n.CompactNumberFormatSymbols_ar_ER',
  'goog.i18n.CompactNumberFormatSymbols_ar_IL',
  'goog.i18n.CompactNumberFormatSymbols_ar_IQ',
  'goog.i18n.CompactNumberFormatSymbols_ar_JO',
  'goog.i18n.CompactNumberFormatSymbols_ar_KM',
  'goog.i18n.CompactNumberFormatSymbols_ar_KW',
  'goog.i18n.CompactNumberFormatSymbols_ar_LB',
  'goog.i18n.CompactNumberFormatSymbols_ar_LY',
  'goog.i18n.CompactNumberFormatSymbols_ar_MA',
  'goog.i18n.CompactNumberFormatSymbols_ar_MR',
  'goog.i18n.CompactNumberFormatSymbols_ar_OM',
  'goog.i18n.CompactNumberFormatSymbols_ar_PS',
  'goog.i18n.CompactNumberFormatSymbols_ar_QA',
  'goog.i18n.CompactNumberFormatSymbols_ar_SA',
  'goog.i18n.CompactNumberFormatSymbols_ar_SD',
  'goog.i18n.CompactNumberFormatSymbols_ar_SO',
  'goog.i18n.CompactNumberFormatSymbols_ar_SY',
  'goog.i18n.CompactNumberFormatSymbols_ar_TD',
  'goog.i18n.CompactNumberFormatSymbols_ar_TN',
  'goog.i18n.CompactNumberFormatSymbols_ar_YE',
  'goog.i18n.CompactNumberFormatSymbols_as',
  'goog.i18n.CompactNumberFormatSymbols_as_IN',
  'goog.i18n.CompactNumberFormatSymbols_asa',
  'goog.i18n.CompactNumberFormatSymbols_asa_TZ',
  'goog.i18n.CompactNumberFormatSymbols_ast',
  'goog.i18n.CompactNumberFormatSymbols_ast_ES',
  'goog.i18n.CompactNumberFormatSymbols_az',
  'goog.i18n.CompactNumberFormatSymbols_az_Cyrl',
  'goog.i18n.CompactNumberFormatSymbols_az_Cyrl_AZ',
  'goog.i18n.CompactNumberFormatSymbols_az_Latn',
  'goog.i18n.CompactNumberFormatSymbols_az_Latn_AZ',
  'goog.i18n.CompactNumberFormatSymbols_bas',
  'goog.i18n.CompactNumberFormatSymbols_bas_CM',
  'goog.i18n.CompactNumberFormatSymbols_be',
  'goog.i18n.CompactNumberFormatSymbols_be_BY',
  'goog.i18n.CompactNumberFormatSymbols_bem',
  'goog.i18n.CompactNumberFormatSymbols_bem_ZM',
  'goog.i18n.CompactNumberFormatSymbols_bez',
  'goog.i18n.CompactNumberFormatSymbols_bez_TZ',
  'goog.i18n.CompactNumberFormatSymbols_bm',
  'goog.i18n.CompactNumberFormatSymbols_bm_ML',
  'goog.i18n.CompactNumberFormatSymbols_bn_IN',
  'goog.i18n.CompactNumberFormatSymbols_bo',
  'goog.i18n.CompactNumberFormatSymbols_bo_CN',
  'goog.i18n.CompactNumberFormatSymbols_bo_IN',
  'goog.i18n.CompactNumberFormatSymbols_brx',
  'goog.i18n.CompactNumberFormatSymbols_brx_IN',
  'goog.i18n.CompactNumberFormatSymbols_bs',
  'goog.i18n.CompactNumberFormatSymbols_bs_Cyrl',
  'goog.i18n.CompactNumberFormatSymbols_bs_Cyrl_BA',
  'goog.i18n.CompactNumberFormatSymbols_bs_Latn',
  'goog.i18n.CompactNumberFormatSymbols_bs_Latn_BA',
  'goog.i18n.CompactNumberFormatSymbols_byn',
  'goog.i18n.CompactNumberFormatSymbols_byn_ER',
  'goog.i18n.CompactNumberFormatSymbols_cgg',
  'goog.i18n.CompactNumberFormatSymbols_cgg_UG',
  'goog.i18n.CompactNumberFormatSymbols_ckb',
  'goog.i18n.CompactNumberFormatSymbols_ckb_Arab',
  'goog.i18n.CompactNumberFormatSymbols_ckb_Arab_IQ',
  'goog.i18n.CompactNumberFormatSymbols_ckb_Arab_IR',
  'goog.i18n.CompactNumberFormatSymbols_ckb_IQ',
  'goog.i18n.CompactNumberFormatSymbols_ckb_IR',
  'goog.i18n.CompactNumberFormatSymbols_ckb_Latn',
  'goog.i18n.CompactNumberFormatSymbols_ckb_Latn_IQ',
  'goog.i18n.CompactNumberFormatSymbols_dav',
  'goog.i18n.CompactNumberFormatSymbols_dav_KE',
  'goog.i18n.CompactNumberFormatSymbols_de_LI',
  'goog.i18n.CompactNumberFormatSymbols_dje',
  'goog.i18n.CompactNumberFormatSymbols_dje_NE',
  'goog.i18n.CompactNumberFormatSymbols_dua',
  'goog.i18n.CompactNumberFormatSymbols_dua_CM',
  'goog.i18n.CompactNumberFormatSymbols_dyo',
  'goog.i18n.CompactNumberFormatSymbols_dyo_SN',
  'goog.i18n.CompactNumberFormatSymbols_dz',
  'goog.i18n.CompactNumberFormatSymbols_dz_BT',
  'goog.i18n.CompactNumberFormatSymbols_ebu',
  'goog.i18n.CompactNumberFormatSymbols_ebu_KE',
  'goog.i18n.CompactNumberFormatSymbols_ee',
  'goog.i18n.CompactNumberFormatSymbols_ee_GH',
  'goog.i18n.CompactNumberFormatSymbols_ee_TG',
  'goog.i18n.CompactNumberFormatSymbols_el_CY',
  'goog.i18n.CompactNumberFormatSymbols_en_150',
  'goog.i18n.CompactNumberFormatSymbols_en_AG',
  'goog.i18n.CompactNumberFormatSymbols_en_BB',
  'goog.i18n.CompactNumberFormatSymbols_en_BE',
  'goog.i18n.CompactNumberFormatSymbols_en_BM',
  'goog.i18n.CompactNumberFormatSymbols_en_BS',
  'goog.i18n.CompactNumberFormatSymbols_en_BW',
  'goog.i18n.CompactNumberFormatSymbols_en_BZ',
  'goog.i18n.CompactNumberFormatSymbols_en_CA',
  'goog.i18n.CompactNumberFormatSymbols_en_CM',
  'goog.i18n.CompactNumberFormatSymbols_en_DM',
  'goog.i18n.CompactNumberFormatSymbols_en_Dsrt',
  'goog.i18n.CompactNumberFormatSymbols_en_FJ',
  'goog.i18n.CompactNumberFormatSymbols_en_GD',
  'goog.i18n.CompactNumberFormatSymbols_en_GG',
  'goog.i18n.CompactNumberFormatSymbols_en_GH',
  'goog.i18n.CompactNumberFormatSymbols_en_GI',
  'goog.i18n.CompactNumberFormatSymbols_en_GM',
  'goog.i18n.CompactNumberFormatSymbols_en_GY',
  'goog.i18n.CompactNumberFormatSymbols_en_HK',
  'goog.i18n.CompactNumberFormatSymbols_en_IM',
  'goog.i18n.CompactNumberFormatSymbols_en_JE',
  'goog.i18n.CompactNumberFormatSymbols_en_JM',
  'goog.i18n.CompactNumberFormatSymbols_en_KE',
  'goog.i18n.CompactNumberFormatSymbols_en_KI',
  'goog.i18n.CompactNumberFormatSymbols_en_KN',
  'goog.i18n.CompactNumberFormatSymbols_en_KY',
  'goog.i18n.CompactNumberFormatSymbols_en_LC',
  'goog.i18n.CompactNumberFormatSymbols_en_LR',
  'goog.i18n.CompactNumberFormatSymbols_en_LS',
  'goog.i18n.CompactNumberFormatSymbols_en_MG',
  'goog.i18n.CompactNumberFormatSymbols_en_MT',
  'goog.i18n.CompactNumberFormatSymbols_en_MU',
  'goog.i18n.CompactNumberFormatSymbols_en_MW',
  'goog.i18n.CompactNumberFormatSymbols_en_NA',
  'goog.i18n.CompactNumberFormatSymbols_en_NG',
  'goog.i18n.CompactNumberFormatSymbols_en_NZ',
  'goog.i18n.CompactNumberFormatSymbols_en_PG',
  'goog.i18n.CompactNumberFormatSymbols_en_PH',
  'goog.i18n.CompactNumberFormatSymbols_en_PK',
  'goog.i18n.CompactNumberFormatSymbols_en_SB',
  'goog.i18n.CompactNumberFormatSymbols_en_SC',
  'goog.i18n.CompactNumberFormatSymbols_en_SL',
  'goog.i18n.CompactNumberFormatSymbols_en_SS',
  'goog.i18n.CompactNumberFormatSymbols_en_SZ',
  'goog.i18n.CompactNumberFormatSymbols_en_TO',
  'goog.i18n.CompactNumberFormatSymbols_en_TT',
  'goog.i18n.CompactNumberFormatSymbols_en_TZ',
  'goog.i18n.CompactNumberFormatSymbols_en_UG',
  'goog.i18n.CompactNumberFormatSymbols_en_VC',
  'goog.i18n.CompactNumberFormatSymbols_en_VU',
  'goog.i18n.CompactNumberFormatSymbols_en_WS',
  'goog.i18n.CompactNumberFormatSymbols_en_ZM',
  'goog.i18n.CompactNumberFormatSymbols_en_ZW',
  'goog.i18n.CompactNumberFormatSymbols_eo',
  'goog.i18n.CompactNumberFormatSymbols_es_AR',
  'goog.i18n.CompactNumberFormatSymbols_es_BO',
  'goog.i18n.CompactNumberFormatSymbols_es_CL',
  'goog.i18n.CompactNumberFormatSymbols_es_CO',
  'goog.i18n.CompactNumberFormatSymbols_es_CR',
  'goog.i18n.CompactNumberFormatSymbols_es_CU',
  'goog.i18n.CompactNumberFormatSymbols_es_DO',
  'goog.i18n.CompactNumberFormatSymbols_es_EC',
  'goog.i18n.CompactNumberFormatSymbols_es_GQ',
  'goog.i18n.CompactNumberFormatSymbols_es_GT',
  'goog.i18n.CompactNumberFormatSymbols_es_HN',
  'goog.i18n.CompactNumberFormatSymbols_es_MX',
  'goog.i18n.CompactNumberFormatSymbols_es_NI',
  'goog.i18n.CompactNumberFormatSymbols_es_PA',
  'goog.i18n.CompactNumberFormatSymbols_es_PE',
  'goog.i18n.CompactNumberFormatSymbols_es_PH',
  'goog.i18n.CompactNumberFormatSymbols_es_PR',
  'goog.i18n.CompactNumberFormatSymbols_es_PY',
  'goog.i18n.CompactNumberFormatSymbols_es_SV',
  'goog.i18n.CompactNumberFormatSymbols_es_US',
  'goog.i18n.CompactNumberFormatSymbols_es_UY',
  'goog.i18n.CompactNumberFormatSymbols_es_VE',
  'goog.i18n.CompactNumberFormatSymbols_ewo',
  'goog.i18n.CompactNumberFormatSymbols_ewo_CM',
  'goog.i18n.CompactNumberFormatSymbols_fa_AF',
  'goog.i18n.CompactNumberFormatSymbols_ff',
  'goog.i18n.CompactNumberFormatSymbols_ff_SN',
  'goog.i18n.CompactNumberFormatSymbols_fo',
  'goog.i18n.CompactNumberFormatSymbols_fo_FO',
  'goog.i18n.CompactNumberFormatSymbols_fr_BE',
  'goog.i18n.CompactNumberFormatSymbols_fr_BF',
  'goog.i18n.CompactNumberFormatSymbols_fr_BI',
  'goog.i18n.CompactNumberFormatSymbols_fr_BJ',
  'goog.i18n.CompactNumberFormatSymbols_fr_CD',
  'goog.i18n.CompactNumberFormatSymbols_fr_CF',
  'goog.i18n.CompactNumberFormatSymbols_fr_CG',
  'goog.i18n.CompactNumberFormatSymbols_fr_CH',
  'goog.i18n.CompactNumberFormatSymbols_fr_CI',
  'goog.i18n.CompactNumberFormatSymbols_fr_CM',
  'goog.i18n.CompactNumberFormatSymbols_fr_DJ',
  'goog.i18n.CompactNumberFormatSymbols_fr_DZ',
  'goog.i18n.CompactNumberFormatSymbols_fr_GA',
  'goog.i18n.CompactNumberFormatSymbols_fr_GN',
  'goog.i18n.CompactNumberFormatSymbols_fr_GQ',
  'goog.i18n.CompactNumberFormatSymbols_fr_HT',
  'goog.i18n.CompactNumberFormatSymbols_fr_KM',
  'goog.i18n.CompactNumberFormatSymbols_fr_LU',
  'goog.i18n.CompactNumberFormatSymbols_fr_MA',
  'goog.i18n.CompactNumberFormatSymbols_fr_MG',
  'goog.i18n.CompactNumberFormatSymbols_fr_ML',
  'goog.i18n.CompactNumberFormatSymbols_fr_MR',
  'goog.i18n.CompactNumberFormatSymbols_fr_MU',
  'goog.i18n.CompactNumberFormatSymbols_fr_NC',
  'goog.i18n.CompactNumberFormatSymbols_fr_NE',
  'goog.i18n.CompactNumberFormatSymbols_fr_PF',
  'goog.i18n.CompactNumberFormatSymbols_fr_RW',
  'goog.i18n.CompactNumberFormatSymbols_fr_SC',
  'goog.i18n.CompactNumberFormatSymbols_fr_SN',
  'goog.i18n.CompactNumberFormatSymbols_fr_SY',
  'goog.i18n.CompactNumberFormatSymbols_fr_TD',
  'goog.i18n.CompactNumberFormatSymbols_fr_TG',
  'goog.i18n.CompactNumberFormatSymbols_fr_TN',
  'goog.i18n.CompactNumberFormatSymbols_fr_VU',
  'goog.i18n.CompactNumberFormatSymbols_fur',
  'goog.i18n.CompactNumberFormatSymbols_fur_IT',
  'goog.i18n.CompactNumberFormatSymbols_ga',
  'goog.i18n.CompactNumberFormatSymbols_ga_IE',
  'goog.i18n.CompactNumberFormatSymbols_gd',
  'goog.i18n.CompactNumberFormatSymbols_gd_GB',
  'goog.i18n.CompactNumberFormatSymbols_guz',
  'goog.i18n.CompactNumberFormatSymbols_guz_KE',
  'goog.i18n.CompactNumberFormatSymbols_gv',
  'goog.i18n.CompactNumberFormatSymbols_gv_GB',
  'goog.i18n.CompactNumberFormatSymbols_ha',
  'goog.i18n.CompactNumberFormatSymbols_ha_Latn',
  'goog.i18n.CompactNumberFormatSymbols_ha_Latn_GH',
  'goog.i18n.CompactNumberFormatSymbols_ha_Latn_NE',
  'goog.i18n.CompactNumberFormatSymbols_ha_Latn_NG',
  'goog.i18n.CompactNumberFormatSymbols_hr_BA',
  'goog.i18n.CompactNumberFormatSymbols_hy',
  'goog.i18n.CompactNumberFormatSymbols_hy_AM',
  'goog.i18n.CompactNumberFormatSymbols_ia',
  'goog.i18n.CompactNumberFormatSymbols_ia_FR',
  'goog.i18n.CompactNumberFormatSymbols_ig',
  'goog.i18n.CompactNumberFormatSymbols_ig_NG',
  'goog.i18n.CompactNumberFormatSymbols_ii',
  'goog.i18n.CompactNumberFormatSymbols_ii_CN',
  'goog.i18n.CompactNumberFormatSymbols_it_CH',
  'goog.i18n.CompactNumberFormatSymbols_jgo',
  'goog.i18n.CompactNumberFormatSymbols_jgo_CM',
  'goog.i18n.CompactNumberFormatSymbols_jmc',
  'goog.i18n.CompactNumberFormatSymbols_jmc_TZ',
  'goog.i18n.CompactNumberFormatSymbols_ka',
  'goog.i18n.CompactNumberFormatSymbols_ka_GE',
  'goog.i18n.CompactNumberFormatSymbols_kab',
  'goog.i18n.CompactNumberFormatSymbols_kab_DZ',
  'goog.i18n.CompactNumberFormatSymbols_kam',
  'goog.i18n.CompactNumberFormatSymbols_kam_KE',
  'goog.i18n.CompactNumberFormatSymbols_kde',
  'goog.i18n.CompactNumberFormatSymbols_kde_TZ',
  'goog.i18n.CompactNumberFormatSymbols_kea',
  'goog.i18n.CompactNumberFormatSymbols_kea_CV',
  'goog.i18n.CompactNumberFormatSymbols_khq',
  'goog.i18n.CompactNumberFormatSymbols_khq_ML',
  'goog.i18n.CompactNumberFormatSymbols_ki',
  'goog.i18n.CompactNumberFormatSymbols_ki_KE',
  'goog.i18n.CompactNumberFormatSymbols_kk',
  'goog.i18n.CompactNumberFormatSymbols_kk_Cyrl',
  'goog.i18n.CompactNumberFormatSymbols_kk_Cyrl_KZ',
  'goog.i18n.CompactNumberFormatSymbols_kkj',
  'goog.i18n.CompactNumberFormatSymbols_kkj_CM',
  'goog.i18n.CompactNumberFormatSymbols_kl',
  'goog.i18n.CompactNumberFormatSymbols_kl_GL',
  'goog.i18n.CompactNumberFormatSymbols_kln',
  'goog.i18n.CompactNumberFormatSymbols_kln_KE',
  'goog.i18n.CompactNumberFormatSymbols_km',
  'goog.i18n.CompactNumberFormatSymbols_km_KH',
  'goog.i18n.CompactNumberFormatSymbols_ko_KP',
  'goog.i18n.CompactNumberFormatSymbols_kok',
  'goog.i18n.CompactNumberFormatSymbols_kok_IN',
  'goog.i18n.CompactNumberFormatSymbols_ks',
  'goog.i18n.CompactNumberFormatSymbols_ks_Arab',
  'goog.i18n.CompactNumberFormatSymbols_ks_Arab_IN',
  'goog.i18n.CompactNumberFormatSymbols_ksb',
  'goog.i18n.CompactNumberFormatSymbols_ksb_TZ',
  'goog.i18n.CompactNumberFormatSymbols_ksf',
  'goog.i18n.CompactNumberFormatSymbols_ksf_CM',
  'goog.i18n.CompactNumberFormatSymbols_ksh',
  'goog.i18n.CompactNumberFormatSymbols_ksh_DE',
  'goog.i18n.CompactNumberFormatSymbols_kw',
  'goog.i18n.CompactNumberFormatSymbols_kw_GB',
  'goog.i18n.CompactNumberFormatSymbols_ky',
  'goog.i18n.CompactNumberFormatSymbols_ky_KG',
  'goog.i18n.CompactNumberFormatSymbols_lag',
  'goog.i18n.CompactNumberFormatSymbols_lag_TZ',
  'goog.i18n.CompactNumberFormatSymbols_lg',
  'goog.i18n.CompactNumberFormatSymbols_lg_UG',
  'goog.i18n.CompactNumberFormatSymbols_ln_AO',
  'goog.i18n.CompactNumberFormatSymbols_ln_CF',
  'goog.i18n.CompactNumberFormatSymbols_ln_CG',
  'goog.i18n.CompactNumberFormatSymbols_lo',
  'goog.i18n.CompactNumberFormatSymbols_lo_LA',
  'goog.i18n.CompactNumberFormatSymbols_lu',
  'goog.i18n.CompactNumberFormatSymbols_lu_CD',
  'goog.i18n.CompactNumberFormatSymbols_luo',
  'goog.i18n.CompactNumberFormatSymbols_luo_KE',
  'goog.i18n.CompactNumberFormatSymbols_luy',
  'goog.i18n.CompactNumberFormatSymbols_luy_KE',
  'goog.i18n.CompactNumberFormatSymbols_mas',
  'goog.i18n.CompactNumberFormatSymbols_mas_KE',
  'goog.i18n.CompactNumberFormatSymbols_mas_TZ',
  'goog.i18n.CompactNumberFormatSymbols_mer',
  'goog.i18n.CompactNumberFormatSymbols_mer_KE',
  'goog.i18n.CompactNumberFormatSymbols_mfe',
  'goog.i18n.CompactNumberFormatSymbols_mfe_MU',
  'goog.i18n.CompactNumberFormatSymbols_mg',
  'goog.i18n.CompactNumberFormatSymbols_mg_MG',
  'goog.i18n.CompactNumberFormatSymbols_mgh',
  'goog.i18n.CompactNumberFormatSymbols_mgh_MZ',
  'goog.i18n.CompactNumberFormatSymbols_mgo',
  'goog.i18n.CompactNumberFormatSymbols_mgo_CM',
  'goog.i18n.CompactNumberFormatSymbols_mk',
  'goog.i18n.CompactNumberFormatSymbols_mk_MK',
  'goog.i18n.CompactNumberFormatSymbols_mn',
  'goog.i18n.CompactNumberFormatSymbols_mn_Cyrl',
  'goog.i18n.CompactNumberFormatSymbols_mn_Cyrl_MN',
  'goog.i18n.CompactNumberFormatSymbols_ms_Latn',
  'goog.i18n.CompactNumberFormatSymbols_ms_Latn_BN',
  'goog.i18n.CompactNumberFormatSymbols_ms_Latn_SG',
  'goog.i18n.CompactNumberFormatSymbols_mua',
  'goog.i18n.CompactNumberFormatSymbols_mua_CM',
  'goog.i18n.CompactNumberFormatSymbols_my',
  'goog.i18n.CompactNumberFormatSymbols_my_MM',
  'goog.i18n.CompactNumberFormatSymbols_naq',
  'goog.i18n.CompactNumberFormatSymbols_naq_NA',
  'goog.i18n.CompactNumberFormatSymbols_nd',
  'goog.i18n.CompactNumberFormatSymbols_nd_ZW',
  'goog.i18n.CompactNumberFormatSymbols_ne',
  'goog.i18n.CompactNumberFormatSymbols_ne_IN',
  'goog.i18n.CompactNumberFormatSymbols_ne_NP',
  'goog.i18n.CompactNumberFormatSymbols_nl_AW',
  'goog.i18n.CompactNumberFormatSymbols_nl_BE',
  'goog.i18n.CompactNumberFormatSymbols_nl_CW',
  'goog.i18n.CompactNumberFormatSymbols_nl_SR',
  'goog.i18n.CompactNumberFormatSymbols_nl_SX',
  'goog.i18n.CompactNumberFormatSymbols_nmg',
  'goog.i18n.CompactNumberFormatSymbols_nmg_CM',
  'goog.i18n.CompactNumberFormatSymbols_nn',
  'goog.i18n.CompactNumberFormatSymbols_nn_NO',
  'goog.i18n.CompactNumberFormatSymbols_nnh',
  'goog.i18n.CompactNumberFormatSymbols_nnh_CM',
  'goog.i18n.CompactNumberFormatSymbols_nr',
  'goog.i18n.CompactNumberFormatSymbols_nr_ZA',
  'goog.i18n.CompactNumberFormatSymbols_nso',
  'goog.i18n.CompactNumberFormatSymbols_nso_ZA',
  'goog.i18n.CompactNumberFormatSymbols_nus',
  'goog.i18n.CompactNumberFormatSymbols_nus_SD',
  'goog.i18n.CompactNumberFormatSymbols_nyn',
  'goog.i18n.CompactNumberFormatSymbols_nyn_UG',
  'goog.i18n.CompactNumberFormatSymbols_om',
  'goog.i18n.CompactNumberFormatSymbols_om_ET',
  'goog.i18n.CompactNumberFormatSymbols_om_KE',
  'goog.i18n.CompactNumberFormatSymbols_os',
  'goog.i18n.CompactNumberFormatSymbols_os_GE',
  'goog.i18n.CompactNumberFormatSymbols_os_RU',
  'goog.i18n.CompactNumberFormatSymbols_pa',
  'goog.i18n.CompactNumberFormatSymbols_pa_Arab',
  'goog.i18n.CompactNumberFormatSymbols_pa_Arab_PK',
  'goog.i18n.CompactNumberFormatSymbols_pa_Guru',
  'goog.i18n.CompactNumberFormatSymbols_pa_Guru_IN',
  'goog.i18n.CompactNumberFormatSymbols_ps',
  'goog.i18n.CompactNumberFormatSymbols_ps_AF',
  'goog.i18n.CompactNumberFormatSymbols_pt_AO',
  'goog.i18n.CompactNumberFormatSymbols_pt_CV',
  'goog.i18n.CompactNumberFormatSymbols_pt_GW',
  'goog.i18n.CompactNumberFormatSymbols_pt_MO',
  'goog.i18n.CompactNumberFormatSymbols_pt_MZ',
  'goog.i18n.CompactNumberFormatSymbols_pt_ST',
  'goog.i18n.CompactNumberFormatSymbols_pt_TL',
  'goog.i18n.CompactNumberFormatSymbols_rm',
  'goog.i18n.CompactNumberFormatSymbols_rm_CH',
  'goog.i18n.CompactNumberFormatSymbols_rn',
  'goog.i18n.CompactNumberFormatSymbols_rn_BI',
  'goog.i18n.CompactNumberFormatSymbols_ro_MD',
  'goog.i18n.CompactNumberFormatSymbols_rof',
  'goog.i18n.CompactNumberFormatSymbols_rof_TZ',
  'goog.i18n.CompactNumberFormatSymbols_ru_BY',
  'goog.i18n.CompactNumberFormatSymbols_ru_KG',
  'goog.i18n.CompactNumberFormatSymbols_ru_KZ',
  'goog.i18n.CompactNumberFormatSymbols_ru_MD',
  'goog.i18n.CompactNumberFormatSymbols_ru_UA',
  'goog.i18n.CompactNumberFormatSymbols_rw',
  'goog.i18n.CompactNumberFormatSymbols_rw_RW',
  'goog.i18n.CompactNumberFormatSymbols_rwk',
  'goog.i18n.CompactNumberFormatSymbols_rwk_TZ',
  'goog.i18n.CompactNumberFormatSymbols_sah',
  'goog.i18n.CompactNumberFormatSymbols_sah_RU',
  'goog.i18n.CompactNumberFormatSymbols_saq',
  'goog.i18n.CompactNumberFormatSymbols_saq_KE',
  'goog.i18n.CompactNumberFormatSymbols_sbp',
  'goog.i18n.CompactNumberFormatSymbols_sbp_TZ',
  'goog.i18n.CompactNumberFormatSymbols_se',
  'goog.i18n.CompactNumberFormatSymbols_se_FI',
  'goog.i18n.CompactNumberFormatSymbols_se_NO',
  'goog.i18n.CompactNumberFormatSymbols_seh',
  'goog.i18n.CompactNumberFormatSymbols_seh_MZ',
  'goog.i18n.CompactNumberFormatSymbols_ses',
  'goog.i18n.CompactNumberFormatSymbols_ses_ML',
  'goog.i18n.CompactNumberFormatSymbols_sg',
  'goog.i18n.CompactNumberFormatSymbols_sg_CF',
  'goog.i18n.CompactNumberFormatSymbols_shi',
  'goog.i18n.CompactNumberFormatSymbols_shi_Latn',
  'goog.i18n.CompactNumberFormatSymbols_shi_Latn_MA',
  'goog.i18n.CompactNumberFormatSymbols_shi_Tfng',
  'goog.i18n.CompactNumberFormatSymbols_shi_Tfng_MA',
  'goog.i18n.CompactNumberFormatSymbols_si',
  'goog.i18n.CompactNumberFormatSymbols_si_LK',
  'goog.i18n.CompactNumberFormatSymbols_sn',
  'goog.i18n.CompactNumberFormatSymbols_sn_ZW',
  'goog.i18n.CompactNumberFormatSymbols_so',
  'goog.i18n.CompactNumberFormatSymbols_so_DJ',
  'goog.i18n.CompactNumberFormatSymbols_so_ET',
  'goog.i18n.CompactNumberFormatSymbols_so_KE',
  'goog.i18n.CompactNumberFormatSymbols_so_SO',
  'goog.i18n.CompactNumberFormatSymbols_sq_MK',
  'goog.i18n.CompactNumberFormatSymbols_sq_XK',
  'goog.i18n.CompactNumberFormatSymbols_sr_Cyrl',
  'goog.i18n.CompactNumberFormatSymbols_sr_Cyrl_BA',
  'goog.i18n.CompactNumberFormatSymbols_sr_Cyrl_ME',
  'goog.i18n.CompactNumberFormatSymbols_sr_Cyrl_XK',
  'goog.i18n.CompactNumberFormatSymbols_sr_Latn',
  'goog.i18n.CompactNumberFormatSymbols_sr_Latn_BA',
  'goog.i18n.CompactNumberFormatSymbols_sr_Latn_ME',
  'goog.i18n.CompactNumberFormatSymbols_sr_Latn_RS',
  'goog.i18n.CompactNumberFormatSymbols_sr_Latn_XK',
  'goog.i18n.CompactNumberFormatSymbols_ss',
  'goog.i18n.CompactNumberFormatSymbols_ss_SZ',
  'goog.i18n.CompactNumberFormatSymbols_ss_ZA',
  'goog.i18n.CompactNumberFormatSymbols_ssy',
  'goog.i18n.CompactNumberFormatSymbols_ssy_ER',
  'goog.i18n.CompactNumberFormatSymbols_st',
  'goog.i18n.CompactNumberFormatSymbols_st_LS',
  'goog.i18n.CompactNumberFormatSymbols_st_ZA',
  'goog.i18n.CompactNumberFormatSymbols_sv_AX',
  'goog.i18n.CompactNumberFormatSymbols_sv_FI',
  'goog.i18n.CompactNumberFormatSymbols_sw_KE',
  'goog.i18n.CompactNumberFormatSymbols_sw_UG',
  'goog.i18n.CompactNumberFormatSymbols_swc',
  'goog.i18n.CompactNumberFormatSymbols_swc_CD',
  'goog.i18n.CompactNumberFormatSymbols_ta_LK',
  'goog.i18n.CompactNumberFormatSymbols_ta_MY',
  'goog.i18n.CompactNumberFormatSymbols_ta_SG',
  'goog.i18n.CompactNumberFormatSymbols_teo',
  'goog.i18n.CompactNumberFormatSymbols_teo_KE',
  'goog.i18n.CompactNumberFormatSymbols_teo_UG',
  'goog.i18n.CompactNumberFormatSymbols_tg',
  'goog.i18n.CompactNumberFormatSymbols_tg_Cyrl',
  'goog.i18n.CompactNumberFormatSymbols_tg_Cyrl_TJ',
  'goog.i18n.CompactNumberFormatSymbols_ti',
  'goog.i18n.CompactNumberFormatSymbols_ti_ER',
  'goog.i18n.CompactNumberFormatSymbols_ti_ET',
  'goog.i18n.CompactNumberFormatSymbols_tig',
  'goog.i18n.CompactNumberFormatSymbols_tig_ER',
  'goog.i18n.CompactNumberFormatSymbols_tn',
  'goog.i18n.CompactNumberFormatSymbols_tn_BW',
  'goog.i18n.CompactNumberFormatSymbols_tn_ZA',
  'goog.i18n.CompactNumberFormatSymbols_to',
  'goog.i18n.CompactNumberFormatSymbols_to_TO',
  'goog.i18n.CompactNumberFormatSymbols_tr_CY',
  'goog.i18n.CompactNumberFormatSymbols_ts',
  'goog.i18n.CompactNumberFormatSymbols_ts_ZA',
  'goog.i18n.CompactNumberFormatSymbols_twq',
  'goog.i18n.CompactNumberFormatSymbols_twq_NE',
  'goog.i18n.CompactNumberFormatSymbols_tzm',
  'goog.i18n.CompactNumberFormatSymbols_tzm_Latn',
  'goog.i18n.CompactNumberFormatSymbols_tzm_Latn_MA',
  'goog.i18n.CompactNumberFormatSymbols_ur_IN',
  'goog.i18n.CompactNumberFormatSymbols_uz',
  'goog.i18n.CompactNumberFormatSymbols_uz_Arab',
  'goog.i18n.CompactNumberFormatSymbols_uz_Arab_AF',
  'goog.i18n.CompactNumberFormatSymbols_uz_Cyrl',
  'goog.i18n.CompactNumberFormatSymbols_uz_Cyrl_UZ',
  'goog.i18n.CompactNumberFormatSymbols_uz_Latn',
  'goog.i18n.CompactNumberFormatSymbols_uz_Latn_UZ',
  'goog.i18n.CompactNumberFormatSymbols_vai',
  'goog.i18n.CompactNumberFormatSymbols_vai_Latn',
  'goog.i18n.CompactNumberFormatSymbols_vai_Latn_LR',
  'goog.i18n.CompactNumberFormatSymbols_vai_Vaii',
  'goog.i18n.CompactNumberFormatSymbols_vai_Vaii_LR',
  'goog.i18n.CompactNumberFormatSymbols_ve',
  'goog.i18n.CompactNumberFormatSymbols_ve_ZA',
  'goog.i18n.CompactNumberFormatSymbols_vo',
  'goog.i18n.CompactNumberFormatSymbols_vun',
  'goog.i18n.CompactNumberFormatSymbols_vun_TZ',
  'goog.i18n.CompactNumberFormatSymbols_wae',
  'goog.i18n.CompactNumberFormatSymbols_wae_CH',
  'goog.i18n.CompactNumberFormatSymbols_wal',
  'goog.i18n.CompactNumberFormatSymbols_wal_ET',
  'goog.i18n.CompactNumberFormatSymbols_xh',
  'goog.i18n.CompactNumberFormatSymbols_xh_ZA',
  'goog.i18n.CompactNumberFormatSymbols_xog',
  'goog.i18n.CompactNumberFormatSymbols_xog_UG',
  'goog.i18n.CompactNumberFormatSymbols_yav',
  'goog.i18n.CompactNumberFormatSymbols_yav_CM',
  'goog.i18n.CompactNumberFormatSymbols_yo',
  'goog.i18n.CompactNumberFormatSymbols_yo_NG',
  'goog.i18n.CompactNumberFormatSymbols_zh_Hans',
  'goog.i18n.CompactNumberFormatSymbols_zh_Hans_HK',
  'goog.i18n.CompactNumberFormatSymbols_zh_Hans_MO',
  'goog.i18n.CompactNumberFormatSymbols_zh_Hans_SG',
  'goog.i18n.CompactNumberFormatSymbols_zh_Hant',
  'goog.i18n.CompactNumberFormatSymbols_zh_Hant_HK',
  'goog.i18n.CompactNumberFormatSymbols_zh_Hant_MO',
  'goog.i18n.CompactNumberFormatSymbols_zh_Hant_TW'
], []);
goog.addDependency('i18n/currency.js', [
  'goog.i18n.currency',
  'goog.i18n.currency.CurrencyInfo',
  'goog.i18n.currency.CurrencyInfoTier2'
], []);
goog.addDependency('i18n/currencycodemap.js', [
  'goog.i18n.currencyCodeMap',
  'goog.i18n.currencyCodeMapTier2'
], []);
goog.addDependency('i18n/datetimeformat.js', [
  'goog.i18n.DateTimeFormat',
  'goog.i18n.DateTimeFormat.Format'
], [
  'goog.asserts',
  'goog.i18n.DateTimeSymbols',
  'goog.i18n.TimeZone',
  'goog.string'
]);
goog.addDependency('i18n/datetimeparse.js', ['goog.i18n.DateTimeParse'], [
  'goog.i18n.DateTimeFormat',
  'goog.i18n.DateTimeSymbols'
]);
goog.addDependency('i18n/datetimepatterns.js', [
  'goog.i18n.DateTimePatterns',
  'goog.i18n.DateTimePatterns_af',
  'goog.i18n.DateTimePatterns_am',
  'goog.i18n.DateTimePatterns_ar',
  'goog.i18n.DateTimePatterns_bg',
  'goog.i18n.DateTimePatterns_bn',
  'goog.i18n.DateTimePatterns_br',
  'goog.i18n.DateTimePatterns_ca',
  'goog.i18n.DateTimePatterns_chr',
  'goog.i18n.DateTimePatterns_cs',
  'goog.i18n.DateTimePatterns_cy',
  'goog.i18n.DateTimePatterns_da',
  'goog.i18n.DateTimePatterns_de',
  'goog.i18n.DateTimePatterns_de_AT',
  'goog.i18n.DateTimePatterns_de_CH',
  'goog.i18n.DateTimePatterns_el',
  'goog.i18n.DateTimePatterns_en',
  'goog.i18n.DateTimePatterns_en_AU',
  'goog.i18n.DateTimePatterns_en_GB',
  'goog.i18n.DateTimePatterns_en_IE',
  'goog.i18n.DateTimePatterns_en_IN',
  'goog.i18n.DateTimePatterns_en_SG',
  'goog.i18n.DateTimePatterns_en_US',
  'goog.i18n.DateTimePatterns_en_ZA',
  'goog.i18n.DateTimePatterns_es',
  'goog.i18n.DateTimePatterns_es_419',
  'goog.i18n.DateTimePatterns_es_ES',
  'goog.i18n.DateTimePatterns_et',
  'goog.i18n.DateTimePatterns_eu',
  'goog.i18n.DateTimePatterns_fa',
  'goog.i18n.DateTimePatterns_fi',
  'goog.i18n.DateTimePatterns_fil',
  'goog.i18n.DateTimePatterns_fr',
  'goog.i18n.DateTimePatterns_fr_CA',
  'goog.i18n.DateTimePatterns_gl',
  'goog.i18n.DateTimePatterns_gsw',
  'goog.i18n.DateTimePatterns_gu',
  'goog.i18n.DateTimePatterns_haw',
  'goog.i18n.DateTimePatterns_he',
  'goog.i18n.DateTimePatterns_hi',
  'goog.i18n.DateTimePatterns_hr',
  'goog.i18n.DateTimePatterns_hu',
  'goog.i18n.DateTimePatterns_id',
  'goog.i18n.DateTimePatterns_in',
  'goog.i18n.DateTimePatterns_is',
  'goog.i18n.DateTimePatterns_it',
  'goog.i18n.DateTimePatterns_iw',
  'goog.i18n.DateTimePatterns_ja',
  'goog.i18n.DateTimePatterns_kn',
  'goog.i18n.DateTimePatterns_ko',
  'goog.i18n.DateTimePatterns_ln',
  'goog.i18n.DateTimePatterns_lt',
  'goog.i18n.DateTimePatterns_lv',
  'goog.i18n.DateTimePatterns_ml',
  'goog.i18n.DateTimePatterns_mo',
  'goog.i18n.DateTimePatterns_mr',
  'goog.i18n.DateTimePatterns_ms',
  'goog.i18n.DateTimePatterns_mt',
  'goog.i18n.DateTimePatterns_nb',
  'goog.i18n.DateTimePatterns_nl',
  'goog.i18n.DateTimePatterns_no',
  'goog.i18n.DateTimePatterns_or',
  'goog.i18n.DateTimePatterns_pl',
  'goog.i18n.DateTimePatterns_pt',
  'goog.i18n.DateTimePatterns_pt_BR',
  'goog.i18n.DateTimePatterns_pt_PT',
  'goog.i18n.DateTimePatterns_ro',
  'goog.i18n.DateTimePatterns_ru',
  'goog.i18n.DateTimePatterns_sk',
  'goog.i18n.DateTimePatterns_sl',
  'goog.i18n.DateTimePatterns_sq',
  'goog.i18n.DateTimePatterns_sr',
  'goog.i18n.DateTimePatterns_sv',
  'goog.i18n.DateTimePatterns_sw',
  'goog.i18n.DateTimePatterns_ta',
  'goog.i18n.DateTimePatterns_te',
  'goog.i18n.DateTimePatterns_th',
  'goog.i18n.DateTimePatterns_tl',
  'goog.i18n.DateTimePatterns_tr',
  'goog.i18n.DateTimePatterns_uk',
  'goog.i18n.DateTimePatterns_ur',
  'goog.i18n.DateTimePatterns_vi',
  'goog.i18n.DateTimePatterns_zh',
  'goog.i18n.DateTimePatterns_zh_CN',
  'goog.i18n.DateTimePatterns_zh_HK',
  'goog.i18n.DateTimePatterns_zh_TW',
  'goog.i18n.DateTimePatterns_zu'
], []);
goog.addDependency('i18n/datetimepatternsext.js', [
  'goog.i18n.DateTimePatternsExt',
  'goog.i18n.DateTimePatterns_af_NA',
  'goog.i18n.DateTimePatterns_af_ZA',
  'goog.i18n.DateTimePatterns_agq',
  'goog.i18n.DateTimePatterns_agq_CM',
  'goog.i18n.DateTimePatterns_ak',
  'goog.i18n.DateTimePatterns_ak_GH',
  'goog.i18n.DateTimePatterns_am_ET',
  'goog.i18n.DateTimePatterns_ar_001',
  'goog.i18n.DateTimePatterns_ar_AE',
  'goog.i18n.DateTimePatterns_ar_BH',
  'goog.i18n.DateTimePatterns_ar_DJ',
  'goog.i18n.DateTimePatterns_ar_DZ',
  'goog.i18n.DateTimePatterns_ar_EG',
  'goog.i18n.DateTimePatterns_ar_EH',
  'goog.i18n.DateTimePatterns_ar_ER',
  'goog.i18n.DateTimePatterns_ar_IL',
  'goog.i18n.DateTimePatterns_ar_IQ',
  'goog.i18n.DateTimePatterns_ar_JO',
  'goog.i18n.DateTimePatterns_ar_KM',
  'goog.i18n.DateTimePatterns_ar_KW',
  'goog.i18n.DateTimePatterns_ar_LB',
  'goog.i18n.DateTimePatterns_ar_LY',
  'goog.i18n.DateTimePatterns_ar_MA',
  'goog.i18n.DateTimePatterns_ar_MR',
  'goog.i18n.DateTimePatterns_ar_OM',
  'goog.i18n.DateTimePatterns_ar_PS',
  'goog.i18n.DateTimePatterns_ar_QA',
  'goog.i18n.DateTimePatterns_ar_SA',
  'goog.i18n.DateTimePatterns_ar_SD',
  'goog.i18n.DateTimePatterns_ar_SO',
  'goog.i18n.DateTimePatterns_ar_SY',
  'goog.i18n.DateTimePatterns_ar_TD',
  'goog.i18n.DateTimePatterns_ar_TN',
  'goog.i18n.DateTimePatterns_ar_YE',
  'goog.i18n.DateTimePatterns_as',
  'goog.i18n.DateTimePatterns_as_IN',
  'goog.i18n.DateTimePatterns_asa',
  'goog.i18n.DateTimePatterns_asa_TZ',
  'goog.i18n.DateTimePatterns_az',
  'goog.i18n.DateTimePatterns_az_Cyrl',
  'goog.i18n.DateTimePatterns_az_Cyrl_AZ',
  'goog.i18n.DateTimePatterns_az_Latn',
  'goog.i18n.DateTimePatterns_az_Latn_AZ',
  'goog.i18n.DateTimePatterns_bas',
  'goog.i18n.DateTimePatterns_bas_CM',
  'goog.i18n.DateTimePatterns_be',
  'goog.i18n.DateTimePatterns_be_BY',
  'goog.i18n.DateTimePatterns_bem',
  'goog.i18n.DateTimePatterns_bem_ZM',
  'goog.i18n.DateTimePatterns_bez',
  'goog.i18n.DateTimePatterns_bez_TZ',
  'goog.i18n.DateTimePatterns_bg_BG',
  'goog.i18n.DateTimePatterns_bm',
  'goog.i18n.DateTimePatterns_bm_ML',
  'goog.i18n.DateTimePatterns_bn_BD',
  'goog.i18n.DateTimePatterns_bn_IN',
  'goog.i18n.DateTimePatterns_bo',
  'goog.i18n.DateTimePatterns_bo_CN',
  'goog.i18n.DateTimePatterns_bo_IN',
  'goog.i18n.DateTimePatterns_br_FR',
  'goog.i18n.DateTimePatterns_brx',
  'goog.i18n.DateTimePatterns_brx_IN',
  'goog.i18n.DateTimePatterns_bs',
  'goog.i18n.DateTimePatterns_bs_Cyrl',
  'goog.i18n.DateTimePatterns_bs_Cyrl_BA',
  'goog.i18n.DateTimePatterns_bs_Latn',
  'goog.i18n.DateTimePatterns_bs_Latn_BA',
  'goog.i18n.DateTimePatterns_ca_AD',
  'goog.i18n.DateTimePatterns_ca_ES',
  'goog.i18n.DateTimePatterns_cgg',
  'goog.i18n.DateTimePatterns_cgg_UG',
  'goog.i18n.DateTimePatterns_chr_US',
  'goog.i18n.DateTimePatterns_cs_CZ',
  'goog.i18n.DateTimePatterns_cy_GB',
  'goog.i18n.DateTimePatterns_da_DK',
  'goog.i18n.DateTimePatterns_dav',
  'goog.i18n.DateTimePatterns_dav_KE',
  'goog.i18n.DateTimePatterns_de_BE',
  'goog.i18n.DateTimePatterns_de_DE',
  'goog.i18n.DateTimePatterns_de_LI',
  'goog.i18n.DateTimePatterns_de_LU',
  'goog.i18n.DateTimePatterns_dje',
  'goog.i18n.DateTimePatterns_dje_NE',
  'goog.i18n.DateTimePatterns_dua',
  'goog.i18n.DateTimePatterns_dua_CM',
  'goog.i18n.DateTimePatterns_dyo',
  'goog.i18n.DateTimePatterns_dyo_SN',
  'goog.i18n.DateTimePatterns_dz',
  'goog.i18n.DateTimePatterns_dz_BT',
  'goog.i18n.DateTimePatterns_ebu',
  'goog.i18n.DateTimePatterns_ebu_KE',
  'goog.i18n.DateTimePatterns_ee',
  'goog.i18n.DateTimePatterns_ee_GH',
  'goog.i18n.DateTimePatterns_ee_TG',
  'goog.i18n.DateTimePatterns_el_CY',
  'goog.i18n.DateTimePatterns_el_GR',
  'goog.i18n.DateTimePatterns_en_150',
  'goog.i18n.DateTimePatterns_en_AG',
  'goog.i18n.DateTimePatterns_en_AS',
  'goog.i18n.DateTimePatterns_en_BB',
  'goog.i18n.DateTimePatterns_en_BE',
  'goog.i18n.DateTimePatterns_en_BM',
  'goog.i18n.DateTimePatterns_en_BS',
  'goog.i18n.DateTimePatterns_en_BW',
  'goog.i18n.DateTimePatterns_en_BZ',
  'goog.i18n.DateTimePatterns_en_CA',
  'goog.i18n.DateTimePatterns_en_CM',
  'goog.i18n.DateTimePatterns_en_DM',
  'goog.i18n.DateTimePatterns_en_FJ',
  'goog.i18n.DateTimePatterns_en_FM',
  'goog.i18n.DateTimePatterns_en_GD',
  'goog.i18n.DateTimePatterns_en_GG',
  'goog.i18n.DateTimePatterns_en_GH',
  'goog.i18n.DateTimePatterns_en_GI',
  'goog.i18n.DateTimePatterns_en_GM',
  'goog.i18n.DateTimePatterns_en_GU',
  'goog.i18n.DateTimePatterns_en_GY',
  'goog.i18n.DateTimePatterns_en_HK',
  'goog.i18n.DateTimePatterns_en_IM',
  'goog.i18n.DateTimePatterns_en_JE',
  'goog.i18n.DateTimePatterns_en_JM',
  'goog.i18n.DateTimePatterns_en_KE',
  'goog.i18n.DateTimePatterns_en_KI',
  'goog.i18n.DateTimePatterns_en_KN',
  'goog.i18n.DateTimePatterns_en_KY',
  'goog.i18n.DateTimePatterns_en_LC',
  'goog.i18n.DateTimePatterns_en_LR',
  'goog.i18n.DateTimePatterns_en_LS',
  'goog.i18n.DateTimePatterns_en_MG',
  'goog.i18n.DateTimePatterns_en_MH',
  'goog.i18n.DateTimePatterns_en_MP',
  'goog.i18n.DateTimePatterns_en_MT',
  'goog.i18n.DateTimePatterns_en_MU',
  'goog.i18n.DateTimePatterns_en_MW',
  'goog.i18n.DateTimePatterns_en_NA',
  'goog.i18n.DateTimePatterns_en_NG',
  'goog.i18n.DateTimePatterns_en_NZ',
  'goog.i18n.DateTimePatterns_en_PG',
  'goog.i18n.DateTimePatterns_en_PH',
  'goog.i18n.DateTimePatterns_en_PK',
  'goog.i18n.DateTimePatterns_en_PR',
  'goog.i18n.DateTimePatterns_en_PW',
  'goog.i18n.DateTimePatterns_en_SB',
  'goog.i18n.DateTimePatterns_en_SC',
  'goog.i18n.DateTimePatterns_en_SL',
  'goog.i18n.DateTimePatterns_en_SS',
  'goog.i18n.DateTimePatterns_en_SZ',
  'goog.i18n.DateTimePatterns_en_TC',
  'goog.i18n.DateTimePatterns_en_TO',
  'goog.i18n.DateTimePatterns_en_TT',
  'goog.i18n.DateTimePatterns_en_TZ',
  'goog.i18n.DateTimePatterns_en_UG',
  'goog.i18n.DateTimePatterns_en_UM',
  'goog.i18n.DateTimePatterns_en_US_POSIX',
  'goog.i18n.DateTimePatterns_en_VC',
  'goog.i18n.DateTimePatterns_en_VG',
  'goog.i18n.DateTimePatterns_en_VI',
  'goog.i18n.DateTimePatterns_en_VU',
  'goog.i18n.DateTimePatterns_en_WS',
  'goog.i18n.DateTimePatterns_en_ZM',
  'goog.i18n.DateTimePatterns_en_ZW',
  'goog.i18n.DateTimePatterns_eo',
  'goog.i18n.DateTimePatterns_es_AR',
  'goog.i18n.DateTimePatterns_es_BO',
  'goog.i18n.DateTimePatterns_es_CL',
  'goog.i18n.DateTimePatterns_es_CO',
  'goog.i18n.DateTimePatterns_es_CR',
  'goog.i18n.DateTimePatterns_es_CU',
  'goog.i18n.DateTimePatterns_es_DO',
  'goog.i18n.DateTimePatterns_es_EA',
  'goog.i18n.DateTimePatterns_es_EC',
  'goog.i18n.DateTimePatterns_es_GQ',
  'goog.i18n.DateTimePatterns_es_GT',
  'goog.i18n.DateTimePatterns_es_HN',
  'goog.i18n.DateTimePatterns_es_IC',
  'goog.i18n.DateTimePatterns_es_MX',
  'goog.i18n.DateTimePatterns_es_NI',
  'goog.i18n.DateTimePatterns_es_PA',
  'goog.i18n.DateTimePatterns_es_PE',
  'goog.i18n.DateTimePatterns_es_PH',
  'goog.i18n.DateTimePatterns_es_PR',
  'goog.i18n.DateTimePatterns_es_PY',
  'goog.i18n.DateTimePatterns_es_SV',
  'goog.i18n.DateTimePatterns_es_US',
  'goog.i18n.DateTimePatterns_es_UY',
  'goog.i18n.DateTimePatterns_es_VE',
  'goog.i18n.DateTimePatterns_et_EE',
  'goog.i18n.DateTimePatterns_eu_ES',
  'goog.i18n.DateTimePatterns_ewo',
  'goog.i18n.DateTimePatterns_ewo_CM',
  'goog.i18n.DateTimePatterns_fa_AF',
  'goog.i18n.DateTimePatterns_fa_IR',
  'goog.i18n.DateTimePatterns_ff',
  'goog.i18n.DateTimePatterns_ff_SN',
  'goog.i18n.DateTimePatterns_fi_FI',
  'goog.i18n.DateTimePatterns_fil_PH',
  'goog.i18n.DateTimePatterns_fo',
  'goog.i18n.DateTimePatterns_fo_FO',
  'goog.i18n.DateTimePatterns_fr_BE',
  'goog.i18n.DateTimePatterns_fr_BF',
  'goog.i18n.DateTimePatterns_fr_BI',
  'goog.i18n.DateTimePatterns_fr_BJ',
  'goog.i18n.DateTimePatterns_fr_BL',
  'goog.i18n.DateTimePatterns_fr_CD',
  'goog.i18n.DateTimePatterns_fr_CF',
  'goog.i18n.DateTimePatterns_fr_CG',
  'goog.i18n.DateTimePatterns_fr_CH',
  'goog.i18n.DateTimePatterns_fr_CI',
  'goog.i18n.DateTimePatterns_fr_CM',
  'goog.i18n.DateTimePatterns_fr_DJ',
  'goog.i18n.DateTimePatterns_fr_DZ',
  'goog.i18n.DateTimePatterns_fr_FR',
  'goog.i18n.DateTimePatterns_fr_GA',
  'goog.i18n.DateTimePatterns_fr_GF',
  'goog.i18n.DateTimePatterns_fr_GN',
  'goog.i18n.DateTimePatterns_fr_GP',
  'goog.i18n.DateTimePatterns_fr_GQ',
  'goog.i18n.DateTimePatterns_fr_HT',
  'goog.i18n.DateTimePatterns_fr_KM',
  'goog.i18n.DateTimePatterns_fr_LU',
  'goog.i18n.DateTimePatterns_fr_MA',
  'goog.i18n.DateTimePatterns_fr_MC',
  'goog.i18n.DateTimePatterns_fr_MF',
  'goog.i18n.DateTimePatterns_fr_MG',
  'goog.i18n.DateTimePatterns_fr_ML',
  'goog.i18n.DateTimePatterns_fr_MQ',
  'goog.i18n.DateTimePatterns_fr_MR',
  'goog.i18n.DateTimePatterns_fr_MU',
  'goog.i18n.DateTimePatterns_fr_NC',
  'goog.i18n.DateTimePatterns_fr_NE',
  'goog.i18n.DateTimePatterns_fr_PF',
  'goog.i18n.DateTimePatterns_fr_RE',
  'goog.i18n.DateTimePatterns_fr_RW',
  'goog.i18n.DateTimePatterns_fr_SC',
  'goog.i18n.DateTimePatterns_fr_SN',
  'goog.i18n.DateTimePatterns_fr_SY',
  'goog.i18n.DateTimePatterns_fr_TD',
  'goog.i18n.DateTimePatterns_fr_TG',
  'goog.i18n.DateTimePatterns_fr_TN',
  'goog.i18n.DateTimePatterns_fr_VU',
  'goog.i18n.DateTimePatterns_fr_YT',
  'goog.i18n.DateTimePatterns_ga',
  'goog.i18n.DateTimePatterns_ga_IE',
  'goog.i18n.DateTimePatterns_gl_ES',
  'goog.i18n.DateTimePatterns_gsw_CH',
  'goog.i18n.DateTimePatterns_gu_IN',
  'goog.i18n.DateTimePatterns_guz',
  'goog.i18n.DateTimePatterns_guz_KE',
  'goog.i18n.DateTimePatterns_gv',
  'goog.i18n.DateTimePatterns_gv_GB',
  'goog.i18n.DateTimePatterns_ha',
  'goog.i18n.DateTimePatterns_ha_Latn',
  'goog.i18n.DateTimePatterns_ha_Latn_GH',
  'goog.i18n.DateTimePatterns_ha_Latn_NE',
  'goog.i18n.DateTimePatterns_ha_Latn_NG',
  'goog.i18n.DateTimePatterns_haw_US',
  'goog.i18n.DateTimePatterns_he_IL',
  'goog.i18n.DateTimePatterns_hi_IN',
  'goog.i18n.DateTimePatterns_hr_BA',
  'goog.i18n.DateTimePatterns_hr_HR',
  'goog.i18n.DateTimePatterns_hu_HU',
  'goog.i18n.DateTimePatterns_hy',
  'goog.i18n.DateTimePatterns_hy_AM',
  'goog.i18n.DateTimePatterns_id_ID',
  'goog.i18n.DateTimePatterns_ig',
  'goog.i18n.DateTimePatterns_ig_NG',
  'goog.i18n.DateTimePatterns_ii',
  'goog.i18n.DateTimePatterns_ii_CN',
  'goog.i18n.DateTimePatterns_is_IS',
  'goog.i18n.DateTimePatterns_it_CH',
  'goog.i18n.DateTimePatterns_it_IT',
  'goog.i18n.DateTimePatterns_it_SM',
  'goog.i18n.DateTimePatterns_ja_JP',
  'goog.i18n.DateTimePatterns_jgo',
  'goog.i18n.DateTimePatterns_jgo_CM',
  'goog.i18n.DateTimePatterns_jmc',
  'goog.i18n.DateTimePatterns_jmc_TZ',
  'goog.i18n.DateTimePatterns_ka',
  'goog.i18n.DateTimePatterns_ka_GE',
  'goog.i18n.DateTimePatterns_kab',
  'goog.i18n.DateTimePatterns_kab_DZ',
  'goog.i18n.DateTimePatterns_kam',
  'goog.i18n.DateTimePatterns_kam_KE',
  'goog.i18n.DateTimePatterns_kde',
  'goog.i18n.DateTimePatterns_kde_TZ',
  'goog.i18n.DateTimePatterns_kea',
  'goog.i18n.DateTimePatterns_kea_CV',
  'goog.i18n.DateTimePatterns_khq',
  'goog.i18n.DateTimePatterns_khq_ML',
  'goog.i18n.DateTimePatterns_ki',
  'goog.i18n.DateTimePatterns_ki_KE',
  'goog.i18n.DateTimePatterns_kk',
  'goog.i18n.DateTimePatterns_kk_Cyrl',
  'goog.i18n.DateTimePatterns_kk_Cyrl_KZ',
  'goog.i18n.DateTimePatterns_kl',
  'goog.i18n.DateTimePatterns_kl_GL',
  'goog.i18n.DateTimePatterns_kln',
  'goog.i18n.DateTimePatterns_kln_KE',
  'goog.i18n.DateTimePatterns_km',
  'goog.i18n.DateTimePatterns_km_KH',
  'goog.i18n.DateTimePatterns_kn_IN',
  'goog.i18n.DateTimePatterns_ko_KP',
  'goog.i18n.DateTimePatterns_ko_KR',
  'goog.i18n.DateTimePatterns_kok',
  'goog.i18n.DateTimePatterns_kok_IN',
  'goog.i18n.DateTimePatterns_ks',
  'goog.i18n.DateTimePatterns_ks_Arab',
  'goog.i18n.DateTimePatterns_ks_Arab_IN',
  'goog.i18n.DateTimePatterns_ksb',
  'goog.i18n.DateTimePatterns_ksb_TZ',
  'goog.i18n.DateTimePatterns_ksf',
  'goog.i18n.DateTimePatterns_ksf_CM',
  'goog.i18n.DateTimePatterns_kw',
  'goog.i18n.DateTimePatterns_kw_GB',
  'goog.i18n.DateTimePatterns_lag',
  'goog.i18n.DateTimePatterns_lag_TZ',
  'goog.i18n.DateTimePatterns_lg',
  'goog.i18n.DateTimePatterns_lg_UG',
  'goog.i18n.DateTimePatterns_ln_AO',
  'goog.i18n.DateTimePatterns_ln_CD',
  'goog.i18n.DateTimePatterns_ln_CF',
  'goog.i18n.DateTimePatterns_ln_CG',
  'goog.i18n.DateTimePatterns_lo',
  'goog.i18n.DateTimePatterns_lo_LA',
  'goog.i18n.DateTimePatterns_lt_LT',
  'goog.i18n.DateTimePatterns_lu',
  'goog.i18n.DateTimePatterns_lu_CD',
  'goog.i18n.DateTimePatterns_luo',
  'goog.i18n.DateTimePatterns_luo_KE',
  'goog.i18n.DateTimePatterns_luy',
  'goog.i18n.DateTimePatterns_luy_KE',
  'goog.i18n.DateTimePatterns_lv_LV',
  'goog.i18n.DateTimePatterns_mas',
  'goog.i18n.DateTimePatterns_mas_KE',
  'goog.i18n.DateTimePatterns_mas_TZ',
  'goog.i18n.DateTimePatterns_mer',
  'goog.i18n.DateTimePatterns_mer_KE',
  'goog.i18n.DateTimePatterns_mfe',
  'goog.i18n.DateTimePatterns_mfe_MU',
  'goog.i18n.DateTimePatterns_mg',
  'goog.i18n.DateTimePatterns_mg_MG',
  'goog.i18n.DateTimePatterns_mgh',
  'goog.i18n.DateTimePatterns_mgh_MZ',
  'goog.i18n.DateTimePatterns_mgo',
  'goog.i18n.DateTimePatterns_mgo_CM',
  'goog.i18n.DateTimePatterns_mk',
  'goog.i18n.DateTimePatterns_mk_MK',
  'goog.i18n.DateTimePatterns_ml_IN',
  'goog.i18n.DateTimePatterns_mn',
  'goog.i18n.DateTimePatterns_mn_Cyrl',
  'goog.i18n.DateTimePatterns_mn_Cyrl_MN',
  'goog.i18n.DateTimePatterns_mr_IN',
  'goog.i18n.DateTimePatterns_ms_Latn',
  'goog.i18n.DateTimePatterns_ms_Latn_BN',
  'goog.i18n.DateTimePatterns_ms_Latn_MY',
  'goog.i18n.DateTimePatterns_ms_Latn_SG',
  'goog.i18n.DateTimePatterns_mt_MT',
  'goog.i18n.DateTimePatterns_mua',
  'goog.i18n.DateTimePatterns_mua_CM',
  'goog.i18n.DateTimePatterns_my',
  'goog.i18n.DateTimePatterns_my_MM',
  'goog.i18n.DateTimePatterns_naq',
  'goog.i18n.DateTimePatterns_naq_NA',
  'goog.i18n.DateTimePatterns_nb_NO',
  'goog.i18n.DateTimePatterns_nd',
  'goog.i18n.DateTimePatterns_nd_ZW',
  'goog.i18n.DateTimePatterns_ne',
  'goog.i18n.DateTimePatterns_ne_IN',
  'goog.i18n.DateTimePatterns_ne_NP',
  'goog.i18n.DateTimePatterns_nl_AW',
  'goog.i18n.DateTimePatterns_nl_BE',
  'goog.i18n.DateTimePatterns_nl_CW',
  'goog.i18n.DateTimePatterns_nl_NL',
  'goog.i18n.DateTimePatterns_nl_SR',
  'goog.i18n.DateTimePatterns_nl_SX',
  'goog.i18n.DateTimePatterns_nmg',
  'goog.i18n.DateTimePatterns_nmg_CM',
  'goog.i18n.DateTimePatterns_nn',
  'goog.i18n.DateTimePatterns_nn_NO',
  'goog.i18n.DateTimePatterns_nus',
  'goog.i18n.DateTimePatterns_nus_SD',
  'goog.i18n.DateTimePatterns_nyn',
  'goog.i18n.DateTimePatterns_nyn_UG',
  'goog.i18n.DateTimePatterns_om',
  'goog.i18n.DateTimePatterns_om_ET',
  'goog.i18n.DateTimePatterns_om_KE',
  'goog.i18n.DateTimePatterns_or_IN',
  'goog.i18n.DateTimePatterns_pa',
  'goog.i18n.DateTimePatterns_pa_Arab',
  'goog.i18n.DateTimePatterns_pa_Arab_PK',
  'goog.i18n.DateTimePatterns_pa_Guru',
  'goog.i18n.DateTimePatterns_pa_Guru_IN',
  'goog.i18n.DateTimePatterns_pl_PL',
  'goog.i18n.DateTimePatterns_ps',
  'goog.i18n.DateTimePatterns_ps_AF',
  'goog.i18n.DateTimePatterns_pt_AO',
  'goog.i18n.DateTimePatterns_pt_CV',
  'goog.i18n.DateTimePatterns_pt_GW',
  'goog.i18n.DateTimePatterns_pt_MO',
  'goog.i18n.DateTimePatterns_pt_MZ',
  'goog.i18n.DateTimePatterns_pt_ST',
  'goog.i18n.DateTimePatterns_pt_TL',
  'goog.i18n.DateTimePatterns_rm',
  'goog.i18n.DateTimePatterns_rm_CH',
  'goog.i18n.DateTimePatterns_rn',
  'goog.i18n.DateTimePatterns_rn_BI',
  'goog.i18n.DateTimePatterns_ro_MD',
  'goog.i18n.DateTimePatterns_ro_RO',
  'goog.i18n.DateTimePatterns_rof',
  'goog.i18n.DateTimePatterns_rof_TZ',
  'goog.i18n.DateTimePatterns_ru_BY',
  'goog.i18n.DateTimePatterns_ru_KG',
  'goog.i18n.DateTimePatterns_ru_KZ',
  'goog.i18n.DateTimePatterns_ru_MD',
  'goog.i18n.DateTimePatterns_ru_RU',
  'goog.i18n.DateTimePatterns_ru_UA',
  'goog.i18n.DateTimePatterns_rw',
  'goog.i18n.DateTimePatterns_rw_RW',
  'goog.i18n.DateTimePatterns_rwk',
  'goog.i18n.DateTimePatterns_rwk_TZ',
  'goog.i18n.DateTimePatterns_saq',
  'goog.i18n.DateTimePatterns_saq_KE',
  'goog.i18n.DateTimePatterns_sbp',
  'goog.i18n.DateTimePatterns_sbp_TZ',
  'goog.i18n.DateTimePatterns_seh',
  'goog.i18n.DateTimePatterns_seh_MZ',
  'goog.i18n.DateTimePatterns_ses',
  'goog.i18n.DateTimePatterns_ses_ML',
  'goog.i18n.DateTimePatterns_sg',
  'goog.i18n.DateTimePatterns_sg_CF',
  'goog.i18n.DateTimePatterns_shi',
  'goog.i18n.DateTimePatterns_shi_Latn',
  'goog.i18n.DateTimePatterns_shi_Latn_MA',
  'goog.i18n.DateTimePatterns_shi_Tfng',
  'goog.i18n.DateTimePatterns_shi_Tfng_MA',
  'goog.i18n.DateTimePatterns_si',
  'goog.i18n.DateTimePatterns_si_LK',
  'goog.i18n.DateTimePatterns_sk_SK',
  'goog.i18n.DateTimePatterns_sl_SI',
  'goog.i18n.DateTimePatterns_sn',
  'goog.i18n.DateTimePatterns_sn_ZW',
  'goog.i18n.DateTimePatterns_so',
  'goog.i18n.DateTimePatterns_so_DJ',
  'goog.i18n.DateTimePatterns_so_ET',
  'goog.i18n.DateTimePatterns_so_KE',
  'goog.i18n.DateTimePatterns_so_SO',
  'goog.i18n.DateTimePatterns_sq_AL',
  'goog.i18n.DateTimePatterns_sq_MK',
  'goog.i18n.DateTimePatterns_sr_Cyrl',
  'goog.i18n.DateTimePatterns_sr_Cyrl_BA',
  'goog.i18n.DateTimePatterns_sr_Cyrl_ME',
  'goog.i18n.DateTimePatterns_sr_Cyrl_RS',
  'goog.i18n.DateTimePatterns_sr_Latn',
  'goog.i18n.DateTimePatterns_sr_Latn_BA',
  'goog.i18n.DateTimePatterns_sr_Latn_ME',
  'goog.i18n.DateTimePatterns_sr_Latn_RS',
  'goog.i18n.DateTimePatterns_sv_AX',
  'goog.i18n.DateTimePatterns_sv_FI',
  'goog.i18n.DateTimePatterns_sv_SE',
  'goog.i18n.DateTimePatterns_sw_KE',
  'goog.i18n.DateTimePatterns_sw_TZ',
  'goog.i18n.DateTimePatterns_sw_UG',
  'goog.i18n.DateTimePatterns_swc',
  'goog.i18n.DateTimePatterns_swc_CD',
  'goog.i18n.DateTimePatterns_ta_IN',
  'goog.i18n.DateTimePatterns_ta_LK',
  'goog.i18n.DateTimePatterns_ta_MY',
  'goog.i18n.DateTimePatterns_ta_SG',
  'goog.i18n.DateTimePatterns_te_IN',
  'goog.i18n.DateTimePatterns_teo',
  'goog.i18n.DateTimePatterns_teo_KE',
  'goog.i18n.DateTimePatterns_teo_UG',
  'goog.i18n.DateTimePatterns_th_TH',
  'goog.i18n.DateTimePatterns_ti',
  'goog.i18n.DateTimePatterns_ti_ER',
  'goog.i18n.DateTimePatterns_ti_ET',
  'goog.i18n.DateTimePatterns_to',
  'goog.i18n.DateTimePatterns_to_TO',
  'goog.i18n.DateTimePatterns_tr_CY',
  'goog.i18n.DateTimePatterns_tr_TR',
  'goog.i18n.DateTimePatterns_twq',
  'goog.i18n.DateTimePatterns_twq_NE',
  'goog.i18n.DateTimePatterns_tzm',
  'goog.i18n.DateTimePatterns_tzm_Latn',
  'goog.i18n.DateTimePatterns_tzm_Latn_MA',
  'goog.i18n.DateTimePatterns_uk_UA',
  'goog.i18n.DateTimePatterns_ur_IN',
  'goog.i18n.DateTimePatterns_ur_PK',
  'goog.i18n.DateTimePatterns_uz',
  'goog.i18n.DateTimePatterns_uz_Arab',
  'goog.i18n.DateTimePatterns_uz_Arab_AF',
  'goog.i18n.DateTimePatterns_uz_Cyrl',
  'goog.i18n.DateTimePatterns_uz_Cyrl_UZ',
  'goog.i18n.DateTimePatterns_uz_Latn',
  'goog.i18n.DateTimePatterns_uz_Latn_UZ',
  'goog.i18n.DateTimePatterns_vai',
  'goog.i18n.DateTimePatterns_vai_Latn',
  'goog.i18n.DateTimePatterns_vai_Latn_LR',
  'goog.i18n.DateTimePatterns_vai_Vaii',
  'goog.i18n.DateTimePatterns_vai_Vaii_LR',
  'goog.i18n.DateTimePatterns_vi_VN',
  'goog.i18n.DateTimePatterns_vun',
  'goog.i18n.DateTimePatterns_vun_TZ',
  'goog.i18n.DateTimePatterns_xog',
  'goog.i18n.DateTimePatterns_xog_UG',
  'goog.i18n.DateTimePatterns_yav',
  'goog.i18n.DateTimePatterns_yav_CM',
  'goog.i18n.DateTimePatterns_yo',
  'goog.i18n.DateTimePatterns_yo_NG',
  'goog.i18n.DateTimePatterns_zh_Hans',
  'goog.i18n.DateTimePatterns_zh_Hans_CN',
  'goog.i18n.DateTimePatterns_zh_Hans_HK',
  'goog.i18n.DateTimePatterns_zh_Hans_MO',
  'goog.i18n.DateTimePatterns_zh_Hans_SG',
  'goog.i18n.DateTimePatterns_zh_Hant',
  'goog.i18n.DateTimePatterns_zh_Hant_HK',
  'goog.i18n.DateTimePatterns_zh_Hant_MO',
  'goog.i18n.DateTimePatterns_zh_Hant_TW',
  'goog.i18n.DateTimePatterns_zu_ZA'
], ['goog.i18n.DateTimePatterns']);
goog.addDependency('i18n/datetimesymbols.js', [
  'goog.i18n.DateTimeSymbols',
  'goog.i18n.DateTimeSymbols_af',
  'goog.i18n.DateTimeSymbols_am',
  'goog.i18n.DateTimeSymbols_ar',
  'goog.i18n.DateTimeSymbols_bg',
  'goog.i18n.DateTimeSymbols_bn',
  'goog.i18n.DateTimeSymbols_br',
  'goog.i18n.DateTimeSymbols_ca',
  'goog.i18n.DateTimeSymbols_chr',
  'goog.i18n.DateTimeSymbols_cs',
  'goog.i18n.DateTimeSymbols_cy',
  'goog.i18n.DateTimeSymbols_da',
  'goog.i18n.DateTimeSymbols_de',
  'goog.i18n.DateTimeSymbols_de_AT',
  'goog.i18n.DateTimeSymbols_de_CH',
  'goog.i18n.DateTimeSymbols_el',
  'goog.i18n.DateTimeSymbols_en',
  'goog.i18n.DateTimeSymbols_en_AU',
  'goog.i18n.DateTimeSymbols_en_GB',
  'goog.i18n.DateTimeSymbols_en_IE',
  'goog.i18n.DateTimeSymbols_en_IN',
  'goog.i18n.DateTimeSymbols_en_ISO',
  'goog.i18n.DateTimeSymbols_en_SG',
  'goog.i18n.DateTimeSymbols_en_US',
  'goog.i18n.DateTimeSymbols_en_ZA',
  'goog.i18n.DateTimeSymbols_es',
  'goog.i18n.DateTimeSymbols_es_419',
  'goog.i18n.DateTimeSymbols_es_ES',
  'goog.i18n.DateTimeSymbols_et',
  'goog.i18n.DateTimeSymbols_eu',
  'goog.i18n.DateTimeSymbols_fa',
  'goog.i18n.DateTimeSymbols_fi',
  'goog.i18n.DateTimeSymbols_fil',
  'goog.i18n.DateTimeSymbols_fr',
  'goog.i18n.DateTimeSymbols_fr_CA',
  'goog.i18n.DateTimeSymbols_gl',
  'goog.i18n.DateTimeSymbols_gsw',
  'goog.i18n.DateTimeSymbols_gu',
  'goog.i18n.DateTimeSymbols_haw',
  'goog.i18n.DateTimeSymbols_he',
  'goog.i18n.DateTimeSymbols_hi',
  'goog.i18n.DateTimeSymbols_hr',
  'goog.i18n.DateTimeSymbols_hu',
  'goog.i18n.DateTimeSymbols_id',
  'goog.i18n.DateTimeSymbols_in',
  'goog.i18n.DateTimeSymbols_is',
  'goog.i18n.DateTimeSymbols_it',
  'goog.i18n.DateTimeSymbols_iw',
  'goog.i18n.DateTimeSymbols_ja',
  'goog.i18n.DateTimeSymbols_kn',
  'goog.i18n.DateTimeSymbols_ko',
  'goog.i18n.DateTimeSymbols_ln',
  'goog.i18n.DateTimeSymbols_lt',
  'goog.i18n.DateTimeSymbols_lv',
  'goog.i18n.DateTimeSymbols_ml',
  'goog.i18n.DateTimeSymbols_mr',
  'goog.i18n.DateTimeSymbols_ms',
  'goog.i18n.DateTimeSymbols_mt',
  'goog.i18n.DateTimeSymbols_nb',
  'goog.i18n.DateTimeSymbols_nl',
  'goog.i18n.DateTimeSymbols_no',
  'goog.i18n.DateTimeSymbols_or',
  'goog.i18n.DateTimeSymbols_pl',
  'goog.i18n.DateTimeSymbols_pt',
  'goog.i18n.DateTimeSymbols_pt_BR',
  'goog.i18n.DateTimeSymbols_pt_PT',
  'goog.i18n.DateTimeSymbols_ro',
  'goog.i18n.DateTimeSymbols_ru',
  'goog.i18n.DateTimeSymbols_sk',
  'goog.i18n.DateTimeSymbols_sl',
  'goog.i18n.DateTimeSymbols_sq',
  'goog.i18n.DateTimeSymbols_sr',
  'goog.i18n.DateTimeSymbols_sv',
  'goog.i18n.DateTimeSymbols_sw',
  'goog.i18n.DateTimeSymbols_ta',
  'goog.i18n.DateTimeSymbols_te',
  'goog.i18n.DateTimeSymbols_th',
  'goog.i18n.DateTimeSymbols_tl',
  'goog.i18n.DateTimeSymbols_tr',
  'goog.i18n.DateTimeSymbols_uk',
  'goog.i18n.DateTimeSymbols_ur',
  'goog.i18n.DateTimeSymbols_vi',
  'goog.i18n.DateTimeSymbols_zh',
  'goog.i18n.DateTimeSymbols_zh_CN',
  'goog.i18n.DateTimeSymbols_zh_HK',
  'goog.i18n.DateTimeSymbols_zh_TW',
  'goog.i18n.DateTimeSymbols_zu'
], []);
goog.addDependency('i18n/datetimesymbolsext.js', [
  'goog.i18n.DateTimeSymbolsExt',
  'goog.i18n.DateTimeSymbols_aa',
  'goog.i18n.DateTimeSymbols_aa_DJ',
  'goog.i18n.DateTimeSymbols_aa_ER',
  'goog.i18n.DateTimeSymbols_aa_ET',
  'goog.i18n.DateTimeSymbols_af_NA',
  'goog.i18n.DateTimeSymbols_af_ZA',
  'goog.i18n.DateTimeSymbols_agq',
  'goog.i18n.DateTimeSymbols_agq_CM',
  'goog.i18n.DateTimeSymbols_ak',
  'goog.i18n.DateTimeSymbols_ak_GH',
  'goog.i18n.DateTimeSymbols_am_ET',
  'goog.i18n.DateTimeSymbols_ar_001',
  'goog.i18n.DateTimeSymbols_ar_AE',
  'goog.i18n.DateTimeSymbols_ar_BH',
  'goog.i18n.DateTimeSymbols_ar_DJ',
  'goog.i18n.DateTimeSymbols_ar_DZ',
  'goog.i18n.DateTimeSymbols_ar_EG',
  'goog.i18n.DateTimeSymbols_ar_EH',
  'goog.i18n.DateTimeSymbols_ar_ER',
  'goog.i18n.DateTimeSymbols_ar_IL',
  'goog.i18n.DateTimeSymbols_ar_IQ',
  'goog.i18n.DateTimeSymbols_ar_JO',
  'goog.i18n.DateTimeSymbols_ar_KM',
  'goog.i18n.DateTimeSymbols_ar_KW',
  'goog.i18n.DateTimeSymbols_ar_LB',
  'goog.i18n.DateTimeSymbols_ar_LY',
  'goog.i18n.DateTimeSymbols_ar_MA',
  'goog.i18n.DateTimeSymbols_ar_MR',
  'goog.i18n.DateTimeSymbols_ar_OM',
  'goog.i18n.DateTimeSymbols_ar_PS',
  'goog.i18n.DateTimeSymbols_ar_QA',
  'goog.i18n.DateTimeSymbols_ar_SA',
  'goog.i18n.DateTimeSymbols_ar_SD',
  'goog.i18n.DateTimeSymbols_ar_SO',
  'goog.i18n.DateTimeSymbols_ar_SY',
  'goog.i18n.DateTimeSymbols_ar_TD',
  'goog.i18n.DateTimeSymbols_ar_TN',
  'goog.i18n.DateTimeSymbols_ar_YE',
  'goog.i18n.DateTimeSymbols_as',
  'goog.i18n.DateTimeSymbols_as_IN',
  'goog.i18n.DateTimeSymbols_asa',
  'goog.i18n.DateTimeSymbols_asa_TZ',
  'goog.i18n.DateTimeSymbols_ast',
  'goog.i18n.DateTimeSymbols_ast_ES',
  'goog.i18n.DateTimeSymbols_az',
  'goog.i18n.DateTimeSymbols_az_Cyrl',
  'goog.i18n.DateTimeSymbols_az_Cyrl_AZ',
  'goog.i18n.DateTimeSymbols_az_Latn',
  'goog.i18n.DateTimeSymbols_az_Latn_AZ',
  'goog.i18n.DateTimeSymbols_bas',
  'goog.i18n.DateTimeSymbols_bas_CM',
  'goog.i18n.DateTimeSymbols_be',
  'goog.i18n.DateTimeSymbols_be_BY',
  'goog.i18n.DateTimeSymbols_bem',
  'goog.i18n.DateTimeSymbols_bem_ZM',
  'goog.i18n.DateTimeSymbols_bez',
  'goog.i18n.DateTimeSymbols_bez_TZ',
  'goog.i18n.DateTimeSymbols_bg_BG',
  'goog.i18n.DateTimeSymbols_bm',
  'goog.i18n.DateTimeSymbols_bm_ML',
  'goog.i18n.DateTimeSymbols_bn_BD',
  'goog.i18n.DateTimeSymbols_bn_IN',
  'goog.i18n.DateTimeSymbols_bo',
  'goog.i18n.DateTimeSymbols_bo_CN',
  'goog.i18n.DateTimeSymbols_bo_IN',
  'goog.i18n.DateTimeSymbols_br_FR',
  'goog.i18n.DateTimeSymbols_brx',
  'goog.i18n.DateTimeSymbols_brx_IN',
  'goog.i18n.DateTimeSymbols_bs',
  'goog.i18n.DateTimeSymbols_bs_Cyrl',
  'goog.i18n.DateTimeSymbols_bs_Cyrl_BA',
  'goog.i18n.DateTimeSymbols_bs_Latn',
  'goog.i18n.DateTimeSymbols_bs_Latn_BA',
  'goog.i18n.DateTimeSymbols_byn',
  'goog.i18n.DateTimeSymbols_byn_ER',
  'goog.i18n.DateTimeSymbols_ca_AD',
  'goog.i18n.DateTimeSymbols_ca_ES',
  'goog.i18n.DateTimeSymbols_cgg',
  'goog.i18n.DateTimeSymbols_cgg_UG',
  'goog.i18n.DateTimeSymbols_chr_US',
  'goog.i18n.DateTimeSymbols_ckb',
  'goog.i18n.DateTimeSymbols_ckb_Arab',
  'goog.i18n.DateTimeSymbols_ckb_Arab_IQ',
  'goog.i18n.DateTimeSymbols_ckb_Arab_IR',
  'goog.i18n.DateTimeSymbols_ckb_IQ',
  'goog.i18n.DateTimeSymbols_ckb_IR',
  'goog.i18n.DateTimeSymbols_ckb_Latn',
  'goog.i18n.DateTimeSymbols_ckb_Latn_IQ',
  'goog.i18n.DateTimeSymbols_cs_CZ',
  'goog.i18n.DateTimeSymbols_cy_GB',
  'goog.i18n.DateTimeSymbols_da_DK',
  'goog.i18n.DateTimeSymbols_dav',
  'goog.i18n.DateTimeSymbols_dav_KE',
  'goog.i18n.DateTimeSymbols_de_BE',
  'goog.i18n.DateTimeSymbols_de_DE',
  'goog.i18n.DateTimeSymbols_de_LI',
  'goog.i18n.DateTimeSymbols_de_LU',
  'goog.i18n.DateTimeSymbols_dje',
  'goog.i18n.DateTimeSymbols_dje_NE',
  'goog.i18n.DateTimeSymbols_dua',
  'goog.i18n.DateTimeSymbols_dua_CM',
  'goog.i18n.DateTimeSymbols_dyo',
  'goog.i18n.DateTimeSymbols_dyo_SN',
  'goog.i18n.DateTimeSymbols_dz',
  'goog.i18n.DateTimeSymbols_dz_BT',
  'goog.i18n.DateTimeSymbols_ebu',
  'goog.i18n.DateTimeSymbols_ebu_KE',
  'goog.i18n.DateTimeSymbols_ee',
  'goog.i18n.DateTimeSymbols_ee_GH',
  'goog.i18n.DateTimeSymbols_ee_TG',
  'goog.i18n.DateTimeSymbols_el_CY',
  'goog.i18n.DateTimeSymbols_el_GR',
  'goog.i18n.DateTimeSymbols_en_150',
  'goog.i18n.DateTimeSymbols_en_AG',
  'goog.i18n.DateTimeSymbols_en_AS',
  'goog.i18n.DateTimeSymbols_en_BB',
  'goog.i18n.DateTimeSymbols_en_BE',
  'goog.i18n.DateTimeSymbols_en_BM',
  'goog.i18n.DateTimeSymbols_en_BS',
  'goog.i18n.DateTimeSymbols_en_BW',
  'goog.i18n.DateTimeSymbols_en_BZ',
  'goog.i18n.DateTimeSymbols_en_CA',
  'goog.i18n.DateTimeSymbols_en_CM',
  'goog.i18n.DateTimeSymbols_en_DM',
  'goog.i18n.DateTimeSymbols_en_Dsrt',
  'goog.i18n.DateTimeSymbols_en_Dsrt_US',
  'goog.i18n.DateTimeSymbols_en_FJ',
  'goog.i18n.DateTimeSymbols_en_FM',
  'goog.i18n.DateTimeSymbols_en_GD',
  'goog.i18n.DateTimeSymbols_en_GG',
  'goog.i18n.DateTimeSymbols_en_GH',
  'goog.i18n.DateTimeSymbols_en_GI',
  'goog.i18n.DateTimeSymbols_en_GM',
  'goog.i18n.DateTimeSymbols_en_GU',
  'goog.i18n.DateTimeSymbols_en_GY',
  'goog.i18n.DateTimeSymbols_en_HK',
  'goog.i18n.DateTimeSymbols_en_IM',
  'goog.i18n.DateTimeSymbols_en_JE',
  'goog.i18n.DateTimeSymbols_en_JM',
  'goog.i18n.DateTimeSymbols_en_KE',
  'goog.i18n.DateTimeSymbols_en_KI',
  'goog.i18n.DateTimeSymbols_en_KN',
  'goog.i18n.DateTimeSymbols_en_KY',
  'goog.i18n.DateTimeSymbols_en_LC',
  'goog.i18n.DateTimeSymbols_en_LR',
  'goog.i18n.DateTimeSymbols_en_LS',
  'goog.i18n.DateTimeSymbols_en_MG',
  'goog.i18n.DateTimeSymbols_en_MH',
  'goog.i18n.DateTimeSymbols_en_MP',
  'goog.i18n.DateTimeSymbols_en_MT',
  'goog.i18n.DateTimeSymbols_en_MU',
  'goog.i18n.DateTimeSymbols_en_MW',
  'goog.i18n.DateTimeSymbols_en_NA',
  'goog.i18n.DateTimeSymbols_en_NG',
  'goog.i18n.DateTimeSymbols_en_NZ',
  'goog.i18n.DateTimeSymbols_en_PG',
  'goog.i18n.DateTimeSymbols_en_PH',
  'goog.i18n.DateTimeSymbols_en_PK',
  'goog.i18n.DateTimeSymbols_en_PR',
  'goog.i18n.DateTimeSymbols_en_PW',
  'goog.i18n.DateTimeSymbols_en_SB',
  'goog.i18n.DateTimeSymbols_en_SC',
  'goog.i18n.DateTimeSymbols_en_SL',
  'goog.i18n.DateTimeSymbols_en_SS',
  'goog.i18n.DateTimeSymbols_en_SZ',
  'goog.i18n.DateTimeSymbols_en_TC',
  'goog.i18n.DateTimeSymbols_en_TO',
  'goog.i18n.DateTimeSymbols_en_TT',
  'goog.i18n.DateTimeSymbols_en_TZ',
  'goog.i18n.DateTimeSymbols_en_UG',
  'goog.i18n.DateTimeSymbols_en_UM',
  'goog.i18n.DateTimeSymbols_en_VC',
  'goog.i18n.DateTimeSymbols_en_VG',
  'goog.i18n.DateTimeSymbols_en_VI',
  'goog.i18n.DateTimeSymbols_en_VU',
  'goog.i18n.DateTimeSymbols_en_WS',
  'goog.i18n.DateTimeSymbols_en_ZM',
  'goog.i18n.DateTimeSymbols_en_ZW',
  'goog.i18n.DateTimeSymbols_eo',
  'goog.i18n.DateTimeSymbols_es_AR',
  'goog.i18n.DateTimeSymbols_es_BO',
  'goog.i18n.DateTimeSymbols_es_CL',
  'goog.i18n.DateTimeSymbols_es_CO',
  'goog.i18n.DateTimeSymbols_es_CR',
  'goog.i18n.DateTimeSymbols_es_CU',
  'goog.i18n.DateTimeSymbols_es_DO',
  'goog.i18n.DateTimeSymbols_es_EA',
  'goog.i18n.DateTimeSymbols_es_EC',
  'goog.i18n.DateTimeSymbols_es_GQ',
  'goog.i18n.DateTimeSymbols_es_GT',
  'goog.i18n.DateTimeSymbols_es_HN',
  'goog.i18n.DateTimeSymbols_es_IC',
  'goog.i18n.DateTimeSymbols_es_MX',
  'goog.i18n.DateTimeSymbols_es_NI',
  'goog.i18n.DateTimeSymbols_es_PA',
  'goog.i18n.DateTimeSymbols_es_PE',
  'goog.i18n.DateTimeSymbols_es_PH',
  'goog.i18n.DateTimeSymbols_es_PR',
  'goog.i18n.DateTimeSymbols_es_PY',
  'goog.i18n.DateTimeSymbols_es_SV',
  'goog.i18n.DateTimeSymbols_es_US',
  'goog.i18n.DateTimeSymbols_es_UY',
  'goog.i18n.DateTimeSymbols_es_VE',
  'goog.i18n.DateTimeSymbols_et_EE',
  'goog.i18n.DateTimeSymbols_eu_ES',
  'goog.i18n.DateTimeSymbols_ewo',
  'goog.i18n.DateTimeSymbols_ewo_CM',
  'goog.i18n.DateTimeSymbols_fa_AF',
  'goog.i18n.DateTimeSymbols_fa_IR',
  'goog.i18n.DateTimeSymbols_ff',
  'goog.i18n.DateTimeSymbols_ff_SN',
  'goog.i18n.DateTimeSymbols_fi_FI',
  'goog.i18n.DateTimeSymbols_fil_PH',
  'goog.i18n.DateTimeSymbols_fo',
  'goog.i18n.DateTimeSymbols_fo_FO',
  'goog.i18n.DateTimeSymbols_fr_BE',
  'goog.i18n.DateTimeSymbols_fr_BF',
  'goog.i18n.DateTimeSymbols_fr_BI',
  'goog.i18n.DateTimeSymbols_fr_BJ',
  'goog.i18n.DateTimeSymbols_fr_BL',
  'goog.i18n.DateTimeSymbols_fr_CD',
  'goog.i18n.DateTimeSymbols_fr_CF',
  'goog.i18n.DateTimeSymbols_fr_CG',
  'goog.i18n.DateTimeSymbols_fr_CH',
  'goog.i18n.DateTimeSymbols_fr_CI',
  'goog.i18n.DateTimeSymbols_fr_CM',
  'goog.i18n.DateTimeSymbols_fr_DJ',
  'goog.i18n.DateTimeSymbols_fr_DZ',
  'goog.i18n.DateTimeSymbols_fr_FR',
  'goog.i18n.DateTimeSymbols_fr_GA',
  'goog.i18n.DateTimeSymbols_fr_GF',
  'goog.i18n.DateTimeSymbols_fr_GN',
  'goog.i18n.DateTimeSymbols_fr_GP',
  'goog.i18n.DateTimeSymbols_fr_GQ',
  'goog.i18n.DateTimeSymbols_fr_HT',
  'goog.i18n.DateTimeSymbols_fr_KM',
  'goog.i18n.DateTimeSymbols_fr_LU',
  'goog.i18n.DateTimeSymbols_fr_MA',
  'goog.i18n.DateTimeSymbols_fr_MC',
  'goog.i18n.DateTimeSymbols_fr_MF',
  'goog.i18n.DateTimeSymbols_fr_MG',
  'goog.i18n.DateTimeSymbols_fr_ML',
  'goog.i18n.DateTimeSymbols_fr_MQ',
  'goog.i18n.DateTimeSymbols_fr_MR',
  'goog.i18n.DateTimeSymbols_fr_MU',
  'goog.i18n.DateTimeSymbols_fr_NC',
  'goog.i18n.DateTimeSymbols_fr_NE',
  'goog.i18n.DateTimeSymbols_fr_PF',
  'goog.i18n.DateTimeSymbols_fr_RE',
  'goog.i18n.DateTimeSymbols_fr_RW',
  'goog.i18n.DateTimeSymbols_fr_SC',
  'goog.i18n.DateTimeSymbols_fr_SN',
  'goog.i18n.DateTimeSymbols_fr_SY',
  'goog.i18n.DateTimeSymbols_fr_TD',
  'goog.i18n.DateTimeSymbols_fr_TG',
  'goog.i18n.DateTimeSymbols_fr_TN',
  'goog.i18n.DateTimeSymbols_fr_VU',
  'goog.i18n.DateTimeSymbols_fr_YT',
  'goog.i18n.DateTimeSymbols_fur',
  'goog.i18n.DateTimeSymbols_fur_IT',
  'goog.i18n.DateTimeSymbols_ga',
  'goog.i18n.DateTimeSymbols_ga_IE',
  'goog.i18n.DateTimeSymbols_gd',
  'goog.i18n.DateTimeSymbols_gd_GB',
  'goog.i18n.DateTimeSymbols_gl_ES',
  'goog.i18n.DateTimeSymbols_gsw_CH',
  'goog.i18n.DateTimeSymbols_gu_IN',
  'goog.i18n.DateTimeSymbols_guz',
  'goog.i18n.DateTimeSymbols_guz_KE',
  'goog.i18n.DateTimeSymbols_gv',
  'goog.i18n.DateTimeSymbols_gv_GB',
  'goog.i18n.DateTimeSymbols_ha',
  'goog.i18n.DateTimeSymbols_ha_Latn',
  'goog.i18n.DateTimeSymbols_ha_Latn_GH',
  'goog.i18n.DateTimeSymbols_ha_Latn_NE',
  'goog.i18n.DateTimeSymbols_ha_Latn_NG',
  'goog.i18n.DateTimeSymbols_haw_US',
  'goog.i18n.DateTimeSymbols_he_IL',
  'goog.i18n.DateTimeSymbols_hi_IN',
  'goog.i18n.DateTimeSymbols_hr_BA',
  'goog.i18n.DateTimeSymbols_hr_HR',
  'goog.i18n.DateTimeSymbols_hu_HU',
  'goog.i18n.DateTimeSymbols_hy',
  'goog.i18n.DateTimeSymbols_hy_AM',
  'goog.i18n.DateTimeSymbols_ia',
  'goog.i18n.DateTimeSymbols_ia_FR',
  'goog.i18n.DateTimeSymbols_id_ID',
  'goog.i18n.DateTimeSymbols_ig',
  'goog.i18n.DateTimeSymbols_ig_NG',
  'goog.i18n.DateTimeSymbols_ii',
  'goog.i18n.DateTimeSymbols_ii_CN',
  'goog.i18n.DateTimeSymbols_is_IS',
  'goog.i18n.DateTimeSymbols_it_CH',
  'goog.i18n.DateTimeSymbols_it_IT',
  'goog.i18n.DateTimeSymbols_it_SM',
  'goog.i18n.DateTimeSymbols_ja_JP',
  'goog.i18n.DateTimeSymbols_jgo',
  'goog.i18n.DateTimeSymbols_jgo_CM',
  'goog.i18n.DateTimeSymbols_jmc',
  'goog.i18n.DateTimeSymbols_jmc_TZ',
  'goog.i18n.DateTimeSymbols_ka',
  'goog.i18n.DateTimeSymbols_ka_GE',
  'goog.i18n.DateTimeSymbols_kab',
  'goog.i18n.DateTimeSymbols_kab_DZ',
  'goog.i18n.DateTimeSymbols_kam',
  'goog.i18n.DateTimeSymbols_kam_KE',
  'goog.i18n.DateTimeSymbols_kde',
  'goog.i18n.DateTimeSymbols_kde_TZ',
  'goog.i18n.DateTimeSymbols_kea',
  'goog.i18n.DateTimeSymbols_kea_CV',
  'goog.i18n.DateTimeSymbols_khq',
  'goog.i18n.DateTimeSymbols_khq_ML',
  'goog.i18n.DateTimeSymbols_ki',
  'goog.i18n.DateTimeSymbols_ki_KE',
  'goog.i18n.DateTimeSymbols_kk',
  'goog.i18n.DateTimeSymbols_kk_Cyrl',
  'goog.i18n.DateTimeSymbols_kk_Cyrl_KZ',
  'goog.i18n.DateTimeSymbols_kkj',
  'goog.i18n.DateTimeSymbols_kkj_CM',
  'goog.i18n.DateTimeSymbols_kl',
  'goog.i18n.DateTimeSymbols_kl_GL',
  'goog.i18n.DateTimeSymbols_kln',
  'goog.i18n.DateTimeSymbols_kln_KE',
  'goog.i18n.DateTimeSymbols_km',
  'goog.i18n.DateTimeSymbols_km_KH',
  'goog.i18n.DateTimeSymbols_kn_IN',
  'goog.i18n.DateTimeSymbols_ko_KP',
  'goog.i18n.DateTimeSymbols_ko_KR',
  'goog.i18n.DateTimeSymbols_kok',
  'goog.i18n.DateTimeSymbols_kok_IN',
  'goog.i18n.DateTimeSymbols_ks',
  'goog.i18n.DateTimeSymbols_ks_Arab',
  'goog.i18n.DateTimeSymbols_ks_Arab_IN',
  'goog.i18n.DateTimeSymbols_ksb',
  'goog.i18n.DateTimeSymbols_ksb_TZ',
  'goog.i18n.DateTimeSymbols_ksf',
  'goog.i18n.DateTimeSymbols_ksf_CM',
  'goog.i18n.DateTimeSymbols_ksh',
  'goog.i18n.DateTimeSymbols_ksh_DE',
  'goog.i18n.DateTimeSymbols_kw',
  'goog.i18n.DateTimeSymbols_kw_GB',
  'goog.i18n.DateTimeSymbols_ky',
  'goog.i18n.DateTimeSymbols_ky_KG',
  'goog.i18n.DateTimeSymbols_lag',
  'goog.i18n.DateTimeSymbols_lag_TZ',
  'goog.i18n.DateTimeSymbols_lg',
  'goog.i18n.DateTimeSymbols_lg_UG',
  'goog.i18n.DateTimeSymbols_ln_AO',
  'goog.i18n.DateTimeSymbols_ln_CD',
  'goog.i18n.DateTimeSymbols_ln_CF',
  'goog.i18n.DateTimeSymbols_ln_CG',
  'goog.i18n.DateTimeSymbols_lo',
  'goog.i18n.DateTimeSymbols_lo_LA',
  'goog.i18n.DateTimeSymbols_lt_LT',
  'goog.i18n.DateTimeSymbols_lu',
  'goog.i18n.DateTimeSymbols_lu_CD',
  'goog.i18n.DateTimeSymbols_luo',
  'goog.i18n.DateTimeSymbols_luo_KE',
  'goog.i18n.DateTimeSymbols_luy',
  'goog.i18n.DateTimeSymbols_luy_KE',
  'goog.i18n.DateTimeSymbols_lv_LV',
  'goog.i18n.DateTimeSymbols_mas',
  'goog.i18n.DateTimeSymbols_mas_KE',
  'goog.i18n.DateTimeSymbols_mas_TZ',
  'goog.i18n.DateTimeSymbols_mer',
  'goog.i18n.DateTimeSymbols_mer_KE',
  'goog.i18n.DateTimeSymbols_mfe',
  'goog.i18n.DateTimeSymbols_mfe_MU',
  'goog.i18n.DateTimeSymbols_mg',
  'goog.i18n.DateTimeSymbols_mg_MG',
  'goog.i18n.DateTimeSymbols_mgh',
  'goog.i18n.DateTimeSymbols_mgh_MZ',
  'goog.i18n.DateTimeSymbols_mgo',
  'goog.i18n.DateTimeSymbols_mgo_CM',
  'goog.i18n.DateTimeSymbols_mk',
  'goog.i18n.DateTimeSymbols_mk_MK',
  'goog.i18n.DateTimeSymbols_ml_IN',
  'goog.i18n.DateTimeSymbols_mn',
  'goog.i18n.DateTimeSymbols_mn_Cyrl',
  'goog.i18n.DateTimeSymbols_mn_Cyrl_MN',
  'goog.i18n.DateTimeSymbols_mr_IN',
  'goog.i18n.DateTimeSymbols_ms_Latn',
  'goog.i18n.DateTimeSymbols_ms_Latn_BN',
  'goog.i18n.DateTimeSymbols_ms_Latn_MY',
  'goog.i18n.DateTimeSymbols_ms_Latn_SG',
  'goog.i18n.DateTimeSymbols_mt_MT',
  'goog.i18n.DateTimeSymbols_mua',
  'goog.i18n.DateTimeSymbols_mua_CM',
  'goog.i18n.DateTimeSymbols_my',
  'goog.i18n.DateTimeSymbols_my_MM',
  'goog.i18n.DateTimeSymbols_naq',
  'goog.i18n.DateTimeSymbols_naq_NA',
  'goog.i18n.DateTimeSymbols_nb_NO',
  'goog.i18n.DateTimeSymbols_nd',
  'goog.i18n.DateTimeSymbols_nd_ZW',
  'goog.i18n.DateTimeSymbols_ne',
  'goog.i18n.DateTimeSymbols_ne_IN',
  'goog.i18n.DateTimeSymbols_ne_NP',
  'goog.i18n.DateTimeSymbols_nl_AW',
  'goog.i18n.DateTimeSymbols_nl_BE',
  'goog.i18n.DateTimeSymbols_nl_CW',
  'goog.i18n.DateTimeSymbols_nl_NL',
  'goog.i18n.DateTimeSymbols_nl_SR',
  'goog.i18n.DateTimeSymbols_nl_SX',
  'goog.i18n.DateTimeSymbols_nmg',
  'goog.i18n.DateTimeSymbols_nmg_CM',
  'goog.i18n.DateTimeSymbols_nn',
  'goog.i18n.DateTimeSymbols_nn_NO',
  'goog.i18n.DateTimeSymbols_nnh',
  'goog.i18n.DateTimeSymbols_nnh_CM',
  'goog.i18n.DateTimeSymbols_nr',
  'goog.i18n.DateTimeSymbols_nr_ZA',
  'goog.i18n.DateTimeSymbols_nso',
  'goog.i18n.DateTimeSymbols_nso_ZA',
  'goog.i18n.DateTimeSymbols_nus',
  'goog.i18n.DateTimeSymbols_nus_SD',
  'goog.i18n.DateTimeSymbols_nyn',
  'goog.i18n.DateTimeSymbols_nyn_UG',
  'goog.i18n.DateTimeSymbols_om',
  'goog.i18n.DateTimeSymbols_om_ET',
  'goog.i18n.DateTimeSymbols_om_KE',
  'goog.i18n.DateTimeSymbols_or_IN',
  'goog.i18n.DateTimeSymbols_os',
  'goog.i18n.DateTimeSymbols_os_GE',
  'goog.i18n.DateTimeSymbols_os_RU',
  'goog.i18n.DateTimeSymbols_pa',
  'goog.i18n.DateTimeSymbols_pa_Arab',
  'goog.i18n.DateTimeSymbols_pa_Arab_PK',
  'goog.i18n.DateTimeSymbols_pa_Guru',
  'goog.i18n.DateTimeSymbols_pa_Guru_IN',
  'goog.i18n.DateTimeSymbols_pl_PL',
  'goog.i18n.DateTimeSymbols_ps',
  'goog.i18n.DateTimeSymbols_ps_AF',
  'goog.i18n.DateTimeSymbols_pt_AO',
  'goog.i18n.DateTimeSymbols_pt_CV',
  'goog.i18n.DateTimeSymbols_pt_GW',
  'goog.i18n.DateTimeSymbols_pt_MO',
  'goog.i18n.DateTimeSymbols_pt_MZ',
  'goog.i18n.DateTimeSymbols_pt_ST',
  'goog.i18n.DateTimeSymbols_pt_TL',
  'goog.i18n.DateTimeSymbols_rm',
  'goog.i18n.DateTimeSymbols_rm_CH',
  'goog.i18n.DateTimeSymbols_rn',
  'goog.i18n.DateTimeSymbols_rn_BI',
  'goog.i18n.DateTimeSymbols_ro_MD',
  'goog.i18n.DateTimeSymbols_ro_RO',
  'goog.i18n.DateTimeSymbols_rof',
  'goog.i18n.DateTimeSymbols_rof_TZ',
  'goog.i18n.DateTimeSymbols_ru_BY',
  'goog.i18n.DateTimeSymbols_ru_KG',
  'goog.i18n.DateTimeSymbols_ru_KZ',
  'goog.i18n.DateTimeSymbols_ru_MD',
  'goog.i18n.DateTimeSymbols_ru_RU',
  'goog.i18n.DateTimeSymbols_ru_UA',
  'goog.i18n.DateTimeSymbols_rw',
  'goog.i18n.DateTimeSymbols_rw_RW',
  'goog.i18n.DateTimeSymbols_rwk',
  'goog.i18n.DateTimeSymbols_rwk_TZ',
  'goog.i18n.DateTimeSymbols_sah',
  'goog.i18n.DateTimeSymbols_sah_RU',
  'goog.i18n.DateTimeSymbols_saq',
  'goog.i18n.DateTimeSymbols_saq_KE',
  'goog.i18n.DateTimeSymbols_sbp',
  'goog.i18n.DateTimeSymbols_sbp_TZ',
  'goog.i18n.DateTimeSymbols_se',
  'goog.i18n.DateTimeSymbols_se_FI',
  'goog.i18n.DateTimeSymbols_se_NO',
  'goog.i18n.DateTimeSymbols_seh',
  'goog.i18n.DateTimeSymbols_seh_MZ',
  'goog.i18n.DateTimeSymbols_ses',
  'goog.i18n.DateTimeSymbols_ses_ML',
  'goog.i18n.DateTimeSymbols_sg',
  'goog.i18n.DateTimeSymbols_sg_CF',
  'goog.i18n.DateTimeSymbols_shi',
  'goog.i18n.DateTimeSymbols_shi_Latn',
  'goog.i18n.DateTimeSymbols_shi_Latn_MA',
  'goog.i18n.DateTimeSymbols_shi_Tfng',
  'goog.i18n.DateTimeSymbols_shi_Tfng_MA',
  'goog.i18n.DateTimeSymbols_si',
  'goog.i18n.DateTimeSymbols_si_LK',
  'goog.i18n.DateTimeSymbols_sk_SK',
  'goog.i18n.DateTimeSymbols_sl_SI',
  'goog.i18n.DateTimeSymbols_sn',
  'goog.i18n.DateTimeSymbols_sn_ZW',
  'goog.i18n.DateTimeSymbols_so',
  'goog.i18n.DateTimeSymbols_so_DJ',
  'goog.i18n.DateTimeSymbols_so_ET',
  'goog.i18n.DateTimeSymbols_so_KE',
  'goog.i18n.DateTimeSymbols_so_SO',
  'goog.i18n.DateTimeSymbols_sq_AL',
  'goog.i18n.DateTimeSymbols_sq_MK',
  'goog.i18n.DateTimeSymbols_sq_XK',
  'goog.i18n.DateTimeSymbols_sr_Cyrl',
  'goog.i18n.DateTimeSymbols_sr_Cyrl_BA',
  'goog.i18n.DateTimeSymbols_sr_Cyrl_ME',
  'goog.i18n.DateTimeSymbols_sr_Cyrl_RS',
  'goog.i18n.DateTimeSymbols_sr_Cyrl_XK',
  'goog.i18n.DateTimeSymbols_sr_Latn',
  'goog.i18n.DateTimeSymbols_sr_Latn_BA',
  'goog.i18n.DateTimeSymbols_sr_Latn_ME',
  'goog.i18n.DateTimeSymbols_sr_Latn_RS',
  'goog.i18n.DateTimeSymbols_sr_Latn_XK',
  'goog.i18n.DateTimeSymbols_ss',
  'goog.i18n.DateTimeSymbols_ss_SZ',
  'goog.i18n.DateTimeSymbols_ss_ZA',
  'goog.i18n.DateTimeSymbols_ssy',
  'goog.i18n.DateTimeSymbols_ssy_ER',
  'goog.i18n.DateTimeSymbols_st',
  'goog.i18n.DateTimeSymbols_st_LS',
  'goog.i18n.DateTimeSymbols_st_ZA',
  'goog.i18n.DateTimeSymbols_sv_AX',
  'goog.i18n.DateTimeSymbols_sv_FI',
  'goog.i18n.DateTimeSymbols_sv_SE',
  'goog.i18n.DateTimeSymbols_sw_KE',
  'goog.i18n.DateTimeSymbols_sw_TZ',
  'goog.i18n.DateTimeSymbols_sw_UG',
  'goog.i18n.DateTimeSymbols_swc',
  'goog.i18n.DateTimeSymbols_swc_CD',
  'goog.i18n.DateTimeSymbols_ta_IN',
  'goog.i18n.DateTimeSymbols_ta_LK',
  'goog.i18n.DateTimeSymbols_ta_MY',
  'goog.i18n.DateTimeSymbols_ta_SG',
  'goog.i18n.DateTimeSymbols_te_IN',
  'goog.i18n.DateTimeSymbols_teo',
  'goog.i18n.DateTimeSymbols_teo_KE',
  'goog.i18n.DateTimeSymbols_teo_UG',
  'goog.i18n.DateTimeSymbols_tg',
  'goog.i18n.DateTimeSymbols_tg_Cyrl',
  'goog.i18n.DateTimeSymbols_tg_Cyrl_TJ',
  'goog.i18n.DateTimeSymbols_th_TH',
  'goog.i18n.DateTimeSymbols_ti',
  'goog.i18n.DateTimeSymbols_ti_ER',
  'goog.i18n.DateTimeSymbols_ti_ET',
  'goog.i18n.DateTimeSymbols_tig',
  'goog.i18n.DateTimeSymbols_tig_ER',
  'goog.i18n.DateTimeSymbols_tn',
  'goog.i18n.DateTimeSymbols_tn_BW',
  'goog.i18n.DateTimeSymbols_tn_ZA',
  'goog.i18n.DateTimeSymbols_to',
  'goog.i18n.DateTimeSymbols_to_TO',
  'goog.i18n.DateTimeSymbols_tr_CY',
  'goog.i18n.DateTimeSymbols_tr_TR',
  'goog.i18n.DateTimeSymbols_ts',
  'goog.i18n.DateTimeSymbols_ts_ZA',
  'goog.i18n.DateTimeSymbols_twq',
  'goog.i18n.DateTimeSymbols_twq_NE',
  'goog.i18n.DateTimeSymbols_tzm',
  'goog.i18n.DateTimeSymbols_tzm_Latn',
  'goog.i18n.DateTimeSymbols_tzm_Latn_MA',
  'goog.i18n.DateTimeSymbols_uk_UA',
  'goog.i18n.DateTimeSymbols_ur_IN',
  'goog.i18n.DateTimeSymbols_ur_PK',
  'goog.i18n.DateTimeSymbols_uz',
  'goog.i18n.DateTimeSymbols_uz_Arab',
  'goog.i18n.DateTimeSymbols_uz_Arab_AF',
  'goog.i18n.DateTimeSymbols_uz_Cyrl',
  'goog.i18n.DateTimeSymbols_uz_Cyrl_UZ',
  'goog.i18n.DateTimeSymbols_uz_Latn',
  'goog.i18n.DateTimeSymbols_uz_Latn_UZ',
  'goog.i18n.DateTimeSymbols_vai',
  'goog.i18n.DateTimeSymbols_vai_Latn',
  'goog.i18n.DateTimeSymbols_vai_Latn_LR',
  'goog.i18n.DateTimeSymbols_vai_Vaii',
  'goog.i18n.DateTimeSymbols_vai_Vaii_LR',
  'goog.i18n.DateTimeSymbols_ve',
  'goog.i18n.DateTimeSymbols_ve_ZA',
  'goog.i18n.DateTimeSymbols_vi_VN',
  'goog.i18n.DateTimeSymbols_vo',
  'goog.i18n.DateTimeSymbols_vun',
  'goog.i18n.DateTimeSymbols_vun_TZ',
  'goog.i18n.DateTimeSymbols_wae',
  'goog.i18n.DateTimeSymbols_wae_CH',
  'goog.i18n.DateTimeSymbols_wal',
  'goog.i18n.DateTimeSymbols_wal_ET',
  'goog.i18n.DateTimeSymbols_xh',
  'goog.i18n.DateTimeSymbols_xh_ZA',
  'goog.i18n.DateTimeSymbols_xog',
  'goog.i18n.DateTimeSymbols_xog_UG',
  'goog.i18n.DateTimeSymbols_yav',
  'goog.i18n.DateTimeSymbols_yav_CM',
  'goog.i18n.DateTimeSymbols_yo',
  'goog.i18n.DateTimeSymbols_yo_NG',
  'goog.i18n.DateTimeSymbols_zh_Hans',
  'goog.i18n.DateTimeSymbols_zh_Hans_CN',
  'goog.i18n.DateTimeSymbols_zh_Hans_HK',
  'goog.i18n.DateTimeSymbols_zh_Hans_MO',
  'goog.i18n.DateTimeSymbols_zh_Hans_SG',
  'goog.i18n.DateTimeSymbols_zh_Hant',
  'goog.i18n.DateTimeSymbols_zh_Hant_HK',
  'goog.i18n.DateTimeSymbols_zh_Hant_MO',
  'goog.i18n.DateTimeSymbols_zh_Hant_TW',
  'goog.i18n.DateTimeSymbols_zu_ZA'
], ['goog.i18n.DateTimeSymbols']);
goog.addDependency('i18n/graphemebreak.js', ['goog.i18n.GraphemeBreak'], ['goog.structs.InversionMap']);
goog.addDependency('i18n/messageformat.js', ['goog.i18n.MessageFormat'], [
  'goog.asserts',
  'goog.i18n.NumberFormat',
  'goog.i18n.ordinalRules',
  'goog.i18n.pluralRules'
]);
goog.addDependency('i18n/mime.js', [
  'goog.i18n.mime',
  'goog.i18n.mime.encode'
], ['goog.array']);
goog.addDependency('i18n/numberformat.js', [
  'goog.i18n.NumberFormat',
  'goog.i18n.NumberFormat.CurrencyStyle',
  'goog.i18n.NumberFormat.Format'
], [
  'goog.asserts',
  'goog.i18n.CompactNumberFormatSymbols',
  'goog.i18n.NumberFormatSymbols',
  'goog.i18n.currency',
  'goog.math'
]);
goog.addDependency('i18n/numberformatsymbols.js', [
  'goog.i18n.NumberFormatSymbols',
  'goog.i18n.NumberFormatSymbols_af',
  'goog.i18n.NumberFormatSymbols_af_ZA',
  'goog.i18n.NumberFormatSymbols_am',
  'goog.i18n.NumberFormatSymbols_am_ET',
  'goog.i18n.NumberFormatSymbols_ar',
  'goog.i18n.NumberFormatSymbols_ar_001',
  'goog.i18n.NumberFormatSymbols_ar_EG',
  'goog.i18n.NumberFormatSymbols_bg',
  'goog.i18n.NumberFormatSymbols_bg_BG',
  'goog.i18n.NumberFormatSymbols_bn',
  'goog.i18n.NumberFormatSymbols_bn_BD',
  'goog.i18n.NumberFormatSymbols_br',
  'goog.i18n.NumberFormatSymbols_br_FR',
  'goog.i18n.NumberFormatSymbols_ca',
  'goog.i18n.NumberFormatSymbols_ca_AD',
  'goog.i18n.NumberFormatSymbols_ca_ES',
  'goog.i18n.NumberFormatSymbols_chr',
  'goog.i18n.NumberFormatSymbols_chr_US',
  'goog.i18n.NumberFormatSymbols_cs',
  'goog.i18n.NumberFormatSymbols_cs_CZ',
  'goog.i18n.NumberFormatSymbols_cy',
  'goog.i18n.NumberFormatSymbols_cy_GB',
  'goog.i18n.NumberFormatSymbols_da',
  'goog.i18n.NumberFormatSymbols_da_DK',
  'goog.i18n.NumberFormatSymbols_de',
  'goog.i18n.NumberFormatSymbols_de_AT',
  'goog.i18n.NumberFormatSymbols_de_BE',
  'goog.i18n.NumberFormatSymbols_de_CH',
  'goog.i18n.NumberFormatSymbols_de_DE',
  'goog.i18n.NumberFormatSymbols_de_LU',
  'goog.i18n.NumberFormatSymbols_el',
  'goog.i18n.NumberFormatSymbols_el_GR',
  'goog.i18n.NumberFormatSymbols_en',
  'goog.i18n.NumberFormatSymbols_en_AS',
  'goog.i18n.NumberFormatSymbols_en_AU',
  'goog.i18n.NumberFormatSymbols_en_Dsrt_US',
  'goog.i18n.NumberFormatSymbols_en_FM',
  'goog.i18n.NumberFormatSymbols_en_GB',
  'goog.i18n.NumberFormatSymbols_en_GU',
  'goog.i18n.NumberFormatSymbols_en_IE',
  'goog.i18n.NumberFormatSymbols_en_IN',
  'goog.i18n.NumberFormatSymbols_en_MH',
  'goog.i18n.NumberFormatSymbols_en_MP',
  'goog.i18n.NumberFormatSymbols_en_PR',
  'goog.i18n.NumberFormatSymbols_en_PW',
  'goog.i18n.NumberFormatSymbols_en_SG',
  'goog.i18n.NumberFormatSymbols_en_TC',
  'goog.i18n.NumberFormatSymbols_en_UM',
  'goog.i18n.NumberFormatSymbols_en_US',
  'goog.i18n.NumberFormatSymbols_en_VG',
  'goog.i18n.NumberFormatSymbols_en_VI',
  'goog.i18n.NumberFormatSymbols_en_ZA',
  'goog.i18n.NumberFormatSymbols_es',
  'goog.i18n.NumberFormatSymbols_es_419',
  'goog.i18n.NumberFormatSymbols_es_EA',
  'goog.i18n.NumberFormatSymbols_es_ES',
  'goog.i18n.NumberFormatSymbols_es_IC',
  'goog.i18n.NumberFormatSymbols_et',
  'goog.i18n.NumberFormatSymbols_et_EE',
  'goog.i18n.NumberFormatSymbols_eu',
  'goog.i18n.NumberFormatSymbols_eu_ES',
  'goog.i18n.NumberFormatSymbols_fa',
  'goog.i18n.NumberFormatSymbols_fa_IR',
  'goog.i18n.NumberFormatSymbols_fi',
  'goog.i18n.NumberFormatSymbols_fi_FI',
  'goog.i18n.NumberFormatSymbols_fil',
  'goog.i18n.NumberFormatSymbols_fil_PH',
  'goog.i18n.NumberFormatSymbols_fr',
  'goog.i18n.NumberFormatSymbols_fr_BL',
  'goog.i18n.NumberFormatSymbols_fr_CA',
  'goog.i18n.NumberFormatSymbols_fr_FR',
  'goog.i18n.NumberFormatSymbols_fr_GF',
  'goog.i18n.NumberFormatSymbols_fr_GP',
  'goog.i18n.NumberFormatSymbols_fr_MC',
  'goog.i18n.NumberFormatSymbols_fr_MF',
  'goog.i18n.NumberFormatSymbols_fr_MQ',
  'goog.i18n.NumberFormatSymbols_fr_RE',
  'goog.i18n.NumberFormatSymbols_fr_YT',
  'goog.i18n.NumberFormatSymbols_gl',
  'goog.i18n.NumberFormatSymbols_gl_ES',
  'goog.i18n.NumberFormatSymbols_gsw',
  'goog.i18n.NumberFormatSymbols_gsw_CH',
  'goog.i18n.NumberFormatSymbols_gu',
  'goog.i18n.NumberFormatSymbols_gu_IN',
  'goog.i18n.NumberFormatSymbols_haw',
  'goog.i18n.NumberFormatSymbols_haw_US',
  'goog.i18n.NumberFormatSymbols_he',
  'goog.i18n.NumberFormatSymbols_he_IL',
  'goog.i18n.NumberFormatSymbols_hi',
  'goog.i18n.NumberFormatSymbols_hi_IN',
  'goog.i18n.NumberFormatSymbols_hr',
  'goog.i18n.NumberFormatSymbols_hr_HR',
  'goog.i18n.NumberFormatSymbols_hu',
  'goog.i18n.NumberFormatSymbols_hu_HU',
  'goog.i18n.NumberFormatSymbols_id',
  'goog.i18n.NumberFormatSymbols_id_ID',
  'goog.i18n.NumberFormatSymbols_in',
  'goog.i18n.NumberFormatSymbols_is',
  'goog.i18n.NumberFormatSymbols_is_IS',
  'goog.i18n.NumberFormatSymbols_it',
  'goog.i18n.NumberFormatSymbols_it_IT',
  'goog.i18n.NumberFormatSymbols_it_SM',
  'goog.i18n.NumberFormatSymbols_iw',
  'goog.i18n.NumberFormatSymbols_ja',
  'goog.i18n.NumberFormatSymbols_ja_JP',
  'goog.i18n.NumberFormatSymbols_kn',
  'goog.i18n.NumberFormatSymbols_kn_IN',
  'goog.i18n.NumberFormatSymbols_ko',
  'goog.i18n.NumberFormatSymbols_ko_KR',
  'goog.i18n.NumberFormatSymbols_ln',
  'goog.i18n.NumberFormatSymbols_ln_CD',
  'goog.i18n.NumberFormatSymbols_lt',
  'goog.i18n.NumberFormatSymbols_lt_LT',
  'goog.i18n.NumberFormatSymbols_lv',
  'goog.i18n.NumberFormatSymbols_lv_LV',
  'goog.i18n.NumberFormatSymbols_ml',
  'goog.i18n.NumberFormatSymbols_ml_IN',
  'goog.i18n.NumberFormatSymbols_mr',
  'goog.i18n.NumberFormatSymbols_mr_IN',
  'goog.i18n.NumberFormatSymbols_ms',
  'goog.i18n.NumberFormatSymbols_ms_Latn_MY',
  'goog.i18n.NumberFormatSymbols_mt',
  'goog.i18n.NumberFormatSymbols_mt_MT',
  'goog.i18n.NumberFormatSymbols_nb',
  'goog.i18n.NumberFormatSymbols_nb_NO',
  'goog.i18n.NumberFormatSymbols_nl',
  'goog.i18n.NumberFormatSymbols_nl_NL',
  'goog.i18n.NumberFormatSymbols_no',
  'goog.i18n.NumberFormatSymbols_or',
  'goog.i18n.NumberFormatSymbols_or_IN',
  'goog.i18n.NumberFormatSymbols_pl',
  'goog.i18n.NumberFormatSymbols_pl_PL',
  'goog.i18n.NumberFormatSymbols_pt',
  'goog.i18n.NumberFormatSymbols_pt_BR',
  'goog.i18n.NumberFormatSymbols_pt_PT',
  'goog.i18n.NumberFormatSymbols_ro',
  'goog.i18n.NumberFormatSymbols_ro_RO',
  'goog.i18n.NumberFormatSymbols_ru',
  'goog.i18n.NumberFormatSymbols_ru_RU',
  'goog.i18n.NumberFormatSymbols_sk',
  'goog.i18n.NumberFormatSymbols_sk_SK',
  'goog.i18n.NumberFormatSymbols_sl',
  'goog.i18n.NumberFormatSymbols_sl_SI',
  'goog.i18n.NumberFormatSymbols_sq',
  'goog.i18n.NumberFormatSymbols_sq_AL',
  'goog.i18n.NumberFormatSymbols_sr',
  'goog.i18n.NumberFormatSymbols_sr_Cyrl_RS',
  'goog.i18n.NumberFormatSymbols_sv',
  'goog.i18n.NumberFormatSymbols_sv_SE',
  'goog.i18n.NumberFormatSymbols_sw',
  'goog.i18n.NumberFormatSymbols_sw_TZ',
  'goog.i18n.NumberFormatSymbols_ta',
  'goog.i18n.NumberFormatSymbols_ta_IN',
  'goog.i18n.NumberFormatSymbols_te',
  'goog.i18n.NumberFormatSymbols_te_IN',
  'goog.i18n.NumberFormatSymbols_th',
  'goog.i18n.NumberFormatSymbols_th_TH',
  'goog.i18n.NumberFormatSymbols_tl',
  'goog.i18n.NumberFormatSymbols_tr',
  'goog.i18n.NumberFormatSymbols_tr_TR',
  'goog.i18n.NumberFormatSymbols_uk',
  'goog.i18n.NumberFormatSymbols_uk_UA',
  'goog.i18n.NumberFormatSymbols_ur',
  'goog.i18n.NumberFormatSymbols_ur_PK',
  'goog.i18n.NumberFormatSymbols_vi',
  'goog.i18n.NumberFormatSymbols_vi_VN',
  'goog.i18n.NumberFormatSymbols_zh',
  'goog.i18n.NumberFormatSymbols_zh_CN',
  'goog.i18n.NumberFormatSymbols_zh_HK',
  'goog.i18n.NumberFormatSymbols_zh_Hans_CN',
  'goog.i18n.NumberFormatSymbols_zh_TW',
  'goog.i18n.NumberFormatSymbols_zu',
  'goog.i18n.NumberFormatSymbols_zu_ZA'
], []);
goog.addDependency('i18n/numberformatsymbolsext.js', [
  'goog.i18n.NumberFormatSymbolsExt',
  'goog.i18n.NumberFormatSymbols_aa',
  'goog.i18n.NumberFormatSymbols_aa_DJ',
  'goog.i18n.NumberFormatSymbols_aa_ER',
  'goog.i18n.NumberFormatSymbols_aa_ET',
  'goog.i18n.NumberFormatSymbols_af_NA',
  'goog.i18n.NumberFormatSymbols_agq',
  'goog.i18n.NumberFormatSymbols_agq_CM',
  'goog.i18n.NumberFormatSymbols_ak',
  'goog.i18n.NumberFormatSymbols_ak_GH',
  'goog.i18n.NumberFormatSymbols_ar_AE',
  'goog.i18n.NumberFormatSymbols_ar_BH',
  'goog.i18n.NumberFormatSymbols_ar_DJ',
  'goog.i18n.NumberFormatSymbols_ar_DZ',
  'goog.i18n.NumberFormatSymbols_ar_EH',
  'goog.i18n.NumberFormatSymbols_ar_ER',
  'goog.i18n.NumberFormatSymbols_ar_IL',
  'goog.i18n.NumberFormatSymbols_ar_IQ',
  'goog.i18n.NumberFormatSymbols_ar_JO',
  'goog.i18n.NumberFormatSymbols_ar_KM',
  'goog.i18n.NumberFormatSymbols_ar_KW',
  'goog.i18n.NumberFormatSymbols_ar_LB',
  'goog.i18n.NumberFormatSymbols_ar_LY',
  'goog.i18n.NumberFormatSymbols_ar_MA',
  'goog.i18n.NumberFormatSymbols_ar_MR',
  'goog.i18n.NumberFormatSymbols_ar_OM',
  'goog.i18n.NumberFormatSymbols_ar_PS',
  'goog.i18n.NumberFormatSymbols_ar_QA',
  'goog.i18n.NumberFormatSymbols_ar_SA',
  'goog.i18n.NumberFormatSymbols_ar_SD',
  'goog.i18n.NumberFormatSymbols_ar_SO',
  'goog.i18n.NumberFormatSymbols_ar_SY',
  'goog.i18n.NumberFormatSymbols_ar_TD',
  'goog.i18n.NumberFormatSymbols_ar_TN',
  'goog.i18n.NumberFormatSymbols_ar_YE',
  'goog.i18n.NumberFormatSymbols_as',
  'goog.i18n.NumberFormatSymbols_as_IN',
  'goog.i18n.NumberFormatSymbols_asa',
  'goog.i18n.NumberFormatSymbols_asa_TZ',
  'goog.i18n.NumberFormatSymbols_ast',
  'goog.i18n.NumberFormatSymbols_ast_ES',
  'goog.i18n.NumberFormatSymbols_az',
  'goog.i18n.NumberFormatSymbols_az_Cyrl',
  'goog.i18n.NumberFormatSymbols_az_Cyrl_AZ',
  'goog.i18n.NumberFormatSymbols_az_Latn',
  'goog.i18n.NumberFormatSymbols_az_Latn_AZ',
  'goog.i18n.NumberFormatSymbols_bas',
  'goog.i18n.NumberFormatSymbols_bas_CM',
  'goog.i18n.NumberFormatSymbols_be',
  'goog.i18n.NumberFormatSymbols_be_BY',
  'goog.i18n.NumberFormatSymbols_bem',
  'goog.i18n.NumberFormatSymbols_bem_ZM',
  'goog.i18n.NumberFormatSymbols_bez',
  'goog.i18n.NumberFormatSymbols_bez_TZ',
  'goog.i18n.NumberFormatSymbols_bm',
  'goog.i18n.NumberFormatSymbols_bm_ML',
  'goog.i18n.NumberFormatSymbols_bn_IN',
  'goog.i18n.NumberFormatSymbols_bo',
  'goog.i18n.NumberFormatSymbols_bo_CN',
  'goog.i18n.NumberFormatSymbols_bo_IN',
  'goog.i18n.NumberFormatSymbols_brx',
  'goog.i18n.NumberFormatSymbols_brx_IN',
  'goog.i18n.NumberFormatSymbols_bs',
  'goog.i18n.NumberFormatSymbols_bs_Cyrl',
  'goog.i18n.NumberFormatSymbols_bs_Cyrl_BA',
  'goog.i18n.NumberFormatSymbols_bs_Latn',
  'goog.i18n.NumberFormatSymbols_bs_Latn_BA',
  'goog.i18n.NumberFormatSymbols_byn',
  'goog.i18n.NumberFormatSymbols_byn_ER',
  'goog.i18n.NumberFormatSymbols_cgg',
  'goog.i18n.NumberFormatSymbols_cgg_UG',
  'goog.i18n.NumberFormatSymbols_ckb',
  'goog.i18n.NumberFormatSymbols_ckb_Arab',
  'goog.i18n.NumberFormatSymbols_ckb_Arab_IQ',
  'goog.i18n.NumberFormatSymbols_ckb_Arab_IR',
  'goog.i18n.NumberFormatSymbols_ckb_IQ',
  'goog.i18n.NumberFormatSymbols_ckb_IR',
  'goog.i18n.NumberFormatSymbols_ckb_Latn',
  'goog.i18n.NumberFormatSymbols_ckb_Latn_IQ',
  'goog.i18n.NumberFormatSymbols_dav',
  'goog.i18n.NumberFormatSymbols_dav_KE',
  'goog.i18n.NumberFormatSymbols_de_LI',
  'goog.i18n.NumberFormatSymbols_dje',
  'goog.i18n.NumberFormatSymbols_dje_NE',
  'goog.i18n.NumberFormatSymbols_dua',
  'goog.i18n.NumberFormatSymbols_dua_CM',
  'goog.i18n.NumberFormatSymbols_dyo',
  'goog.i18n.NumberFormatSymbols_dyo_SN',
  'goog.i18n.NumberFormatSymbols_dz',
  'goog.i18n.NumberFormatSymbols_dz_BT',
  'goog.i18n.NumberFormatSymbols_ebu',
  'goog.i18n.NumberFormatSymbols_ebu_KE',
  'goog.i18n.NumberFormatSymbols_ee',
  'goog.i18n.NumberFormatSymbols_ee_GH',
  'goog.i18n.NumberFormatSymbols_ee_TG',
  'goog.i18n.NumberFormatSymbols_el_CY',
  'goog.i18n.NumberFormatSymbols_en_150',
  'goog.i18n.NumberFormatSymbols_en_AG',
  'goog.i18n.NumberFormatSymbols_en_BB',
  'goog.i18n.NumberFormatSymbols_en_BE',
  'goog.i18n.NumberFormatSymbols_en_BM',
  'goog.i18n.NumberFormatSymbols_en_BS',
  'goog.i18n.NumberFormatSymbols_en_BW',
  'goog.i18n.NumberFormatSymbols_en_BZ',
  'goog.i18n.NumberFormatSymbols_en_CA',
  'goog.i18n.NumberFormatSymbols_en_CM',
  'goog.i18n.NumberFormatSymbols_en_DM',
  'goog.i18n.NumberFormatSymbols_en_Dsrt',
  'goog.i18n.NumberFormatSymbols_en_FJ',
  'goog.i18n.NumberFormatSymbols_en_GD',
  'goog.i18n.NumberFormatSymbols_en_GG',
  'goog.i18n.NumberFormatSymbols_en_GH',
  'goog.i18n.NumberFormatSymbols_en_GI',
  'goog.i18n.NumberFormatSymbols_en_GM',
  'goog.i18n.NumberFormatSymbols_en_GY',
  'goog.i18n.NumberFormatSymbols_en_HK',
  'goog.i18n.NumberFormatSymbols_en_IM',
  'goog.i18n.NumberFormatSymbols_en_JE',
  'goog.i18n.NumberFormatSymbols_en_JM',
  'goog.i18n.NumberFormatSymbols_en_KE',
  'goog.i18n.NumberFormatSymbols_en_KI',
  'goog.i18n.NumberFormatSymbols_en_KN',
  'goog.i18n.NumberFormatSymbols_en_KY',
  'goog.i18n.NumberFormatSymbols_en_LC',
  'goog.i18n.NumberFormatSymbols_en_LR',
  'goog.i18n.NumberFormatSymbols_en_LS',
  'goog.i18n.NumberFormatSymbols_en_MG',
  'goog.i18n.NumberFormatSymbols_en_MT',
  'goog.i18n.NumberFormatSymbols_en_MU',
  'goog.i18n.NumberFormatSymbols_en_MW',
  'goog.i18n.NumberFormatSymbols_en_NA',
  'goog.i18n.NumberFormatSymbols_en_NG',
  'goog.i18n.NumberFormatSymbols_en_NZ',
  'goog.i18n.NumberFormatSymbols_en_PG',
  'goog.i18n.NumberFormatSymbols_en_PH',
  'goog.i18n.NumberFormatSymbols_en_PK',
  'goog.i18n.NumberFormatSymbols_en_SB',
  'goog.i18n.NumberFormatSymbols_en_SC',
  'goog.i18n.NumberFormatSymbols_en_SL',
  'goog.i18n.NumberFormatSymbols_en_SS',
  'goog.i18n.NumberFormatSymbols_en_SZ',
  'goog.i18n.NumberFormatSymbols_en_TO',
  'goog.i18n.NumberFormatSymbols_en_TT',
  'goog.i18n.NumberFormatSymbols_en_TZ',
  'goog.i18n.NumberFormatSymbols_en_UG',
  'goog.i18n.NumberFormatSymbols_en_VC',
  'goog.i18n.NumberFormatSymbols_en_VU',
  'goog.i18n.NumberFormatSymbols_en_WS',
  'goog.i18n.NumberFormatSymbols_en_ZM',
  'goog.i18n.NumberFormatSymbols_en_ZW',
  'goog.i18n.NumberFormatSymbols_eo',
  'goog.i18n.NumberFormatSymbols_es_AR',
  'goog.i18n.NumberFormatSymbols_es_BO',
  'goog.i18n.NumberFormatSymbols_es_CL',
  'goog.i18n.NumberFormatSymbols_es_CO',
  'goog.i18n.NumberFormatSymbols_es_CR',
  'goog.i18n.NumberFormatSymbols_es_CU',
  'goog.i18n.NumberFormatSymbols_es_DO',
  'goog.i18n.NumberFormatSymbols_es_EC',
  'goog.i18n.NumberFormatSymbols_es_GQ',
  'goog.i18n.NumberFormatSymbols_es_GT',
  'goog.i18n.NumberFormatSymbols_es_HN',
  'goog.i18n.NumberFormatSymbols_es_MX',
  'goog.i18n.NumberFormatSymbols_es_NI',
  'goog.i18n.NumberFormatSymbols_es_PA',
  'goog.i18n.NumberFormatSymbols_es_PE',
  'goog.i18n.NumberFormatSymbols_es_PH',
  'goog.i18n.NumberFormatSymbols_es_PR',
  'goog.i18n.NumberFormatSymbols_es_PY',
  'goog.i18n.NumberFormatSymbols_es_SV',
  'goog.i18n.NumberFormatSymbols_es_US',
  'goog.i18n.NumberFormatSymbols_es_UY',
  'goog.i18n.NumberFormatSymbols_es_VE',
  'goog.i18n.NumberFormatSymbols_ewo',
  'goog.i18n.NumberFormatSymbols_ewo_CM',
  'goog.i18n.NumberFormatSymbols_fa_AF',
  'goog.i18n.NumberFormatSymbols_ff',
  'goog.i18n.NumberFormatSymbols_ff_SN',
  'goog.i18n.NumberFormatSymbols_fo',
  'goog.i18n.NumberFormatSymbols_fo_FO',
  'goog.i18n.NumberFormatSymbols_fr_BE',
  'goog.i18n.NumberFormatSymbols_fr_BF',
  'goog.i18n.NumberFormatSymbols_fr_BI',
  'goog.i18n.NumberFormatSymbols_fr_BJ',
  'goog.i18n.NumberFormatSymbols_fr_CD',
  'goog.i18n.NumberFormatSymbols_fr_CF',
  'goog.i18n.NumberFormatSymbols_fr_CG',
  'goog.i18n.NumberFormatSymbols_fr_CH',
  'goog.i18n.NumberFormatSymbols_fr_CI',
  'goog.i18n.NumberFormatSymbols_fr_CM',
  'goog.i18n.NumberFormatSymbols_fr_DJ',
  'goog.i18n.NumberFormatSymbols_fr_DZ',
  'goog.i18n.NumberFormatSymbols_fr_GA',
  'goog.i18n.NumberFormatSymbols_fr_GN',
  'goog.i18n.NumberFormatSymbols_fr_GQ',
  'goog.i18n.NumberFormatSymbols_fr_HT',
  'goog.i18n.NumberFormatSymbols_fr_KM',
  'goog.i18n.NumberFormatSymbols_fr_LU',
  'goog.i18n.NumberFormatSymbols_fr_MA',
  'goog.i18n.NumberFormatSymbols_fr_MG',
  'goog.i18n.NumberFormatSymbols_fr_ML',
  'goog.i18n.NumberFormatSymbols_fr_MR',
  'goog.i18n.NumberFormatSymbols_fr_MU',
  'goog.i18n.NumberFormatSymbols_fr_NC',
  'goog.i18n.NumberFormatSymbols_fr_NE',
  'goog.i18n.NumberFormatSymbols_fr_PF',
  'goog.i18n.NumberFormatSymbols_fr_RW',
  'goog.i18n.NumberFormatSymbols_fr_SC',
  'goog.i18n.NumberFormatSymbols_fr_SN',
  'goog.i18n.NumberFormatSymbols_fr_SY',
  'goog.i18n.NumberFormatSymbols_fr_TD',
  'goog.i18n.NumberFormatSymbols_fr_TG',
  'goog.i18n.NumberFormatSymbols_fr_TN',
  'goog.i18n.NumberFormatSymbols_fr_VU',
  'goog.i18n.NumberFormatSymbols_fur',
  'goog.i18n.NumberFormatSymbols_fur_IT',
  'goog.i18n.NumberFormatSymbols_ga',
  'goog.i18n.NumberFormatSymbols_ga_IE',
  'goog.i18n.NumberFormatSymbols_gd',
  'goog.i18n.NumberFormatSymbols_gd_GB',
  'goog.i18n.NumberFormatSymbols_guz',
  'goog.i18n.NumberFormatSymbols_guz_KE',
  'goog.i18n.NumberFormatSymbols_gv',
  'goog.i18n.NumberFormatSymbols_gv_GB',
  'goog.i18n.NumberFormatSymbols_ha',
  'goog.i18n.NumberFormatSymbols_ha_Latn',
  'goog.i18n.NumberFormatSymbols_ha_Latn_GH',
  'goog.i18n.NumberFormatSymbols_ha_Latn_NE',
  'goog.i18n.NumberFormatSymbols_ha_Latn_NG',
  'goog.i18n.NumberFormatSymbols_hr_BA',
  'goog.i18n.NumberFormatSymbols_hy',
  'goog.i18n.NumberFormatSymbols_hy_AM',
  'goog.i18n.NumberFormatSymbols_ia',
  'goog.i18n.NumberFormatSymbols_ia_FR',
  'goog.i18n.NumberFormatSymbols_ig',
  'goog.i18n.NumberFormatSymbols_ig_NG',
  'goog.i18n.NumberFormatSymbols_ii',
  'goog.i18n.NumberFormatSymbols_ii_CN',
  'goog.i18n.NumberFormatSymbols_it_CH',
  'goog.i18n.NumberFormatSymbols_jgo',
  'goog.i18n.NumberFormatSymbols_jgo_CM',
  'goog.i18n.NumberFormatSymbols_jmc',
  'goog.i18n.NumberFormatSymbols_jmc_TZ',
  'goog.i18n.NumberFormatSymbols_ka',
  'goog.i18n.NumberFormatSymbols_ka_GE',
  'goog.i18n.NumberFormatSymbols_kab',
  'goog.i18n.NumberFormatSymbols_kab_DZ',
  'goog.i18n.NumberFormatSymbols_kam',
  'goog.i18n.NumberFormatSymbols_kam_KE',
  'goog.i18n.NumberFormatSymbols_kde',
  'goog.i18n.NumberFormatSymbols_kde_TZ',
  'goog.i18n.NumberFormatSymbols_kea',
  'goog.i18n.NumberFormatSymbols_kea_CV',
  'goog.i18n.NumberFormatSymbols_khq',
  'goog.i18n.NumberFormatSymbols_khq_ML',
  'goog.i18n.NumberFormatSymbols_ki',
  'goog.i18n.NumberFormatSymbols_ki_KE',
  'goog.i18n.NumberFormatSymbols_kk',
  'goog.i18n.NumberFormatSymbols_kk_Cyrl',
  'goog.i18n.NumberFormatSymbols_kk_Cyrl_KZ',
  'goog.i18n.NumberFormatSymbols_kkj',
  'goog.i18n.NumberFormatSymbols_kkj_CM',
  'goog.i18n.NumberFormatSymbols_kl',
  'goog.i18n.NumberFormatSymbols_kl_GL',
  'goog.i18n.NumberFormatSymbols_kln',
  'goog.i18n.NumberFormatSymbols_kln_KE',
  'goog.i18n.NumberFormatSymbols_km',
  'goog.i18n.NumberFormatSymbols_km_KH',
  'goog.i18n.NumberFormatSymbols_ko_KP',
  'goog.i18n.NumberFormatSymbols_kok',
  'goog.i18n.NumberFormatSymbols_kok_IN',
  'goog.i18n.NumberFormatSymbols_ks',
  'goog.i18n.NumberFormatSymbols_ks_Arab',
  'goog.i18n.NumberFormatSymbols_ks_Arab_IN',
  'goog.i18n.NumberFormatSymbols_ksb',
  'goog.i18n.NumberFormatSymbols_ksb_TZ',
  'goog.i18n.NumberFormatSymbols_ksf',
  'goog.i18n.NumberFormatSymbols_ksf_CM',
  'goog.i18n.NumberFormatSymbols_ksh',
  'goog.i18n.NumberFormatSymbols_ksh_DE',
  'goog.i18n.NumberFormatSymbols_kw',
  'goog.i18n.NumberFormatSymbols_kw_GB',
  'goog.i18n.NumberFormatSymbols_ky',
  'goog.i18n.NumberFormatSymbols_ky_KG',
  'goog.i18n.NumberFormatSymbols_lag',
  'goog.i18n.NumberFormatSymbols_lag_TZ',
  'goog.i18n.NumberFormatSymbols_lg',
  'goog.i18n.NumberFormatSymbols_lg_UG',
  'goog.i18n.NumberFormatSymbols_ln_AO',
  'goog.i18n.NumberFormatSymbols_ln_CF',
  'goog.i18n.NumberFormatSymbols_ln_CG',
  'goog.i18n.NumberFormatSymbols_lo',
  'goog.i18n.NumberFormatSymbols_lo_LA',
  'goog.i18n.NumberFormatSymbols_lu',
  'goog.i18n.NumberFormatSymbols_lu_CD',
  'goog.i18n.NumberFormatSymbols_luo',
  'goog.i18n.NumberFormatSymbols_luo_KE',
  'goog.i18n.NumberFormatSymbols_luy',
  'goog.i18n.NumberFormatSymbols_luy_KE',
  'goog.i18n.NumberFormatSymbols_mas',
  'goog.i18n.NumberFormatSymbols_mas_KE',
  'goog.i18n.NumberFormatSymbols_mas_TZ',
  'goog.i18n.NumberFormatSymbols_mer',
  'goog.i18n.NumberFormatSymbols_mer_KE',
  'goog.i18n.NumberFormatSymbols_mfe',
  'goog.i18n.NumberFormatSymbols_mfe_MU',
  'goog.i18n.NumberFormatSymbols_mg',
  'goog.i18n.NumberFormatSymbols_mg_MG',
  'goog.i18n.NumberFormatSymbols_mgh',
  'goog.i18n.NumberFormatSymbols_mgh_MZ',
  'goog.i18n.NumberFormatSymbols_mgo',
  'goog.i18n.NumberFormatSymbols_mgo_CM',
  'goog.i18n.NumberFormatSymbols_mk',
  'goog.i18n.NumberFormatSymbols_mk_MK',
  'goog.i18n.NumberFormatSymbols_mn',
  'goog.i18n.NumberFormatSymbols_mn_Cyrl',
  'goog.i18n.NumberFormatSymbols_mn_Cyrl_MN',
  'goog.i18n.NumberFormatSymbols_ms_Latn',
  'goog.i18n.NumberFormatSymbols_ms_Latn_BN',
  'goog.i18n.NumberFormatSymbols_ms_Latn_SG',
  'goog.i18n.NumberFormatSymbols_mua',
  'goog.i18n.NumberFormatSymbols_mua_CM',
  'goog.i18n.NumberFormatSymbols_my',
  'goog.i18n.NumberFormatSymbols_my_MM',
  'goog.i18n.NumberFormatSymbols_naq',
  'goog.i18n.NumberFormatSymbols_naq_NA',
  'goog.i18n.NumberFormatSymbols_nd',
  'goog.i18n.NumberFormatSymbols_nd_ZW',
  'goog.i18n.NumberFormatSymbols_ne',
  'goog.i18n.NumberFormatSymbols_ne_IN',
  'goog.i18n.NumberFormatSymbols_ne_NP',
  'goog.i18n.NumberFormatSymbols_nl_AW',
  'goog.i18n.NumberFormatSymbols_nl_BE',
  'goog.i18n.NumberFormatSymbols_nl_CW',
  'goog.i18n.NumberFormatSymbols_nl_SR',
  'goog.i18n.NumberFormatSymbols_nl_SX',
  'goog.i18n.NumberFormatSymbols_nmg',
  'goog.i18n.NumberFormatSymbols_nmg_CM',
  'goog.i18n.NumberFormatSymbols_nn',
  'goog.i18n.NumberFormatSymbols_nn_NO',
  'goog.i18n.NumberFormatSymbols_nnh',
  'goog.i18n.NumberFormatSymbols_nnh_CM',
  'goog.i18n.NumberFormatSymbols_nr',
  'goog.i18n.NumberFormatSymbols_nr_ZA',
  'goog.i18n.NumberFormatSymbols_nso',
  'goog.i18n.NumberFormatSymbols_nso_ZA',
  'goog.i18n.NumberFormatSymbols_nus',
  'goog.i18n.NumberFormatSymbols_nus_SD',
  'goog.i18n.NumberFormatSymbols_nyn',
  'goog.i18n.NumberFormatSymbols_nyn_UG',
  'goog.i18n.NumberFormatSymbols_om',
  'goog.i18n.NumberFormatSymbols_om_ET',
  'goog.i18n.NumberFormatSymbols_om_KE',
  'goog.i18n.NumberFormatSymbols_os',
  'goog.i18n.NumberFormatSymbols_os_GE',
  'goog.i18n.NumberFormatSymbols_os_RU',
  'goog.i18n.NumberFormatSymbols_pa',
  'goog.i18n.NumberFormatSymbols_pa_Arab',
  'goog.i18n.NumberFormatSymbols_pa_Arab_PK',
  'goog.i18n.NumberFormatSymbols_pa_Guru',
  'goog.i18n.NumberFormatSymbols_pa_Guru_IN',
  'goog.i18n.NumberFormatSymbols_ps',
  'goog.i18n.NumberFormatSymbols_ps_AF',
  'goog.i18n.NumberFormatSymbols_pt_AO',
  'goog.i18n.NumberFormatSymbols_pt_CV',
  'goog.i18n.NumberFormatSymbols_pt_GW',
  'goog.i18n.NumberFormatSymbols_pt_MO',
  'goog.i18n.NumberFormatSymbols_pt_MZ',
  'goog.i18n.NumberFormatSymbols_pt_ST',
  'goog.i18n.NumberFormatSymbols_pt_TL',
  'goog.i18n.NumberFormatSymbols_rm',
  'goog.i18n.NumberFormatSymbols_rm_CH',
  'goog.i18n.NumberFormatSymbols_rn',
  'goog.i18n.NumberFormatSymbols_rn_BI',
  'goog.i18n.NumberFormatSymbols_ro_MD',
  'goog.i18n.NumberFormatSymbols_rof',
  'goog.i18n.NumberFormatSymbols_rof_TZ',
  'goog.i18n.NumberFormatSymbols_ru_BY',
  'goog.i18n.NumberFormatSymbols_ru_KG',
  'goog.i18n.NumberFormatSymbols_ru_KZ',
  'goog.i18n.NumberFormatSymbols_ru_MD',
  'goog.i18n.NumberFormatSymbols_ru_UA',
  'goog.i18n.NumberFormatSymbols_rw',
  'goog.i18n.NumberFormatSymbols_rw_RW',
  'goog.i18n.NumberFormatSymbols_rwk',
  'goog.i18n.NumberFormatSymbols_rwk_TZ',
  'goog.i18n.NumberFormatSymbols_sah',
  'goog.i18n.NumberFormatSymbols_sah_RU',
  'goog.i18n.NumberFormatSymbols_saq',
  'goog.i18n.NumberFormatSymbols_saq_KE',
  'goog.i18n.NumberFormatSymbols_sbp',
  'goog.i18n.NumberFormatSymbols_sbp_TZ',
  'goog.i18n.NumberFormatSymbols_se',
  'goog.i18n.NumberFormatSymbols_se_FI',
  'goog.i18n.NumberFormatSymbols_se_NO',
  'goog.i18n.NumberFormatSymbols_seh',
  'goog.i18n.NumberFormatSymbols_seh_MZ',
  'goog.i18n.NumberFormatSymbols_ses',
  'goog.i18n.NumberFormatSymbols_ses_ML',
  'goog.i18n.NumberFormatSymbols_sg',
  'goog.i18n.NumberFormatSymbols_sg_CF',
  'goog.i18n.NumberFormatSymbols_shi',
  'goog.i18n.NumberFormatSymbols_shi_Latn',
  'goog.i18n.NumberFormatSymbols_shi_Latn_MA',
  'goog.i18n.NumberFormatSymbols_shi_Tfng',
  'goog.i18n.NumberFormatSymbols_shi_Tfng_MA',
  'goog.i18n.NumberFormatSymbols_si',
  'goog.i18n.NumberFormatSymbols_si_LK',
  'goog.i18n.NumberFormatSymbols_sn',
  'goog.i18n.NumberFormatSymbols_sn_ZW',
  'goog.i18n.NumberFormatSymbols_so',
  'goog.i18n.NumberFormatSymbols_so_DJ',
  'goog.i18n.NumberFormatSymbols_so_ET',
  'goog.i18n.NumberFormatSymbols_so_KE',
  'goog.i18n.NumberFormatSymbols_so_SO',
  'goog.i18n.NumberFormatSymbols_sq_MK',
  'goog.i18n.NumberFormatSymbols_sq_XK',
  'goog.i18n.NumberFormatSymbols_sr_Cyrl',
  'goog.i18n.NumberFormatSymbols_sr_Cyrl_BA',
  'goog.i18n.NumberFormatSymbols_sr_Cyrl_ME',
  'goog.i18n.NumberFormatSymbols_sr_Cyrl_XK',
  'goog.i18n.NumberFormatSymbols_sr_Latn',
  'goog.i18n.NumberFormatSymbols_sr_Latn_BA',
  'goog.i18n.NumberFormatSymbols_sr_Latn_ME',
  'goog.i18n.NumberFormatSymbols_sr_Latn_RS',
  'goog.i18n.NumberFormatSymbols_sr_Latn_XK',
  'goog.i18n.NumberFormatSymbols_ss',
  'goog.i18n.NumberFormatSymbols_ss_SZ',
  'goog.i18n.NumberFormatSymbols_ss_ZA',
  'goog.i18n.NumberFormatSymbols_ssy',
  'goog.i18n.NumberFormatSymbols_ssy_ER',
  'goog.i18n.NumberFormatSymbols_st',
  'goog.i18n.NumberFormatSymbols_st_LS',
  'goog.i18n.NumberFormatSymbols_st_ZA',
  'goog.i18n.NumberFormatSymbols_sv_AX',
  'goog.i18n.NumberFormatSymbols_sv_FI',
  'goog.i18n.NumberFormatSymbols_sw_KE',
  'goog.i18n.NumberFormatSymbols_sw_UG',
  'goog.i18n.NumberFormatSymbols_swc',
  'goog.i18n.NumberFormatSymbols_swc_CD',
  'goog.i18n.NumberFormatSymbols_ta_LK',
  'goog.i18n.NumberFormatSymbols_ta_MY',
  'goog.i18n.NumberFormatSymbols_ta_SG',
  'goog.i18n.NumberFormatSymbols_teo',
  'goog.i18n.NumberFormatSymbols_teo_KE',
  'goog.i18n.NumberFormatSymbols_teo_UG',
  'goog.i18n.NumberFormatSymbols_tg',
  'goog.i18n.NumberFormatSymbols_tg_Cyrl',
  'goog.i18n.NumberFormatSymbols_tg_Cyrl_TJ',
  'goog.i18n.NumberFormatSymbols_ti',
  'goog.i18n.NumberFormatSymbols_ti_ER',
  'goog.i18n.NumberFormatSymbols_ti_ET',
  'goog.i18n.NumberFormatSymbols_tig',
  'goog.i18n.NumberFormatSymbols_tig_ER',
  'goog.i18n.NumberFormatSymbols_tn',
  'goog.i18n.NumberFormatSymbols_tn_BW',
  'goog.i18n.NumberFormatSymbols_tn_ZA',
  'goog.i18n.NumberFormatSymbols_to',
  'goog.i18n.NumberFormatSymbols_to_TO',
  'goog.i18n.NumberFormatSymbols_tr_CY',
  'goog.i18n.NumberFormatSymbols_ts',
  'goog.i18n.NumberFormatSymbols_ts_ZA',
  'goog.i18n.NumberFormatSymbols_twq',
  'goog.i18n.NumberFormatSymbols_twq_NE',
  'goog.i18n.NumberFormatSymbols_tzm',
  'goog.i18n.NumberFormatSymbols_tzm_Latn',
  'goog.i18n.NumberFormatSymbols_tzm_Latn_MA',
  'goog.i18n.NumberFormatSymbols_ur_IN',
  'goog.i18n.NumberFormatSymbols_uz',
  'goog.i18n.NumberFormatSymbols_uz_Arab',
  'goog.i18n.NumberFormatSymbols_uz_Arab_AF',
  'goog.i18n.NumberFormatSymbols_uz_Cyrl',
  'goog.i18n.NumberFormatSymbols_uz_Cyrl_UZ',
  'goog.i18n.NumberFormatSymbols_uz_Latn',
  'goog.i18n.NumberFormatSymbols_uz_Latn_UZ',
  'goog.i18n.NumberFormatSymbols_vai',
  'goog.i18n.NumberFormatSymbols_vai_Latn',
  'goog.i18n.NumberFormatSymbols_vai_Latn_LR',
  'goog.i18n.NumberFormatSymbols_vai_Vaii',
  'goog.i18n.NumberFormatSymbols_vai_Vaii_LR',
  'goog.i18n.NumberFormatSymbols_ve',
  'goog.i18n.NumberFormatSymbols_ve_ZA',
  'goog.i18n.NumberFormatSymbols_vo',
  'goog.i18n.NumberFormatSymbols_vun',
  'goog.i18n.NumberFormatSymbols_vun_TZ',
  'goog.i18n.NumberFormatSymbols_wae',
  'goog.i18n.NumberFormatSymbols_wae_CH',
  'goog.i18n.NumberFormatSymbols_wal',
  'goog.i18n.NumberFormatSymbols_wal_ET',
  'goog.i18n.NumberFormatSymbols_xh',
  'goog.i18n.NumberFormatSymbols_xh_ZA',
  'goog.i18n.NumberFormatSymbols_xog',
  'goog.i18n.NumberFormatSymbols_xog_UG',
  'goog.i18n.NumberFormatSymbols_yav',
  'goog.i18n.NumberFormatSymbols_yav_CM',
  'goog.i18n.NumberFormatSymbols_yo',
  'goog.i18n.NumberFormatSymbols_yo_NG',
  'goog.i18n.NumberFormatSymbols_zh_Hans',
  'goog.i18n.NumberFormatSymbols_zh_Hans_HK',
  'goog.i18n.NumberFormatSymbols_zh_Hans_MO',
  'goog.i18n.NumberFormatSymbols_zh_Hans_SG',
  'goog.i18n.NumberFormatSymbols_zh_Hant',
  'goog.i18n.NumberFormatSymbols_zh_Hant_HK',
  'goog.i18n.NumberFormatSymbols_zh_Hant_MO',
  'goog.i18n.NumberFormatSymbols_zh_Hant_TW'
], ['goog.i18n.NumberFormatSymbols']);
goog.addDependency('i18n/ordinalrules.js', ['goog.i18n.ordinalRules'], []);
goog.addDependency('i18n/pluralrules.js', ['goog.i18n.pluralRules'], []);
goog.addDependency('i18n/timezone.js', ['goog.i18n.TimeZone'], [
  'goog.array',
  'goog.date.DateLike',
  'goog.string'
]);
goog.addDependency('i18n/uchar.js', ['goog.i18n.uChar'], []);
goog.addDependency('i18n/uchar/localnamefetcher.js', ['goog.i18n.uChar.LocalNameFetcher'], [
  'goog.i18n.uChar',
  'goog.i18n.uChar.NameFetcher',
  'goog.log'
]);
goog.addDependency('i18n/uchar/namefetcher.js', ['goog.i18n.uChar.NameFetcher'], []);
goog.addDependency('i18n/uchar/remotenamefetcher.js', ['goog.i18n.uChar.RemoteNameFetcher'], [
  'goog.Disposable',
  'goog.Uri',
  'goog.i18n.uChar',
  'goog.i18n.uChar.NameFetcher',
  'goog.log',
  'goog.net.XhrIo',
  'goog.structs.Map'
]);
goog.addDependency('iter/iter.js', [
  'goog.iter',
  'goog.iter.Iterator',
  'goog.iter.StopIteration'
], [
  'goog.array',
  'goog.asserts'
]);
goog.addDependency('json/evaljsonprocessor.js', ['goog.json.EvalJsonProcessor'], [
  'goog.json',
  'goog.json.Processor',
  'goog.json.Serializer'
]);
goog.addDependency('json/json.js', [
  'goog.json',
  'goog.json.Serializer'
], []);
goog.addDependency('json/nativejsonprocessor.js', ['goog.json.NativeJsonProcessor'], [
  'goog.asserts',
  'goog.json',
  'goog.json.Processor'
]);
goog.addDependency('json/processor.js', ['goog.json.Processor'], [
  'goog.string.Parser',
  'goog.string.Stringifier'
]);
goog.addDependency('labs/classdef/classdef.js', ['goog.labs.classdef'], []);
goog.addDependency('labs/events/touch.js', [
  'goog.labs.events.touch',
  'goog.labs.events.touch.TouchData'
], [
  'goog.array',
  'goog.asserts',
  'goog.events.EventType',
  'goog.string'
]);
goog.addDependency('labs/events/touch_test.js', ['goog.labs.events.touchTest'], [
  'goog.labs.events.touch',
  'goog.testing.jsunit'
]);
goog.addDependency('labs/format/csv.js', [
  'goog.labs.format.csv',
  'goog.labs.format.csv.ParseError',
  'goog.labs.format.csv.Token'
], [
  'goog.array',
  'goog.asserts',
  'goog.debug.Error',
  'goog.object',
  'goog.string',
  'goog.string.newlines'
]);
goog.addDependency('labs/format/csv_test.js', ['goog.labs.format.csvTest'], [
  'goog.labs.format.csv',
  'goog.labs.format.csv.ParseError',
  'goog.object',
  'goog.testing.asserts',
  'goog.testing.jsunit'
]);
goog.addDependency('labs/mock/mock.js', ['goog.labs.mock'], [
  'goog.array',
  'goog.debug',
  'goog.debug.Error',
  'goog.functions',
  'goog.json'
]);
goog.addDependency('labs/net/image.js', ['goog.labs.net.image'], [
  'goog.events.EventHandler',
  'goog.events.EventType',
  'goog.net.EventType',
  'goog.result.SimpleResult',
  'goog.userAgent'
]);
goog.addDependency('labs/net/image_test.js', ['goog.labs.net.imageTest'], [
  'goog.events',
  'goog.labs.net.image',
  'goog.result',
  'goog.result.Result',
  'goog.string',
  'goog.testing.AsyncTestCase',
  'goog.testing.jsunit',
  'goog.testing.recordFunction'
]);
goog.addDependency('labs/net/webchannel.js', ['goog.net.WebChannel'], [
  'goog.events',
  'goog.events.Event'
]);
goog.addDependency('labs/net/webchannel/basetestchannel.js', ['goog.labs.net.webChannel.BaseTestChannel'], [
  'goog.json.EvalJsonProcessor',
  'goog.labs.net.webChannel.Channel',
  'goog.labs.net.webChannel.WebChannelRequest',
  'goog.labs.net.webChannel.requestStats',
  'goog.labs.net.webChannel.requestStats.ServerReachability',
  'goog.labs.net.webChannel.requestStats.Stat',
  'goog.net.tmpnetwork'
]);
goog.addDependency('labs/net/webchannel/channel.js', ['goog.labs.net.webChannel.Channel'], []);
goog.addDependency('labs/net/webchannel/requeststats.js', [
  'goog.labs.net.webChannel.requestStats',
  'goog.labs.net.webChannel.requestStats.Event',
  'goog.labs.net.webChannel.requestStats.ServerReachability',
  'goog.labs.net.webChannel.requestStats.ServerReachabilityEvent',
  'goog.labs.net.webChannel.requestStats.Stat',
  'goog.labs.net.webChannel.requestStats.StatEvent',
  'goog.labs.net.webChannel.requestStats.TimingEvent'
], [
  'goog.events.Event',
  'goog.events.EventTarget'
]);
goog.addDependency('labs/net/webchannel/webchannelbase.js', ['goog.labs.net.webChannel.WebChannelBase'], [
  'goog.Uri',
  'goog.array',
  'goog.asserts',
  'goog.debug.TextFormatter',
  'goog.json',
  'goog.json.EvalJsonProcessor',
  'goog.labs.net.webChannel.BaseTestChannel',
  'goog.labs.net.webChannel.Channel',
  'goog.labs.net.webChannel.WebChannelDebug',
  'goog.labs.net.webChannel.WebChannelRequest',
  'goog.labs.net.webChannel.requestStats',
  'goog.labs.net.webChannel.requestStats.Stat',
  'goog.log',
  'goog.net.XhrIo',
  'goog.net.tmpnetwork',
  'goog.string',
  'goog.structs',
  'goog.structs.CircularBuffer'
]);
goog.addDependency('labs/net/webchannel/webchannelbase_test.js', ['goog.labs.net.webChannel.webChannelBaseTest'], [
  'goog.Timer',
  'goog.array',
  'goog.dom',
  'goog.functions',
  'goog.json',
  'goog.labs.net.webChannel.WebChannelBase',
  'goog.labs.net.webChannel.WebChannelDebug',
  'goog.labs.net.webChannel.WebChannelRequest',
  'goog.labs.net.webChannel.requestStats',
  'goog.labs.net.webChannel.requestStats.Stat',
  'goog.net.tmpnetwork',
  'goog.structs.Map',
  'goog.testing.MockClock',
  'goog.testing.PropertyReplacer',
  'goog.testing.asserts',
  'goog.testing.jsunit',
  'goog.testing.recordFunction'
]);
goog.addDependency('labs/net/webchannel/webchannelbasetransport.js', ['goog.labs.net.webChannel.WebChannelBaseTransport'], [
  'goog.asserts',
  'goog.events.EventTarget',
  'goog.labs.net.webChannel.WebChannelBase',
  'goog.log',
  'goog.net.WebChannel',
  'goog.net.WebChannelTransport',
  'goog.string.path'
]);
goog.addDependency('labs/net/webchannel/webchanneldebug.js', ['goog.labs.net.webChannel.WebChannelDebug'], [
  'goog.json',
  'goog.log'
]);
goog.addDependency('labs/net/webchannel/webchannelrequest.js', ['goog.labs.net.webChannel.WebChannelRequest'], [
  'goog.Timer',
  'goog.async.Throttle',
  'goog.events.EventHandler',
  'goog.labs.net.webChannel.requestStats',
  'goog.labs.net.webChannel.requestStats.ServerReachability',
  'goog.labs.net.webChannel.requestStats.Stat',
  'goog.net.ErrorCode',
  'goog.net.EventType',
  'goog.net.XmlHttp',
  'goog.object',
  'goog.userAgent'
]);
goog.addDependency('labs/net/webchanneltransport.js', ['goog.net.WebChannelTransport'], []);
goog.addDependency('labs/net/webchanneltransportfactory.js', ['goog.net.createWebChannelTransport'], [
  'goog.functions',
  'goog.labs.net.webChannel.WebChannelBaseTransport'
]);
goog.addDependency('labs/net/xhr.js', [
  'goog.labs.net.xhr',
  'goog.labs.net.xhr.Error',
  'goog.labs.net.xhr.HttpError',
  'goog.labs.net.xhr.TimeoutError'
], [
  'goog.debug.Error',
  'goog.json',
  'goog.net.HttpStatus',
  'goog.net.XmlHttp',
  'goog.result',
  'goog.result.SimpleResult',
  'goog.string',
  'goog.uri.utils'
]);
goog.addDependency('labs/object/object.js', ['goog.labs.object'], []);
goog.addDependency('labs/observe/notice.js', ['goog.labs.observe.Notice'], []);
goog.addDependency('labs/observe/observable.js', ['goog.labs.observe.Observable'], ['goog.disposable.IDisposable']);
goog.addDependency('labs/observe/observableset.js', ['goog.labs.observe.ObservableSet'], [
  'goog.array',
  'goog.labs.observe.Observer'
]);
goog.addDependency('labs/observe/observationset.js', ['goog.labs.observe.ObservationSet'], [
  'goog.array',
  'goog.labs.observe.Observer'
]);
goog.addDependency('labs/observe/observer.js', ['goog.labs.observe.Observer'], []);
goog.addDependency('labs/observe/simpleobservable.js', ['goog.labs.observe.SimpleObservable'], [
  'goog.Disposable',
  'goog.array',
  'goog.asserts',
  'goog.labs.observe.Notice',
  'goog.labs.observe.Observable',
  'goog.labs.observe.Observer',
  'goog.object'
]);
goog.addDependency('labs/structs/map.js', ['goog.labs.structs.Map'], [
  'goog.array',
  'goog.asserts',
  'goog.labs.object',
  'goog.object'
]);
goog.addDependency('labs/structs/map_perf.js', ['goog.labs.structs.mapPerf'], [
  'goog.dom',
  'goog.labs.structs.Map',
  'goog.structs.Map',
  'goog.testing.PerformanceTable',
  'goog.testing.jsunit'
]);
goog.addDependency('labs/structs/multimap.js', ['goog.labs.structs.Multimap'], [
  'goog.array',
  'goog.labs.object',
  'goog.labs.structs.Map'
]);
goog.addDependency('labs/style/pixeldensitymonitor.js', [
  'goog.labs.style.PixelDensityMonitor',
  'goog.labs.style.PixelDensityMonitor.Density',
  'goog.labs.style.PixelDensityMonitor.EventType'
], [
  'goog.events',
  'goog.events.EventTarget'
]);
goog.addDependency('labs/style/pixeldensitymonitor_test.js', ['goog.labs.style.PixelDensityMonitorTest'], [
  'goog.array',
  'goog.dom.DomHelper',
  'goog.events',
  'goog.labs.style.PixelDensityMonitor',
  'goog.testing.MockControl',
  'goog.testing.jsunit',
  'goog.testing.recordFunction'
]);
goog.addDependency('labs/testing/assertthat.js', [
  'goog.labs.testing.MatcherError',
  'goog.labs.testing.assertThat'
], [
  'goog.asserts',
  'goog.debug.Error',
  'goog.labs.testing.Matcher'
]);
goog.addDependency('labs/testing/decoratormatcher.js', ['goog.labs.testing.AnythingMatcher'], ['goog.labs.testing.Matcher']);
goog.addDependency('labs/testing/dictionarymatcher.js', [
  'goog.labs.testing.HasEntriesMatcher',
  'goog.labs.testing.HasEntryMatcher',
  'goog.labs.testing.HasKeyMatcher',
  'goog.labs.testing.HasValueMatcher'
], [
  'goog.array',
  'goog.asserts',
  'goog.labs.testing.Matcher',
  'goog.string'
]);
goog.addDependency('labs/testing/logicmatcher.js', [
  'goog.labs.testing.AllOfMatcher',
  'goog.labs.testing.AnyOfMatcher',
  'goog.labs.testing.IsNotMatcher'
], [
  'goog.array',
  'goog.labs.testing.Matcher'
]);
goog.addDependency('labs/testing/matcher.js', ['goog.labs.testing.Matcher'], []);
goog.addDependency('labs/testing/numbermatcher.js', [
  'goog.labs.testing.CloseToMatcher',
  'goog.labs.testing.EqualToMatcher',
  'goog.labs.testing.GreaterThanEqualToMatcher',
  'goog.labs.testing.GreaterThanMatcher',
  'goog.labs.testing.LessThanEqualToMatcher',
  'goog.labs.testing.LessThanMatcher'
], [
  'goog.asserts',
  'goog.labs.testing.Matcher'
]);
goog.addDependency('labs/testing/objectmatcher.js', [
  'goog.labs.testing.HasPropertyMatcher',
  'goog.labs.testing.InstanceOfMatcher',
  'goog.labs.testing.IsNullMatcher',
  'goog.labs.testing.IsNullOrUndefinedMatcher',
  'goog.labs.testing.IsUndefinedMatcher',
  'goog.labs.testing.ObjectEqualsMatcher'
], [
  'goog.labs.testing.Matcher',
  'goog.string'
]);
goog.addDependency('labs/testing/stringmatcher.js', [
  'goog.labs.testing.ContainsStringMatcher',
  'goog.labs.testing.EndsWithMatcher',
  'goog.labs.testing.EqualToIgnoringCaseMatcher',
  'goog.labs.testing.EqualToIgnoringWhitespaceMatcher',
  'goog.labs.testing.EqualsMatcher',
  'goog.labs.testing.RegexMatcher',
  'goog.labs.testing.StartsWithMatcher',
  'goog.labs.testing.StringContainsInOrderMatcher'
], [
  'goog.asserts',
  'goog.labs.testing.Matcher',
  'goog.string'
]);
goog.addDependency('labs/useragent/browser.js', ['goog.labs.userAgent.browser'], [
  'goog.asserts',
  'goog.labs.userAgent.util',
  'goog.memoize',
  'goog.string'
]);
goog.addDependency('labs/useragent/browser_test.js', ['goog.labs.userAgent.browserTest'], [
  'goog.labs.userAgent.browser',
  'goog.labs.userAgent.testAgents',
  'goog.testing.PropertyReplacer',
  'goog.testing.jsunit'
]);
goog.addDependency('labs/useragent/device.js', ['goog.labs.userAgent.device'], ['goog.labs.userAgent.util']);
goog.addDependency('labs/useragent/device_test.js', ['goog.labs.userAgent.deviceTest'], [
  'goog.labs.userAgent.device',
  'goog.labs.userAgent.testAgents',
  'goog.testing.PropertyReplacer',
  'goog.testing.jsunit'
]);
goog.addDependency('labs/useragent/engine.js', ['goog.labs.userAgent.engine'], [
  'goog.array',
  'goog.labs.userAgent.util',
  'goog.memoize',
  'goog.string'
]);
goog.addDependency('labs/useragent/engine_test.js', ['goog.labs.userAgent.engineTest'], [
  'goog.labs.userAgent.engine',
  'goog.labs.userAgent.testAgents',
  'goog.testing.PropertyReplacer',
  'goog.testing.jsunit'
]);
goog.addDependency('labs/useragent/platform.js', ['goog.labs.userAgent.platform'], [
  'goog.labs.userAgent.util',
  'goog.memoize',
  'goog.string'
]);
goog.addDependency('labs/useragent/platform_test.js', ['goog.labs.userAgent.platformTest'], [
  'goog.labs.userAgent.platform',
  'goog.labs.userAgent.testAgents',
  'goog.testing.PropertyReplacer',
  'goog.testing.jsunit'
]);
goog.addDependency('labs/useragent/test_agents.js', ['goog.labs.userAgent.testAgents'], []);
goog.addDependency('labs/useragent/util.js', ['goog.labs.userAgent.util'], [
  'goog.memoize',
  'goog.string'
]);
goog.addDependency('labs/useragent/util_test.js', ['goog.labs.userAgent.utilTest'], [
  'goog.labs.userAgent.testAgents',
  'goog.labs.userAgent.util',
  'goog.testing.jsunit'
]);
goog.addDependency('locale/countries.js', ['goog.locale.countries'], []);
goog.addDependency('locale/defaultlocalenameconstants.js', ['goog.locale.defaultLocaleNameConstants'], []);
goog.addDependency('locale/genericfontnames.js', ['goog.locale.genericFontNames'], []);
goog.addDependency('locale/genericfontnamesdata.js', ['goog.locale.genericFontNamesData'], []);
goog.addDependency('locale/locale.js', ['goog.locale'], ['goog.locale.nativeNameConstants']);
goog.addDependency('locale/nativenameconstants.js', ['goog.locale.nativeNameConstants'], []);
goog.addDependency('locale/scriptToLanguages.js', ['goog.locale.scriptToLanguages'], ['goog.locale']);
goog.addDependency('locale/timezonedetection.js', ['goog.locale.timeZoneDetection'], [
  'goog.locale',
  'goog.locale.TimeZoneFingerprint'
]);
goog.addDependency('locale/timezonefingerprint.js', ['goog.locale.TimeZoneFingerprint'], []);
goog.addDependency('locale/timezonelist.js', ['goog.locale.TimeZoneList'], ['goog.locale']);
goog.addDependency('log/log.js', [
  'goog.log',
  'goog.log.Level',
  'goog.log.LogRecord',
  'goog.log.Logger'
], [
  'goog.debug',
  'goog.debug.LogRecord',
  'goog.debug.Logger'
]);
goog.addDependency('log/log_test.js', ['goog.logTest'], [
  'goog.debug.LogManager',
  'goog.log',
  'goog.log.Level',
  'goog.testing.jsunit'
]);
goog.addDependency('math/bezier.js', ['goog.math.Bezier'], [
  'goog.math',
  'goog.math.Coordinate'
]);
goog.addDependency('math/box.js', ['goog.math.Box'], ['goog.math.Coordinate']);
goog.addDependency('math/coordinate.js', ['goog.math.Coordinate'], ['goog.math']);
goog.addDependency('math/coordinate3.js', ['goog.math.Coordinate3'], []);
goog.addDependency('math/exponentialbackoff.js', ['goog.math.ExponentialBackoff'], ['goog.asserts']);
goog.addDependency('math/integer.js', ['goog.math.Integer'], []);
goog.addDependency('math/interpolator/interpolator1.js', ['goog.math.interpolator.Interpolator1'], []);
goog.addDependency('math/interpolator/linear1.js', ['goog.math.interpolator.Linear1'], [
  'goog.array',
  'goog.math',
  'goog.math.interpolator.Interpolator1'
]);
goog.addDependency('math/interpolator/pchip1.js', ['goog.math.interpolator.Pchip1'], [
  'goog.math',
  'goog.math.interpolator.Spline1'
]);
goog.addDependency('math/interpolator/spline1.js', ['goog.math.interpolator.Spline1'], [
  'goog.array',
  'goog.math',
  'goog.math.interpolator.Interpolator1',
  'goog.math.tdma'
]);
goog.addDependency('math/line.js', ['goog.math.Line'], [
  'goog.math',
  'goog.math.Coordinate'
]);
goog.addDependency('math/long.js', ['goog.math.Long'], []);
goog.addDependency('math/math.js', ['goog.math'], [
  'goog.array',
  'goog.asserts'
]);
goog.addDependency('math/matrix.js', ['goog.math.Matrix'], [
  'goog.array',
  'goog.math',
  'goog.math.Size',
  'goog.string'
]);
goog.addDependency('math/range.js', ['goog.math.Range'], []);
goog.addDependency('math/rangeset.js', ['goog.math.RangeSet'], [
  'goog.array',
  'goog.iter.Iterator',
  'goog.iter.StopIteration',
  'goog.math.Range'
]);
goog.addDependency('math/rect.js', ['goog.math.Rect'], [
  'goog.math.Box',
  'goog.math.Coordinate',
  'goog.math.Size'
]);
goog.addDependency('math/size.js', ['goog.math.Size'], []);
goog.addDependency('math/tdma.js', ['goog.math.tdma'], []);
goog.addDependency('math/vec2.js', ['goog.math.Vec2'], [
  'goog.math',
  'goog.math.Coordinate'
]);
goog.addDependency('math/vec3.js', ['goog.math.Vec3'], [
  'goog.math',
  'goog.math.Coordinate3'
]);
goog.addDependency('memoize/memoize.js', ['goog.memoize'], []);
goog.addDependency('messaging/abstractchannel.js', ['goog.messaging.AbstractChannel'], [
  'goog.Disposable',
  'goog.debug',
  'goog.json',
  'goog.log',
  'goog.messaging.MessageChannel'
]);
goog.addDependency('messaging/bufferedchannel.js', ['goog.messaging.BufferedChannel'], [
  'goog.Timer',
  'goog.Uri',
  'goog.debug.Error',
  'goog.events',
  'goog.log',
  'goog.messaging.MessageChannel',
  'goog.messaging.MultiChannel'
]);
goog.addDependency('messaging/deferredchannel.js', ['goog.messaging.DeferredChannel'], [
  'goog.Disposable',
  'goog.async.Deferred',
  'goog.messaging.MessageChannel'
]);
goog.addDependency('messaging/loggerclient.js', ['goog.messaging.LoggerClient'], [
  'goog.Disposable',
  'goog.debug',
  'goog.debug.LogManager',
  'goog.debug.Logger'
]);
goog.addDependency('messaging/loggerserver.js', ['goog.messaging.LoggerServer'], [
  'goog.Disposable',
  'goog.log'
]);
goog.addDependency('messaging/messagechannel.js', ['goog.messaging.MessageChannel'], []);
goog.addDependency('messaging/messaging.js', ['goog.messaging'], ['goog.messaging.MessageChannel']);
goog.addDependency('messaging/multichannel.js', [
  'goog.messaging.MultiChannel',
  'goog.messaging.MultiChannel.VirtualChannel'
], [
  'goog.Disposable',
  'goog.events.EventHandler',
  'goog.log',
  'goog.messaging.MessageChannel',
  'goog.object'
]);
goog.addDependency('messaging/portcaller.js', ['goog.messaging.PortCaller'], [
  'goog.Disposable',
  'goog.async.Deferred',
  'goog.messaging.DeferredChannel',
  'goog.messaging.PortChannel',
  'goog.messaging.PortNetwork',
  'goog.object'
]);
goog.addDependency('messaging/portchannel.js', ['goog.messaging.PortChannel'], [
  'goog.Timer',
  'goog.array',
  'goog.async.Deferred',
  'goog.debug',
  'goog.dom',
  'goog.dom.DomHelper',
  'goog.events',
  'goog.events.EventType',
  'goog.json',
  'goog.log',
  'goog.messaging.AbstractChannel',
  'goog.messaging.DeferredChannel',
  'goog.object',
  'goog.string'
]);
goog.addDependency('messaging/portnetwork.js', ['goog.messaging.PortNetwork'], []);
goog.addDependency('messaging/portoperator.js', ['goog.messaging.PortOperator'], [
  'goog.Disposable',
  'goog.asserts',
  'goog.log',
  'goog.messaging.PortChannel',
  'goog.messaging.PortNetwork',
  'goog.object'
]);
goog.addDependency('messaging/respondingchannel.js', ['goog.messaging.RespondingChannel'], [
  'goog.Disposable',
  'goog.log',
  'goog.messaging.MessageChannel',
  'goog.messaging.MultiChannel',
  'goog.messaging.MultiChannel.VirtualChannel'
]);
goog.addDependency('messaging/testdata/portchannel_worker.js', ['goog.messaging.testdata.portchannel_worker'], ['goog.messaging.PortChannel']);
goog.addDependency('messaging/testdata/portnetwork_worker1.js', ['goog.messaging.testdata.portnetwork_worker1'], [
  'goog.messaging.PortCaller',
  'goog.messaging.PortChannel'
]);
goog.addDependency('messaging/testdata/portnetwork_worker2.js', ['goog.messaging.testdata.portnetwork_worker2'], [
  'goog.messaging.PortCaller',
  'goog.messaging.PortChannel'
]);
goog.addDependency('module/abstractmoduleloader.js', ['goog.module.AbstractModuleLoader'], []);
goog.addDependency('module/basemodule.js', ['goog.module.BaseModule'], ['goog.Disposable']);
goog.addDependency('module/loader.js', ['goog.module.Loader'], [
  'goog.Timer',
  'goog.array',
  'goog.dom',
  'goog.object'
]);
goog.addDependency('module/module.js', ['goog.module'], [
  'goog.array',
  'goog.module.Loader'
]);
goog.addDependency('module/moduleinfo.js', ['goog.module.ModuleInfo'], [
  'goog.Disposable',
  'goog.functions',
  'goog.module.BaseModule',
  'goog.module.ModuleLoadCallback'
]);
goog.addDependency('module/moduleloadcallback.js', ['goog.module.ModuleLoadCallback'], [
  'goog.debug.entryPointRegistry',
  'goog.debug.errorHandlerWeakDep'
]);
goog.addDependency('module/moduleloader.js', ['goog.module.ModuleLoader'], [
  'goog.Timer',
  'goog.array',
  'goog.events',
  'goog.events.Event',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.log',
  'goog.module.AbstractModuleLoader',
  'goog.net.BulkLoader',
  'goog.net.EventType',
  'goog.net.jsloader',
  'goog.userAgent.product'
]);
goog.addDependency('module/moduleloader_test.js', ['goog.module.ModuleLoaderTest'], [
  'goog.array',
  'goog.dom',
  'goog.functions',
  'goog.module.ModuleLoader',
  'goog.module.ModuleManager',
  'goog.module.ModuleManager.CallbackType',
  'goog.object',
  'goog.testing.AsyncTestCase',
  'goog.testing.PropertyReplacer',
  'goog.testing.events.EventObserver',
  'goog.testing.jsunit',
  'goog.testing.recordFunction',
  'goog.userAgent.product'
]);
goog.addDependency('module/modulemanager.js', [
  'goog.module.ModuleManager',
  'goog.module.ModuleManager.CallbackType',
  'goog.module.ModuleManager.FailureType'
], [
  'goog.Disposable',
  'goog.array',
  'goog.asserts',
  'goog.async.Deferred',
  'goog.debug.Trace',
  'goog.dispose',
  'goog.log',
  'goog.module.ModuleInfo',
  'goog.module.ModuleLoadCallback',
  'goog.object'
]);
goog.addDependency('module/testdata/modA_1.js', ['goog.module.testdata.modA_1'], []);
goog.addDependency('module/testdata/modA_2.js', ['goog.module.testdata.modA_2'], ['goog.module.ModuleManager']);
goog.addDependency('module/testdata/modB_1.js', ['goog.module.testdata.modB_1'], ['goog.module.ModuleManager']);
goog.addDependency('net/browserchannel.js', [
  'goog.net.BrowserChannel',
  'goog.net.BrowserChannel.Error',
  'goog.net.BrowserChannel.Event',
  'goog.net.BrowserChannel.Handler',
  'goog.net.BrowserChannel.LogSaver',
  'goog.net.BrowserChannel.QueuedMap',
  'goog.net.BrowserChannel.ServerReachability',
  'goog.net.BrowserChannel.ServerReachabilityEvent',
  'goog.net.BrowserChannel.Stat',
  'goog.net.BrowserChannel.StatEvent',
  'goog.net.BrowserChannel.State',
  'goog.net.BrowserChannel.TimingEvent'
], [
  'goog.Uri',
  'goog.array',
  'goog.asserts',
  'goog.debug.TextFormatter',
  'goog.events.Event',
  'goog.events.EventTarget',
  'goog.json',
  'goog.json.EvalJsonProcessor',
  'goog.log',
  'goog.net.BrowserTestChannel',
  'goog.net.ChannelDebug',
  'goog.net.ChannelRequest',
  'goog.net.XhrIo',
  'goog.net.tmpnetwork',
  'goog.string',
  'goog.structs',
  'goog.structs.CircularBuffer'
]);
goog.addDependency('net/browsertestchannel.js', ['goog.net.BrowserTestChannel'], [
  'goog.json.EvalJsonProcessor',
  'goog.net.ChannelRequest',
  'goog.net.ChannelRequest.Error',
  'goog.net.tmpnetwork',
  'goog.string.Parser',
  'goog.userAgent'
]);
goog.addDependency('net/bulkloader.js', ['goog.net.BulkLoader'], [
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.log',
  'goog.net.BulkLoaderHelper',
  'goog.net.EventType',
  'goog.net.XhrIo'
]);
goog.addDependency('net/bulkloaderhelper.js', ['goog.net.BulkLoaderHelper'], [
  'goog.Disposable',
  'goog.log'
]);
goog.addDependency('net/channeldebug.js', ['goog.net.ChannelDebug'], [
  'goog.json',
  'goog.log'
]);
goog.addDependency('net/channelrequest.js', [
  'goog.net.ChannelRequest',
  'goog.net.ChannelRequest.Error'
], [
  'goog.Timer',
  'goog.async.Throttle',
  'goog.events.EventHandler',
  'goog.net.ErrorCode',
  'goog.net.EventType',
  'goog.net.XmlHttp',
  'goog.object',
  'goog.userAgent'
]);
goog.addDependency('net/cookies.js', [
  'goog.net.Cookies',
  'goog.net.cookies'
], []);
goog.addDependency('net/crossdomainrpc.js', ['goog.net.CrossDomainRpc'], [
  'goog.Uri',
  'goog.dom',
  'goog.events',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.json',
  'goog.log',
  'goog.net.EventType',
  'goog.net.HttpStatus',
  'goog.string',
  'goog.userAgent'
]);
goog.addDependency('net/errorcode.js', ['goog.net.ErrorCode'], []);
goog.addDependency('net/eventtype.js', ['goog.net.EventType'], []);
goog.addDependency('net/filedownloader.js', [
  'goog.net.FileDownloader',
  'goog.net.FileDownloader.Error'
], [
  'goog.Disposable',
  'goog.asserts',
  'goog.async.Deferred',
  'goog.crypt.hash32',
  'goog.debug.Error',
  'goog.events',
  'goog.events.EventHandler',
  'goog.fs',
  'goog.fs.DirectoryEntry',
  'goog.fs.Error',
  'goog.fs.FileSaver',
  'goog.net.EventType',
  'goog.net.XhrIo',
  'goog.net.XhrIoPool',
  'goog.object'
]);
goog.addDependency('net/httpstatus.js', ['goog.net.HttpStatus'], []);
goog.addDependency('net/iframeio.js', [
  'goog.net.IframeIo',
  'goog.net.IframeIo.IncrementalDataEvent'
], [
  'goog.Timer',
  'goog.Uri',
  'goog.debug',
  'goog.dom',
  'goog.events',
  'goog.events.Event',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.json',
  'goog.log',
  'goog.net.ErrorCode',
  'goog.net.EventType',
  'goog.reflect',
  'goog.string',
  'goog.structs',
  'goog.userAgent'
]);
goog.addDependency('net/iframeloadmonitor.js', ['goog.net.IframeLoadMonitor'], [
  'goog.dom',
  'goog.events',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.userAgent'
]);
goog.addDependency('net/imageloader.js', ['goog.net.ImageLoader'], [
  'goog.array',
  'goog.dom',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.net.EventType',
  'goog.object',
  'goog.userAgent'
]);
goog.addDependency('net/ipaddress.js', [
  'goog.net.IpAddress',
  'goog.net.Ipv4Address',
  'goog.net.Ipv6Address'
], [
  'goog.array',
  'goog.math.Integer',
  'goog.object',
  'goog.string'
]);
goog.addDependency('net/jsloader.js', [
  'goog.net.jsloader',
  'goog.net.jsloader.Error',
  'goog.net.jsloader.ErrorCode',
  'goog.net.jsloader.Options'
], [
  'goog.array',
  'goog.async.Deferred',
  'goog.debug.Error',
  'goog.dom',
  'goog.dom.TagName'
]);
goog.addDependency('net/jsonp.js', ['goog.net.Jsonp'], [
  'goog.Uri',
  'goog.net.jsloader'
]);
goog.addDependency('net/mockiframeio.js', ['goog.net.MockIFrameIo'], [
  'goog.events.EventTarget',
  'goog.json',
  'goog.net.ErrorCode',
  'goog.net.EventType',
  'goog.net.IframeIo'
]);
goog.addDependency('net/multiiframeloadmonitor.js', ['goog.net.MultiIframeLoadMonitor'], [
  'goog.events',
  'goog.net.IframeLoadMonitor'
]);
goog.addDependency('net/networkstatusmonitor.js', ['goog.net.NetworkStatusMonitor'], ['goog.events.Listenable']);
goog.addDependency('net/networktester.js', ['goog.net.NetworkTester'], [
  'goog.Timer',
  'goog.Uri',
  'goog.log'
]);
goog.addDependency('net/testdata/jsloader_test1.js', ['goog.net.testdata.jsloader_test1'], []);
goog.addDependency('net/testdata/jsloader_test2.js', ['goog.net.testdata.jsloader_test2'], []);
goog.addDependency('net/testdata/jsloader_test3.js', ['goog.net.testdata.jsloader_test3'], []);
goog.addDependency('net/testdata/jsloader_test4.js', ['goog.net.testdata.jsloader_test4'], []);
goog.addDependency('net/tmpnetwork.js', ['goog.net.tmpnetwork'], [
  'goog.Uri',
  'goog.net.ChannelDebug'
]);
goog.addDependency('net/websocket.js', [
  'goog.net.WebSocket',
  'goog.net.WebSocket.ErrorEvent',
  'goog.net.WebSocket.EventType',
  'goog.net.WebSocket.MessageEvent'
], [
  'goog.Timer',
  'goog.asserts',
  'goog.debug.entryPointRegistry',
  'goog.events',
  'goog.events.Event',
  'goog.events.EventTarget',
  'goog.log'
]);
goog.addDependency('net/wrapperxmlhttpfactory.js', ['goog.net.WrapperXmlHttpFactory'], ['goog.net.XmlHttpFactory']);
goog.addDependency('net/xhrio.js', [
  'goog.net.XhrIo',
  'goog.net.XhrIo.ResponseType'
], [
  'goog.Timer',
  'goog.array',
  'goog.debug.entryPointRegistry',
  'goog.events.EventTarget',
  'goog.json',
  'goog.log',
  'goog.net.ErrorCode',
  'goog.net.EventType',
  'goog.net.HttpStatus',
  'goog.net.XmlHttp',
  'goog.object',
  'goog.string',
  'goog.structs',
  'goog.structs.Map',
  'goog.uri.utils',
  'goog.userAgent'
]);
goog.addDependency('net/xhriopool.js', ['goog.net.XhrIoPool'], [
  'goog.net.XhrIo',
  'goog.structs',
  'goog.structs.PriorityPool'
]);
goog.addDependency('net/xhrmanager.js', [
  'goog.net.XhrManager',
  'goog.net.XhrManager.Event',
  'goog.net.XhrManager.Request'
], [
  'goog.Disposable',
  'goog.events',
  'goog.events.Event',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.net.ErrorCode',
  'goog.net.EventType',
  'goog.net.XhrIo',
  'goog.net.XhrIoPool',
  'goog.structs',
  'goog.structs.Map'
]);
goog.addDependency('net/xmlhttp.js', [
  'goog.net.DefaultXmlHttpFactory',
  'goog.net.XmlHttp',
  'goog.net.XmlHttp.OptionType',
  'goog.net.XmlHttp.ReadyState'
], [
  'goog.net.WrapperXmlHttpFactory',
  'goog.net.XmlHttpFactory'
]);
goog.addDependency('net/xmlhttpfactory.js', ['goog.net.XmlHttpFactory'], []);
goog.addDependency('net/xpc/crosspagechannel.js', ['goog.net.xpc.CrossPageChannel'], [
  'goog.Disposable',
  'goog.Uri',
  'goog.async.Deferred',
  'goog.async.Delay',
  'goog.dom',
  'goog.events',
  'goog.events.EventHandler',
  'goog.json',
  'goog.messaging.AbstractChannel',
  'goog.net.xpc',
  'goog.net.xpc.CrossPageChannelRole',
  'goog.net.xpc.FrameElementMethodTransport',
  'goog.net.xpc.IframePollingTransport',
  'goog.net.xpc.IframeRelayTransport',
  'goog.net.xpc.NativeMessagingTransport',
  'goog.net.xpc.NixTransport',
  'goog.net.xpc.Transport',
  'goog.userAgent'
]);
goog.addDependency('net/xpc/crosspagechannelrole.js', ['goog.net.xpc.CrossPageChannelRole'], []);
goog.addDependency('net/xpc/frameelementmethodtransport.js', ['goog.net.xpc.FrameElementMethodTransport'], [
  'goog.net.xpc',
  'goog.net.xpc.CrossPageChannelRole',
  'goog.net.xpc.Transport'
]);
goog.addDependency('net/xpc/iframepollingtransport.js', [
  'goog.net.xpc.IframePollingTransport',
  'goog.net.xpc.IframePollingTransport.Receiver',
  'goog.net.xpc.IframePollingTransport.Sender'
], [
  'goog.array',
  'goog.dom',
  'goog.net.xpc',
  'goog.net.xpc.CrossPageChannelRole',
  'goog.net.xpc.Transport',
  'goog.userAgent'
]);
goog.addDependency('net/xpc/iframerelaytransport.js', ['goog.net.xpc.IframeRelayTransport'], [
  'goog.dom',
  'goog.events',
  'goog.net.xpc',
  'goog.net.xpc.Transport',
  'goog.userAgent'
]);
goog.addDependency('net/xpc/nativemessagingtransport.js', ['goog.net.xpc.NativeMessagingTransport'], [
  'goog.Timer',
  'goog.asserts',
  'goog.async.Deferred',
  'goog.events',
  'goog.events.EventHandler',
  'goog.net.xpc',
  'goog.net.xpc.CrossPageChannelRole',
  'goog.net.xpc.Transport'
]);
goog.addDependency('net/xpc/nixtransport.js', ['goog.net.xpc.NixTransport'], [
  'goog.net.xpc',
  'goog.net.xpc.CrossPageChannelRole',
  'goog.net.xpc.Transport',
  'goog.reflect'
]);
goog.addDependency('net/xpc/relay.js', ['goog.net.xpc.relay'], []);
goog.addDependency('net/xpc/transport.js', ['goog.net.xpc.Transport'], [
  'goog.Disposable',
  'goog.dom',
  'goog.net.xpc'
]);
goog.addDependency('net/xpc/xpc.js', [
  'goog.net.xpc',
  'goog.net.xpc.CfgFields',
  'goog.net.xpc.ChannelStates',
  'goog.net.xpc.TransportNames',
  'goog.net.xpc.TransportTypes',
  'goog.net.xpc.UriCfgFields'
], ['goog.log']);
goog.addDependency('object/object.js', ['goog.object'], []);
goog.addDependency('positioning/absoluteposition.js', ['goog.positioning.AbsolutePosition'], [
  'goog.math.Box',
  'goog.math.Coordinate',
  'goog.math.Size',
  'goog.positioning',
  'goog.positioning.AbstractPosition'
]);
goog.addDependency('positioning/abstractposition.js', ['goog.positioning.AbstractPosition'], [
  'goog.math.Box',
  'goog.math.Size',
  'goog.positioning.Corner'
]);
goog.addDependency('positioning/anchoredposition.js', ['goog.positioning.AnchoredPosition'], [
  'goog.math.Box',
  'goog.positioning',
  'goog.positioning.AbstractPosition'
]);
goog.addDependency('positioning/anchoredviewportposition.js', ['goog.positioning.AnchoredViewportPosition'], [
  'goog.math.Box',
  'goog.positioning',
  'goog.positioning.AnchoredPosition',
  'goog.positioning.Corner',
  'goog.positioning.Overflow',
  'goog.positioning.OverflowStatus'
]);
goog.addDependency('positioning/clientposition.js', ['goog.positioning.ClientPosition'], [
  'goog.asserts',
  'goog.math.Box',
  'goog.math.Coordinate',
  'goog.math.Size',
  'goog.positioning',
  'goog.positioning.AbstractPosition',
  'goog.style'
]);
goog.addDependency('positioning/clientposition_test.js', ['goog.positioning.clientPositionTest'], [
  'goog.dom',
  'goog.positioning.ClientPosition',
  'goog.style',
  'goog.testing.jsunit'
]);
goog.addDependency('positioning/menuanchoredposition.js', ['goog.positioning.MenuAnchoredPosition'], [
  'goog.math.Box',
  'goog.math.Size',
  'goog.positioning',
  'goog.positioning.AnchoredViewportPosition',
  'goog.positioning.Corner',
  'goog.positioning.Overflow'
]);
goog.addDependency('positioning/positioning.js', [
  'goog.positioning',
  'goog.positioning.Corner',
  'goog.positioning.CornerBit',
  'goog.positioning.Overflow',
  'goog.positioning.OverflowStatus'
], [
  'goog.asserts',
  'goog.dom',
  'goog.dom.TagName',
  'goog.math.Box',
  'goog.math.Coordinate',
  'goog.math.Size',
  'goog.style',
  'goog.style.bidi'
]);
goog.addDependency('positioning/positioning_test.js', ['goog.positioningTest'], [
  'goog.dom',
  'goog.dom.DomHelper',
  'goog.math.Box',
  'goog.math.Coordinate',
  'goog.math.Rect',
  'goog.math.Size',
  'goog.positioning',
  'goog.positioning.Corner',
  'goog.positioning.Overflow',
  'goog.positioning.OverflowStatus',
  'goog.style',
  'goog.testing.ExpectedFailures',
  'goog.testing.jsunit',
  'goog.userAgent',
  'goog.userAgent.product'
]);
goog.addDependency('positioning/viewportclientposition.js', ['goog.positioning.ViewportClientPosition'], [
  'goog.math.Box',
  'goog.math.Coordinate',
  'goog.math.Size',
  'goog.positioning.ClientPosition'
]);
goog.addDependency('positioning/viewportposition.js', ['goog.positioning.ViewportPosition'], [
  'goog.math.Box',
  'goog.math.Coordinate',
  'goog.math.Size',
  'goog.positioning.AbstractPosition'
]);
goog.addDependency('proto/proto.js', ['goog.proto'], ['goog.proto.Serializer']);
goog.addDependency('proto/serializer.js', ['goog.proto.Serializer'], [
  'goog.json.Serializer',
  'goog.string'
]);
goog.addDependency('proto2/descriptor.js', [
  'goog.proto2.Descriptor',
  'goog.proto2.Metadata'
], [
  'goog.array',
  'goog.object',
  'goog.proto2.Util'
]);
goog.addDependency('proto2/fielddescriptor.js', ['goog.proto2.FieldDescriptor'], [
  'goog.proto2.Util',
  'goog.string'
]);
goog.addDependency('proto2/lazydeserializer.js', ['goog.proto2.LazyDeserializer'], [
  'goog.proto2.Message',
  'goog.proto2.Serializer',
  'goog.proto2.Util'
]);
goog.addDependency('proto2/message.js', ['goog.proto2.Message'], [
  'goog.proto2.Descriptor',
  'goog.proto2.FieldDescriptor',
  'goog.proto2.Util',
  'goog.string'
]);
goog.addDependency('proto2/objectserializer.js', ['goog.proto2.ObjectSerializer'], [
  'goog.proto2.Serializer',
  'goog.proto2.Util',
  'goog.string'
]);
goog.addDependency('proto2/package_test.pb.js', ['someprotopackage.TestPackageTypes'], [
  'goog.proto2.Message',
  'proto2.TestAllTypes'
]);
goog.addDependency('proto2/pbliteserializer.js', ['goog.proto2.PbLiteSerializer'], [
  'goog.proto2.LazyDeserializer',
  'goog.proto2.Util'
]);
goog.addDependency('proto2/serializer.js', ['goog.proto2.Serializer'], [
  'goog.proto2.Descriptor',
  'goog.proto2.FieldDescriptor',
  'goog.proto2.Message',
  'goog.proto2.Util'
]);
goog.addDependency('proto2/test.pb.js', [
  'proto2.TestAllTypes',
  'proto2.TestAllTypes.NestedEnum',
  'proto2.TestAllTypes.NestedMessage',
  'proto2.TestAllTypes.OptionalGroup',
  'proto2.TestAllTypes.RepeatedGroup'
], ['goog.proto2.Message']);
goog.addDependency('proto2/textformatserializer.js', [
  'goog.proto2.TextFormatSerializer',
  'goog.proto2.TextFormatSerializer.Parser'
], [
  'goog.array',
  'goog.asserts',
  'goog.json',
  'goog.proto2.Serializer',
  'goog.proto2.Util',
  'goog.string'
]);
goog.addDependency('proto2/textformatserializer_test.js', ['goog.proto2.TextFormatSerializerTest'], [
  'goog.proto2.TextFormatSerializer',
  'goog.testing.jsunit',
  'proto2.TestAllTypes'
]);
goog.addDependency('proto2/util.js', ['goog.proto2.Util'], ['goog.asserts']);
goog.addDependency('pubsub/pubsub.js', ['goog.pubsub.PubSub'], [
  'goog.Disposable',
  'goog.array'
]);
goog.addDependency('reflect/reflect.js', ['goog.reflect'], []);
goog.addDependency('result/deferredadaptor.js', ['goog.result.DeferredAdaptor'], [
  'goog.async.Deferred',
  'goog.result',
  'goog.result.Result'
]);
goog.addDependency('result/dependentresult.js', ['goog.result.DependentResult'], ['goog.result.Result']);
goog.addDependency('result/result_interface.js', ['goog.result.Result'], []);
goog.addDependency('result/resultutil.js', ['goog.result'], [
  'goog.array',
  'goog.result.DependentResult',
  'goog.result.Result',
  'goog.result.SimpleResult'
]);
goog.addDependency('result/simpleresult.js', [
  'goog.result.SimpleResult',
  'goog.result.SimpleResult.StateError'
], [
  'goog.debug.Error',
  'goog.result.Result'
]);
goog.addDependency('soy/data.js', [
  'goog.soy.data',
  'goog.soy.data.SanitizedContent',
  'goog.soy.data.SanitizedContentKind'
], []);
goog.addDependency('soy/renderer.js', [
  'goog.soy.InjectedDataSupplier',
  'goog.soy.Renderer'
], [
  'goog.asserts',
  'goog.dom',
  'goog.soy',
  'goog.soy.data.SanitizedContent',
  'goog.soy.data.SanitizedContentKind'
]);
goog.addDependency('soy/soy.js', ['goog.soy'], [
  'goog.asserts',
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.TagName',
  'goog.soy.data',
  'goog.string'
]);
goog.addDependency('soy/soy_test.js', ['goog.soy.testHelper'], [
  'goog.dom',
  'goog.dom.TagName',
  'goog.soy.data.SanitizedContent',
  'goog.soy.data.SanitizedContentKind',
  'goog.string',
  'goog.userAgent'
]);
goog.addDependency('spell/spellcheck.js', [
  'goog.spell.SpellCheck',
  'goog.spell.SpellCheck.WordChangedEvent'
], [
  'goog.Timer',
  'goog.events.EventTarget',
  'goog.structs.Set'
]);
goog.addDependency('stats/basicstat.js', ['goog.stats.BasicStat'], [
  'goog.array',
  'goog.iter',
  'goog.log',
  'goog.object',
  'goog.string.format',
  'goog.structs.CircularBuffer'
]);
goog.addDependency('storage/collectablestorage.js', ['goog.storage.CollectableStorage'], [
  'goog.array',
  'goog.asserts',
  'goog.iter',
  'goog.storage.ErrorCode',
  'goog.storage.ExpiringStorage',
  'goog.storage.RichStorage.Wrapper',
  'goog.storage.mechanism.IterableMechanism'
]);
goog.addDependency('storage/encryptedstorage.js', ['goog.storage.EncryptedStorage'], [
  'goog.crypt',
  'goog.crypt.Arc4',
  'goog.crypt.Sha1',
  'goog.crypt.base64',
  'goog.json',
  'goog.json.Serializer',
  'goog.storage.CollectableStorage',
  'goog.storage.ErrorCode',
  'goog.storage.RichStorage',
  'goog.storage.RichStorage.Wrapper',
  'goog.storage.mechanism.IterableMechanism'
]);
goog.addDependency('storage/errorcode.js', ['goog.storage.ErrorCode'], []);
goog.addDependency('storage/expiringstorage.js', ['goog.storage.ExpiringStorage'], [
  'goog.storage.RichStorage',
  'goog.storage.RichStorage.Wrapper',
  'goog.storage.mechanism.Mechanism'
]);
goog.addDependency('storage/mechanism/errorcode.js', ['goog.storage.mechanism.ErrorCode'], []);
goog.addDependency('storage/mechanism/errorhandlingmechanism.js', ['goog.storage.mechanism.ErrorHandlingMechanism'], ['goog.storage.mechanism.Mechanism']);
goog.addDependency('storage/mechanism/html5localstorage.js', ['goog.storage.mechanism.HTML5LocalStorage'], ['goog.storage.mechanism.HTML5WebStorage']);
goog.addDependency('storage/mechanism/html5sessionstorage.js', ['goog.storage.mechanism.HTML5SessionStorage'], ['goog.storage.mechanism.HTML5WebStorage']);
goog.addDependency('storage/mechanism/html5webstorage.js', ['goog.storage.mechanism.HTML5WebStorage'], [
  'goog.asserts',
  'goog.iter.Iterator',
  'goog.iter.StopIteration',
  'goog.storage.mechanism.ErrorCode',
  'goog.storage.mechanism.IterableMechanism'
]);
goog.addDependency('storage/mechanism/ieuserdata.js', ['goog.storage.mechanism.IEUserData'], [
  'goog.asserts',
  'goog.iter.Iterator',
  'goog.iter.StopIteration',
  'goog.storage.mechanism.ErrorCode',
  'goog.storage.mechanism.IterableMechanism',
  'goog.structs.Map',
  'goog.userAgent'
]);
goog.addDependency('storage/mechanism/iterablemechanism.js', ['goog.storage.mechanism.IterableMechanism'], [
  'goog.array',
  'goog.asserts',
  'goog.iter',
  'goog.iter.Iterator',
  'goog.storage.mechanism.Mechanism'
]);
goog.addDependency('storage/mechanism/iterablemechanismtester.js', ['goog.storage.mechanism.iterableMechanismTester'], [
  'goog.iter.Iterator',
  'goog.storage.mechanism.IterableMechanism',
  'goog.testing.asserts'
]);
goog.addDependency('storage/mechanism/mechanism.js', ['goog.storage.mechanism.Mechanism'], []);
goog.addDependency('storage/mechanism/mechanismfactory.js', ['goog.storage.mechanism.mechanismfactory'], [
  'goog.storage.mechanism.HTML5LocalStorage',
  'goog.storage.mechanism.HTML5SessionStorage',
  'goog.storage.mechanism.IEUserData',
  'goog.storage.mechanism.IterableMechanism',
  'goog.storage.mechanism.PrefixedMechanism'
]);
goog.addDependency('storage/mechanism/mechanismseparationtester.js', ['goog.storage.mechanism.mechanismSeparationTester'], [
  'goog.iter.Iterator',
  'goog.storage.mechanism.IterableMechanism',
  'goog.testing.asserts'
]);
goog.addDependency('storage/mechanism/mechanismsharingtester.js', ['goog.storage.mechanism.mechanismSharingTester'], [
  'goog.iter.Iterator',
  'goog.storage.mechanism.IterableMechanism',
  'goog.testing.asserts'
]);
goog.addDependency('storage/mechanism/mechanismtester.js', ['goog.storage.mechanism.mechanismTester'], [
  'goog.storage.mechanism.ErrorCode',
  'goog.storage.mechanism.HTML5LocalStorage',
  'goog.storage.mechanism.Mechanism',
  'goog.testing.asserts',
  'goog.userAgent.product',
  'goog.userAgent.product.isVersion'
]);
goog.addDependency('storage/mechanism/prefixedmechanism.js', ['goog.storage.mechanism.PrefixedMechanism'], [
  'goog.iter.Iterator',
  'goog.storage.mechanism.IterableMechanism'
]);
goog.addDependency('storage/richstorage.js', [
  'goog.storage.RichStorage',
  'goog.storage.RichStorage.Wrapper'
], [
  'goog.storage.ErrorCode',
  'goog.storage.Storage',
  'goog.storage.mechanism.Mechanism'
]);
goog.addDependency('storage/storage.js', ['goog.storage.Storage'], [
  'goog.json',
  'goog.json.Serializer',
  'goog.storage.ErrorCode'
]);
goog.addDependency('storage/storage_test.js', ['goog.storage.storage_test'], [
  'goog.storage.Storage',
  'goog.structs.Map',
  'goog.testing.asserts'
]);
goog.addDependency('string/linkify.js', ['goog.string.linkify'], ['goog.string']);
goog.addDependency('string/newlines.js', [
  'goog.string.newlines',
  'goog.string.newlines.Line'
], ['goog.array']);
goog.addDependency('string/newlines_test.js', ['goog.string.newlinesTest'], [
  'goog.string.newlines',
  'goog.testing.jsunit'
]);
goog.addDependency('string/parser.js', ['goog.string.Parser'], []);
goog.addDependency('string/path.js', ['goog.string.path'], [
  'goog.array',
  'goog.string'
]);
goog.addDependency('string/string.js', [
  'goog.string',
  'goog.string.Unicode'
], []);
goog.addDependency('string/string_test.js', ['goog.stringTest'], [
  'goog.functions',
  'goog.object',
  'goog.string',
  'goog.testing.PropertyReplacer',
  'goog.testing.jsunit'
]);
goog.addDependency('string/stringbuffer.js', ['goog.string.StringBuffer'], []);
goog.addDependency('string/stringformat.js', ['goog.string.format'], ['goog.string']);
goog.addDependency('string/stringifier.js', ['goog.string.Stringifier'], []);
goog.addDependency('structs/avltree.js', [
  'goog.structs.AvlTree',
  'goog.structs.AvlTree.Node'
], ['goog.structs.Collection']);
goog.addDependency('structs/circularbuffer.js', ['goog.structs.CircularBuffer'], []);
goog.addDependency('structs/collection.js', ['goog.structs.Collection'], []);
goog.addDependency('structs/heap.js', ['goog.structs.Heap'], [
  'goog.array',
  'goog.object',
  'goog.structs.Node'
]);
goog.addDependency('structs/inversionmap.js', ['goog.structs.InversionMap'], ['goog.array']);
goog.addDependency('structs/linkedmap.js', ['goog.structs.LinkedMap'], ['goog.structs.Map']);
goog.addDependency('structs/map.js', ['goog.structs.Map'], [
  'goog.iter.Iterator',
  'goog.iter.StopIteration',
  'goog.object'
]);
goog.addDependency('structs/node.js', ['goog.structs.Node'], []);
goog.addDependency('structs/pool.js', ['goog.structs.Pool'], [
  'goog.Disposable',
  'goog.structs.Queue',
  'goog.structs.Set'
]);
goog.addDependency('structs/prioritypool.js', ['goog.structs.PriorityPool'], [
  'goog.structs.Pool',
  'goog.structs.PriorityQueue'
]);
goog.addDependency('structs/priorityqueue.js', ['goog.structs.PriorityQueue'], ['goog.structs.Heap']);
goog.addDependency('structs/quadtree.js', [
  'goog.structs.QuadTree',
  'goog.structs.QuadTree.Node',
  'goog.structs.QuadTree.Point'
], ['goog.math.Coordinate']);
goog.addDependency('structs/queue.js', ['goog.structs.Queue'], ['goog.array']);
goog.addDependency('structs/set.js', ['goog.structs.Set'], [
  'goog.structs',
  'goog.structs.Collection',
  'goog.structs.Map'
]);
goog.addDependency('structs/simplepool.js', ['goog.structs.SimplePool'], ['goog.Disposable']);
goog.addDependency('structs/stringset.js', ['goog.structs.StringSet'], [
  'goog.asserts',
  'goog.iter'
]);
goog.addDependency('structs/structs.js', ['goog.structs'], [
  'goog.array',
  'goog.object'
]);
goog.addDependency('structs/treenode.js', ['goog.structs.TreeNode'], [
  'goog.array',
  'goog.asserts',
  'goog.structs.Node'
]);
goog.addDependency('structs/trie.js', ['goog.structs.Trie'], [
  'goog.object',
  'goog.structs'
]);
goog.addDependency('style/bidi.js', ['goog.style.bidi'], [
  'goog.dom',
  'goog.style',
  'goog.userAgent'
]);
goog.addDependency('style/cursor.js', ['goog.style.cursor'], ['goog.userAgent']);
goog.addDependency('style/style.js', ['goog.style'], [
  'goog.array',
  'goog.asserts',
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.vendor',
  'goog.math.Box',
  'goog.math.Coordinate',
  'goog.math.Rect',
  'goog.math.Size',
  'goog.object',
  'goog.string',
  'goog.userAgent'
]);
goog.addDependency('style/style_test.js', ['goog.style_test'], [
  'goog.array',
  'goog.color',
  'goog.dom',
  'goog.events.BrowserEvent',
  'goog.math.Box',
  'goog.math.Coordinate',
  'goog.math.Rect',
  'goog.math.Size',
  'goog.object',
  'goog.string',
  'goog.style',
  'goog.testing.ExpectedFailures',
  'goog.testing.PropertyReplacer',
  'goog.testing.asserts',
  'goog.testing.jsunit',
  'goog.userAgent',
  'goog.userAgent.product',
  'goog.userAgent.product.isVersion'
]);
goog.addDependency('style/stylescrollbartester.js', ['goog.styleScrollbarTester'], [
  'goog.dom',
  'goog.style',
  'goog.testing.asserts'
]);
goog.addDependency('style/transition.js', [
  'goog.style.transition',
  'goog.style.transition.Css3Property'
], [
  'goog.array',
  'goog.asserts',
  'goog.dom.vendor',
  'goog.style',
  'goog.userAgent'
]);
goog.addDependency('testing/asserts.js', [
  'goog.testing.JsUnitException',
  'goog.testing.asserts'
], ['goog.testing.stacktrace']);
goog.addDependency('testing/async/mockcontrol.js', ['goog.testing.async.MockControl'], [
  'goog.asserts',
  'goog.async.Deferred',
  'goog.debug',
  'goog.testing.asserts',
  'goog.testing.mockmatchers.IgnoreArgument'
]);
goog.addDependency('testing/asynctestcase.js', [
  'goog.testing.AsyncTestCase',
  'goog.testing.AsyncTestCase.ControlBreakingException'
], [
  'goog.testing.TestCase',
  'goog.testing.TestCase.Test',
  'goog.testing.asserts'
]);
goog.addDependency('testing/benchmark.js', ['goog.testing.benchmark'], [
  'goog.dom',
  'goog.dom.TagName',
  'goog.testing.PerformanceTable',
  'goog.testing.PerformanceTimer',
  'goog.testing.TestCase'
]);
goog.addDependency('testing/continuationtestcase.js', [
  'goog.testing.ContinuationTestCase',
  'goog.testing.ContinuationTestCase.Step',
  'goog.testing.ContinuationTestCase.Test'
], [
  'goog.array',
  'goog.events.EventHandler',
  'goog.testing.TestCase',
  'goog.testing.TestCase.Test',
  'goog.testing.asserts'
]);
goog.addDependency('testing/deferredtestcase.js', ['goog.testing.DeferredTestCase'], [
  'goog.async.Deferred',
  'goog.testing.AsyncTestCase',
  'goog.testing.TestCase'
]);
goog.addDependency('testing/dom.js', ['goog.testing.dom'], [
  'goog.dom',
  'goog.dom.NodeIterator',
  'goog.dom.NodeType',
  'goog.dom.TagIterator',
  'goog.dom.TagName',
  'goog.dom.classes',
  'goog.iter',
  'goog.object',
  'goog.string',
  'goog.style',
  'goog.testing.asserts',
  'goog.userAgent'
]);
goog.addDependency('testing/editor/dom.js', ['goog.testing.editor.dom'], [
  'goog.dom.NodeType',
  'goog.dom.TagIterator',
  'goog.dom.TagWalkType',
  'goog.iter',
  'goog.string',
  'goog.testing.asserts'
]);
goog.addDependency('testing/editor/fieldmock.js', ['goog.testing.editor.FieldMock'], [
  'goog.dom',
  'goog.dom.Range',
  'goog.editor.Field',
  'goog.testing.LooseMock',
  'goog.testing.mockmatchers'
]);
goog.addDependency('testing/editor/testhelper.js', ['goog.testing.editor.TestHelper'], [
  'goog.Disposable',
  'goog.dom',
  'goog.dom.Range',
  'goog.editor.BrowserFeature',
  'goog.editor.node',
  'goog.editor.plugins.AbstractBubblePlugin',
  'goog.testing.dom'
]);
goog.addDependency('testing/events/eventobserver.js', ['goog.testing.events.EventObserver'], ['goog.array']);
goog.addDependency('testing/events/events.js', [
  'goog.testing.events',
  'goog.testing.events.Event'
], [
  'goog.Disposable',
  'goog.asserts',
  'goog.dom.NodeType',
  'goog.events',
  'goog.events.BrowserEvent',
  'goog.events.BrowserFeature',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.object',
  'goog.style',
  'goog.userAgent'
]);
goog.addDependency('testing/events/matchers.js', ['goog.testing.events.EventMatcher'], [
  'goog.events.Event',
  'goog.testing.mockmatchers.ArgumentMatcher'
]);
goog.addDependency('testing/events/onlinehandler.js', ['goog.testing.events.OnlineHandler'], [
  'goog.events.EventTarget',
  'goog.net.NetworkStatusMonitor'
]);
goog.addDependency('testing/expectedfailures.js', ['goog.testing.ExpectedFailures'], [
  'goog.debug.DivConsole',
  'goog.dom',
  'goog.dom.TagName',
  'goog.events',
  'goog.events.EventType',
  'goog.log',
  'goog.style',
  'goog.testing.JsUnitException',
  'goog.testing.TestCase',
  'goog.testing.asserts'
]);
goog.addDependency('testing/fs/blob.js', ['goog.testing.fs.Blob'], ['goog.crypt.base64']);
goog.addDependency('testing/fs/entry.js', [
  'goog.testing.fs.DirectoryEntry',
  'goog.testing.fs.Entry',
  'goog.testing.fs.FileEntry'
], [
  'goog.Timer',
  'goog.array',
  'goog.asserts',
  'goog.async.Deferred',
  'goog.fs.DirectoryEntry',
  'goog.fs.DirectoryEntryImpl',
  'goog.fs.Entry',
  'goog.fs.Error',
  'goog.fs.FileEntry',
  'goog.functions',
  'goog.object',
  'goog.string',
  'goog.testing.fs.File',
  'goog.testing.fs.FileWriter'
]);
goog.addDependency('testing/fs/file.js', ['goog.testing.fs.File'], ['goog.testing.fs.Blob']);
goog.addDependency('testing/fs/filereader.js', ['goog.testing.fs.FileReader'], [
  'goog.Timer',
  'goog.events.EventTarget',
  'goog.fs.Error',
  'goog.fs.FileReader.EventType',
  'goog.fs.FileReader.ReadyState',
  'goog.testing.fs.File',
  'goog.testing.fs.ProgressEvent'
]);
goog.addDependency('testing/fs/filesystem.js', ['goog.testing.fs.FileSystem'], [
  'goog.fs.FileSystem',
  'goog.testing.fs.DirectoryEntry'
]);
goog.addDependency('testing/fs/filewriter.js', ['goog.testing.fs.FileWriter'], [
  'goog.Timer',
  'goog.events.Event',
  'goog.events.EventTarget',
  'goog.fs.Error',
  'goog.fs.FileSaver.EventType',
  'goog.fs.FileSaver.ReadyState',
  'goog.string',
  'goog.testing.fs.File',
  'goog.testing.fs.ProgressEvent'
]);
goog.addDependency('testing/fs/fs.js', ['goog.testing.fs'], [
  'goog.Timer',
  'goog.array',
  'goog.async.Deferred',
  'goog.fs',
  'goog.testing.fs.Blob',
  'goog.testing.fs.FileSystem'
]);
goog.addDependency('testing/fs/progressevent.js', ['goog.testing.fs.ProgressEvent'], ['goog.events.Event']);
goog.addDependency('testing/functionmock.js', [
  'goog.testing',
  'goog.testing.FunctionMock',
  'goog.testing.GlobalFunctionMock',
  'goog.testing.MethodMock'
], [
  'goog.object',
  'goog.testing.LooseMock',
  'goog.testing.Mock',
  'goog.testing.MockInterface',
  'goog.testing.PropertyReplacer',
  'goog.testing.StrictMock'
]);
goog.addDependency('testing/graphics.js', ['goog.testing.graphics'], [
  'goog.graphics.Path.Segment',
  'goog.testing.asserts'
]);
goog.addDependency('testing/i18n/asserts.js', ['goog.testing.i18n.asserts'], ['goog.testing.jsunit']);
goog.addDependency('testing/i18n/asserts_test.js', ['goog.testing.i18n.assertsTest'], [
  'goog.testing.ExpectedFailures',
  'goog.testing.i18n.asserts'
]);
goog.addDependency('testing/jsunit.js', ['goog.testing.jsunit'], [
  'goog.testing.TestCase',
  'goog.testing.TestRunner'
]);
goog.addDependency('testing/loosemock.js', [
  'goog.testing.LooseExpectationCollection',
  'goog.testing.LooseMock'
], [
  'goog.array',
  'goog.structs.Map',
  'goog.testing.Mock'
]);
goog.addDependency('testing/messaging/mockmessagechannel.js', ['goog.testing.messaging.MockMessageChannel'], [
  'goog.messaging.AbstractChannel',
  'goog.testing.asserts'
]);
goog.addDependency('testing/messaging/mockmessageevent.js', ['goog.testing.messaging.MockMessageEvent'], [
  'goog.events.BrowserEvent',
  'goog.events.EventType',
  'goog.testing.events'
]);
goog.addDependency('testing/messaging/mockmessageport.js', ['goog.testing.messaging.MockMessagePort'], ['goog.events.EventTarget']);
goog.addDependency('testing/messaging/mockportnetwork.js', ['goog.testing.messaging.MockPortNetwork'], [
  'goog.messaging.PortNetwork',
  'goog.testing.messaging.MockMessageChannel'
]);
goog.addDependency('testing/mock.js', [
  'goog.testing.Mock',
  'goog.testing.MockExpectation'
], [
  'goog.array',
  'goog.object',
  'goog.testing.JsUnitException',
  'goog.testing.MockInterface',
  'goog.testing.mockmatchers'
]);
goog.addDependency('testing/mockclassfactory.js', [
  'goog.testing.MockClassFactory',
  'goog.testing.MockClassRecord'
], [
  'goog.array',
  'goog.object',
  'goog.testing.LooseMock',
  'goog.testing.StrictMock',
  'goog.testing.TestCase',
  'goog.testing.mockmatchers'
]);
goog.addDependency('testing/mockclock.js', ['goog.testing.MockClock'], [
  'goog.Disposable',
  'goog.testing.PropertyReplacer',
  'goog.testing.events',
  'goog.testing.events.Event'
]);
goog.addDependency('testing/mockcontrol.js', ['goog.testing.MockControl'], [
  'goog.array',
  'goog.testing',
  'goog.testing.LooseMock',
  'goog.testing.MockInterface',
  'goog.testing.StrictMock'
]);
goog.addDependency('testing/mockinterface.js', ['goog.testing.MockInterface'], []);
goog.addDependency('testing/mockmatchers.js', [
  'goog.testing.mockmatchers',
  'goog.testing.mockmatchers.ArgumentMatcher',
  'goog.testing.mockmatchers.IgnoreArgument',
  'goog.testing.mockmatchers.InstanceOf',
  'goog.testing.mockmatchers.ObjectEquals',
  'goog.testing.mockmatchers.RegexpMatch',
  'goog.testing.mockmatchers.SaveArgument',
  'goog.testing.mockmatchers.TypeOf'
], [
  'goog.array',
  'goog.dom',
  'goog.testing.asserts'
]);
goog.addDependency('testing/mockrandom.js', ['goog.testing.MockRandom'], ['goog.Disposable']);
goog.addDependency('testing/mockrange.js', ['goog.testing.MockRange'], [
  'goog.dom.AbstractRange',
  'goog.testing.LooseMock'
]);
goog.addDependency('testing/mockstorage.js', ['goog.testing.MockStorage'], ['goog.structs.Map']);
goog.addDependency('testing/mockuseragent.js', ['goog.testing.MockUserAgent'], [
  'goog.Disposable',
  'goog.userAgent'
]);
goog.addDependency('testing/multitestrunner.js', [
  'goog.testing.MultiTestRunner',
  'goog.testing.MultiTestRunner.TestFrame'
], [
  'goog.Timer',
  'goog.array',
  'goog.dom',
  'goog.dom.classes',
  'goog.events.EventHandler',
  'goog.functions',
  'goog.string',
  'goog.ui.Component',
  'goog.ui.ServerChart',
  'goog.ui.TableSorter'
]);
goog.addDependency('testing/net/xhrio.js', ['goog.testing.net.XhrIo'], [
  'goog.array',
  'goog.dom.xml',
  'goog.events',
  'goog.events.EventTarget',
  'goog.json',
  'goog.net.ErrorCode',
  'goog.net.EventType',
  'goog.net.HttpStatus',
  'goog.net.XhrIo',
  'goog.net.XmlHttp',
  'goog.object',
  'goog.structs.Map'
]);
goog.addDependency('testing/net/xhriopool.js', ['goog.testing.net.XhrIoPool'], [
  'goog.net.XhrIoPool',
  'goog.testing.net.XhrIo'
]);
goog.addDependency('testing/objectpropertystring.js', ['goog.testing.ObjectPropertyString'], []);
goog.addDependency('testing/performancetable.js', ['goog.testing.PerformanceTable'], [
  'goog.dom',
  'goog.testing.PerformanceTimer'
]);
goog.addDependency('testing/performancetimer.js', [
  'goog.testing.PerformanceTimer',
  'goog.testing.PerformanceTimer.Task'
], [
  'goog.array',
  'goog.async.Deferred',
  'goog.math'
]);
goog.addDependency('testing/propertyreplacer.js', ['goog.testing.PropertyReplacer'], ['goog.userAgent']);
goog.addDependency('testing/proto2/proto2.js', ['goog.testing.proto2'], [
  'goog.proto2.Message',
  'goog.testing.asserts'
]);
goog.addDependency('testing/pseudorandom.js', ['goog.testing.PseudoRandom'], ['goog.Disposable']);
goog.addDependency('testing/recordfunction.js', [
  'goog.testing.FunctionCall',
  'goog.testing.recordConstructor',
  'goog.testing.recordFunction'
], []);
goog.addDependency('testing/shardingtestcase.js', ['goog.testing.ShardingTestCase'], [
  'goog.asserts',
  'goog.testing.TestCase'
]);
goog.addDependency('testing/singleton.js', ['goog.testing.singleton'], []);
goog.addDependency('testing/stacktrace.js', [
  'goog.testing.stacktrace',
  'goog.testing.stacktrace.Frame'
], []);
goog.addDependency('testing/storage/fakemechanism.js', ['goog.testing.storage.FakeMechanism'], [
  'goog.storage.mechanism.IterableMechanism',
  'goog.structs.Map'
]);
goog.addDependency('testing/strictmock.js', ['goog.testing.StrictMock'], [
  'goog.array',
  'goog.testing.Mock'
]);
goog.addDependency('testing/style/layoutasserts.js', ['goog.testing.style.layoutasserts'], [
  'goog.style',
  'goog.testing.asserts',
  'goog.testing.style'
]);
goog.addDependency('testing/style/style.js', ['goog.testing.style'], [
  'goog.dom',
  'goog.math.Rect',
  'goog.style'
]);
goog.addDependency('testing/testcase.js', [
  'goog.testing.TestCase',
  'goog.testing.TestCase.Error',
  'goog.testing.TestCase.Order',
  'goog.testing.TestCase.Result',
  'goog.testing.TestCase.Test'
], [
  'goog.object',
  'goog.testing.asserts',
  'goog.testing.stacktrace'
]);
goog.addDependency('testing/testqueue.js', ['goog.testing.TestQueue'], []);
goog.addDependency('testing/testrunner.js', ['goog.testing.TestRunner'], ['goog.testing.TestCase']);
goog.addDependency('testing/ui/rendererasserts.js', ['goog.testing.ui.rendererasserts'], ['goog.testing.asserts']);
goog.addDependency('testing/ui/rendererharness.js', ['goog.testing.ui.RendererHarness'], [
  'goog.Disposable',
  'goog.dom.NodeType',
  'goog.testing.asserts',
  'goog.testing.dom'
]);
goog.addDependency('testing/ui/style.js', ['goog.testing.ui.style'], [
  'goog.array',
  'goog.dom',
  'goog.dom.classes',
  'goog.testing.asserts'
]);
goog.addDependency('timer/timer.js', ['goog.Timer'], ['goog.events.EventTarget']);
goog.addDependency('tweak/entries.js', [
  'goog.tweak.BaseEntry',
  'goog.tweak.BasePrimitiveSetting',
  'goog.tweak.BaseSetting',
  'goog.tweak.BooleanGroup',
  'goog.tweak.BooleanInGroupSetting',
  'goog.tweak.BooleanSetting',
  'goog.tweak.ButtonAction',
  'goog.tweak.NumericSetting',
  'goog.tweak.StringSetting'
], [
  'goog.array',
  'goog.asserts',
  'goog.log',
  'goog.object'
]);
goog.addDependency('tweak/registry.js', ['goog.tweak.Registry'], [
  'goog.asserts',
  'goog.log',
  'goog.object',
  'goog.string',
  'goog.tweak.BaseEntry',
  'goog.uri.utils'
]);
goog.addDependency('tweak/testhelpers.js', ['goog.tweak.testhelpers'], [
  'goog.tweak',
  'goog.tweak.BooleanGroup',
  'goog.tweak.BooleanInGroupSetting',
  'goog.tweak.BooleanSetting',
  'goog.tweak.ButtonAction',
  'goog.tweak.NumericSetting',
  'goog.tweak.Registry',
  'goog.tweak.StringSetting'
]);
goog.addDependency('tweak/tweak.js', [
  'goog.tweak',
  'goog.tweak.ConfigParams'
], [
  'goog.asserts',
  'goog.tweak.BaseSetting',
  'goog.tweak.BooleanGroup',
  'goog.tweak.BooleanInGroupSetting',
  'goog.tweak.BooleanSetting',
  'goog.tweak.ButtonAction',
  'goog.tweak.NumericSetting',
  'goog.tweak.Registry',
  'goog.tweak.StringSetting'
]);
goog.addDependency('tweak/tweakui.js', [
  'goog.tweak.EntriesPanel',
  'goog.tweak.TweakUi'
], [
  'goog.array',
  'goog.asserts',
  'goog.dom.DomHelper',
  'goog.object',
  'goog.style',
  'goog.tweak',
  'goog.ui.Zippy',
  'goog.userAgent'
]);
goog.addDependency('ui/abstractspellchecker.js', [
  'goog.ui.AbstractSpellChecker',
  'goog.ui.AbstractSpellChecker.AsyncResult'
], [
  'goog.a11y.aria',
  'goog.array',
  'goog.asserts',
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.classes',
  'goog.dom.selection',
  'goog.events',
  'goog.events.Event',
  'goog.events.EventType',
  'goog.math.Coordinate',
  'goog.spell.SpellCheck',
  'goog.structs.Set',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.MenuItem',
  'goog.ui.MenuSeparator',
  'goog.ui.PopupMenu'
]);
goog.addDependency('ui/ac/ac.js', ['goog.ui.ac'], [
  'goog.ui.ac.ArrayMatcher',
  'goog.ui.ac.AutoComplete',
  'goog.ui.ac.InputHandler',
  'goog.ui.ac.Renderer'
]);
goog.addDependency('ui/ac/arraymatcher.js', ['goog.ui.ac.ArrayMatcher'], ['goog.string']);
goog.addDependency('ui/ac/autocomplete.js', [
  'goog.ui.ac.AutoComplete',
  'goog.ui.ac.AutoComplete.EventType'
], [
  'goog.array',
  'goog.asserts',
  'goog.events',
  'goog.events.EventTarget',
  'goog.object'
]);
goog.addDependency('ui/ac/inputhandler.js', ['goog.ui.ac.InputHandler'], [
  'goog.Disposable',
  'goog.Timer',
  'goog.a11y.aria',
  'goog.dom',
  'goog.dom.selection',
  'goog.events.EventHandler',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.events.KeyHandler',
  'goog.string',
  'goog.userAgent',
  'goog.userAgent.product'
]);
goog.addDependency('ui/ac/remote.js', ['goog.ui.ac.Remote'], [
  'goog.ui.ac.AutoComplete',
  'goog.ui.ac.InputHandler',
  'goog.ui.ac.RemoteArrayMatcher',
  'goog.ui.ac.Renderer'
]);
goog.addDependency('ui/ac/remotearraymatcher.js', ['goog.ui.ac.RemoteArrayMatcher'], [
  'goog.Disposable',
  'goog.Uri',
  'goog.events',
  'goog.json',
  'goog.net.EventType',
  'goog.net.XhrIo'
]);
goog.addDependency('ui/ac/renderer.js', [
  'goog.ui.ac.Renderer',
  'goog.ui.ac.Renderer.CustomRenderer'
], [
  'goog.a11y.aria',
  'goog.a11y.aria.Role',
  'goog.a11y.aria.State',
  'goog.array',
  'goog.dispose',
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.classes',
  'goog.events',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.fx.dom.FadeInAndShow',
  'goog.fx.dom.FadeOutAndHide',
  'goog.positioning',
  'goog.positioning.Corner',
  'goog.positioning.Overflow',
  'goog.string',
  'goog.style',
  'goog.ui.IdGenerator',
  'goog.ui.ac.AutoComplete'
]);
goog.addDependency('ui/ac/renderoptions.js', ['goog.ui.ac.RenderOptions'], []);
goog.addDependency('ui/ac/richinputhandler.js', ['goog.ui.ac.RichInputHandler'], ['goog.ui.ac.InputHandler']);
goog.addDependency('ui/ac/richremote.js', ['goog.ui.ac.RichRemote'], [
  'goog.ui.ac.AutoComplete',
  'goog.ui.ac.Remote',
  'goog.ui.ac.Renderer',
  'goog.ui.ac.RichInputHandler',
  'goog.ui.ac.RichRemoteArrayMatcher'
]);
goog.addDependency('ui/ac/richremotearraymatcher.js', ['goog.ui.ac.RichRemoteArrayMatcher'], [
  'goog.json',
  'goog.ui.ac.RemoteArrayMatcher'
]);
goog.addDependency('ui/activitymonitor.js', ['goog.ui.ActivityMonitor'], [
  'goog.array',
  'goog.asserts',
  'goog.dom',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.events.EventType'
]);
goog.addDependency('ui/advancedtooltip.js', ['goog.ui.AdvancedTooltip'], [
  'goog.events',
  'goog.events.EventType',
  'goog.math.Box',
  'goog.math.Coordinate',
  'goog.style',
  'goog.ui.Tooltip',
  'goog.userAgent'
]);
goog.addDependency('ui/animatedzippy.js', ['goog.ui.AnimatedZippy'], [
  'goog.dom',
  'goog.events',
  'goog.fx.Animation',
  'goog.fx.Transition',
  'goog.fx.easing',
  'goog.ui.Zippy',
  'goog.ui.ZippyEvent'
]);
goog.addDependency('ui/attachablemenu.js', ['goog.ui.AttachableMenu'], [
  'goog.a11y.aria',
  'goog.a11y.aria.State',
  'goog.array',
  'goog.asserts',
  'goog.dom',
  'goog.dom.classes',
  'goog.events.Event',
  'goog.events.KeyCodes',
  'goog.string',
  'goog.style',
  'goog.ui.ItemEvent',
  'goog.ui.MenuBase',
  'goog.ui.PopupBase',
  'goog.userAgent'
]);
goog.addDependency('ui/bidiinput.js', ['goog.ui.BidiInput'], [
  'goog.dom',
  'goog.events',
  'goog.events.InputHandler',
  'goog.i18n.bidi',
  'goog.ui.Component'
]);
goog.addDependency('ui/bubble.js', ['goog.ui.Bubble'], [
  'goog.Timer',
  'goog.events',
  'goog.events.EventType',
  'goog.math.Box',
  'goog.positioning',
  'goog.positioning.AbsolutePosition',
  'goog.positioning.AnchoredPosition',
  'goog.positioning.Corner',
  'goog.positioning.CornerBit',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.Popup'
]);
goog.addDependency('ui/button.js', [
  'goog.ui.Button',
  'goog.ui.Button.Side'
], [
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.events.KeyHandler',
  'goog.ui.ButtonRenderer',
  'goog.ui.ButtonSide',
  'goog.ui.Component',
  'goog.ui.Control',
  'goog.ui.NativeButtonRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/buttonrenderer.js', ['goog.ui.ButtonRenderer'], [
  'goog.a11y.aria',
  'goog.a11y.aria.Role',
  'goog.a11y.aria.State',
  'goog.asserts',
  'goog.ui.ButtonSide',
  'goog.ui.Component',
  'goog.ui.ControlRenderer'
]);
goog.addDependency('ui/buttonside.js', ['goog.ui.ButtonSide'], []);
goog.addDependency('ui/charcounter.js', [
  'goog.ui.CharCounter',
  'goog.ui.CharCounter.Display'
], [
  'goog.dom',
  'goog.events',
  'goog.events.EventTarget',
  'goog.events.InputHandler'
]);
goog.addDependency('ui/charpicker.js', ['goog.ui.CharPicker'], [
  'goog.a11y.aria',
  'goog.a11y.aria.State',
  'goog.array',
  'goog.asserts',
  'goog.dom.classes',
  'goog.events',
  'goog.events.Event',
  'goog.events.EventHandler',
  'goog.events.EventType',
  'goog.events.InputHandler',
  'goog.events.KeyCodes',
  'goog.events.KeyHandler',
  'goog.i18n.CharListDecompressor',
  'goog.i18n.uChar',
  'goog.structs.Set',
  'goog.style',
  'goog.ui.Button',
  'goog.ui.Component',
  'goog.ui.ContainerScroller',
  'goog.ui.FlatButtonRenderer',
  'goog.ui.HoverCard',
  'goog.ui.LabelInput',
  'goog.ui.Menu',
  'goog.ui.MenuButton',
  'goog.ui.MenuItem',
  'goog.ui.Tooltip'
]);
goog.addDependency('ui/checkbox.js', [
  'goog.ui.Checkbox',
  'goog.ui.Checkbox.State'
], [
  'goog.a11y.aria',
  'goog.a11y.aria.State',
  'goog.asserts',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.ui.CheckboxRenderer',
  'goog.ui.Component.EventType',
  'goog.ui.Component.State',
  'goog.ui.Control',
  'goog.ui.registry'
]);
goog.addDependency('ui/checkboxmenuitem.js', ['goog.ui.CheckBoxMenuItem'], [
  'goog.ui.MenuItem',
  'goog.ui.registry'
]);
goog.addDependency('ui/checkboxrenderer.js', ['goog.ui.CheckboxRenderer'], [
  'goog.a11y.aria',
  'goog.a11y.aria.Role',
  'goog.a11y.aria.State',
  'goog.array',
  'goog.asserts',
  'goog.dom.classes',
  'goog.object',
  'goog.ui.ControlRenderer'
]);
goog.addDependency('ui/colorbutton.js', ['goog.ui.ColorButton'], [
  'goog.ui.Button',
  'goog.ui.ColorButtonRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/colorbuttonrenderer.js', ['goog.ui.ColorButtonRenderer'], [
  'goog.dom.classes',
  'goog.functions',
  'goog.ui.ColorMenuButtonRenderer'
]);
goog.addDependency('ui/colormenubutton.js', ['goog.ui.ColorMenuButton'], [
  'goog.array',
  'goog.object',
  'goog.ui.ColorMenuButtonRenderer',
  'goog.ui.ColorPalette',
  'goog.ui.Component',
  'goog.ui.Menu',
  'goog.ui.MenuButton',
  'goog.ui.registry'
]);
goog.addDependency('ui/colormenubuttonrenderer.js', ['goog.ui.ColorMenuButtonRenderer'], [
  'goog.color',
  'goog.dom.classes',
  'goog.ui.MenuButtonRenderer',
  'goog.userAgent'
]);
goog.addDependency('ui/colorpalette.js', ['goog.ui.ColorPalette'], [
  'goog.array',
  'goog.color',
  'goog.style',
  'goog.ui.Palette',
  'goog.ui.PaletteRenderer'
]);
goog.addDependency('ui/colorpicker.js', [
  'goog.ui.ColorPicker',
  'goog.ui.ColorPicker.EventType'
], [
  'goog.ui.ColorPalette',
  'goog.ui.Component'
]);
goog.addDependency('ui/colorsplitbehavior.js', ['goog.ui.ColorSplitBehavior'], [
  'goog.ui.ColorMenuButton',
  'goog.ui.SplitBehavior'
]);
goog.addDependency('ui/combobox.js', [
  'goog.ui.ComboBox',
  'goog.ui.ComboBoxItem'
], [
  'goog.Timer',
  'goog.dom',
  'goog.dom.classlist',
  'goog.events.EventType',
  'goog.events.InputHandler',
  'goog.events.KeyCodes',
  'goog.events.KeyHandler',
  'goog.log',
  'goog.positioning.Corner',
  'goog.positioning.MenuAnchoredPosition',
  'goog.string',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.ItemEvent',
  'goog.ui.LabelInput',
  'goog.ui.Menu',
  'goog.ui.MenuItem',
  'goog.ui.MenuSeparator',
  'goog.ui.registry',
  'goog.userAgent'
]);
goog.addDependency('ui/component.js', [
  'goog.ui.Component',
  'goog.ui.Component.Error',
  'goog.ui.Component.EventType',
  'goog.ui.Component.State'
], [
  'goog.array',
  'goog.asserts',
  'goog.dom',
  'goog.dom.NodeType',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.object',
  'goog.style',
  'goog.ui.IdGenerator'
]);
goog.addDependency('ui/container.js', [
  'goog.ui.Container',
  'goog.ui.Container.EventType',
  'goog.ui.Container.Orientation'
], [
  'goog.a11y.aria',
  'goog.a11y.aria.State',
  'goog.asserts',
  'goog.dom',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.events.KeyHandler',
  'goog.object',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.ContainerRenderer',
  'goog.ui.Control'
]);
goog.addDependency('ui/containerrenderer.js', ['goog.ui.ContainerRenderer'], [
  'goog.a11y.aria',
  'goog.array',
  'goog.asserts',
  'goog.dom.NodeType',
  'goog.dom.classes',
  'goog.string',
  'goog.style',
  'goog.ui.registry',
  'goog.userAgent'
]);
goog.addDependency('ui/containerscroller.js', ['goog.ui.ContainerScroller'], [
  'goog.Disposable',
  'goog.Timer',
  'goog.events.EventHandler',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.Container'
]);
goog.addDependency('ui/control.js', ['goog.ui.Control'], [
  'goog.array',
  'goog.dom',
  'goog.events.Event',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.events.KeyHandler',
  'goog.string',
  'goog.ui.Component',
  'goog.ui.ControlContent',
  'goog.ui.ControlRenderer',
  'goog.ui.decorate',
  'goog.ui.registry',
  'goog.userAgent'
]);
goog.addDependency('ui/controlcontent.js', ['goog.ui.ControlContent'], []);
goog.addDependency('ui/controlrenderer.js', ['goog.ui.ControlRenderer'], [
  'goog.a11y.aria',
  'goog.a11y.aria.State',
  'goog.array',
  'goog.asserts',
  'goog.dom',
  'goog.dom.classes',
  'goog.object',
  'goog.style',
  'goog.ui.Component',
  'goog.userAgent'
]);
goog.addDependency('ui/cookieeditor.js', ['goog.ui.CookieEditor'], [
  'goog.asserts',
  'goog.dom',
  'goog.dom.TagName',
  'goog.events.EventType',
  'goog.net.cookies',
  'goog.string',
  'goog.style',
  'goog.ui.Component'
]);
goog.addDependency('ui/css3buttonrenderer.js', ['goog.ui.Css3ButtonRenderer'], [
  'goog.dom.TagName',
  'goog.dom.classes',
  'goog.ui.Button',
  'goog.ui.ButtonRenderer',
  'goog.ui.Component',
  'goog.ui.INLINE_BLOCK_CLASSNAME',
  'goog.ui.registry'
]);
goog.addDependency('ui/css3menubuttonrenderer.js', ['goog.ui.Css3MenuButtonRenderer'], [
  'goog.dom',
  'goog.dom.TagName',
  'goog.ui.INLINE_BLOCK_CLASSNAME',
  'goog.ui.MenuButton',
  'goog.ui.MenuButtonRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/cssnames.js', ['goog.ui.INLINE_BLOCK_CLASSNAME'], []);
goog.addDependency('ui/custombutton.js', ['goog.ui.CustomButton'], [
  'goog.ui.Button',
  'goog.ui.CustomButtonRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/custombuttonrenderer.js', ['goog.ui.CustomButtonRenderer'], [
  'goog.a11y.aria.Role',
  'goog.dom.NodeType',
  'goog.dom.classes',
  'goog.string',
  'goog.ui.ButtonRenderer',
  'goog.ui.INLINE_BLOCK_CLASSNAME'
]);
goog.addDependency('ui/customcolorpalette.js', ['goog.ui.CustomColorPalette'], [
  'goog.color',
  'goog.dom',
  'goog.dom.classes',
  'goog.ui.ColorPalette',
  'goog.ui.Component'
]);
goog.addDependency('ui/datepicker.js', [
  'goog.ui.DatePicker',
  'goog.ui.DatePicker.Events',
  'goog.ui.DatePickerEvent'
], [
  'goog.a11y.aria',
  'goog.asserts',
  'goog.date',
  'goog.date.Date',
  'goog.date.Interval',
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.classes',
  'goog.events.Event',
  'goog.events.EventType',
  'goog.events.KeyHandler',
  'goog.i18n.DateTimeFormat',
  'goog.i18n.DateTimeSymbols',
  'goog.string',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.DefaultDatePickerRenderer',
  'goog.ui.IdGenerator'
]);
goog.addDependency('ui/datepickerrenderer.js', ['goog.ui.DatePickerRenderer'], []);
goog.addDependency('ui/decorate.js', ['goog.ui.decorate'], ['goog.ui.registry']);
goog.addDependency('ui/defaultdatepickerrenderer.js', ['goog.ui.DefaultDatePickerRenderer'], [
  'goog.dom',
  'goog.dom.TagName',
  'goog.ui.DatePickerRenderer'
]);
goog.addDependency('ui/dialog.js', [
  'goog.ui.Dialog',
  'goog.ui.Dialog.ButtonSet',
  'goog.ui.Dialog.ButtonSet.DefaultButtons',
  'goog.ui.Dialog.DefaultButtonCaptions',
  'goog.ui.Dialog.DefaultButtonKeys',
  'goog.ui.Dialog.Event',
  'goog.ui.Dialog.EventType'
], [
  'goog.a11y.aria',
  'goog.a11y.aria.Role',
  'goog.a11y.aria.State',
  'goog.asserts',
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.TagName',
  'goog.dom.classes',
  'goog.events',
  'goog.events.Event',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.fx.Dragger',
  'goog.math.Rect',
  'goog.structs',
  'goog.structs.Map',
  'goog.style',
  'goog.ui.ModalPopup',
  'goog.userAgent'
]);
goog.addDependency('ui/dimensionpicker.js', ['goog.ui.DimensionPicker'], [
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.math.Size',
  'goog.ui.Component',
  'goog.ui.Control',
  'goog.ui.DimensionPickerRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/dimensionpickerrenderer.js', ['goog.ui.DimensionPickerRenderer'], [
  'goog.a11y.aria',
  'goog.a11y.aria.State',
  'goog.dom',
  'goog.dom.TagName',
  'goog.i18n.bidi',
  'goog.style',
  'goog.ui.ControlRenderer',
  'goog.userAgent'
]);
goog.addDependency('ui/dragdropdetector.js', [
  'goog.ui.DragDropDetector',
  'goog.ui.DragDropDetector.EventType',
  'goog.ui.DragDropDetector.ImageDropEvent',
  'goog.ui.DragDropDetector.LinkDropEvent'
], [
  'goog.dom',
  'goog.dom.TagName',
  'goog.events.Event',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.math.Coordinate',
  'goog.string',
  'goog.style',
  'goog.userAgent'
]);
goog.addDependency('ui/drilldownrow.js', ['goog.ui.DrilldownRow'], [
  'goog.dom',
  'goog.dom.classes',
  'goog.ui.Component'
]);
goog.addDependency('ui/editor/abstractdialog.js', [
  'goog.ui.editor.AbstractDialog',
  'goog.ui.editor.AbstractDialog.Builder',
  'goog.ui.editor.AbstractDialog.EventType'
], [
  'goog.dom',
  'goog.dom.classes',
  'goog.events.EventTarget',
  'goog.string',
  'goog.ui.Dialog'
]);
goog.addDependency('ui/editor/bubble.js', ['goog.ui.editor.Bubble'], [
  'goog.dom',
  'goog.dom.TagName',
  'goog.dom.ViewportSizeMonitor',
  'goog.dom.classes',
  'goog.editor.style',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.log',
  'goog.math.Box',
  'goog.object',
  'goog.positioning',
  'goog.positioning.Corner',
  'goog.positioning.Overflow',
  'goog.positioning.OverflowStatus',
  'goog.string',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.PopupBase',
  'goog.userAgent'
]);
goog.addDependency('ui/editor/defaulttoolbar.js', [
  'goog.ui.editor.ButtonDescriptor',
  'goog.ui.editor.DefaultToolbar'
], [
  'goog.dom',
  'goog.dom.TagName',
  'goog.dom.classes',
  'goog.editor.Command',
  'goog.style',
  'goog.ui.editor.ToolbarFactory',
  'goog.ui.editor.messages',
  'goog.userAgent'
]);
goog.addDependency('ui/editor/equationeditordialog.js', ['goog.ui.editor.EquationEditorDialog'], [
  'goog.editor.Command',
  'goog.ui.Dialog',
  'goog.ui.editor.AbstractDialog',
  'goog.ui.editor.EquationEditorOkEvent',
  'goog.ui.equation.TexEditor'
]);
goog.addDependency('ui/editor/equationeditorokevent.js', ['goog.ui.editor.EquationEditorOkEvent'], [
  'goog.events.Event',
  'goog.ui.editor.AbstractDialog'
]);
goog.addDependency('ui/editor/linkdialog.js', [
  'goog.ui.editor.LinkDialog',
  'goog.ui.editor.LinkDialog.BeforeTestLinkEvent',
  'goog.ui.editor.LinkDialog.EventType',
  'goog.ui.editor.LinkDialog.OkEvent'
], [
  'goog.dom',
  'goog.dom.TagName',
  'goog.editor.BrowserFeature',
  'goog.editor.Link',
  'goog.editor.focus',
  'goog.editor.node',
  'goog.events.Event',
  'goog.events.EventHandler',
  'goog.events.EventType',
  'goog.events.InputHandler',
  'goog.string',
  'goog.style',
  'goog.ui.Button',
  'goog.ui.Component',
  'goog.ui.LinkButtonRenderer',
  'goog.ui.editor.AbstractDialog',
  'goog.ui.editor.TabPane',
  'goog.ui.editor.messages',
  'goog.userAgent',
  'goog.window'
]);
goog.addDependency('ui/editor/messages.js', ['goog.ui.editor.messages'], []);
goog.addDependency('ui/editor/tabpane.js', ['goog.ui.editor.TabPane'], [
  'goog.dom.TagName',
  'goog.dom.classes',
  'goog.events.EventHandler',
  'goog.events.EventType',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.Control',
  'goog.ui.Tab',
  'goog.ui.TabBar'
]);
goog.addDependency('ui/editor/toolbarcontroller.js', ['goog.ui.editor.ToolbarController'], [
  'goog.editor.Field',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.ui.Component'
]);
goog.addDependency('ui/editor/toolbarfactory.js', ['goog.ui.editor.ToolbarFactory'], [
  'goog.array',
  'goog.dom',
  'goog.dom.TagName',
  'goog.string',
  'goog.string.Unicode',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.Container',
  'goog.ui.Option',
  'goog.ui.Toolbar',
  'goog.ui.ToolbarButton',
  'goog.ui.ToolbarColorMenuButton',
  'goog.ui.ToolbarMenuButton',
  'goog.ui.ToolbarRenderer',
  'goog.ui.ToolbarSelect',
  'goog.userAgent'
]);
goog.addDependency('ui/emoji/emoji.js', ['goog.ui.emoji.Emoji'], []);
goog.addDependency('ui/emoji/emojipalette.js', ['goog.ui.emoji.EmojiPalette'], [
  'goog.events.EventType',
  'goog.net.ImageLoader',
  'goog.ui.Palette',
  'goog.ui.emoji.Emoji',
  'goog.ui.emoji.EmojiPaletteRenderer'
]);
goog.addDependency('ui/emoji/emojipaletterenderer.js', ['goog.ui.emoji.EmojiPaletteRenderer'], [
  'goog.a11y.aria',
  'goog.dom.NodeType',
  'goog.dom.classes',
  'goog.style',
  'goog.ui.PaletteRenderer',
  'goog.ui.emoji.Emoji'
]);
goog.addDependency('ui/emoji/emojipicker.js', ['goog.ui.emoji.EmojiPicker'], [
  'goog.log',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.TabPane',
  'goog.ui.emoji.Emoji',
  'goog.ui.emoji.EmojiPalette',
  'goog.ui.emoji.EmojiPaletteRenderer',
  'goog.ui.emoji.ProgressiveEmojiPaletteRenderer'
]);
goog.addDependency('ui/emoji/popupemojipicker.js', ['goog.ui.emoji.PopupEmojiPicker'], [
  'goog.events.EventType',
  'goog.positioning.AnchoredPosition',
  'goog.positioning.Corner',
  'goog.ui.Component',
  'goog.ui.Popup',
  'goog.ui.emoji.EmojiPicker'
]);
goog.addDependency('ui/emoji/progressiveemojipaletterenderer.js', ['goog.ui.emoji.ProgressiveEmojiPaletteRenderer'], [
  'goog.style',
  'goog.ui.emoji.EmojiPaletteRenderer'
]);
goog.addDependency('ui/emoji/spriteinfo.js', ['goog.ui.emoji.SpriteInfo'], []);
goog.addDependency('ui/equation/arrowpalette.js', ['goog.ui.equation.ArrowPalette'], [
  'goog.math.Size',
  'goog.ui.equation.Palette'
]);
goog.addDependency('ui/equation/changeevent.js', ['goog.ui.equation.ChangeEvent'], ['goog.events.Event']);
goog.addDependency('ui/equation/comparisonpalette.js', ['goog.ui.equation.ComparisonPalette'], [
  'goog.math.Size',
  'goog.ui.equation.Palette'
]);
goog.addDependency('ui/equation/editorpane.js', ['goog.ui.equation.EditorPane'], [
  'goog.style',
  'goog.ui.Component'
]);
goog.addDependency('ui/equation/equationeditor.js', ['goog.ui.equation.EquationEditor'], [
  'goog.events',
  'goog.ui.Component',
  'goog.ui.TabBar',
  'goog.ui.equation.ImageRenderer',
  'goog.ui.equation.TexPane'
]);
goog.addDependency('ui/equation/equationeditordialog.js', ['goog.ui.equation.EquationEditorDialog'], [
  'goog.dom',
  'goog.dom.classes',
  'goog.ui.Dialog',
  'goog.ui.equation.EquationEditor',
  'goog.ui.equation.PaletteManager',
  'goog.ui.equation.TexEditor'
]);
goog.addDependency('ui/equation/greekpalette.js', ['goog.ui.equation.GreekPalette'], [
  'goog.math.Size',
  'goog.ui.equation.Palette'
]);
goog.addDependency('ui/equation/imagerenderer.js', ['goog.ui.equation.ImageRenderer'], [
  'goog.dom.TagName',
  'goog.dom.classes',
  'goog.string',
  'goog.uri.utils'
]);
goog.addDependency('ui/equation/mathpalette.js', ['goog.ui.equation.MathPalette'], [
  'goog.math.Size',
  'goog.ui.equation.Palette'
]);
goog.addDependency('ui/equation/menupalette.js', [
  'goog.ui.equation.MenuPalette',
  'goog.ui.equation.MenuPaletteRenderer'
], [
  'goog.math.Size',
  'goog.ui.PaletteRenderer',
  'goog.ui.equation.Palette',
  'goog.ui.equation.PaletteRenderer'
]);
goog.addDependency('ui/equation/palette.js', [
  'goog.ui.equation.Palette',
  'goog.ui.equation.PaletteEvent',
  'goog.ui.equation.PaletteRenderer'
], [
  'goog.dom',
  'goog.dom.TagName',
  'goog.events.Event',
  'goog.ui.Palette',
  'goog.ui.PaletteRenderer'
]);
goog.addDependency('ui/equation/palettemanager.js', ['goog.ui.equation.PaletteManager'], [
  'goog.Timer',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.ui.equation.ArrowPalette',
  'goog.ui.equation.ComparisonPalette',
  'goog.ui.equation.GreekPalette',
  'goog.ui.equation.MathPalette',
  'goog.ui.equation.MenuPalette',
  'goog.ui.equation.Palette',
  'goog.ui.equation.SymbolPalette'
]);
goog.addDependency('ui/equation/symbolpalette.js', ['goog.ui.equation.SymbolPalette'], [
  'goog.math.Size',
  'goog.ui.equation.Palette'
]);
goog.addDependency('ui/equation/texeditor.js', ['goog.ui.equation.TexEditor'], [
  'goog.ui.Component',
  'goog.ui.equation.ImageRenderer',
  'goog.ui.equation.TexPane'
]);
goog.addDependency('ui/equation/texpane.js', ['goog.ui.equation.TexPane'], [
  'goog.Timer',
  'goog.dom',
  'goog.dom.TagName',
  'goog.dom.selection',
  'goog.events',
  'goog.events.EventType',
  'goog.events.InputHandler',
  'goog.style',
  'goog.ui.equation.ChangeEvent',
  'goog.ui.equation.EditorPane',
  'goog.ui.equation.ImageRenderer',
  'goog.ui.equation.Palette',
  'goog.ui.equation.PaletteEvent'
]);
goog.addDependency('ui/filteredmenu.js', ['goog.ui.FilteredMenu'], [
  'goog.dom',
  'goog.events',
  'goog.events.EventType',
  'goog.events.InputHandler',
  'goog.events.KeyCodes',
  'goog.string',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.FilterObservingMenuItem',
  'goog.ui.Menu',
  'goog.userAgent'
]);
goog.addDependency('ui/filterobservingmenuitem.js', ['goog.ui.FilterObservingMenuItem'], [
  'goog.ui.FilterObservingMenuItemRenderer',
  'goog.ui.MenuItem',
  'goog.ui.registry'
]);
goog.addDependency('ui/filterobservingmenuitemrenderer.js', ['goog.ui.FilterObservingMenuItemRenderer'], ['goog.ui.MenuItemRenderer']);
goog.addDependency('ui/flatbuttonrenderer.js', ['goog.ui.FlatButtonRenderer'], [
  'goog.a11y.aria.Role',
  'goog.dom.classes',
  'goog.ui.Button',
  'goog.ui.ButtonRenderer',
  'goog.ui.INLINE_BLOCK_CLASSNAME',
  'goog.ui.registry'
]);
goog.addDependency('ui/flatmenubuttonrenderer.js', ['goog.ui.FlatMenuButtonRenderer'], [
  'goog.a11y.aria',
  'goog.a11y.aria.State',
  'goog.asserts',
  'goog.dom',
  'goog.string',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.FlatButtonRenderer',
  'goog.ui.INLINE_BLOCK_CLASSNAME',
  'goog.ui.Menu',
  'goog.ui.MenuButton',
  'goog.ui.MenuRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/formpost.js', ['goog.ui.FormPost'], [
  'goog.array',
  'goog.dom.TagName',
  'goog.string',
  'goog.string.StringBuffer',
  'goog.ui.Component'
]);
goog.addDependency('ui/gauge.js', [
  'goog.ui.Gauge',
  'goog.ui.GaugeColoredRange'
], [
  'goog.a11y.aria',
  'goog.asserts',
  'goog.events',
  'goog.fx.Animation',
  'goog.fx.Transition',
  'goog.fx.easing',
  'goog.graphics',
  'goog.graphics.Font',
  'goog.graphics.Path',
  'goog.graphics.SolidFill',
  'goog.math',
  'goog.ui.Component',
  'goog.ui.GaugeTheme'
]);
goog.addDependency('ui/gaugetheme.js', ['goog.ui.GaugeTheme'], [
  'goog.graphics.LinearGradient',
  'goog.graphics.SolidFill',
  'goog.graphics.Stroke'
]);
goog.addDependency('ui/hovercard.js', [
  'goog.ui.HoverCard',
  'goog.ui.HoverCard.EventType',
  'goog.ui.HoverCard.TriggerEvent'
], [
  'goog.array',
  'goog.dom',
  'goog.events',
  'goog.events.Event',
  'goog.events.EventType',
  'goog.ui.AdvancedTooltip',
  'goog.ui.PopupBase',
  'goog.ui.Tooltip'
]);
goog.addDependency('ui/hsvapalette.js', ['goog.ui.HsvaPalette'], [
  'goog.array',
  'goog.color.alpha',
  'goog.dom',
  'goog.dom.TagName',
  'goog.events',
  'goog.events.EventType',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.HsvPalette'
]);
goog.addDependency('ui/hsvpalette.js', ['goog.ui.HsvPalette'], [
  'goog.color',
  'goog.dom.TagName',
  'goog.events',
  'goog.events.EventType',
  'goog.events.InputHandler',
  'goog.style',
  'goog.style.bidi',
  'goog.ui.Component',
  'goog.userAgent'
]);
goog.addDependency('ui/idgenerator.js', ['goog.ui.IdGenerator'], []);
goog.addDependency('ui/idletimer.js', ['goog.ui.IdleTimer'], [
  'goog.Timer',
  'goog.events',
  'goog.events.EventTarget',
  'goog.structs.Set',
  'goog.ui.ActivityMonitor'
]);
goog.addDependency('ui/iframemask.js', ['goog.ui.IframeMask'], [
  'goog.Disposable',
  'goog.Timer',
  'goog.dom',
  'goog.dom.iframe',
  'goog.events.EventHandler',
  'goog.style'
]);
goog.addDependency('ui/imagelessbuttonrenderer.js', ['goog.ui.ImagelessButtonRenderer'], [
  'goog.dom.classes',
  'goog.ui.Button',
  'goog.ui.Component',
  'goog.ui.CustomButtonRenderer',
  'goog.ui.INLINE_BLOCK_CLASSNAME',
  'goog.ui.registry'
]);
goog.addDependency('ui/imagelessmenubuttonrenderer.js', ['goog.ui.ImagelessMenuButtonRenderer'], [
  'goog.dom',
  'goog.dom.TagName',
  'goog.dom.classes',
  'goog.ui.INLINE_BLOCK_CLASSNAME',
  'goog.ui.MenuButton',
  'goog.ui.MenuButtonRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/inputdatepicker.js', ['goog.ui.InputDatePicker'], [
  'goog.date.DateTime',
  'goog.dom',
  'goog.string',
  'goog.ui.Component',
  'goog.ui.DatePicker',
  'goog.ui.PopupBase',
  'goog.ui.PopupDatePicker'
]);
goog.addDependency('ui/itemevent.js', ['goog.ui.ItemEvent'], ['goog.events.Event']);
goog.addDependency('ui/keyboardshortcuthandler.js', [
  'goog.ui.KeyboardShortcutEvent',
  'goog.ui.KeyboardShortcutHandler',
  'goog.ui.KeyboardShortcutHandler.EventType'
], [
  'goog.Timer',
  'goog.events',
  'goog.events.Event',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.events.KeyNames',
  'goog.object',
  'goog.userAgent'
]);
goog.addDependency('ui/labelinput.js', ['goog.ui.LabelInput'], [
  'goog.Timer',
  'goog.a11y.aria',
  'goog.a11y.aria.State',
  'goog.asserts',
  'goog.dom',
  'goog.dom.classlist',
  'goog.events.EventHandler',
  'goog.events.EventType',
  'goog.ui.Component',
  'goog.userAgent'
]);
goog.addDependency('ui/linkbuttonrenderer.js', ['goog.ui.LinkButtonRenderer'], [
  'goog.ui.Button',
  'goog.ui.FlatButtonRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/media/flashobject.js', [
  'goog.ui.media.FlashObject',
  'goog.ui.media.FlashObject.ScriptAccessLevel',
  'goog.ui.media.FlashObject.Wmodes'
], [
  'goog.asserts',
  'goog.events.Event',
  'goog.events.EventHandler',
  'goog.events.EventType',
  'goog.log',
  'goog.object',
  'goog.string',
  'goog.structs.Map',
  'goog.style',
  'goog.ui.Component',
  'goog.userAgent',
  'goog.userAgent.flash'
]);
goog.addDependency('ui/media/flickr.js', [
  'goog.ui.media.FlickrSet',
  'goog.ui.media.FlickrSetModel'
], [
  'goog.ui.media.FlashObject',
  'goog.ui.media.Media',
  'goog.ui.media.MediaModel',
  'goog.ui.media.MediaRenderer'
]);
goog.addDependency('ui/media/googlevideo.js', [
  'goog.ui.media.GoogleVideo',
  'goog.ui.media.GoogleVideoModel'
], [
  'goog.string',
  'goog.ui.media.FlashObject',
  'goog.ui.media.Media',
  'goog.ui.media.MediaModel',
  'goog.ui.media.MediaRenderer'
]);
goog.addDependency('ui/media/media.js', [
  'goog.ui.media.Media',
  'goog.ui.media.MediaRenderer'
], [
  'goog.style',
  'goog.ui.Component',
  'goog.ui.Control',
  'goog.ui.ControlRenderer'
]);
goog.addDependency('ui/media/mediamodel.js', [
  'goog.ui.media.MediaModel',
  'goog.ui.media.MediaModel.Category',
  'goog.ui.media.MediaModel.Credit',
  'goog.ui.media.MediaModel.Credit.Role',
  'goog.ui.media.MediaModel.Credit.Scheme',
  'goog.ui.media.MediaModel.Medium',
  'goog.ui.media.MediaModel.MimeType',
  'goog.ui.media.MediaModel.Player',
  'goog.ui.media.MediaModel.SubTitle',
  'goog.ui.media.MediaModel.Thumbnail'
], ['goog.array']);
goog.addDependency('ui/media/mp3.js', ['goog.ui.media.Mp3'], [
  'goog.string',
  'goog.ui.media.FlashObject',
  'goog.ui.media.Media',
  'goog.ui.media.MediaRenderer'
]);
goog.addDependency('ui/media/photo.js', ['goog.ui.media.Photo'], [
  'goog.ui.media.Media',
  'goog.ui.media.MediaRenderer'
]);
goog.addDependency('ui/media/picasa.js', [
  'goog.ui.media.PicasaAlbum',
  'goog.ui.media.PicasaAlbumModel'
], [
  'goog.ui.media.FlashObject',
  'goog.ui.media.Media',
  'goog.ui.media.MediaModel',
  'goog.ui.media.MediaRenderer'
]);
goog.addDependency('ui/media/vimeo.js', [
  'goog.ui.media.Vimeo',
  'goog.ui.media.VimeoModel'
], [
  'goog.string',
  'goog.ui.media.FlashObject',
  'goog.ui.media.Media',
  'goog.ui.media.MediaModel',
  'goog.ui.media.MediaRenderer'
]);
goog.addDependency('ui/media/youtube.js', [
  'goog.ui.media.Youtube',
  'goog.ui.media.YoutubeModel'
], [
  'goog.string',
  'goog.ui.Component',
  'goog.ui.media.FlashObject',
  'goog.ui.media.Media',
  'goog.ui.media.MediaModel',
  'goog.ui.media.MediaRenderer'
]);
goog.addDependency('ui/menu.js', [
  'goog.ui.Menu',
  'goog.ui.Menu.EventType'
], [
  'goog.math.Coordinate',
  'goog.string',
  'goog.style',
  'goog.ui.Component.EventType',
  'goog.ui.Component.State',
  'goog.ui.Container',
  'goog.ui.Container.Orientation',
  'goog.ui.MenuHeader',
  'goog.ui.MenuItem',
  'goog.ui.MenuRenderer',
  'goog.ui.MenuSeparator'
]);
goog.addDependency('ui/menubar.js', ['goog.ui.menuBar'], [
  'goog.ui.Container',
  'goog.ui.MenuBarRenderer'
]);
goog.addDependency('ui/menubardecorator.js', ['goog.ui.menuBarDecorator'], [
  'goog.ui.MenuBarRenderer',
  'goog.ui.menuBar',
  'goog.ui.registry'
]);
goog.addDependency('ui/menubarrenderer.js', ['goog.ui.MenuBarRenderer'], [
  'goog.a11y.aria.Role',
  'goog.ui.Container',
  'goog.ui.ContainerRenderer'
]);
goog.addDependency('ui/menubase.js', ['goog.ui.MenuBase'], [
  'goog.events.EventHandler',
  'goog.events.EventType',
  'goog.events.KeyHandler',
  'goog.ui.Popup'
]);
goog.addDependency('ui/menubutton.js', ['goog.ui.MenuButton'], [
  'goog.Timer',
  'goog.a11y.aria',
  'goog.a11y.aria.State',
  'goog.asserts',
  'goog.dom',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.events.KeyHandler',
  'goog.math.Box',
  'goog.math.Rect',
  'goog.positioning',
  'goog.positioning.Corner',
  'goog.positioning.MenuAnchoredPosition',
  'goog.positioning.Overflow',
  'goog.style',
  'goog.ui.Button',
  'goog.ui.Component',
  'goog.ui.Menu',
  'goog.ui.MenuButtonRenderer',
  'goog.ui.registry',
  'goog.userAgent',
  'goog.userAgent.product'
]);
goog.addDependency('ui/menubuttonrenderer.js', ['goog.ui.MenuButtonRenderer'], [
  'goog.a11y.aria',
  'goog.a11y.aria.State',
  'goog.asserts',
  'goog.dom',
  'goog.string',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.CustomButtonRenderer',
  'goog.ui.INLINE_BLOCK_CLASSNAME',
  'goog.ui.Menu',
  'goog.ui.MenuRenderer',
  'goog.userAgent'
]);
goog.addDependency('ui/menuheader.js', ['goog.ui.MenuHeader'], [
  'goog.ui.Component',
  'goog.ui.Control',
  'goog.ui.MenuHeaderRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/menuheaderrenderer.js', ['goog.ui.MenuHeaderRenderer'], ['goog.ui.ControlRenderer']);
goog.addDependency('ui/menuitem.js', ['goog.ui.MenuItem'], [
  'goog.array',
  'goog.dom',
  'goog.dom.classes',
  'goog.math.Coordinate',
  'goog.string',
  'goog.ui.Component',
  'goog.ui.Control',
  'goog.ui.MenuItemRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/menuitemrenderer.js', ['goog.ui.MenuItemRenderer'], [
  'goog.a11y.aria',
  'goog.a11y.aria.Role',
  'goog.dom',
  'goog.dom.classes',
  'goog.ui.Component',
  'goog.ui.ControlRenderer'
]);
goog.addDependency('ui/menurenderer.js', ['goog.ui.MenuRenderer'], [
  'goog.a11y.aria',
  'goog.a11y.aria.Role',
  'goog.a11y.aria.State',
  'goog.asserts',
  'goog.dom',
  'goog.ui.ContainerRenderer',
  'goog.ui.Separator'
]);
goog.addDependency('ui/menuseparator.js', ['goog.ui.MenuSeparator'], [
  'goog.ui.MenuSeparatorRenderer',
  'goog.ui.Separator',
  'goog.ui.registry'
]);
goog.addDependency('ui/menuseparatorrenderer.js', ['goog.ui.MenuSeparatorRenderer'], [
  'goog.dom',
  'goog.dom.classes',
  'goog.ui.ControlContent',
  'goog.ui.ControlRenderer'
]);
goog.addDependency('ui/mockactivitymonitor.js', ['goog.ui.MockActivityMonitor'], [
  'goog.events.EventType',
  'goog.ui.ActivityMonitor'
]);
goog.addDependency('ui/mockactivitymonitor_test.js', ['goog.ui.MockActivityMonitorTest'], [
  'goog.events',
  'goog.functions',
  'goog.testing.jsunit',
  'goog.testing.recordFunction',
  'goog.ui.ActivityMonitor',
  'goog.ui.MockActivityMonitor'
]);
goog.addDependency('ui/modalpopup.js', ['goog.ui.ModalPopup'], [
  'goog.Timer',
  'goog.a11y.aria',
  'goog.a11y.aria.State',
  'goog.asserts',
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.TagName',
  'goog.dom.classes',
  'goog.dom.iframe',
  'goog.events',
  'goog.events.EventType',
  'goog.events.FocusHandler',
  'goog.fx.Transition',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.PopupBase',
  'goog.userAgent'
]);
goog.addDependency('ui/nativebuttonrenderer.js', ['goog.ui.NativeButtonRenderer'], [
  'goog.dom.classes',
  'goog.events.EventType',
  'goog.ui.ButtonRenderer',
  'goog.ui.Component'
]);
goog.addDependency('ui/offlineinstalldialog.js', [
  'goog.ui.OfflineInstallDialog',
  'goog.ui.OfflineInstallDialog.ButtonKeyType',
  'goog.ui.OfflineInstallDialog.EnableScreen',
  'goog.ui.OfflineInstallDialog.InstallScreen',
  'goog.ui.OfflineInstallDialog.InstallingGearsScreen',
  'goog.ui.OfflineInstallDialog.ScreenType',
  'goog.ui.OfflineInstallDialog.UpgradeScreen',
  'goog.ui.OfflineInstallDialogScreen'
], [
  'goog.Disposable',
  'goog.dom.classes',
  'goog.gears',
  'goog.string',
  'goog.string.StringBuffer',
  'goog.ui.Dialog',
  'goog.window'
]);
goog.addDependency('ui/offlinestatuscard.js', [
  'goog.ui.OfflineStatusCard',
  'goog.ui.OfflineStatusCard.EventType'
], [
  'goog.dom',
  'goog.events.EventType',
  'goog.gears.StatusType',
  'goog.structs.Map',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.ProgressBar'
]);
goog.addDependency('ui/offlinestatuscomponent.js', [
  'goog.ui.OfflineStatusComponent',
  'goog.ui.OfflineStatusComponent.StatusClassNames'
], [
  'goog.dom.classes',
  'goog.events.EventType',
  'goog.gears.StatusType',
  'goog.positioning.AnchoredPosition',
  'goog.positioning.Corner',
  'goog.positioning.Overflow',
  'goog.ui.Component',
  'goog.ui.OfflineStatusCard',
  'goog.ui.Popup'
]);
goog.addDependency('ui/option.js', ['goog.ui.Option'], [
  'goog.ui.Component',
  'goog.ui.MenuItem',
  'goog.ui.registry'
]);
goog.addDependency('ui/palette.js', ['goog.ui.Palette'], [
  'goog.array',
  'goog.dom',
  'goog.events',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.math.Size',
  'goog.ui.Component',
  'goog.ui.Control',
  'goog.ui.PaletteRenderer',
  'goog.ui.SelectionModel'
]);
goog.addDependency('ui/paletterenderer.js', ['goog.ui.PaletteRenderer'], [
  'goog.a11y.aria',
  'goog.a11y.aria.Role',
  'goog.a11y.aria.State',
  'goog.array',
  'goog.dom',
  'goog.dom.NodeIterator',
  'goog.dom.NodeType',
  'goog.dom.TagName',
  'goog.dom.classes',
  'goog.iter',
  'goog.style',
  'goog.ui.ControlRenderer',
  'goog.userAgent'
]);
goog.addDependency('ui/plaintextspellchecker.js', ['goog.ui.PlainTextSpellChecker'], [
  'goog.Timer',
  'goog.a11y.aria',
  'goog.asserts',
  'goog.dom',
  'goog.events.EventHandler',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.events.KeyHandler',
  'goog.spell.SpellCheck',
  'goog.style',
  'goog.ui.AbstractSpellChecker',
  'goog.ui.Component',
  'goog.userAgent'
]);
goog.addDependency('ui/popup.js', [
  'goog.ui.Popup',
  'goog.ui.Popup.AbsolutePosition',
  'goog.ui.Popup.AnchoredPosition',
  'goog.ui.Popup.AnchoredViewPortPosition',
  'goog.ui.Popup.ClientPosition',
  'goog.ui.Popup.Corner',
  'goog.ui.Popup.Overflow',
  'goog.ui.Popup.ViewPortClientPosition',
  'goog.ui.Popup.ViewPortPosition'
], [
  'goog.math.Box',
  'goog.positioning.AbsolutePosition',
  'goog.positioning.AnchoredPosition',
  'goog.positioning.AnchoredViewportPosition',
  'goog.positioning.ClientPosition',
  'goog.positioning.Corner',
  'goog.positioning.Overflow',
  'goog.positioning.ViewportClientPosition',
  'goog.positioning.ViewportPosition',
  'goog.style',
  'goog.ui.PopupBase'
]);
goog.addDependency('ui/popupbase.js', [
  'goog.ui.PopupBase',
  'goog.ui.PopupBase.EventType',
  'goog.ui.PopupBase.Type'
], [
  'goog.Timer',
  'goog.dom',
  'goog.events',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.fx.Transition',
  'goog.style',
  'goog.userAgent'
]);
goog.addDependency('ui/popupcolorpicker.js', ['goog.ui.PopupColorPicker'], [
  'goog.dom.classes',
  'goog.events.EventType',
  'goog.positioning.AnchoredPosition',
  'goog.positioning.Corner',
  'goog.ui.ColorPicker',
  'goog.ui.Component',
  'goog.ui.Popup'
]);
goog.addDependency('ui/popupdatepicker.js', ['goog.ui.PopupDatePicker'], [
  'goog.events.EventType',
  'goog.positioning.AnchoredPosition',
  'goog.positioning.Corner',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.DatePicker',
  'goog.ui.Popup',
  'goog.ui.PopupBase'
]);
goog.addDependency('ui/popupmenu.js', ['goog.ui.PopupMenu'], [
  'goog.events.EventType',
  'goog.positioning.AnchoredViewportPosition',
  'goog.positioning.Corner',
  'goog.positioning.MenuAnchoredPosition',
  'goog.positioning.ViewportClientPosition',
  'goog.structs',
  'goog.structs.Map',
  'goog.style',
  'goog.ui.Component.EventType',
  'goog.ui.Menu',
  'goog.ui.PopupBase',
  'goog.userAgent'
]);
goog.addDependency('ui/progressbar.js', [
  'goog.ui.ProgressBar',
  'goog.ui.ProgressBar.Orientation'
], [
  'goog.a11y.aria',
  'goog.asserts',
  'goog.dom',
  'goog.dom.classes',
  'goog.events',
  'goog.events.EventType',
  'goog.ui.Component',
  'goog.ui.RangeModel',
  'goog.userAgent'
]);
goog.addDependency('ui/prompt.js', ['goog.ui.Prompt'], [
  'goog.Timer',
  'goog.dom',
  'goog.events',
  'goog.events.EventType',
  'goog.functions',
  'goog.ui.Component',
  'goog.ui.Dialog',
  'goog.userAgent'
]);
goog.addDependency('ui/rangemodel.js', ['goog.ui.RangeModel'], [
  'goog.events.EventTarget',
  'goog.ui.Component'
]);
goog.addDependency('ui/ratings.js', [
  'goog.ui.Ratings',
  'goog.ui.Ratings.EventType'
], [
  'goog.a11y.aria',
  'goog.a11y.aria.Role',
  'goog.a11y.aria.State',
  'goog.asserts',
  'goog.dom.classes',
  'goog.events.EventType',
  'goog.ui.Component'
]);
goog.addDependency('ui/registry.js', ['goog.ui.registry'], ['goog.dom.classes']);
goog.addDependency('ui/richtextspellchecker.js', ['goog.ui.RichTextSpellChecker'], [
  'goog.Timer',
  'goog.dom',
  'goog.dom.NodeType',
  'goog.events',
  'goog.events.EventType',
  'goog.spell.SpellCheck',
  'goog.string.StringBuffer',
  'goog.ui.AbstractSpellChecker'
]);
goog.addDependency('ui/roundedpanel.js', [
  'goog.ui.BaseRoundedPanel',
  'goog.ui.CssRoundedPanel',
  'goog.ui.GraphicsRoundedPanel',
  'goog.ui.RoundedPanel',
  'goog.ui.RoundedPanel.Corner'
], [
  'goog.dom',
  'goog.dom.classes',
  'goog.graphics',
  'goog.graphics.Path',
  'goog.graphics.SolidFill',
  'goog.graphics.Stroke',
  'goog.math',
  'goog.math.Coordinate',
  'goog.style',
  'goog.ui.Component',
  'goog.userAgent'
]);
goog.addDependency('ui/roundedtabrenderer.js', ['goog.ui.RoundedTabRenderer'], [
  'goog.dom',
  'goog.ui.Tab',
  'goog.ui.TabBar',
  'goog.ui.TabRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/scrollfloater.js', [
  'goog.ui.ScrollFloater',
  'goog.ui.ScrollFloater.EventType'
], [
  'goog.array',
  'goog.dom',
  'goog.dom.classes',
  'goog.events.EventType',
  'goog.style',
  'goog.ui.Component',
  'goog.userAgent'
]);
goog.addDependency('ui/select.js', ['goog.ui.Select'], [
  'goog.a11y.aria.Role',
  'goog.events.EventType',
  'goog.ui.Component',
  'goog.ui.MenuButton',
  'goog.ui.MenuItem',
  'goog.ui.SelectionModel',
  'goog.ui.registry'
]);
goog.addDependency('ui/selectionmenubutton.js', [
  'goog.ui.SelectionMenuButton',
  'goog.ui.SelectionMenuButton.SelectionState'
], [
  'goog.events.EventType',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.MenuButton',
  'goog.ui.MenuItem',
  'goog.ui.registry'
]);
goog.addDependency('ui/selectionmodel.js', ['goog.ui.SelectionModel'], [
  'goog.array',
  'goog.events.EventTarget',
  'goog.events.EventType'
]);
goog.addDependency('ui/separator.js', ['goog.ui.Separator'], [
  'goog.a11y.aria',
  'goog.asserts',
  'goog.ui.Component',
  'goog.ui.Control',
  'goog.ui.MenuSeparatorRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/serverchart.js', [
  'goog.ui.ServerChart',
  'goog.ui.ServerChart.AxisDisplayType',
  'goog.ui.ServerChart.ChartType',
  'goog.ui.ServerChart.EncodingType',
  'goog.ui.ServerChart.Event',
  'goog.ui.ServerChart.LegendPosition',
  'goog.ui.ServerChart.MaximumValue',
  'goog.ui.ServerChart.MultiAxisAlignment',
  'goog.ui.ServerChart.MultiAxisType',
  'goog.ui.ServerChart.UriParam',
  'goog.ui.ServerChart.UriTooLongEvent'
], [
  'goog.Uri',
  'goog.array',
  'goog.asserts',
  'goog.events.Event',
  'goog.string',
  'goog.ui.Component'
]);
goog.addDependency('ui/slider.js', [
  'goog.ui.Slider',
  'goog.ui.Slider.Orientation'
], [
  'goog.a11y.aria',
  'goog.a11y.aria.Role',
  'goog.dom',
  'goog.ui.SliderBase'
]);
goog.addDependency('ui/sliderbase.js', [
  'goog.ui.SliderBase',
  'goog.ui.SliderBase.AnimationFactory',
  'goog.ui.SliderBase.Orientation'
], [
  'goog.Timer',
  'goog.a11y.aria',
  'goog.a11y.aria.Role',
  'goog.a11y.aria.State',
  'goog.array',
  'goog.asserts',
  'goog.dom',
  'goog.dom.classes',
  'goog.events',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.events.KeyHandler',
  'goog.events.MouseWheelHandler',
  'goog.fx.AnimationParallelQueue',
  'goog.fx.Dragger',
  'goog.fx.Transition',
  'goog.fx.dom.ResizeHeight',
  'goog.fx.dom.ResizeWidth',
  'goog.fx.dom.Slide',
  'goog.math',
  'goog.math.Coordinate',
  'goog.style',
  'goog.style.bidi',
  'goog.ui.Component',
  'goog.ui.RangeModel'
]);
goog.addDependency('ui/splitbehavior.js', [
  'goog.ui.SplitBehavior',
  'goog.ui.SplitBehavior.DefaultHandlers'
], [
  'goog.Disposable',
  'goog.dispose',
  'goog.dom',
  'goog.dom.NodeType',
  'goog.dom.classes',
  'goog.events.EventHandler',
  'goog.ui.ButtonSide',
  'goog.ui.Component',
  'goog.ui.decorate',
  'goog.ui.registry'
]);
goog.addDependency('ui/splitpane.js', [
  'goog.ui.SplitPane',
  'goog.ui.SplitPane.Orientation'
], [
  'goog.dom',
  'goog.dom.classes',
  'goog.events.EventType',
  'goog.fx.Dragger',
  'goog.math.Rect',
  'goog.math.Size',
  'goog.style',
  'goog.ui.Component',
  'goog.userAgent'
]);
goog.addDependency('ui/style/app/buttonrenderer.js', ['goog.ui.style.app.ButtonRenderer'], [
  'goog.dom.classes',
  'goog.ui.Button',
  'goog.ui.CustomButtonRenderer',
  'goog.ui.INLINE_BLOCK_CLASSNAME',
  'goog.ui.registry'
]);
goog.addDependency('ui/style/app/menubuttonrenderer.js', ['goog.ui.style.app.MenuButtonRenderer'], [
  'goog.a11y.aria.Role',
  'goog.array',
  'goog.dom',
  'goog.style',
  'goog.ui.Menu',
  'goog.ui.MenuRenderer',
  'goog.ui.style.app.ButtonRenderer'
]);
goog.addDependency('ui/style/app/primaryactionbuttonrenderer.js', ['goog.ui.style.app.PrimaryActionButtonRenderer'], [
  'goog.ui.Button',
  'goog.ui.registry',
  'goog.ui.style.app.ButtonRenderer'
]);
goog.addDependency('ui/submenu.js', ['goog.ui.SubMenu'], [
  'goog.Timer',
  'goog.dom',
  'goog.dom.classes',
  'goog.events.KeyCodes',
  'goog.positioning.AnchoredViewportPosition',
  'goog.positioning.Corner',
  'goog.style',
  'goog.ui.Component',
  'goog.ui.Menu',
  'goog.ui.MenuItem',
  'goog.ui.SubMenuRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/submenurenderer.js', ['goog.ui.SubMenuRenderer'], [
  'goog.a11y.aria',
  'goog.a11y.aria.State',
  'goog.asserts',
  'goog.dom',
  'goog.dom.classes',
  'goog.style',
  'goog.ui.Menu',
  'goog.ui.MenuItemRenderer'
]);
goog.addDependency('ui/tab.js', ['goog.ui.Tab'], [
  'goog.ui.Component',
  'goog.ui.Control',
  'goog.ui.TabRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/tabbar.js', [
  'goog.ui.TabBar',
  'goog.ui.TabBar.Location'
], [
  'goog.ui.Component.EventType',
  'goog.ui.Container',
  'goog.ui.Container.Orientation',
  'goog.ui.Tab',
  'goog.ui.TabBarRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/tabbarrenderer.js', ['goog.ui.TabBarRenderer'], [
  'goog.a11y.aria.Role',
  'goog.object',
  'goog.ui.ContainerRenderer'
]);
goog.addDependency('ui/tablesorter.js', [
  'goog.ui.TableSorter',
  'goog.ui.TableSorter.EventType'
], [
  'goog.array',
  'goog.dom',
  'goog.dom.TagName',
  'goog.dom.classes',
  'goog.events.EventType',
  'goog.functions',
  'goog.ui.Component'
]);
goog.addDependency('ui/tabpane.js', [
  'goog.ui.TabPane',
  'goog.ui.TabPane.Events',
  'goog.ui.TabPane.TabLocation',
  'goog.ui.TabPane.TabPage',
  'goog.ui.TabPaneEvent'
], [
  'goog.dom',
  'goog.dom.classes',
  'goog.events',
  'goog.events.Event',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.style'
]);
goog.addDependency('ui/tabrenderer.js', ['goog.ui.TabRenderer'], [
  'goog.a11y.aria.Role',
  'goog.ui.Component',
  'goog.ui.ControlRenderer'
]);
goog.addDependency('ui/textarea.js', [
  'goog.ui.Textarea',
  'goog.ui.Textarea.EventType'
], [
  'goog.dom',
  'goog.events.EventType',
  'goog.style',
  'goog.ui.Control',
  'goog.ui.TextareaRenderer',
  'goog.userAgent'
]);
goog.addDependency('ui/textarearenderer.js', ['goog.ui.TextareaRenderer'], [
  'goog.dom.TagName',
  'goog.ui.Component',
  'goog.ui.ControlRenderer'
]);
goog.addDependency('ui/togglebutton.js', ['goog.ui.ToggleButton'], [
  'goog.ui.Button',
  'goog.ui.Component',
  'goog.ui.CustomButtonRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/toolbar.js', ['goog.ui.Toolbar'], [
  'goog.ui.Container',
  'goog.ui.ToolbarRenderer'
]);
goog.addDependency('ui/toolbarbutton.js', ['goog.ui.ToolbarButton'], [
  'goog.ui.Button',
  'goog.ui.ToolbarButtonRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/toolbarbuttonrenderer.js', ['goog.ui.ToolbarButtonRenderer'], ['goog.ui.CustomButtonRenderer']);
goog.addDependency('ui/toolbarcolormenubutton.js', ['goog.ui.ToolbarColorMenuButton'], [
  'goog.ui.ColorMenuButton',
  'goog.ui.ToolbarColorMenuButtonRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/toolbarcolormenubuttonrenderer.js', ['goog.ui.ToolbarColorMenuButtonRenderer'], [
  'goog.dom.classes',
  'goog.ui.ColorMenuButtonRenderer',
  'goog.ui.MenuButtonRenderer',
  'goog.ui.ToolbarMenuButtonRenderer'
]);
goog.addDependency('ui/toolbarmenubutton.js', ['goog.ui.ToolbarMenuButton'], [
  'goog.ui.MenuButton',
  'goog.ui.ToolbarMenuButtonRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/toolbarmenubuttonrenderer.js', ['goog.ui.ToolbarMenuButtonRenderer'], ['goog.ui.MenuButtonRenderer']);
goog.addDependency('ui/toolbarrenderer.js', ['goog.ui.ToolbarRenderer'], [
  'goog.a11y.aria.Role',
  'goog.ui.Container',
  'goog.ui.ContainerRenderer',
  'goog.ui.Separator',
  'goog.ui.ToolbarSeparatorRenderer'
]);
goog.addDependency('ui/toolbarselect.js', ['goog.ui.ToolbarSelect'], [
  'goog.ui.Select',
  'goog.ui.ToolbarMenuButtonRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/toolbarseparator.js', ['goog.ui.ToolbarSeparator'], [
  'goog.ui.Separator',
  'goog.ui.ToolbarSeparatorRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/toolbarseparatorrenderer.js', ['goog.ui.ToolbarSeparatorRenderer'], [
  'goog.dom.classes',
  'goog.ui.INLINE_BLOCK_CLASSNAME',
  'goog.ui.MenuSeparatorRenderer'
]);
goog.addDependency('ui/toolbartogglebutton.js', ['goog.ui.ToolbarToggleButton'], [
  'goog.ui.ToggleButton',
  'goog.ui.ToolbarButtonRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/tooltip.js', [
  'goog.ui.Tooltip',
  'goog.ui.Tooltip.CursorTooltipPosition',
  'goog.ui.Tooltip.ElementTooltipPosition',
  'goog.ui.Tooltip.State'
], [
  'goog.Timer',
  'goog.array',
  'goog.dom',
  'goog.events',
  'goog.events.EventType',
  'goog.math.Box',
  'goog.math.Coordinate',
  'goog.positioning',
  'goog.positioning.AnchoredPosition',
  'goog.positioning.Corner',
  'goog.positioning.Overflow',
  'goog.positioning.OverflowStatus',
  'goog.positioning.ViewportPosition',
  'goog.structs.Set',
  'goog.style',
  'goog.ui.Popup',
  'goog.ui.PopupBase'
]);
goog.addDependency('ui/tree/basenode.js', [
  'goog.ui.tree.BaseNode',
  'goog.ui.tree.BaseNode.EventType'
], [
  'goog.Timer',
  'goog.a11y.aria',
  'goog.asserts',
  'goog.events.KeyCodes',
  'goog.string',
  'goog.string.StringBuffer',
  'goog.style',
  'goog.ui.Component',
  'goog.userAgent'
]);
goog.addDependency('ui/tree/treecontrol.js', ['goog.ui.tree.TreeControl'], [
  'goog.a11y.aria',
  'goog.asserts',
  'goog.dom.classes',
  'goog.events.EventType',
  'goog.events.FocusHandler',
  'goog.events.KeyHandler',
  'goog.log',
  'goog.ui.tree.BaseNode',
  'goog.ui.tree.TreeNode',
  'goog.ui.tree.TypeAhead',
  'goog.userAgent'
]);
goog.addDependency('ui/tree/treenode.js', ['goog.ui.tree.TreeNode'], ['goog.ui.tree.BaseNode']);
goog.addDependency('ui/tree/typeahead.js', [
  'goog.ui.tree.TypeAhead',
  'goog.ui.tree.TypeAhead.Offset'
], [
  'goog.array',
  'goog.events.KeyCodes',
  'goog.string',
  'goog.structs.Trie'
]);
goog.addDependency('ui/tristatemenuitem.js', [
  'goog.ui.TriStateMenuItem',
  'goog.ui.TriStateMenuItem.State'
], [
  'goog.dom.classes',
  'goog.ui.Component',
  'goog.ui.MenuItem',
  'goog.ui.TriStateMenuItemRenderer',
  'goog.ui.registry'
]);
goog.addDependency('ui/tristatemenuitemrenderer.js', ['goog.ui.TriStateMenuItemRenderer'], [
  'goog.dom.classes',
  'goog.ui.MenuItemRenderer'
]);
goog.addDependency('ui/twothumbslider.js', ['goog.ui.TwoThumbSlider'], [
  'goog.a11y.aria',
  'goog.a11y.aria.Role',
  'goog.dom',
  'goog.ui.SliderBase'
]);
goog.addDependency('ui/zippy.js', [
  'goog.ui.Zippy',
  'goog.ui.Zippy.Events',
  'goog.ui.ZippyEvent'
], [
  'goog.a11y.aria',
  'goog.a11y.aria.Role',
  'goog.a11y.aria.State',
  'goog.dom',
  'goog.dom.classes',
  'goog.events.Event',
  'goog.events.EventHandler',
  'goog.events.EventTarget',
  'goog.events.EventType',
  'goog.events.KeyCodes',
  'goog.style'
]);
goog.addDependency('uri/uri.js', [
  'goog.Uri',
  'goog.Uri.QueryData'
], [
  'goog.array',
  'goog.string',
  'goog.structs',
  'goog.structs.Map',
  'goog.uri.utils',
  'goog.uri.utils.ComponentIndex',
  'goog.uri.utils.StandardQueryParam'
]);
goog.addDependency('uri/uri_test.js', ['goog.UriTest'], [
  'goog.Uri',
  'goog.testing.jsunit'
]);
goog.addDependency('uri/utils.js', [
  'goog.uri.utils',
  'goog.uri.utils.ComponentIndex',
  'goog.uri.utils.QueryArray',
  'goog.uri.utils.QueryValue',
  'goog.uri.utils.StandardQueryParam'
], [
  'goog.asserts',
  'goog.string',
  'goog.userAgent'
]);
goog.addDependency('useragent/adobereader.js', ['goog.userAgent.adobeReader'], [
  'goog.string',
  'goog.userAgent'
]);
goog.addDependency('useragent/flash.js', ['goog.userAgent.flash'], ['goog.string']);
goog.addDependency('useragent/iphoto.js', ['goog.userAgent.iphoto'], [
  'goog.string',
  'goog.userAgent'
]);
goog.addDependency('useragent/jscript.js', ['goog.userAgent.jscript'], ['goog.string']);
goog.addDependency('useragent/picasa.js', ['goog.userAgent.picasa'], [
  'goog.string',
  'goog.userAgent'
]);
goog.addDependency('useragent/platform.js', ['goog.userAgent.platform'], ['goog.userAgent']);
goog.addDependency('useragent/product.js', ['goog.userAgent.product'], ['goog.userAgent']);
goog.addDependency('useragent/product_isversion.js', ['goog.userAgent.product.isVersion'], ['goog.userAgent.product']);
goog.addDependency('useragent/useragent.js', ['goog.userAgent'], ['goog.string']);
goog.addDependency('vec/float32array.js', ['goog.vec.Float32Array'], []);
goog.addDependency('vec/float64array.js', ['goog.vec.Float64Array'], []);
goog.addDependency('vec/mat3.js', ['goog.vec.Mat3'], ['goog.vec']);
goog.addDependency('vec/mat3d.js', [
  'goog.vec.mat3d',
  'goog.vec.mat3d.Type'
], ['goog.vec']);
goog.addDependency('vec/mat3f.js', [
  'goog.vec.mat3f',
  'goog.vec.mat3f.Type'
], ['goog.vec']);
goog.addDependency('vec/mat4.js', ['goog.vec.Mat4'], [
  'goog.vec',
  'goog.vec.Vec3',
  'goog.vec.Vec4'
]);
goog.addDependency('vec/mat4d.js', [
  'goog.vec.mat4d',
  'goog.vec.mat4d.Type'
], [
  'goog.vec',
  'goog.vec.vec3d',
  'goog.vec.vec4d'
]);
goog.addDependency('vec/mat4f.js', [
  'goog.vec.mat4f',
  'goog.vec.mat4f.Type'
], [
  'goog.vec',
  'goog.vec.vec3f',
  'goog.vec.vec4f'
]);
goog.addDependency('vec/matrix3.js', ['goog.vec.Matrix3'], []);
goog.addDependency('vec/matrix4.js', ['goog.vec.Matrix4'], [
  'goog.vec',
  'goog.vec.Vec3',
  'goog.vec.Vec4'
]);
goog.addDependency('vec/quaternion.js', ['goog.vec.Quaternion'], [
  'goog.vec',
  'goog.vec.Vec3',
  'goog.vec.Vec4'
]);
goog.addDependency('vec/ray.js', ['goog.vec.Ray'], ['goog.vec.Vec3']);
goog.addDependency('vec/vec.js', [
  'goog.vec',
  'goog.vec.AnyType',
  'goog.vec.ArrayType',
  'goog.vec.Float32',
  'goog.vec.Float64',
  'goog.vec.Number'
], [
  'goog.vec.Float32Array',
  'goog.vec.Float64Array'
]);
goog.addDependency('vec/vec2.js', ['goog.vec.Vec2'], ['goog.vec']);
goog.addDependency('vec/vec2d.js', [
  'goog.vec.vec2d',
  'goog.vec.vec2d.Type'
], ['goog.vec']);
goog.addDependency('vec/vec2f.js', [
  'goog.vec.vec2f',
  'goog.vec.vec2f.Type'
], ['goog.vec']);
goog.addDependency('vec/vec3.js', ['goog.vec.Vec3'], ['goog.vec']);
goog.addDependency('vec/vec3d.js', [
  'goog.vec.vec3d',
  'goog.vec.vec3d.Type'
], ['goog.vec']);
goog.addDependency('vec/vec3f.js', [
  'goog.vec.vec3f',
  'goog.vec.vec3f.Type'
], ['goog.vec']);
goog.addDependency('vec/vec4.js', ['goog.vec.Vec4'], ['goog.vec']);
goog.addDependency('vec/vec4d.js', [
  'goog.vec.vec4d',
  'goog.vec.vec4d.Type'
], ['goog.vec']);
goog.addDependency('vec/vec4f.js', [
  'goog.vec.vec4f',
  'goog.vec.vec4f.Type'
], ['goog.vec']);
goog.addDependency('webgl/webgl.js', ['goog.webgl'], []);
goog.addDependency('window/window.js', ['goog.window'], [
  'goog.string',
  'goog.userAgent'
]);
goog.provide('goog.string');
goog.provide('goog.string.Unicode');
goog.string.Unicode = { NBSP: '\xa0' };
goog.string.startsWith = function (str, prefix) {
  return str.lastIndexOf(prefix, 0) == 0;
};
goog.string.endsWith = function (str, suffix) {
  var l = str.length - suffix.length;
  return l >= 0 && str.indexOf(suffix, l) == l;
};
goog.string.caseInsensitiveStartsWith = function (str, prefix) {
  return goog.string.caseInsensitiveCompare(prefix, str.substr(0, prefix.length)) == 0;
};
goog.string.caseInsensitiveEndsWith = function (str, suffix) {
  return goog.string.caseInsensitiveCompare(suffix, str.substr(str.length - suffix.length, suffix.length)) == 0;
};
goog.string.caseInsensitiveEquals = function (str1, str2) {
  return str1.toLowerCase() == str2.toLowerCase();
};
goog.string.subs = function (str, var_args) {
  var splitParts = str.split('%s');
  var returnString = '';
  var subsArguments = Array.prototype.slice.call(arguments, 1);
  while (subsArguments.length && splitParts.length > 1) {
    returnString += splitParts.shift() + subsArguments.shift();
  }
  return returnString + splitParts.join('%s');
};
goog.string.collapseWhitespace = function (str) {
  return str.replace(/[\s\xa0]+/g, ' ').replace(/^\s+|\s+$/g, '');
};
goog.string.isEmpty = function (str) {
  return /^[\s\xa0]*$/.test(str);
};
goog.string.isEmptySafe = function (str) {
  return goog.string.isEmpty(goog.string.makeSafe(str));
};
goog.string.isBreakingWhitespace = function (str) {
  return !/[^\t\n\r ]/.test(str);
};
goog.string.isAlpha = function (str) {
  return !/[^a-zA-Z]/.test(str);
};
goog.string.isNumeric = function (str) {
  return !/[^0-9]/.test(str);
};
goog.string.isAlphaNumeric = function (str) {
  return !/[^a-zA-Z0-9]/.test(str);
};
goog.string.isSpace = function (ch) {
  return ch == ' ';
};
goog.string.isUnicodeChar = function (ch) {
  return ch.length == 1 && ch >= ' ' && ch <= '~' || ch >= '\x80' && ch <= '\ufffd';
};
goog.string.stripNewlines = function (str) {
  return str.replace(/(\r\n|\r|\n)+/g, ' ');
};
goog.string.canonicalizeNewlines = function (str) {
  return str.replace(/(\r\n|\r|\n)/g, '\n');
};
goog.string.normalizeWhitespace = function (str) {
  return str.replace(/\xa0|\s/g, ' ');
};
goog.string.normalizeSpaces = function (str) {
  return str.replace(/\xa0|[ \t]+/g, ' ');
};
goog.string.collapseBreakingSpaces = function (str) {
  return str.replace(/[\t\r\n ]+/g, ' ').replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, '');
};
goog.string.trim = function (str) {
  return str.replace(/^[\s\xa0]+|[\s\xa0]+$/g, '');
};
goog.string.trimLeft = function (str) {
  return str.replace(/^[\s\xa0]+/, '');
};
goog.string.trimRight = function (str) {
  return str.replace(/[\s\xa0]+$/, '');
};
goog.string.caseInsensitiveCompare = function (str1, str2) {
  var test1 = String(str1).toLowerCase();
  var test2 = String(str2).toLowerCase();
  if (test1 < test2) {
    return -1;
  } else if (test1 == test2) {
    return 0;
  } else {
    return 1;
  }
};
goog.string.numerateCompareRegExp_ = /(\.\d+)|(\d+)|(\D+)/g;
goog.string.numerateCompare = function (str1, str2) {
  if (str1 == str2) {
    return 0;
  }
  if (!str1) {
    return -1;
  }
  if (!str2) {
    return 1;
  }
  var tokens1 = str1.toLowerCase().match(goog.string.numerateCompareRegExp_);
  var tokens2 = str2.toLowerCase().match(goog.string.numerateCompareRegExp_);
  var count = Math.min(tokens1.length, tokens2.length);
  for (var i = 0; i < count; i++) {
    var a = tokens1[i];
    var b = tokens2[i];
    if (a != b) {
      var num1 = parseInt(a, 10);
      if (!isNaN(num1)) {
        var num2 = parseInt(b, 10);
        if (!isNaN(num2) && num1 - num2) {
          return num1 - num2;
        }
      }
      return a < b ? -1 : 1;
    }
  }
  if (tokens1.length != tokens2.length) {
    return tokens1.length - tokens2.length;
  }
  return str1 < str2 ? -1 : 1;
};
goog.string.urlEncode = function (str) {
  return encodeURIComponent(String(str));
};
goog.string.urlDecode = function (str) {
  return decodeURIComponent(str.replace(/\+/g, ' '));
};
goog.string.newLineToBr = function (str, opt_xml) {
  return str.replace(/(\r\n|\r|\n)/g, opt_xml ? '<br />' : '<br>');
};
goog.string.htmlEscape = function (str, opt_isLikelyToContainHtmlChars) {
  if (opt_isLikelyToContainHtmlChars) {
    return str.replace(goog.string.amperRe_, '&amp;').replace(goog.string.ltRe_, '&lt;').replace(goog.string.gtRe_, '&gt;').replace(goog.string.quotRe_, '&quot;');
  } else {
    if (!goog.string.allRe_.test(str))
      return str;
    if (str.indexOf('&') != -1) {
      str = str.replace(goog.string.amperRe_, '&amp;');
    }
    if (str.indexOf('<') != -1) {
      str = str.replace(goog.string.ltRe_, '&lt;');
    }
    if (str.indexOf('>') != -1) {
      str = str.replace(goog.string.gtRe_, '&gt;');
    }
    if (str.indexOf('"') != -1) {
      str = str.replace(goog.string.quotRe_, '&quot;');
    }
    return str;
  }
};
goog.string.amperRe_ = /&/g;
goog.string.ltRe_ = /</g;
goog.string.gtRe_ = />/g;
goog.string.quotRe_ = /\"/g;
goog.string.allRe_ = /[&<>\"]/;
goog.string.unescapeEntities = function (str) {
  if (goog.string.contains(str, '&')) {
    if ('document' in goog.global) {
      return goog.string.unescapeEntitiesUsingDom_(str);
    } else {
      return goog.string.unescapePureXmlEntities_(str);
    }
  }
  return str;
};
goog.string.unescapeEntitiesUsingDom_ = function (str) {
  var seen = {
      '&amp;': '&',
      '&lt;': '<',
      '&gt;': '>',
      '&quot;': '"'
    };
  var div = document.createElement('div');
  return str.replace(goog.string.HTML_ENTITY_PATTERN_, function (s, entity) {
    var value = seen[s];
    if (value) {
      return value;
    }
    if (entity.charAt(0) == '#') {
      var n = Number('0' + entity.substr(1));
      if (!isNaN(n)) {
        value = String.fromCharCode(n);
      }
    }
    if (!value) {
      div.innerHTML = s + ' ';
      value = div.firstChild.nodeValue.slice(0, -1);
    }
    return seen[s] = value;
  });
};
goog.string.unescapePureXmlEntities_ = function (str) {
  return str.replace(/&([^;]+);/g, function (s, entity) {
    switch (entity) {
    case 'amp':
      return '&';
    case 'lt':
      return '<';
    case 'gt':
      return '>';
    case 'quot':
      return '"';
    default:
      if (entity.charAt(0) == '#') {
        var n = Number('0' + entity.substr(1));
        if (!isNaN(n)) {
          return String.fromCharCode(n);
        }
      }
      return s;
    }
  });
};
goog.string.HTML_ENTITY_PATTERN_ = /&([^;\s<&]+);?/g;
goog.string.whitespaceEscape = function (str, opt_xml) {
  return goog.string.newLineToBr(str.replace(/  /g, ' &#160;'), opt_xml);
};
goog.string.stripQuotes = function (str, quoteChars) {
  var length = quoteChars.length;
  for (var i = 0; i < length; i++) {
    var quoteChar = length == 1 ? quoteChars : quoteChars.charAt(i);
    if (str.charAt(0) == quoteChar && str.charAt(str.length - 1) == quoteChar) {
      return str.substring(1, str.length - 1);
    }
  }
  return str;
};
goog.string.truncate = function (str, chars, opt_protectEscapedCharacters) {
  if (opt_protectEscapedCharacters) {
    str = goog.string.unescapeEntities(str);
  }
  if (str.length > chars) {
    str = str.substring(0, chars - 3) + '...';
  }
  if (opt_protectEscapedCharacters) {
    str = goog.string.htmlEscape(str);
  }
  return str;
};
goog.string.truncateMiddle = function (str, chars, opt_protectEscapedCharacters, opt_trailingChars) {
  if (opt_protectEscapedCharacters) {
    str = goog.string.unescapeEntities(str);
  }
  if (opt_trailingChars && str.length > chars) {
    if (opt_trailingChars > chars) {
      opt_trailingChars = chars;
    }
    var endPoint = str.length - opt_trailingChars;
    var startPoint = chars - opt_trailingChars;
    str = str.substring(0, startPoint) + '...' + str.substring(endPoint);
  } else if (str.length > chars) {
    var half = Math.floor(chars / 2);
    var endPos = str.length - half;
    half += chars % 2;
    str = str.substring(0, half) + '...' + str.substring(endPos);
  }
  if (opt_protectEscapedCharacters) {
    str = goog.string.htmlEscape(str);
  }
  return str;
};
goog.string.specialEscapeChars_ = {
  '\0': '\\0',
  '\b': '\\b',
  '\f': '\\f',
  '\n': '\\n',
  '\r': '\\r',
  '\t': '\\t',
  '\x0B': '\\x0B',
  '"': '\\"',
  '\\': '\\\\'
};
goog.string.jsEscapeCache_ = { '\'': '\\\'' };
goog.string.quote = function (s) {
  s = String(s);
  if (s.quote) {
    return s.quote();
  } else {
    var sb = ['"'];
    for (var i = 0; i < s.length; i++) {
      var ch = s.charAt(i);
      var cc = ch.charCodeAt(0);
      sb[i + 1] = goog.string.specialEscapeChars_[ch] || (cc > 31 && cc < 127 ? ch : goog.string.escapeChar(ch));
    }
    sb.push('"');
    return sb.join('');
  }
};
goog.string.escapeString = function (str) {
  var sb = [];
  for (var i = 0; i < str.length; i++) {
    sb[i] = goog.string.escapeChar(str.charAt(i));
  }
  return sb.join('');
};
goog.string.escapeChar = function (c) {
  if (c in goog.string.jsEscapeCache_) {
    return goog.string.jsEscapeCache_[c];
  }
  if (c in goog.string.specialEscapeChars_) {
    return goog.string.jsEscapeCache_[c] = goog.string.specialEscapeChars_[c];
  }
  var rv = c;
  var cc = c.charCodeAt(0);
  if (cc > 31 && cc < 127) {
    rv = c;
  } else {
    if (cc < 256) {
      rv = '\\x';
      if (cc < 16 || cc > 256) {
        rv += '0';
      }
    } else {
      rv = '\\u';
      if (cc < 4096) {
        rv += '0';
      }
    }
    rv += cc.toString(16).toUpperCase();
  }
  return goog.string.jsEscapeCache_[c] = rv;
};
goog.string.toMap = function (s) {
  var rv = {};
  for (var i = 0; i < s.length; i++) {
    rv[s.charAt(i)] = true;
  }
  return rv;
};
goog.string.contains = function (s, ss) {
  return s.indexOf(ss) != -1;
};
goog.string.countOf = function (s, ss) {
  return s && ss ? s.split(ss).length - 1 : 0;
};
goog.string.removeAt = function (s, index, stringLength) {
  var resultStr = s;
  if (index >= 0 && index < s.length && stringLength > 0) {
    resultStr = s.substr(0, index) + s.substr(index + stringLength, s.length - index - stringLength);
  }
  return resultStr;
};
goog.string.remove = function (s, ss) {
  var re = new RegExp(goog.string.regExpEscape(ss), '');
  return s.replace(re, '');
};
goog.string.removeAll = function (s, ss) {
  var re = new RegExp(goog.string.regExpEscape(ss), 'g');
  return s.replace(re, '');
};
goog.string.regExpEscape = function (s) {
  return String(s).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
};
goog.string.repeat = function (string, length) {
  return new Array(length + 1).join(string);
};
goog.string.padNumber = function (num, length, opt_precision) {
  var s = goog.isDef(opt_precision) ? num.toFixed(opt_precision) : String(num);
  var index = s.indexOf('.');
  if (index == -1) {
    index = s.length;
  }
  return goog.string.repeat('0', Math.max(0, length - index)) + s;
};
goog.string.makeSafe = function (obj) {
  return obj == null ? '' : String(obj);
};
goog.string.buildString = function (var_args) {
  return Array.prototype.join.call(arguments, '');
};
goog.string.getRandomString = function () {
  var x = 2147483648;
  return Math.floor(Math.random() * x).toString(36) + Math.abs(Math.floor(Math.random() * x) ^ goog.now()).toString(36);
};
goog.string.compareVersions = function (version1, version2) {
  var order = 0;
  var v1Subs = goog.string.trim(String(version1)).split('.');
  var v2Subs = goog.string.trim(String(version2)).split('.');
  var subCount = Math.max(v1Subs.length, v2Subs.length);
  for (var subIdx = 0; order == 0 && subIdx < subCount; subIdx++) {
    var v1Sub = v1Subs[subIdx] || '';
    var v2Sub = v2Subs[subIdx] || '';
    var v1CompParser = new RegExp('(\\d*)(\\D*)', 'g');
    var v2CompParser = new RegExp('(\\d*)(\\D*)', 'g');
    do {
      var v1Comp = v1CompParser.exec(v1Sub) || [
          '',
          '',
          ''
        ];
      var v2Comp = v2CompParser.exec(v2Sub) || [
          '',
          '',
          ''
        ];
      if (v1Comp[0].length == 0 && v2Comp[0].length == 0) {
        break;
      }
      var v1CompNum = v1Comp[1].length == 0 ? 0 : parseInt(v1Comp[1], 10);
      var v2CompNum = v2Comp[1].length == 0 ? 0 : parseInt(v2Comp[1], 10);
      order = goog.string.compareElements_(v1CompNum, v2CompNum) || goog.string.compareElements_(v1Comp[2].length == 0, v2Comp[2].length == 0) || goog.string.compareElements_(v1Comp[2], v2Comp[2]);
    } while (order == 0);
  }
  return order;
};
goog.string.compareElements_ = function (left, right) {
  if (left < right) {
    return -1;
  } else if (left > right) {
    return 1;
  }
  return 0;
};
goog.string.HASHCODE_MAX_ = 4294967296;
goog.string.hashCode = function (str) {
  var result = 0;
  for (var i = 0; i < str.length; ++i) {
    result = 31 * result + str.charCodeAt(i);
    result %= goog.string.HASHCODE_MAX_;
  }
  return result;
};
goog.string.uniqueStringCounter_ = Math.random() * 2147483648 | 0;
goog.string.createUniqueString = function () {
  return 'goog_' + goog.string.uniqueStringCounter_++;
};
goog.string.toNumber = function (str) {
  var num = Number(str);
  if (num == 0 && goog.string.isEmpty(str)) {
    return NaN;
  }
  return num;
};
goog.string.isLowerCamelCase = function (str) {
  return /^[a-z]+([A-Z][a-z]*)*$/.test(str);
};
goog.string.isUpperCamelCase = function (str) {
  return /^([A-Z][a-z]*)+$/.test(str);
};
goog.string.toCamelCase = function (str) {
  return String(str).replace(/\-([a-z])/g, function (all, match) {
    return match.toUpperCase();
  });
};
goog.string.toSelectorCase = function (str) {
  return String(str).replace(/([A-Z])/g, '-$1').toLowerCase();
};
goog.string.toTitleCase = function (str, opt_delimiters) {
  var delimiters = goog.isString(opt_delimiters) ? goog.string.regExpEscape(opt_delimiters) : '\\s';
  delimiters = delimiters ? '|[' + delimiters + ']+' : '';
  var regexp = new RegExp('(^' + delimiters + ')([a-z])', 'g');
  return str.replace(regexp, function (all, p1, p2) {
    return p1 + p2.toUpperCase();
  });
};
goog.string.parseInt = function (value) {
  if (isFinite(value)) {
    value = String(value);
  }
  if (goog.isString(value)) {
    return /^\s*-?0x/i.test(value) ? parseInt(value, 16) : parseInt(value, 10);
  }
  return NaN;
};
goog.string.splitLimit = function (str, separator, limit) {
  var parts = str.split(separator);
  var returnVal = [];
  while (limit > 0 && parts.length) {
    returnVal.push(parts.shift());
    limit--;
  }
  if (parts.length) {
    returnVal.push(parts.join(separator));
  }
  return returnVal;
};
goog.provide('goog.debug.Error');
goog.debug.Error = function (opt_msg) {
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, goog.debug.Error);
  } else {
    this.stack = new Error().stack || '';
  }
  if (opt_msg) {
    this.message = String(opt_msg);
  }
};
goog.inherits(goog.debug.Error, Error);
goog.debug.Error.prototype.name = 'CustomError';
goog.provide('goog.asserts');
goog.provide('goog.asserts.AssertionError');
goog.require('goog.debug.Error');
goog.require('goog.string');
goog.define('goog.asserts.ENABLE_ASSERTS', goog.DEBUG);
goog.asserts.AssertionError = function (messagePattern, messageArgs) {
  messageArgs.unshift(messagePattern);
  goog.debug.Error.call(this, goog.string.subs.apply(null, messageArgs));
  messageArgs.shift();
  this.messagePattern = messagePattern;
};
goog.inherits(goog.asserts.AssertionError, goog.debug.Error);
goog.asserts.AssertionError.prototype.name = 'AssertionError';
goog.asserts.doAssertFailure_ = function (defaultMessage, defaultArgs, givenMessage, givenArgs) {
  var message = 'Assertion failed';
  if (givenMessage) {
    message += ': ' + givenMessage;
    var args = givenArgs;
  } else if (defaultMessage) {
    message += ': ' + defaultMessage;
    args = defaultArgs;
  }
  throw new goog.asserts.AssertionError('' + message, args || []);
};
goog.asserts.assert = function (condition, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !condition) {
    goog.asserts.doAssertFailure_('', null, opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return condition;
};
goog.asserts.fail = function (opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS) {
    throw new goog.asserts.AssertionError('Failure' + (opt_message ? ': ' + opt_message : ''), Array.prototype.slice.call(arguments, 1));
  }
};
goog.asserts.assertNumber = function (value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isNumber(value)) {
    goog.asserts.doAssertFailure_('Expected number but got %s: %s.', [
      goog.typeOf(value),
      value
    ], opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return value;
};
goog.asserts.assertString = function (value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isString(value)) {
    goog.asserts.doAssertFailure_('Expected string but got %s: %s.', [
      goog.typeOf(value),
      value
    ], opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return value;
};
goog.asserts.assertFunction = function (value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isFunction(value)) {
    goog.asserts.doAssertFailure_('Expected function but got %s: %s.', [
      goog.typeOf(value),
      value
    ], opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return value;
};
goog.asserts.assertObject = function (value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isObject(value)) {
    goog.asserts.doAssertFailure_('Expected object but got %s: %s.', [
      goog.typeOf(value),
      value
    ], opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return value;
};
goog.asserts.assertArray = function (value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isArray(value)) {
    goog.asserts.doAssertFailure_('Expected array but got %s: %s.', [
      goog.typeOf(value),
      value
    ], opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return value;
};
goog.asserts.assertBoolean = function (value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isBoolean(value)) {
    goog.asserts.doAssertFailure_('Expected boolean but got %s: %s.', [
      goog.typeOf(value),
      value
    ], opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return value;
};
goog.asserts.assertInstanceof = function (value, type, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !(value instanceof type)) {
    goog.asserts.doAssertFailure_('instanceof check failed.', null, opt_message, Array.prototype.slice.call(arguments, 3));
  }
  return value;
};
goog.asserts.assertObjectPrototypeIsIntact = function () {
  for (var key in Object.prototype) {
    goog.asserts.fail(key + ' should not be enumerable in Object.prototype.');
  }
};
var Sk = Sk || {};
Sk.configure = function (options) {
  Sk.output = options['output'] || Sk.output;
  goog.asserts.assert(typeof Sk.output === 'function');
  Sk.debugout = options['debugout'] || Sk.debugout;
  goog.asserts.assert(typeof Sk.debugout === 'function');
  Sk.read = options['read'] || Sk.read;
  goog.asserts.assert(typeof Sk.read === 'function');
  Sk.timeoutMsg = options['timeoutMsg'] || Sk.timeoutMsg;
  goog.asserts.assert(typeof Sk.timeoutMsg === 'function');
  goog.exportSymbol('Sk.timeoutMsg', Sk.timeoutMsg);
  Sk.sysargv = options['sysargv'] || Sk.sysargv;
  goog.asserts.assert(goog.isArrayLike(Sk.sysargv));
  Sk.physics = options['physics'] || Sk.physics;
  goog.asserts.assertBoolean(Sk.physics, 'Sk.physics must be set to a JavaScript boolean value.');
  Sk.python3 = options['python3'] || Sk.python3;
  goog.asserts.assertBoolean(Sk.python3);
  Sk.inputfun = options['inputfun'] || Sk.inputfun;
  goog.asserts.assert(typeof Sk.inputfun === 'function');
  Sk.throwSystemExit = options['systemexit'] || false;
  goog.asserts.assert(typeof Sk.throwSystemExit === 'boolean');
  if (options['syspath']) {
    Sk.syspath = options['syspath'];
    goog.asserts.assert(goog.isArrayLike(Sk.syspath));
    Sk.realsyspath = undefined;
    Sk.sysmodules = new Sk.builtin.dict([]);
  }
  Sk.misceval.softspace_ = false;
};
goog.exportSymbol('Sk.configure', Sk.configure);
Sk.timeoutMsg = function () {
  return 'Program exceeded run time limit.';
};
goog.exportSymbol('Sk.timeoutMsg', Sk.timeoutMsg);
Sk.output = function (x) {
};
Sk.read = function (x) {
  throw 'Sk.read has not been implemented';
};
Sk.sysargv = [];
Sk.getSysArgv = function () {
  return Sk.sysargv;
};
goog.exportSymbol('Sk.getSysArgv', Sk.getSysArgv);
Sk.syspath = [];
Sk.inBrowser = goog.global['document'] !== undefined;
Sk.debugout = function (args) {
};
(function () {
  if (goog.global['write'] !== undefined)
    Sk.output = goog.global['write'];
  else if (goog.global['console'] !== undefined && goog.global['console']['log'] !== undefined)
    Sk.output = function (x) {
      goog.global['console']['log'](x);
    };
  else if (goog.global['print'] !== undefined)
    Sk.output = goog.global['print'];
  if (goog.global['print'] !== undefined)
    Sk.debugout = goog.global['print'];
}());
if (!Sk.inBrowser) {
  goog.global.CLOSURE_IMPORT_SCRIPT = function (src) {
    goog.global['eval'](goog.global['read']('support/closure-library/closure/goog/' + src));
    return true;
  };
}
Sk.physics = false;
goog.exportSymbol('Sk.physics', Sk.physics);
Sk.python3 = false;
goog.exportSymbol('Sk.python3', Sk.python3);
Sk.inputfun = function (args) {
  return window.prompt(args);
};
goog.exportSymbol('Sk.inputfun', Sk.inputfun);
goog.require('goog.asserts');
Sk.builtin = {};
Sk.builtin.range = function range(start, stop, step) {
  var ret = [];
  var i;
  Sk.ffi.checkFunctionArgs('range(stop) or range(start, stop[, step])', arguments, 1, 3);
  Sk.builtin.pyCheckType('start', 'integer', Sk.builtin.checkInt(start));
  if (stop !== undefined) {
    Sk.builtin.pyCheckType('stop', 'integer', Sk.builtin.checkInt(stop));
  }
  if (step !== undefined) {
    Sk.builtin.pyCheckType('step', 'integer', Sk.builtin.checkInt(step));
  }
  start = Sk.builtin.asnum$(start);
  stop = Sk.builtin.asnum$(stop);
  step = Sk.builtin.asnum$(step);
  if (stop === undefined && step === undefined) {
    stop = start;
    start = 0;
    step = 1;
  } else if (step === undefined) {
    step = 1;
  }
  if (step === 0) {
    throw new Sk.builtin.ValueError('range() step argument must not be zero');
  }
  if (step > 0) {
    for (i = start; i < stop; i += step) {
      ret.push(new Sk.builtin.nmber(i, Sk.builtin.nmber.int$));
    }
  } else {
    for (i = start; i > stop; i += step) {
      ret.push(new Sk.builtin.nmber(i, Sk.builtin.nmber.int$));
    }
  }
  return new Sk.builtin.list(ret);
};
Sk.builtin.asnum$ = function (a) {
  if (a === undefined)
    return a;
  if (a === null)
    return a;
  if (a.constructor === Sk.builtin.none)
    return null;
  if (a.constructor === Sk.builtin.bool) {
    if (a.v)
      return 1;
    return 0;
  }
  if (typeof a === 'number')
    return a;
  if (typeof a === 'string')
    return a;
  if (a.constructor === Sk.builtin.nmber)
    return a.v;
  if (a.constructor === Sk.builtin.lng) {
    if (a.cantBeInt())
      return a.str$(10, true);
    return a.toInt$();
  }
  if (a.constructor === Sk.builtin.biginteger) {
    if (a.trueCompare(new Sk.builtin.biginteger(Sk.builtin.lng.threshold$)) > 0 || a.trueCompare(new Sk.builtin.biginteger(-Sk.builtin.lng.threshold$)) < 0) {
      return a.toString();
    }
    return a.intValue();
  }
  return a;
};
goog.exportSymbol('Sk.builtin.asnum$', Sk.builtin.asnum$);
Sk.builtin.assk$ = function (a, b) {
  return new Sk.builtin.nmber(a, b);
};
goog.exportSymbol('Sk.builtin.assk$', Sk.builtin.assk$);
Sk.builtin.asnum$nofloat = function (a) {
  if (a === undefined)
    return a;
  if (a === null)
    return a;
  if (a.constructor === Sk.builtin.none)
    return null;
  if (a.constructor === Sk.builtin.bool) {
    if (a.v)
      return 1;
    return 0;
  }
  if (typeof a === 'number')
    a = a.toString();
  if (a.constructor === Sk.builtin.nmber)
    a = a.v.toString();
  if (a.constructor === Sk.builtin.lng)
    a = a.str$(10, true);
  if (a.constructor === Sk.builtin.biginteger)
    a = a.toString();
  if (a.indexOf('.') < 0 && a.indexOf('e') < 0 && a.indexOf('E') < 0)
    return a;
  var expon = 0;
  var mantissa;
  if (a.indexOf('e') >= 0) {
    mantissa = a.substr(0, a.indexOf('e'));
    expon = a.substr(a.indexOf('e') + 1);
  } else if (a.indexOf('E') >= 0) {
    mantissa = a.substr(0, a.indexOf('e'));
    expon = a.substr(a.indexOf('E') + 1);
  } else {
    mantissa = a;
  }
  expon = parseInt(expon, 10);
  var decimal = mantissa.indexOf('.');
  if (decimal < 0) {
    if (expon >= 0) {
      while (expon-- > 0)
        mantissa += '0';
      return mantissa;
    } else {
      if (mantissa.length > -expon)
        return mantissa.substr(0, mantissa.length + expon);
      else
        return 0;
    }
  }
  if (decimal == 0)
    mantissa = mantissa.substr(1);
  else if (decimal < mantissa.length)
    mantissa = mantissa.substr(0, decimal) + mantissa.substr(decimal + 1);
  else
    mantissa = mantissa.substr(0, decimal);
  decimal = decimal + expon;
  while (decimal > mantissa.length)
    mantissa += '0';
  if (decimal <= 0) {
    mantissa = 0;
  } else {
    mantissa = mantissa.substr(0, decimal);
  }
  return mantissa;
};
goog.exportSymbol('Sk.builtin.asnum$nofloat', Sk.builtin.asnum$nofloat);
Sk.builtin.round = function round(number, ndigits) {
  var result, multiplier;
  Sk.builtin.pyCheckArgs('round', arguments, 1, 2);
  if (!Sk.builtin.checkNumber(number)) {
    throw new Sk.builtin.TypeError('a float is required');
  }
  if (ndigits !== undefined && !Sk.misceval.isIndex(ndigits)) {
    throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(ndigits) + '\' object cannot be interpreted as an index');
  }
  ;
  if (ndigits === undefined) {
    ndigits = 0;
  }
  ;
  number = Sk.builtin.asnum$(number);
  ndigits = Sk.misceval.asIndex(ndigits);
  multiplier = Math.pow(10, ndigits);
  result = Math.round(number * multiplier) / multiplier;
  return new Sk.builtin.nmber(result, Sk.builtin.nmber.float$);
};
Sk.builtin.len = function len(item) {
  Sk.builtin.pyCheckArgs('len', arguments, 1, 1);
  if (item.sq$length)
    return new Sk.builtin.nmber(item.sq$length(), Sk.builtin.nmber.int$);
  if (item.mp$length)
    return new Sk.builtin.nmber(item.mp$length(), Sk.builtin.nmber.int$);
  if (item.tp$length)
    return new Sk.builtin.nmber(item.tp$length(), Sk.builtin.nmber.int$);
  throw new Sk.builtin.TypeError('object of type \'' + Sk.abstr.typeName(item) + '\' has no len()');
};
Sk.builtin.min = function min() {
  Sk.builtin.pyCheckArgs('min', arguments, 1);
  var argArray = Sk.misceval.arrayFromArguments(arguments);
  var lowest = argArray[0];
  for (var i = 1; i < argArray.length; ++i) {
    if (Sk.misceval.richCompareBool(argArray[i], lowest, 'Lt'))
      lowest = argArray[i];
  }
  return lowest;
};
Sk.builtin.max = function max() {
  Sk.builtin.pyCheckArgs('max', arguments, 1);
  var argArray = Sk.misceval.arrayFromArguments(arguments);
  var highest = argArray[0];
  for (var i = 1; i < argArray.length; ++i) {
    if (Sk.misceval.richCompareBool(argArray[i], highest, 'Gt'))
      highest = argArray[i];
  }
  return highest;
};
Sk.builtin.any = function any(iter) {
  var it, i;
  Sk.builtin.pyCheckArgs('any', arguments, 1);
  if (!Sk.builtin.checkIterable(iter)) {
    throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(iter) + '\' object is not iterable');
  }
  it = iter.tp$iter();
  for (i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {
    if (Sk.misceval.isTrue(i)) {
      return true;
    }
  }
  return false;
};
Sk.builtin.all = function all(iter) {
  var it, i;
  Sk.builtin.pyCheckArgs('all', arguments, 1);
  if (!Sk.builtin.checkIterable(iter)) {
    throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(iter) + '\' object is not iterable');
  }
  it = iter.tp$iter();
  for (i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {
    if (!Sk.misceval.isTrue(i)) {
      return false;
    }
  }
  return true;
};
Sk.builtin.sum = function sum(iter, start) {
  var tot;
  var it, i;
  var has_float;
  Sk.builtin.pyCheckArgs('sum', arguments, 1, 2);
  Sk.builtin.pyCheckType('iter', 'iterable', Sk.builtin.checkIterable(iter));
  if (start !== undefined && Sk.builtin.checkString(start)) {
    throw new Sk.builtin.TypeError('sum() can\'t sum strings [use \'\'.join(seq) instead]');
  }
  ;
  if (start === undefined) {
    tot = new Sk.builtin.nmber(0, Sk.builtin.nmber.int$);
  } else {
    tot = start;
  }
  it = iter.tp$iter();
  for (i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {
    if (i.skType === Sk.builtin.nmber.float$) {
      has_float = true;
      if (tot.skType !== Sk.builtin.nmber.float$) {
        tot = new Sk.builtin.nmber(Sk.builtin.asnum$(tot), Sk.builtin.nmber.float$);
      }
    } else if (i instanceof Sk.builtin.lng) {
      if (!has_float) {
        if (!(tot instanceof Sk.builtin.lng)) {
          tot = new Sk.builtin.lng(tot);
        }
      }
    }
    if (tot.nb$add(i) !== undefined) {
      tot = tot.nb$add(i);
    } else {
      throw new Sk.builtin.TypeError('unsupported operand type(s) for +: \'' + Sk.abstr.typeName(tot) + '\' and \'' + Sk.abstr.typeName(i) + '\'');
    }
  }
  return tot;
};
Sk.builtin.zip = function zip() {
  if (arguments.length === 0) {
    return new Sk.builtin.list([]);
  }
  var iters = [];
  for (var i = 0; i < arguments.length; i++) {
    if (arguments[i].tp$iter) {
      iters.push(arguments[i].tp$iter());
    } else {
      throw 'TypeError: argument ' + i + ' must support iteration';
    }
  }
  var res = [];
  var done = false;
  while (!done) {
    var tup = [];
    for (i = 0; i < arguments.length; i++) {
      var el = iters[i].tp$iternext();
      if (el === undefined) {
        done = true;
        break;
      }
      tup.push(el);
    }
    if (!done) {
      res.push(new Sk.builtin.tuple(tup));
    }
  }
  return new Sk.builtin.list(res);
};
Sk.builtin.abs = function abs(xPy) {
  Sk.ffi.checkFunctionArgs('abs', arguments, 1, 1);
  if (Sk.ffi.isNum(xPy)) {
    return Sk.ffi.numberToPy(Math.abs(Sk.ffi.remapToJs(xPy)), Sk.ffi.getType(xPy));
  } else {
    return Sk.ffh.abs(xPy);
  }
};
Sk.builtin.ord = function ord(x) {
  Sk.builtin.pyCheckArgs('ord', arguments, 1, 1);
  if (!Sk.builtin.checkString(x)) {
    throw new Sk.builtin.TypeError('ord() expected a string of length 1, but ' + Sk.abstr.typeName(x) + ' found');
  } else if (x.v.length !== 1) {
    throw new Sk.builtin.TypeError('ord() expected a character, but string of length ' + x.v.length + ' found');
  }
  return new Sk.builtin.nmber(x.v.charCodeAt(0), Sk.builtin.nmber.int$);
};
Sk.builtin.chr = function chr(x) {
  Sk.builtin.pyCheckArgs('chr', arguments, 1, 1);
  if (!Sk.builtin.checkInt(x)) {
    throw new Sk.builtin.TypeError('an integer is required');
  }
  x = Sk.builtin.asnum$(x);
  if (x < 0 || x > 255) {
    throw new Sk.builtin.ValueError('chr() arg not in range(256)');
  }
  return new Sk.builtin.str(String.fromCharCode(x));
};
Sk.builtin.int2str_ = function helper_(x, radix, prefix) {
  var str = '';
  if (x instanceof Sk.builtin.lng) {
    var suffix = '';
    if (radix !== 2)
      suffix = 'L';
    str = x.str$(radix, false);
    if (x.nb$isnegative()) {
      return new Sk.builtin.str('-' + prefix + str + suffix);
    }
    return new Sk.builtin.str(prefix + str + suffix);
  } else {
    x = Sk.misceval.asIndex(x);
    str = x.toString(radix);
    if (x < 0) {
      return new Sk.builtin.str('-' + prefix + str.slice(1));
    }
    return new Sk.builtin.str(prefix + str);
  }
};
Sk.builtin.hex = function hex(x) {
  Sk.builtin.pyCheckArgs('hex', arguments, 1, 1);
  if (!Sk.misceval.isIndex(x)) {
    throw new Sk.builtin.TypeError('hex() argument can\'t be converted to hex');
  }
  return Sk.builtin.int2str_(x, 16, '0x');
};
Sk.builtin.oct = function oct(x) {
  Sk.builtin.pyCheckArgs('oct', arguments, 1, 1);
  if (!Sk.misceval.isIndex(x)) {
    throw new Sk.builtin.TypeError('oct() argument can\'t be converted to hex');
  }
  return Sk.builtin.int2str_(x, 8, '0');
};
Sk.builtin.bin = function bin(x) {
  Sk.builtin.pyCheckArgs('bin', arguments, 1, 1);
  if (!Sk.misceval.isIndex(x)) {
    throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(x) + '\' object can\'t be interpreted as an index');
  }
  return Sk.builtin.int2str_(x, 2, '0b');
};
Sk.builtin.dir = function dir(x) {
  Sk.builtin.pyCheckArgs('dir', arguments, 1, 1);
  var getName = function (k) {
    var s = null;
    var internal = [
        '__bases__',
        '__mro__',
        '__class__'
      ];
    if (internal.indexOf(k) !== -1)
      return null;
    if (k.indexOf('$') !== -1)
      s = Sk.builtin.dir.slotNameToRichName(k);
    else if (k.charAt(k.length - 1) !== '_')
      s = k;
    else if (k.charAt(0) === '_')
      s = k;
    return s;
  };
  var names = [];
  var k;
  var s;
  var i;
  var mro;
  var base;
  var prop;
  for (k in x.constructor.prototype) {
    s = getName(k);
    if (s)
      names.push(new Sk.builtin.str(s));
  }
  if (x['$d']) {
    if (x['$d'].tp$iter) {
      var it = x['$d'].tp$iter();
      var i;
      for (i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {
        s = new Sk.builtin.str(i);
        s = getName(s.v);
        if (s)
          names.push(new Sk.builtin.str(s));
      }
    } else {
      for (s in x['$d']) {
        names.push(new Sk.builtin.str(s));
      }
    }
  }
  mro = x.tp$mro;
  if (mro) {
    mro = x.tp$mro;
    for (i = 0; i < mro.v.length; ++i) {
      base = mro.v[i];
      for (prop in base) {
        if (base.hasOwnProperty(prop)) {
          s = getName(prop);
          if (s)
            names.push(new Sk.builtin.str(s));
        }
      }
    }
  }
  names.sort(function (a, b) {
    return (a.v > b.v) - (a.v < b.v);
  });
  var last = function (value, index, self) {
    return value !== self[index + 1];
  };
  return new Sk.builtin.list(names.filter(last));
};
Sk.builtin.dir.slotNameToRichName = function (k) {
  return undefined;
};
Sk.builtin.repr = function repr(x) {
  Sk.builtin.pyCheckArgs('repr', arguments, 1, 1);
  return Sk.misceval.objectRepr(x);
};
Sk.builtin.open = function open(filename, mode, bufsize) {
  Sk.builtin.pyCheckArgs('open', arguments, 1, 3);
  if (mode === undefined)
    mode = new Sk.builtin.str('r');
  if (mode.v !== 'r' && mode.v !== 'rb')
    throw 'todo; haven\'t implemented non-read opens';
  return new Sk.builtin.file(filename, mode, bufsize);
};
Sk.builtin.isinstance = function isinstance(obj, type) {
  Sk.builtin.pyCheckArgs('isinstance', arguments, 2, 2);
  if (!Sk.builtin.checkClass(type) && !(type instanceof Sk.builtin.tuple)) {
    throw new Sk.builtin.TypeError('isinstance() arg 2 must be a class, type, or tuple of classes and types');
  }
  if (type === Sk.builtin.int_.prototype.ob$type) {
    return obj.tp$name === 'number' && obj.skType === Sk.builtin.nmber.int$;
  }
  if (type === Sk.builtin.float_.prototype.ob$type) {
    return obj.tp$name === 'number' && obj.skType === Sk.builtin.nmber.float$;
  }
  if (type === Sk.builtin.none.prototype.ob$type) {
    return obj instanceof Sk.builtin.none;
  }
  if (obj.ob$type === type)
    return true;
  if (type instanceof Sk.builtin.tuple) {
    for (var i = 0; i < type.v.length; ++i) {
      if (Sk.builtin.isinstance(obj, type.v[i]))
        return true;
    }
    return false;
  }
  var issubclass = function (klass, base) {
    if (klass === base)
      return true;
    if (klass['$d'] === undefined)
      return false;
    var bases = klass['$d'].mp$subscript(Sk.builtin.type.basesStr_);
    for (var i = 0; i < bases.v.length; ++i) {
      if (issubclass(bases.v[i], base))
        return true;
    }
    return false;
  };
  return issubclass(obj.ob$type, type);
};
Sk.builtin.hashCount = 0;
Sk.builtin.hash = function hash(value) {
  Sk.builtin.pyCheckArgs('hash', arguments, 1, 1);
  var junk = {
      __hash__: function () {
        return 0;
      }
    };
  if (value instanceof Object && value.tp$hash !== undefined) {
    if (value.$savedHash_)
      return value.$savedHash_;
    value.$savedHash_ = value.tp$hash();
    return value.$savedHash_;
  } else if (value instanceof Object && value.__hash__ !== undefined) {
    return Sk.misceval.callsim(value.__hash__, value);
  } else if (value instanceof Sk.builtin.bool) {
    if (value.v)
      return 1;
    return 0;
  } else if (value instanceof Sk.builtin.none) {
    return 0;
  } else if (value instanceof Object) {
    if (value.__id === undefined) {
      Sk.builtin.hashCount += 1;
      value.__id = Sk.builtin.hashCount;
    }
    return value.__id;
  } else if (typeof value === 'number') {
    return value;
  } else if (value === null) {
    return 0;
  } else if (value === true) {
    return 1;
  } else if (value === false) {
    return 0;
  }
  return typeof value + ' ' + String(value);
};
Sk.builtin.getattr = function getattr(obj, name, default_) {
  Sk.builtin.pyCheckArgs('getattr', arguments, 2, 3);
  if (!Sk.builtin.checkString(name)) {
    throw new Sk.builtin.TypeError('attribute name must be string');
  }
  var ret = obj.tp$getattr(name.v);
  if (ret === undefined) {
    if (default_ !== undefined)
      return default_;
    else
      throw new Sk.builtin.AttributeError('\'' + Sk.abstr.typeName(obj) + '\' object has no attribute \'' + name.v + '\'');
  }
  return ret;
};
Sk.builtin.raw_input = function (obj, name, default_) {
  var x = Sk.inputfun(obj.v);
  return new Sk.builtin.str(x);
};
Sk.builtin.input = function (promptPy, name, default_) {
  Sk.ffi.checkFunctionArgs('input', arguments, 0, 1);
  if (Sk.ffi.isDefined(promptPy)) {
    Sk.ffi.checkArgType('prompt', Sk.ffi.PyType.STR, Sk.ffi.isStr(promptPy), promptPy);
    var x = Sk.inputfun(Sk.ffi.remapToJs(promptPy));
    return Sk.ffi.stringToPy(x);
  } else {
    var x = Sk.inputfun('');
    return Sk.ffi.stringToPy(x);
  }
};
Sk.builtin.jseval = function jseval(evalcode) {
  goog.global['eval'](evalcode);
};
Sk.builtin.jsmillis = function jsmillis() {
  var now = new Date();
  return now.valueOf();
};
Sk.builtin.superbi = function superbi() {
  throw new Sk.builtin.NotImplementedError('super is not yet implemented, please report your use case as a github issue.');
};
Sk.builtin.eval_ = function eval_() {
  throw new Sk.builtin.NotImplementedError('eval is not yet implemented');
};
Sk.builtin.map = function map(fun, seq) {
  Sk.ffi.checkFunctionArgs('map(function, iterable, ...)', arguments, 2);
  if (arguments.length > 2) {
    var combined = [];
    var iterables = Array.prototype.slice.apply(arguments).slice(1);
    for (var i in iterables) {
      if (iterables[i].tp$iter === undefined) {
        var argnum = parseInt(i, 10) + 2;
        throw new Sk.builtin.TypeError('argument ' + argnum + ' to map() must support iteration');
      }
      iterables[i] = iterables[i].tp$iter();
    }
    while (true) {
      var args = [];
      var nones = 0;
      for (var i in iterables) {
        var next = iterables[i].tp$iternext();
        if (next === undefined) {
          args.push(Sk.builtin.none.none$);
          nones++;
        } else {
          args.push(next);
        }
      }
      if (nones !== iterables.length) {
        combined.push(args);
      } else {
        break;
      }
    }
    seq = new Sk.builtin.list(combined);
  }
  if (seq.tp$iter === undefined) {
    throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(seq) + '\' object is not iterable');
  }
  var retval = [];
  var iter, item;
  for (iter = seq.tp$iter(), item = iter.tp$iternext(); item !== undefined; item = iter.tp$iternext()) {
    if (fun === Sk.builtin.none.none$) {
      if (item instanceof Array) {
        item = new Sk.builtin.tuple(item);
      }
      retval.push(item);
    } else {
      if (!(item instanceof Array)) {
        item = [item];
      }
      retval.push(Sk.misceval.apply(fun, undefined, undefined, undefined, item));
    }
  }
  return new Sk.builtin.list(retval);
};
Sk.builtin.reduce = function reduce(fun, seq, initializer) {
  Sk.builtin.pyCheckArgs('reduce', arguments, 2, 3);
  var iter = seq.tp$iter();
  if (initializer === undefined) {
    initializer = iter.tp$iternext();
    if (initializer === undefined) {
      throw new Sk.builtin.TypeError('reduce() of empty sequence with no initial value');
    }
  }
  var accum_value = initializer;
  var next = iter.tp$iternext();
  while (next !== undefined) {
    accum_value = fun.func_code(accum_value, next);
    next = iter.tp$iternext();
  }
  return accum_value;
};
Sk.builtin.filter = function filter(fun, iterable) {
  Sk.builtin.pyCheckArgs('filter', arguments, 2, 2);
  if (iterable.tp$iter === undefined) {
    throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(iterable) + '\' object is not iterable');
  }
  if (fun instanceof Sk.builtin.none) {
    fun = {
      func_code: function (x) {
        return Sk.builtin.bool(x);
      }
    };
  }
  var ctor = function () {
    return [];
  };
  var add = function (iter, item) {
    iter.push(item);
    return iter;
  };
  var ret = function (iter) {
    return new Sk.builtin.list(iter);
  };
  if (iterable.__class__ === Sk.builtin.str) {
    ctor = function () {
      return new Sk.builtin.str('');
    };
    add = function (iter, item) {
      return iter.sq$concat(item);
    };
    ret = function (iter) {
      return iter;
    };
  } else if (iterable.__class__ === Sk.builtin.tuple) {
    ret = function (iter) {
      return new Sk.builtin.tuple(iter);
    };
  }
  var iter = iterable.tp$iter(), next = iter.tp$iternext(), retval = ctor();
  if (next === undefined) {
    return ret(retval);
  }
  while (next !== undefined) {
    if (Sk.misceval.isTrue(fun.func_code(next))) {
      retval = add(retval, next);
    }
    next = iter.tp$iternext();
  }
  return ret(retval);
};
Sk.builtin.hasattr = function hasattr(obj, attr) {
  Sk.builtin.pyCheckArgs('hasattr', arguments, 2, 2);
  if (!Sk.builtin.checkString(attr)) {
    throw new Sk.builtin.TypeError('hasattr(): attribute name must be string');
  }
  if (obj.tp$getattr) {
    if (obj.tp$getattr(attr.v)) {
      return true;
    } else
      return false;
  } else
    throw new Sk.builtin.AttributeError('Object has no tp$getattr method');
};
Sk.builtin.pow = function pow(a, b, c) {
  Sk.builtin.pyCheckArgs('pow', arguments, 2, 3);
  var a_num = Sk.builtin.asnum$(a);
  var b_num = Sk.builtin.asnum$(b);
  var c_num = Sk.builtin.asnum$(c);
  if (!Sk.builtin.checkNumber(a) || !Sk.builtin.checkNumber(b)) {
    if (c === undefined) {
      throw new Sk.builtin.TypeError('unsupported operand type(s) for pow(): \'' + Sk.abstr.typeName(a) + '\' and \'' + Sk.abstr.typeName(b) + '\'');
    } else {
      throw new Sk.builtin.TypeError('unsupported operand type(s) for pow(): \'' + Sk.abstr.typeName(a) + '\', \'' + Sk.abstr.typeName(b) + '\', \'' + Sk.abstr.typeName(c) + '\'');
    }
  }
  if (a_num < 0 && b.skType === Sk.builtin.nmber.float$) {
    throw new Sk.builtin.ValueError('negative number cannot be raised to a fractional power');
  }
  if (c === undefined) {
    var res = Math.pow(a_num, b_num);
    if (a.skType === Sk.builtin.nmber.float$ || b.skType === Sk.builtin.nmber.float$ || b_num < 0) {
      return new Sk.builtin.nmber(res, Sk.builtin.nmber.float$);
    } else if (a instanceof Sk.builtin.lng || b instanceof Sk.builtin.lng) {
      return new Sk.builtin.lng(res);
    } else {
      return new Sk.builtin.nmber(res, Sk.builtin.nmber.int$);
    }
  } else {
    if (!Sk.builtin.checkInt(a) || !Sk.builtin.checkInt(b) || !Sk.builtin.checkInt(c)) {
      throw new Sk.builtin.TypeError('pow() 3rd argument not allowed unless all arguments are integers');
    }
    if (b_num < 0) {
      throw new Sk.builtin.TypeError('pow() 2nd argument cannot be negative when 3rd argument specified');
    }
    if (a instanceof Sk.builtin.lng || b instanceof Sk.builtin.lng || c instanceof Sk.builtin.lng || Math.pow(a_num, b_num) === Infinity) {
      a = new Sk.builtin.lng(a);
      return a.nb$power(b, c);
    } else {
      var ret = new Sk.builtin.nmber(Math.pow(a_num, b_num), Sk.builtin.nmber.int$);
      return ret.nb$remainder(c);
    }
  }
};
Sk.builtin.quit = function quit(msg) {
  var s = new Sk.builtin.str(msg).v;
  throw new Sk.builtin.SystemExit(s);
};
Sk.builtin.sorted = function sorted(iterable, cmp, key, reverse) {
  var compare_func;
  var list;
  if (key !== undefined && !(key instanceof Sk.builtin.none)) {
    if (cmp instanceof Sk.builtin.none) {
      compare_func = {
        func_code: function (a, b) {
          return Sk.misceval.richCompareBool(a[0], b[0], 'Lt') ? new Sk.builtin.nmber(-1, Sk.builtin.nmber.int$) : new Sk.builtin.nmber(0, Sk.builtin.nmber.int$);
        }
      };
    } else {
      compare_func = {
        func_code: function (a, b) {
          return cmp.func_code(a[0], b[0]);
        }
      };
    }
    var iter = iterable.tp$iter();
    var next = iter.tp$iternext();
    var arr = [];
    while (next !== undefined) {
      arr.push([
        key.func_code(next),
        next
      ]);
      next = iter.tp$iternext();
    }
    list = new Sk.builtin.list(arr);
  } else {
    if (!(cmp instanceof Sk.builtin.none) && cmp !== undefined) {
      compare_func = cmp;
    }
    list = new Sk.builtin.list(iterable);
  }
  if (compare_func !== undefined) {
    list.list_sort_(list, compare_func);
  } else {
    list.list_sort_(list);
  }
  if (reverse) {
    list.list_reverse_(list);
  }
  if (key !== undefined && !(key instanceof Sk.builtin.none)) {
    var iter = list.tp$iter();
    var next = iter.tp$iternext();
    var arr = [];
    while (next !== undefined) {
      arr.push(next[1]);
      next = iter.tp$iternext();
    }
    list = new Sk.builtin.list(arr);
  }
  return list;
};
Sk.builtin.bytearray = function bytearray() {
  throw new Sk.builtin.NotImplementedError('bytearray is not yet implemented');
};
Sk.builtin.callable = function callable() {
  throw new Sk.builtin.NotImplementedError('callable is not yet implemented');
};
Sk.builtin.complex = function complex() {
  throw new Sk.builtin.NotImplementedError('complex is not yet implemented');
};
Sk.builtin.delattr = function delattr() {
  throw new Sk.builtin.NotImplementedError('delattr is not yet implemented');
};
Sk.builtin.divmod = function divmod() {
  throw new Sk.builtin.NotImplementedError('divmod is not yet implemented');
};
Sk.builtin.execfile = function execfile() {
  throw new Sk.builtin.NotImplementedError('execfile is not yet implemented');
};
Sk.builtin.format = function format() {
  throw new Sk.builtin.NotImplementedError('format is not yet implemented');
};
Sk.builtin.frozenset = function frozenset() {
  throw new Sk.builtin.NotImplementedError('frozenset is not yet implemented');
};
Sk.builtin.globals = function globals() {
  throw new Sk.builtin.NotImplementedError('globals is not yet implemented');
};
Sk.builtin.help = function help() {
  throw new Sk.builtin.NotImplementedError('help is not yet implemented');
};
Sk.builtin.issubclass = function issubclass() {
  throw new Sk.builtin.NotImplementedError('issubclass is not yet implemented');
};
Sk.builtin.iter = function iter() {
  throw new Sk.builtin.NotImplementedError('iter is not yet implemented');
};
Sk.builtin.locals = function locals() {
  throw new Sk.builtin.NotImplementedError('locals is not yet implemented');
};
Sk.builtin.memoryview = function memoryview() {
  throw new Sk.builtin.NotImplementedError('memoryview is not yet implemented');
};
Sk.builtin.next_ = function next_() {
  throw new Sk.builtin.NotImplementedError('next is not yet implemented');
};
Sk.builtin.property = function property() {
  throw new Sk.builtin.NotImplementedError('property is not yet implemented');
};
Sk.builtin.reload = function reload() {
  throw new Sk.builtin.NotImplementedError('reload is not yet implemented');
};
Sk.builtin.reversed = function reversed() {
  throw new Sk.builtin.NotImplementedError('reversed is not yet implemented');
};
Sk.builtin.unichr = function unichr() {
  throw new Sk.builtin.NotImplementedError('unichr is not yet implemented');
};
Sk.builtin.vars = function vars() {
  throw new Sk.builtin.NotImplementedError('vars is not yet implemented');
};
Sk.builtin.xrange = Sk.builtin.range;
Sk.builtin.apply_ = function apply_() {
  throw new Sk.builtin.NotImplementedError('apply is not yet implemented');
};
Sk.builtin.buffer = function buffer() {
  throw new Sk.builtin.NotImplementedError('buffer is not yet implemented');
};
Sk.builtin.coerce = function coerce() {
  throw new Sk.builtin.NotImplementedError('coerce is not yet implemented');
};
Sk.builtin.intern = function intern() {
  throw new Sk.builtin.NotImplementedError('intern is not yet implemented');
};
Sk.builtin.Exception = function (args) {
  var args = Array.prototype.slice.call(arguments);
  for (var i = 0; i < args.length; ++i) {
    if (typeof args[i] === 'string')
      args[i] = new Sk.builtin.str(args[i]);
  }
  this.args = new Sk.builtin.tuple(args);
  if (Sk.currFilename) {
    this.filename = Sk.currFilename;
  } else if (this.args.sq$length() >= 3) {
    if (this.args.v[1].v) {
      this.filename = this.args.v[1].v;
    } else {
      this.filename = '<unknown>';
    }
  } else {
    this.filename = '<unknown>';
  }
  if (this.args.sq$length() >= 3) {
    this.lineno = this.args.v[2];
  } else if (Sk.currLineNo > 0) {
    this.lineno = Sk.currLineNo;
  } else {
    this.lineno = '<unknown>';
  }
  if (Sk.currColNo > 0) {
    this.colno = Sk.currColNo;
  } else {
    this.colno = '<unknown>';
  }
};
Sk.builtin.Exception.prototype.tp$name = 'Exception';
Sk.builtin.Exception.prototype.tp$str = function () {
  var ret = '';
  ret += this.tp$name;
  if (this.args)
    ret += ': ' + (this.args.v.length > 0 ? this.args.v[0].v : '');
  ret += ' on line ' + this.lineno;
  if (this.args.v.length > 4) {
    ret += '\n' + this.args.v[4].v + '\n';
    for (var i = 0; i < this.args.v[3]; ++i)
      ret += ' ';
    ret += '^\n';
  }
  return new Sk.builtin.str(ret);
};
Sk.builtin.Exception.prototype.toString = function () {
  return this.tp$str().v;
};
goog.exportSymbol('Sk.builtin.Exception', Sk.builtin.Exception);
Sk.builtin.AssertionError = function (args) {
  if (!(this instanceof Sk.builtin.AssertionError)) {
    var o = Object.create(Sk.builtin.AssertionError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.AssertionError, Sk.builtin.Exception);
Sk.builtin.AssertionError.prototype.tp$name = 'AssertionError';
goog.exportSymbol('Sk.builtin.AssertionError', Sk.builtin.AssertionError);
Sk.builtin.AttributeError = function (args) {
  if (!(this instanceof Sk.builtin.AttributeError)) {
    var o = Object.create(Sk.builtin.AttributeError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.AttributeError, Sk.builtin.Exception);
Sk.builtin.AttributeError.prototype.tp$name = 'AttributeError';
Sk.builtin.ImportError = function (args) {
  if (!(this instanceof Sk.builtin.ImportError)) {
    var o = Object.create(Sk.builtin.ImportError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.ImportError, Sk.builtin.Exception);
Sk.builtin.ImportError.prototype.tp$name = 'ImportError';
Sk.builtin.IndentationError = function (args) {
  if (!(this instanceof Sk.builtin.IndentationError)) {
    var o = Object.create(Sk.builtin.IndentationError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.IndentationError, Sk.builtin.Exception);
Sk.builtin.IndentationError.prototype.tp$name = 'IndentationError';
Sk.builtin.IndexError = function (args) {
  if (!(this instanceof Sk.builtin.IndexError)) {
    var o = Object.create(Sk.builtin.IndexError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.IndexError, Sk.builtin.Exception);
Sk.builtin.IndexError.prototype.tp$name = 'IndexError';
Sk.builtin.KeyError = function (args) {
  if (!(this instanceof Sk.builtin.KeyError)) {
    var o = Object.create(Sk.builtin.KeyError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.KeyError, Sk.builtin.Exception);
Sk.builtin.KeyError.prototype.tp$name = 'KeyError';
Sk.builtin.NameError = function (args) {
  if (!(this instanceof Sk.builtin.NameError)) {
    var o = Object.create(Sk.builtin.NameError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.NameError, Sk.builtin.Exception);
Sk.builtin.NameError.prototype.tp$name = 'NameError';
Sk.builtin.OverflowError = function (args) {
  if (!(this instanceof Sk.builtin.OverflowError)) {
    var o = Object.create(Sk.builtin.OverflowError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.OverflowError, Sk.builtin.Exception);
Sk.builtin.OverflowError.prototype.tp$name = 'OverflowError';
Sk.builtin.ParseError = function (args) {
  if (!(this instanceof Sk.builtin.ParseError)) {
    var o = Object.create(Sk.builtin.ParseError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.ParseError, Sk.builtin.Exception);
Sk.builtin.ParseError.prototype.tp$name = 'ParseError';
Sk.builtin.SystemExit = function (args) {
  if (!(this instanceof Sk.builtin.SystemExit)) {
    var o = Object.create(Sk.builtin.SystemExit.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.SystemExit, Sk.builtin.Exception);
Sk.builtin.SystemExit.prototype.tp$name = 'SystemExit';
goog.exportSymbol('Sk.builtin.SystemExit', Sk.builtin.SystemExit);
Sk.builtin.SyntaxError = function (args) {
  if (!(this instanceof Sk.builtin.SyntaxError)) {
    var o = Object.create(Sk.builtin.SyntaxError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.SyntaxError, Sk.builtin.Exception);
Sk.builtin.SyntaxError.prototype.tp$name = 'SyntaxError';
Sk.builtin.TokenError = function (args) {
  if (!(this instanceof Sk.builtin.TokenError)) {
    var o = Object.create(Sk.builtin.TokenError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.TokenError, Sk.builtin.Exception);
Sk.builtin.TokenError.prototype.tp$name = 'TokenError';
Sk.builtin.TypeError = function (args) {
  if (!(this instanceof Sk.builtin.TypeError)) {
    var o = Object.create(Sk.builtin.TypeError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.TypeError, Sk.builtin.Exception);
Sk.builtin.TypeError.prototype.tp$name = 'TypeError';
goog.exportSymbol('Sk.builtin.TypeError', Sk.builtin.TypeError);
Sk.builtin.ValueError = function (args) {
  if (!(this instanceof Sk.builtin.ValueError)) {
    var o = Object.create(Sk.builtin.ValueError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.ValueError, Sk.builtin.Exception);
Sk.builtin.ValueError.prototype.tp$name = 'ValueError';
goog.exportSymbol('Sk.builtin.ValueError', Sk.builtin.ValueError);
Sk.builtin.ZeroDivisionError = function (args) {
  if (!(this instanceof Sk.builtin.ZeroDivisionError)) {
    var o = Object.create(Sk.builtin.ZeroDivisionError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.ZeroDivisionError, Sk.builtin.Exception);
Sk.builtin.ZeroDivisionError.prototype.tp$name = 'ZeroDivisionError';
Sk.builtin.TimeLimitError = function (args) {
  if (!(this instanceof Sk.builtin.TimeLimitError)) {
    var o = Object.create(Sk.builtin.TimeLimitError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.TimeLimitError, Sk.builtin.Exception);
Sk.builtin.TimeLimitError.prototype.tp$name = 'TimeLimitError';
goog.exportSymbol('Sk.builtin.TimeLimitError', Sk.builtin.TimeLimitError);
Sk.builtin.IOError = function (args) {
  if (!(this instanceof Sk.builtin.IOError)) {
    var o = Object.create(Sk.builtin.IOError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.IOError, Sk.builtin.Exception);
Sk.builtin.IOError.prototype.tp$name = 'IOError';
goog.exportSymbol('Sk.builtin.IOError', Sk.builtin.IOError);
Sk.builtin.NotImplementedError = function (args) {
  if (!(this instanceof Sk.builtin.NotImplementedError)) {
    var o = Object.create(Sk.builtin.NotImplementedError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.NotImplementedError, Sk.builtin.Exception);
Sk.builtin.NotImplementedError.prototype.tp$name = 'NotImplementedError';
goog.exportSymbol('Sk.builtin.NotImplementedError', Sk.builtin.NotImplementedError);
Sk.builtin.NegativePowerError = function (args) {
  if (!(this instanceof Sk.builtin.NegativePowerError)) {
    var o = Object.create(Sk.builtin.NegativePowerError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.NegativePowerError, Sk.builtin.Exception);
Sk.builtin.NegativePowerError.prototype.tp$name = 'NegativePowerError';
goog.exportSymbol('Sk.builtin.NegativePowerError', Sk.builtin.NegativePowerError);
Sk.builtin.OperationError = function (args) {
  if (!(this instanceof Sk.builtin.OperationError)) {
    var o = Object.create(Sk.builtin.OperationError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.OperationError, Sk.builtin.Exception);
Sk.builtin.OperationError.prototype.tp$name = 'OperationError';
goog.exportSymbol('Sk.builtin.OperationError', Sk.builtin.OperationError);
Sk.builtin.SystemError = function (args) {
  if (!(this instanceof Sk.builtin.SystemError)) {
    var o = Object.create(Sk.builtin.SystemError.prototype);
    o.constructor.apply(o, arguments);
    return o;
  }
  Sk.builtin.Exception.apply(this, arguments);
};
goog.inherits(Sk.builtin.SystemError, Sk.builtin.Exception);
Sk.builtin.SystemError.prototype.tp$name = 'SystemError';
goog.exportSymbol('Sk.builtin.SystemError', Sk.builtin.SystemError);
Sk.currLineNo = -1;
Sk.currColNo = -1;
Sk.currFilename = '';
goog.exportSymbol('Sk', Sk);
goog.exportProperty(Sk, 'currLineNo', Sk.currLineNo);
goog.exportProperty(Sk, 'currColNo', Sk.currColNo);
goog.exportProperty(Sk, 'currFilename', Sk.currFilename);
Sk.builtin.type = function (name, bases, dict) {
  if (bases === undefined && dict === undefined) {
    var obj = name;
    if (obj.constructor === Sk.builtin.nmber) {
      if (obj.skType === Sk.builtin.nmber.int$) {
        return Sk.builtin.int_.prototype.ob$type;
      } else {
        return Sk.builtin.float_.prototype.ob$type;
      }
    }
    return obj.ob$type;
  } else {
    var klass = function (kwdict, varargseq, kws, args) {
      if (!(this instanceof klass)) {
        return new klass(kwdict, varargseq, kws, args);
      }
      args = args || [];
      this['$d'] = new Sk.builtin.dict([]);
      var init = Sk.builtin.type.typeLookup(this.ob$type, '__init__');
      if (init !== undefined) {
        args.unshift(this);
        Sk.misceval.apply(init, kwdict, varargseq, kws, args);
      }
      return this;
    };
    for (var v in dict) {
      klass.prototype[v] = dict[v];
      klass[v] = dict[v];
    }
    klass['__class__'] = klass;
    klass.sk$klass = true;
    klass.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
    klass.prototype.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;
    klass.prototype.tp$descr_get = function () {
      goog.asserts.fail('in type tp$descr_get');
    };
    klass.prototype.tp$repr = function () {
      var reprf = this.tp$getattr('__repr__');
      if (reprf !== undefined)
        return Sk.misceval.apply(reprf, undefined, undefined, undefined, []);
      var mod = dict.__module__;
      var cname = '';
      if (mod)
        cname = mod.v + '.';
      return new Sk.builtin.str('<' + cname + name + ' object>');
    };
    klass.prototype.tp$str = function () {
      var strf = this.tp$getattr('__str__');
      if (strf !== undefined)
        return Sk.misceval.apply(strf, undefined, undefined, undefined, []);
      return this.tp$repr();
    };
    klass.prototype.tp$length = function () {
      var lenf = this.tp$getattr('__len__');
      if (lenf !== undefined)
        return Sk.misceval.apply(lenf, undefined, undefined, undefined, []);
      var tname = Sk.abstr.typeName(this);
      throw new Sk.builtin.AttributeError(tname + ' instance has no attribute \'__len__\'');
    };
    klass.prototype.tp$call = function (args, kw) {
      var callf = this.tp$getattr('__call__');
      if (callf)
        return Sk.misceval.apply(callf, undefined, undefined, kw, args);
      throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(this) + '\' object is not callable');
    };
    klass.prototype.tp$iter = function () {
      var iterf = this.tp$getattr('__iter__');
      var tname = Sk.abstr.typeName(this);
      if (iterf) {
        var ret = Sk.misceval.callsim(iterf);
        return ret;
      }
      throw new Sk.builtin.TypeError('\'' + tname + '\' object is not iterable');
    };
    klass.prototype.tp$iternext = function () {
      var iternextf = this.tp$getattr('next');
      goog.asserts.assert(iternextf !== undefined, 'iter() should have caught this');
      return Sk.misceval.callsim(iternextf);
    };
    klass.prototype.tp$getitem = function (key) {
      var getf = this.tp$getattr('__getitem__');
      if (getf !== undefined) {
        return Sk.misceval.apply(getf, undefined, undefined, undefined, [key]);
      }
      throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(this) + '\' object does not support indexing');
    };
    klass.prototype.tp$setitem = function (key, value) {
      var setf = this.tp$getattr('__setitem__');
      if (setf !== undefined)
        return Sk.misceval.apply(setf, undefined, undefined, undefined, [
          key,
          value
        ]);
      throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(this) + '\' object does not support item assignment');
    };
    klass.prototype.tp$name = name;
    if (bases) {
      klass['$d'] = new Sk.builtin.dict([]);
      klass['$d'].mp$ass_subscript(Sk.builtin.type.basesStr_, new Sk.builtin.tuple(bases));
      var mro = Sk.builtin.type.buildMRO(klass);
      klass['$d'].mp$ass_subscript(Sk.builtin.type.mroStr_, mro);
      klass.tp$mro = mro;
    }
    klass.prototype.ob$type = klass;
    Sk.builtin.type.makeIntoTypeObj(name, klass);
    klass.tp$setattr = Sk.builtin.type.prototype.tp$setattr;
    return klass;
  }
};
Sk.builtin.type.makeTypeObj = function (name, newedInstanceOfType) {
  var t = newedInstanceOfType;
  Sk.builtin.type.makeIntoTypeObj(name, t);
  return newedInstanceOfType;
};
Sk.builtin.type.makeIntoTypeObj = function (name, t) {
  goog.asserts.assert(name !== undefined);
  goog.asserts.assert(t !== undefined);
  t.ob$type = Sk.builtin.type;
  t.tp$name = name;
  t.tp$repr = function () {
    var mod = t.__module__;
    var cname = '';
    if (mod)
      cname = mod.v + '.';
    var ctype = 'class';
    if (!mod && !t.sk$klass)
      ctype = 'type';
    return new Sk.builtin.str('<' + ctype + ' \'' + cname + t.tp$name + '\'>');
  };
  t.tp$str = undefined;
  t.tp$getattr = Sk.builtin.type.prototype.tp$getattr;
  t.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;
  t.tp$richcompare = Sk.builtin.type.prototype.tp$richcompare;
  t.sk$type = true;
  return t;
};
Sk.builtin.type.ob$type = Sk.builtin.type;
Sk.builtin.type.tp$name = 'type';
Sk.builtin.type.tp$repr = function () {
  return new Sk.builtin.str('<type \'type\'>');
};
Sk.builtin.type.prototype.tp$getattr = function (name) {
  var tp = this;
  var descr = Sk.builtin.type.typeLookup(tp, name);
  var f;
  if (descr !== undefined && descr !== null && descr.ob$type !== undefined) {
    f = descr.ob$type.tp$descr_get;
  }
  if (this['$d']) {
    var res = this['$d'].mp$lookup(new Sk.builtin.str(name));
    if (res !== undefined) {
      return res;
    }
  }
  if (f) {
    return f.call(descr, null, tp);
  }
  if (descr !== undefined) {
    return descr;
  }
  return undefined;
};
Sk.builtin.type.prototype.tp$setattr = function (name, value) {
  this[name] = value;
};
Sk.builtin.type.typeLookup = function (type, name) {
  var mro = type.tp$mro;
  var pyname = new Sk.builtin.str(name);
  var base;
  var res;
  var i;
  if (!mro)
    return type.prototype[name];
  for (i = 0; i < mro.v.length; ++i) {
    base = mro.v[i];
    if (base.hasOwnProperty(name))
      return base[name];
    res = base['$d'].mp$lookup(pyname);
    if (res !== undefined) {
      return res;
    }
  }
  return undefined;
};
Sk.builtin.type.mroMerge_ = function (seqs) {
  var res = [];
  for (;;) {
    for (var i = 0; i < seqs.length; ++i) {
      var seq = seqs[i];
      if (seq.length !== 0)
        break;
    }
    if (i === seqs.length)
      return res;
    var cands = [];
    for (var i = 0; i < seqs.length; ++i) {
      var seq = seqs[i];
      if (seq.length !== 0) {
        var cand = seq[0];
        OUTER:
          for (var j = 0; j < seqs.length; ++j) {
            var sseq = seqs[j];
            for (var k = 1; k < sseq.length; ++k)
              if (sseq[k] === cand)
                break OUTER;
          }
        if (j === seqs.length)
          cands.push(cand);
      }
    }
    if (cands.length === 0)
      throw new Sk.builtin.TypeError('Inconsistent precedences in type hierarchy');
    var next = cands[0];
    res.push(next);
    for (var i = 0; i < seqs.length; ++i) {
      var seq = seqs[i];
      if (seq.length > 0 && seq[0] === next)
        seq.splice(0, 1);
    }
  }
};
Sk.builtin.type.buildMRO_ = function (klass) {
  var all = [[klass]];
  var kbases = klass['$d'].mp$subscript(Sk.builtin.type.basesStr_);
  for (var i = 0; i < kbases.v.length; ++i)
    all.push(Sk.builtin.type.buildMRO_(kbases.v[i]));
  var bases = [];
  for (var i = 0; i < kbases.v.length; ++i)
    bases.push(kbases.v[i]);
  all.push(bases);
  return Sk.builtin.type.mroMerge_(all);
};
Sk.builtin.type.buildMRO = function (klass) {
  return new Sk.builtin.tuple(Sk.builtin.type.buildMRO_(klass));
};
Sk.builtin.type.prototype.tp$richcompare = function (other, op) {
  if (other.ob$type != Sk.builtin.type)
    return undefined;
  if (!this.tp$repr || !other.tp$repr)
    return undefined;
  var r1 = this.tp$repr();
  var r2 = other.tp$repr();
  return r1.tp$richcompare(r2, op);
};
Sk.builtin.object = function () {
  if (!(this instanceof Sk.builtin.object))
    return new Sk.builtin.object();
  this['$d'] = new Sk.builtin.dict([]);
  return this;
};
Sk.builtin.object.prototype.GenericGetAttr = function (name) {
  goog.asserts.assert(typeof name === 'string');
  var tp = this.ob$type;
  goog.asserts.assert(tp !== undefined, 'object has no ob$type!');
  var descr = Sk.builtin.type.typeLookup(tp, name);
  var f;
  if (descr !== undefined && descr !== null && descr.ob$type !== undefined) {
    f = descr.ob$type.tp$descr_get;
  }
  if (this['$d']) {
    var res;
    if (this['$d'].mp$lookup) {
      res = this['$d'].mp$lookup(new Sk.builtin.str(name));
    } else if (this['$d'].mp$subscript) {
      try {
        res = this['$d'].mp$subscript(new Sk.builtin.str(name));
      } catch (x) {
        res = undefined;
      }
    } else if (typeof this['$d'] === 'object')
      res = this['$d'][name];
    if (res !== undefined)
      return res;
  }
  if (f) {
    return f.call(descr, this, this.ob$type);
  }
  if (descr !== undefined) {
    return descr;
  }
  return undefined;
};
goog.exportSymbol('Sk.builtin.object.prototype.GenericGetAttr', Sk.builtin.object.prototype.GenericGetAttr);
Sk.builtin.object.prototype.GenericSetAttr = function (name, value) {
  goog.asserts.assert(typeof name === 'string');
  if (this['$d'].mp$ass_subscript)
    this['$d'].mp$ass_subscript(new Sk.builtin.str(name), value);
  else if (typeof this['$d'] === 'object')
    this['$d'][name] = value;
};
goog.exportSymbol('Sk.builtin.object.prototype.GenericSetAttr', Sk.builtin.object.prototype.GenericSetAttr);
Sk.builtin.object.prototype.HashNotImplemented = function () {
  throw new Sk.builtin.TypeError('unhashable type: \'' + Sk.abstr.typeName(this) + '\'');
};
Sk.builtin.object.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
Sk.builtin.object.prototype.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;
Sk.builtin.object.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('object', Sk.builtin.object);
Sk.builtin.none = function () {
};
Sk.builtin.none.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('NoneType', Sk.builtin.none);
Sk.builtin.none.prototype.tp$name = 'NoneType';
Sk.builtin.none.none$ = Object.create(Sk.builtin.none.prototype, {
  v: {
    value: null,
    enumerable: true
  }
});
goog.exportSymbol('Sk.builtin.none', Sk.builtin.none);
Sk.builtin.bool = function (x) {
  Sk.ffi.checkFunctionArgs('bool', arguments, 1);
  if (Sk.misceval.isTrue(x)) {
    return Sk.builtin.bool.true$;
  } else {
    return Sk.builtin.bool.false$;
  }
};
Sk.builtin.bool.prototype.tp$name = 'bool';
Sk.builtin.bool.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('bool', Sk.builtin.bool);
Sk.builtin.bool.true$ = Object.create(Sk.builtin.bool.prototype, {
  v: {
    value: true,
    enumerable: true
  }
});
Sk.builtin.bool.false$ = Object.create(Sk.builtin.bool.prototype, {
  v: {
    value: false,
    enumerable: true
  }
});
Sk.builtin.bool.prototype.tp$str = function () {
  if (this.v) {
    return new Sk.builtin.str('True');
  } else {
    return new Sk.builtin.str('False');
  }
};
Sk.builtin.bool.prototype.tp$repr = function () {
  if (this.v) {
    return new Sk.builtin.str('True');
  } else {
    return new Sk.builtin.str('False');
  }
};
goog.exportSymbol('Sk.builtin.bool', Sk.builtin.bool);
Sk.builtin.pyCheckArgs = function (name, args, minargs, maxargs, kwargs, free) {
  var nargs = args.length;
  var msg = '';
  if (maxargs === undefined) {
    maxargs = Infinity;
  }
  if (kwargs) {
    nargs -= 1;
  }
  if (free) {
    nargs -= 1;
  }
  if (nargs < minargs || nargs > maxargs) {
    if (minargs === maxargs) {
      msg = name + '() takes exactly ' + minargs + ' arguments';
    } else if (nargs < minargs) {
      msg = name + '() takes at least ' + minargs + ' arguments';
    } else {
      msg = name + '() takes at most ' + maxargs + ' arguments';
    }
    msg += ' (' + nargs + ' given)';
    throw new Sk.builtin.TypeError(msg);
  }
  ;
};
goog.exportSymbol('Sk.builtin.pyCheckArgs', Sk.builtin.pyCheckArgs);
Sk.builtin.pyCheckType = function (name, exptype, check) {
  if (!check) {
    throw new Sk.builtin.TypeError(name + ' must be a ' + exptype);
  }
  ;
};
goog.exportSymbol('Sk.builtin.pyCheckType', Sk.builtin.pyCheckType);
Sk.builtin.checkSequence = function (arg) {
  return arg !== null && arg.mp$subscript !== undefined;
};
goog.exportSymbol('Sk.builtin.checkSequence', Sk.builtin.checkSequence);
Sk.builtin.checkIterable = function (arg) {
  return arg !== null && arg.tp$iter !== undefined;
};
goog.exportSymbol('Sk.builtin.checkIterable', Sk.builtin.checkIterable);
Sk.builtin.checkNumber = function (arg) {
  return arg !== null && (typeof arg === 'number' || arg instanceof Sk.builtin.nmber || arg instanceof Sk.builtin.lng);
};
goog.exportSymbol('Sk.builtin.checkNumber', Sk.builtin.checkNumber);
Sk.builtin.checkInt = function (arg) {
  return arg !== null && (typeof arg === 'number' && arg === (arg | 0) || arg instanceof Sk.builtin.nmber && arg.skType === Sk.builtin.nmber.int$ || arg instanceof Sk.builtin.lng);
};
goog.exportSymbol('Sk.builtin.checkInt', Sk.builtin.checkInt);
Sk.builtin.checkString = function (arg) {
  return arg !== null && arg.__class__ == Sk.builtin.str;
};
goog.exportSymbol('Sk.builtin.checkString', Sk.builtin.checkString);
Sk.builtin.checkClass = function (arg) {
  return arg !== null && arg.sk$type;
};
goog.exportSymbol('Sk.builtin.checkClass', Sk.builtin.checkClass);
Sk.builtin.checkBool = function (arg) {
  return arg instanceof Sk.builtin.bool;
};
goog.exportSymbol('Sk.builtin.checkBool', Sk.builtin.checkBool);
Sk.builtin.checkFunction = function (arg) {
  return arg !== null && arg.tp$call !== undefined;
};
goog.exportSymbol('Sk.builtin.checkFunction', Sk.builtin.checkFunction);
Sk.builtin.func = function (code, globals, cellVars, freeVars) {
  this.func_code = code;
  this.func_globals = globals || null;
  if (freeVars !== undefined) {
    for (var k in freeVars)
      cellVars[k] = freeVars[k];
  }
  this.func_closure = cellVars;
  return this;
};
goog.exportSymbol('Sk.builtin.func', Sk.builtin.func);
Sk.builtin.func.prototype.tp$name = 'function';
Sk.builtin.func.prototype.tp$descr_get = function (obj, objtype) {
  goog.asserts.assert(obj !== undefined && objtype !== undefined);
  if (obj == null)
    return this;
  return new Sk.builtin.method(this, obj);
};
Sk.builtin.func.prototype.tp$call = function (args, kw) {
  var name;
  if (this.func_closure) {
    args.push(this.func_closure);
  }
  var expectskw = this.func_code['co_kwargs'];
  var kwargsarr = [];
  if (this.func_code['no_kw'] && kw) {
    name = this.func_code && this.func_code['co_name'] && this.func_code['co_name'].v || '<native JS>';
    throw new Sk.builtin.TypeError(name + '() takes no keyword arguments');
  }
  if (kw) {
    var kwlen = kw.length;
    var varnames = this.func_code['co_varnames'];
    var numvarnames = varnames && varnames.length;
    for (var i = 0; i < kwlen; i += 2) {
      for (var j = 0; j < numvarnames; ++j) {
        if (kw[i] === varnames[j])
          break;
      }
      if (varnames && j !== numvarnames) {
        args[j] = kw[i + 1];
      } else if (expectskw) {
        kwargsarr.push(new Sk.builtin.str(kw[i]));
        kwargsarr.push(kw[i + 1]);
      } else {
        name = this.func_code && this.func_code['co_name'] && this.func_code['co_name'].v || '<native JS>';
        throw new Sk.builtin.TypeError(name + '() got an unexpected keyword argument \'' + kw[i] + '\'');
      }
    }
  }
  if (expectskw) {
    args.unshift(kwargsarr);
  }
  return this.func_code.apply(this.func_globals, args);
};
Sk.builtin.func.prototype.tp$getattr = function (key) {
  return this[key];
};
Sk.builtin.func.prototype.tp$setattr = function (key, value) {
  this[key] = value;
};
Sk.builtin.func.prototype.ob$type = Sk.builtin.type.makeTypeObj('function', new Sk.builtin.func(null, null));
Sk.builtin.func.prototype.tp$repr = function () {
  var name = this.func_code && this.func_code['co_name'] && this.func_code['co_name'].v || '<native JS>';
  return new Sk.builtin.str('<function ' + name + '>');
};
Sk.nativejs = {
  FN_ARGS: /^function\s*[^\(]*\(\s*([^\)]*)\)/m,
  FN_ARG_SPLIT: /,/,
  FN_ARG: /^\s*(_?)(\S+?)\1\s*$/,
  STRIP_COMMENTS: /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm,
  formalParameterList: function (fn) {
    var fnText, argDecl;
    var args = [];
    fnText = fn.toString().replace(this.STRIP_COMMENTS, '');
    argDecl = fnText.match(this.FN_ARGS);
    var r = argDecl[1].split(this.FN_ARG_SPLIT);
    for (var a in r) {
      var arg = r[a];
      arg.replace(this.FN_ARG, function (all, underscore, name) {
        args.push(name);
      });
    }
    return args;
  },
  func: function (code) {
    code['co_name'] = new Sk.builtin.str(code.name);
    code['co_varnames'] = Sk.nativejs.formalParameterList(code);
    return new Sk.builtin.func(code);
  },
  func_nokw: function (code) {
    code['co_name'] = new Sk.builtin.str(code.name);
    code['co_varnames'] = Sk.nativejs.formalParameterList(code);
    code['no_kw'] = true;
    return new Sk.builtin.func(code);
  }
};
goog.exportSymbol('Sk.nativejs.func', Sk.nativejs.func);
goog.exportSymbol('Sk.nativejs.func_nokw', Sk.nativejs.func_nokw);
Sk.builtin.method = function (func, self) {
  this.im_func = func;
  this.im_self = self;
};
goog.exportSymbol('Sk.builtin.method', Sk.builtin.method);
Sk.builtin.method.prototype.tp$call = function (args, kw) {
  goog.asserts.assert(this.im_self, 'should just be a function, not a method since there\'s no self?');
  goog.asserts.assert(this.im_func instanceof Sk.builtin.func);
  args.unshift(this.im_self);
  if (kw) {
    var kwlen = kw.length;
    for (var i = 0; i < kwlen; i += 2) {
      var varnames = this.im_func.func_code['co_varnames'];
      var numvarnames = varnames && varnames.length;
      for (var j = 0; j < numvarnames; ++j) {
        if (kw[i] === varnames[j])
          break;
      }
      args[j] = kw[i + 1];
    }
  }
  return this.im_func.func_code.apply(this.im_func.func_globals, args);
};
Sk.builtin.method.prototype.tp$repr = function () {
  var name = this.im_func.func_code && this.im_func.func_code['co_name'] && this.im_func.func_code['co_name'].v || '<native JS>';
  return new Sk.builtin.str('<bound method ' + this.im_self.ob$type.tp$name + '.' + name + ' of ' + this.im_self.tp$repr().v + '>');
};
Sk.misceval = {};
Sk.misceval.isIndex = function (o) {
  if (o === null || o.constructor === Sk.builtin.lng || o.tp$index || o === true || o === false) {
    return true;
  }
  return Sk.builtin.checkInt(o);
};
goog.exportSymbol('Sk.misceval.isIndex', Sk.misceval.isIndex);
Sk.misceval.asIndex = function (o) {
  if (!Sk.misceval.isIndex(o))
    return undefined;
  if (o === null)
    return undefined;
  if (o === true)
    return 1;
  if (o === false)
    return 0;
  if (typeof o === 'number')
    return o;
  if (o.constructor === Sk.builtin.nmber)
    return o.v;
  if (o.constructor === Sk.builtin.lng)
    return o.tp$index();
  goog.asserts.fail('todo;');
};
Sk.misceval.applySlice = function (u, v, w) {
  if (u.sq$slice && Sk.misceval.isIndex(v) && Sk.misceval.isIndex(w)) {
    var ilow = Sk.misceval.asIndex(v);
    if (ilow === undefined)
      ilow = 0;
    var ihigh = Sk.misceval.asIndex(w);
    if (ihigh === undefined)
      ihigh = 1e+100;
    return Sk.abstr.sequenceGetSlice(u, ilow, ihigh);
  }
  return Sk.abstr.objectGetItem(u, new Sk.builtin.slice(v, w, null));
};
goog.exportSymbol('Sk.misceval.applySlice', Sk.misceval.applySlice);
Sk.misceval.assignSlice = function (u, v, w, x) {
  if (u.sq$ass_slice && Sk.misceval.isIndex(v) && Sk.misceval.isIndex(w)) {
    var ilow = Sk.misceval.asIndex(v) || 0;
    var ihigh = Sk.misceval.asIndex(w) || 1e+100;
    if (x === null)
      Sk.abstr.sequenceDelSlice(u, ilow, ihigh);
    else
      Sk.abstr.sequenceSetSlice(u, ilow, ihigh, x);
  } else {
    var slice = new Sk.builtin.slice(v, w);
    if (x === null)
      return Sk.abstr.objectDelItem(u, slice);
    else
      return Sk.abstr.objectSetItem(u, slice, x);
  }
};
goog.exportSymbol('Sk.misceval.assignSlice', Sk.misceval.assignSlice);
Sk.misceval.arrayFromArguments = function (args) {
  if (args.length != 1) {
    return args;
  }
  var arg = args[0];
  if (arg instanceof Sk.builtin.set) {
    arg = arg.tp$iter().$obj;
  } else if (arg instanceof Sk.builtin.dict) {
    arg = Sk.builtin.dict.prototype['keys'].func_code(arg);
  } else if (arg instanceof Sk.builtin.str) {
    var res = [];
    for (var it = arg.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {
      res.push(i);
    }
    return res;
  }
  if (arg instanceof Sk.builtin.list || arg instanceof Sk.builtin.tuple) {
    return arg.v;
  }
  return args;
};
goog.exportSymbol('Sk.misceval.arrayFromArguments', Sk.misceval.arrayFromArguments);
Sk.misceval.swappedOp_ = {
  'Eq': 'Eq',
  'NotEq': 'NotEq',
  'Lt': 'GtE',
  'LtE': 'Gt',
  'Gt': 'LtE',
  'GtE': 'Lt',
  'Is': 'IsNot',
  'IsNot': 'Is',
  'In_': 'NotIn',
  'NotIn': 'In_'
};
Sk.misceval.richCompareBool = function (v, w, op) {
  goog.asserts.assert(v !== null && v !== undefined, 'passed undefined or null parameter to Sk.misceval.richCompareBool');
  goog.asserts.assert(w !== null && w !== undefined, 'passed undefined or null parameter to Sk.misceval.richCompareBool');
  var v_type = new Sk.builtin.type(v);
  var w_type = new Sk.builtin.type(w);
  if (v_type !== w_type && (op === 'GtE' || op === 'Gt' || op === 'LtE' || op === 'Lt')) {
    var numeric_types = [
        Sk.builtin.float_.prototype.ob$type,
        Sk.builtin.int_.prototype.ob$type,
        Sk.builtin.lng.prototype.ob$type,
        Sk.builtin.bool.prototype.ob$type
      ];
    var sequence_types = [
        Sk.builtin.dict.prototype.ob$type,
        Sk.builtin.enumerate.prototype.ob$type,
        Sk.builtin.list.prototype.ob$type,
        Sk.builtin.str.prototype.ob$type,
        Sk.builtin.tuple.prototype.ob$type
      ];
    var v_num_type = numeric_types.indexOf(v_type);
    var v_seq_type = sequence_types.indexOf(v_type);
    var w_num_type = numeric_types.indexOf(w_type);
    var w_seq_type = sequence_types.indexOf(w_type);
    if (v_type === Sk.builtin.none.prototype.ob$type) {
      switch (op) {
      case 'Lt':
        return true;
      case 'LtE':
        return true;
      case 'Gt':
        return false;
      case 'GtE':
        return false;
      }
    }
    if (w_type === Sk.builtin.none.prototype.ob$type) {
      switch (op) {
      case 'Lt':
        return false;
      case 'LtE':
        return false;
      case 'Gt':
        return true;
      case 'GtE':
        return true;
      }
    }
    if (v_num_type !== -1 && w_seq_type !== -1) {
      switch (op) {
      case 'Lt':
        return true;
      case 'LtE':
        return true;
      case 'Gt':
        return false;
      case 'GtE':
        return false;
      }
    }
    if (v_seq_type !== -1 && w_num_type !== -1) {
      switch (op) {
      case 'Lt':
        return false;
      case 'LtE':
        return false;
      case 'Gt':
        return true;
      case 'GtE':
        return true;
      }
    }
    if (v_seq_type !== -1 && w_seq_type !== -1) {
      switch (op) {
      case 'Lt':
        return v_seq_type < w_seq_type;
      case 'LtE':
        return v_seq_type <= w_seq_type;
      case 'Gt':
        return v_seq_type > w_seq_type;
      case 'GtE':
        return v_seq_type >= w_seq_type;
      }
    }
  }
  if (op === 'Is') {
    if (v instanceof Sk.builtin.nmber && w instanceof Sk.builtin.nmber) {
      return v.numberCompare(w) === 0 && v.skType === w.skType;
    } else if (v instanceof Sk.builtin.lng && w instanceof Sk.builtin.lng) {
      return v.longCompare(w) === 0;
    }
    return v === w;
  }
  if (op === 'IsNot') {
    if (v instanceof Sk.builtin.nmber && w instanceof Sk.builtin.nmber) {
      return v.numberCompare(w) !== 0 || v.skType !== w.skType;
    } else if (v instanceof Sk.builtin.lng && w instanceof Sk.builtin.lng) {
      return v.longCompare(w) !== 0;
    }
    return v !== w;
  }
  if (op === 'In')
    return Sk.abstr.sequenceContains(w, v);
  if (op === 'NotIn')
    return !Sk.abstr.sequenceContains(w, v);
  var res;
  if (v.tp$richcompare && (res = v.tp$richcompare(w, op)) !== undefined) {
    return res;
  }
  if (w.tp$richcompare && (res = w.tp$richcompare(v, Sk.misceval.swappedOp_[op])) !== undefined) {
    return res;
  }
  var op2method = {
      'Eq': '__eq__',
      'NotEq': '__ne__',
      'Gt': '__gt__',
      'GtE': '__ge__',
      'Lt': '__lt__',
      'LtE': '__le__'
    };
  var method = op2method[op];
  var swapped_method = op2method[Sk.misceval.swappedOp_[op]];
  if (v[method]) {
    return Sk.misceval.callsim(v[method], v, w);
  } else if (w[swapped_method]) {
    return Sk.misceval.callsim(w[swapped_method], w, v);
  }
  if (v['__cmp__']) {
    var ret = Sk.misceval.callsim(v['__cmp__'], v, w);
    ret = Sk.builtin.asnum$(ret);
    if (op === 'Eq')
      return ret === 0;
    else if (op === 'NotEq')
      return ret !== 0;
    else if (op === 'Lt')
      return ret < 0;
    else if (op === 'Gt')
      return ret > 0;
    else if (op === 'LtE')
      return ret <= 0;
    else if (op === 'GtE')
      return ret >= 0;
  }
  if (w['__cmp__']) {
    var ret = Sk.misceval.callsim(w['__cmp__'], w, v);
    ret = Sk.builtin.asnum$(ret);
    if (op === 'Eq')
      return ret === 0;
    else if (op === 'NotEq')
      return ret !== 0;
    else if (op === 'Lt')
      return ret > 0;
    else if (op === 'Gt')
      return ret < 0;
    else if (op === 'LtE')
      return ret >= 0;
    else if (op === 'GtE')
      return ret <= 0;
  }
  if (v instanceof Sk.builtin.none && w instanceof Sk.builtin.none || v instanceof Sk.builtin.bool && w instanceof Sk.builtin.bool) {
    if (op === 'Eq')
      return v.v === w.v;
    if (op === 'NotEq')
      return v.v !== w.v;
    if (op === 'Gt')
      return v.v > w.v;
    if (op === 'GtE')
      return v.v >= w.v;
    if (op === 'Lt')
      return v.v < w.v;
    if (op === 'LtE')
      return v.v <= w.v;
  }
  if (op === 'Eq') {
    if (v instanceof Sk.builtin.str && w instanceof Sk.builtin.str)
      return v.v === w.v;
    return v === w;
  }
  if (op === 'NotEq') {
    if (v instanceof Sk.builtin.str && w instanceof Sk.builtin.str)
      return v.v !== w.v;
    return v !== w;
  }
  var vname = Sk.abstr.typeName(v);
  var wname = Sk.abstr.typeName(w);
  throw new Sk.builtin.ValueError('don\'t know how to compare \'' + vname + '\' and \'' + wname + '\'');
};
goog.exportSymbol('Sk.misceval.richCompareBool', Sk.misceval.richCompareBool);
Sk.misceval.objectRepr = function (v) {
  goog.asserts.assert(v !== undefined, 'trying to repr undefined');
  if (v === null || v instanceof Sk.builtin.none)
    return new Sk.builtin.str('None');
  else if (v === true)
    return new Sk.builtin.str('True');
  else if (v === false)
    return new Sk.builtin.str('False');
  else if (typeof v === 'number')
    return new Sk.builtin.str('' + v);
  else if (!v.tp$repr) {
    if (v.tp$name) {
      return new Sk.builtin.str('<' + v.tp$name + ' object>');
    } else {
      return new Sk.builtin.str('<unknown>');
    }
    ;
  } else if (v.constructor === Sk.builtin.nmber) {
    if (v.v === Infinity)
      return new Sk.builtin.str('inf');
    else if (v.v === -Infinity)
      return new Sk.builtin.str('-inf');
    else
      return new Sk.builtin.str('' + v.v);
  } else
    return v.tp$repr();
};
goog.exportSymbol('Sk.misceval.objectRepr', Sk.misceval.objectRepr);
Sk.misceval.opAllowsEquality = function (op) {
  switch (op) {
  case 'LtE':
  case 'Eq':
  case 'GtE':
    return true;
  }
  return false;
};
goog.exportSymbol('Sk.misceval.opAllowsEquality', Sk.misceval.opAllowsEquality);
Sk.misceval.isTrue = function (x) {
  if (x === true)
    return true;
  if (x === false)
    return false;
  if (x === null)
    return false;
  if (x.constructor === Sk.builtin.none)
    return false;
  if (x.constructor === Sk.builtin.bool)
    return x.v;
  if (typeof x === 'number')
    return x !== 0;
  if (x instanceof Sk.builtin.lng)
    return x.nb$nonzero();
  if (x.constructor === Sk.builtin.nmber)
    return x.v !== 0;
  if (x.mp$length)
    return x.mp$length() !== 0;
  if (x.sq$length)
    return x.sq$length() !== 0;
  return true;
};
goog.exportSymbol('Sk.misceval.isTrue', Sk.misceval.isTrue);
Sk.misceval.softspace_ = false;
Sk.misceval.print_ = function (x) {
  if (Sk.misceval.softspace_) {
    if (x !== '\n')
      Sk.output(' ');
    Sk.misceval.softspace_ = false;
  }
  var s = new Sk.builtin.str(x);
  Sk.output(s.v);
  var isspace = function (c) {
    return c === '\n' || c === '\t' || c === '\r';
  };
  if (s.v.length === 0 || !isspace(s.v[s.v.length - 1]) || s.v[s.v.length - 1] === ' ')
    Sk.misceval.softspace_ = true;
};
goog.exportSymbol('Sk.misceval.print_', Sk.misceval.print_);
Sk.misceval.loadname = function (name, other) {
  var v = other[name];
  if (v !== undefined)
    return v;
  var bi = Sk.builtins[name];
  if (bi !== undefined)
    return bi;
  name = name.replace('_$rw$', '');
  name = name.replace('_$rn$', '');
  throw new Sk.builtin.NameError('name \'' + name + '\' is not defined');
};
goog.exportSymbol('Sk.misceval.loadname', Sk.misceval.loadname);
Sk.misceval.call = function (func, kwdict, varargseq, kws, args) {
  var args = Array.prototype.slice.call(arguments, 4);
  return Sk.misceval.apply(func, kwdict, varargseq, kws, args);
};
goog.exportSymbol('Sk.misceval.call', Sk.misceval.call);
Sk.misceval.callsim = function (func, args) {
  var args = Array.prototype.slice.call(arguments, 1);
  return Sk.misceval.apply(func, undefined, undefined, undefined, args);
};
goog.exportSymbol('Sk.misceval.callsim', Sk.misceval.callsim);
Sk.misceval.apply = function (func, kwdict, varargseq, kws, args) {
  if (func === null || func instanceof Sk.builtin.none) {
    throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(func) + '\' object is not callable');
  } else if (typeof func === 'function') {
    if (func.sk$klass) {
      return func.apply(null, [
        kwdict,
        varargseq,
        kws,
        args
      ]);
    }
    if (varargseq) {
      for (var it = varargseq.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {
        args.push(i);
      }
    }
    if (kwdict) {
      goog.asserts.fail('kwdict not implemented;');
    }
    goog.asserts.assert(kws === undefined || kws.length === 0);
    return func.apply(null, args);
  } else {
    var fcall = func.tp$call;
    if (fcall !== undefined) {
      if (varargseq) {
        for (var it = varargseq.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {
          args.push(i);
        }
      }
      if (kwdict) {
        goog.asserts.fail('kwdict not implemented;');
      }
      return fcall.call(func, args, kws, kwdict);
    }
    fcall = func.__call__;
    if (fcall !== undefined) {
      args.unshift(func);
      return Sk.misceval.apply(fcall, kws, args, kwdict, varargseq);
    }
    throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(func) + '\' object is not callable');
  }
};
goog.exportSymbol('Sk.misceval.apply', Sk.misceval.apply);
Sk.misceval.buildClass = function (globals, func, name, bases) {
  var meta = Sk.builtin.type;
  var locals = {};
  func(globals, locals, []);
  locals.__module__ = globals['__name__'];
  var klass = Sk.misceval.callsim(meta, name, bases, locals);
  return klass;
};
goog.exportSymbol('Sk.misceval.buildClass', Sk.misceval.buildClass);
Sk.abstr = {};
Sk.abstr.typeName = function (valuePy) {
  if (valuePy instanceof Sk.builtin.nmber) {
    return valuePy.skType;
  } else if (valuePy.tp$name !== undefined) {
    return valuePy.tp$name;
  } else {
    return '<invalid type>';
  }
};
Sk.abstr.binop_type_error = function (lhsPy, rhsPy, name) {
  var lhs = Sk.abstr.typeName(lhsPy);
  var rhs = Sk.abstr.typeName(rhsPy);
  throw new Sk.builtin.TypeError('unsupported operand type(s) for ' + name + ': \'' + lhs + '\' and \'' + rhs + '\'');
};
Sk.abstr.boNameToSlotFuncLhs_ = function (obj, name) {
  if (obj === null) {
    return undefined;
  }
  ;
  switch (name) {
  case 'Add':
    return obj.nb$add ? obj.nb$add : obj['__add__'];
  case 'Sub':
    return obj.nb$subtract ? obj.nb$subtract : obj['__sub__'];
  case 'Mult':
    return obj.nb$multiply ? obj.nb$multiply : obj['__mul__'];
  case 'Div':
    return obj.nb$divide ? obj.nb$divide : obj['__div__'];
  case 'FloorDiv':
    return obj.nb$floor_divide ? obj.nb$floor_divide : obj['__floordiv__'];
  case 'Mod':
    return obj.nb$remainder ? obj.nb$remainder : obj['__mod__'];
  case 'Pow':
    return obj.nb$power ? obj.nb$power : obj['__pow__'];
  case 'LShift':
    return obj.nb$lshift ? obj.nb$lshift : obj['__lshift__'];
  case 'RShift':
    return obj.nb$rshift ? obj.nb$rshift : obj['__rshift__'];
  case 'BitAnd':
    return obj.nb$and ? obj.nb$and : obj['__and__'];
  case 'BitXor':
    return obj.nb$xor ? obj.nb$xor : obj['__xor__'];
  case 'BitOr':
    return obj.nb$or ? obj.nb$or : obj['__or__'];
  }
};
Sk.abstr.boNameToSlotFuncRhs_ = function (obj, name) {
  if (obj === null) {
    return undefined;
  }
  ;
  switch (name) {
  case 'Add':
    return obj.nb$add ? obj.nb$add : obj['__radd__'];
  case 'Sub':
    return obj.nb$subtract ? obj.nb$subtract : obj['__rsub__'];
  case 'Mult':
    return obj.nb$multiply ? obj.nb$multiply : obj['__rmul__'];
  case 'Div':
    return obj.nb$divide ? obj.nb$divide : obj['__rdiv__'];
  case 'FloorDiv':
    return obj.nb$floor_divide ? obj.nb$floor_divide : obj['__rfloordiv__'];
  case 'Mod':
    return obj.nb$remainder ? obj.nb$remainder : obj['__rmod__'];
  case 'Pow':
    return obj.nb$power ? obj.nb$power : obj['__rpow__'];
  case 'LShift':
    return obj.nb$lshift ? obj.nb$lshift : obj['__rlshift__'];
  case 'RShift':
    return obj.nb$rshift ? obj.nb$rshift : obj['__rrshift__'];
  case 'BitAnd':
    return obj.nb$and ? obj.nb$and : obj['__rand__'];
  case 'BitXor':
    return obj.nb$xor ? obj.nb$xor : obj['__rxor__'];
  case 'BitOr':
    return obj.nb$or ? obj.nb$or : obj['__ror__'];
  }
};
Sk.abstr.iboNameToSlotFunc_ = function (obj, name) {
  if (obj === null) {
    return undefined;
  }
  ;
  switch (name) {
  case 'Add':
    return obj.nb$inplace_add ? obj.nb$inplace_add : obj['__iadd__'];
  case 'Sub':
    return obj.nb$inplace_subtract ? obj.nb$inplace_subtract : obj['__isub__'];
  case 'Mult':
    return obj.nb$inplace_multiply ? obj.nb$inplace_multiply : obj['__imul__'];
  case 'Div':
    return obj.nb$inplace_divide ? obj.nb$inplace_divide : obj['__idiv__'];
  case 'FloorDiv':
    return obj.nb$inplace_floor_divide ? obj.nb$inplace_floor_divide : obj['__ifloordiv__'];
  case 'Mod':
    return obj.nb$inplace_remainder;
  case 'Pow':
    return obj.nb$inplace_power;
  case 'LShift':
    return obj.nb$inplace_lshift ? obj.nb$inplace_lshift : obj['__ilshift__'];
  case 'RShift':
    return obj.nb$inplace_rshift ? obj.nb$inplace_rshift : obj['__irshift__'];
  case 'BitAnd':
    return obj.nb$inplace_and;
  case 'BitOr':
    return obj.nb$inplace_or;
  case 'BitXor':
    return obj.nb$inplace_xor ? obj.nb$inplace_xor : obj['__ixor__'];
  }
};
Sk.abstr.binary_op_ = function (v, w, opname) {
  var ret;
  var vop = Sk.abstr.boNameToSlotFuncLhs_(v, opname);
  if (vop !== undefined) {
    if (vop.call) {
      ret = vop.call(v, w);
    } else {
      ret = Sk.misceval.callsim(vop, v, w);
    }
    if (ret !== undefined)
      return ret;
  }
  var wop = Sk.abstr.boNameToSlotFuncRhs_(w, opname);
  if (wop !== undefined) {
    if (wop.call) {
      ret = wop.call(w, v);
    } else {
      ret = Sk.misceval.callsim(wop, w, v);
    }
    if (ret !== undefined)
      return ret;
  }
  Sk.abstr.binop_type_error(v, w, opname);
};
Sk.abstr.binary_iop_ = function (v, w, opname) {
  var ret;
  var vop = Sk.abstr.iboNameToSlotFunc_(v, opname);
  if (vop !== undefined) {
    if (vop.call) {
      ret = vop.call(v, w);
    } else {
      ret = Sk.misceval.callsim(vop, v, w);
    }
    if (ret !== undefined)
      return ret;
  }
  var wop = Sk.abstr.iboNameToSlotFunc_(w, opname);
  if (wop !== undefined) {
    if (wop.call) {
      ret = wop.call(w, v);
    } else {
      ret = Sk.misceval.callsim(wop, w, v);
    }
    if (ret !== undefined)
      return ret;
  }
  Sk.abstr.binop_type_error(v, w, opname);
};
Sk.abstr.numOpAndPromote = function (a, b, opfn) {
  if (a === null || b === null) {
    return undefined;
  }
  ;
  if (typeof a === 'number' && typeof b === 'number') {
    var ans = opfn(a, b);
    if ((ans > Sk.builtin.lng.threshold$ || ans < -Sk.builtin.lng.threshold$) && Math.floor(ans) === ans) {
      return [
        Sk.builtin.lng.fromInt$(a),
        Sk.builtin.lng.fromInt$(b)
      ];
    } else
      return ans;
  } else if (a === undefined || b === undefined) {
    throw new Sk.builtin.NameError('Undefined variable in expression');
  }
  if (a.constructor === Sk.builtin.lng) {
    return [
      a,
      b
    ];
  } else if (a.constructor === Sk.builtin.nmber) {
    return [
      a,
      b
    ];
  } else if (typeof a === 'number') {
    var tmp = new Sk.builtin.nmber(a, undefined);
    return [
      tmp,
      b
    ];
  } else
    return undefined;
};
Sk.abstr.boNumPromote_ = {
  'Add': function (a, b) {
    return a + b;
  },
  'Sub': function (a, b) {
    return a - b;
  },
  'Mult': function (a, b) {
    return a * b;
  },
  'Mod': function (a, b) {
    if (b === 0)
      throw new Sk.builtin.ZeroDivisionError('division or modulo by zero');
    var m = a % b;
    return m * b < 0 ? m + b : m;
  },
  'Div': function (a, b) {
    if (b === 0)
      throw new Sk.builtin.ZeroDivisionError('division or modulo by zero');
    else
      return a / b;
  },
  'FloorDiv': function (a, b) {
    if (b === 0)
      throw new Sk.builtin.ZeroDivisionError('division or modulo by zero');
    else
      return Math.floor(a / b);
  },
  'Pow': Math.pow,
  'BitAnd': function (a, b) {
    var m = a & b;
    if (m < 0) {
      m = m + 4294967296;
    }
    return m;
  },
  'BitOr': function (a, b) {
    var m = a | b;
    if (m < 0) {
      m = m + 4294967296;
    }
    return m;
  },
  'BitXor': function (a, b) {
    var m = a ^ b;
    if (m < 0) {
      m = m + 4294967296;
    }
    return m;
  },
  'LShift': function (a, b) {
    if (b < 0) {
      throw new Sk.builtin.ValueError('negative shift count');
    }
    var m = a << b;
    if (m > a) {
      return m;
    } else {
      return a * Math.pow(2, b);
    }
  },
  'RShift': function (a, b) {
    if (b < 0) {
      throw new Sk.builtin.ValueError('negative shift count');
    }
    var m = a >> b;
    if (a > 0 && m < 0) {
      m = m & Math.pow(2, 32 - b) - 1;
    }
    return m;
  }
};
Sk.abstr.numberBinOp = function (v, w, op) {
  var numPromoteFunc = Sk.abstr.boNumPromote_[op];
  if (numPromoteFunc !== undefined) {
    var tmp = Sk.abstr.numOpAndPromote(v, w, numPromoteFunc);
    if (typeof tmp === 'number') {
      return tmp;
    } else if (tmp !== undefined && tmp.constructor === Sk.builtin.nmber) {
      return tmp;
    } else if (tmp !== undefined && tmp.constructor === Sk.builtin.lng) {
      return tmp;
    } else if (tmp !== undefined) {
      v = tmp[0];
      w = tmp[1];
    }
  }
  return Sk.abstr.binary_op_(v, w, op);
};
goog.exportSymbol('Sk.abstr.numberBinOp', Sk.abstr.numberBinOp);
Sk.abstr.numberInplaceBinOp = function (v, w, op) {
  var numPromoteFunc = Sk.abstr.boNumPromote_[op];
  if (numPromoteFunc !== undefined) {
    var tmp = Sk.abstr.numOpAndPromote(v, w, numPromoteFunc);
    if (typeof tmp === 'number') {
      return tmp;
    } else if (tmp !== undefined && tmp.constructor === Sk.builtin.nmber) {
      return tmp;
    } else if (tmp !== undefined && tmp.constructor === Sk.builtin.lng) {
      return tmp;
    } else if (tmp !== undefined) {
      v = tmp[0];
      w = tmp[1];
    }
  }
  return Sk.abstr.binary_iop_(v, w, op);
};
goog.exportSymbol('Sk.abstr.numberInplaceBinOp', Sk.abstr.numberInplaceBinOp);
Sk.abstr.uboNameToSlotFunc_ = function (obj, name) {
  if (obj === null) {
    return undefined;
  }
  ;
  switch (name) {
  case 'USub': {
      return obj.nu$negative ? obj.nu$negative : obj['__neg__'];
    }
  case 'Invert': {
      return obj.nb$invert ? obj.nb$invert : obj['__invert__'];
    }
  case 'UAdd': {
      return obj.nb$positive ? obj.nb$positive : obj['__pos__'];
    }
  default: {
      throw new Sk.builtin.AssertionError('7fb8237f-879b-4192-89ce-13ad6fa3b2d8 ' + name);
    }
  }
};
Sk.abstr.numberUnaryOp = function (valuePy, op) {
  if (op === 'Not') {
    return Sk.misceval.isTrue(valuePy) ? Sk.builtin.bool.false$ : Sk.builtin.bool.true$;
  } else if (valuePy instanceof Sk.builtin.nmber || valuePy instanceof Sk.builtin.bool) {
    var value = Sk.builtin.asnum$(valuePy);
    if (op === 'USub')
      return new Sk.builtin.nmber(-value, value.skType);
    if (op === 'Invert')
      return new Sk.builtin.nmber(~value, value.skType);
    if (op === 'UAdd')
      return new Sk.builtin.nmber(value, value.skType);
  } else {
    var uop = Sk.abstr.uboNameToSlotFunc_(valuePy, op);
    if (uop != undefined) {
      if (uop.call) {
        return uop.call(valuePy);
      } else {
        return Sk.misceval.callsim(uop, valuePy);
      }
    }
  }
  var vtypename = Sk.abstr.typeName(valuePy);
  throw new Sk.builtin.TypeError('unsupported operand type for ' + op + ' \'' + vtypename + '\'');
};
goog.exportSymbol('Sk.abstr.numberUnaryOp', Sk.abstr.numberUnaryOp);
Sk.abstr.fixSeqIndex_ = function (seq, i) {
  i = Sk.builtin.asnum$(i);
  if (i < 0 && seq.sq$length)
    i += seq.sq$length();
  return i;
};
Sk.abstr.sequenceContains = function (seq, ob) {
  if (seq.sq$contains)
    return seq.sq$contains(ob);
  var seqtypename = Sk.abstr.typeName(seq);
  if (!seq.tp$iter)
    throw new Sk.builtin.TypeError('argument of type \'' + seqtypename + '\' is not iterable');
  for (var it = seq.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {
    if (Sk.misceval.richCompareBool(i, ob, 'Eq'))
      return true;
  }
  return false;
};
Sk.abstr.sequenceGetItem = function (seq, i) {
  goog.asserts.fail();
};
Sk.abstr.sequenceSetItem = function (seq, i, x) {
  goog.asserts.fail();
};
Sk.abstr.sequenceDelItem = function (seq, i) {
  if (seq.sq$del_item) {
    i = Sk.abstr.fixSeqIndex_(seq, i);
    seq.sq$del_item(i);
    return;
  }
  var seqtypename = Sk.abstr.typeName(seq);
  throw new Sk.builtin.TypeError('\'' + seqtypename + '\' object does not support item deletion');
};
Sk.abstr.sequenceRepeat = function (f, seq, n) {
  n = Sk.builtin.asnum$(n);
  var count = Sk.misceval.asIndex(n);
  if (count === undefined) {
    var ntypename = Sk.abstr.typeName(n);
    throw new Sk.builtin.TypeError('can\'t multiply sequence by non-int of type \'' + ntypename + '\'');
  }
  return f.call(seq, n);
};
Sk.abstr.sequenceGetSlice = function (seq, i1, i2) {
  if (seq.sq$slice) {
    i1 = Sk.abstr.fixSeqIndex_(seq, i1);
    i2 = Sk.abstr.fixSeqIndex_(seq, i2);
    return seq.sq$slice(i1, i2);
  } else if (seq.mp$subscript) {
    return seq.mp$subscript(new Sk.builtin.slice(i1, i2));
  }
  var seqtypename = Sk.abstr.typeName(seq);
  throw new Sk.builtin.TypeError('\'' + seqtypename + '\' object is unsliceable');
};
Sk.abstr.sequenceDelSlice = function (seq, i1, i2) {
  if (seq.sq$del_slice) {
    i1 = Sk.abstr.fixSeqIndex_(seq, i1);
    i2 = Sk.abstr.fixSeqIndex_(seq, i2);
    seq.sq$del_slice(i1, i2);
    return;
  }
  var seqtypename = Sk.abstr.typeName(seq);
  throw new Sk.builtin.TypeError('\'' + seqtypename + '\' doesn\'t support slice deletion');
};
Sk.abstr.sequenceSetSlice = function (seq, i1, i2, x) {
  if (seq.sq$ass_slice) {
    i1 = Sk.abstr.fixSeqIndex_(seq, i1);
    i2 = Sk.abstr.fixSeqIndex_(seq, i2);
    seq.sq$ass_slice(i1, i2, x);
  } else if (seq.mp$ass_subscript) {
    seq.mp$ass_subscript(new Sk.builtin.slice(i1, i2), x);
  } else {
    var seqtypename = Sk.abstr.typeName(seq);
    throw new Sk.builtin.TypeError('\'' + seqtypename + '\' object doesn\'t support slice assignment');
  }
};
Sk.abstr.objectDelItem = function (o, key) {
  if (o !== null) {
    if (o.mp$del_subscript) {
      o.mp$del_subscript(key);
      return;
    }
    if (o.sq$ass_item) {
      var keyValue = Sk.misceval.asIndex(key);
      if (keyValue === undefined) {
        var keytypename = Sk.abstr.typeName(key);
        throw new Sk.builtin.TypeError('sequence index must be integer, not \'' + keytypename + '\'');
      }
      Sk.abstr.sequenceDelItem(o, keyValue);
      return;
    }
  }
  var otypename = Sk.abstr.typeName(o);
  throw new Sk.builtin.TypeError('\'' + otypename + '\' object does not support item deletion');
};
goog.exportSymbol('Sk.abstr.objectDelItem', Sk.abstr.objectDelItem);
Sk.abstr.objectGetItem = function (o, key) {
  if (o !== null) {
    if (o.mp$subscript) {
      return o.mp$subscript(key);
    } else if (Sk.misceval.isIndex(key) && o.sq$item) {
      return Sk.abstr.sequenceGetItem(o, Sk.misceval.asIndex(key));
    } else if (o.tp$getitem) {
      return o.tp$getitem(key);
    }
  }
  var otypename = Sk.abstr.typeName(o);
  throw new Sk.builtin.TypeError('\'' + otypename + '\' does not support indexing');
};
goog.exportSymbol('Sk.abstr.objectGetItem', Sk.abstr.objectGetItem);
Sk.abstr.objectSetItem = function (o, key, v) {
  if (o !== null) {
    if (o.mp$ass_subscript)
      return o.mp$ass_subscript(key, v);
    else if (Sk.misceval.isIndex(key) && o.sq$ass_item)
      return Sk.abstr.sequenceSetItem(o, Sk.misceval.asIndex(key), v);
    else if (o.tp$setitem)
      return o.tp$setitem(key, v);
  }
  var otypename = Sk.abstr.typeName(o);
  throw new Sk.builtin.TypeError('\'' + otypename + '\' does not support item assignment');
};
goog.exportSymbol('Sk.abstr.objectSetItem', Sk.abstr.objectSetItem);
Sk.abstr.gattr = function (obj, nameJS) {
  var objname = Sk.abstr.typeName(obj);
  if (obj === null) {
    throw new Sk.builtin.AttributeError('\'' + objname + '\' object has no attribute \'' + nameJS + '\'');
  }
  var ret = undefined;
  if (obj['__getattr__']) {
    ret = Sk.misceval.callsim(obj['__getattr__'], obj, nameJS);
  } else if (obj.tp$getattr !== undefined) {
    ret = obj.tp$getattr(nameJS);
  }
  if (ret === undefined) {
    throw new Sk.builtin.AttributeError('\'' + objname + '\' object has no attribute \'' + nameJS + '\'');
  }
  return ret;
};
goog.exportSymbol('Sk.abstr.gattr', Sk.abstr.gattr);
Sk.abstr.sattr = function (obj, nameJS, data) {
  var objname = Sk.abstr.typeName(obj);
  if (obj === null) {
    throw new Sk.builtin.AttributeError('\'' + objname + '\' object has no attribute \'' + nameJS + '\'');
  } else if (obj['__setattr__']) {
    Sk.misceval.callsim(obj['__setattr__'], obj, nameJS, data);
  } else if (obj.tp$setattr !== undefined) {
    obj.tp$setattr(nameJS, data);
  } else {
    throw new Sk.builtin.AttributeError('\'' + objname + '\' object has no attribute \'' + nameJS + '\'');
  }
};
goog.exportSymbol('Sk.abstr.sattr', Sk.abstr.sattr);
Sk.abstr.iter = function (obj) {
  if (obj.tp$iter) {
    return obj.tp$iter();
  } else {
    throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(obj) + '\' object is not iterable');
  }
};
goog.exportSymbol('Sk.abstr.iter', Sk.abstr.iter);
Sk.abstr.iternext = function (it) {
  return it.tp$iternext();
};
goog.exportSymbol('Sk.abstr.iternext', Sk.abstr.iternext);
Sk.mergeSort = function (arr, cmp, key, reverse) {
  Sk.quickSort(arr, cmp, key, reverse);
};
Sk.quickSort = function (arr, cmp, key, reverse) {
  goog.asserts.assert(!key, 'todo;');
  if (!cmp) {
    cmp = Sk.mergeSort.stdCmp;
  }
  var partition = function (arr, begin, end, pivot, reverse) {
    var tmp;
    var piv = arr[pivot];
    tmp = arr[pivot];
    arr[pivot] = arr[end - 1];
    arr[end - 1] = tmp;
    var store = begin;
    var ix;
    for (ix = begin; ix < end - 1; ++ix) {
      if (reverse) {
        var cmpresult = Sk.misceval.callsim(cmp, piv, arr[ix]);
      } else {
        var cmpresult = Sk.misceval.callsim(cmp, arr[ix], piv);
      }
      if (Sk.builtin.asnum$(cmpresult) < 0) {
        tmp = arr[store];
        arr[store] = arr[ix];
        arr[ix] = tmp;
        ++store;
      }
    }
    tmp = arr[end - 1];
    arr[end - 1] = arr[store];
    arr[store] = tmp;
    return store;
  };
  var qsort = function (arr, begin, end, reverse) {
    if (end - 1 > begin) {
      var pivot = begin + Math.floor(Math.random() * (end - begin));
      pivot = partition(arr, begin, end, pivot, reverse);
      qsort(arr, begin, pivot, reverse);
      qsort(arr, pivot + 1, end, reverse);
    }
  };
  qsort(arr, 0, arr.length, reverse);
  return null;
};
Sk.mergeSort.stdCmp = new Sk.builtin.func(function (k0, k1) {
  var res = Sk.misceval.richCompareBool(k0, k1, 'Lt') ? -1 : 0;
  return res;
});
Sk.builtin.list = function (L) {
  if (!(this instanceof Sk.builtin.list))
    return new Sk.builtin.list(L);
  if (L === undefined) {
    this.v = [];
  } else if (Object.prototype.toString.apply(L) === '[object Array]') {
    this.v = L;
  } else {
    if (L.tp$iter) {
      this.v = [];
      for (var it = L.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext())
        this.v.push(i);
    } else
      throw new Sk.builtin.ValueError('expecting Array or iterable');
  }
  this.__class__ = Sk.builtin.list;
  this['v'] = this.v;
  return this;
};
Sk.builtin.list.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('list', Sk.builtin.list);
Sk.builtin.list.prototype.list_iter_ = function () {
  var ret = {
      tp$iter: function () {
        return ret;
      },
      $obj: this,
      $index: 0,
      tp$iternext: function () {
        if (ret.$index >= ret.$obj.v.length)
          return undefined;
        return ret.$obj.v[ret.$index++];
      }
    };
  return ret;
};
Sk.builtin.list.prototype.list_concat_ = function (other) {
  if (!other.__class__ || other.__class__ != Sk.builtin.list) {
    throw new Sk.builtin.TypeError('can only concatenate list to list');
  }
  var ret = this.v.slice();
  for (var i = 0; i < other.v.length; ++i) {
    ret.push(other.v[i]);
  }
  return new Sk.builtin.list(ret);
};
Sk.builtin.list.prototype.list_del_item_ = function (i) {
  i = Sk.builtin.asnum$(i);
  if (i < 0 || i >= this.v.length)
    throw new Sk.builtin.IndexError('list assignment index out of range');
  this.list_del_slice_(i, i + 1);
};
Sk.builtin.list.prototype.list_del_slice_ = function (ilow, ihigh) {
  ilow = Sk.builtin.asnum$(ilow);
  ihigh = Sk.builtin.asnum$(ihigh);
  var args = [];
  args.unshift(ihigh - ilow);
  args.unshift(ilow);
  this.v.splice.apply(this.v, args);
};
Sk.builtin.list.prototype.list_ass_item_ = function (i, v) {
  i = Sk.builtin.asnum$(i);
  if (i < 0 || i >= this.v.length)
    throw new Sk.builtin.IndexError('list assignment index out of range');
  this.v[i] = v;
};
Sk.builtin.list.prototype.list_ass_slice_ = function (ilow, ihigh, v) {
  ilow = Sk.builtin.asnum$(ilow);
  ihigh = Sk.builtin.asnum$(ihigh);
  var args = v.v.slice(0);
  args.unshift(ihigh - ilow);
  args.unshift(ilow);
  this.v.splice.apply(this.v, args);
};
Sk.builtin.list.prototype.tp$name = 'list';
Sk.builtin.list.prototype.tp$str = function () {
  var ret = [];
  for (var it = this.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {
    ret.push(Sk.ffi.remapToJs(Sk.misceval.objectRepr(i)));
  }
  return Sk.ffi.stringToPy('[' + ret.join(', ') + ']');
};
Sk.builtin.list.prototype.tp$repr = function () {
  var ret = [];
  for (var it = this.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {
    ret.push(Sk.misceval.objectRepr(i).v);
  }
  return new Sk.builtin.str('[' + ret.join(', ') + ']');
};
Sk.builtin.list.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
Sk.builtin.list.prototype.tp$hash = Sk.builtin.object.prototype.HashNotImplemented;
Sk.builtin.list.prototype.tp$richcompare = function (w, op) {
  if (this === w && Sk.misceval.opAllowsEquality(op))
    return true;
  if (!w.__class__ || w.__class__ != Sk.builtin.list) {
    if (op === 'Eq')
      return false;
    if (op === 'NotEq')
      return true;
    return false;
  }
  var v = this.v;
  var w = w.v;
  var vl = v.length;
  var wl = w.length;
  var i;
  for (i = 0; i < vl && i < wl; ++i) {
    var k = Sk.misceval.richCompareBool(v[i], w[i], 'Eq');
    if (!k)
      break;
  }
  if (i >= vl || i >= wl) {
    switch (op) {
    case 'Lt':
      return vl < wl;
    case 'LtE':
      return vl <= wl;
    case 'Eq':
      return vl === wl;
    case 'NotEq':
      return vl !== wl;
    case 'Gt':
      return vl > wl;
    case 'GtE':
      return vl >= wl;
    default:
      goog.asserts.fail();
    }
  }
  if (op === 'Eq')
    return false;
  if (op === 'NotEq')
    return true;
  return Sk.misceval.richCompareBool(v[i], w[i], op);
};
Sk.builtin.list.prototype.tp$iter = Sk.builtin.list.prototype.list_iter_;
Sk.builtin.list.prototype.sq$length = function () {
  return this.v.length;
};
Sk.builtin.list.prototype.sq$concat = Sk.builtin.list.prototype.list_concat_;
Sk.builtin.list.prototype.nb$add = Sk.builtin.list.prototype.list_concat_;
Sk.builtin.list.prototype.nb$inplace_add = Sk.builtin.list.prototype.list_concat_;
Sk.builtin.list.prototype.sq$repeat = function (n) {
  if (!Sk.builtin.checkInt(n)) {
    throw new Sk.builtin.TypeError('can\'t multiply sequence by non-int of type \'' + Sk.abstr.typeName(n) + '\'');
  }
  n = Sk.builtin.asnum$(n);
  var ret = [];
  for (var i = 0; i < n; ++i)
    for (var j = 0; j < this.v.length; ++j)
      ret.push(this.v[j]);
  return new Sk.builtin.list(ret);
};
Sk.builtin.list.prototype.nb$multiply = Sk.builtin.list.prototype.sq$repeat;
Sk.builtin.list.prototype.nb$inplace_multiply = Sk.builtin.list.prototype.sq$repeat;
Sk.builtin.list.prototype.sq$ass_item = Sk.builtin.list.prototype.list_ass_item_;
Sk.builtin.list.prototype.sq$del_item = Sk.builtin.list.prototype.list_del_item_;
Sk.builtin.list.prototype.sq$ass_slice = Sk.builtin.list.prototype.list_ass_slice_;
Sk.builtin.list.prototype.sq$del_slice = Sk.builtin.list.prototype.list_del_slice_;
Sk.builtin.list.prototype.list_subscript_ = function (index) {
  if (Sk.misceval.isIndex(index)) {
    var i = Sk.misceval.asIndex(index);
    if (i !== undefined) {
      if (i < 0)
        i = this.v.length + i;
      if (i < 0 || i >= this.v.length) {
        throw new Sk.builtin.IndexError('list index out of range');
      }
      return this.v[i];
    }
  } else if (index instanceof Sk.builtin.slice) {
    var ret = [];
    index.sssiter$(this, function (i, wrt) {
      ret.push(wrt.v[i]);
    });
    return new Sk.builtin.list(ret);
  }
  throw new Sk.builtin.TypeError('list indices must be integers, not ' + Sk.abstr.typeName(index));
};
Sk.builtin.list.prototype.list_ass_subscript_ = function (index, value) {
  if (Sk.misceval.isIndex(index)) {
    var i = Sk.misceval.asIndex(index);
    if (i !== undefined) {
      if (i < 0)
        i = this.v.length + i;
      this.list_ass_item_(i, value);
      return;
    }
  } else if (index instanceof Sk.builtin.slice) {
    var step = index.step !== null ? index.step : 1;
    if (step === 1)
      this.list_ass_slice_(index.start, index.stop, value);
    else {
      var tosub = [];
      index.sssiter$(this, function (i, wrt) {
        tosub.push(i);
      });
      var j = 0;
      if (tosub.length !== value.v.length)
        throw new Sk.builtin.ValueError('attempt to assign sequence of size ' + value.v.length + ' to extended slice of size ' + tosub.length);
      for (var i = 0; i < tosub.length; ++i) {
        this.v.splice(tosub[i], 1, value.v[j]);
        j += 1;
      }
    }
    return;
  }
  throw new Sk.builtin.TypeError('list indices must be integers, not ' + Sk.abstr.typeName(index));
};
Sk.builtin.list.prototype.list_del_subscript_ = function (index) {
  if (Sk.misceval.isIndex(index)) {
    var i = Sk.misceval.asIndex(index);
    if (i !== undefined) {
      if (i < 0)
        i = this.v.length + i;
      this.list_del_item_(i);
      return;
    }
  } else if (index instanceof Sk.builtin.slice) {
    if (index.step === 1)
      this.list_del_slice_(index.start, index.stop);
    else {
      var self = this;
      var dec = 0;
      var step = index.step === null ? 1 : index.step;
      var offdir = step > 0 ? 1 : 0;
      index.sssiter$(this, function (i, wrt) {
        self.v.splice(i - dec, 1);
        dec += offdir;
      });
    }
    return;
  }
  throw new Sk.builtin.TypeError('list indices must be integers, not ' + typeof index);
};
Sk.builtin.list.prototype.mp$subscript = Sk.builtin.list.prototype.list_subscript_;
Sk.builtin.list.prototype.mp$ass_subscript = Sk.builtin.list.prototype.list_ass_subscript_;
Sk.builtin.list.prototype.mp$del_subscript = Sk.builtin.list.prototype.list_del_subscript_;
Sk.builtin.list.prototype.__getitem__ = new Sk.builtin.func(function (self, index) {
  return Sk.builtin.list.prototype.list_subscript_.call(self, index);
});
Sk.builtin.list.prototype.list_sort_ = function (self, cmp, key, reverse) {
  var has_key = key !== undefined && key !== null;
  var has_cmp = cmp !== undefined && cmp !== null;
  if (reverse == undefined) {
    reverse = false;
  }
  var timsort = new Sk.builtin.timSort(self);
  self.v = [];
  var zero = new Sk.builtin.nmber(0, Sk.builtin.nmber.int$);
  if (has_key) {
    if (has_cmp) {
      timsort.lt = function (a, b) {
        return Sk.misceval.richCompareBool(cmp.func_code(a[0], b[0]), zero, 'Lt');
      };
    } else {
      timsort.lt = function (a, b) {
        return Sk.misceval.richCompareBool(a[0], b[0], 'Lt');
      };
    }
    for (var i = 0; i < timsort.listlength; i++) {
      var item = timsort.list.v[i];
      var keyvalue = key.func_code(item);
      timsort.list.v[i] = [
        keyvalue,
        item
      ];
    }
  } else if (has_cmp) {
    timsort.lt = function (a, b) {
      return Sk.misceval.richCompareBool(cmp.func_code(a, b), zero, 'Lt');
    };
  }
  if (reverse) {
    timsort.list.list_reverse_(timsort.list);
  }
  timsort.sort();
  if (reverse) {
    timsort.list.list_reverse_(timsort.list);
  }
  if (has_key) {
    for (var j = 0; j < timsort.listlength; j++) {
      item = timsort.list.v[j][1];
      timsort.list.v[j] = item;
    }
  }
  var mucked = self.sq$length() > 0;
  self.v = timsort.list.v;
  if (mucked) {
    throw new Sk.builtin.OperationError('list modified during sort');
  }
};
Sk.builtin.list.prototype.list_reverse_ = function (self) {
  Sk.builtin.pyCheckArgs('reverse', arguments, 1, 1);
  var len = self.v.length;
  var old = self.v;
  var newarr = [];
  for (var i = len - 1; i > -1; --i) {
    newarr.push(old[i]);
  }
  self.v = newarr;
  return null;
};
Sk.builtin.list.prototype['__iter__'] = new Sk.builtin.func(function (self) {
  Sk.builtin.pyCheckArgs('__iter__', arguments, 1, 1);
  return self.list_iter_();
});
Sk.builtin.list.prototype['append'] = new Sk.builtin.func(function (self, item) {
  Sk.builtin.pyCheckArgs('append', arguments, 2, 2);
  self.v.push(item);
  return null;
});
Sk.builtin.list.prototype['insert'] = new Sk.builtin.func(function (self, i, x) {
  Sk.builtin.pyCheckArgs('insert', arguments, 3, 3);
  if (!Sk.builtin.checkNumber(i)) {
    throw new Sk.builtin.TypeError('an integer is required');
  }
  ;
  i = Sk.builtin.asnum$(i);
  if (i < 0)
    i = 0;
  else if (i > self.v.length)
    i = self.v.length;
  self.v.splice(i, 0, x);
});
Sk.builtin.list.prototype['extend'] = new Sk.builtin.func(function (self, b) {
  Sk.builtin.pyCheckArgs('extend', arguments, 2, 2);
  if (!Sk.builtin.checkIterable(b)) {
    throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(b) + '\' object is not iterable');
  }
  ;
  if (self == b) {
    var newb = [];
    for (var it = b.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext())
      newb.push(i);
    self.v.push.apply(self.v, newb);
    return null;
  }
  ;
  for (var it = b.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext())
    self.v.push(i);
  return null;
});
Sk.builtin.list.prototype['pop'] = new Sk.builtin.func(function (self, i) {
  Sk.builtin.pyCheckArgs('pop', arguments, 1, 2);
  if (i === undefined) {
    i = self.v.length - 1;
  }
  ;
  if (!Sk.builtin.checkNumber(i)) {
    throw new Sk.builtin.TypeError('an integer is required');
  }
  ;
  i = Sk.builtin.asnum$(i);
  if (i < 0 || i >= self.v.length) {
    throw new Sk.builtin.IndexError('pop index out of range');
  }
  ;
  var ret = self.v[i];
  self.v.splice(i, 1);
  return ret;
});
Sk.builtin.list.prototype['remove'] = new Sk.builtin.func(function (self, item) {
  Sk.builtin.pyCheckArgs('remove', arguments, 2, 2);
  var idx = Sk.builtin.list.prototype['index'].func_code(self, item);
  self.v.splice(idx, 1);
  return null;
});
Sk.builtin.list.prototype['index'] = new Sk.builtin.func(function (self, item) {
  Sk.builtin.pyCheckArgs('index', arguments, 2, 2);
  var len = self.v.length;
  var obj = self.v;
  for (var i = 0; i < len; ++i) {
    if (Sk.misceval.richCompareBool(obj[i], item, 'Eq')) {
      return i;
    }
  }
  throw new Sk.builtin.ValueError('list.index(x): x not in list');
});
Sk.builtin.list.prototype['count'] = new Sk.builtin.func(function (self, item) {
  Sk.ffi.checkMethodArgs('count()', arguments, 1, 1);
  var len = self.v.length;
  var obj = self.v;
  var count = 0;
  for (var i = 0; i < len; ++i) {
    if (Sk.misceval.richCompareBool(obj[i], item, 'Eq')) {
      count += 1;
    }
  }
  return count;
});
Sk.builtin.list.prototype['reverse'] = new Sk.builtin.func(Sk.builtin.list.prototype.list_reverse_);
Sk.builtin.list.prototype['sort'] = new Sk.builtin.func(Sk.builtin.list.prototype.list_sort_);
Sk.builtin.list.prototype['sort'].func_code['co_varnames'] = [
  '__self__',
  'cmp',
  'key',
  'reverse'
];
goog.exportSymbol('Sk.builtin.list', Sk.builtin.list);
var interned = {};
Sk.builtin.str = function (x) {
  if (x === undefined)
    x = '';
  if (x instanceof Sk.builtin.str && x !== Sk.builtin.str.prototype.ob$type)
    return x;
  if (!(this instanceof Sk.builtin.str))
    return new Sk.builtin.str(x);
  var ret;
  if (x === true)
    ret = 'True';
  else if (x === false)
    ret = 'False';
  else if (x === null || x instanceof Sk.builtin.none)
    ret = 'None';
  else if (x instanceof Sk.builtin.bool) {
    if (x.v)
      ret = 'True';
    else
      ret = 'False';
  } else if (typeof x === 'number') {
    ret = x.toString();
    if (ret === 'Infinity')
      ret = 'inf';
    else if (ret === '-Infinity')
      ret = '-inf';
  } else if (typeof x === 'string')
    ret = x;
  else if (x.tp$str !== undefined) {
    ret = x.tp$str();
    if (!(ret instanceof Sk.builtin.str))
      throw new Sk.builtin.ValueError('__str__ didn\'t return a str');
    return ret;
  } else
    return Sk.misceval.objectRepr(x);
  if (Object.prototype.hasOwnProperty.call(interned, '1' + ret)) {
    return interned['1' + ret];
  }
  this.__class__ = Sk.builtin.str;
  this.v = ret;
  this['v'] = this.v;
  interned['1' + ret] = this;
  return this;
};
goog.exportSymbol('Sk.builtin.str', Sk.builtin.str);
Sk.builtin.str.$emptystr = new Sk.builtin.str('');
Sk.builtin.str.prototype.mp$subscript = function (index) {
  index = Sk.builtin.asnum$(index);
  if (typeof index === 'number' && Math.floor(index) === index) {
    if (index < 0)
      index = this.v.length + index;
    if (index < 0 || index >= this.v.length)
      throw new Sk.builtin.IndexError('string index out of range');
    return new Sk.builtin.str(this.v.charAt(index));
  } else if (index instanceof Sk.builtin.slice) {
    var ret = '';
    index.sssiter$(this, function (i, wrt) {
      if (i >= 0 && i < wrt.v.length)
        ret += wrt.v.charAt(i);
    });
    return new Sk.builtin.str(ret);
  } else
    throw new Sk.builtin.TypeError('string indices must be numbers, not ' + typeof index);
};
Sk.builtin.str.prototype.sq$length = function () {
  return this.v.length;
};
Sk.builtin.str.prototype.sq$concat = function (other) {
  if (!other || !Sk.builtin.checkString(other)) {
    var otypename = Sk.abstr.typeName(other);
    throw new Sk.builtin.TypeError('cannot concatenate \'str\' and \'' + otypename + '\' objects');
  }
  return new Sk.builtin.str(this.v + other.v);
};
Sk.builtin.str.prototype.nb$add = Sk.builtin.str.prototype.sq$concat;
Sk.builtin.str.prototype.nb$inplace_add = Sk.builtin.str.prototype.sq$concat;
Sk.builtin.str.prototype.sq$repeat = function (n) {
  n = Sk.builtin.asnum$(n);
  var ret = '';
  for (var i = 0; i < n; ++i)
    ret += this.v;
  return new Sk.builtin.str(ret);
};
Sk.builtin.str.prototype.nb$multiply = Sk.builtin.str.prototype.sq$repeat;
Sk.builtin.str.prototype.nb$inplace_multiply = Sk.builtin.str.prototype.sq$repeat;
Sk.builtin.str.prototype.sq$item = function () {
  goog.asserts.fail();
};
Sk.builtin.str.prototype.sq$slice = function (i1, i2) {
  i1 = Sk.builtin.asnum$(i1);
  i2 = Sk.builtin.asnum$(i2);
  if (i1 < 0)
    i1 = 0;
  return new Sk.builtin.str(this.v.substr(i1, i2 - i1));
};
Sk.builtin.str.prototype.sq$contains = function (ob) {
  if (ob.v === undefined || ob.v.constructor != String) {
    throw new Sk.builtin.TypeError('TypeError: \'In <string> requires string as left operand');
  }
  if (this.v.indexOf(ob.v) != -1) {
    return true;
  } else {
    return false;
  }
};
Sk.builtin.str.prototype.tp$name = 'str';
Sk.builtin.str.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
Sk.builtin.str.prototype.tp$iter = function () {
  var ret = {
      tp$iter: function () {
        return ret;
      },
      $obj: this,
      $index: 0,
      tp$iternext: function () {
        if (ret.$index >= ret.$obj.v.length)
          return undefined;
        return new Sk.builtin.str(ret.$obj.v.substr(ret.$index++, 1));
      }
    };
  return ret;
};
Sk.builtin.str.prototype.tp$richcompare = function (other, op) {
  if (!(other instanceof Sk.builtin.str))
    return undefined;
  if (this === other) {
    switch (op) {
    case 'Eq':
    case 'LtE':
    case 'GtE':
      return true;
    case 'NotEq':
    case 'Lt':
    case 'Gt':
      return false;
    }
  }
  var lenA = this.v.length;
  var lenB = other.v.length;
  var minLength = Math.min(lenA, lenB);
  var c = 0;
  if (minLength > 0) {
    for (var i = 0; i < minLength; ++i) {
      if (this.v[i] != other.v[i]) {
        c = this.v[i].charCodeAt(0) - other.v[i].charCodeAt(0);
        break;
      }
    }
  } else {
    c = 0;
  }
  if (c == 0) {
    c = lenA < lenB ? -1 : lenA > lenB ? 1 : 0;
  }
  switch (op) {
  case 'Lt':
    return c < 0;
  case 'LtE':
    return c <= 0;
  case 'Eq':
    return c == 0;
  case 'NotEq':
    return c != 0;
  case 'Gt':
    return c > 0;
  case 'GtE':
    return c >= 0;
  default:
    goog.asserts.fail();
  }
};
Sk.builtin.str.prototype.tp$repr = function () {
  var quote = '\'';
  if (this.v.indexOf('\'') !== -1 && this.v.indexOf('"') === -1) {
    quote = '"';
  }
  var len = this.v.length;
  var ret = quote;
  for (var i = 0; i < len; ++i) {
    var c = this.v.charAt(i);
    if (c === quote || c === '\\')
      ret += '\\' + c;
    else if (c === '\t')
      ret += '\\t';
    else if (c === '\n')
      ret += '\\n';
    else if (c === '\r')
      ret += '\\r';
    else if (c < ' ' || c >= 127) {
      var ashex = c.charCodeAt(0).toString(16);
      if (ashex.length < 2)
        ashex = '0' + ashex;
      ret += '\\x' + ashex;
    } else
      ret += c;
  }
  ret += quote;
  return new Sk.builtin.str(ret);
};
Sk.builtin.str.re_escape_ = function (s) {
  var ret = [];
  var re = /^[A-Za-z0-9]+$/;
  for (var i = 0; i < s.length; ++i) {
    var c = s.charAt(i);
    if (re.test(c)) {
      ret.push(c);
    } else {
      if (c === '\\000')
        ret.push('\\000');
      else
        ret.push('\\' + c);
    }
  }
  return ret.join('');
};
Sk.builtin.str.prototype['lower'] = new Sk.builtin.func(function (self) {
  Sk.builtin.pyCheckArgs('lower', arguments, 1, 1);
  return new Sk.builtin.str(self.v.toLowerCase());
});
Sk.builtin.str.prototype['upper'] = new Sk.builtin.func(function (self) {
  Sk.builtin.pyCheckArgs('upper', arguments, 1, 1);
  return new Sk.builtin.str(self.v.toUpperCase());
});
Sk.builtin.str.prototype['capitalize'] = new Sk.builtin.func(function (self) {
  Sk.builtin.pyCheckArgs('capitalize', arguments, 1, 1);
  var orig = self.v;
  var cap;
  var i;
  if (orig.length === 0) {
    return new Sk.builtin.str('');
  }
  ;
  cap = orig.charAt(0).toUpperCase();
  for (i = 1; i < orig.length; i++) {
    cap += orig.charAt(i).toLowerCase();
  }
  ;
  return new Sk.builtin.str(cap);
});
Sk.builtin.str.prototype['join'] = new Sk.builtin.func(function (self, seq) {
  Sk.builtin.pyCheckArgs('join', arguments, 2, 2);
  Sk.builtin.pyCheckType('seq', 'iterable', Sk.builtin.checkIterable(seq));
  var arrOfStrs = [];
  for (var it = seq.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {
    if (i.constructor !== Sk.builtin.str)
      throw 'TypeError: sequence item ' + arrOfStrs.length + ': expected string, ' + typeof i + ' found';
    arrOfStrs.push(i.v);
  }
  return new Sk.builtin.str(arrOfStrs.join(self.v));
});
Sk.builtin.str.prototype['split'] = new Sk.builtin.func(function (self, on, howmany) {
  Sk.builtin.pyCheckArgs('split', arguments, 1, 3);
  if (on === undefined || on instanceof Sk.builtin.none) {
    on = null;
  }
  if (on !== null && !Sk.builtin.checkString(on)) {
    throw new Sk.builtin.TypeError('expected a string');
  }
  if (on !== null && on.v === '') {
    throw new Sk.builtin.ValueError('empty separator');
  }
  if (howmany !== undefined && !Sk.builtin.checkInt(howmany)) {
    throw new Sk.builtin.TypeError('an integer is required');
  }
  howmany = Sk.builtin.asnum$(howmany);
  var regex = /[\s]+/g;
  var str = self.v;
  if (on === null) {
    str = str.trimLeft();
  } else {
    var s = on.v.replace(/([.*+?=|\\\/()\[\]\{\}^$])/g, '\\$1');
    regex = new RegExp(s, 'g');
  }
  var result = [];
  var match;
  var index = 0;
  var splits = 0;
  while ((match = regex.exec(str)) != null) {
    if (match.index === regex.lastIndex) {
      break;
    }
    result.push(new Sk.builtin.str(str.substring(index, match.index)));
    index = regex.lastIndex;
    splits += 1;
    if (howmany && splits >= howmany) {
      break;
    }
  }
  str = str.substring(index);
  if (on !== null || str.length > 0) {
    result.push(new Sk.builtin.str(str));
  }
  return new Sk.builtin.list(result);
});
Sk.builtin.str.prototype['strip'] = new Sk.builtin.func(function (self, chars) {
  Sk.builtin.pyCheckArgs('strip', arguments, 1, 2);
  if (chars !== undefined && !Sk.builtin.checkString(chars)) {
    throw new Sk.builtin.TypeError('strip arg must be None or str');
  }
  var pattern;
  if (chars === undefined) {
    pattern = /^\s+|\s+$/g;
  } else {
    var regex = Sk.builtin.str.re_escape_(chars.v);
    pattern = new RegExp('^[' + regex + ']+|[' + regex + ']+$', 'g');
  }
  return new Sk.builtin.str(self.v.replace(pattern, ''));
});
Sk.builtin.str.prototype['lstrip'] = new Sk.builtin.func(function (self, chars) {
  Sk.builtin.pyCheckArgs('lstrip', arguments, 1, 2);
  if (chars !== undefined && !Sk.builtin.checkString(chars)) {
    throw new Sk.builtin.TypeError('lstrip arg must be None or str');
  }
  var pattern;
  if (chars === undefined) {
    pattern = /^\s+/g;
  } else {
    var regex = Sk.builtin.str.re_escape_(chars.v);
    pattern = new RegExp('^[' + regex + ']+', 'g');
  }
  return new Sk.builtin.str(self.v.replace(pattern, ''));
});
Sk.builtin.str.prototype['rstrip'] = new Sk.builtin.func(function (self, chars) {
  Sk.builtin.pyCheckArgs('rstrip', arguments, 1, 2);
  if (chars !== undefined && !Sk.builtin.checkString(chars)) {
    throw new Sk.builtin.TypeError('rstrip arg must be None or str');
  }
  var pattern;
  if (chars === undefined) {
    pattern = /\s+$/g;
  } else {
    var regex = Sk.builtin.str.re_escape_(chars.v);
    pattern = new RegExp('[' + regex + ']+$', 'g');
  }
  return new Sk.builtin.str(self.v.replace(pattern, ''));
});
Sk.builtin.str.prototype['partition'] = new Sk.builtin.func(function (self, sep) {
  Sk.builtin.pyCheckArgs('partition', arguments, 2, 2);
  Sk.builtin.pyCheckType('sep', 'string', Sk.builtin.checkString(sep));
  var sepStr = new Sk.builtin.str(sep);
  var pos = self.v.indexOf(sepStr.v);
  if (pos < 0) {
    return new Sk.builtin.tuple([
      self,
      Sk.builtin.str.$emptystr,
      Sk.builtin.str.$emptystr
    ]);
  }
  return new Sk.builtin.tuple([
    new Sk.builtin.str(self.v.substring(0, pos)),
    sepStr,
    new Sk.builtin.str(self.v.substring(pos + sepStr.v.length))
  ]);
});
Sk.builtin.str.prototype['rpartition'] = new Sk.builtin.func(function (self, sep) {
  Sk.builtin.pyCheckArgs('rpartition', arguments, 2, 2);
  Sk.builtin.pyCheckType('sep', 'string', Sk.builtin.checkString(sep));
  var sepStr = new Sk.builtin.str(sep);
  var pos = self.v.lastIndexOf(sepStr.v);
  if (pos < 0) {
    return new Sk.builtin.tuple([
      Sk.builtin.str.$emptystr,
      Sk.builtin.str.$emptystr,
      self
    ]);
  }
  return new Sk.builtin.tuple([
    new Sk.builtin.str(self.v.substring(0, pos)),
    sepStr,
    new Sk.builtin.str(self.v.substring(pos + sepStr.v.length))
  ]);
});
Sk.builtin.str.prototype['count'] = new Sk.builtin.func(function (self, pat, start, end) {
  Sk.builtin.pyCheckArgs('count', arguments, 2, 4);
  if (!Sk.builtin.checkString(pat)) {
    throw new Sk.builtin.TypeError('expected a character buffer object');
  }
  if (start !== undefined && !Sk.builtin.checkInt(start)) {
    throw new Sk.builtin.TypeError('slice indices must be integers or None or have an __index__ method');
  }
  if (end !== undefined && !Sk.builtin.checkInt(end)) {
    throw new Sk.builtin.TypeError('slice indices must be integers or None or have an __index__ method');
  }
  if (start === undefined)
    start = 0;
  else {
    start = Sk.builtin.asnum$(start);
    start = start >= 0 ? start : self.v.length + start;
  }
  if (end === undefined)
    end = self.v.length;
  else {
    end = Sk.builtin.asnum$(end);
    end = end >= 0 ? end : self.v.length + end;
  }
  var m = new RegExp(pat.v, 'g');
  var slice = self.v.slice(start, end);
  var ctl = slice.match(m);
  if (!ctl) {
    return 0;
  } else {
    return ctl.length;
  }
});
Sk.builtin.str.prototype['ljust'] = new Sk.builtin.func(function (self, len, fillchar) {
  Sk.builtin.pyCheckArgs('ljust', arguments, 2, 3);
  if (!Sk.builtin.checkInt(len)) {
    throw new Sk.builtin.TypeError('integer argument exepcted, got ' + Sk.abstr.typeName(len));
  }
  if (fillchar !== undefined && (!Sk.builtin.checkString(fillchar) || fillchar.v.length !== 1)) {
    throw new Sk.builtin.TypeError('must be char, not ' + Sk.abstr.typeName(fillchar));
  }
  if (fillchar === undefined) {
    fillchar = ' ';
  } else {
    fillchar = fillchar.v;
  }
  len = Sk.builtin.asnum$(len);
  if (self.v.length >= len) {
    return self;
  } else {
    var newstr = Array.prototype.join.call({ length: Math.floor(len - self.v.length) + 1 }, fillchar);
    return new Sk.builtin.str(self.v + newstr);
  }
});
Sk.builtin.str.prototype['rjust'] = new Sk.builtin.func(function (self, len, fillchar) {
  Sk.builtin.pyCheckArgs('rjust', arguments, 2, 3);
  if (!Sk.builtin.checkInt(len)) {
    throw new Sk.builtin.TypeError('integer argument exepcted, got ' + Sk.abstr.typeName(len));
  }
  if (fillchar !== undefined && (!Sk.builtin.checkString(fillchar) || fillchar.v.length !== 1)) {
    throw new Sk.builtin.TypeError('must be char, not ' + Sk.abstr.typeName(fillchar));
  }
  if (fillchar === undefined) {
    fillchar = ' ';
  } else {
    fillchar = fillchar.v;
  }
  len = Sk.builtin.asnum$(len);
  if (self.v.length >= len) {
    return self;
  } else {
    var newstr = Array.prototype.join.call({ length: Math.floor(len - self.v.length) + 1 }, fillchar);
    return new Sk.builtin.str(newstr + self.v);
  }
});
Sk.builtin.str.prototype['center'] = new Sk.builtin.func(function (self, len, fillchar) {
  Sk.builtin.pyCheckArgs('center', arguments, 2, 3);
  if (!Sk.builtin.checkInt(len)) {
    throw new Sk.builtin.TypeError('integer argument exepcted, got ' + Sk.abstr.typeName(len));
  }
  if (fillchar !== undefined && (!Sk.builtin.checkString(fillchar) || fillchar.v.length !== 1)) {
    throw new Sk.builtin.TypeError('must be char, not ' + Sk.abstr.typeName(fillchar));
  }
  if (fillchar === undefined) {
    fillchar = ' ';
  } else {
    fillchar = fillchar.v;
  }
  len = Sk.builtin.asnum$(len);
  if (self.v.length >= len) {
    return self;
  } else {
    var newstr1 = Array.prototype.join.call({ length: Math.floor((len - self.v.length) / 2) + 1 }, fillchar);
    var newstr = newstr1 + self.v + newstr1;
    if (newstr.length < len) {
      newstr = newstr + fillchar;
    }
    return new Sk.builtin.str(newstr);
  }
});
Sk.builtin.str.prototype['find'] = new Sk.builtin.func(function (self, tgt, start, end) {
  Sk.builtin.pyCheckArgs('find', arguments, 2, 4);
  if (!Sk.builtin.checkString(tgt)) {
    throw new Sk.builtin.TypeError('expected a character buffer object');
  }
  if (start !== undefined && !Sk.builtin.checkInt(start)) {
    throw new Sk.builtin.TypeError('slice indices must be integers or None or have an __index__ method');
  }
  if (end !== undefined && !Sk.builtin.checkInt(end)) {
    throw new Sk.builtin.TypeError('slice indices must be integers or None or have an __index__ method');
  }
  if (start === undefined)
    start = 0;
  else {
    start = Sk.builtin.asnum$(start);
    start = start >= 0 ? start : self.v.length + start;
  }
  if (end === undefined)
    end = self.v.length;
  else {
    end = Sk.builtin.asnum$(end);
    end = end >= 0 ? end : self.v.length + end;
  }
  var idx = self.v.indexOf(tgt.v, start);
  idx = idx >= start && idx < end ? idx : -1;
  return new Sk.builtin.nmber(idx, Sk.builtin.nmber.int$);
});
Sk.builtin.str.prototype['index'] = new Sk.builtin.func(function (self, tgt, start, end) {
  Sk.builtin.pyCheckArgs('index', arguments, 2, 4);
  var idx = Sk.misceval.callsim(self['find'], self, tgt, start, end);
  if (Sk.builtin.asnum$(idx) === -1) {
    throw new Sk.builtin.ValueError('substring not found');
  }
  ;
  return idx;
});
Sk.builtin.str.prototype['rfind'] = new Sk.builtin.func(function (self, tgt, start, end) {
  Sk.builtin.pyCheckArgs('rfind', arguments, 2, 4);
  if (!Sk.builtin.checkString(tgt)) {
    throw new Sk.builtin.TypeError('expected a character buffer object');
  }
  if (start !== undefined && !Sk.builtin.checkInt(start)) {
    throw new Sk.builtin.TypeError('slice indices must be integers or None or have an __index__ method');
  }
  if (end !== undefined && !Sk.builtin.checkInt(end)) {
    throw new Sk.builtin.TypeError('slice indices must be integers or None or have an __index__ method');
  }
  if (start === undefined)
    start = 0;
  else {
    start = Sk.builtin.asnum$(start);
    start = start >= 0 ? start : self.v.length + start;
  }
  if (end === undefined)
    end = self.v.length;
  else {
    end = Sk.builtin.asnum$(end);
    end = end >= 0 ? end : self.v.length + end;
  }
  var idx = self.v.lastIndexOf(tgt.v, end);
  idx = idx !== end ? idx : self.v.lastIndexOf(tgt.v, end - 1);
  idx = idx >= start && idx < end ? idx : -1;
  return new Sk.builtin.nmber(idx, Sk.builtin.nmber.int$);
});
Sk.builtin.str.prototype['rindex'] = new Sk.builtin.func(function (self, tgt, start, end) {
  Sk.builtin.pyCheckArgs('rindex', arguments, 2, 4);
  var idx = Sk.misceval.callsim(self['rfind'], self, tgt, start, end);
  if (Sk.builtin.asnum$(idx) === -1) {
    throw new Sk.builtin.ValueError('substring not found');
  }
  ;
  return idx;
});
Sk.builtin.str.prototype['startswith'] = new Sk.builtin.func(function (self, tgt) {
  Sk.builtin.pyCheckArgs('startswith', arguments, 2, 2);
  Sk.builtin.pyCheckType('tgt', 'string', Sk.builtin.checkString(tgt));
  return Sk.builtin.bool(0 == self.v.indexOf(tgt.v));
});
Sk.builtin.str.prototype['endswith'] = new Sk.builtin.func(function (self, tgt) {
  Sk.builtin.pyCheckArgs('endswith', arguments, 2, 2);
  Sk.builtin.pyCheckType('tgt', 'string', Sk.builtin.checkString(tgt));
  return Sk.builtin.bool(self.v.indexOf(tgt.v, self.v.length - tgt.v.length) !== -1);
});
Sk.builtin.str.prototype['replace'] = new Sk.builtin.func(function (self, oldS, newS, count) {
  Sk.builtin.pyCheckArgs('replace', arguments, 3, 4);
  Sk.builtin.pyCheckType('oldS', 'string', Sk.builtin.checkString(oldS));
  Sk.builtin.pyCheckType('newS', 'string', Sk.builtin.checkString(newS));
  if (count !== undefined && !Sk.builtin.checkInt(count)) {
    throw new Sk.builtin.TypeError('integer argument expected, got ' + Sk.abstr.typeName(count));
  }
  count = Sk.builtin.asnum$(count);
  var patt = new RegExp(Sk.builtin.str.re_escape_(oldS.v), 'g');
  if (count === undefined || count < 0) {
    return new Sk.builtin.str(self.v.replace(patt, newS.v));
  }
  var c = 0;
  function replacer(match) {
    c++;
    if (c <= count) {
      return newS.v;
    }
    return match;
  }
  return new Sk.builtin.str(self.v.replace(patt, replacer));
});
Sk.builtin.str.prototype['isdigit'] = new Sk.builtin.func(function (self) {
  Sk.builtin.pyCheckArgs('isdigit', arguments, 1, 1);
  if (self.v.length === 0) {
    return Sk.builtin.bool(false);
  }
  var i;
  for (i = 0; i < self.v.length; i++) {
    var ch = self.v.charAt(i);
    if (ch < '0' || ch > '9') {
      return Sk.builtin.bool(false);
    }
    ;
  }
  ;
  return Sk.builtin.bool(true);
});
Sk.builtin.str.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('str', Sk.builtin.str);
Sk.builtin.str.prototype.nb$remainder = function (rhs) {
  if (rhs.constructor !== Sk.builtin.tuple && (rhs.mp$subscript === undefined || rhs.constructor === Sk.builtin.str))
    rhs = new Sk.builtin.tuple([rhs]);
  var regex = /%(\([a-zA-Z0-9]+\))?([#0 +\-]+)?(\*|[0-9]+)?(\.(\*|[0-9]+))?[hlL]?([diouxXeEfFgGcrs%])/g;
  var index = 0;
  var replFunc = function (substring, mappingKey, conversionFlags, fieldWidth, precision, precbody, conversionType) {
    fieldWidth = Sk.builtin.asnum$(fieldWidth);
    precision = Sk.builtin.asnum$(precision);
    var i;
    if (mappingKey === undefined || mappingKey === '')
      i = index++;
    var zeroPad = false;
    var leftAdjust = false;
    var blankBeforePositive = false;
    var precedeWithSign = false;
    var alternateForm = false;
    if (conversionFlags) {
      if (conversionFlags.indexOf('-') !== -1)
        leftAdjust = true;
      else if (conversionFlags.indexOf('0') !== -1)
        zeroPad = true;
      if (conversionFlags.indexOf('+') !== -1)
        precedeWithSign = true;
      else if (conversionFlags.indexOf(' ') !== -1)
        blankBeforePositive = true;
      alternateForm = conversionFlags.indexOf('#') !== -1;
    }
    if (precision) {
      precision = parseInt(precision.substr(1), 10);
    }
    var formatNumber = function (n, base) {
      base = Sk.builtin.asnum$(base);
      var j;
      var r;
      var neg = false;
      var didSign = false;
      if (typeof n === 'number') {
        if (n < 0) {
          n = -n;
          neg = true;
        }
        r = n.toString(base);
      } else if (n instanceof Sk.builtin.nmber) {
        r = n.str$(base, false);
        if (r.length > 2 && r.substr(-2) === '.0')
          r = r.substr(0, r.length - 2);
        neg = n.nb$isnegative();
      } else if (n instanceof Sk.builtin.lng) {
        r = n.str$(base, false);
        neg = n.nb$isnegative();
      }
      goog.asserts.assert(r !== undefined, 'unhandled number format');
      var precZeroPadded = false;
      if (precision) {
        for (j = r.length; j < precision; ++j) {
          r = '0' + r;
          precZeroPadded = true;
        }
      }
      var prefix = '';
      if (neg)
        prefix = '-';
      else if (precedeWithSign)
        prefix = '+' + prefix;
      else if (blankBeforePositive)
        prefix = ' ' + prefix;
      if (alternateForm) {
        if (base === 16)
          prefix += '0x';
        else if (base === 8 && !precZeroPadded && r !== '0')
          prefix += '0';
      }
      return [
        prefix,
        r
      ];
    };
    var handleWidth = function (args) {
      var prefix = args[0];
      var r = args[1];
      var j;
      if (fieldWidth) {
        fieldWidth = parseInt(fieldWidth, 10);
        var totLen = r.length + prefix.length;
        if (zeroPad)
          for (j = totLen; j < fieldWidth; ++j)
            r = '0' + r;
        else if (leftAdjust)
          for (j = totLen; j < fieldWidth; ++j)
            r = r + ' ';
        else
          for (j = totLen; j < fieldWidth; ++j)
            prefix = ' ' + prefix;
      }
      return prefix + r;
    };
    var value;
    if (rhs.constructor === Sk.builtin.tuple) {
      value = rhs.v[i];
    } else if (rhs.mp$subscript !== undefined) {
      var mk = mappingKey.substring(1, mappingKey.length - 1);
      value = rhs.mp$subscript(new Sk.builtin.str(mk));
    } else
      throw new Sk.builtin.AttributeError(rhs.tp$name + ' instance has no attribute \'mp$subscript\'');
    var r;
    var base = 10;
    switch (conversionType) {
    case 'd':
    case 'i':
      return handleWidth(formatNumber(value, 10));
    case 'o':
      return handleWidth(formatNumber(value, 8));
    case 'x':
      return handleWidth(formatNumber(value, 16));
    case 'X':
      return handleWidth(formatNumber(value, 16)).toUpperCase();
    case 'f':
    case 'F':
    case 'e':
    case 'E':
    case 'g':
    case 'G':
      var convValue = Sk.builtin.asnum$(value);
      if (typeof convValue === 'string')
        convValue = Number(convValue);
      if (convValue === Infinity)
        return 'inf';
      if (convValue === -Infinity)
        return '-inf';
      if (isNaN(convValue))
        return 'nan';
      var convName = [
          'toExponential',
          'toFixed',
          'toPrecision'
        ]['efg'.indexOf(conversionType.toLowerCase())];
      if (precision === undefined || precision === '')
        if (conversionType === 'e' || conversionType === 'E')
          precision = 6;
        else if (conversionType === 'f' || conversionType === 'F')
          precision = 7;
      var result = convValue[convName](precision);
      if ('EFG'.indexOf(conversionType) !== -1)
        result = result.toUpperCase();
      return handleWidth([
        '',
        result
      ]);
    case 'c':
      if (typeof value === 'number')
        return String.fromCharCode(value);
      else if (value instanceof Sk.builtin.nmber)
        return String.fromCharCode(value.v);
      else if (value instanceof Sk.builtin.lng)
        return String.fromCharCode(value.str$(10, false)[0]);
      else if (value.constructor === Sk.builtin.str)
        return value.v.substr(0, 1);
      else
        throw new Sk.builtin.TypeError('an integer is required');
      break;
    case 'r':
      r = Sk.builtin.repr(value);
      if (precision)
        return r.v.substr(0, precision);
      return r.v;
    case 's':
      r = new Sk.builtin.str(value);
      if (precision)
        return r.v.substr(0, precision);
      return r.v;
    case '%':
      return '%';
    }
  };
  var ret = this.v.replace(regex, replFunc);
  return new Sk.builtin.str(ret);
};
Sk.builtin.tuple = function (L) {
  if (!(this instanceof Sk.builtin.tuple))
    return new Sk.builtin.tuple(L);
  if (L === undefined) {
    L = [];
  }
  if (Object.prototype.toString.apply(L) === '[object Array]') {
    this.v = L;
  } else {
    if (L.tp$iter) {
      this.v = [];
      for (var it = L.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext())
        this.v.push(i);
    } else
      throw new Sk.builtin.ValueError('expecting Array or iterable');
  }
  this.__class__ = Sk.builtin.tuple;
  this['v'] = this.v;
  return this;
};
Sk.builtin.tuple.prototype.tp$name = 'tuple';
Sk.builtin.tuple.prototype.tp$str = function () {
  if (this.v.length === 0)
    return new Sk.builtin.str('()');
  var bits = [];
  for (var i = 0; i < this.v.length; ++i) {
    bits[i] = Sk.ffi.remapToJs(Sk.ffh.str(this.v[i]));
  }
  var ret = bits.join(', ');
  if (this.v.length === 1)
    ret += ',';
  return new Sk.builtin.str('(' + ret + ')');
};
Sk.builtin.tuple.prototype.tp$repr = function () {
  if (this.v.length === 0)
    return new Sk.builtin.str('()');
  var bits = [];
  for (var i = 0; i < this.v.length; ++i) {
    bits[i] = Sk.misceval.objectRepr(this.v[i]).v;
  }
  var ret = bits.join(', ');
  if (this.v.length === 1)
    ret += ',';
  return new Sk.builtin.str('(' + ret + ')');
};
Sk.builtin.tuple.prototype.mp$subscript = function (index) {
  if (Sk.misceval.isIndex(index)) {
    var i = Sk.misceval.asIndex(index);
    if (i !== undefined) {
      if (i < 0)
        i = this.v.length + i;
      if (i < 0 || i >= this.v.length) {
        throw new Sk.builtin.IndexError('tuple index out of range');
      }
      return this.v[i];
    }
  } else if (index instanceof Sk.builtin.slice) {
    var ret = [];
    index.sssiter$(this, function (i, wrt) {
      ret.push(wrt.v[i]);
    });
    return new Sk.builtin.tuple(ret);
  }
  throw new Sk.builtin.TypeError('tuple indices must be integers, not ' + Sk.abstr.typeName(index));
};
Sk.builtin.tuple.prototype.tp$hash = function () {
  var mult = 1000003;
  var x = 3430008;
  var len = this.v.length;
  for (var i = 0; i < len; ++i) {
    var y = Sk.builtin.hash(this.v[i]);
    if (y === -1)
      return -1;
    x = (x ^ y) * mult;
    mult += 82520 + len + len;
  }
  x += 97531;
  if (x === -1)
    x = -2;
  return x;
};
Sk.builtin.tuple.prototype.sq$repeat = function (n) {
  n = Sk.builtin.asnum$(n);
  var ret = [];
  for (var i = 0; i < n; ++i)
    for (var j = 0; j < this.v.length; ++j)
      ret.push(this.v[j]);
  return new Sk.builtin.tuple(ret);
};
Sk.builtin.tuple.prototype.nb$multiply = Sk.builtin.tuple.prototype.sq$repeat;
Sk.builtin.tuple.prototype.nb$inplace_multiply = Sk.builtin.tuple.prototype.sq$repeat;
Sk.builtin.tuple.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('tuple', Sk.builtin.tuple);
Sk.builtin.tuple.prototype.tp$iter = function () {
  var ret = {
      tp$iter: function () {
        return ret;
      },
      $obj: this,
      $index: 0,
      tp$iternext: function () {
        if (ret.$index >= ret.$obj.v.length)
          return undefined;
        return ret.$obj.v[ret.$index++];
      }
    };
  return ret;
};
Sk.builtin.tuple.prototype['__iter__'] = new Sk.builtin.func(function (self) {
  Sk.builtin.pyCheckArgs('__iter__', arguments, 1, 1);
  return self.tp$iter();
});
Sk.builtin.tuple.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
Sk.builtin.tuple.prototype.tp$richcompare = function (w, op) {
  if (!w.__class__ || w.__class__ != Sk.builtin.tuple) {
    if (op === 'Eq')
      return false;
    if (op === 'NotEq')
      return true;
    return false;
  }
  var v = this.v;
  var w = w.v;
  var vl = v.length;
  var wl = w.length;
  var i;
  for (i = 0; i < vl && i < wl; ++i) {
    var k = Sk.misceval.richCompareBool(v[i], w[i], 'Eq');
    if (!k)
      break;
  }
  if (i >= vl || i >= wl) {
    switch (op) {
    case 'Lt':
      return vl < wl;
    case 'LtE':
      return vl <= wl;
    case 'Eq':
      return vl === wl;
    case 'NotEq':
      return vl !== wl;
    case 'Gt':
      return vl > wl;
    case 'GtE':
      return vl >= wl;
    default:
      goog.asserts.fail();
    }
  }
  if (op === 'Eq')
    return false;
  if (op === 'NotEq')
    return true;
  return Sk.misceval.richCompareBool(v[i], w[i], op);
};
Sk.builtin.tuple.prototype.sq$concat = function (other) {
  return new Sk.builtin.tuple(this.v.concat(other.v));
};
Sk.builtin.tuple.prototype.nb$add = Sk.builtin.tuple.prototype.sq$concat;
Sk.builtin.tuple.prototype.nb$inplace_add = Sk.builtin.tuple.prototype.sq$concat;
Sk.builtin.tuple.prototype.sq$length = function () {
  return this.v.length;
};
Sk.builtin.tuple.prototype['index'] = new Sk.builtin.func(function (self, item) {
  var len = self.v.length;
  var obj = self.v;
  for (var i = 0; i < len; ++i) {
    if (Sk.misceval.richCompareBool(obj[i], item, 'Eq'))
      return i;
  }
  throw new Sk.builtin.ValueError('tuple.index(x): x not in tuple');
});
Sk.builtin.tuple.prototype['count'] = new Sk.builtin.func(function (self, item) {
  var len = self.v.length;
  var obj = self.v;
  var count = 0;
  for (var i = 0; i < len; ++i) {
    if (Sk.misceval.richCompareBool(obj[i], item, 'Eq')) {
      count += 1;
    }
  }
  return count;
});
goog.exportSymbol('Sk.builtin.tuple', Sk.builtin.tuple);
Sk.builtin.dict = function dict(L) {
  if (!(this instanceof Sk.builtin.dict))
    return new Sk.builtin.dict(L);
  if (L === undefined) {
    L = [];
  }
  this.size = 0;
  if (Object.prototype.toString.apply(L) === '[object Array]') {
    for (var i = 0; i < L.length; i += 2) {
      this.mp$ass_subscript(L[i], L[i + 1]);
    }
  } else if (L instanceof Sk.builtin.dict) {
    for (var it = L.tp$iter(), k = it.tp$iternext(); k !== undefined; k = it.tp$iternext()) {
      var v = L.mp$subscript(k);
      if (v === undefined) {
        v = null;
      }
      this.mp$ass_subscript(k, v);
    }
  } else if (L.tp$iter) {
    for (var it = L.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {
      if (i.mp$subscript) {
        this.mp$ass_subscript(i.mp$subscript(0), i.mp$subscript(1));
      } else {
        throw new Sk.builtin.TypeError('element ' + this.size + ' is not a sequence');
      }
    }
  } else {
    throw new Sk.builtin.TypeError('object is not iterable');
  }
  this.__class__ = Sk.builtin.dict;
  return this;
};
Sk.builtin.dict.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('dict', Sk.builtin.dict);
var kf = Sk.builtin.hash;
Sk.builtin.dict.prototype.key$lookup = function (bucket, key) {
  var item;
  var eq;
  var i;
  for (i = 0; i < bucket.items.length; i++) {
    item = bucket.items[i];
    eq = Sk.misceval.richCompareBool(item.lhs, key, 'Eq');
    if (eq) {
      return item;
    }
  }
  return null;
};
Sk.builtin.dict.prototype.key$pop = function (bucket, key) {
  var item;
  var eq;
  var i;
  for (i = 0; i < bucket.items.length; i++) {
    item = bucket.items[i];
    eq = Sk.misceval.richCompareBool(item.lhs, key, 'Eq');
    if (eq) {
      bucket.items.splice(i, 1);
      this.size -= 1;
      return item;
    }
  }
  return undefined;
};
Sk.builtin.dict.prototype.mp$lookup = function (key) {
  var bucket = this[kf(key)];
  var item;
  if (bucket !== undefined) {
    item = this.key$lookup(bucket, key);
    if (item) {
      return item.rhs;
    }
    ;
  }
  return undefined;
};
Sk.builtin.dict.prototype.mp$subscript = function (key) {
  var res = this.mp$lookup(key);
  if (res !== undefined) {
    return res;
  } else {
    var s = new Sk.builtin.str(key);
    throw new Sk.builtin.KeyError(s.v);
  }
};
Sk.builtin.dict.prototype.sq$contains = function (ob) {
  var res = this.mp$lookup(ob);
  return res !== undefined;
};
Sk.builtin.dict.prototype.mp$ass_subscript = function (key, w) {
  var k = kf(key);
  var bucket = this[k];
  var item;
  if (bucket === undefined) {
    bucket = {
      $hash: k,
      items: [{
          lhs: key,
          rhs: w
        }]
    };
    this[k] = bucket;
    this.size += 1;
    return;
  }
  item = this.key$lookup(bucket, key);
  if (item) {
    item.rhs = w;
    return;
  }
  ;
  bucket.items.push({
    lhs: key,
    rhs: w
  });
  this.size += 1;
};
Sk.builtin.dict.prototype.mp$del_subscript = function (key) {
  var bucket = this[kf(key)];
  var item;
  var s;
  if (bucket !== undefined) {
    item = this.key$pop(bucket, key);
    if (item !== undefined) {
      return;
    }
    ;
  }
  s = new Sk.builtin.str(key);
  throw new Sk.builtin.KeyError(s.v);
};
Sk.builtin.dict.prototype.tp$iter = function () {
  var allkeys = [];
  for (var k in this) {
    if (this.hasOwnProperty(k)) {
      var bucket = this[k];
      if (bucket && bucket.$hash !== undefined) {
        for (var i = 0; i < bucket.items.length; i++) {
          allkeys.push(bucket.items[i].lhs);
        }
      }
    }
  }
  var ret = {
      tp$iter: function () {
        return ret;
      },
      $obj: this,
      $index: 0,
      $keys: allkeys,
      tp$iternext: function () {
        if (ret.$index >= ret.$keys.length)
          return undefined;
        return ret.$keys[ret.$index++];
      }
    };
  return ret;
};
Sk.builtin.dict.prototype['__iter__'] = new Sk.builtin.func(function (self) {
  Sk.builtin.pyCheckArgs('__iter__', arguments, 1, 1);
  return self.tp$iter();
});
Sk.builtin.dict.prototype.tp$repr = function () {
  var ret = [];
  for (var iter = this.tp$iter(), k = iter.tp$iternext(); k !== undefined; k = iter.tp$iternext()) {
    var v = this.mp$subscript(k);
    if (v === undefined) {
      v = null;
    }
    ret.push(Sk.misceval.objectRepr(k).v + ': ' + Sk.misceval.objectRepr(v).v);
  }
  return new Sk.builtin.str('{' + ret.join(', ') + '}');
};
Sk.builtin.dict.prototype.mp$length = function () {
  return this.size;
};
Sk.builtin.dict.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
Sk.builtin.dict.prototype.tp$hash = Sk.builtin.object.prototype.HashNotImplemented;
Sk.builtin.dict.prototype.tp$richcompare = function (other, op) {
  if (this === other && Sk.misceval.opAllowsEquality(op))
    return true;
  switch (op) {
  case 'Lt':
    return undefined;
  case 'LtE':
    return undefined;
  case 'Eq':
    break;
  case 'NotEq':
    break;
  case 'Gt':
    return undefined;
  case 'GtE':
    return undefined;
  default:
    goog.asserts.fail();
  }
  if (!(other instanceof Sk.builtin.dict)) {
    if (op === 'Eq') {
      return false;
    } else {
      return true;
    }
  }
  var thisl = this.size;
  var otherl = other.size;
  if (thisl !== otherl) {
    if (op === 'Eq') {
      return false;
    } else {
      return true;
    }
  }
  for (var iter = this.tp$iter(), k = iter.tp$iternext(); k !== undefined; k = iter.tp$iternext()) {
    var v = this.mp$subscript(k);
    var otherv = other.mp$subscript(k);
    if (!Sk.misceval.richCompareBool(v, otherv, 'Eq')) {
      if (op === 'Eq') {
        return false;
      } else {
        return true;
      }
    }
  }
  if (op === 'Eq') {
    return true;
  } else {
    return false;
  }
};
Sk.builtin.dict.prototype['get'] = new Sk.builtin.func(function (self, k, d) {
  var ret;
  if (d === undefined) {
    d = null;
  }
  ret = self.mp$lookup(k);
  if (ret === undefined) {
    ret = d;
  }
  return ret;
});
Sk.builtin.dict.prototype['has_key'] = new Sk.builtin.func(function (self, k) {
  return self.sq$contains(k);
});
Sk.builtin.dict.prototype['items'] = new Sk.builtin.func(function (self) {
  var ret = [];
  for (var iter = self.tp$iter(), k = iter.tp$iternext(); k !== undefined; k = iter.tp$iternext()) {
    var v = self.mp$subscript(k);
    if (v === undefined) {
      v = null;
    }
    ret.push(new Sk.builtin.tuple([
      k,
      v
    ]));
  }
  return new Sk.builtin.list(ret);
});
Sk.builtin.dict.prototype['keys'] = new Sk.builtin.func(function (self) {
  var ret = [];
  for (var iter = self.tp$iter(), k = iter.tp$iternext(); k !== undefined; k = iter.tp$iternext()) {
    ret.push(k);
  }
  return new Sk.builtin.list(ret);
});
Sk.builtin.dict.prototype['values'] = new Sk.builtin.func(function (self) {
  var ret = [];
  for (var iter = self.tp$iter(), k = iter.tp$iternext(); k !== undefined; k = iter.tp$iternext()) {
    var v = self.mp$subscript(k);
    if (v === undefined) {
      v = null;
    }
    ret.push(v);
  }
  return new Sk.builtin.list(ret);
});
Sk.builtin.dict.prototype.tp$name = 'dict';
goog.exportSymbol('Sk.builtin.dict', Sk.builtin.dict);
Sk.builtin.biginteger = function (a, b, c) {
  if (a != null)
    if ('number' == typeof a)
      this.fromNumber(a, b, c);
    else if (b == null && 'string' != typeof a)
      this.fromString(a, 256);
    else
      this.fromString(a, b);
};
Sk.builtin.biginteger.canary = 244837814094590;
Sk.builtin.biginteger.j_lm = (Sk.builtin.biginteger.canary & 16777215) == 15715070;
Sk.builtin.biginteger.nbi = function () {
  return new Sk.builtin.biginteger(null);
};
Sk.builtin.biginteger.prototype.am1 = function (i, x, w, j, c, n) {
  while (--n >= 0) {
    var v = x * this[i++] + w[j] + c;
    c = Math.floor(v / 67108864);
    w[j++] = v & 67108863;
  }
  return c;
};
Sk.builtin.biginteger.prototype.am2 = function (i, x, w, j, c, n) {
  var xl = x & 32767, xh = x >> 15;
  while (--n >= 0) {
    var l = this[i] & 32767;
    var h = this[i++] >> 15;
    var m = xh * l + h * xl;
    l = xl * l + ((m & 32767) << 15) + w[j] + (c & 1073741823);
    c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
    w[j++] = l & 1073741823;
  }
  return c;
};
Sk.builtin.biginteger.prototype.am3 = function (i, x, w, j, c, n) {
  var xl = x & 16383, xh = x >> 14;
  while (--n >= 0) {
    var l = this[i] & 16383;
    var h = this[i++] >> 14;
    var m = xh * l + h * xl;
    l = xl * l + ((m & 16383) << 14) + w[j] + c;
    c = (l >> 28) + (m >> 14) + xh * h;
    w[j++] = l & 268435455;
  }
  return c;
};
Sk.builtin.biginteger.prototype.am = Sk.builtin.biginteger.prototype.am3;
Sk.builtin.biginteger.dbits = 28;
Sk.builtin.biginteger.prototype.DB = Sk.builtin.biginteger.dbits;
Sk.builtin.biginteger.prototype.DM = (1 << Sk.builtin.biginteger.dbits) - 1;
Sk.builtin.biginteger.prototype.DV = 1 << Sk.builtin.biginteger.dbits;
Sk.builtin.biginteger.BI_FP = 52;
Sk.builtin.biginteger.prototype.FV = Math.pow(2, Sk.builtin.biginteger.BI_FP);
Sk.builtin.biginteger.prototype.F1 = Sk.builtin.biginteger.BI_FP - Sk.builtin.biginteger.dbits;
Sk.builtin.biginteger.prototype.F2 = 2 * Sk.builtin.biginteger.dbits - Sk.builtin.biginteger.BI_FP;
Sk.builtin.biginteger.BI_RM = '0123456789abcdefghijklmnopqrstuvwxyz';
Sk.builtin.biginteger.BI_RC = new Array();
var rr, vv;
rr = '0'.charCodeAt(0);
for (vv = 0; vv <= 9; ++vv)
  Sk.builtin.biginteger.BI_RC[rr++] = vv;
rr = 'a'.charCodeAt(0);
for (vv = 10; vv < 36; ++vv)
  Sk.builtin.biginteger.BI_RC[rr++] = vv;
rr = 'A'.charCodeAt(0);
for (vv = 10; vv < 36; ++vv)
  Sk.builtin.biginteger.BI_RC[rr++] = vv;
Sk.builtin.biginteger.int2char = function (n) {
  return Sk.builtin.biginteger.BI_RM.charAt(n);
};
Sk.builtin.biginteger.intAt = function (s, i) {
  var c = Sk.builtin.biginteger.BI_RC[s.charCodeAt(i)];
  return c == null ? -1 : c;
};
Sk.builtin.biginteger.prototype.bnpCopyTo = function (r) {
  for (var i = this.t - 1; i >= 0; --i)
    r[i] = this[i];
  r.t = this.t;
  r.s = this.s;
};
Sk.builtin.biginteger.prototype.bnpFromInt = function (x) {
  this.t = 1;
  this.s = x < 0 ? -1 : 0;
  if (x > 0)
    this[0] = x;
  else if (x < -1)
    this[0] = x + this.DV;
  else
    this.t = 0;
};
Sk.builtin.biginteger.nbv = function (i) {
  var r = new Sk.builtin.biginteger(null);
  r.bnpFromInt(i);
  return r;
};
Sk.builtin.biginteger.prototype.bnpFromString = function (s, b) {
  var k;
  if (b == 16)
    k = 4;
  else if (b == 8)
    k = 3;
  else if (b == 256)
    k = 8;
  else if (b == 2)
    k = 1;
  else if (b == 32)
    k = 5;
  else if (b == 4)
    k = 2;
  else {
    this.fromRadix(s, b);
    return;
  }
  this.t = 0;
  this.s = 0;
  var i = s.length, mi = false, sh = 0;
  while (--i >= 0) {
    var x = k == 8 ? s[i] & 255 : Sk.builtin.biginteger.intAt(s, i);
    if (x < 0) {
      if (s.charAt(i) == '-')
        mi = true;
      continue;
    }
    mi = false;
    if (sh == 0)
      this[this.t++] = x;
    else if (sh + k > this.DB) {
      this[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
      this[this.t++] = x >> this.DB - sh;
    } else
      this[this.t - 1] |= x << sh;
    sh += k;
    if (sh >= this.DB)
      sh -= this.DB;
  }
  if (k == 8 && (s[0] & 128) != 0) {
    this.s = -1;
    if (sh > 0)
      this[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
  }
  this.clamp();
  if (mi)
    Sk.builtin.biginteger.ZERO.subTo(this, this);
};
Sk.builtin.biginteger.prototype.bnpClamp = function () {
  var c = this.s & this.DM;
  while (this.t > 0 && this[this.t - 1] == c)
    --this.t;
};
Sk.builtin.biginteger.prototype.bnToString = function (b) {
  if (this.s < 0)
    return '-' + this.negate().toString(b);
  var k;
  if (b == 16)
    k = 4;
  else if (b == 8)
    k = 3;
  else if (b == 2)
    k = 1;
  else if (b == 32)
    k = 5;
  else if (b == 4)
    k = 2;
  else
    return this.toRadix(b);
  var km = (1 << k) - 1, d, m = false, r = '', i = this.t;
  var p = this.DB - i * this.DB % k;
  if (i-- > 0) {
    if (p < this.DB && (d = this[i] >> p) > 0) {
      m = true;
      r = Sk.builtin.biginteger.int2char(d);
    }
    while (i >= 0) {
      if (p < k) {
        d = (this[i] & (1 << p) - 1) << k - p;
        d |= this[--i] >> (p += this.DB - k);
      } else {
        d = this[i] >> (p -= k) & km;
        if (p <= 0) {
          p += this.DB;
          --i;
        }
      }
      if (d > 0)
        m = true;
      if (m)
        r += Sk.builtin.biginteger.int2char(d);
    }
  }
  return m ? r : '0';
};
Sk.builtin.biginteger.prototype.bnNegate = function () {
  var r = Sk.builtin.biginteger.nbi();
  Sk.builtin.biginteger.ZERO.subTo(this, r);
  return r;
};
Sk.builtin.biginteger.prototype.bnAbs = function () {
  return this.s < 0 ? this.negate() : this;
};
Sk.builtin.biginteger.prototype.bnCompareTo = function (a) {
  var r = this.s - a.s;
  if (r != 0)
    return r;
  var i = this.t;
  r = i - a.t;
  if (r != 0)
    return this.s < 0 ? -r : r;
  while (--i >= 0)
    if ((r = this[i] - a[i]) != 0)
      return r;
  return 0;
};
Sk.builtin.biginteger.nbits = function (x) {
  var r = 1, t;
  if ((t = x >>> 16) != 0) {
    x = t;
    r += 16;
  }
  if ((t = x >> 8) != 0) {
    x = t;
    r += 8;
  }
  if ((t = x >> 4) != 0) {
    x = t;
    r += 4;
  }
  if ((t = x >> 2) != 0) {
    x = t;
    r += 2;
  }
  if ((t = x >> 1) != 0) {
    x = t;
    r += 1;
  }
  return r;
};
Sk.builtin.biginteger.prototype.bnBitLength = function () {
  if (this.t <= 0)
    return 0;
  return this.DB * (this.t - 1) + Sk.builtin.biginteger.nbits(this[this.t - 1] ^ this.s & this.DM);
};
Sk.builtin.biginteger.prototype.bnpDLShiftTo = function (n, r) {
  var i;
  for (i = this.t - 1; i >= 0; --i)
    r[i + n] = this[i];
  for (i = n - 1; i >= 0; --i)
    r[i] = 0;
  r.t = this.t + n;
  r.s = this.s;
};
Sk.builtin.biginteger.prototype.bnpDRShiftTo = function (n, r) {
  for (var i = n; i < this.t; ++i)
    r[i - n] = this[i];
  r.t = Math.max(this.t - n, 0);
  r.s = this.s;
};
Sk.builtin.biginteger.prototype.bnpLShiftTo = function (n, r) {
  var bs = n % this.DB;
  var cbs = this.DB - bs;
  var bm = (1 << cbs) - 1;
  var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
  for (i = this.t - 1; i >= 0; --i) {
    r[i + ds + 1] = this[i] >> cbs | c;
    c = (this[i] & bm) << bs;
  }
  for (i = ds - 1; i >= 0; --i)
    r[i] = 0;
  r[ds] = c;
  r.t = this.t + ds + 1;
  r.s = this.s;
  r.clamp();
};
Sk.builtin.biginteger.prototype.bnpRShiftTo = function (n, r) {
  r.s = this.s;
  var ds = Math.floor(n / this.DB);
  if (ds >= this.t) {
    r.t = 0;
    return;
  }
  var bs = n % this.DB;
  var cbs = this.DB - bs;
  var bm = (1 << bs) - 1;
  r[0] = this[ds] >> bs;
  for (var i = ds + 1; i < this.t; ++i) {
    r[i - ds - 1] |= (this[i] & bm) << cbs;
    r[i - ds] = this[i] >> bs;
  }
  if (bs > 0)
    r[this.t - ds - 1] |= (this.s & bm) << cbs;
  r.t = this.t - ds;
  r.clamp();
};
Sk.builtin.biginteger.prototype.bnpSubTo = function (a, r) {
  var i = 0, c = 0, m = Math.min(a.t, this.t);
  while (i < m) {
    c += this[i] - a[i];
    r[i++] = c & this.DM;
    c >>= this.DB;
  }
  if (a.t < this.t) {
    c -= a.s;
    while (i < this.t) {
      c += this[i];
      r[i++] = c & this.DM;
      c >>= this.DB;
    }
    c += this.s;
  } else {
    c += this.s;
    while (i < a.t) {
      c -= a[i];
      r[i++] = c & this.DM;
      c >>= this.DB;
    }
    c -= a.s;
  }
  r.s = c < 0 ? -1 : 0;
  if (c < -1)
    r[i++] = this.DV + c;
  else if (c > 0)
    r[i++] = c;
  r.t = i;
  r.clamp();
};
Sk.builtin.biginteger.prototype.bnpMultiplyTo = function (a, r) {
  var x = this.abs(), y = a.abs();
  var i = x.t;
  r.t = i + y.t;
  while (--i >= 0)
    r[i] = 0;
  for (i = 0; i < y.t; ++i)
    r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
  r.s = 0;
  r.clamp();
  if (this.s != a.s)
    Sk.builtin.biginteger.ZERO.subTo(r, r);
};
Sk.builtin.biginteger.prototype.bnpSquareTo = function (r) {
  var x = this.abs();
  var i = r.t = 2 * x.t;
  while (--i >= 0)
    r[i] = 0;
  for (i = 0; i < x.t - 1; ++i) {
    var c = x.am(i, x[i], r, 2 * i, 0, 1);
    if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
      r[i + x.t] -= x.DV;
      r[i + x.t + 1] = 1;
    }
  }
  if (r.t > 0)
    r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
  r.s = 0;
  r.clamp();
};
Sk.builtin.biginteger.prototype.bnpDivRemTo = function (m, q, r) {
  var pm = m.abs();
  if (pm.t <= 0)
    return;
  var pt = this.abs();
  if (pt.t < pm.t) {
    if (q != null)
      q.fromInt(0);
    if (r != null)
      this.copyTo(r);
    return;
  }
  if (r == null)
    r = Sk.builtin.biginteger.nbi();
  var y = Sk.builtin.biginteger.nbi(), ts = this.s, ms = m.s;
  var nsh = this.DB - Sk.builtin.biginteger.nbits(pm[pm.t - 1]);
  if (nsh > 0) {
    pm.lShiftTo(nsh, y);
    pt.lShiftTo(nsh, r);
  } else {
    pm.copyTo(y);
    pt.copyTo(r);
  }
  var ys = y.t;
  var y0 = y[ys - 1];
  if (y0 == 0)
    return;
  var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);
  var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
  var i = r.t, j = i - ys, t = q == null ? Sk.builtin.biginteger.nbi() : q;
  y.dlShiftTo(j, t);
  if (r.compareTo(t) >= 0) {
    r[r.t++] = 1;
    r.subTo(t, r);
  }
  Sk.builtin.biginteger.ONE.dlShiftTo(ys, t);
  t.subTo(y, y);
  while (y.t < ys)
    y[y.t++] = 0;
  while (--j >= 0) {
    var qd = r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
    if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
      y.dlShiftTo(j, t);
      r.subTo(t, r);
      while (r[i] < --qd)
        r.subTo(t, r);
    }
  }
  if (q != null) {
    r.drShiftTo(ys, q);
    if (ts != ms)
      Sk.builtin.biginteger.ZERO.subTo(q, q);
  }
  r.t = ys;
  r.clamp();
  if (nsh > 0)
    r.rShiftTo(nsh, r);
  if (ts < 0)
    Sk.builtin.biginteger.ZERO.subTo(r, r);
};
Sk.builtin.biginteger.prototype.bnMod = function (a) {
  var r = Sk.builtin.biginteger.nbi();
  this.abs().divRemTo(a, null, r);
  if (this.s < 0 && r.compareTo(Sk.builtin.biginteger.ZERO) > 0)
    a.subTo(r, r);
  return r;
};
Sk.builtin.biginteger.Classic = function (m) {
  this.m = m;
};
Sk.builtin.biginteger.prototype.cConvert = function (x) {
  if (x.s < 0 || x.compareTo(this.m) >= 0)
    return x.mod(this.m);
  else
    return x;
};
Sk.builtin.biginteger.prototype.cRevert = function (x) {
  return x;
};
Sk.builtin.biginteger.prototype.cReduce = function (x) {
  x.divRemTo(this.m, null, x);
};
Sk.builtin.biginteger.prototype.cMulTo = function (x, y, r) {
  x.multiplyTo(y, r);
  this.reduce(r);
};
Sk.builtin.biginteger.prototype.cSqrTo = function (x, r) {
  x.squareTo(r);
  this.reduce(r);
};
Sk.builtin.biginteger.Classic.prototype.convert = Sk.builtin.biginteger.prototype.cConvert;
Sk.builtin.biginteger.Classic.prototype.revert = Sk.builtin.biginteger.prototype.cRevert;
Sk.builtin.biginteger.Classic.prototype.reduce = Sk.builtin.biginteger.prototype.cReduce;
Sk.builtin.biginteger.Classic.prototype.mulTo = Sk.builtin.biginteger.prototype.cMulTo;
Sk.builtin.biginteger.Classic.prototype.sqrTo = Sk.builtin.biginteger.prototype.cSqrTo;
Sk.builtin.biginteger.prototype.bnpInvDigit = function () {
  if (this.t < 1)
    return 0;
  var x = this[0];
  if ((x & 1) == 0)
    return 0;
  var y = x & 3;
  y = y * (2 - (x & 15) * y) & 15;
  y = y * (2 - (x & 255) * y) & 255;
  y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
  y = y * (2 - x * y % this.DV) % this.DV;
  return y > 0 ? this.DV - y : -y;
};
Sk.builtin.biginteger.Montgomery = function (m) {
  this.m = m;
  this.mp = m.invDigit();
  this.mpl = this.mp & 32767;
  this.mph = this.mp >> 15;
  this.um = (1 << m.DB - 15) - 1;
  this.mt2 = 2 * m.t;
};
Sk.builtin.biginteger.prototype.montConvert = function (x) {
  var r = Sk.builtin.biginteger.nbi();
  x.abs().dlShiftTo(this.m.t, r);
  r.divRemTo(this.m, null, r);
  if (x.s < 0 && r.compareTo(Sk.builtin.biginteger.ZERO) > 0)
    this.m.subTo(r, r);
  return r;
};
Sk.builtin.biginteger.prototype.montRevert = function (x) {
  var r = Sk.builtin.biginteger.nbi();
  x.copyTo(r);
  this.reduce(r);
  return r;
};
Sk.builtin.biginteger.prototype.montReduce = function (x) {
  while (x.t <= this.mt2)
    x[x.t++] = 0;
  for (var i = 0; i < this.m.t; ++i) {
    var j = x[i] & 32767;
    var u0 = j * this.mpl + ((j * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
    j = i + this.m.t;
    x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
    while (x[j] >= x.DV) {
      x[j] -= x.DV;
      x[++j]++;
    }
  }
  x.clamp();
  x.drShiftTo(this.m.t, x);
  if (x.compareTo(this.m) >= 0)
    x.subTo(this.m, x);
};
Sk.builtin.biginteger.prototype.montSqrTo = function (x, r) {
  x.squareTo(r);
  this.reduce(r);
};
Sk.builtin.biginteger.prototype.montMulTo = function (x, y, r) {
  x.multiplyTo(y, r);
  this.reduce(r);
};
Sk.builtin.biginteger.Montgomery.prototype.convert = Sk.builtin.biginteger.prototype.montConvert;
Sk.builtin.biginteger.Montgomery.prototype.revert = Sk.builtin.biginteger.prototype.montRevert;
Sk.builtin.biginteger.Montgomery.prototype.reduce = Sk.builtin.biginteger.prototype.montReduce;
Sk.builtin.biginteger.Montgomery.prototype.mulTo = Sk.builtin.biginteger.prototype.montMulTo;
Sk.builtin.biginteger.Montgomery.prototype.sqrTo = Sk.builtin.biginteger.prototype.montSqrTo;
Sk.builtin.biginteger.prototype.bnpIsEven = function () {
  return (this.t > 0 ? this[0] & 1 : this.s) == 0;
};
Sk.builtin.biginteger.prototype.bnpExp = function (e, z) {
  if (e > 4294967295 || e < 1)
    return Sk.builtin.biginteger.ONE;
  var r = Sk.builtin.biginteger.nbi(), r2 = Sk.builtin.biginteger.nbi(), g = z.convert(this), i = Sk.builtin.biginteger.nbits(e) - 1;
  g.copyTo(r);
  while (--i >= 0) {
    z.sqrTo(r, r2);
    if ((e & 1 << i) > 0)
      z.mulTo(r2, g, r);
    else {
      var t = r;
      r = r2;
      r2 = t;
    }
  }
  return z.revert(r);
};
Sk.builtin.biginteger.prototype.bnModPowInt = function (e, m) {
  var z;
  if (e < 256 || m.isEven())
    z = new Sk.builtin.biginteger.Classic(m);
  else
    z = new Sk.builtin.biginteger.Montgomery(m);
  return this.exp(e, z);
};
Sk.builtin.biginteger.prototype.copyTo = Sk.builtin.biginteger.prototype.bnpCopyTo;
Sk.builtin.biginteger.prototype.fromInt = Sk.builtin.biginteger.prototype.bnpFromInt;
Sk.builtin.biginteger.prototype.fromString = Sk.builtin.biginteger.prototype.bnpFromString;
Sk.builtin.biginteger.prototype.clamp = Sk.builtin.biginteger.prototype.bnpClamp;
Sk.builtin.biginteger.prototype.dlShiftTo = Sk.builtin.biginteger.prototype.bnpDLShiftTo;
Sk.builtin.biginteger.prototype.drShiftTo = Sk.builtin.biginteger.prototype.bnpDRShiftTo;
Sk.builtin.biginteger.prototype.lShiftTo = Sk.builtin.biginteger.prototype.bnpLShiftTo;
Sk.builtin.biginteger.prototype.rShiftTo = Sk.builtin.biginteger.prototype.bnpRShiftTo;
Sk.builtin.biginteger.prototype.subTo = Sk.builtin.biginteger.prototype.bnpSubTo;
Sk.builtin.biginteger.prototype.multiplyTo = Sk.builtin.biginteger.prototype.bnpMultiplyTo;
Sk.builtin.biginteger.prototype.squareTo = Sk.builtin.biginteger.prototype.bnpSquareTo;
Sk.builtin.biginteger.prototype.divRemTo = Sk.builtin.biginteger.prototype.bnpDivRemTo;
Sk.builtin.biginteger.prototype.invDigit = Sk.builtin.biginteger.prototype.bnpInvDigit;
Sk.builtin.biginteger.prototype.isEven = Sk.builtin.biginteger.prototype.bnpIsEven;
Sk.builtin.biginteger.prototype.exp = Sk.builtin.biginteger.prototype.bnpExp;
Sk.builtin.biginteger.prototype.toString = Sk.builtin.biginteger.prototype.bnToString;
Sk.builtin.biginteger.prototype.negate = Sk.builtin.biginteger.prototype.bnNegate;
Sk.builtin.biginteger.prototype.abs = Sk.builtin.biginteger.prototype.bnAbs;
Sk.builtin.biginteger.prototype.compareTo = Sk.builtin.biginteger.prototype.bnCompareTo;
Sk.builtin.biginteger.prototype.bitLength = Sk.builtin.biginteger.prototype.bnBitLength;
Sk.builtin.biginteger.prototype.mod = Sk.builtin.biginteger.prototype.bnMod;
Sk.builtin.biginteger.prototype.modPowInt = Sk.builtin.biginteger.prototype.bnModPowInt;
Sk.builtin.biginteger.ZERO = Sk.builtin.biginteger.nbv(0);
Sk.builtin.biginteger.ONE = Sk.builtin.biginteger.nbv(1);
Sk.builtin.biginteger.prototype.bnClone = function () {
  var r = Sk.builtin.biginteger.nbi();
  this.copyTo(r);
  return r;
};
Sk.builtin.biginteger.prototype.bnIntValue = function () {
  if (this.s < 0) {
    if (this.t == 1)
      return this[0] - this.DV;
    else if (this.t == 0)
      return -1;
  } else if (this.t == 1)
    return this[0];
  else if (this.t == 0)
    return 0;
  return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
};
Sk.builtin.biginteger.prototype.bnByteValue = function () {
  return this.t == 0 ? this.s : this[0] << 24 >> 24;
};
Sk.builtin.biginteger.prototype.bnShortValue = function () {
  return this.t == 0 ? this.s : this[0] << 16 >> 16;
};
Sk.builtin.biginteger.prototype.bnpChunkSize = function (r) {
  return Math.floor(Math.LN2 * this.DB / Math.log(r));
};
Sk.builtin.biginteger.prototype.bnSigNum = function () {
  if (this.s < 0)
    return -1;
  else if (this.t <= 0 || this.t == 1 && this[0] <= 0)
    return 0;
  else
    return 1;
};
Sk.builtin.biginteger.prototype.bnpToRadix = function (b) {
  if (b == null)
    b = 10;
  if (this.signum() == 0 || b < 2 || b > 36)
    return '0';
  var cs = this.chunkSize(b);
  var a = Math.pow(b, cs);
  var d = Sk.builtin.biginteger.nbv(a), y = Sk.builtin.biginteger.nbi(), z = Sk.builtin.biginteger.nbi(), r = '';
  this.divRemTo(d, y, z);
  while (y.signum() > 0) {
    r = (a + z.intValue()).toString(b).substr(1) + r;
    y.divRemTo(d, y, z);
  }
  return z.intValue().toString(b) + r;
};
Sk.builtin.biginteger.prototype.bnpFromRadix = function (s, b) {
  this.fromInt(0);
  if (b == null)
    b = 10;
  var cs = this.chunkSize(b);
  var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
  for (var i = 0; i < s.length; ++i) {
    var x = Sk.builtin.biginteger.intAt(s, i);
    if (x < 0) {
      if (s.charAt(i) == '-' && this.signum() == 0)
        mi = true;
      if (s.charAt(i) == '.')
        break;
      continue;
    }
    w = b * w + x;
    if (++j >= cs) {
      this.dMultiply(d);
      this.dAddOffset(w, 0);
      j = 0;
      w = 0;
    }
  }
  if (j > 0) {
    this.dMultiply(Math.pow(b, j));
    this.dAddOffset(w, 0);
  }
  if (mi)
    Sk.builtin.biginteger.ZERO.subTo(this, this);
};
Sk.builtin.biginteger.prototype.bnpFromNumber = function (a, b, c) {
  if ('number' == typeof b) {
    if (a < 2)
      this.fromInt(1);
    else {
      this.fromNumber(a, c);
      if (!this.testBit(a - 1))
        this.bitwiseTo(Sk.builtin.biginteger.ONE.shiftLeft(a - 1), Sk.builtin.biginteger.op_or, this);
      if (this.isEven())
        this.dAddOffset(1, 0);
      while (!this.isProbablePrime(b)) {
        this.dAddOffset(2, 0);
        if (this.bitLength() > a)
          this.subTo(Sk.builtin.biginteger.ONE.shiftLeft(a - 1), this);
      }
    }
  }
  this.fromString(a + '');
};
Sk.builtin.biginteger.prototype.bnToByteArray = function () {
  var i = this.t, r = new Array();
  r[0] = this.s;
  var p = this.DB - i * this.DB % 8, d, k = 0;
  if (i-- > 0) {
    if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
      r[k++] = d | this.s << this.DB - p;
    while (i >= 0) {
      if (p < 8) {
        d = (this[i] & (1 << p) - 1) << 8 - p;
        d |= this[--i] >> (p += this.DB - 8);
      } else {
        d = this[i] >> (p -= 8) & 255;
        if (p <= 0) {
          p += this.DB;
          --i;
        }
      }
      if ((d & 128) != 0)
        d |= -256;
      if (k == 0 && (this.s & 128) != (d & 128))
        ++k;
      if (k > 0 || d != this.s)
        r[k++] = d;
    }
  }
  return r;
};
Sk.builtin.biginteger.prototype.bnEquals = function (a) {
  return this.compareTo(a) == 0;
};
Sk.builtin.biginteger.prototype.bnMin = function (a) {
  return this.compareTo(a) < 0 ? this : a;
};
Sk.builtin.biginteger.prototype.bnMax = function (a) {
  return this.compareTo(a) > 0 ? this : a;
};
Sk.builtin.biginteger.prototype.bnpBitwiseTo = function (a, op, r) {
  var i, f, m = Math.min(a.t, this.t);
  for (i = 0; i < m; ++i)
    r[i] = op(this[i], a[i]);
  if (a.t < this.t) {
    f = a.s & this.DM;
    for (i = m; i < this.t; ++i)
      r[i] = op(this[i], f);
    r.t = this.t;
  } else {
    f = this.s & this.DM;
    for (i = m; i < a.t; ++i)
      r[i] = op(f, a[i]);
    r.t = a.t;
  }
  r.s = op(this.s, a.s);
  r.clamp();
};
Sk.builtin.biginteger.op_and = function (x, y) {
  return x & y;
};
Sk.builtin.biginteger.prototype.bnAnd = function (a) {
  var r = Sk.builtin.biginteger.nbi();
  this.bitwiseTo(a, Sk.builtin.biginteger.op_and, r);
  return r;
};
Sk.builtin.biginteger.op_or = function (x, y) {
  return x | y;
};
Sk.builtin.biginteger.prototype.bnOr = function (a) {
  var r = Sk.builtin.biginteger.nbi();
  this.bitwiseTo(a, Sk.builtin.biginteger.op_or, r);
  return r;
};
Sk.builtin.biginteger.op_xor = function (x, y) {
  return x ^ y;
};
Sk.builtin.biginteger.prototype.bnXor = function (a) {
  var r = Sk.builtin.biginteger.nbi();
  this.bitwiseTo(a, Sk.builtin.biginteger.op_xor, r);
  return r;
};
Sk.builtin.biginteger.op_andnot = function (x, y) {
  return x & ~y;
};
Sk.builtin.biginteger.prototype.bnAndNot = function (a) {
  var r = Sk.builtin.biginteger.nbi();
  this.bitwiseTo(a, Sk.builtin.biginteger.op_andnot, r);
  return r;
};
Sk.builtin.biginteger.prototype.bnNot = function () {
  var r = Sk.builtin.biginteger.nbi();
  for (var i = 0; i < this.t; ++i)
    r[i] = this.DM & ~this[i];
  r.t = this.t;
  r.s = ~this.s;
  return r;
};
Sk.builtin.biginteger.prototype.bnShiftLeft = function (n) {
  var r = Sk.builtin.biginteger.nbi();
  if (n < 0)
    this.rShiftTo(-n, r);
  else
    this.lShiftTo(n, r);
  return r;
};
Sk.builtin.biginteger.prototype.bnShiftRight = function (n) {
  var r = Sk.builtin.biginteger.nbi();
  if (n < 0)
    this.lShiftTo(-n, r);
  else
    this.rShiftTo(n, r);
  return r;
};
Sk.builtin.biginteger.lbit = function (x) {
  if (x == 0)
    return -1;
  var r = 0;
  if ((x & 65535) == 0) {
    x >>= 16;
    r += 16;
  }
  if ((x & 255) == 0) {
    x >>= 8;
    r += 8;
  }
  if ((x & 15) == 0) {
    x >>= 4;
    r += 4;
  }
  if ((x & 3) == 0) {
    x >>= 2;
    r += 2;
  }
  if ((x & 1) == 0)
    ++r;
  return r;
};
Sk.builtin.biginteger.prototype.bnGetLowestSetBit = function () {
  for (var i = 0; i < this.t; ++i)
    if (this[i] != 0)
      return i * this.DB + Sk.builtin.biginteger.lbit(this[i]);
  if (this.s < 0)
    return this.t * this.DB;
  return -1;
};
Sk.builtin.biginteger.cbit = function (x) {
  var r = 0;
  while (x != 0) {
    x &= x - 1;
    ++r;
  }
  return r;
};
Sk.builtin.biginteger.prototype.bnBitCount = function () {
  var r = 0, x = this.s & this.DM;
  for (var i = 0; i < this.t; ++i)
    r += Sk.builtin.biginteger.cbit(this[i] ^ x);
  return r;
};
Sk.builtin.biginteger.prototype.bnTestBit = function (n) {
  var j = Math.floor(n / this.DB);
  if (j >= this.t)
    return this.s != 0;
  return (this[j] & 1 << n % this.DB) != 0;
};
Sk.builtin.biginteger.prototype.bnpChangeBit = function (n, op) {
  var r = Sk.builtin.biginteger.ONE.shiftLeft(n);
  this.bitwiseTo(r, op, r);
  return r;
};
Sk.builtin.biginteger.prototype.bnSetBit = function (n) {
  return this.changeBit(n, Sk.builtin.biginteger.op_or);
};
Sk.builtin.biginteger.prototype.bnClearBit = function (n) {
  return this.changeBit(n, Sk.builtin.biginteger.op_andnot);
};
Sk.builtin.biginteger.prototype.bnFlipBit = function (n) {
  return this.changeBit(n, Sk.builtin.biginteger.op_xor);
};
Sk.builtin.biginteger.prototype.bnpAddTo = function (a, r) {
  var i = 0, c = 0, m = Math.min(a.t, this.t);
  while (i < m) {
    c += this[i] + a[i];
    r[i++] = c & this.DM;
    c >>= this.DB;
  }
  if (a.t < this.t) {
    c += a.s;
    while (i < this.t) {
      c += this[i];
      r[i++] = c & this.DM;
      c >>= this.DB;
    }
    c += this.s;
  } else {
    c += this.s;
    while (i < a.t) {
      c += a[i];
      r[i++] = c & this.DM;
      c >>= this.DB;
    }
    c += a.s;
  }
  r.s = c < 0 ? -1 : 0;
  if (c > 0)
    r[i++] = c;
  else if (c < -1)
    r[i++] = this.DV + c;
  r.t = i;
  r.clamp();
};
Sk.builtin.biginteger.prototype.bnAdd = function (a) {
  var r = Sk.builtin.biginteger.nbi();
  this.addTo(a, r);
  return r;
};
Sk.builtin.biginteger.prototype.bnSubtract = function (a) {
  var r = Sk.builtin.biginteger.nbi();
  this.subTo(a, r);
  return r;
};
Sk.builtin.biginteger.prototype.bnMultiply = function (a) {
  var r = Sk.builtin.biginteger.nbi();
  this.multiplyTo(a, r);
  return r;
};
Sk.builtin.biginteger.prototype.bnDivide = function (a) {
  var r = Sk.builtin.biginteger.nbi();
  this.divRemTo(a, r, null);
  return r;
};
Sk.builtin.biginteger.prototype.bnRemainder = function (a) {
  var r = Sk.builtin.biginteger.nbi();
  this.divRemTo(a, null, r);
  return r;
};
Sk.builtin.biginteger.prototype.bnDivideAndRemainder = function (a) {
  var q = Sk.builtin.biginteger.nbi(), r = Sk.builtin.biginteger.nbi();
  this.divRemTo(a, q, r);
  return new Array(q, r);
};
Sk.builtin.biginteger.prototype.bnpDMultiply = function (n) {
  this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
  ++this.t;
  this.clamp();
};
Sk.builtin.biginteger.prototype.bnpDAddOffset = function (n, w) {
  if (n == 0)
    return;
  while (this.t <= w)
    this[this.t++] = 0;
  this[w] += n;
  while (this[w] >= this.DV) {
    this[w] -= this.DV;
    if (++w >= this.t)
      this[this.t++] = 0;
    ++this[w];
  }
};
Sk.builtin.biginteger.NullExp = function () {
};
Sk.builtin.biginteger.prototype.nNop = function (x) {
  return x;
};
Sk.builtin.biginteger.prototype.nMulTo = function (x, y, r) {
  x.multiplyTo(y, r);
};
Sk.builtin.biginteger.prototype.nSqrTo = function (x, r) {
  x.squareTo(r);
};
Sk.builtin.biginteger.NullExp.prototype.convert = Sk.builtin.biginteger.prototype.nNop;
Sk.builtin.biginteger.NullExp.prototype.revert = Sk.builtin.biginteger.prototype.nNop;
Sk.builtin.biginteger.NullExp.prototype.mulTo = Sk.builtin.biginteger.prototype.nMulTo;
Sk.builtin.biginteger.NullExp.prototype.sqrTo = Sk.builtin.biginteger.prototype.nSqrTo;
Sk.builtin.biginteger.prototype.bnPow = function (e) {
  return this.exp(e, new Sk.builtin.biginteger.NullExp());
};
Sk.builtin.biginteger.prototype.bnpMultiplyLowerTo = function (a, n, r) {
  var i = Math.min(this.t + a.t, n);
  r.s = 0;
  r.t = i;
  while (i > 0)
    r[--i] = 0;
  var j;
  for (j = r.t - this.t; i < j; ++i)
    r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
  for (j = Math.min(a.t, n); i < j; ++i)
    this.am(0, a[i], r, i, 0, n - i);
  r.clamp();
};
Sk.builtin.biginteger.prototype.bnpMultiplyUpperTo = function (a, n, r) {
  --n;
  var i = r.t = this.t + a.t - n;
  r.s = 0;
  while (--i >= 0)
    r[i] = 0;
  for (i = Math.max(n - this.t, 0); i < a.t; ++i)
    r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
  r.clamp();
  r.drShiftTo(1, r);
};
Sk.builtin.biginteger.Barrett = function (m) {
  this.r2 = Sk.builtin.biginteger.nbi();
  this.q3 = Sk.builtin.biginteger.nbi();
  Sk.builtin.biginteger.ONE.dlShiftTo(2 * m.t, this.r2);
  this.mu = this.r2.divide(m);
  this.m = m;
};
Sk.builtin.biginteger.prototype.barrettConvert = function (x) {
  if (x.s < 0 || x.t > 2 * this.m.t)
    return x.mod(this.m);
  else if (x.compareTo(this.m) < 0)
    return x;
  else {
    var r = Sk.builtin.biginteger.nbi();
    x.copyTo(r);
    this.reduce(r);
    return r;
  }
};
Sk.builtin.biginteger.prototype.barrettRevert = function (x) {
  return x;
};
Sk.builtin.biginteger.prototype.barrettReduce = function (x) {
  x.drShiftTo(this.m.t - 1, this.r2);
  if (x.t > this.m.t + 1) {
    x.t = this.m.t + 1;
    x.clamp();
  }
  this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
  this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
  while (x.compareTo(this.r2) < 0)
    x.dAddOffset(1, this.m.t + 1);
  x.subTo(this.r2, x);
  while (x.compareTo(this.m) >= 0)
    x.subTo(this.m, x);
};
Sk.builtin.biginteger.prototype.barrettSqrTo = function (x, r) {
  x.squareTo(r);
  this.reduce(r);
};
Sk.builtin.biginteger.prototype.barrettMulTo = function (x, y, r) {
  x.multiplyTo(y, r);
  this.reduce(r);
};
Sk.builtin.biginteger.Barrett.prototype.convert = Sk.builtin.biginteger.prototype.barrettConvert;
Sk.builtin.biginteger.Barrett.prototype.revert = Sk.builtin.biginteger.prototype.barrettRevert;
Sk.builtin.biginteger.Barrett.prototype.reduce = Sk.builtin.biginteger.prototype.barrettReduce;
Sk.builtin.biginteger.Barrett.prototype.mulTo = Sk.builtin.biginteger.prototype.barrettMulTo;
Sk.builtin.biginteger.Barrett.prototype.sqrTo = Sk.builtin.biginteger.prototype.barrettSqrTo;
Sk.builtin.biginteger.prototype.bnModPow = function (e, m) {
  var i = e.bitLength(), k, r = Sk.builtin.biginteger.nbv(1), z;
  if (i <= 0)
    return r;
  else if (i < 18)
    k = 1;
  else if (i < 48)
    k = 3;
  else if (i < 144)
    k = 4;
  else if (i < 768)
    k = 5;
  else
    k = 6;
  if (i < 8)
    z = new Sk.builtin.biginteger.Classic(m);
  else if (m.isEven())
    z = new Sk.builtin.biginteger.Barrett(m);
  else
    z = new Sk.builtin.biginteger.Montgomery(m);
  var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
  g[1] = z.convert(this);
  if (k > 1) {
    var g2 = Sk.builtin.biginteger.nbi();
    z.sqrTo(g[1], g2);
    while (n <= km) {
      g[n] = Sk.builtin.biginteger.nbi();
      z.mulTo(g2, g[n - 2], g[n]);
      n += 2;
    }
  }
  var j = e.t - 1, w, is1 = true, r2 = Sk.builtin.biginteger.nbi(), t;
  i = Sk.builtin.biginteger.nbits(e[j]) - 1;
  while (j >= 0) {
    if (i >= k1)
      w = e[j] >> i - k1 & km;
    else {
      w = (e[j] & (1 << i + 1) - 1) << k1 - i;
      if (j > 0)
        w |= e[j - 1] >> this.DB + i - k1;
    }
    n = k;
    while ((w & 1) == 0) {
      w >>= 1;
      --n;
    }
    if ((i -= n) < 0) {
      i += this.DB;
      --j;
    }
    if (is1) {
      g[w].copyTo(r);
      is1 = false;
    } else {
      while (n > 1) {
        z.sqrTo(r, r2);
        z.sqrTo(r2, r);
        n -= 2;
      }
      if (n > 0)
        z.sqrTo(r, r2);
      else {
        t = r;
        r = r2;
        r2 = t;
      }
      z.mulTo(r2, g[w], r);
    }
    while (j >= 0 && (e[j] & 1 << i) == 0) {
      z.sqrTo(r, r2);
      t = r;
      r = r2;
      r2 = t;
      if (--i < 0) {
        i = this.DB - 1;
        --j;
      }
    }
  }
  return z.revert(r);
};
Sk.builtin.biginteger.prototype.bnGCD = function (a) {
  var x = this.s < 0 ? this.negate() : this.clone();
  var y = a.s < 0 ? a.negate() : a.clone();
  if (x.compareTo(y) < 0) {
    var t = x;
    x = y;
    y = t;
  }
  var i = x.getLowestSetBit(), g = y.getLowestSetBit();
  if (g < 0)
    return x;
  if (i < g)
    g = i;
  if (g > 0) {
    x.rShiftTo(g, x);
    y.rShiftTo(g, y);
  }
  while (x.signum() > 0) {
    if ((i = x.getLowestSetBit()) > 0)
      x.rShiftTo(i, x);
    if ((i = y.getLowestSetBit()) > 0)
      y.rShiftTo(i, y);
    if (x.compareTo(y) >= 0) {
      x.subTo(y, x);
      x.rShiftTo(1, x);
    } else {
      y.subTo(x, y);
      y.rShiftTo(1, y);
    }
  }
  if (g > 0)
    y.lShiftTo(g, y);
  return y;
};
Sk.builtin.biginteger.prototype.bnpModInt = function (n) {
  if (n <= 0)
    return 0;
  var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
  if (this.t > 0)
    if (d == 0)
      r = this[0] % n;
    else
      for (var i = this.t - 1; i >= 0; --i)
        r = (d * r + this[i]) % n;
  return r;
};
Sk.builtin.biginteger.prototype.bnModInverse = function (m) {
  var ac = m.isEven();
  if (this.isEven() && ac || m.signum() == 0)
    return Sk.builtin.biginteger.ZERO;
  var u = m.clone(), v = this.clone();
  var a = Sk.builtin.biginteger.nbv(1), b = Sk.builtin.biginteger.nbv(0), c = Sk.builtin.biginteger.nbv(0), d = Sk.builtin.biginteger.nbv(1);
  while (u.signum() != 0) {
    while (u.isEven()) {
      u.rShiftTo(1, u);
      if (ac) {
        if (!a.isEven() || !b.isEven()) {
          a.addTo(this, a);
          b.subTo(m, b);
        }
        a.rShiftTo(1, a);
      } else if (!b.isEven())
        b.subTo(m, b);
      b.rShiftTo(1, b);
    }
    while (v.isEven()) {
      v.rShiftTo(1, v);
      if (ac) {
        if (!c.isEven() || !d.isEven()) {
          c.addTo(this, c);
          d.subTo(m, d);
        }
        c.rShiftTo(1, c);
      } else if (!d.isEven())
        d.subTo(m, d);
      d.rShiftTo(1, d);
    }
    if (u.compareTo(v) >= 0) {
      u.subTo(v, u);
      if (ac)
        a.subTo(c, a);
      b.subTo(d, b);
    } else {
      v.subTo(u, v);
      if (ac)
        c.subTo(a, c);
      d.subTo(b, d);
    }
  }
  if (v.compareTo(Sk.builtin.biginteger.ONE) != 0)
    return Sk.builtin.biginteger.ZERO;
  if (d.compareTo(m) >= 0)
    return d.subtract(m);
  if (d.signum() < 0)
    d.addTo(m, d);
  else
    return d;
  if (d.signum() < 0)
    return d.add(m);
  else
    return d;
};
Sk.builtin.biginteger.lowprimes = [
  2,
  3,
  5,
  7,
  11,
  13,
  17,
  19,
  23,
  29,
  31,
  37,
  41,
  43,
  47,
  53,
  59,
  61,
  67,
  71,
  73,
  79,
  83,
  89,
  97,
  101,
  103,
  107,
  109,
  113,
  127,
  131,
  137,
  139,
  149,
  151,
  157,
  163,
  167,
  173,
  179,
  181,
  191,
  193,
  197,
  199,
  211,
  223,
  227,
  229,
  233,
  239,
  241,
  251,
  257,
  263,
  269,
  271,
  277,
  281,
  283,
  293,
  307,
  311,
  313,
  317,
  331,
  337,
  347,
  349,
  353,
  359,
  367,
  373,
  379,
  383,
  389,
  397,
  401,
  409,
  419,
  421,
  431,
  433,
  439,
  443,
  449,
  457,
  461,
  463,
  467,
  479,
  487,
  491,
  499,
  503,
  509
];
Sk.builtin.biginteger.lplim = (1 << 26) / Sk.builtin.biginteger.lowprimes[Sk.builtin.biginteger.lowprimes.length - 1];
Sk.builtin.biginteger.prototype.bnIsProbablePrime = function (t) {
  var i, x = this.abs();
  if (x.t == 1 && x[0] <= Sk.builtin.biginteger.lowprimes[Sk.builtin.biginteger.lowprimes.length - 1]) {
    for (i = 0; i < Sk.builtin.biginteger.lowprimes.length; ++i)
      if (x[0] == Sk.builtin.biginteger.lowprimes[i])
        return true;
    return false;
  }
  if (x.isEven())
    return false;
  i = 1;
  while (i < Sk.builtin.biginteger.lowprimes.length) {
    var m = Sk.builtin.biginteger.lowprimes[i], j = i + 1;
    while (j < Sk.builtin.biginteger.lowprimes.length && m < Sk.builtin.biginteger.lplim)
      m *= Sk.builtin.biginteger.lowprimes[j++];
    m = x.modInt(m);
    while (i < j)
      if (m % Sk.builtin.biginteger.lowprimes[i++] == 0)
        return false;
  }
  return x.millerRabin(t);
};
Sk.builtin.biginteger.prototype.bnpMillerRabin = function (t) {
  var n1 = this.subtract(Sk.builtin.biginteger.ONE);
  var k = n1.getLowestSetBit();
  if (k <= 0)
    return false;
  var r = n1.shiftRight(k);
  t = t + 1 >> 1;
  if (t > Sk.builtin.biginteger.lowprimes.length)
    t = Sk.builtin.biginteger.lowprimes.length;
  var a = Sk.builtin.biginteger.nbi();
  for (var i = 0; i < t; ++i) {
    a.fromInt(Sk.builtin.biginteger.lowprimes[i]);
    var y = a.modPow(r, this);
    if (y.compareTo(Sk.builtin.biginteger.ONE) != 0 && y.compareTo(n1) != 0) {
      var j = 1;
      while (j++ < k && y.compareTo(n1) != 0) {
        y = y.modPowInt(2, this);
        if (y.compareTo(Sk.builtin.biginteger.ONE) == 0)
          return false;
      }
      if (y.compareTo(n1) != 0)
        return false;
    }
  }
  return true;
};
Sk.builtin.biginteger.prototype.isnegative = function () {
  return this.s < 0;
};
Sk.builtin.biginteger.prototype.ispositive = function () {
  return this.s >= 0;
};
Sk.builtin.biginteger.prototype.trueCompare = function (a) {
  if (this.s >= 0 && a.s < 0)
    return 1;
  if (this.s < 0 && a.s >= 0)
    return -1;
  return this.compare(a);
};
Sk.builtin.biginteger.prototype.chunkSize = Sk.builtin.biginteger.prototype.bnpChunkSize;
Sk.builtin.biginteger.prototype.toRadix = Sk.builtin.biginteger.prototype.bnpToRadix;
Sk.builtin.biginteger.prototype.fromRadix = Sk.builtin.biginteger.prototype.bnpFromRadix;
Sk.builtin.biginteger.prototype.fromNumber = Sk.builtin.biginteger.prototype.bnpFromNumber;
Sk.builtin.biginteger.prototype.bitwiseTo = Sk.builtin.biginteger.prototype.bnpBitwiseTo;
Sk.builtin.biginteger.prototype.changeBit = Sk.builtin.biginteger.prototype.bnpChangeBit;
Sk.builtin.biginteger.prototype.addTo = Sk.builtin.biginteger.prototype.bnpAddTo;
Sk.builtin.biginteger.prototype.dMultiply = Sk.builtin.biginteger.prototype.bnpDMultiply;
Sk.builtin.biginteger.prototype.dAddOffset = Sk.builtin.biginteger.prototype.bnpDAddOffset;
Sk.builtin.biginteger.prototype.multiplyLowerTo = Sk.builtin.biginteger.prototype.bnpMultiplyLowerTo;
Sk.builtin.biginteger.prototype.multiplyUpperTo = Sk.builtin.biginteger.prototype.bnpMultiplyUpperTo;
Sk.builtin.biginteger.prototype.modInt = Sk.builtin.biginteger.prototype.bnpModInt;
Sk.builtin.biginteger.prototype.millerRabin = Sk.builtin.biginteger.prototype.bnpMillerRabin;
Sk.builtin.biginteger.prototype.clone = Sk.builtin.biginteger.prototype.bnClone;
Sk.builtin.biginteger.prototype.intValue = Sk.builtin.biginteger.prototype.bnIntValue;
Sk.builtin.biginteger.prototype.byteValue = Sk.builtin.biginteger.prototype.bnByteValue;
Sk.builtin.biginteger.prototype.shortValue = Sk.builtin.biginteger.prototype.bnShortValue;
Sk.builtin.biginteger.prototype.signum = Sk.builtin.biginteger.prototype.bnSigNum;
Sk.builtin.biginteger.prototype.toByteArray = Sk.builtin.biginteger.prototype.bnToByteArray;
Sk.builtin.biginteger.prototype.equals = Sk.builtin.biginteger.prototype.bnEquals;
Sk.builtin.biginteger.prototype.compare = Sk.builtin.biginteger.prototype.compareTo;
Sk.builtin.biginteger.prototype.min = Sk.builtin.biginteger.prototype.bnMin;
Sk.builtin.biginteger.prototype.max = Sk.builtin.biginteger.prototype.bnMax;
Sk.builtin.biginteger.prototype.and = Sk.builtin.biginteger.prototype.bnAnd;
Sk.builtin.biginteger.prototype.or = Sk.builtin.biginteger.prototype.bnOr;
Sk.builtin.biginteger.prototype.xor = Sk.builtin.biginteger.prototype.bnXor;
Sk.builtin.biginteger.prototype.andNot = Sk.builtin.biginteger.prototype.bnAndNot;
Sk.builtin.biginteger.prototype.not = Sk.builtin.biginteger.prototype.bnNot;
Sk.builtin.biginteger.prototype.shiftLeft = Sk.builtin.biginteger.prototype.bnShiftLeft;
Sk.builtin.biginteger.prototype.shiftRight = Sk.builtin.biginteger.prototype.bnShiftRight;
Sk.builtin.biginteger.prototype.getLowestSetBit = Sk.builtin.biginteger.prototype.bnGetLowestSetBit;
Sk.builtin.biginteger.prototype.bitCount = Sk.builtin.biginteger.prototype.bnBitCount;
Sk.builtin.biginteger.prototype.testBit = Sk.builtin.biginteger.prototype.bnTestBit;
Sk.builtin.biginteger.prototype.setBit = Sk.builtin.biginteger.prototype.bnSetBit;
Sk.builtin.biginteger.prototype.clearBit = Sk.builtin.biginteger.prototype.bnClearBit;
Sk.builtin.biginteger.prototype.flipBit = Sk.builtin.biginteger.prototype.bnFlipBit;
Sk.builtin.biginteger.prototype.add = Sk.builtin.biginteger.prototype.bnAdd;
Sk.builtin.biginteger.prototype.subtract = Sk.builtin.biginteger.prototype.bnSubtract;
Sk.builtin.biginteger.prototype.multiply = Sk.builtin.biginteger.prototype.bnMultiply;
Sk.builtin.biginteger.prototype.divide = Sk.builtin.biginteger.prototype.bnDivide;
Sk.builtin.biginteger.prototype.remainder = Sk.builtin.biginteger.prototype.bnRemainder;
Sk.builtin.biginteger.prototype.divideAndRemainder = Sk.builtin.biginteger.prototype.bnDivideAndRemainder;
Sk.builtin.biginteger.prototype.modPow = Sk.builtin.biginteger.prototype.bnModPow;
Sk.builtin.biginteger.prototype.modInverse = Sk.builtin.biginteger.prototype.bnModInverse;
Sk.builtin.biginteger.prototype.pow = Sk.builtin.biginteger.prototype.bnPow;
Sk.builtin.biginteger.prototype.gcd = Sk.builtin.biginteger.prototype.bnGCD;
Sk.builtin.biginteger.prototype.isProbablePrime = Sk.builtin.biginteger.prototype.bnIsProbablePrime;
Sk.builtin.nmber = function (x, skType) {
  if (!(this instanceof Sk.builtin.nmber))
    return new Sk.builtin.nmber(x, skType);
  if (x instanceof Sk.builtin.str)
    x = x.v;
  if (x instanceof Sk.builtin.nmber) {
    this.v = x.v;
    this.skType = x.skType;
  } else if (typeof x === 'number') {
    this.v = x;
    if (skType === undefined) {
      if (x > Sk.builtin.nmber.threshold$ || x < -Sk.builtin.nmber.threshold$ || x % 1 != 0)
        this.skType = Sk.builtin.nmber.float$;
      else
        this.skType = Sk.builtin.nmber.int$;
    } else {
      this.skType = skType;
      if (skType === Sk.builtin.nmber.int$)
        if (x > Sk.builtin.nmber.threshold$ || x < -Sk.builtin.nmber.threshold$)
          return new Sk.builtin.lng(x);
    }
  } else if (typeof x === 'string') {
    var result = Sk.numberFromStr(x);
    if (skType !== undefined)
      result.skType = skType;
    if (skType === Sk.builtin.nmber.int$)
      if (result.v > Sk.builtin.nmber.threshold$ || result.v < -Sk.builtin.nmber.threshold$)
        return new Sk.builtin.lng(x);
    return result;
  } else if (x instanceof Sk.builtin.lng) {
    return Sk.numberFromStr(x.str$(10, true));
  } else if (x instanceof Sk.builtin.biginteger) {
    var result = Sk.numberFromStr(x.toString());
    if (skType !== undefined)
      result.skType = skType;
    if (skType === Sk.builtin.nmber.int$)
      if (result.v > Sk.builtin.nmber.threshold$ || result.v < -Sk.builtin.nmber.threshold$)
        return new Sk.builtin.lng(x);
  } else {
    this.v = 0;
    if (skType === undefined)
      this.skType = Sk.builtin.nmber.int$;
    else
      this.skType = skType;
  }
  return this;
};
Sk.builtin.nmber.prototype.tp$index = function () {
  return this.v;
};
Sk.builtin.nmber.prototype.tp$hash = function () {
  return this.v;
};
Sk.builtin.nmber.prototype.tp$name = 'number';
Sk.builtin.nmber.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('number', Sk.builtin.nmber);
Sk.builtin.nmber.threshold$ = Math.pow(2, 53);
Sk.builtin.nmber.float$ = 'float';
Sk.builtin.nmber.int$ = 'int';
Sk.builtin.nmber.fromInt$ = function (ival) {
  return new Sk.builtin.nmber(ival, undefined);
};
Sk.numberFromStr = function (s) {
  if (s == 'inf')
    return new Sk.builtin.nmber(Infinity, undefined);
  if (s == '-inf')
    return new Sk.builtin.nmber(-Infinity, undefined);
  var res = new Sk.builtin.nmber(0, undefined);
  if (s.indexOf('.') !== -1 || s.indexOf('e') !== -1 || s.indexOf('E') !== -1) {
    res.v = parseFloat(s);
    res.skType = Sk.builtin.nmber.float$;
    return res;
  }
  var tmp = s;
  var s1;
  if (s.charAt(0) === '-')
    tmp = s.substr(1);
  if (tmp.charAt(0) === '0' && (tmp.charAt(1) === 'x' || tmp.charAt(1) === 'X'))
    s1 = parseInt(s, 16);
  else if (tmp.charAt(0) === '0' && (tmp.charAt(1) === 'b' || tmp.charAt(1) === 'B'))
    s1 = parseInt(s, 2);
  else if (tmp.charAt(0) === '0')
    s1 = parseInt(s, 8);
  else
    s1 = parseInt(s, 10);
  res.v = s1;
  res.skType = Sk.builtin.nmber.int$;
  return res;
};
goog.exportSymbol('Sk.numberFromStr', Sk.numberFromStr);
Sk.builtin.nmber.prototype.clone = function () {
  return new Sk.builtin.nmber(this, undefined);
};
Sk.builtin.nmber.prototype.toFixed = function (x) {
  x = Sk.builtin.asnum$(x);
  return this.v.toFixed(x);
};
Sk.builtin.nmber.prototype.nb$add = function (other) {
  var result;
  if (typeof other === 'number')
    other = new Sk.builtin.nmber(other, undefined);
  if (other instanceof Sk.builtin.nmber) {
    result = new Sk.builtin.nmber(this.v + other.v, undefined);
    if (this.skType === Sk.builtin.nmber.float$ || other.skType === Sk.builtin.nmber.float$)
      result.skType = Sk.builtin.nmber.float$;
    else {
      result.skType = Sk.builtin.nmber.int$;
      if (result.v > Sk.builtin.nmber.threshold$ || result.v < -Sk.builtin.nmber.threshold$) {
        result = new Sk.builtin.lng(this.v).nb$add(other.v);
      }
    }
    return result;
  }
  if (other instanceof Sk.builtin.lng) {
    if (this.skType === Sk.builtin.nmber.float$) {
      result = new Sk.builtin.nmber(this.v + parseFloat(other.str$(10, true)), Sk.builtin.nmber.float$);
    } else {
      var thisAsLong = new Sk.builtin.lng(this.v);
      result = thisAsLong.nb$add(other);
    }
    return result;
  }
  return undefined;
};
Sk.builtin.nmber.prototype.nb$subtract = function (other) {
  var result;
  if (typeof other === 'number') {
    other = new Sk.builtin.nmber(other, undefined);
  }
  if (other instanceof Sk.builtin.nmber) {
    result = new Sk.builtin.nmber(this.v - other.v, undefined);
    if (this.skType === Sk.builtin.nmber.float$ || other.skType === Sk.builtin.nmber.float$)
      result.skType = Sk.builtin.nmber.float$;
    else {
      result.skType = Sk.builtin.nmber.int$;
      if (result.v > Sk.builtin.nmber.threshold$ || result.v < -Sk.builtin.nmber.threshold$) {
        result = new Sk.builtin.lng(this.v).nb$subtract(other.v);
      }
    }
    return result;
  }
  if (other instanceof Sk.builtin.lng) {
    if (this.skType === Sk.builtin.nmber.float$) {
      result = new Sk.builtin.nmber(this.v - parseFloat(other.str$(10, true)), Sk.builtin.nmber.float$);
    } else {
      var thisAsLong = new Sk.builtin.lng(this.v);
      result = thisAsLong.nb$subtract(other);
    }
    return result;
  }
  return undefined;
};
Sk.builtin.nmber.prototype.nb$multiply = function (other) {
  var result;
  if (typeof other === 'number')
    other = new Sk.builtin.nmber(other, undefined);
  if (other instanceof Sk.builtin.nmber) {
    result = new Sk.builtin.nmber(this.v * other.v, undefined);
    if (this.skType === Sk.builtin.nmber.float$ || other.skType === Sk.builtin.nmber.float$)
      result.skType = Sk.builtin.nmber.float$;
    else {
      result.skType = Sk.builtin.nmber.int$;
      if (result.v > Sk.builtin.nmber.threshold$ || result.v < -Sk.builtin.nmber.threshold$) {
        result = new Sk.builtin.lng(this.v).nb$multiply(other.v);
      }
    }
    return result;
  }
  if (other instanceof Sk.builtin.lng) {
    if (this.skType === Sk.builtin.nmber.float$) {
      result = new Sk.builtin.nmber(this.v * parseFloat(other.str$(10, true)), Sk.builtin.nmber.float$);
    } else {
      var thisAsLong = new Sk.builtin.lng(this.v);
      result = thisAsLong.nb$multiply(other);
    }
    return result;
  }
  return undefined;
};
Sk.builtin.nmber.prototype.nb$divide = function (other) {
  var result;
  if (typeof other === 'number')
    other = new Sk.builtin.nmber(other, undefined);
  if (other instanceof Sk.builtin.nmber) {
    if (other.v == 0)
      throw new Sk.builtin.ZeroDivisionError('integer division or modulo by zero');
    if (this.v === Infinity)
      if (other.v === Infinity || other.v === -Infinity)
        return new Sk.builtin.nmber(NaN, Sk.builtin.nmber.float$);
      else if (other.nb$isnegative())
        return new Sk.builtin.nmber(-Infinity, Sk.builtin.nmber.float$);
      else
        return new Sk.builtin.nmber(Infinity, Sk.builtin.nmber.float$);
    if (this.v === -Infinity)
      if (other.v === Infinity || other.v === -Infinity)
        return new Sk.builtin.nmber(NaN, Sk.builtin.nmber.float$);
      else if (other.nb$isnegative())
        return new Sk.builtin.nmber(Infinity, Sk.builtin.nmber.float$);
      else
        return new Sk.builtin.nmber(-Infinity, Sk.builtin.nmber.float$);
    result = new Sk.builtin.nmber(this.v / other.v, undefined);
    if (this.skType === Sk.builtin.nmber.float$ || other.skType === Sk.builtin.nmber.float$ || Sk.python3)
      result.skType = Sk.builtin.nmber.float$;
    else {
      result.v = Math.floor(result.v);
      result.skType = Sk.builtin.nmber.int$;
      if (result.v > Sk.builtin.nmber.threshold$ || result.v < -Sk.builtin.nmber.threshold$) {
        result = new Sk.builtin.lng(this.v).nb$divide(other.v);
      }
    }
    return result;
  }
  if (other instanceof Sk.builtin.lng) {
    if (other.longCompare(Sk.builtin.biginteger.ZERO) == 0)
      throw new Sk.builtin.ZeroDivisionError('integer division or modulo by zero');
    if (this.v === Infinity)
      if (other.nb$isnegative())
        return new Sk.builtin.nmber(-Infinity, Sk.builtin.nmber.float$);
      else
        return new Sk.builtin.nmber(Infinity, Sk.builtin.nmber.float$);
    if (this.v === -Infinity)
      if (other.nb$isnegative())
        return new Sk.builtin.nmber(Infinity, Sk.builtin.nmber.float$);
      else
        return new Sk.builtin.nmber(-Infinity, Sk.builtin.nmber.float$);
    if (this.skType === Sk.builtin.nmber.float$) {
      result = new Sk.builtin.nmber(this.v / parseFloat(other.str$(10, true)), Sk.builtin.nmber.float$);
    } else {
      var thisAsLong = new Sk.builtin.lng(this.v);
      result = thisAsLong.nb$divide(other);
    }
    return result;
  }
  return undefined;
};
Sk.builtin.nmber.prototype.nb$floor_divide = function (other) {
  var result;
  if (typeof other === 'number')
    other = new Sk.builtin.nmber(other, undefined);
  if (this.v === Infinity || this.v === -Infinity)
    return new Sk.builtin.nmber(NaN, Sk.builtin.nmber.float$);
  if (other instanceof Sk.builtin.nmber) {
    if (other.v == 0)
      throw new Sk.builtin.ZeroDivisionError('integer division or modulo by zero');
    if (other.v === Infinity)
      if (this.nb$isnegative())
        return new Sk.builtin.nmber(-1, Sk.builtin.nmber.float$);
      else
        return new Sk.builtin.nmber(0, Sk.builtin.nmber.float$);
    if (other.v === -Infinity)
      if (this.nb$isnegative() || !this.nb$nonzero())
        return new Sk.builtin.nmber(0, Sk.builtin.nmber.float$);
      else
        return new Sk.builtin.nmber(-1, Sk.builtin.nmber.float$);
    result = new Sk.builtin.nmber(Math.floor(this.v / other.v), undefined);
    if (this.skType === Sk.builtin.nmber.float$ || other.skType === Sk.builtin.nmber.float$)
      result.skType = Sk.builtin.nmber.float$;
    else {
      result.v = Math.floor(result.v);
      result.skType = Sk.builtin.nmber.int$;
      if (result.v > Sk.builtin.nmber.threshold$ || result.v < -Sk.builtin.nmber.threshold$) {
        result = new Sk.builtin.lng(this.v).nb$floor_divide(other.v);
      }
    }
    return result;
  }
  if (other instanceof Sk.builtin.lng) {
    if (other.longCompare(Sk.builtin.biginteger.ZERO) == 0)
      throw new Sk.builtin.ZeroDivisionError('integer division or modulo by zero');
    if (this.skType === Sk.builtin.nmber.float$) {
      result = Math.floor(this.v / parseFloat(other.str$(10, true)));
      result = new Sk.builtin.nmber(result, Sk.builtin.nmber.float$);
    } else {
      var thisAsLong = new Sk.builtin.lng(this.v);
      result = thisAsLong.nb$floor_divide(other);
    }
    return result;
  }
  return undefined;
};
Sk.builtin.nmber.prototype.nb$remainder = function (other) {
  var result;
  if (typeof other === 'number')
    other = new Sk.builtin.nmber(other, undefined);
  if (other instanceof Sk.builtin.nmber) {
    if (other.v == 0)
      throw new Sk.builtin.ZeroDivisionError('integer division or modulo by zero');
    if (this.v == 0)
      if (this.skType == Sk.builtin.nmber.float$ || other.skType == Sk.builtin.nmber.float$)
        return new Sk.builtin.nmber(0, Sk.builtin.nmber.float$);
      else
        return new Sk.builtin.nmber(0, Sk.builtin.nmber.int$);
    if (other.v === Infinity)
      if (this.v === Infinity || this.v === -Infinity)
        return new Sk.builtin.nmber(NaN, Sk.builtin.nmber.float$);
      else if (this.nb$ispositive())
        return new Sk.builtin.nmber(this.v, Sk.builtin.nmber.float$);
      else
        return new Sk.builtin.nmber(Infinity, Sk.builtin.nmber.float$);
    var tmp = this.v % other.v;
    if (this.v < 0) {
      if (other.v > 0 && tmp < 0)
        tmp = tmp + other.v;
    } else {
      if (other.v < 0 && tmp != 0)
        tmp = tmp + other.v;
    }
    if (this.skType === Sk.builtin.nmber.float$ || other.skType === Sk.builtin.nmber.float$)
      result = new Sk.builtin.nmber(tmp, Sk.builtin.nmber.float$);
    else {
      result = new Sk.builtin.nmber(tmp, Sk.builtin.nmber.int$);
      if (result.v > Sk.builtin.nmber.threshold$ || result.v < -Sk.builtin.nmber.threshold$) {
        result = new Sk.builtin.lng(this.v).nb$remainder(other.v);
      }
    }
    return result;
  }
  if (other instanceof Sk.builtin.lng) {
    if (other.longCompare(Sk.builtin.biginteger.ZERO) == 0)
      throw new Sk.builtin.ZeroDivisionError('integer division or modulo by zero');
    if (this.v == 0)
      if (this.skType === Sk.builtin.nmber.int$)
        return new Sk.builtin.lng(0);
      else
        return new Sk.builtin.nmber(0, this.skType);
    if (this.skType === Sk.builtin.nmber.float$) {
      var op2 = parseFloat(other.str$(10, true));
      var tmp = this.v % op2;
      if (tmp < 0) {
        if (op2 > 0 && tmp != 0)
          tmp = tmp + op2;
      } else {
        if (op2 < 0 && tmp != 0)
          tmp = tmp + op2;
      }
      result = new Sk.builtin.nmber(tmp, Sk.builtin.nmber.float$);
    } else {
      var thisAsLong = new Sk.builtin.lng(this.v);
      result = thisAsLong.nb$remainder(other);
    }
    return result;
  }
  return undefined;
};
Sk.builtin.nmber.prototype.nb$power = function (other) {
  var result;
  if (typeof other === 'number')
    other = new Sk.builtin.nmber(other, undefined);
  if (other instanceof Sk.builtin.nmber) {
    if (this.v < 0 && other.v % 1 != 0)
      throw new Sk.builtin.NegativePowerError('cannot raise a negative number to a fractional power');
    if (this.v == 0 && other.v < 0) {
      throw new Sk.builtin.NegativePowerError('cannot raise zero to a negative power');
    }
    result = new Sk.builtin.nmber(Math.pow(this.v, other.v), undefined);
    if (this.skType === Sk.builtin.nmber.float$ || other.skType === Sk.builtin.nmber.float$ || other.v < 0)
      result.skType = Sk.builtin.nmber.float$;
    else {
      result.v = Math.floor(result.v);
      result.skType = Sk.builtin.nmber.int$;
      if (result.v > Sk.builtin.nmber.threshold$ || result.v < -Sk.builtin.nmber.threshold$) {
        result = new Sk.builtin.lng(this.v).nb$power(other.v);
      }
    }
    if (Math.abs(result.v) === Infinity && Math.abs(this.v) !== Infinity && Math.abs(other.v) !== Infinity) {
      throw new Sk.builtin.OverflowError('Numerical result out of range');
    }
    return result;
  }
  if (other instanceof Sk.builtin.lng) {
    if (this.v == 0 && other.longCompare(Sk.builtin.biginteger.ZERO) < 0)
      throw new Sk.builtin.NegativePowerError('cannot raise zero to a negative power');
    if (this.skType === Sk.builtin.nmber.float$ || other.nb$isnegative()) {
      result = new Sk.builtin.nmber(Math.pow(this.v, parseFloat(other.str$(10, true))), Sk.builtin.nmber.float$);
    } else {
      var thisAsLong = new Sk.builtin.lng(this.v);
      result = thisAsLong.nb$power(other);
    }
    return result;
  }
  return undefined;
};
Sk.builtin.nmber.prototype.nb$and = function (other) {
  var tmp;
  other = Sk.builtin.asnum$(other);
  tmp = this.v & other;
  if (tmp !== undefined && tmp < 0) {
    tmp = tmp + 4294967296;
  }
  if (tmp !== undefined)
    return new Sk.builtin.nmber(tmp, undefined);
  return undefined;
};
Sk.builtin.nmber.prototype.nb$or = function (other) {
  var tmp;
  other = Sk.builtin.asnum$(other);
  tmp = this.v | other;
  if (tmp !== undefined && tmp < 0) {
    tmp = tmp + 4294967296;
  }
  if (tmp !== undefined)
    return new Sk.builtin.nmber(tmp, undefined);
  return undefined;
};
Sk.builtin.nmber.prototype.nb$xor = function (other) {
  var tmp;
  other = Sk.builtin.asnum$(other);
  tmp = this.v ^ other;
  if (tmp !== undefined && tmp < 0) {
    tmp = tmp + 4294967296;
  }
  if (tmp !== undefined)
    return new Sk.builtin.nmber(tmp, undefined);
  return undefined;
};
Sk.builtin.nmber.prototype.nb$lshift = function (other) {
  var tmp;
  var shift = Sk.builtin.asnum$(other);
  if (shift !== undefined) {
    if (shift < 0)
      throw new Sk.builtin.ValueError('negative shift count');
    tmp = this.v << shift;
    if (tmp <= this.v) {
      return Sk.builtin.lng.fromInt$(this.v).nb$lshift(shift);
    }
  }
  if (tmp !== undefined)
    return new Sk.builtin.nmber(tmp, this.skType);
  return undefined;
};
Sk.builtin.nmber.prototype.nb$rshift = function (other) {
  var tmp;
  var shift = Sk.builtin.asnum$(other);
  if (shift !== undefined) {
    if (shift < 0)
      throw new Sk.builtin.ValueError('negative shift count');
    tmp = this.v >> shift;
    if (this.v > 0 && tmp < 0) {
      tmp = tmp & Math.pow(2, 32 - shift) - 1;
    }
  }
  if (tmp !== undefined)
    return new Sk.builtin.nmber(tmp, this.skType);
  return undefined;
};
Sk.builtin.nmber.prototype.nb$inplace_add = Sk.builtin.nmber.prototype.nb$add;
Sk.builtin.nmber.prototype.nb$inplace_subtract = Sk.builtin.nmber.prototype.nb$subtract;
Sk.builtin.nmber.prototype.nb$inplace_multiply = Sk.builtin.nmber.prototype.nb$multiply;
Sk.builtin.nmber.prototype.nb$inplace_divide = Sk.builtin.nmber.prototype.nb$divide;
Sk.builtin.nmber.prototype.nb$inplace_remainder = Sk.builtin.nmber.prototype.nb$remainder;
Sk.builtin.nmber.prototype.nb$inplace_floor_divide = Sk.builtin.nmber.prototype.nb$floor_divide;
Sk.builtin.nmber.prototype.nb$inplace_power = Sk.builtin.nmber.prototype.nb$power;
Sk.builtin.nmber.prototype.nb$inplace_and = Sk.builtin.nmber.prototype.nb$and;
Sk.builtin.nmber.prototype.nb$inplace_or = Sk.builtin.nmber.prototype.nb$or;
Sk.builtin.nmber.prototype.nb$inplace_xor = Sk.builtin.nmber.prototype.nb$xor;
Sk.builtin.nmber.prototype.nb$inplace_lshift = Sk.builtin.nmber.prototype.nb$lshift;
Sk.builtin.nmber.prototype.nb$inplace_rshift = Sk.builtin.nmber.prototype.nb$rshift;
Sk.builtin.nmber.prototype.nu$negative = function () {
  return new Sk.builtin.nmber(-this.v, this.skType);
};
Sk.builtin.nmber.prototype.nb$positive = function () {
  return this;
};
Sk.builtin.nmber.prototype.nb$cos = function () {
  return new Sk.builtin.nmber(Math.cos(this.v), this.skType);
};
Sk.builtin.nmber.prototype.nb$sin = function () {
  return new Sk.builtin.nmber(Math.sin(this.v), this.skType);
};
Sk.builtin.nmber.prototype.nb$tan = function () {
  return new Sk.builtin.nmber(Math.tan(this.v), this.skType);
};
Sk.builtin.nmber.prototype.nu$exponential = function () {
  return new Sk.builtin.nmber(Math.exp(this.v), this.skType);
};
Sk.builtin.nmber.prototype.nu$magnitude = function () {
  return new Sk.builtin.nmber(Math.abs(this.v), this.skType);
};
Sk.builtin.nmber.prototype.nu$quadrance = function () {
  return new Sk.builtin.nmber(this.v * this.v, this.skType);
};
Sk.builtin.nmber.prototype.nb$nonzero = function () {
  return this.v !== 0 ? Sk.builtin.bool.true$ : Sk.builtin.bool.false$;
};
Sk.builtin.nmber.prototype.nb$isnegative = function () {
  return this.v < 0;
};
Sk.builtin.nmber.prototype.nb$ispositive = function () {
  return this.v >= 0;
};
Sk.builtin.nmber.prototype.numberCompare = function (other) {
  if (other instanceof Sk.builtin.bool)
    other = Sk.builtin.asnum$(other);
  if (other instanceof Sk.builtin.none)
    other = 0;
  if (typeof other === 'number') {
    return this.v - other;
  }
  if (other instanceof Sk.builtin.nmber) {
    if (this.v == Infinity && other.v == Infinity)
      return 0;
    if (this.v == -Infinity && other.v == -Infinity)
      return 0;
    return this.v - other.v;
  }
  if (other instanceof Sk.builtin.lng) {
    if (this.skType === Sk.builtin.nmber.int$ || this.v % 1 == 0) {
      var thisAsLong = new Sk.builtin.lng(this.v);
      var tmp = thisAsLong.longCompare(other);
      return tmp;
    }
    var diff = this.nb$subtract(other);
    if (diff instanceof Sk.builtin.nmber) {
      return diff.v;
    } else if (diff instanceof Sk.builtin.lng) {
      return diff.longCompare(Sk.builtin.biginteger.ZERO);
    }
  }
  return undefined;
};
Sk.builtin.nmber.prototype.__eq__ = function (me, other) {
  return me.numberCompare(other) == 0 && !(other instanceof Sk.builtin.none);
};
Sk.builtin.nmber.prototype.__ne__ = function (me, other) {
  return me.numberCompare(other) != 0 || other instanceof Sk.builtin.none;
};
Sk.builtin.nmber.prototype.__lt__ = function (me, other) {
  return me.numberCompare(other) < 0;
};
Sk.builtin.nmber.prototype.__le__ = function (me, other) {
  return me.numberCompare(other) <= 0;
};
Sk.builtin.nmber.prototype.__gt__ = function (me, other) {
  return me.numberCompare(other) > 0;
};
Sk.builtin.nmber.prototype.__ge__ = function (me, other) {
  return me.numberCompare(other) >= 0;
};
Sk.builtin.nmber.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
Sk.builtin.nmber.prototype.tp$repr = function () {
  return new Sk.builtin.str(this.str$(10, true));
};
Sk.builtin.nmber.prototype.tp$str = function () {
  return new Sk.builtin.str(this.str$(10, true));
};
Sk.builtin.nmber.prototype.str$ = function (base, sign) {
  if (isNaN(this.v))
    return 'nan';
  if (sign === undefined)
    sign = true;
  if (this.v == Infinity)
    return 'inf';
  if (this.v == -Infinity && sign)
    return '-inf';
  if (this.v == -Infinity && !sign)
    return 'inf';
  var work = sign ? this.v : Math.abs(this.v);
  var tmp;
  if (base === undefined || base === 10) {
    if (this.skType == Sk.builtin.nmber.float$) {
      tmp = work.toPrecision(12);
      var idx = tmp.indexOf('.');
      var pre = work.toString().slice(0, idx);
      var post = work.toString().slice(idx);
      if (pre.match(/^-?0$/) && post.slice(1).match(/^0{4,}/)) {
        if (tmp.length < 12)
          tmp = work.toExponential();
        else
          tmp = work.toExponential(11);
      }
      while (tmp.charAt(tmp.length - 1) == '0' && tmp.indexOf('e') < 0) {
        tmp = tmp.substring(0, tmp.length - 1);
      }
      if (tmp.charAt(tmp.length - 1) == '.') {
        tmp = tmp + '0';
      }
      tmp = tmp.replace(new RegExp('\\.0+e'), 'e', 'i');
      tmp = tmp.replace(/(e[-+])([1-9])$/, '$10$2');
      tmp = tmp.replace(/0+(e.*)/, '$1');
    } else {
      tmp = work.toString();
    }
  } else {
    tmp = work.toString(base);
  }
  if (this.skType !== Sk.builtin.nmber.float$)
    return tmp;
  if (tmp.indexOf('.') < 0 && tmp.indexOf('E') < 0 && tmp.indexOf('e') < 0)
    tmp = tmp + '.0';
  return tmp;
};
goog.exportSymbol('Sk.builtin.nmber', Sk.builtin.nmber);
Sk.builtin.lng = function (x, base) {
  base = Sk.builtin.asnum$(base);
  if (!(this instanceof Sk.builtin.lng))
    return new Sk.builtin.lng(x, base);
  if (x === undefined)
    this.biginteger = new Sk.builtin.biginteger(0);
  else if (x instanceof Sk.builtin.lng)
    this.biginteger = x.biginteger.clone();
  else if (x instanceof Sk.builtin.biginteger)
    this.biginteger = x;
  else if (x instanceof String)
    return Sk.longFromStr(x, base);
  else if (x instanceof Sk.builtin.str)
    return Sk.longFromStr(x.v, base);
  else {
    if (x !== undefined && (!Sk.builtin.checkString(x) && !Sk.builtin.checkNumber(x))) {
      if (x === true)
        x = 1;
      else if (x === false)
        x = 0;
      else
        throw new Sk.builtin.TypeError('long() argument must be a string or a number, not \'' + Sk.abstr.typeName(x) + '\'');
    }
    x = Sk.builtin.asnum$nofloat(x);
    this.biginteger = new Sk.builtin.biginteger(x);
  }
  return this;
};
Sk.builtin.lng.prototype.tp$index = function () {
  return parseInt(this.str$(10, true), 10);
};
Sk.builtin.lng.prototype.tp$hash = function () {
  return this.tp$index();
};
Sk.builtin.lng.prototype.tp$name = 'long';
Sk.builtin.lng.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('long', Sk.builtin.lng);
Sk.builtin.lng.threshold$ = Math.pow(2, 53);
Sk.builtin.lng.MAX_INT$ = new Sk.builtin.lng(Sk.builtin.lng.threshold$);
Sk.builtin.lng.MIN_INT$ = new Sk.builtin.lng(-Sk.builtin.lng.threshold$);
Sk.builtin.lng.prototype.cantBeInt = function () {
  return this.longCompare(Sk.builtin.lng.MAX_INT$) > 0 || this.longCompare(Sk.builtin.lng.MIN_INT$) < 0;
};
Sk.builtin.lng.fromInt$ = function (ival) {
  return new Sk.builtin.lng(ival);
};
Sk.longFromStr = function (s, base) {
  var parser = function (s, base) {
    if (base == 10)
      return new Sk.builtin.biginteger(s);
    else
      return new Sk.builtin.biginteger(s, base);
  };
  var biginteger = Sk.str2number(s, base, parser, function (x) {
      return x.negate();
    }, 'long');
  return new Sk.builtin.lng(biginteger);
};
goog.exportSymbol('Sk.longFromStr', Sk.longFromStr);
Sk.builtin.lng.prototype.toInt$ = function () {
  return this.biginteger.intValue();
};
Sk.builtin.lng.prototype.clone = function () {
  return new Sk.builtin.lng(this);
};
Sk.builtin.lng.prototype.nb$add = function (other) {
  if (other instanceof Sk.builtin.nmber) {
    if (other.skType === Sk.builtin.nmber.float$) {
      var thisAsFloat = new Sk.builtin.nmber(this.str$(10, true), Sk.builtin.nmber.float$);
      return thisAsFloat.nb$add(other);
    } else {
      other = new Sk.builtin.lng(other.v);
    }
  }
  if (other instanceof Sk.builtin.lng) {
    return new Sk.builtin.lng(this.biginteger.add(other.biginteger));
  }
  if (other instanceof Sk.builtin.biginteger) {
    return new Sk.builtin.lng(this.biginteger.add(other));
  }
  return new Sk.builtin.lng(this.biginteger.add(new Sk.builtin.biginteger(other)));
};
Sk.builtin.lng.prototype.nb$inplace_add = Sk.builtin.lng.prototype.nb$add;
Sk.builtin.lng.prototype.nb$subtract = function (other) {
  if (other instanceof Sk.builtin.nmber) {
    if (other.skType === Sk.builtin.nmber.float$) {
      var thisAsFloat = new Sk.builtin.nmber(this.str$(10, true), Sk.builtin.nmber.float$);
      return thisAsFloat.nb$subtract(other);
    } else {
      other = new Sk.builtin.lng(other.v);
    }
  }
  if (other instanceof Sk.builtin.lng) {
    return new Sk.builtin.lng(this.biginteger.subtract(other.biginteger));
  }
  if (other instanceof Sk.builtin.biginteger) {
    return new Sk.builtin.lng(this.biginteger.subtract(other));
  }
  return new Sk.builtin.lng(this.biginteger.subtract(new Sk.builtin.biginteger(other)));
};
Sk.builtin.lng.prototype.nb$inplace_subtract = Sk.builtin.lng.prototype.nb$subtract;
Sk.builtin.lng.prototype.nb$multiply = function (other) {
  if (other instanceof Sk.builtin.nmber) {
    if (other.skType === Sk.builtin.nmber.float$) {
      var thisAsFloat = new Sk.builtin.nmber(this.str$(10, true), Sk.builtin.nmber.float$);
      return thisAsFloat.nb$multiply(other);
    } else {
      other = new Sk.builtin.lng(other.v);
    }
  }
  if (other instanceof Sk.builtin.lng) {
    return new Sk.builtin.lng(this.biginteger.multiply(other.biginteger));
  }
  if (other instanceof Sk.builtin.biginteger) {
    return new Sk.builtin.lng(this.biginteger.multiply(other));
  }
  return new Sk.builtin.lng(this.biginteger.multiply(new Sk.builtin.biginteger(other)));
};
Sk.builtin.lng.prototype.nb$inplace_multiply = Sk.builtin.lng.prototype.nb$multiply;
Sk.builtin.lng.prototype.nb$divide = function (other) {
  if (other instanceof Sk.builtin.nmber) {
    if (other.skType === Sk.builtin.nmber.float$) {
      var thisAsFloat = new Sk.builtin.nmber(this.str$(10, true), Sk.builtin.nmber.float$);
      return thisAsFloat.nb$divide(other);
    } else {
      other = new Sk.builtin.lng(other.v);
    }
  }
  var result;
  if (!(other instanceof Sk.builtin.lng)) {
    other = new Sk.builtin.lng(other);
  }
  var thisneg = this.nb$isnegative();
  var otherneg = other.nb$isnegative();
  if (thisneg && !otherneg || otherneg && !thisneg) {
    result = this.biginteger.divideAndRemainder(other.biginteger);
    if (result[1].trueCompare(Sk.builtin.biginteger.ZERO) == 0) {
      return new Sk.builtin.lng(result[0]);
    } else {
      result = result[0].subtract(Sk.builtin.biginteger.ONE);
      return new Sk.builtin.lng(result);
    }
  } else {
    return new Sk.builtin.lng(this.biginteger.divide(other.biginteger));
  }
};
Sk.builtin.lng.prototype.nb$inplace_divide = Sk.builtin.lng.prototype.nb$divide;
Sk.builtin.lng.prototype.nb$floor_divide = function (other) {
  if (other instanceof Sk.builtin.nmber) {
    if (other.skType === Sk.builtin.nmber.float$) {
      var thisAsFloat = new Sk.builtin.nmber(this.str$(10, true), Sk.builtin.nmber.float$);
      return thisAsFloat.nb$floor_divide(other);
    }
  }
  return this.nb$divide(other);
};
Sk.builtin.lng.prototype.nb$inplace_floor_divide = Sk.builtin.lng.prototype.nb$floor_divide;
Sk.builtin.lng.prototype.nb$remainder = function (other) {
  if (this.biginteger.trueCompare(Sk.builtin.biginteger.ZERO) === 0)
    if (other instanceof Sk.builtin.nmber && other.skType === Sk.builtin.nmber.float$)
      return new Sk.builtin.nmber(0, Sk.builtin.nmber.float$);
    else
      return new Sk.builtin.lng(0);
  if (other instanceof Sk.builtin.nmber) {
    if (other.skType === Sk.builtin.nmber.float$) {
      var thisAsFloat = new Sk.builtin.nmber(this.str$(10, true), Sk.builtin.nmber.float$);
      return thisAsFloat.nb$remainder(other);
    } else {
      other = new Sk.builtin.lng(other.v);
    }
  }
  if (!(other instanceof Sk.builtin.lng)) {
    other = new Sk.builtin.lng(other);
  }
  var tmp = new Sk.builtin.lng(this.biginteger.remainder(other.biginteger));
  if (this.nb$isnegative()) {
    if (other.nb$ispositive() && tmp.nb$nonzero())
      tmp = tmp.nb$add(other).nb$remainder(other);
  } else {
    if (other.nb$isnegative() && tmp.nb$nonzero())
      tmp = tmp.nb$add(other);
  }
  return tmp;
};
Sk.builtin.lng.prototype.nb$inplace_remainder = Sk.builtin.lng.prototype.nb$remainder;
Sk.builtin.lng.prototype.nb$power = function (n, mod) {
  if (mod !== undefined) {
    n = new Sk.builtin.biginteger(Sk.builtin.asnum$(n));
    mod = new Sk.builtin.biginteger(Sk.builtin.asnum$(mod));
    return new Sk.builtin.lng(this.biginteger.modPowInt(n, mod));
  }
  if (typeof n === 'number') {
    if (n < 0) {
      var thisAsFloat = new Sk.builtin.nmber(this.str$(10, true), Sk.builtin.nmber.float$);
      return thisAsFloat.nb$power(n);
    } else
      return new Sk.builtin.lng(this.biginteger.pow(new Sk.builtin.biginteger(n)));
  }
  if (n instanceof Sk.builtin.nmber) {
    if (n.skType === Sk.builtin.nmber.float$ || n.v < 0) {
      var thisAsFloat = new Sk.builtin.nmber(this.str$(10, true), Sk.builtin.nmber.float$);
      return thisAsFloat.nb$power(n);
    } else {
      n = new Sk.builtin.lng(n.v);
    }
  }
  if (n instanceof Sk.builtin.lng) {
    if (n.nb$isnegative()) {
      var thisAsFloat = new Sk.builtin.nmber(this.str$(10, true), Sk.builtin.nmber.float$);
      return thisAsFloat.nb$power(n);
    } else
      return new Sk.builtin.lng(this.biginteger.pow(n.biginteger));
  }
  if (n instanceof Sk.builtin.biginteger) {
    if (n.isnegative()) {
      var thisAsFloat = new Sk.builtin.nmber(this.str$(10, true), Sk.builtin.nmber.float$);
      return thisAsFloat.nb$power(n);
    }
    return new Sk.builtin.lng(this.biginteger.pow(n));
  }
  return new Sk.builtin.lng(this.biginteger.pow(new Sk.builtin.biginteger(n)));
};
Sk.builtin.lng.prototype.nb$inplace_power = Sk.builtin.lng.prototype.nb$power;
Sk.builtin.lng.prototype.nb$lshift = function (other) {
  if (other instanceof Sk.builtin.lng) {
    if (other.biginteger.signum() < 0) {
      throw new Sk.builtin.ValueError('negative shift count');
    }
    return new Sk.builtin.lng(this.biginteger.shiftLeft(other.biginteger));
  }
  if (other instanceof Sk.builtin.biginteger) {
    if (other.signum() < 0) {
      throw new Sk.builtin.ValueError('negative shift count');
    }
    return new Sk.builtin.lng(this.biginteger.shiftLeft(other));
  }
  if (other < 0) {
    throw new Sk.builtin.ValueError('negative shift count');
  }
  other = Sk.builtin.asnum$(other);
  return new Sk.builtin.lng(this.biginteger.shiftLeft(new Sk.builtin.biginteger(other)));
};
Sk.builtin.lng.prototype.nb$inplace_lshift = Sk.builtin.lng.prototype.nb$lshift;
Sk.builtin.lng.prototype.nb$rshift = function (other) {
  if (other instanceof Sk.builtin.lng) {
    if (other.biginteger.signum() < 0) {
      throw new Sk.builtin.ValueError('negative shift count');
    }
    return new Sk.builtin.lng(this.biginteger.shiftRight(other.biginteger));
  }
  if (other instanceof Sk.builtin.biginteger) {
    if (other.signum() < 0) {
      throw new Sk.builtin.ValueError('negative shift count');
    }
    return new Sk.builtin.lng(this.biginteger.shiftRight(other));
  }
  if (other < 0) {
    throw new Sk.builtin.ValueError('negative shift count');
  }
  other = Sk.builtin.asnum$(other);
  return new Sk.builtin.lng(this.biginteger.shiftRight(new Sk.builtin.biginteger(other)));
};
Sk.builtin.lng.prototype.nb$inplace_rshift = Sk.builtin.lng.prototype.nb$rshift;
Sk.builtin.lng.prototype.nb$and = function (other) {
  if (other instanceof Sk.builtin.lng) {
    return new Sk.builtin.lng(this.biginteger.and(other.biginteger));
  }
  if (other instanceof Sk.builtin.biginteger) {
    return new Sk.builtin.lng(this.biginteger.and(other));
  }
  other = Sk.builtin.asnum$(other);
  return new Sk.builtin.lng(this.biginteger.and(new Sk.builtin.biginteger(other)));
};
Sk.builtin.lng.prototype.nb$inplace_and = Sk.builtin.lng.prototype.nb$and;
Sk.builtin.lng.prototype.nb$or = function (other) {
  if (other instanceof Sk.builtin.lng) {
    return new Sk.builtin.lng(this.biginteger.or(other.biginteger));
  }
  if (other instanceof Sk.builtin.biginteger) {
    return new Sk.builtin.lng(this.biginteger.or(other));
  }
  other = Sk.builtin.asnum$(other);
  return new Sk.builtin.lng(this.biginteger.or(new Sk.builtin.biginteger(other)));
};
Sk.builtin.lng.prototype.nb$inplace_or = Sk.builtin.lng.prototype.nb$or;
Sk.builtin.lng.prototype.nb$xor = function (other) {
  if (other instanceof Sk.builtin.lng) {
    return new Sk.builtin.lng(this.biginteger.xor(other.biginteger));
  }
  if (other instanceof Sk.builtin.biginteger) {
    return new Sk.builtin.lng(this.biginteger.xor(other));
  }
  other = Sk.builtin.asnum$(other);
  return new Sk.builtin.lng(this.biginteger.xor(new Sk.builtin.biginteger(other)));
};
Sk.builtin.lng.prototype.nb$inplace_xor = Sk.builtin.lng.prototype.nb$xor;
Sk.builtin.lng.prototype.nu$negative = function () {
  return new Sk.builtin.lng(this.biginteger.negate());
};
Sk.builtin.lng.prototype.nb$positive = function () {
  return this.clone();
};
Sk.builtin.lng.prototype.nb$nonzero = function () {
  return this.biginteger.trueCompare(Sk.builtin.biginteger.ZERO) !== 0;
};
Sk.builtin.lng.prototype.nb$isnegative = function () {
  return this.biginteger.isnegative();
};
Sk.builtin.lng.prototype.nb$ispositive = function () {
  return !this.biginteger.isnegative();
};
Sk.builtin.lng.prototype.longCompare = function (other) {
  if (typeof other === 'boolean')
    if (other)
      other = 1;
    else
      other = 0;
  var tmp;
  if (typeof other === 'number') {
    other = new Sk.builtin.lng(other);
  }
  if (other instanceof Sk.builtin.nmber) {
    if (other.skType === Sk.builtin.nmber.int$ || other.v % 1 == 0) {
      var otherAsLong = new Sk.builtin.lng(other.v);
      return this.longCompare(otherAsLong);
    } else {
      var thisAsFloat = new Sk.builtin.nmber(this, Sk.builtin.nmber.float$);
      return thisAsFloat.numberCompare(other);
    }
  } else if (other instanceof Sk.builtin.lng) {
    tmp = this.biginteger.subtract(other.biginteger);
  } else if (other instanceof Sk.builtin.biginteger) {
    tmp = this.biginteger.subtract(other);
  } else {
    tmp = this.biginteger.subtract(new Sk.builtin.biginteger(other));
  }
  return tmp;
};
Sk.builtin.lng.prototype.__eq__ = function (me, other) {
  return me.longCompare(other) == 0 && !(other instanceof Sk.builtin.none);
};
Sk.builtin.lng.prototype.__ne__ = function (me, other) {
  return me.longCompare(other) != 0 || other instanceof Sk.builtin.none;
};
Sk.builtin.lng.prototype.__lt__ = function (me, other) {
  return me.longCompare(other) < 0;
};
Sk.builtin.lng.prototype.__le__ = function (me, other) {
  return me.longCompare(other) <= 0;
};
Sk.builtin.lng.prototype.__gt__ = function (me, other) {
  return me.longCompare(other) > 0;
};
Sk.builtin.lng.prototype.__ge__ = function (me, other) {
  return me.longCompare(other) >= 0;
};
Sk.builtin.lng.prototype.tp$repr = function () {
  return new Sk.builtin.str(this.str$(10, true) + 'L');
};
Sk.builtin.lng.prototype.tp$str = function () {
  return new Sk.builtin.str(this.str$(10, true));
};
Sk.builtin.lng.prototype.str$ = function (base, sign) {
  if (sign === undefined)
    sign = true;
  var work = sign ? this.biginteger : this.biginteger.abs();
  if (base === undefined || base === 10) {
    return work.toString();
  }
  return work.toString(base);
};
Sk.str2number = function (s, base, parser, negater, fname) {
  var origs = s;
  var neg = false;
  s = s.replace(/^\s+|\s+$/g, '');
  if (s.charAt(0) == '-') {
    neg = true;
    s = s.substring(1);
  }
  if (s.charAt(0) == '+') {
    s = s.substring(1);
  }
  if (base === undefined)
    base = 10;
  if (base < 2 || base > 36) {
    if (base != 0) {
      throw new Sk.builtin.ValueError(fname + '() base must be >= 2 and <= 36');
    }
  }
  if (s.substring(0, 2).toLowerCase() == '0x') {
    if (base != 16 && base != 0) {
      throw new Sk.builtin.ValueError('invalid literal for ' + fname + '() with base ' + base + ': \'' + origs + '\'');
    } else {
      s = s.substring(2);
      base = 16;
    }
  } else if (s.substring(0, 2).toLowerCase() == '0b') {
    if (base != 2 && base != 0) {
      throw new Sk.builtin.ValueError('invalid literal for ' + fname + '() with base ' + base + ': \'' + origs + '\'');
    } else {
      s = s.substring(2);
      base = 2;
    }
  } else if (s.substring(0, 2).toLowerCase() == '0o') {
    if (base != 8 && base != 0) {
      throw new Sk.builtin.ValueError('invalid literal for ' + fname + '() with base ' + base + ': \'' + origs + '\'');
    } else {
      s = s.substring(2);
      base = 8;
    }
  } else if (s.charAt(0) == '0') {
    if (s == '0')
      return 0;
    if (base == 8 || base == 0) {
      base = 8;
    }
  }
  if (base == 0)
    base = 10;
  if (s.length === 0) {
    throw new Sk.builtin.ValueError('invalid literal for ' + fname + '() with base ' + base + ': \'' + origs + '\'');
  }
  var i, ch, val;
  for (i = 0; i < s.length; i++) {
    ch = s.charCodeAt(i);
    val = base;
    if (ch >= 48 && ch <= 57) {
      val = ch - 48;
    } else if (ch >= 65 && ch <= 90) {
      val = ch - 65 + 10;
    } else if (ch >= 97 && ch <= 122) {
      val = ch - 97 + 10;
    }
    if (val >= base) {
      throw new Sk.builtin.ValueError('invalid literal for ' + fname + '() with base ' + base + ': \'' + origs + '\'');
    }
  }
  val = parser(s, base);
  if (neg) {
    val = negater(val);
  }
  return val;
};
Sk.builtin.int_ = function (x, base) {
  if (x !== undefined && (!Sk.builtin.checkString(x) && !Sk.builtin.checkNumber(x))) {
    if (x instanceof Sk.builtin.bool)
      x = Sk.builtin.asnum$(x);
    else
      throw new Sk.builtin.TypeError('int() argument must be a string or a number, not \'' + Sk.abstr.typeName(x) + '\'');
  }
  if (x instanceof Sk.builtin.str) {
    base = Sk.builtin.asnum$(base);
    var val = Sk.str2number(x.v, base, parseInt, function (x) {
        return -x;
      }, 'int');
    if (val > Sk.builtin.lng.threshold$ || val < -Sk.builtin.lng.threshold$) {
      return new Sk.builtin.lng(x, base);
    }
    return new Sk.builtin.nmber(val, Sk.builtin.nmber.int$);
  }
  if (base !== undefined) {
    throw new Sk.builtin.TypeError('int() can\'t convert non-string with explicit base');
  }
  if (x instanceof Sk.builtin.lng) {
    if (x.cantBeInt())
      return new Sk.builtin.lng(x);
    else
      return new Sk.builtin.nmber(x.toInt$(), Sk.builtin.nmber.int$);
  }
  x = Sk.builtin.asnum$(x);
  return new Sk.builtin.nmber(x | 0, Sk.builtin.nmber.int$);
};
Sk.builtin.int_.prototype.tp$name = 'int';
Sk.builtin.int_.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('int', Sk.builtin.int_);
Sk.builtin.float_ = function (x) {
  if (x === undefined) {
    return new Sk.builtin.nmber(0, Sk.builtin.nmber.float$);
  }
  if (x instanceof Sk.builtin.str) {
    var tmp;
    if (x.v.match(/^-inf$/i)) {
      tmp = -Infinity;
    } else if (x.v.match(/^[+]?inf$/i)) {
      tmp = Infinity;
    } else if (x.v.match(/^[-+]?nan$/i)) {
      tmp = NaN;
    } else if (!isNaN(x.v))
      tmp = parseFloat(x.v);
    else {
      throw new Sk.builtin.ValueError('float: Argument: ' + x.v + ' is not number');
    }
    return new Sk.builtin.nmber(tmp, Sk.builtin.nmber.float$);
  }
  if (typeof x === 'number' || x instanceof Sk.builtin.nmber || x instanceof Sk.builtin.lng) {
    x = Sk.builtin.asnum$(x);
    return new Sk.builtin.nmber(x, Sk.builtin.nmber.float$);
  }
  if (x instanceof Sk.builtin.bool) {
    x = Sk.builtin.asnum$(x);
    return new Sk.builtin.nmber(x, Sk.builtin.nmber.float$);
  }
  throw new Sk.builtin.TypeError('float() argument must be a string or a number');
};
Sk.builtin.float_.prototype.tp$name = 'float';
Sk.builtin.float_.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('float', Sk.builtin.float_);
Sk.builtin.slice = function slice(start, stop, step) {
  start = Sk.builtin.asnum$(start);
  stop = Sk.builtin.asnum$(stop);
  step = Sk.builtin.asnum$(step);
  if (!(this instanceof Sk.builtin.slice))
    return new Sk.builtin.slice(start, stop, step);
  if (stop === undefined && step === undefined) {
    stop = start;
    start = null;
  }
  if (!start)
    start = null;
  if (stop === undefined)
    stop = null;
  if (step === undefined)
    step = null;
  this.start = start;
  this.stop = stop;
  this.step = step;
  if (this.start !== null && !Sk.builtin.checkInt(this.start) || this.stop !== null && !Sk.builtin.checkInt(this.stop) || this.step !== null && !Sk.builtin.checkInt(this.step)) {
    throw new Sk.builtin.TypeError('slice indices must be integers or None');
  }
  return this;
};
Sk.builtin.slice.prototype.tp$str = function () {
  var a = Sk.builtin.repr(this.start).v;
  var b = Sk.builtin.repr(this.stop).v;
  var c = Sk.builtin.repr(this.step).v;
  return new Sk.builtin.str('slice(' + a + ', ' + b + ', ' + c + ')');
};
Sk.builtin.slice.prototype.indices = function (length) {
  length = Sk.builtin.asnum$(length);
  var start = this.start, stop = this.stop, step = this.step, i;
  if (step === null)
    step = 1;
  if (step > 0) {
    if (start === null)
      start = 0;
    if (stop === null)
      stop = length;
    if (stop > length) {
      stop = length;
    }
    if (start < 0) {
      start = length + start;
      if (start < 0) {
        start = 0;
      }
    }
    if (stop < 0)
      stop = length + stop;
  } else {
    if (start === null)
      start = length - 1;
    if (start >= length) {
      start = length - 1;
    }
    if (stop === null) {
      stop = -1;
    } else if (stop < 0) {
      stop = length + stop;
      if (stop < 0) {
        stop = -1;
      }
    }
    if (start < 0)
      start = length + start;
  }
  return [
    start,
    stop,
    step
  ];
};
Sk.builtin.slice.prototype.sssiter$ = function (wrt, f) {
  var wrtv = Sk.builtin.asnum$(wrt);
  var sss = this.indices(typeof wrtv === 'number' ? wrtv : wrt.v.length);
  if (sss[2] > 0) {
    var i;
    for (i = sss[0]; i < sss[1]; i += sss[2])
      if (f(i, wrtv) === false)
        return;
  } else {
    for (i = sss[0]; i > sss[1]; i += sss[2])
      if (f(i, wrtv) === false)
        return;
  }
};
Sk.builtin.set = function (S) {
  if (!(this instanceof Sk.builtin.set))
    return new Sk.builtin.set(S);
  if (typeof S === 'undefined') {
    S = [];
  }
  this.set_reset_();
  var S_list = new Sk.builtin.list(S);
  for (var it = S_list.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {
    Sk.builtin.set.prototype['add'].func_code(this, i);
  }
  this.__class__ = Sk.builtin.set;
  this['v'] = this.v;
  return this;
};
Sk.builtin.set.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('set', Sk.builtin.set);
Sk.builtin.set.prototype.set_iter_ = function () {
  var ret = Sk.builtin.dict.prototype['keys'].func_code(this['v']);
  return ret.tp$iter();
};
Sk.builtin.set.prototype.set_reset_ = function () {
  this.v = new Sk.builtin.dict([]);
};
Sk.builtin.set.prototype.tp$name = 'set';
Sk.builtin.set.prototype.tp$repr = function () {
  var ret = [];
  for (var it = this.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {
    ret.push(Sk.misceval.objectRepr(i).v);
  }
  return new Sk.builtin.str('set([' + ret.join(', ') + '])');
};
Sk.builtin.set.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
Sk.builtin.set.prototype.tp$hash = Sk.builtin.object.prototype.HashNotImplemented;
Sk.builtin.set.prototype.tp$richcompare = function (w, op) {
  if (this === w && Sk.misceval.opAllowsEquality(op))
    return true;
  if (!w.__class__ || w.__class__ != Sk.builtin.set) {
    if (op === 'Eq')
      return false;
    if (op === 'NotEq')
      return true;
    return false;
  }
  var vl = this.sq$length();
  var wl = w.sq$length();
  if (wl !== vl) {
    if (op === 'Eq')
      return false;
    if (op === 'NotEq')
      return true;
  }
  var isSub = false;
  var isSuper = false;
  switch (op) {
  case 'Lt':
  case 'LtE':
  case 'Eq':
  case 'NotEq':
    isSub = Sk.builtin.set.prototype['issubset'].func_code(this, w);
    break;
  case 'Gt':
  case 'GtE':
    isSuper = Sk.builtin.set.prototype['issuperset'].func_code(this, w);
    break;
  default:
    goog.asserts.fail();
  }
  switch (op) {
  case 'Lt':
    return vl < wl && isSub;
  case 'LtE':
  case 'Eq':
    return isSub;
  case 'NotEq':
    return !isSub;
  case 'Gt':
    return vl > wl && isSuper;
  case 'GtE':
    return isSuper;
  }
};
Sk.builtin.set.prototype.tp$iter = Sk.builtin.set.prototype.set_iter_;
Sk.builtin.set.prototype.sq$length = function () {
  return this['v'].mp$length();
};
Sk.builtin.set.prototype['isdisjoint'] = new Sk.builtin.func(function (self, other) {
  for (var it = self.tp$iter(), item = it.tp$iternext(); item !== undefined; item = it.tp$iternext()) {
    var isIn = Sk.abstr.sequenceContains(other, item);
    if (isIn) {
      return Sk.builtin.bool.false$;
    }
  }
  return Sk.builtin.bool(true);
});
Sk.builtin.set.prototype['issubset'] = new Sk.builtin.func(function (self, other) {
  var selfLength = self.sq$length();
  var otherLength = other.sq$length();
  if (selfLength > otherLength) {
    return Sk.builtin.bool.false$;
  }
  for (var it = self.tp$iter(), item = it.tp$iternext(); item !== undefined; item = it.tp$iternext()) {
    var isIn = Sk.abstr.sequenceContains(other, item);
    if (!isIn) {
      return Sk.builtin.bool.false$;
    }
  }
  return Sk.builtin.bool.true$;
});
Sk.builtin.set.prototype['issuperset'] = new Sk.builtin.func(function (self, other) {
  return Sk.builtin.set.prototype['issubset'].func_code(other, self);
});
Sk.builtin.set.prototype['union'] = new Sk.builtin.func(function (self) {
  var S = new Sk.builtin.set(self);
  for (var i = 1; i < arguments.length; i++) {
    Sk.builtin.set.prototype['update'].func_code(S, arguments[i]);
  }
  return S;
});
Sk.builtin.set.prototype['intersection'] = new Sk.builtin.func(function (self) {
  var S = Sk.builtin.set.prototype['copy'].func_code(self);
  arguments[0] = S;
  Sk.builtin.set.prototype['intersection_update'].func_code.apply(null, arguments);
  return S;
});
Sk.builtin.set.prototype['difference'] = new Sk.builtin.func(function (self, other) {
  var S = Sk.builtin.set.prototype['copy'].func_code(self);
  arguments[0] = S;
  Sk.builtin.set.prototype['difference_update'].func_code.apply(null, arguments);
  return S;
});
Sk.builtin.set.prototype['symmetric_difference'] = new Sk.builtin.func(function (self, other) {
  var S = Sk.builtin.set.prototype['union'].func_code(self, other);
  for (var it = S.tp$iter(), item = it.tp$iternext(); item !== undefined; item = it.tp$iternext()) {
    if (Sk.abstr.sequenceContains(self, item) && Sk.abstr.sequenceContains(other, item)) {
      Sk.builtin.set.prototype['discard'].func_code(S, item);
    }
  }
  return S;
});
Sk.builtin.set.prototype['copy'] = new Sk.builtin.func(function (self) {
  return new Sk.builtin.set(self);
});
Sk.builtin.set.prototype['update'] = new Sk.builtin.func(function (self, other) {
  for (var it = other.tp$iter(), item = it.tp$iternext(); item !== undefined; item = it.tp$iternext()) {
    Sk.builtin.set.prototype['add'].func_code(self, item);
  }
  return null;
});
Sk.builtin.set.prototype['intersection_update'] = new Sk.builtin.func(function (self) {
  for (var it = self.tp$iter(), item = it.tp$iternext(); item !== undefined; item = it.tp$iternext()) {
    for (var i = 1; i < arguments.length; i++) {
      if (!Sk.abstr.sequenceContains(arguments[i], item)) {
        Sk.builtin.set.prototype['discard'].func_code(self, item);
        break;
      }
    }
  }
  return null;
});
Sk.builtin.set.prototype['difference_update'] = new Sk.builtin.func(function (self, other) {
  for (var it = self.tp$iter(), item = it.tp$iternext(); item !== undefined; item = it.tp$iternext()) {
    for (var i = 1; i < arguments.length; i++) {
      if (Sk.abstr.sequenceContains(arguments[i], item)) {
        Sk.builtin.set.prototype['discard'].func_code(self, item);
        break;
      }
    }
  }
  return null;
});
Sk.builtin.set.prototype['symmetric_difference_update'] = new Sk.builtin.func(function (self, other) {
  var sd = Sk.builtin.set.prototype['symmetric_difference'].func_code(self, other);
  self.set_reset_();
  Sk.builtin.set.prototype['update'].func_code(self, sd);
  return null;
});
Sk.builtin.set.prototype['add'] = new Sk.builtin.func(function (self, item) {
  self.v.mp$ass_subscript(item, true);
  return null;
});
Sk.builtin.set.prototype['discard'] = new Sk.builtin.func(function (self, item) {
  if (self.v.mp$lookup(item) !== undefined) {
    var kf = Sk.builtin.hash;
    var k = kf(item);
    if (self.v[k] !== undefined) {
      self.v.size -= 1;
      delete self.v[k];
    }
  }
  return null;
});
Sk.builtin.set.prototype['pop'] = new Sk.builtin.func(function (self) {
  if (self.sq$length() === 0) {
    throw new Sk.builtin.KeyError('pop from an empty set');
  }
  var it = self.tp$iter(), item = it.tp$iternext();
  Sk.builtin.set.prototype['discard'].func_code(self, item);
  return item;
});
Sk.builtin.set.prototype['remove'] = new Sk.builtin.func(function (self, item) {
  self.v.mp$del_subscript(item);
  return null;
});
goog.exportSymbol('Sk.builtin.set', Sk.builtin.set);
Sk.builtin.module = function () {
};
goog.exportSymbol('Sk.builtin.module', Sk.builtin.module);
Sk.builtin.module.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('module', Sk.builtin.module);
Sk.builtin.module.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
Sk.builtin.module.prototype.tp$setattr = Sk.builtin.object.prototype.GenericSetAttr;
Sk.builtin.generator = function (code, globals, args, closure, closure2) {
  if (!code)
    return;
  this.func_code = code;
  this.func_globals = globals || null;
  this.gi$running = false;
  this['gi$resumeat'] = 0;
  this['gi$sentvalue'] = undefined;
  this['gi$locals'] = {};
  if (args.length > 0) {
    for (var i = 0; i < code['co_varnames'].length; ++i)
      this['gi$locals'][code['co_varnames'][i]] = args[i];
  }
  if (closure2 !== undefined) {
    for (var k in closure2)
      closure[k] = closure2[k];
  }
  this.func_closure = closure;
  return this;
};
goog.exportSymbol('Sk.builtin.generator', Sk.builtin.generator);
Sk.builtin.generator.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
Sk.builtin.generator.prototype.tp$iter = function () {
  return this;
};
Sk.builtin.generator.prototype.tp$iternext = function (yielded) {
  this.gi$running = true;
  if (yielded === undefined)
    yielded = null;
  this['gi$sentvalue'] = yielded;
  var args = [this];
  if (this.func_closure)
    args.push(this.func_closure);
  var ret = this.func_code.apply(this.func_globals, args);
  this.gi$running = false;
  goog.asserts.assert(ret !== undefined);
  if (ret !== null) {
    this['gi$resumeat'] = ret[0];
    ret = ret[1];
  } else {
    return undefined;
  }
  return ret;
};
Sk.builtin.generator.prototype['next'] = new Sk.builtin.func(function (self) {
  return self.tp$iternext();
});
Sk.builtin.generator.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('generator', Sk.builtin.generator);
Sk.builtin.generator.prototype.tp$repr = function () {
  return new Sk.builtin.str('<generator object ' + this.func_code['co_name'].v + '>');
};
Sk.builtin.generator.prototype['send'] = new Sk.builtin.func(function (self, value) {
  return self.tp$iternext(value);
});
Sk.builtin.makeGenerator = function (next, data) {
  var gen = new Sk.builtin.generator(null, null, null);
  gen.tp$iternext = next;
  for (var key in data) {
    if (data.hasOwnProperty(key)) {
      gen[key] = data[key];
    }
  }
  return gen;
};
goog.exportSymbol('Sk.builtin.makeGenerator', Sk.builtin.makeGenerator);
Sk.builtin.file = function (name, mode, buffering) {
  this.mode = mode;
  this.name = name;
  this.closed = false;
  if (Sk.inBrowser) {
    var elem = document.getElementById(name.v);
    if (elem == null) {
      throw new Sk.builtin.IOError('[Errno 2] No such file or directory: \'' + name.v + '\'');
    } else {
      if (elem.nodeName.toLowerCase() == 'textarea') {
        this.data$ = elem.value;
      } else {
        this.data$ = elem.textContent;
      }
    }
  } else {
    this.data$ = Sk.read(name.v);
  }
  this.lineList = this.data$.split('\n');
  this.lineList = this.lineList.slice(0, -1);
  for (var i in this.lineList) {
    this.lineList[i] = this.lineList[i] + '\n';
  }
  this.currentLine = 0;
  this.pos$ = 0;
  this.__class__ = Sk.builtin.file;
  return this;
};
Sk.builtin.file.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('file', Sk.builtin.file);
Sk.builtin.file.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
Sk.builtin.file.prototype.tp$repr = function () {
  return new Sk.builtin.str('<' + (this.closed ? 'closed' : 'open') + 'file \'' + this.name + '\', mode \'' + this.mode + '\'>');
};
Sk.builtin.file.prototype.tp$iter = function () {
  var allLines = this.lineList;
  var ret = {
      tp$iter: function () {
        return ret;
      },
      $obj: this,
      $index: 0,
      $lines: allLines,
      tp$iternext: function () {
        if (ret.$index >= ret.$lines.length)
          return undefined;
        return new Sk.builtin.str(ret.$lines[ret.$index++]);
      }
    };
  return ret;
};
Sk.builtin.file.prototype['close'] = new Sk.builtin.func(function (self) {
  self.closed = true;
});
Sk.builtin.file.prototype['flush'] = new Sk.builtin.func(function (self) {
});
Sk.builtin.file.prototype['fileno'] = new Sk.builtin.func(function (self) {
  return 10;
});
Sk.builtin.file.prototype['isatty'] = new Sk.builtin.func(function (self) {
  return false;
});
Sk.builtin.file.prototype['read'] = new Sk.builtin.func(function (self, size) {
  if (self.closed)
    throw new Sk.builtin.ValueError('I/O operation on closed file');
  var len = self.data$.length;
  if (size === undefined)
    size = len;
  var ret = new Sk.builtin.str(self.data$.substr(self.pos$, size));
  self.pos$ += size;
  if (self.pos$ >= len)
    self.pos$ = len;
  return ret;
});
Sk.builtin.file.prototype['readline'] = new Sk.builtin.func(function (self, size) {
  var line = '';
  if (self.currentLine < self.lineList.length) {
    line = self.lineList[self.currentLine];
    self.currentLine++;
  }
  return new Sk.builtin.str(line);
});
Sk.builtin.file.prototype['readlines'] = new Sk.builtin.func(function (self, sizehint) {
  var arr = [];
  for (var i = self.currentLine; i < self.lineList.length; i++) {
    arr.push(new Sk.builtin.str(self.lineList[i]));
  }
  return new Sk.builtin.list(arr);
});
Sk.builtin.file.prototype['seek'] = new Sk.builtin.func(function (self, offset, whence) {
  if (whence === undefined)
    whence = 1;
  if (whence == 1) {
    self.pos$ = offset;
  } else {
    self.pos$ = self.data$ + offset;
  }
});
Sk.builtin.file.prototype['tell'] = new Sk.builtin.func(function (self) {
  return self.pos$;
});
Sk.builtin.file.prototype['truncate'] = new Sk.builtin.func(function (self, size) {
  goog.asserts.fail();
});
Sk.builtin.file.prototype['write'] = new Sk.builtin.func(function (self, str) {
  goog.asserts.fail();
});
goog.exportSymbol('Sk.builtin.file', Sk.builtin.file);
Sk.ffi = Sk.ffi || {};
Sk.ffi.AssertionError;
goog.exportSymbol('Sk.ffi.AssertionError', Sk.ffi.AssertionError);
Sk.ffi.assertionError = function (message) {
  return new Sk.builtin.AssertionError(message);
};
goog.exportSymbol('Sk.ffi.assertionError', Sk.ffi.assertionError);
Sk.ffi.AttributeError;
goog.exportSymbol('Sk.ffi.AttributeError', Sk.ffi.AttributeError);
Sk.ffi.attributeError = function (message) {
  return new Sk.builtin.AttributeError(message);
};
goog.exportSymbol('Sk.ffi.attributeError', Sk.ffi.attributeError);
Sk.ffi.NotImplementedError;
goog.exportSymbol('Sk.ffi.NotImplementedError', Sk.ffi.NotImplementedError);
Sk.ffi.notImplementedError = function (message) {
  return new Sk.builtin.NotImplementedError(message);
};
goog.exportSymbol('Sk.ffi.notImplementedError', Sk.ffi.notImplementedError);
Sk.ffi.TypeError;
goog.exportSymbol('Sk.ffi.TypeError', Sk.ffi.TypeError);
Sk.ffi.typeError = function (message) {
  return new Sk.builtin.TypeError(message);
};
goog.exportSymbol('Sk.ffi.typeError', Sk.ffi.typeError);
Sk.ffi.JsType = {
  'UNDEFINED': 'undefined',
  'OBJECT': 'object',
  'STRING': 'string',
  'NUMBER': 'number',
  'BOOLEAN': 'boolean',
  'FUNCTION': 'function'
};
Sk.ffi.type = function (valuePy) {
  if (valuePy.constructor === Sk.builtin.nmber) {
    if (valuePy.skType === Sk.builtin.nmber.int$) {
      return Sk.builtin.int_.prototype.ob$type;
    } else {
      return Sk.builtin.float_.prototype.ob$type;
    }
  }
  return valuePy.ob$type;
};
goog.exportSymbol('Sk.ffi.type', Sk.ffi.type);
Sk.ffi.bool = {
  True: Sk.builtin.bool.true$,
  False: Sk.builtin.bool.false$
};
goog.exportSymbol('Sk.ffi.bool', Sk.ffi.bool);
Sk.ffi.none = { None: Sk.builtin.none.none$ };
goog.exportSymbol('Sk.ffi.none', Sk.ffi.none);
Sk.ffi.booleanToPy = function (valueJs, defaultJs) {
  var t = typeof valueJs;
  if (t === Sk.ffi.JsType.BOOLEAN) {
    return valueJs ? Sk.ffi.bool.True : Sk.ffi.bool.False;
  } else if (t === Sk.ffi.JsType.OBJECT && valueJs === null) {
    return Sk.ffi.none.None;
  } else if (t === Sk.ffi.JsType.UNDEFINED) {
    var d = typeof defaultJs;
    if (d === Sk.ffi.JsType.BOOLEAN) {
      return Sk.ffi.booleanToPy(Boolean(defaultJs));
    } else if (d === Sk.ffi.JsType.UNDEFINED) {
      return undefined;
    } else if (d === Sk.ffi.JsType.OBJECT && defaultJs === null) {
      return Sk.ffi.none.None;
    } else {
      throw Sk.ffi.err.argument('defaultJs').inFunction('Sk.ffi.booleanToPy').mustHaveType([
        Sk.ffi.JsType.BOOLEAN,
        'null',
        Sk.ffi.JsType.UNDEFINED
      ].join(' or '));
    }
  } else {
    throw Sk.ffi.err.argument('valueJs').inFunction('Sk.ffi.booleanToPy').mustHaveType([
      Sk.ffi.JsType.BOOLEAN,
      'null',
      Sk.ffi.JsType.UNDEFINED
    ].join(' or '));
  }
};
goog.exportSymbol('Sk.ffi.booleanToPy', Sk.ffi.booleanToPy);
Sk.ffi.numberToPy = function (valueJs, kind) {
  switch (kind) {
  case Sk.ffi.PyType.FLOAT: {
      return new Sk.builtin.nmber(valueJs, Sk.builtin.nmber.float$);
    }
  case Sk.ffi.PyType.INT: {
      return new Sk.builtin.nmber(valueJs, Sk.builtin.nmber.int$);
    }
  default: {
      throw Sk.ffi.assertionError('ead77baa-30b2-470a-bb18-9db949965e45, kind => ' + kind);
    }
  }
};
goog.exportSymbol('Sk.ffi.numberToPy', Sk.ffi.numberToPy);
Sk.ffi.numberToFloatPy = function (valueJs, defaultJs) {
  var t = typeof valueJs;
  if (t === Sk.ffi.JsType.NUMBER) {
    return new Sk.builtin.nmber(valueJs, Sk.builtin.nmber.float$);
  } else if (t === Sk.ffi.JsType.OBJECT && valueJs === null) {
    return Sk.ffi.none.None;
  } else if (t === Sk.ffi.JsType.UNDEFINED) {
    var d = typeof defaultJs;
    if (d === Sk.ffi.JsType.NUMBER) {
      return Sk.ffi.numberToFloatPy(Number(defaultJs));
    } else if (d === Sk.ffi.JsType.UNDEFINED) {
      return undefined;
    } else if (d === Sk.ffi.JsType.OBJECT && defaultJs === null) {
      return Sk.ffi.none.None;
    } else {
      throw Sk.ffi.err.argument('defaultJs').inFunction('Sk.ffi.numberToFloatPy').mustHaveType([
        Sk.ffi.JsType.NUMBER,
        'null',
        Sk.ffi.JsType.UNDEFINED
      ].join(' or '));
    }
  } else {
    throw Sk.ffi.err.argument('valueJs').inFunction('Sk.ffi.numberToFloatPy').mustHaveType([
      Sk.ffi.JsType.NUMBER,
      'null',
      Sk.ffi.JsType.UNDEFINED
    ].join(' or '));
  }
};
goog.exportSymbol('Sk.ffi.numberToFloatPy', Sk.ffi.numberToFloatPy);
Sk.ffi.numberToIntPy = function (valueJs, defaultJs) {
  var t = typeof valueJs;
  if (t === Sk.ffi.JsType.NUMBER) {
    return new Sk.builtin.nmber(valueJs, Sk.builtin.nmber.int$);
  } else if (t === Sk.ffi.JsType.OBJECT && valueJs === null) {
    return Sk.ffi.none.None;
  } else if (t === Sk.ffi.JsType.UNDEFINED) {
    var d = typeof defaultJs;
    if (d === Sk.ffi.JsType.NUMBER) {
      return Sk.ffi.numberToIntPy(Number(defaultJs));
    } else if (d === Sk.ffi.JsType.UNDEFINED) {
      return undefined;
    } else if (d === Sk.ffi.JsType.OBJECT && defaultJs === null) {
      return Sk.ffi.none.None;
    } else {
      throw Sk.ffi.err.argument('defaultJs').inFunction('Sk.ffi.numberToIntPy').mustHaveType([
        Sk.ffi.JsType.NUMBER,
        'null',
        Sk.ffi.JsType.UNDEFINED
      ].join(' or '));
    }
  } else {
    throw Sk.ffi.err.argument('valueJs').inFunction('Sk.ffi.numberToIntPy').mustHaveType([
      Sk.ffi.JsType.NUMBER,
      'null',
      Sk.ffi.JsType.UNDEFINED
    ].join(' or '));
  }
};
goog.exportSymbol('Sk.ffi.numberToIntPy', Sk.ffi.numberToIntPy);
Sk.ffi.stringToPy = function (valueJs, defaultJs) {
  var t = typeof valueJs;
  if (t === Sk.ffi.JsType.STRING) {
    if (valueJs.length > 0) {
      return new Sk.builtin.str(valueJs);
    } else {
      return Sk.builtin.str.$emptystr;
    }
  } else if (t === Sk.ffi.JsType.OBJECT && valueJs === null) {
    return Sk.ffi.none.None;
  } else if (t === Sk.ffi.JsType.UNDEFINED) {
    var d = typeof defaultJs;
    if (d === Sk.ffi.JsType.STRING) {
      return Sk.ffi.stringToPy(defaultJs.toString());
    } else if (d === Sk.ffi.JsType.UNDEFINED) {
      return undefined;
    } else if (d === Sk.ffi.JsType.OBJECT && defaultJs === null) {
      return Sk.ffi.none.None;
    } else {
      throw Sk.ffi.err.argument('defaultJs').inFunction('Sk.ffi.stringToPy').mustHaveType([
        Sk.ffi.JsType.STRING,
        Sk.ffi.JsType.UNDEFINED,
        'null'
      ].join(' or '));
    }
  } else {
    throw Sk.ffi.err.argument('valueJs').inFunction('Sk.ffi.stringToPy').mustHaveType([
      Sk.ffi.JsType.STRING,
      'null',
      Sk.ffi.JsType.UNDEFINED
    ].join(' or '));
  }
};
goog.exportSymbol('Sk.ffi.stringToPy', Sk.ffi.stringToPy);
Sk.ffi.referenceToPy = function (valueJs, className, custom, targetPy) {
  var t = typeof valueJs;
  if (t === Sk.ffi.JsType.OBJECT || t === Sk.ffi.JsType.FUNCTION) {
    if (typeof className === Sk.ffi.JsType.STRING) {
      if (targetPy) {
        targetPy.v = valueJs;
        targetPy.tp$name = className;
        targetPy.custom = custom;
      } else {
        return {
          'v': valueJs,
          'tp$name': className,
          'custom': custom
        };
      }
    } else {
      throw Sk.ffi.assertionError('9fad4b9e-4845-4a06-9bce-0aa7c68e1f03 [className is ' + className + ']');
    }
  } else {
    throw Sk.ffi.assertionError('306f31df-f0a9-40a0-895b-d01308df8d6e typeof valueJs => ' + t);
  }
};
goog.exportSymbol('Sk.ffi.referenceToPy', Sk.ffi.referenceToPy);
Sk.ffi.functionPy = function (code) {
  return new Sk.builtin.func(code);
};
goog.exportSymbol('Sk.ffi.functionPy', Sk.ffi.functionPy);
Sk.ffi.listPy = function (valuesPy) {
  return new Sk.builtin.list(valuesPy);
};
goog.exportSymbol('Sk.ffi.listPy', Sk.ffi.listPy);
Sk.ffi.tuplePy = function (valuesPy) {
  return new Sk.builtin.tuple(valuesPy);
};
goog.exportSymbol('Sk.ffi.tuplePy', Sk.ffi.tuplePy);
Sk.ffi.remapToPy = function (valueJs, className, custom) {
  var t = typeof valueJs;
  if (t === Sk.ffi.JsType.OBJECT) {
    if (Object.prototype.toString.call(valueJs) === '[object Array]') {
      return new Sk.ffi.ObjectPy(valueJs);
    } else if (typeof className === Sk.ffi.JsType.STRING) {
      return Sk.ffi.referenceToPy(valueJs, className.toString(), custom);
    } else if (t === Sk.ffi.JsType.OBJECT && valueJs === null) {
      return Sk.ffi.none.None;
    } else {
      return new Sk.ffi.ObjectPy(valueJs);
    }
  } else if (t === Sk.ffi.JsType.STRING) {
    return Sk.ffi.stringToPy(valueJs);
  } else if (t === Sk.ffi.JsType.NUMBER) {
    return Sk.ffi.numberToFloatPy(valueJs);
  } else if (t === Sk.ffi.JsType.BOOLEAN) {
    return Sk.ffi.booleanToPy(valueJs);
  } else if (t === Sk.ffi.JsType.FUNCTION) {
    return Sk.ffi.functionPy(valueJs);
  } else if (t === Sk.ffi.JsType.UNDEFINED) {
    return Sk.ffi.none.None;
  } else {
    throw Sk.ffi.assertionError('d39f7c01-213e-4ded-9e5c-209a2dc94b4c, typeof valueJs => ' + t);
  }
};
goog.exportSymbol('Sk.ffi.remapToPy', Sk.ffi.remapToPy);
Sk.ffi.isBool = function (valuePy) {
  return Sk.ffi.getType(valuePy) === Sk.ffi.PyType.BOOL;
};
goog.exportSymbol('Sk.ffi.isBool', Sk.ffi.isBool);
Sk.ffi.isInstance = function (valuePy, className) {
  if (Sk.ffi.getType(valuePy) === Sk.ffi.PyType.INSTANCE) {
    var t = typeof className;
    if (t === Sk.ffi.JsType.STRING) {
      return Sk.ffi.typeName(valuePy) === className;
    } else if (t === Sk.ffi.JsType.UNDEFINED) {
      return true;
    } else if (Object.prototype.toString.call(className) === '[object Array]') {
      var name = Sk.ffi.typeName(valuePy);
      return className.some(function (x) {
        return name === x;
      });
    } else {
      throw Sk.ffi.assertionError('caa41602-62da-4850-8f76-38d013f45a6c, typeof className => ' + t);
    }
  } else {
    return false;
  }
};
goog.exportSymbol('Sk.ffi.isInstance', Sk.ffi.isInstance);
Sk.ffi.isDefined = function (valuePy) {
  return Sk.ffi.getType(valuePy) !== Sk.ffi.PyType.UNDEFINED;
};
goog.exportSymbol('Sk.ffi.isDefined', Sk.ffi.isDefined);
Sk.ffi.isObject = function (valuePy) {
  return Sk.ffi.getType(valuePy) === Sk.ffi.PyType.OBJECT;
};
goog.exportSymbol('Sk.ffi.isObject', Sk.ffi.isObject);
Sk.ffi.isDict = function (valuePy) {
  return Sk.ffi.getType(valuePy) === Sk.ffi.PyType.DICT;
};
goog.exportSymbol('Sk.ffi.isDict', Sk.ffi.isDict);
Sk.ffi.isList = function (valuePy) {
  return Sk.ffi.getType(valuePy) === Sk.ffi.PyType.LIST;
};
goog.exportSymbol('Sk.ffi.isList', Sk.ffi.isList);
Sk.ffi.isTuple = function (valuePy) {
  return Sk.ffi.getType(valuePy) === Sk.ffi.PyType.TUPLE;
};
goog.exportSymbol('Sk.ffi.isTuple', Sk.ffi.isTuple);
Sk.ffi.isFloat = function (valuePy) {
  return Sk.ffi.getType(valuePy) === Sk.ffi.PyType.FLOAT;
};
goog.exportSymbol('Sk.ffi.isFloat', Sk.ffi.isFloat);
Sk.ffi.isFunction = function (valuePy) {
  return Sk.ffi.getType(valuePy) === Sk.ffi.PyType.FUNCTION;
};
goog.exportSymbol('Sk.ffi.isFunction', Sk.ffi.isFunction);
Sk.ffi.isFunctionRef = function (valuePy) {
  return Sk.ffi.getType(valuePy) === Sk.ffi.PyType.FUNREF;
};
goog.exportSymbol('Sk.ffi.isFunctionRef', Sk.ffi.isFunctionRef);
Sk.ffi.isInt = function (valuePy) {
  return Sk.ffi.getType(valuePy) === Sk.ffi.PyType.INT;
};
goog.exportSymbol('Sk.ffi.isInt', Sk.ffi.isInt);
Sk.ffi.isLong = function (valuePy) {
  return Sk.ffi.getType(valuePy) === Sk.ffi.PyType.LONG;
};
goog.exportSymbol('Sk.ffi.isLong', Sk.ffi.isLong);
Sk.ffi.isNone = function (valuePy) {
  return Sk.ffi.getType(valuePy) === Sk.ffi.PyType.NONE;
};
goog.exportSymbol('Sk.ffi.isNone', Sk.ffi.isNone);
Sk.ffi.isNum = function (valuePy) {
  return Sk.builtin.checkNumber(valuePy);
};
goog.exportSymbol('Sk.ffi.isNum', Sk.ffi.isNum);
Sk.ffi.isStr = function (valuePy) {
  return Sk.builtin.checkString(valuePy);
};
goog.exportSymbol('Sk.ffi.isStr', Sk.ffi.isStr);
Sk.ffi.isUndefined = function (valuePy) {
  return Sk.ffi.getType(valuePy) === Sk.ffi.PyType.UNDEFINED;
};
goog.exportSymbol('Sk.ffi.isUndefined', Sk.ffi.isUndefined);
Sk.ffi.checkFunctionArgs = function (prototype, args, minargs, maxargs, kwargs, free) {
  var nargs = args.length;
  var msg = '';
  if (maxargs === undefined) {
    maxargs = Infinity;
  }
  if (kwargs) {
    nargs -= 1;
  }
  if (free) {
    nargs -= 1;
  }
  if (nargs < minargs || nargs > maxargs) {
    if (minargs === maxargs) {
      msg = prototype + ' takes exactly ' + minargs + ' arguments';
    } else if (nargs < minargs) {
      msg = prototype + ' takes at least ' + minargs + ' arguments';
    } else {
      msg = prototype + ' takes at most ' + maxargs + ' arguments';
    }
    msg += ' (' + nargs + ' given)';
    throw Sk.ffi.assertionError(msg);
  } else {
    return nargs;
  }
};
goog.exportSymbol('Sk.ffi.checkFunctionArgs', Sk.ffi.checkFunctionArgs);
Sk.ffi.checkMethodArgs = function (prototype, args, minargs, maxargs, kwargs, free) {
  return Sk.ffi.checkFunctionArgs(prototype, Array.prototype.slice.call(args, 1), minargs, maxargs, kwargs, free);
};
goog.exportSymbol('Sk.ffi.checkMethodArgs', Sk.ffi.checkMethodArgs);
Sk.ffi.SimpleType;
goog.exportSymbol('Sk.ffi.SimpleType', Sk.ffi.SimpleType);
Sk.ffi.UnionType;
goog.exportSymbol('Sk.ffi.UnionType', Sk.ffi.UnionType);
Sk.ffi.FunctionReturningTypeError;
Sk.ffi.checkArgType = function (name, expectedType, condition, valuePy) {
  if (!condition) {
    throw Sk.ffi.err.argument(name).mustHaveType(expectedType);
  }
};
goog.exportSymbol('Sk.ffi.checkArgType', Sk.ffi.checkArgType);
Sk.ffi.checkLhsOperandType = function (opName, expectedType, condition, valuePy) {
  if (!condition) {
    throw Sk.ffi.err.operand('Left').toOperation(opName).mustHaveType(expectedType);
  }
};
goog.exportSymbol('Sk.ffi.checkLhsOperandType', Sk.ffi.checkLhsOperandType);
Sk.ffi.checkRhsOperandType = function (opName, expectedType, condition, valuePy) {
  if (!condition) {
    throw Sk.ffi.err.operand('Right').toOperation(opName).mustHaveType(expectedType);
  }
};
goog.exportSymbol('Sk.ffi.checkRhsOperandType', Sk.ffi.checkRhsOperandType);
Sk.ffi.PyType = {
  'OBJECT': 1,
  'DICT': 2,
  'LIST': 3,
  'TUPLE': 4,
  'BOOL': 5,
  'FLOAT': 6,
  'INT': 7,
  'LONG': 8,
  'STR': 9,
  'NONE': 10,
  'FUNCTION': 11,
  'INSTANCE': 12,
  'UNDEFINED': -1,
  'FUNREF': -2
};
Sk.ffi.typeString = function (kind, name) {
  function typeBrackets(s) {
    return '<type \'' + s + '\'>';
  }
  function typePy(kind) {
    switch (kind) {
    case Sk.ffi.PyType.OBJECT: {
        return typeBrackets('object');
      }
    case Sk.ffi.PyType.DICT: {
        return typeBrackets('dict');
      }
    case Sk.ffi.PyType.LIST: {
        return typeBrackets('list');
      }
    case Sk.ffi.PyType.TUPLE: {
        return typeBrackets('tuple');
      }
    case Sk.ffi.PyType.BOOL: {
        return typeBrackets('bool');
      }
    case Sk.ffi.PyType.FLOAT: {
        return typeBrackets('float');
      }
    case Sk.ffi.PyType.LONG: {
        return typeBrackets('long');
      }
    case Sk.ffi.PyType.INT: {
        return typeBrackets('int');
      }
    case Sk.ffi.PyType.STR: {
        return typeBrackets('str');
      }
    case Sk.ffi.PyType.NONE: {
        return typeBrackets('NoneType');
      }
    case Sk.ffi.PyType.FUNCTION: {
        return typeBrackets('function');
      }
    default: {
        throw Sk.ffi.assertionError('fe2aed99-3b81-4a55-b3e8-61da7e734ac1, kind => ' + kind);
      }
    }
  }
  function classBrackets(name) {
    return '<class \'' + name + '\'>';
  }
  if (typeof kind === Sk.ffi.JsType.STRING) {
    return classBrackets(String(kind));
  } else if (typeof kind === Sk.ffi.JsType.NUMBER) {
    switch (kind) {
    case Sk.ffi.PyType.OBJECT:
    case Sk.ffi.PyType.DICT:
    case Sk.ffi.PyType.LIST:
    case Sk.ffi.PyType.TUPLE:
    case Sk.ffi.PyType.BOOL:
    case Sk.ffi.PyType.FLOAT:
    case Sk.ffi.PyType.LONG:
    case Sk.ffi.PyType.INT:
    case Sk.ffi.PyType.STR:
    case Sk.ffi.PyType.NONE:
    case Sk.ffi.PyType.FUNCTION: {
        return typePy(kind);
      }
    case Sk.ffi.PyType.INSTANCE: {
        return classBrackets(String(name));
      }
    default: {
        throw Sk.ffi.assertionError('b15da19c-b080-4695-a157-cfcb740b265b, kind => ' + kind);
      }
    }
  } else if (Object.prototype.toString.call(kind) === '[object Array]') {
    return kind.map(function (x) {
      return Sk.ffi.typeString(x);
    }).join(' or ');
  } else {
    throw Sk.ffi.assertionError('c32e2f75-a391-49aa-b567-b376955b4b4c, typeof kind => ' + typeof kind);
  }
};
goog.exportSymbol('Sk.ffi.typeString', Sk.ffi.typeString);
Sk.ffi.getType = function (valuePy) {
  if (typeof valuePy === Sk.ffi.JsType.UNDEFINED) {
    return Sk.ffi.PyType.UNDEFINED;
  } else if (valuePy instanceof Sk.ffi.ObjectPy) {
    return Sk.ffi.PyType.OBJECT;
  } else if (valuePy instanceof Sk.builtin.object) {
    throw new Error('Ooch - object');
  } else if (valuePy instanceof Sk.builtin.dict) {
    return Sk.ffi.PyType.DICT;
  } else if (valuePy instanceof Sk.builtin.list) {
    return Sk.ffi.PyType.LIST;
  } else if (valuePy instanceof Sk.builtin.tuple) {
    return Sk.ffi.PyType.TUPLE;
  } else if (valuePy instanceof Sk.builtin.nmber) {
    if (valuePy.skType === Sk.builtin.nmber.float$) {
      return Sk.ffi.PyType.FLOAT;
    } else if (valuePy.skType === Sk.builtin.nmber.int$) {
      return Sk.ffi.PyType.INT;
    } else {
      throw Sk.ffi.assertionError('typeofPy(' + valuePy + ') (Sk.builtin.nmber) skType=' + valuePy.skType);
    }
  } else if (valuePy instanceof Sk.builtin.lng) {
    return Sk.ffi.PyType.LONG;
  } else if (valuePy === Sk.builtin.bool.true$) {
    return Sk.ffi.PyType.BOOL;
  } else if (valuePy === Sk.builtin.bool.false$) {
    return Sk.ffi.PyType.BOOL;
  } else if (valuePy === Sk.ffi.none.None) {
    return Sk.ffi.PyType.NONE;
  } else {
    var x = typeof valuePy.v;
    if (x !== Sk.ffi.JsType.UNDEFINED) {
      if (x === Sk.ffi.JsType.STRING) {
        return Sk.ffi.PyType.STR;
      } else if (x === Sk.ffi.JsType.OBJECT) {
        if (valuePy.tp$name) {
          return Sk.ffi.PyType.INSTANCE;
        } else {
          throw Sk.ffi.assertionError('0a459acc-9540-466b-ba1a-333f8215b61e');
        }
      } else if (x === Sk.ffi.JsType.FUNCTION) {
        return Sk.ffi.PyType.FUNREF;
      } else {
        throw Sk.ffi.assertionError('bb971bb0-3751-49bb-ac24-8dab8a4bcd29 (x:\'' + x + '\')');
      }
    } else {
      return Sk.ffi.PyType.FUNCTION;
    }
  }
};
goog.exportSymbol('Sk.ffi.getType', Sk.ffi.getType);
Sk.ffi.typeName = function (valuePy) {
  switch (Sk.ffi.getType(valuePy)) {
  case Sk.ffi.PyType.INSTANCE:
  case Sk.ffi.PyType.BOOL:
  case Sk.ffi.PyType.FLOAT:
  case Sk.ffi.PyType.INT:
  case Sk.ffi.PyType.STR: {
      return Sk.abstr.typeName(valuePy);
    }
  default: {
      throw Sk.ffi.assertionError('0d35490f-ac78-45d7-ac5e-af6ef09278b1, Sk.ffi.getType(valuePy) => ' + Sk.ffi.getType(valuePy));
    }
  }
};
goog.exportSymbol('Sk.ffi.typeName', Sk.ffi.typeName);
Sk.ffi.booleanToJs = function (valuePy, message) {
  if (valuePy === Sk.builtin.bool.true$) {
    return true;
  } else if (valuePy === Sk.builtin.bool.false$) {
    return false;
  } else {
    if (typeof message === Sk.ffi.JsType.STRING) {
      throw Sk.ffi.typeError(String(message));
    } else {
      throw Sk.ffi.err.attribute('value').mustHaveType(Sk.ffi.PyType.BOOL);
    }
  }
};
goog.exportSymbol('Sk.ffi.booleanToJs', Sk.ffi.booleanToJs);
Sk.ffi.numberToJs = function (valuePy, message) {
  if (valuePy instanceof Sk.builtin.nmber) {
    return Sk.builtin.asnum$(valuePy);
  } else {
    if (typeof message === Sk.ffi.JsType.STRING) {
      throw Sk.ffi.typeError(String(message));
    } else {
      throw Sk.ffi.err.attribute('value').mustHaveType([
        Sk.ffi.PyType.FLOAT,
        Sk.ffi.PyType.INT,
        Sk.ffi.PyType.LONG
      ]);
    }
  }
};
goog.exportSymbol('Sk.ffi.numberToJs', Sk.ffi.numberToJs);
Sk.ffi.remapToJs = function (valuePy, shallow) {
  Sk.ffi.checkFunctionArgs('Sk.ffi.remapToJs', arguments, 1, 2);
  switch (Sk.ffi.getType(valuePy)) {
  case Sk.ffi.PyType.STR: {
      return valuePy.v;
    }
  case Sk.ffi.PyType.OBJECT: {
      return valuePy.v;
    }
  case Sk.ffi.PyType.DICT: {
      var ret = {};
      for (var iter = valuePy.tp$iter(), k = iter.tp$iternext(); k !== undefined; k = iter.tp$iternext()) {
        var v = valuePy.mp$subscript(k);
        if (v === undefined) {
          v = null;
        }
        var kAsJs = Sk.ffi.remapToJs(k);
        ret[kAsJs] = Sk.ffi.remapToJs(v);
      }
      return ret;
    }
  case Sk.ffi.PyType.LIST: {
      if (shallow) {
        return valuePy.v;
      } else {
        var ret = [];
        for (var i = 0; i < valuePy.v.length; ++i) {
          ret.push(Sk.ffi.remapToJs(valuePy.v[i]));
        }
        return ret;
      }
    }
  case Sk.ffi.PyType.TUPLE: {
      var ret = [];
      for (var i = 0; i < valuePy.v.length; ++i) {
        ret.push(Sk.ffi.remapToJs(valuePy.v[i]));
      }
      return ret;
    }
  case Sk.ffi.PyType.BOOL: {
      if (valuePy === Sk.builtin.bool.true$) {
        return true;
      } else if (valuePy === Sk.builtin.bool.false$) {
        return false;
      } else {
        throw Sk.ffi.assertionError('5fd1f529-f9b2-4d0c-9775-36e782973986');
      }
    }
  case Sk.ffi.PyType.FLOAT:
  case Sk.ffi.PyType.INT:
  case Sk.ffi.PyType.LONG: {
      return Sk.builtin.asnum$(valuePy);
    }
  case Sk.ffi.PyType.INSTANCE: {
      return valuePy.v;
    }
  case Sk.ffi.PyType.FUNREF: {
      return valuePy.v;
    }
  case Sk.ffi.PyType.UNDEFINED: {
      return undefined;
    }
  case Sk.ffi.PyType.NONE: {
      return null;
    }
  case Sk.ffi.PyType.FUNCTION: {
      return function () {
        var argsJs = Array.prototype.slice.call(arguments, 0);
        var argsPy = argsJs.map(function (argJs) {
            return Sk.ffi.remapToPy(argJs);
          });
        return Sk.ffi.remapToJs(Sk.misceval.apply(valuePy, undefined, undefined, undefined, argsPy));
      };
    }
  default: {
      throw Sk.ffi.assertionError('20be4da2-63e8-4fff-9359-7ab46eba4702 ' + Sk.ffi.getType(valuePy));
    }
  }
};
goog.exportSymbol('Sk.ffi.remapToJs', Sk.ffi.remapToJs);
Sk.ffi.customToJs = function (valuePy) {
  return valuePy.custom;
};
goog.exportSymbol('Sk.ffi.customToJs', Sk.ffi.customToJs);
Sk.ffi.buildClass = function (globals, func, name, bases) {
  return Sk.misceval.buildClass(globals, func, name, bases);
};
goog.exportSymbol('Sk.ffi.buildClass', Sk.ffi.buildClass);
Sk.ffi.callsim = function (func, args) {
  var args = Array.prototype.slice.call(arguments, 1);
  return Sk.misceval.apply(func, undefined, undefined, undefined, args);
};
goog.exportSymbol('Sk.ffi.callsim', Sk.ffi.callsim);
Sk.ffi.callableToPy = function (mod, nameJs, functionJs) {
  return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
    $loc.__init__ = Sk.ffi.functionPy(function (selfPy) {
      Sk.ffi.referenceToPy(null, nameJs, null, selfPy);
    });
    $loc.__call__ = Sk.ffi.functionPy(functionJs);
    $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
      return Sk.ffi.stringToPy(nameJs);
    });
    $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
      return Sk.ffi.stringToPy(nameJs);
    });
  }, nameJs, []));
};
goog.exportSymbol('Sk.ffi.callableToPy', Sk.ffi.callableToPy);
Sk.ffi.gattr = function (objectPy, name) {
  return Sk.abstr.gattr(objectPy, name);
};
goog.exportSymbol('Sk.ffi.gattr', Sk.ffi.gattr);
Sk.ffi.sattr = function (objectPy, name, valuePy) {
  return Sk.abstr.sattr(objectPy, name, valuePy);
};
goog.exportSymbol('Sk.ffi.sattr', Sk.ffi.sattr);
Sk.ffi.indexError = function (args) {
  return new Sk.builtin.IndexError(args);
};
goog.exportSymbol('Sk.ffi.indexError', Sk.ffi.indexError);
Sk.ffi.valueError = function (args) {
  return new Sk.builtin.ValueError(args);
};
goog.exportSymbol('Sk.ffi.valueError', Sk.ffi.valueError);
Sk.ffi.err = {
  attribute: function (name) {
    return {
      isNotGetableOnType: function (targetType) {
        return Sk.ffi.attributeError(name + ' is not an attribute of ' + Sk.ffi.typeString(targetType));
      },
      isNotSetableOnType: function (targetType) {
        return Sk.ffi.attributeError(name + ' is not an attribute of ' + Sk.ffi.typeString(targetType));
      }
    };
  },
  argument: function (name) {
    return {
      inFunction: function (functionName) {
        return {
          mustHaveType: function (expectedType) {
            return Sk.ffi.typeError('Expecting argument \'' + name + '\' in function \'' + functionName + '\' to have type ' + Sk.ffi.typeString(expectedType) + '.');
          }
        };
      },
      mustHaveType: function (expectedType) {
        return Sk.ffi.typeError(name + ' must be a ' + Sk.ffi.typeString(expectedType));
      }
    };
  },
  operand: function (name) {
    return {
      toOperation: function (opName) {
        return {
          mustHaveType: function (expectedType) {
            return Sk.ffi.typeError('Expecting operand \'' + name + '\' to operation \'' + opName + '\' to have type ' + Sk.ffi.typeString(expectedType) + '.');
          }
        };
      }
    };
  }
};
goog.exportSymbol('Sk.ffi.err', Sk.ffi.err);
Sk.ffi.callback = function (functionPy) {
  return Sk.ffi.remapToJs(functionPy);
};
goog.exportSymbol('Sk.ffi.callback', Sk.ffi.callback);
Sk.ffi.stdwrap = function (type, towrap) {
  var inst = new type();
  inst['v'] = towrap;
  return inst;
};
goog.exportSymbol('Sk.ffi.stdwrap', Sk.ffi.stdwrap);
Sk.ffi.basicwrap = function (obj) {
  return Sk.ffi.remapToPy(obj);
};
goog.exportSymbol('Sk.ffi.basicwrap', Sk.ffi.basicwrap);
Sk.ffi.unwrapo = function (obj) {
  return Sk.ffi.remapToJs(obj);
};
goog.exportSymbol('Sk.ffi.unwrapo', Sk.ffi.unwrapo);
Sk.ffi.unwrapn = function (obj) {
  return Sk.ffi.remapToJs(obj);
};
goog.exportSymbol('Sk.ffi.unwrapn', Sk.ffi.unwrapn);
Sk.ffi.ObjectPy = function (objectJs) {
  this.v = objectJs;
};
Sk.ffi.ObjectPy.prototype.tp$getattr = function (name) {
  goog.asserts.assertString(name);
  goog.asserts.assert(this.ob$type !== undefined, 'object has no ob$type!');
  var selfJs = this.v;
  var propJs = this.v[name];
  switch (typeof propJs) {
  case 'function': {
      return new Sk.ffi.CallablePy(this.v, name);
    }
  case 'number': {
      return Sk.ffi.numberToFloatPy(propJs);
    }
  case 'object': {
      return new Sk.ffi.ObjectPy(propJs);
    }
  case 'boolean': {
      return Sk.ffi.booleanToPy(propJs);
    }
  case 'undefined': {
      switch (name) {
      case 'append': {
          return new Sk.builtin.func(function (itemPy) {
            Sk.builtin.pyCheckArgs('append', arguments, 1, 1);
            selfJs.push(Sk.ffi.remapToJs(itemPy));
            return Sk.ffi.none.None;
          });
        }
      default: {
          return Sk.ffi.none.None;
        }
      }
    }
  default: {
      goog.asserts.assertString(propJs);
      return Sk.ffi.stringToPy(propJs);
    }
  }
};
Sk.ffi.ObjectPy.prototype.tp$setattr = function (name, valuePy) {
  goog.asserts.assert(typeof name === 'string');
  this.v[name] = Sk.ffi.remapToJs(valuePy);
};
Sk.ffi.ObjectPy.prototype.mp$subscript = function (index) {
  if (!Array.isArray(this.v)) {
    throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(this) + '\' object does not support indexing.');
  }
  if (Sk.misceval.isIndex(index)) {
    var i = Sk.misceval.asIndex(index);
    if (i !== undefined) {
      if (i < 0) {
        i = this.v.length + i;
      }
      if (i < 0 || i >= this.v.length) {
        throw new Sk.builtin.IndexError('list index out of range');
      }
      return this.v[i];
    } else {
    }
  } else if (index instanceof Sk.builtin.slice) {
    var ret = [];
    index.sssiter$(this, function (i, wrt) {
      ret.push(wrt.v[i]);
    });
    return new Sk.builtin.list(ret);
  }
  throw new Sk.builtin.TypeError('list indices must be integers, not ' + Sk.abstr.typeName(index));
};
Sk.ffi.ObjectPy.prototype.tp$iter = function () {
  var ret = {
      tp$iter: function () {
        return ret;
      },
      $obj: this,
      $index: 0,
      tp$iternext: function () {
        if (ret.$index >= ret.$obj.v.length)
          return undefined;
        return Sk.ffi.remapToPy(ret.$obj.v[ret.$index++]);
      }
    };
  return ret;
};
Sk.ffi.ObjectPy.prototype.tp$name = 'ObjectPy';
Sk.ffi.ObjectPy.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('ObjectPy', Sk.ffi.ObjectPy);
Sk.ffi.ObjectPy.prototype.tp$str = function () {
  return Sk.ffi.stringToPy('' + this.v);
};
Sk.ffi.ObjectPy.prototype.tp$repr = function () {
  return Sk.ffi.stringToPy('' + this.v);
};
Sk.ffi.ObjectPy.prototype.nb$add = function (otherPy) {
  return Sk.ffi.remapToPy(this.v.add(Sk.ffi.remapToJs(otherPy)));
};
Sk.ffi.ObjectPy.prototype.nb$subtract = function (otherPy) {
  return Sk.ffi.remapToPy(this.v.sub(Sk.ffi.remapToJs(otherPy)));
};
Sk.ffi.ObjectPy.prototype.nb$multiply = function (otherPy) {
  return Sk.ffi.remapToPy(this.v.mul(Sk.ffi.remapToJs(otherPy)));
};
Sk.ffi.ObjectPy.prototype.nb$divide = function (otherPy) {
  return Sk.ffi.remapToPy(this.v.div(Sk.ffi.remapToJs(otherPy)));
};
goog.exportSymbol('Sk.ffi.ObjectPy', Sk.ffi.ObjectPy);
Sk.ffi.CallablePy = function (objectJs, name) {
  this.v = objectJs;
  this.name = name;
};
Sk.ffi.CallablePy.prototype.tp$call = function (args, kw) {
  var objectJs = this.v;
  var name = this.name;
  var propJs = objectJs[name];
  var argsJs = args.map(function (xPy) {
      return Sk.ffi.remapToJs(xPy);
    });
  function isConstructorFunction(name) {
    if (name === 'Value' || name === 'X' || name === 'Y') {
      return false;
    }
    if (name[0] === name[0].toUpperCase()) {
      return true;
    } else {
      return false;
    }
  }
  if (isConstructorFunction(name)) {
    var that = Object.create(propJs.prototype);
    var other = propJs.apply(that, argsJs);
    var valueJs = typeof other === 'object' && other || that;
    return Sk.ffi.remapToPy(valueJs);
  } else {
    return Sk.ffi.remapToPy(propJs.apply(objectJs, argsJs));
  }
};
Sk.ffh = Sk.ffh || {};
var SPECIAL_METHOD_ADD = '__add__';
var SPECIAL_METHOD_CLIFFORD_CONJUGATE = '__cliffordConjugate__';
var SPECIAL_METHOD_CONJUGATE = '__conjugate__';
var SPECIAL_METHOD_DIV = '__div__';
var SPECIAL_METHOD_EQ = '__eq__';
var SPECIAL_METHOD_COS = '__cos__';
var SPECIAL_METHOD_EXP = '__exp__';
var SPECIAL_METHOD_GETITEM = '__getitem__';
var SPECIAL_METHOD_INVERT = '__invert__';
var SPECIAL_METHOD_LSHIFT = '__lshift__';
var SPECIAL_METHOD_MUL = '__mul__';
var SPECIAL_METHOD_NEG = '__neg__';
var SPECIAL_METHOD_NONZERO = '__nonzero__';
var SPECIAL_METHOD_POS = '__pos__';
var SPECIAL_METHOD_REPR = '__repr__';
var SPECIAL_METHOD_RMUL = '__rmul__';
var SPECIAL_METHOD_RSHIFT = '__rshift__';
var SPECIAL_METHOD_SIN = '__sin__';
var SPECIAL_METHOD_SQRT = '__sqrt__';
var SPECIAL_METHOD_STR = '__str__';
var SPECIAL_METHOD_SUB = '__sub__';
var SPECIAL_METHOD_TAN = '__tan__';
var SPECIAL_METHOD_XOR = '__xor__';
Sk.ffh.unaryExec = function (name, specialMethod, valuePy, internalMethod) {
  if (valuePy[specialMethod]) {
    return Sk.ffi.callsim(valuePy[specialMethod], valuePy);
  } else if (typeof internalMethod !== 'undefined' && valuePy[internalMethod]) {
    return valuePy[internalMethod].call(valuePy);
  } else {
    throw Sk.ffi.typeError(name + '(' + Sk.ffi.remapToJs(Sk.ffh.repr(valuePy)) + ')');
  }
};
goog.exportSymbol('Sk.ffh.unaryExec', Sk.ffh.unaryExec);
Sk.ffh.getitem = function (objPy, index) {
  if (objPy[SPECIAL_METHOD_GETITEM]) {
    return Sk.ffi.callsim(objPy[SPECIAL_METHOD_GETITEM], objPy, Sk.ffi.numberToIntPy(index));
  } else {
    throw Sk.ffi.notImplementedError(SPECIAL_METHOD_GETITEM);
  }
};
goog.exportSymbol('Sk.ffh.getitem', Sk.ffh.getitem);
Sk.ffh.add = function (lhsPy, rhsPy) {
  return Sk.abstr.binary_op_(lhsPy, rhsPy, 'Add');
};
goog.exportSymbol('Sk.ffh.add', Sk.ffh.add);
Sk.ffh.subtract = function (lhsPy, rhsPy) {
  return Sk.abstr.binary_op_(lhsPy, rhsPy, 'Sub');
};
goog.exportSymbol('Sk.ffh.subtract', Sk.ffh.subtract);
Sk.ffh.multiply = function (lhsPy, rhsPy) {
  return Sk.abstr.binary_op_(lhsPy, rhsPy, 'Mult');
};
goog.exportSymbol('Sk.ffh.multiply', Sk.ffh.multiply);
Sk.ffh.divide = function (lhsPy, rhsPy) {
  return Sk.abstr.binary_op_(lhsPy, rhsPy, 'Div');
};
goog.exportSymbol('Sk.ffh.divide', Sk.ffh.divide);
Sk.ffh.mod = function (lhsPy, rhsPy) {
  return Sk.abstr.binary_op_(lhsPy, rhsPy, 'Mod');
};
goog.exportSymbol('Sk.ffh.mod', Sk.ffh.mod);
Sk.ffh.xor = function (lhsPy, rhsPy) {
  return Sk.abstr.binary_op_(lhsPy, rhsPy, 'BitXor');
};
goog.exportSymbol('Sk.ffh.xor', Sk.ffh.xor);
Sk.ffh.lshift = function (lhsPy, rhsPy) {
  return Sk.abstr.binary_op_(lhsPy, rhsPy, 'LShift');
};
goog.exportSymbol('Sk.ffh.lshift', Sk.ffh.lshift);
Sk.ffh.rshift = function (lhsPy, rhsPy) {
  return Sk.abstr.binary_op_(lhsPy, rhsPy, 'RShift');
};
goog.exportSymbol('Sk.ffh.rshift', Sk.ffh.rshift);
Sk.ffh.pow = function (lhsPy, rhsPy) {
  return Sk.abstr.binary_op_(lhsPy, rhsPy, 'Pow');
};
goog.exportSymbol('Sk.ffh.rshift', Sk.ffh.rshift);
Sk.ffh.equal = function (lhsPy, rhsPy) {
  if (lhsPy[SPECIAL_METHOD_EQ]) {
    return Sk.ffi.callsim(lhsPy[SPECIAL_METHOD_EQ], lhsPy, rhsPy);
  } else {
    throw Sk.ffi.notImplementedError('equal(' + Sk.ffh.repr(lhsPy) + ', ' + Sk.ffh.repr(rhsPy) + ')');
  }
};
goog.exportSymbol('Sk.ffh.equal', Sk.ffh.equal);
Sk.ffh.cliffordConjugate = function (valuePy) {
  return Sk.ffh.unaryExec('', SPECIAL_METHOD_CLIFFORD_CONJUGATE, valuePy, 'nb$cliffordConjugate');
};
goog.exportSymbol('Sk.ffh.cliffordConjugate', Sk.ffh.cliffordConjugate);
Sk.ffh.conjugate = function (numberPy) {
  if (Sk.ffi.isNum(numberPy)) {
    return numberPy;
  } else {
    return Sk.ffh.unaryExec('', SPECIAL_METHOD_CONJUGATE, numberPy);
  }
};
goog.exportSymbol('Sk.ffh.conjugate', Sk.ffh.conjugate);
Sk.ffh.cos = function (valuePy) {
  return Sk.ffh.unaryExec('cos', SPECIAL_METHOD_COS, valuePy, 'nb$cos');
};
goog.exportSymbol('Sk.ffh.cos', Sk.ffh.cos);
Sk.ffh.sin = function (valuePy) {
  return Sk.ffh.unaryExec('sin', SPECIAL_METHOD_SIN, valuePy, 'nb$sin');
};
goog.exportSymbol('Sk.ffh.sin', Sk.ffh.sin);
Sk.ffh.tan = function (valuePy) {
  return Sk.ffh.unaryExec('tan', SPECIAL_METHOD_TAN, valuePy, 'nb$tan');
};
goog.exportSymbol('Sk.ffh.tan', Sk.ffh.tan);
Sk.ffh.exp = function (valuePy) {
  return Sk.ffh.unaryExec('exp', SPECIAL_METHOD_EXP, valuePy, 'nu$exponential');
};
goog.exportSymbol('Sk.ffh.exp', Sk.ffh.exp);
Sk.ffh.positive = function (valuePy) {
  return Sk.abstr.numberUnaryOp(valuePy, 'UAdd');
};
goog.exportSymbol('Sk.ffh.positive', Sk.ffh.positive);
Sk.ffh.negative = function (valuePy) {
  return Sk.abstr.numberUnaryOp(valuePy, 'USub');
};
goog.exportSymbol('Sk.ffh.negative', Sk.ffh.negative);
Sk.ffh.invert = function (valuePy) {
  return Sk.ffh.unaryExec('~', SPECIAL_METHOD_INVERT, valuePy, 'nb$invert');
};
goog.exportSymbol('Sk.ffh.invert', Sk.ffh.invert);
Sk.ffh.nonzero = function (valuePy) {
  return Sk.ffh.unaryExec('', SPECIAL_METHOD_NONZERO, valuePy, 'nb$nonzero');
};
goog.exportSymbol('Sk.ffh.nonzero', Sk.ffh.nonzero);
Sk.ffh.abs = function (valuePy) {
  return Sk.ffh.unaryExec('abs', '__abs__', valuePy, 'nu$abs');
};
goog.exportSymbol('Sk.ffh.abs', Sk.ffh.abs);
Sk.ffh.magnitude = function (valuePy) {
  return Sk.ffh.unaryExec('magnitude', '__magnitude__', valuePy, 'nu$magnitude');
};
goog.exportSymbol('Sk.ffh.magnitude', Sk.ffh.magnitude);
Sk.ffh.quadrance = function (valuePy) {
  return Sk.ffh.unaryExec('quadrance', '__quadrance__', valuePy, 'nu$quadrance');
};
goog.exportSymbol('Sk.ffh.quadrance', Sk.ffh.quadrance);
Sk.ffh.sqrt = function (valuePy) {
  return Sk.ffh.unaryExec('sqrt', SPECIAL_METHOD_SQRT, valuePy);
};
goog.exportSymbol('Sk.ffh.sqrt', Sk.ffh.sqrt);
Sk.ffh.str = function (valuePy) {
  if (valuePy[SPECIAL_METHOD_STR]) {
    return Sk.ffi.callsim(valuePy[SPECIAL_METHOD_STR], valuePy);
  } else if (valuePy['tp$str']) {
    return valuePy['tp$str'].call(valuePy);
  } else if (valuePy['tp$repr']) {
    return valuePy['tp$repr'].call(valuePy);
  } else {
    throw Sk.ffi.notImplementedError('str');
  }
};
goog.exportSymbol('Sk.ffh.str', Sk.ffh.str);
Sk.ffh.repr = function (valuePy) {
  return Sk.ffh.unaryExec('repr', SPECIAL_METHOD_REPR, valuePy, 'tp$repr');
};
goog.exportSymbol('Sk.ffh.repr', Sk.ffh.repr);
Sk.ffh.evaluate = function (exprPy, envPy) {
  if (Sk.ffi.isFloat(exprPy) || Sk.ffi.isInt(exprPy) || Sk.ffi.isLong(exprPy)) {
    return exprPy;
  } else {
    return Sk.ffi.callsim(Sk.ffi.gattr(exprPy, 'evaluate'), envPy);
  }
};
goog.exportSymbol('Sk.ffh.evaluate', Sk.ffh.evaluate);
Sk.builtin.enumerate = function (iterable, start) {
  if (!(this instanceof Sk.builtin.enumerate))
    return new Sk.builtin.enumerate(iterable, start);
  Sk.builtin.pyCheckArgs('enumerate', arguments, 1, 2);
  if (!Sk.builtin.checkIterable(iterable)) {
    throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(iterable) + '\' object is not iterable');
  }
  if (start !== undefined) {
    if (!Sk.misceval.isIndex(start)) {
      throw new Sk.builtin.TypeError('\'' + Sk.abstr.typeName(start) + '\' object cannot be interpreted as an index');
    } else {
      start = Sk.misceval.asIndex(start);
    }
  } else {
    start = 0;
  }
  var it = iterable.tp$iter();
  this.tp$iter = function () {
    return this;
  };
  this.$index = start;
  this.tp$iternext = function () {
    var next = it.tp$iternext();
    if (next === undefined)
      return undefined;
    return new Sk.builtin.tuple([
      this.$index++,
      next
    ]);
  };
  this.__class__ = Sk.builtin.enumerate;
  return this;
};
Sk.builtin.enumerate.prototype.tp$name = 'enumerate';
Sk.builtin.enumerate.prototype.ob$type = Sk.builtin.type.makeIntoTypeObj('enumerate', Sk.builtin.enumerate);
Sk.builtin.enumerate.prototype.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;
Sk.builtin.enumerate.prototype['__iter__'] = new Sk.builtin.func(function (self) {
  return self.tp$iter();
});
Sk.builtin.enumerate.prototype['next'] = new Sk.builtin.func(function (self) {
  return self.tp$iternext();
});
Sk.Tokenizer = function (filename, interactive, callback) {
  this.filename = filename;
  this.callback = callback;
  this.lnum = 0;
  this.parenlev = 0;
  this.continued = false;
  this.namechars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_';
  this.numchars = '0123456789';
  this.contstr = '';
  this.needcont = false;
  this.contline = undefined;
  this.indents = [0];
  this.endprog = /.*/;
  this.strstart = [
    -1,
    -1
  ];
  this.interactive = interactive;
  this.doneFunc = function () {
    for (var i = 1; i < this.indents.length; ++i) {
      if (this.callback(Sk.Tokenizer.Tokens.T_DEDENT, '', [
          this.lnum,
          0
        ], [
          this.lnum,
          0
        ], ''))
        return 'done';
    }
    if (this.callback(Sk.Tokenizer.Tokens.T_ENDMARKER, '', [
        this.lnum,
        0
      ], [
        this.lnum,
        0
      ], ''))
      return 'done';
    return 'failed';
  };
};
Sk.Tokenizer.Tokens = {
  T_ENDMARKER: 0,
  T_NAME: 1,
  T_NUMBER: 2,
  T_STRING: 3,
  T_NEWLINE: 4,
  T_INDENT: 5,
  T_DEDENT: 6,
  T_LPAR: 7,
  T_RPAR: 8,
  T_LSQB: 9,
  T_RSQB: 10,
  T_COLON: 11,
  T_COMMA: 12,
  T_SEMI: 13,
  T_PLUS: 14,
  T_MINUS: 15,
  T_STAR: 16,
  T_SLASH: 17,
  T_VBAR: 18,
  T_AMPER: 19,
  T_LESS: 20,
  T_GREATER: 21,
  T_EQUAL: 22,
  T_DOT: 23,
  T_PERCENT: 24,
  T_BACKQUOTE: 25,
  T_LBRACE: 26,
  T_RBRACE: 27,
  T_EQEQUAL: 28,
  T_NOTEQUAL: 29,
  T_LESSEQUAL: 30,
  T_GREATEREQUAL: 31,
  T_TILDE: 32,
  T_CIRCUMFLEX: 33,
  T_LEFTSHIFT: 34,
  T_RIGHTSHIFT: 35,
  T_DOUBLESTAR: 36,
  T_PLUSEQUAL: 37,
  T_MINEQUAL: 38,
  T_STAREQUAL: 39,
  T_SLASHEQUAL: 40,
  T_PERCENTEQUAL: 41,
  T_AMPEREQUAL: 42,
  T_VBAREQUAL: 43,
  T_CIRCUMFLEXEQUAL: 44,
  T_LEFTSHIFTEQUAL: 45,
  T_RIGHTSHIFTEQUAL: 46,
  T_DOUBLESTAREQUAL: 47,
  T_DOUBLESLASH: 48,
  T_DOUBLESLASHEQUAL: 49,
  T_AT: 50,
  T_OP: 51,
  T_COMMENT: 52,
  T_NL: 53,
  T_RARROW: 54,
  T_ERRORTOKEN: 55,
  T_N_TOKENS: 56,
  T_NT_OFFSET: 256
};
function group(x) {
  var args = Array.prototype.slice.call(arguments);
  return '(' + args.join('|') + ')';
}
function any(x) {
  return group.apply(null, arguments) + '*';
}
function maybe(x) {
  return group.apply(null, arguments) + '?';
}
var Whitespace = '[ \\f\\t]*';
var Comment_ = '#[^\\r\\n]*';
var Ident = '[a-zA-Z_]\\w*';
var Binnumber = '0[bB][01]*';
var Hexnumber = '0[xX][\\da-fA-F]*[lL]?';
var Octnumber = '0[oO]?[0-7]*[lL]?';
var Decnumber = '[1-9]\\d*[lL]?';
var Intnumber = group(Binnumber, Hexnumber, Octnumber, Decnumber);
var Exponent = '[eE][-+]?\\d+';
var Pointfloat = group('\\d+\\.\\d*', '\\.\\d+') + maybe(Exponent);
var Expfloat = '\\d+' + Exponent;
var Floatnumber = group(Pointfloat, Expfloat);
var Imagnumber = group('\\d+[jJ]', Floatnumber + '[jJ]');
var Number_ = group(Imagnumber, Floatnumber, Intnumber);
var Single = '^[^\'\\\\]*(?:\\\\.[^\'\\\\]*)*\'';
var Double_ = '^[^"\\\\]*(?:\\\\.[^"\\\\]*)*"';
var Single3 = '[^\'\\\\]*(?:(?:\\\\.|\'(?!\'\'))[^\'\\\\]*)*\'\'\'';
var Double3 = '[^"\\\\]*(?:(?:\\\\.|"(?!""))[^"\\\\]*)*"""';
var Triple = group('[ubUB]?[rR]?\'\'\'', '[ubUB]?[rR]?"""');
var String_ = group('[uU]?[rR]?\'[^\\n\'\\\\]*(?:\\\\.[^\\n\'\\\\]*)*\'', '[uU]?[rR]?"[^\\n"\\\\]*(?:\\\\.[^\\n"\\\\]*)*"');
var Operator = group('\\*\\*=?', '>>=?', '<<=?', '<>', '!=', '//=?', '->', '[+\\-*/%&|^=<>]=?', '~');
var Bracket = '[\\][(){}]';
var Special = group('\\r?\\n', '[:;.,`@]');
var Funny = group(Operator, Bracket, Special);
var ContStr = group('[uUbB]?[rR]?\'[^\\n\'\\\\]*(?:\\\\.[^\\n\'\\\\]*)*' + group('\'', '\\\\\\r?\\n'), '[uUbB]?[rR]?"[^\\n"\\\\]*(?:\\\\.[^\\n"\\\\]*)*' + group('"', '\\\\\\r?\\n'));
var PseudoExtras = group('\\\\\\r?\\n', Comment_, Triple);
var PseudoToken = '^' + group(PseudoExtras, Number_, Funny, ContStr, Ident);
var pseudoprog;
var single3prog;
var double3prog;
var endprogs = {};
var triple_quoted = {
    '\'\'\'': true,
    '"""': true,
    'r\'\'\'': true,
    'r"""': true,
    'R\'\'\'': true,
    'R"""': true,
    'u\'\'\'': true,
    'u"""': true,
    'U\'\'\'': true,
    'U"""': true,
    'b\'\'\'': true,
    'b"""': true,
    'B\'\'\'': true,
    'B"""': true,
    'ur\'\'\'': true,
    'ur"""': true,
    'Ur\'\'\'': true,
    'Ur"""': true,
    'uR\'\'\'': true,
    'uR"""': true,
    'UR\'\'\'': true,
    'UR"""': true,
    'br\'\'\'': true,
    'br"""': true,
    'Br\'\'\'': true,
    'Br"""': true,
    'bR\'\'\'': true,
    'bR"""': true,
    'BR\'\'\'': true,
    'BR"""': true
  };
var single_quoted = {
    '\'': true,
    '"': true,
    'r\'': true,
    'r"': true,
    'R\'': true,
    'R"': true,
    'u\'': true,
    'u"': true,
    'U\'': true,
    'U"': true,
    'b\'': true,
    'b"': true,
    'B\'': true,
    'B"': true,
    'ur\'': true,
    'ur"': true,
    'Ur\'': true,
    'Ur"': true,
    'uR\'': true,
    'uR"': true,
    'UR\'': true,
    'UR"': true,
    'br\'': true,
    'br"': true,
    'Br\'': true,
    'Br"': true,
    'bR\'': true,
    'bR"': true,
    'BR\'': true,
    'BR"': true
  };
(function () {
  for (var k in triple_quoted) {
  }
  for (var k in single_quoted) {
  }
}());
var tabsize = 8;
function contains(a, obj) {
  var i = a.length;
  while (i--) {
    if (a[i] === obj) {
      return true;
    }
  }
  return false;
}
function rstrip(input, what) {
  for (var i = input.length; i > 0; --i) {
    if (what.indexOf(input.charAt(i - 1)) === -1)
      break;
  }
  return input.substring(0, i);
}
Sk.Tokenizer.prototype.generateTokens = function (line) {
  var endmatch, pos, column, end, max;
  var pseudoprog = new RegExp(PseudoToken);
  var single3prog = new RegExp(Single3, 'g');
  var double3prog = new RegExp(Double3, 'g');
  var endprogs = {
      '\'': new RegExp(Single, 'g'),
      '"': new RegExp(Double_, 'g'),
      '\'\'\'': single3prog,
      '"""': double3prog,
      'r\'\'\'': single3prog,
      'r"""': double3prog,
      'u\'\'\'': single3prog,
      'u"""': double3prog,
      'b\'\'\'': single3prog,
      'b"""': double3prog,
      'ur\'\'\'': single3prog,
      'ur"""': double3prog,
      'br\'\'\'': single3prog,
      'br"""': double3prog,
      'R\'\'\'': single3prog,
      'R"""': double3prog,
      'U\'\'\'': single3prog,
      'U"""': double3prog,
      'B\'\'\'': single3prog,
      'B"""': double3prog,
      'uR\'\'\'': single3prog,
      'uR"""': double3prog,
      'Ur\'\'\'': single3prog,
      'Ur"""': double3prog,
      'UR\'\'\'': single3prog,
      'UR"""': double3prog,
      'bR\'\'\'': single3prog,
      'bR"""': double3prog,
      'Br\'\'\'': single3prog,
      'Br"""': double3prog,
      'BR\'\'\'': single3prog,
      'BR"""': double3prog,
      'r': null,
      'R': null,
      'u': null,
      'U': null,
      'b': null,
      'B': null
    };
  if (!line)
    line = '';
  this.lnum += 1;
  pos = 0;
  max = line.length;
  if (this.contstr.length > 0) {
    if (!line) {
      throw new Sk.builtin.TokenError('EOF in multi-line string', this.filename, this.strstart[0], this.strstart[1], this.contline);
    }
    this.endprog.lastIndex = 0;
    endmatch = this.endprog.test(line);
    if (endmatch) {
      pos = end = this.endprog.lastIndex;
      if (this.callback(Sk.Tokenizer.Tokens.T_STRING, this.contstr + line.substring(0, end), this.strstart, [
          this.lnum,
          end
        ], this.contline + line))
        return 'done';
      this.contstr = '';
      this.needcont = false;
      this.contline = undefined;
    } else if (this.needcont && line.substring(line.length - 2) !== '\\\n' && line.substring(line.length - 3) !== '\\\r\n') {
      if (this.callback(Sk.Tokenizer.Tokens.T_ERRORTOKEN, this.contstr + line, this.strstart, [
          this.lnum,
          line.length
        ], this.contline))
        return 'done';
      this.contstr = '';
      this.contline = undefined;
      return false;
    } else {
      this.contstr += line;
      this.contline = this.contline + line;
      return false;
    }
  } else if (this.parenlev === 0 && !this.continued) {
    if (!line)
      return this.doneFunc();
    column = 0;
    while (pos < max) {
      if (line.charAt(pos) === ' ')
        column += 1;
      else if (line.charAt(pos) === '\t')
        column = (column / tabsize + 1) * tabsize;
      else if (line.charAt(pos) === '\f')
        column = 0;
      else
        break;
      pos = pos + 1;
    }
    if (pos === max)
      return this.doneFunc();
    if ('#\r\n'.indexOf(line.charAt(pos)) !== -1) {
      if (line.charAt(pos) === '#') {
        var comment_token = rstrip(line.substring(pos), '\r\n');
        var nl_pos = pos + comment_token.length;
        if (this.callback(Sk.Tokenizer.Tokens.T_COMMENT, comment_token, [
            this.lnum,
            pos
          ], [
            this.lnum,
            pos + comment_token.length
          ], line))
          return 'done';
        if (this.callback(Sk.Tokenizer.Tokens.T_NL, line.substring(nl_pos), [
            this.lnum,
            nl_pos
          ], [
            this.lnum,
            line.length
          ], line))
          return 'done';
        return false;
      } else {
        if (this.callback(Sk.Tokenizer.Tokens.T_NL, line.substring(pos), [
            this.lnum,
            pos
          ], [
            this.lnum,
            line.length
          ], line))
          return 'done';
        if (!this.interactive)
          return false;
      }
    }
    if (column > this.indents[this.indents.length - 1]) {
      this.indents.push(column);
      if (this.callback(Sk.Tokenizer.Tokens.T_INDENT, line.substring(0, pos), [
          this.lnum,
          0
        ], [
          this.lnum,
          pos
        ], line))
        return 'done';
    }
    while (column < this.indents[this.indents.length - 1]) {
      if (!contains(this.indents, column)) {
        throw new Sk.builtin.IndentationError('unindent does not match any outer indentation level', this.filename, this.lnum, pos, line);
      }
      this.indents.splice(this.indents.length - 1, 1);
      if (this.callback(Sk.Tokenizer.Tokens.T_DEDENT, '', [
          this.lnum,
          pos
        ], [
          this.lnum,
          pos
        ], line))
        return 'done';
    }
  } else {
    if (!line) {
      throw new Sk.builtin.TokenError('EOF in multi-line statement', this.filename, this.lnum, 0, line);
    }
    this.continued = false;
  }
  while (pos < max) {
    var capos = line.charAt(pos);
    while (capos === ' ' || capos === '\f' || capos === '\t') {
      pos += 1;
      capos = line.charAt(pos);
    }
    pseudoprog.lastIndex = 0;
    var pseudomatch = pseudoprog.exec(line.substring(pos));
    if (pseudomatch) {
      var start = pos;
      end = start + pseudomatch[1].length;
      var spos = [
          this.lnum,
          start
        ];
      var epos = [
          this.lnum,
          end
        ];
      pos = end;
      var token = line.substring(start, end);
      var initial = line.charAt(start);
      if (this.numchars.indexOf(initial) !== -1 || initial === '.' && token !== '.') {
        if (this.callback(Sk.Tokenizer.Tokens.T_NUMBER, token, spos, epos, line))
          return 'done';
      } else if (initial === '\r' || initial === '\n') {
        var newl = Sk.Tokenizer.Tokens.T_NEWLINE;
        if (this.parenlev > 0)
          newl = Sk.Tokenizer.Tokens.T_NL;
        if (this.callback(newl, token, spos, epos, line))
          return 'done';
      } else if (initial === '#') {
        if (this.callback(Sk.Tokenizer.Tokens.T_COMMENT, token, spos, epos, line))
          return 'done';
      } else if (triple_quoted.hasOwnProperty(token)) {
        this.endprog = endprogs[token];
        this.endprog.lastIndex = 0;
        endmatch = this.endprog.test(line.substring(pos));
        if (endmatch) {
          pos = this.endprog.lastIndex + pos;
          token = line.substring(start, pos);
          if (this.callback(Sk.Tokenizer.Tokens.T_STRING, token, spos, [
              this.lnum,
              pos
            ], line))
            return 'done';
        } else {
          this.strstart = [
            this.lnum,
            start
          ];
          this.contstr = line.substring(start);
          this.contline = line;
          return false;
        }
      } else if (single_quoted.hasOwnProperty(initial) || single_quoted.hasOwnProperty(token.substring(0, 2)) || single_quoted.hasOwnProperty(token.substring(0, 3))) {
        if (token[token.length - 1] === '\n') {
          this.strstart = [
            this.lnum,
            start
          ];
          this.endprog = endprogs[initial] || endprogs[token[1]] || endprogs[token[2]];
          this.contstr = line.substring(start);
          this.needcont = true;
          this.contline = line;
          return false;
        } else {
          if (this.callback(Sk.Tokenizer.Tokens.T_STRING, token, spos, epos, line))
            return 'done';
        }
      } else if (this.namechars.indexOf(initial) !== -1) {
        if (this.callback(Sk.Tokenizer.Tokens.T_NAME, token, spos, epos, line))
          return 'done';
      } else if (initial === '\\') {
        if (this.callback(Sk.Tokenizer.Tokens.T_NL, token, spos, [
            this.lnum,
            pos
          ], line))
          return 'done';
        this.continued = true;
      } else {
        if ('([{'.indexOf(initial) !== -1)
          this.parenlev += 1;
        else if (')]}'.indexOf(initial) !== -1)
          this.parenlev -= 1;
        if (this.callback(Sk.Tokenizer.Tokens.T_OP, token, spos, epos, line))
          return 'done';
      }
    } else {
      if (this.callback(Sk.Tokenizer.Tokens.T_ERRORTOKEN, line.charAt(pos), [
          this.lnum,
          pos
        ], [
          this.lnum,
          pos + 1
        ], line))
        return 'done';
      pos += 1;
    }
  }
  return false;
};
Sk.Tokenizer.tokenNames = {
  0: 'T_ENDMARKER',
  1: 'T_NAME',
  2: 'T_NUMBER',
  3: 'T_STRING',
  4: 'T_NEWLINE',
  5: 'T_INDENT',
  6: 'T_DEDENT',
  7: 'T_LPAR',
  8: 'T_RPAR',
  9: 'T_LSQB',
  10: 'T_RSQB',
  11: 'T_COLON',
  12: 'T_COMMA',
  13: 'T_SEMI',
  14: 'T_PLUS',
  15: 'T_MINUS',
  16: 'T_STAR',
  17: 'T_SLASH',
  18: 'T_VBAR',
  19: 'T_AMPER',
  20: 'T_LESS',
  21: 'T_GREATER',
  22: 'T_EQUAL',
  23: 'T_DOT',
  24: 'T_PERCENT',
  25: 'T_BACKQUOTE',
  26: 'T_LBRACE',
  27: 'T_RBRACE',
  28: 'T_EQEQUAL',
  29: 'T_NOTEQUAL',
  30: 'T_LESSEQUAL',
  31: 'T_GREATEREQUAL',
  32: 'T_TILDE',
  33: 'T_CIRCUMFLEX',
  34: 'T_LEFTSHIFT',
  35: 'T_RIGHTSHIFT',
  36: 'T_DOUBLESTAR',
  37: 'T_PLUSEQUAL',
  38: 'T_MINEQUAL',
  39: 'T_STAREQUAL',
  40: 'T_SLASHEQUAL',
  41: 'T_PERCENTEQUAL',
  42: 'T_AMPEREQUAL',
  43: 'T_VBAREQUAL',
  44: 'T_CIRCUMFLEXEQUAL',
  45: 'T_LEFTSHIFTEQUAL',
  46: 'T_RIGHTSHIFTEQUAL',
  47: 'T_DOUBLESTAREQUAL',
  48: 'T_DOUBLESLASH',
  49: 'T_DOUBLESLASHEQUAL',
  50: 'T_AT',
  51: 'T_OP',
  52: 'T_COMMENT',
  53: 'T_NL',
  54: 'T_RARROW',
  55: 'T_ERRORTOKEN',
  56: 'T_N_TOKENS',
  256: 'T_NT_OFFSET'
};
goog.exportSymbol('Sk.Tokenizer', Sk.Tokenizer);
goog.exportSymbol('Sk.Tokenizer.prototype.generateTokens', Sk.Tokenizer.prototype.generateTokens);
goog.exportSymbol('Sk.Tokenizer.tokenNames', Sk.Tokenizer.tokenNames);
Sk.OpMap = {
  '(': Sk.Tokenizer.Tokens.T_LPAR,
  ')': Sk.Tokenizer.Tokens.T_RPAR,
  '[': Sk.Tokenizer.Tokens.T_LSQB,
  ']': Sk.Tokenizer.Tokens.T_RSQB,
  ':': Sk.Tokenizer.Tokens.T_COLON,
  ',': Sk.Tokenizer.Tokens.T_COMMA,
  ';': Sk.Tokenizer.Tokens.T_SEMI,
  '+': Sk.Tokenizer.Tokens.T_PLUS,
  '-': Sk.Tokenizer.Tokens.T_MINUS,
  '*': Sk.Tokenizer.Tokens.T_STAR,
  '/': Sk.Tokenizer.Tokens.T_SLASH,
  '|': Sk.Tokenizer.Tokens.T_VBAR,
  '&': Sk.Tokenizer.Tokens.T_AMPER,
  '<': Sk.Tokenizer.Tokens.T_LESS,
  '>': Sk.Tokenizer.Tokens.T_GREATER,
  '=': Sk.Tokenizer.Tokens.T_EQUAL,
  '.': Sk.Tokenizer.Tokens.T_DOT,
  '%': Sk.Tokenizer.Tokens.T_PERCENT,
  '`': Sk.Tokenizer.Tokens.T_BACKQUOTE,
  '{': Sk.Tokenizer.Tokens.T_LBRACE,
  '}': Sk.Tokenizer.Tokens.T_RBRACE,
  '@': Sk.Tokenizer.Tokens.T_AT,
  '==': Sk.Tokenizer.Tokens.T_EQEQUAL,
  '!=': Sk.Tokenizer.Tokens.T_NOTEQUAL,
  '<>': Sk.Tokenizer.Tokens.T_NOTEQUAL,
  '<=': Sk.Tokenizer.Tokens.T_LESSEQUAL,
  '>=': Sk.Tokenizer.Tokens.T_GREATEREQUAL,
  '~': Sk.Tokenizer.Tokens.T_TILDE,
  '^': Sk.Tokenizer.Tokens.T_CIRCUMFLEX,
  '<<': Sk.Tokenizer.Tokens.T_LEFTSHIFT,
  '>>': Sk.Tokenizer.Tokens.T_RIGHTSHIFT,
  '**': Sk.Tokenizer.Tokens.T_DOUBLESTAR,
  '+=': Sk.Tokenizer.Tokens.T_PLUSEQUAL,
  '-=': Sk.Tokenizer.Tokens.T_MINEQUAL,
  '*=': Sk.Tokenizer.Tokens.T_STAREQUAL,
  '/=': Sk.Tokenizer.Tokens.T_SLASHEQUAL,
  '%=': Sk.Tokenizer.Tokens.T_PERCENTEQUAL,
  '&=': Sk.Tokenizer.Tokens.T_AMPEREQUAL,
  '|=': Sk.Tokenizer.Tokens.T_VBAREQUAL,
  '^=': Sk.Tokenizer.Tokens.T_CIRCUMFLEXEQUAL,
  '<<=': Sk.Tokenizer.Tokens.T_LEFTSHIFTEQUAL,
  '>>=': Sk.Tokenizer.Tokens.T_RIGHTSHIFTEQUAL,
  '**=': Sk.Tokenizer.Tokens.T_DOUBLESTAREQUAL,
  '//': Sk.Tokenizer.Tokens.T_DOUBLESLASH,
  '//=': Sk.Tokenizer.Tokens.T_DOUBLESLASHEQUAL,
  '->': Sk.Tokenizer.Tokens.T_RARROW
};
Sk.ParseTables = {
  sym: {
    and_expr: 257,
    and_test: 258,
    arglist: 259,
    argument: 260,
    arith_expr: 261,
    assert_stmt: 262,
    atom: 263,
    augassign: 264,
    break_stmt: 265,
    classdef: 266,
    comp_op: 267,
    comparison: 268,
    compound_stmt: 269,
    continue_stmt: 270,
    decorated: 271,
    decorator: 272,
    decorators: 273,
    del_stmt: 274,
    dictmaker: 275,
    dotted_as_name: 276,
    dotted_as_names: 277,
    dotted_name: 278,
    encoding_decl: 279,
    eval_input: 280,
    except_clause: 281,
    exec_stmt: 282,
    expr: 283,
    expr_stmt: 284,
    exprlist: 285,
    factor: 286,
    file_input: 287,
    flow_stmt: 288,
    for_stmt: 289,
    fpdef: 290,
    fplist: 291,
    funcdef: 292,
    gen_for: 293,
    gen_if: 294,
    gen_iter: 295,
    global_stmt: 296,
    if_stmt: 297,
    import_as_name: 298,
    import_as_names: 299,
    import_from: 300,
    import_name: 301,
    import_stmt: 302,
    lambdef: 303,
    list_for: 304,
    list_if: 305,
    list_iter: 306,
    listmaker: 307,
    not_test: 308,
    old_lambdef: 309,
    old_test: 310,
    or_test: 311,
    parameters: 312,
    pass_stmt: 313,
    power: 314,
    print_stmt: 315,
    raise_stmt: 316,
    return_stmt: 317,
    shift_expr: 318,
    simple_stmt: 319,
    single_input: 256,
    sliceop: 320,
    small_stmt: 321,
    stmt: 322,
    subscript: 323,
    subscriptlist: 324,
    suite: 325,
    term: 326,
    test: 327,
    testlist: 328,
    testlist1: 329,
    testlist_gexp: 330,
    testlist_safe: 331,
    trailer: 332,
    try_stmt: 333,
    varargslist: 334,
    while_stmt: 335,
    with_stmt: 336,
    with_var: 337,
    xor_expr: 338,
    yield_expr: 339,
    yield_stmt: 340
  },
  number2symbol: {
    256: 'single_input',
    257: 'and_expr',
    258: 'and_test',
    259: 'arglist',
    260: 'argument',
    261: 'arith_expr',
    262: 'assert_stmt',
    263: 'atom',
    264: 'augassign',
    265: 'break_stmt',
    266: 'classdef',
    267: 'comp_op',
    268: 'comparison',
    269: 'compound_stmt',
    270: 'continue_stmt',
    271: 'decorated',
    272: 'decorator',
    273: 'decorators',
    274: 'del_stmt',
    275: 'dictmaker',
    276: 'dotted_as_name',
    277: 'dotted_as_names',
    278: 'dotted_name',
    279: 'encoding_decl',
    280: 'eval_input',
    281: 'except_clause',
    282: 'exec_stmt',
    283: 'expr',
    284: 'expr_stmt',
    285: 'exprlist',
    286: 'factor',
    287: 'file_input',
    288: 'flow_stmt',
    289: 'for_stmt',
    290: 'fpdef',
    291: 'fplist',
    292: 'funcdef',
    293: 'gen_for',
    294: 'gen_if',
    295: 'gen_iter',
    296: 'global_stmt',
    297: 'if_stmt',
    298: 'import_as_name',
    299: 'import_as_names',
    300: 'import_from',
    301: 'import_name',
    302: 'import_stmt',
    303: 'lambdef',
    304: 'list_for',
    305: 'list_if',
    306: 'list_iter',
    307: 'listmaker',
    308: 'not_test',
    309: 'old_lambdef',
    310: 'old_test',
    311: 'or_test',
    312: 'parameters',
    313: 'pass_stmt',
    314: 'power',
    315: 'print_stmt',
    316: 'raise_stmt',
    317: 'return_stmt',
    318: 'shift_expr',
    319: 'simple_stmt',
    320: 'sliceop',
    321: 'small_stmt',
    322: 'stmt',
    323: 'subscript',
    324: 'subscriptlist',
    325: 'suite',
    326: 'term',
    327: 'test',
    328: 'testlist',
    329: 'testlist1',
    330: 'testlist_gexp',
    331: 'testlist_safe',
    332: 'trailer',
    333: 'try_stmt',
    334: 'varargslist',
    335: 'while_stmt',
    336: 'with_stmt',
    337: 'with_var',
    338: 'xor_expr',
    339: 'yield_expr',
    340: 'yield_stmt'
  },
  dfas: {
    256: [
      [
        [
          [
            1,
            1
          ],
          [
            2,
            1
          ],
          [
            3,
            2
          ]
        ],
        [[
            0,
            1
          ]],
        [[
            2,
            1
          ]]
      ],
      {
        2: 1,
        4: 1,
        5: 1,
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        10: 1,
        11: 1,
        12: 1,
        13: 1,
        14: 1,
        15: 1,
        16: 1,
        17: 1,
        18: 1,
        19: 1,
        20: 1,
        21: 1,
        22: 1,
        23: 1,
        24: 1,
        25: 1,
        26: 1,
        27: 1,
        28: 1,
        29: 1,
        30: 1,
        31: 1,
        32: 1,
        33: 1,
        34: 1,
        35: 1,
        36: 1
      }
    ],
    257: [
      [
        [[
            37,
            1
          ]],
        [
          [
            38,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      {
        6: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1
      }
    ],
    258: [
      [
        [[
            39,
            1
          ]],
        [
          [
            40,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      {
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1
      }
    ],
    259: [
      [
        [
          [
            41,
            1
          ],
          [
            42,
            2
          ],
          [
            43,
            3
          ]
        ],
        [[
            44,
            4
          ]],
        [
          [
            45,
            5
          ],
          [
            0,
            2
          ]
        ],
        [[
            44,
            6
          ]],
        [
          [
            45,
            7
          ],
          [
            0,
            4
          ]
        ],
        [
          [
            41,
            1
          ],
          [
            42,
            2
          ],
          [
            43,
            3
          ],
          [
            0,
            5
          ]
        ],
        [[
            0,
            6
          ]],
        [
          [
            42,
            4
          ],
          [
            43,
            3
          ]
        ]
      ],
      {
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1,
        36: 1,
        41: 1,
        43: 1
      }
    ],
    260: [
      [
        [[
            44,
            1
          ]],
        [
          [
            46,
            2
          ],
          [
            47,
            3
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]],
        [[
            44,
            2
          ]]
      ],
      {
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1,
        36: 1
      }
    ],
    261: [
      [
        [[
            48,
            1
          ]],
        [
          [
            24,
            0
          ],
          [
            35,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      {
        6: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1
      }
    ],
    262: [
      [
        [[
            19,
            1
          ]],
        [[
            44,
            2
          ]],
        [
          [
            45,
            3
          ],
          [
            0,
            2
          ]
        ],
        [[
            44,
            4
          ]],
        [[
            0,
            4
          ]]
      ],
      { 19: 1 }
    ],
    263: [
      [
        [
          [
            17,
            1
          ],
          [
            8,
            2
          ],
          [
            9,
            5
          ],
          [
            28,
            4
          ],
          [
            11,
            3
          ],
          [
            13,
            6
          ],
          [
            20,
            2
          ]
        ],
        [
          [
            17,
            1
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]],
        [
          [
            49,
            7
          ],
          [
            50,
            2
          ]
        ],
        [
          [
            51,
            2
          ],
          [
            52,
            8
          ],
          [
            53,
            8
          ]
        ],
        [
          [
            54,
            9
          ],
          [
            55,
            2
          ]
        ],
        [[
            56,
            10
          ]],
        [[
            50,
            2
          ]],
        [[
            51,
            2
          ]],
        [[
            55,
            2
          ]],
        [[
            13,
            2
          ]]
      ],
      {
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        28: 1
      }
    ],
    264: [
      [
        [
          [
            57,
            1
          ],
          [
            58,
            1
          ],
          [
            59,
            1
          ],
          [
            60,
            1
          ],
          [
            61,
            1
          ],
          [
            62,
            1
          ],
          [
            63,
            1
          ],
          [
            64,
            1
          ],
          [
            65,
            1
          ],
          [
            66,
            1
          ],
          [
            67,
            1
          ],
          [
            68,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      {
        57: 1,
        58: 1,
        59: 1,
        60: 1,
        61: 1,
        62: 1,
        63: 1,
        64: 1,
        65: 1,
        66: 1,
        67: 1,
        68: 1
      }
    ],
    265: [
      [
        [[
            31,
            1
          ]],
        [[
            0,
            1
          ]]
      ],
      { 31: 1 }
    ],
    266: [
      [
        [[
            10,
            1
          ]],
        [[
            20,
            2
          ]],
        [
          [
            69,
            3
          ],
          [
            28,
            4
          ]
        ],
        [[
            70,
            5
          ]],
        [
          [
            51,
            6
          ],
          [
            71,
            7
          ]
        ],
        [[
            0,
            5
          ]],
        [[
            69,
            3
          ]],
        [[
            51,
            6
          ]]
      ],
      { 10: 1 }
    ],
    267: [
      [
        [
          [
            72,
            1
          ],
          [
            73,
            1
          ],
          [
            7,
            2
          ],
          [
            74,
            1
          ],
          [
            72,
            1
          ],
          [
            75,
            1
          ],
          [
            76,
            1
          ],
          [
            77,
            3
          ],
          [
            78,
            1
          ],
          [
            79,
            1
          ]
        ],
        [[
            0,
            1
          ]],
        [[
            75,
            1
          ]],
        [
          [
            7,
            1
          ],
          [
            0,
            3
          ]
        ]
      ],
      {
        7: 1,
        72: 1,
        73: 1,
        74: 1,
        75: 1,
        76: 1,
        77: 1,
        78: 1,
        79: 1
      }
    ],
    268: [
      [
        [[
            80,
            1
          ]],
        [
          [
            81,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      {
        6: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1
      }
    ],
    269: [
      [
        [
          [
            82,
            1
          ],
          [
            83,
            1
          ],
          [
            84,
            1
          ],
          [
            85,
            1
          ],
          [
            86,
            1
          ],
          [
            87,
            1
          ],
          [
            88,
            1
          ],
          [
            89,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      {
        4: 1,
        10: 1,
        14: 1,
        16: 1,
        27: 1,
        30: 1,
        33: 1,
        34: 1
      }
    ],
    270: [
      [
        [[
            32,
            1
          ]],
        [[
            0,
            1
          ]]
      ],
      { 32: 1 }
    ],
    271: [
      [
        [[
            90,
            1
          ]],
        [
          [
            88,
            2
          ],
          [
            85,
            2
          ]
        ],
        [[
            0,
            2
          ]]
      ],
      { 33: 1 }
    ],
    272: [
      [
        [[
            33,
            1
          ]],
        [[
            91,
            2
          ]],
        [
          [
            28,
            4
          ],
          [
            2,
            3
          ]
        ],
        [[
            0,
            3
          ]],
        [
          [
            51,
            5
          ],
          [
            92,
            6
          ]
        ],
        [[
            2,
            3
          ]],
        [[
            51,
            5
          ]]
      ],
      { 33: 1 }
    ],
    273: [
      [
        [[
            93,
            1
          ]],
        [
          [
            93,
            1
          ],
          [
            0,
            1
          ]
        ]
      ],
      { 33: 1 }
    ],
    274: [
      [
        [[
            21,
            1
          ]],
        [[
            94,
            2
          ]],
        [[
            0,
            2
          ]]
      ],
      { 21: 1 }
    ],
    275: [
      [
        [[
            44,
            1
          ]],
        [[
            69,
            2
          ]],
        [[
            44,
            3
          ]],
        [
          [
            45,
            4
          ],
          [
            0,
            3
          ]
        ],
        [
          [
            44,
            1
          ],
          [
            0,
            4
          ]
        ]
      ],
      {
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1,
        36: 1
      }
    ],
    276: [
      [
        [[
            91,
            1
          ]],
        [
          [
            95,
            2
          ],
          [
            0,
            1
          ]
        ],
        [[
            20,
            3
          ]],
        [[
            0,
            3
          ]]
      ],
      { 20: 1 }
    ],
    277: [
      [
        [[
            96,
            1
          ]],
        [
          [
            45,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      { 20: 1 }
    ],
    278: [
      [
        [[
            20,
            1
          ]],
        [
          [
            97,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      { 20: 1 }
    ],
    279: [
      [
        [[
            20,
            1
          ]],
        [[
            0,
            1
          ]]
      ],
      { 20: 1 }
    ],
    280: [
      [
        [[
            71,
            1
          ]],
        [
          [
            2,
            1
          ],
          [
            98,
            2
          ]
        ],
        [[
            0,
            2
          ]]
      ],
      {
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1,
        36: 1
      }
    ],
    281: [
      [
        [[
            99,
            1
          ]],
        [
          [
            44,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            95,
            3
          ],
          [
            45,
            3
          ],
          [
            0,
            2
          ]
        ],
        [[
            44,
            4
          ]],
        [[
            0,
            4
          ]]
      ],
      { 99: 1 }
    ],
    282: [
      [
        [[
            15,
            1
          ]],
        [[
            80,
            2
          ]],
        [
          [
            75,
            3
          ],
          [
            0,
            2
          ]
        ],
        [[
            44,
            4
          ]],
        [
          [
            45,
            5
          ],
          [
            0,
            4
          ]
        ],
        [[
            44,
            6
          ]],
        [[
            0,
            6
          ]]
      ],
      { 15: 1 }
    ],
    283: [
      [
        [[
            100,
            1
          ]],
        [
          [
            101,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      {
        6: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1
      }
    ],
    284: [
      [
        [[
            71,
            1
          ]],
        [
          [
            102,
            2
          ],
          [
            47,
            3
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            71,
            4
          ],
          [
            53,
            4
          ]
        ],
        [
          [
            71,
            5
          ],
          [
            53,
            5
          ]
        ],
        [[
            0,
            4
          ]],
        [
          [
            47,
            3
          ],
          [
            0,
            5
          ]
        ]
      ],
      {
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1,
        36: 1
      }
    ],
    285: [
      [
        [[
            80,
            1
          ]],
        [
          [
            45,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            80,
            1
          ],
          [
            0,
            2
          ]
        ]
      ],
      {
        6: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1
      }
    ],
    286: [
      [
        [
          [
            103,
            2
          ],
          [
            24,
            1
          ],
          [
            6,
            1
          ],
          [
            35,
            1
          ]
        ],
        [[
            104,
            2
          ]],
        [[
            0,
            2
          ]]
      ],
      {
        6: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1
      }
    ],
    287: [
      [
        [
          [
            2,
            0
          ],
          [
            98,
            1
          ],
          [
            105,
            0
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      {
        2: 1,
        4: 1,
        5: 1,
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        10: 1,
        11: 1,
        12: 1,
        13: 1,
        14: 1,
        15: 1,
        16: 1,
        17: 1,
        18: 1,
        19: 1,
        20: 1,
        21: 1,
        22: 1,
        23: 1,
        24: 1,
        25: 1,
        26: 1,
        27: 1,
        28: 1,
        29: 1,
        30: 1,
        31: 1,
        32: 1,
        33: 1,
        34: 1,
        35: 1,
        36: 1,
        98: 1
      }
    ],
    288: [
      [
        [
          [
            106,
            1
          ],
          [
            107,
            1
          ],
          [
            108,
            1
          ],
          [
            109,
            1
          ],
          [
            110,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      {
        5: 1,
        18: 1,
        25: 1,
        31: 1,
        32: 1
      }
    ],
    289: [
      [
        [[
            27,
            1
          ]],
        [[
            94,
            2
          ]],
        [[
            75,
            3
          ]],
        [[
            71,
            4
          ]],
        [[
            69,
            5
          ]],
        [[
            70,
            6
          ]],
        [
          [
            111,
            7
          ],
          [
            0,
            6
          ]
        ],
        [[
            69,
            8
          ]],
        [[
            70,
            9
          ]],
        [[
            0,
            9
          ]]
      ],
      { 27: 1 }
    ],
    290: [
      [
        [
          [
            28,
            1
          ],
          [
            20,
            2
          ]
        ],
        [[
            112,
            3
          ]],
        [[
            0,
            2
          ]],
        [[
            51,
            2
          ]]
      ],
      {
        20: 1,
        28: 1
      }
    ],
    291: [
      [
        [[
            113,
            1
          ]],
        [
          [
            45,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            113,
            1
          ],
          [
            0,
            2
          ]
        ]
      ],
      {
        20: 1,
        28: 1
      }
    ],
    292: [
      [
        [[
            4,
            1
          ]],
        [[
            20,
            2
          ]],
        [[
            114,
            3
          ]],
        [[
            69,
            4
          ]],
        [[
            70,
            5
          ]],
        [[
            0,
            5
          ]]
      ],
      { 4: 1 }
    ],
    293: [
      [
        [[
            27,
            1
          ]],
        [[
            94,
            2
          ]],
        [[
            75,
            3
          ]],
        [[
            115,
            4
          ]],
        [
          [
            116,
            5
          ],
          [
            0,
            4
          ]
        ],
        [[
            0,
            5
          ]]
      ],
      { 27: 1 }
    ],
    294: [
      [
        [[
            30,
            1
          ]],
        [[
            117,
            2
          ]],
        [
          [
            116,
            3
          ],
          [
            0,
            2
          ]
        ],
        [[
            0,
            3
          ]]
      ],
      { 30: 1 }
    ],
    295: [
      [
        [
          [
            46,
            1
          ],
          [
            118,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      {
        27: 1,
        30: 1
      }
    ],
    296: [
      [
        [[
            26,
            1
          ]],
        [[
            20,
            2
          ]],
        [
          [
            45,
            1
          ],
          [
            0,
            2
          ]
        ]
      ],
      { 26: 1 }
    ],
    297: [
      [
        [[
            30,
            1
          ]],
        [[
            44,
            2
          ]],
        [[
            69,
            3
          ]],
        [[
            70,
            4
          ]],
        [
          [
            111,
            5
          ],
          [
            119,
            1
          ],
          [
            0,
            4
          ]
        ],
        [[
            69,
            6
          ]],
        [[
            70,
            7
          ]],
        [[
            0,
            7
          ]]
      ],
      { 30: 1 }
    ],
    298: [
      [
        [[
            20,
            1
          ]],
        [
          [
            95,
            2
          ],
          [
            0,
            1
          ]
        ],
        [[
            20,
            3
          ]],
        [[
            0,
            3
          ]]
      ],
      { 20: 1 }
    ],
    299: [
      [
        [[
            120,
            1
          ]],
        [
          [
            45,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            120,
            1
          ],
          [
            0,
            2
          ]
        ]
      ],
      { 20: 1 }
    ],
    300: [
      [
        [[
            29,
            1
          ]],
        [
          [
            91,
            2
          ],
          [
            97,
            3
          ]
        ],
        [[
            23,
            4
          ]],
        [
          [
            91,
            2
          ],
          [
            23,
            4
          ],
          [
            97,
            3
          ]
        ],
        [
          [
            121,
            5
          ],
          [
            41,
            5
          ],
          [
            28,
            6
          ]
        ],
        [[
            0,
            5
          ]],
        [[
            121,
            7
          ]],
        [[
            51,
            5
          ]]
      ],
      { 29: 1 }
    ],
    301: [
      [
        [[
            23,
            1
          ]],
        [[
            122,
            2
          ]],
        [[
            0,
            2
          ]]
      ],
      { 23: 1 }
    ],
    302: [
      [
        [
          [
            123,
            1
          ],
          [
            124,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      {
        23: 1,
        29: 1
      }
    ],
    303: [
      [
        [[
            36,
            1
          ]],
        [
          [
            69,
            2
          ],
          [
            125,
            3
          ]
        ],
        [[
            44,
            4
          ]],
        [[
            69,
            2
          ]],
        [[
            0,
            4
          ]]
      ],
      { 36: 1 }
    ],
    304: [
      [
        [[
            27,
            1
          ]],
        [[
            94,
            2
          ]],
        [[
            75,
            3
          ]],
        [[
            126,
            4
          ]],
        [
          [
            127,
            5
          ],
          [
            0,
            4
          ]
        ],
        [[
            0,
            5
          ]]
      ],
      { 27: 1 }
    ],
    305: [
      [
        [[
            30,
            1
          ]],
        [[
            117,
            2
          ]],
        [
          [
            127,
            3
          ],
          [
            0,
            2
          ]
        ],
        [[
            0,
            3
          ]]
      ],
      { 30: 1 }
    ],
    306: [
      [
        [
          [
            128,
            1
          ],
          [
            129,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      {
        27: 1,
        30: 1
      }
    ],
    307: [
      [
        [[
            44,
            1
          ]],
        [
          [
            128,
            2
          ],
          [
            45,
            3
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]],
        [
          [
            44,
            4
          ],
          [
            0,
            3
          ]
        ],
        [
          [
            45,
            3
          ],
          [
            0,
            4
          ]
        ]
      ],
      {
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1,
        36: 1
      }
    ],
    308: [
      [
        [
          [
            7,
            1
          ],
          [
            130,
            2
          ]
        ],
        [[
            39,
            2
          ]],
        [[
            0,
            2
          ]]
      ],
      {
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1
      }
    ],
    309: [
      [
        [[
            36,
            1
          ]],
        [
          [
            69,
            2
          ],
          [
            125,
            3
          ]
        ],
        [[
            117,
            4
          ]],
        [[
            69,
            2
          ]],
        [[
            0,
            4
          ]]
      ],
      { 36: 1 }
    ],
    310: [
      [
        [
          [
            131,
            1
          ],
          [
            115,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      {
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1,
        36: 1
      }
    ],
    311: [
      [
        [[
            132,
            1
          ]],
        [
          [
            133,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      {
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1
      }
    ],
    312: [
      [
        [[
            28,
            1
          ]],
        [
          [
            51,
            2
          ],
          [
            125,
            3
          ]
        ],
        [[
            0,
            2
          ]],
        [[
            51,
            2
          ]]
      ],
      { 28: 1 }
    ],
    313: [
      [
        [[
            22,
            1
          ]],
        [[
            0,
            1
          ]]
      ],
      { 22: 1 }
    ],
    314: [
      [
        [[
            134,
            1
          ]],
        [
          [
            135,
            1
          ],
          [
            43,
            2
          ],
          [
            0,
            1
          ]
        ],
        [[
            104,
            3
          ]],
        [[
            0,
            3
          ]]
      ],
      {
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        28: 1
      }
    ],
    315: [
      [
        [[
            12,
            1
          ]],
        [
          [
            44,
            2
          ],
          [
            136,
            3
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            45,
            4
          ],
          [
            0,
            2
          ]
        ],
        [[
            44,
            5
          ]],
        [
          [
            44,
            2
          ],
          [
            0,
            4
          ]
        ],
        [
          [
            45,
            6
          ],
          [
            0,
            5
          ]
        ],
        [[
            44,
            7
          ]],
        [
          [
            45,
            8
          ],
          [
            0,
            7
          ]
        ],
        [
          [
            44,
            7
          ],
          [
            0,
            8
          ]
        ]
      ],
      { 12: 1 }
    ],
    316: [
      [
        [[
            5,
            1
          ]],
        [
          [
            44,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            45,
            3
          ],
          [
            0,
            2
          ]
        ],
        [[
            44,
            4
          ]],
        [
          [
            45,
            5
          ],
          [
            0,
            4
          ]
        ],
        [[
            44,
            6
          ]],
        [[
            0,
            6
          ]]
      ],
      { 5: 1 }
    ],
    317: [
      [
        [[
            18,
            1
          ]],
        [
          [
            71,
            2
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]]
      ],
      { 18: 1 }
    ],
    318: [
      [
        [[
            137,
            1
          ]],
        [
          [
            136,
            0
          ],
          [
            138,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      {
        6: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1
      }
    ],
    319: [
      [
        [[
            139,
            1
          ]],
        [
          [
            2,
            2
          ],
          [
            140,
            3
          ]
        ],
        [[
            0,
            2
          ]],
        [
          [
            139,
            1
          ],
          [
            2,
            2
          ]
        ]
      ],
      {
        5: 1,
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        12: 1,
        13: 1,
        15: 1,
        17: 1,
        18: 1,
        19: 1,
        20: 1,
        21: 1,
        22: 1,
        23: 1,
        24: 1,
        25: 1,
        26: 1,
        28: 1,
        29: 1,
        31: 1,
        32: 1,
        35: 1,
        36: 1
      }
    ],
    320: [
      [
        [[
            69,
            1
          ]],
        [
          [
            44,
            2
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]]
      ],
      { 69: 1 }
    ],
    321: [
      [
        [
          [
            141,
            1
          ],
          [
            142,
            1
          ],
          [
            143,
            1
          ],
          [
            144,
            1
          ],
          [
            145,
            1
          ],
          [
            146,
            1
          ],
          [
            147,
            1
          ],
          [
            148,
            1
          ],
          [
            149,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      {
        5: 1,
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        12: 1,
        13: 1,
        15: 1,
        17: 1,
        18: 1,
        19: 1,
        20: 1,
        21: 1,
        22: 1,
        23: 1,
        24: 1,
        25: 1,
        26: 1,
        28: 1,
        29: 1,
        31: 1,
        32: 1,
        35: 1,
        36: 1
      }
    ],
    322: [
      [
        [
          [
            1,
            1
          ],
          [
            3,
            1
          ]
        ],
        [[
            0,
            1
          ]]
      ],
      {
        4: 1,
        5: 1,
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        10: 1,
        11: 1,
        12: 1,
        13: 1,
        14: 1,
        15: 1,
        16: 1,
        17: 1,
        18: 1,
        19: 1,
        20: 1,
        21: 1,
        22: 1,
        23: 1,
        24: 1,
        25: 1,
        26: 1,
        27: 1,
        28: 1,
        29: 1,
        30: 1,
        31: 1,
        32: 1,
        33: 1,
        34: 1,
        35: 1,
        36: 1
      }
    ],
    323: [
      [
        [
          [
            44,
            1
          ],
          [
            69,
            2
          ],
          [
            97,
            3
          ]
        ],
        [
          [
            69,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            44,
            4
          ],
          [
            150,
            5
          ],
          [
            0,
            2
          ]
        ],
        [[
            97,
            6
          ]],
        [
          [
            150,
            5
          ],
          [
            0,
            4
          ]
        ],
        [[
            0,
            5
          ]],
        [[
            97,
            5
          ]]
      ],
      {
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1,
        36: 1,
        69: 1,
        97: 1
      }
    ],
    324: [
      [
        [[
            151,
            1
          ]],
        [
          [
            45,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            151,
            1
          ],
          [
            0,
            2
          ]
        ]
      ],
      {
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1,
        36: 1,
        69: 1,
        97: 1
      }
    ],
    325: [
      [
        [
          [
            1,
            1
          ],
          [
            2,
            2
          ]
        ],
        [[
            0,
            1
          ]],
        [[
            152,
            3
          ]],
        [[
            105,
            4
          ]],
        [
          [
            153,
            1
          ],
          [
            105,
            4
          ]
        ]
      ],
      {
        2: 1,
        5: 1,
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        12: 1,
        13: 1,
        15: 1,
        17: 1,
        18: 1,
        19: 1,
        20: 1,
        21: 1,
        22: 1,
        23: 1,
        24: 1,
        25: 1,
        26: 1,
        28: 1,
        29: 1,
        31: 1,
        32: 1,
        35: 1,
        36: 1
      }
    ],
    326: [
      [
        [[
            104,
            1
          ]],
        [
          [
            154,
            0
          ],
          [
            41,
            0
          ],
          [
            155,
            0
          ],
          [
            156,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      {
        6: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1
      }
    ],
    327: [
      [
        [
          [
            115,
            1
          ],
          [
            157,
            2
          ]
        ],
        [
          [
            30,
            3
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]],
        [[
            115,
            4
          ]],
        [[
            111,
            5
          ]],
        [[
            44,
            2
          ]]
      ],
      {
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1,
        36: 1
      }
    ],
    328: [
      [
        [[
            44,
            1
          ]],
        [
          [
            45,
            2
          ],
          [
            0,
            1
          ]
        ],
        [
          [
            44,
            1
          ],
          [
            0,
            2
          ]
        ]
      ],
      {
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1,
        36: 1
      }
    ],
    329: [
      [
        [[
            44,
            1
          ]],
        [
          [
            45,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      {
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1,
        36: 1
      }
    ],
    330: [
      [
        [[
            44,
            1
          ]],
        [
          [
            46,
            2
          ],
          [
            45,
            3
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]],
        [
          [
            44,
            4
          ],
          [
            0,
            3
          ]
        ],
        [
          [
            45,
            3
          ],
          [
            0,
            4
          ]
        ]
      ],
      {
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1,
        36: 1
      }
    ],
    331: [
      [
        [[
            117,
            1
          ]],
        [
          [
            45,
            2
          ],
          [
            0,
            1
          ]
        ],
        [[
            117,
            3
          ]],
        [
          [
            45,
            4
          ],
          [
            0,
            3
          ]
        ],
        [
          [
            117,
            3
          ],
          [
            0,
            4
          ]
        ]
      ],
      {
        6: 1,
        7: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1,
        36: 1
      }
    ],
    332: [
      [
        [
          [
            28,
            1
          ],
          [
            97,
            2
          ],
          [
            11,
            3
          ]
        ],
        [
          [
            51,
            4
          ],
          [
            92,
            5
          ]
        ],
        [[
            20,
            4
          ]],
        [[
            158,
            6
          ]],
        [[
            0,
            4
          ]],
        [[
            51,
            4
          ]],
        [[
            50,
            4
          ]]
      ],
      {
        11: 1,
        28: 1,
        97: 1
      }
    ],
    333: [
      [
        [[
            14,
            1
          ]],
        [[
            69,
            2
          ]],
        [[
            70,
            3
          ]],
        [
          [
            159,
            4
          ],
          [
            160,
            5
          ]
        ],
        [[
            69,
            6
          ]],
        [[
            69,
            7
          ]],
        [[
            70,
            8
          ]],
        [[
            70,
            9
          ]],
        [
          [
            159,
            4
          ],
          [
            111,
            10
          ],
          [
            160,
            5
          ],
          [
            0,
            8
          ]
        ],
        [[
            0,
            9
          ]],
        [[
            69,
            11
          ]],
        [[
            70,
            12
          ]],
        [
          [
            160,
            5
          ],
          [
            0,
            12
          ]
        ]
      ],
      { 14: 1 }
    ],
    334: [
      [
        [
          [
            41,
            1
          ],
          [
            113,
            2
          ],
          [
            43,
            3
          ]
        ],
        [[
            20,
            4
          ]],
        [
          [
            47,
            5
          ],
          [
            45,
            6
          ],
          [
            0,
            2
          ]
        ],
        [[
            20,
            7
          ]],
        [
          [
            45,
            8
          ],
          [
            0,
            4
          ]
        ],
        [[
            44,
            9
          ]],
        [
          [
            41,
            1
          ],
          [
            113,
            2
          ],
          [
            43,
            3
          ],
          [
            0,
            6
          ]
        ],
        [[
            0,
            7
          ]],
        [[
            43,
            3
          ]],
        [
          [
            45,
            6
          ],
          [
            0,
            9
          ]
        ]
      ],
      {
        20: 1,
        28: 1,
        41: 1,
        43: 1
      }
    ],
    335: [
      [
        [[
            16,
            1
          ]],
        [[
            44,
            2
          ]],
        [[
            69,
            3
          ]],
        [[
            70,
            4
          ]],
        [
          [
            111,
            5
          ],
          [
            0,
            4
          ]
        ],
        [[
            69,
            6
          ]],
        [[
            70,
            7
          ]],
        [[
            0,
            7
          ]]
      ],
      { 16: 1 }
    ],
    336: [
      [
        [[
            34,
            1
          ]],
        [[
            44,
            2
          ]],
        [
          [
            69,
            3
          ],
          [
            161,
            4
          ]
        ],
        [[
            70,
            5
          ]],
        [[
            69,
            3
          ]],
        [[
            0,
            5
          ]]
      ],
      { 34: 1 }
    ],
    337: [
      [
        [[
            95,
            1
          ]],
        [[
            80,
            2
          ]],
        [[
            0,
            2
          ]]
      ],
      { 95: 1 }
    ],
    338: [
      [
        [[
            162,
            1
          ]],
        [
          [
            163,
            0
          ],
          [
            0,
            1
          ]
        ]
      ],
      {
        6: 1,
        8: 1,
        9: 1,
        11: 1,
        13: 1,
        17: 1,
        20: 1,
        24: 1,
        28: 1,
        35: 1
      }
    ],
    339: [
      [
        [[
            25,
            1
          ]],
        [
          [
            71,
            2
          ],
          [
            0,
            1
          ]
        ],
        [[
            0,
            2
          ]]
      ],
      { 25: 1 }
    ],
    340: [
      [
        [[
            53,
            1
          ]],
        [[
            0,
            1
          ]]
      ],
      { 25: 1 }
    ]
  },
  states: [
    [
      [
        [
          1,
          1
        ],
        [
          2,
          1
        ],
        [
          3,
          2
        ]
      ],
      [[
          0,
          1
        ]],
      [[
          2,
          1
        ]]
    ],
    [
      [[
          37,
          1
        ]],
      [
        [
          38,
          0
        ],
        [
          0,
          1
        ]
      ]
    ],
    [
      [[
          39,
          1
        ]],
      [
        [
          40,
          0
        ],
        [
          0,
          1
        ]
      ]
    ],
    [
      [
        [
          41,
          1
        ],
        [
          42,
          2
        ],
        [
          43,
          3
        ]
      ],
      [[
          44,
          4
        ]],
      [
        [
          45,
          5
        ],
        [
          0,
          2
        ]
      ],
      [[
          44,
          6
        ]],
      [
        [
          45,
          7
        ],
        [
          0,
          4
        ]
      ],
      [
        [
          41,
          1
        ],
        [
          42,
          2
        ],
        [
          43,
          3
        ],
        [
          0,
          5
        ]
      ],
      [[
          0,
          6
        ]],
      [
        [
          42,
          4
        ],
        [
          43,
          3
        ]
      ]
    ],
    [
      [[
          44,
          1
        ]],
      [
        [
          46,
          2
        ],
        [
          47,
          3
        ],
        [
          0,
          1
        ]
      ],
      [[
          0,
          2
        ]],
      [[
          44,
          2
        ]]
    ],
    [
      [[
          48,
          1
        ]],
      [
        [
          24,
          0
        ],
        [
          35,
          0
        ],
        [
          0,
          1
        ]
      ]
    ],
    [
      [[
          19,
          1
        ]],
      [[
          44,
          2
        ]],
      [
        [
          45,
          3
        ],
        [
          0,
          2
        ]
      ],
      [[
          44,
          4
        ]],
      [[
          0,
          4
        ]]
    ],
    [
      [
        [
          17,
          1
        ],
        [
          8,
          2
        ],
        [
          9,
          5
        ],
        [
          28,
          4
        ],
        [
          11,
          3
        ],
        [
          13,
          6
        ],
        [
          20,
          2
        ]
      ],
      [
        [
          17,
          1
        ],
        [
          0,
          1
        ]
      ],
      [[
          0,
          2
        ]],
      [
        [
          49,
          7
        ],
        [
          50,
          2
        ]
      ],
      [
        [
          51,
          2
        ],
        [
          52,
          8
        ],
        [
          53,
          8
        ]
      ],
      [
        [
          54,
          9
        ],
        [
          55,
          2
        ]
      ],
      [[
          56,
          10
        ]],
      [[
          50,
          2
        ]],
      [[
          51,
          2
        ]],
      [[
          55,
          2
        ]],
      [[
          13,
          2
        ]]
    ],
    [
      [
        [
          57,
          1
        ],
        [
          58,
          1
        ],
        [
          59,
          1
        ],
        [
          60,
          1
        ],
        [
          61,
          1
        ],
        [
          62,
          1
        ],
        [
          63,
          1
        ],
        [
          64,
          1
        ],
        [
          65,
          1
        ],
        [
          66,
          1
        ],
        [
          67,
          1
        ],
        [
          68,
          1
        ]
      ],
      [[
          0,
          1
        ]]
    ],
    [
      [[
          31,
          1
        ]],
      [[
          0,
          1
        ]]
    ],
    [
      [[
          10,
          1
        ]],
      [[
          20,
          2
        ]],
      [
        [
          69,
          3
        ],
        [
          28,
          4
        ]
      ],
      [[
          70,
          5
        ]],
      [
        [
          51,
          6
        ],
        [
          71,
          7
        ]
      ],
      [[
          0,
          5
        ]],
      [[
          69,
          3
        ]],
      [[
          51,
          6
        ]]
    ],
    [
      [
        [
          72,
          1
        ],
        [
          73,
          1
        ],
        [
          7,
          2
        ],
        [
          74,
          1
        ],
        [
          72,
          1
        ],
        [
          75,
          1
        ],
        [
          76,
          1
        ],
        [
          77,
          3
        ],
        [
          78,
          1
        ],
        [
          79,
          1
        ]
      ],
      [[
          0,
          1
        ]],
      [[
          75,
          1
        ]],
      [
        [
          7,
          1
        ],
        [
          0,
          3
        ]
      ]
    ],
    [
      [[
          80,
          1
        ]],
      [
        [
          81,
          0
        ],
        [
          0,
          1
        ]
      ]
    ],
    [
      [
        [
          82,
          1
        ],
        [
          83,
          1
        ],
        [
          84,
          1
        ],
        [
          85,
          1
        ],
        [
          86,
          1
        ],
        [
          87,
          1
        ],
        [
          88,
          1
        ],
        [
          89,
          1
        ]
      ],
      [[
          0,
          1
        ]]
    ],
    [
      [[
          32,
          1
        ]],
      [[
          0,
          1
        ]]
    ],
    [
      [[
          90,
          1
        ]],
      [
        [
          88,
          2
        ],
        [
          85,
          2
        ]
      ],
      [[
          0,
          2
        ]]
    ],
    [
      [[
          33,
          1
        ]],
      [[
          91,
          2
        ]],
      [
        [
          28,
          4
        ],
        [
          2,
          3
        ]
      ],
      [[
          0,
          3
        ]],
      [
        [
          51,
          5
        ],
        [
          92,
          6
        ]
      ],
      [[
          2,
          3
        ]],
      [[
          51,
          5
        ]]
    ],
    [
      [[
          93,
          1
        ]],
      [
        [
          93,
          1
        ],
        [
          0,
          1
        ]
      ]
    ],
    [
      [[
          21,
          1
        ]],
      [[
          94,
          2
        ]],
      [[
          0,
          2
        ]]
    ],
    [
      [[
          44,
          1
        ]],
      [[
          69,
          2
        ]],
      [[
          44,
          3
        ]],
      [
        [
          45,
          4
        ],
        [
          0,
          3
        ]
      ],
      [
        [
          44,
          1
        ],
        [
          0,
          4
        ]
      ]
    ],
    [
      [[
          91,
          1
        ]],
      [
        [
          95,
          2
        ],
        [
          0,
          1
        ]
      ],
      [[
          20,
          3
        ]],
      [[
          0,
          3
        ]]
    ],
    [
      [[
          96,
          1
        ]],
      [
        [
          45,
          0
        ],
        [
          0,
          1
        ]
      ]
    ],
    [
      [[
          20,
          1
        ]],
      [
        [
          97,
          0
        ],
        [
          0,
          1
        ]
      ]
    ],
    [
      [[
          20,
          1
        ]],
      [[
          0,
          1
        ]]
    ],
    [
      [[
          71,
          1
        ]],
      [
        [
          2,
          1
        ],
        [
          98,
          2
        ]
      ],
      [[
          0,
          2
        ]]
    ],
    [
      [[
          99,
          1
        ]],
      [
        [
          44,
          2
        ],
        [
          0,
          1
        ]
      ],
      [
        [
          95,
          3
        ],
        [
          45,
          3
        ],
        [
          0,
          2
        ]
      ],
      [[
          44,
          4
        ]],
      [[
          0,
          4
        ]]
    ],
    [
      [[
          15,
          1
        ]],
      [[
          80,
          2
        ]],
      [
        [
          75,
          3
        ],
        [
          0,
          2
        ]
      ],
      [[
          44,
          4
        ]],
      [
        [
          45,
          5
        ],
        [
          0,
          4
        ]
      ],
      [[
          44,
          6
        ]],
      [[
          0,
          6
        ]]
    ],
    [
      [[
          100,
          1
        ]],
      [
        [
          101,
          0
        ],
        [
          0,
          1
        ]
      ]
    ],
    [
      [[
          71,
          1
        ]],
      [
        [
          102,
          2
        ],
        [
          47,
          3
        ],
        [
          0,
          1
        ]
      ],
      [
        [
          71,
          4
        ],
        [
          53,
          4
        ]
      ],
      [
        [
          71,
          5
        ],
        [
          53,
          5
        ]
      ],
      [[
          0,
          4
        ]],
      [
        [
          47,
          3
        ],
        [
          0,
          5
        ]
      ]
    ],
    [
      [[
          80,
          1
        ]],
      [
        [
          45,
          2
        ],
        [
          0,
          1
        ]
      ],
      [
        [
          80,
          1
        ],
        [
          0,
          2
        ]
      ]
    ],
    [
      [
        [
          103,
          2
        ],
        [
          24,
          1
        ],
        [
          6,
          1
        ],
        [
          35,
          1
        ]
      ],
      [[
          104,
          2
        ]],
      [[
          0,
          2
        ]]
    ],
    [
      [
        [
          2,
          0
        ],
        [
          98,
          1
        ],
        [
          105,
          0
        ]
      ],
      [[
          0,
          1
        ]]
    ],
    [
      [
        [
          106,
          1
        ],
        [
          107,
          1
        ],
        [
          108,
          1
        ],
        [
          109,
          1
        ],
        [
          110,
          1
        ]
      ],
      [[
          0,
          1
        ]]
    ],
    [
      [[
          27,
          1
        ]],
      [[
          94,
          2
        ]],
      [[
          75,
          3
        ]],
      [[
          71,
          4
        ]],
      [[
          69,
          5
        ]],
      [[
          70,
          6
        ]],
      [
        [
          111,
          7
        ],
        [
          0,
          6
        ]
      ],
      [[
          69,
          8
        ]],
      [[
          70,
          9
        ]],
      [[
          0,
          9
        ]]
    ],
    [
      [
        [
          28,
          1
        ],
        [
          20,
          2
        ]
      ],
      [[
          112,
          3
        ]],
      [[
          0,
          2
        ]],
      [[
          51,
          2
        ]]
    ],
    [
      [[
          113,
          1
        ]],
      [
        [
          45,
          2
        ],
        [
          0,
          1
        ]
      ],
      [
        [
          113,
          1
        ],
        [
          0,
          2
        ]
      ]
    ],
    [
      [[
          4,
          1
        ]],
      [[
          20,
          2
        ]],
      [[
          114,
          3
        ]],
      [[
          69,
          4
        ]],
      [[
          70,
          5
        ]],
      [[
          0,
          5
        ]]
    ],
    [
      [[
          27,
          1
        ]],
      [[
          94,
          2
        ]],
      [[
          75,
          3
        ]],
      [[
          115,
          4
        ]],
      [
        [
          116,
          5
        ],
        [
          0,
          4
        ]
      ],
      [[
          0,
          5
        ]]
    ],
    [
      [[
          30,
          1
        ]],
      [[
          117,
          2
        ]],
      [
        [
          116,
          3
        ],
        [
          0,
          2
        ]
      ],
      [[
          0,
          3
        ]]
    ],
    [
      [
        [
          46,
          1
        ],
        [
          118,
          1
        ]
      ],
      [[
          0,
          1
        ]]
    ],
    [
      [[
          26,
          1
        ]],
      [[
          20,
          2
        ]],
      [
        [
          45,
          1
        ],
        [
          0,
          2
        ]
      ]
    ],
    [
      [[
          30,
          1
        ]],
      [[
          44,
          2
        ]],
      [[
          69,
          3
        ]],
      [[
          70,
          4
        ]],
      [
        [
          111,
          5
        ],
        [
          119,
          1
        ],
        [
          0,
          4
        ]
      ],
      [[
          69,
          6
        ]],
      [[
          70,
          7
        ]],
      [[
          0,
          7
        ]]
    ],
    [
      [[
          20,
          1
        ]],
      [
        [
          95,
          2
        ],
        [
          0,
          1
        ]
      ],
      [[
          20,
          3
        ]],
      [[
          0,
          3
        ]]
    ],
    [
      [[
          120,
          1
        ]],
      [
        [
          45,
          2
        ],
        [
          0,
          1
        ]
      ],
      [
        [
          120,
          1
        ],
        [
          0,
          2
        ]
      ]
    ],
    [
      [[
          29,
          1
        ]],
      [
        [
          91,
          2
        ],
        [
          97,
          3
        ]
      ],
      [[
          23,
          4
        ]],
      [
        [
          91,
          2
        ],
        [
          23,
          4
        ],
        [
          97,
          3
        ]
      ],
      [
        [
          121,
          5
        ],
        [
          41,
          5
        ],
        [
          28,
          6
        ]
      ],
      [[
          0,
          5
        ]],
      [[
          121,
          7
        ]],
      [[
          51,
          5
        ]]
    ],
    [
      [[
          23,
          1
        ]],
      [[
          122,
          2
        ]],
      [[
          0,
          2
        ]]
    ],
    [
      [
        [
          123,
          1
        ],
        [
          124,
          1
        ]
      ],
      [[
          0,
          1
        ]]
    ],
    [
      [[
          36,
          1
        ]],
      [
        [
          69,
          2
        ],
        [
          125,
          3
        ]
      ],
      [[
          44,
          4
        ]],
      [[
          69,
          2
        ]],
      [[
          0,
          4
        ]]
    ],
    [
      [[
          27,
          1
        ]],
      [[
          94,
          2
        ]],
      [[
          75,
          3
        ]],
      [[
          126,
          4
        ]],
      [
        [
          127,
          5
        ],
        [
          0,
          4
        ]
      ],
      [[
          0,
          5
        ]]
    ],
    [
      [[
          30,
          1
        ]],
      [[
          117,
          2
        ]],
      [
        [
          127,
          3
        ],
        [
          0,
          2
        ]
      ],
      [[
          0,
          3
        ]]
    ],
    [
      [
        [
          128,
          1
        ],
        [
          129,
          1
        ]
      ],
      [[
          0,
          1
        ]]
    ],
    [
      [[
          44,
          1
        ]],
      [
        [
          128,
          2
        ],
        [
          45,
          3
        ],
        [
          0,
          1
        ]
      ],
      [[
          0,
          2
        ]],
      [
        [
          44,
          4
        ],
        [
          0,
          3
        ]
      ],
      [
        [
          45,
          3
        ],
        [
          0,
          4
        ]
      ]
    ],
    [
      [
        [
          7,
          1
        ],
        [
          130,
          2
        ]
      ],
      [[
          39,
          2
        ]],
      [[
          0,
          2
        ]]
    ],
    [
      [[
          36,
          1
        ]],
      [
        [
          69,
          2
        ],
        [
          125,
          3
        ]
      ],
      [[
          117,
          4
        ]],
      [[
          69,
          2
        ]],
      [[
          0,
          4
        ]]
    ],
    [
      [
        [
          131,
          1
        ],
        [
          115,
          1
        ]
      ],
      [[
          0,
          1
        ]]
    ],
    [
      [[
          132,
          1
        ]],
      [
        [
          133,
          0
        ],
        [
          0,
          1
        ]
      ]
    ],
    [
      [[
          28,
          1
        ]],
      [
        [
          51,
          2
        ],
        [
          125,
          3
        ]
      ],
      [[
          0,
          2
        ]],
      [[
          51,
          2
        ]]
    ],
    [
      [[
          22,
          1
        ]],
      [[
          0,
          1
        ]]
    ],
    [
      [[
          134,
          1
        ]],
      [
        [
          135,
          1
        ],
        [
          43,
          2
        ],
        [
          0,
          1
        ]
      ],
      [[
          104,
          3
        ]],
      [[
          0,
          3
        ]]
    ],
    [
      [[
          12,
          1
        ]],
      [
        [
          44,
          2
        ],
        [
          136,
          3
        ],
        [
          0,
          1
        ]
      ],
      [
        [
          45,
          4
        ],
        [
          0,
          2
        ]
      ],
      [[
          44,
          5
        ]],
      [
        [
          44,
          2
        ],
        [
          0,
          4
        ]
      ],
      [
        [
          45,
          6
        ],
        [
          0,
          5
        ]
      ],
      [[
          44,
          7
        ]],
      [
        [
          45,
          8
        ],
        [
          0,
          7
        ]
      ],
      [
        [
          44,
          7
        ],
        [
          0,
          8
        ]
      ]
    ],
    [
      [[
          5,
          1
        ]],
      [
        [
          44,
          2
        ],
        [
          0,
          1
        ]
      ],
      [
        [
          45,
          3
        ],
        [
          0,
          2
        ]
      ],
      [[
          44,
          4
        ]],
      [
        [
          45,
          5
        ],
        [
          0,
          4
        ]
      ],
      [[
          44,
          6
        ]],
      [[
          0,
          6
        ]]
    ],
    [
      [[
          18,
          1
        ]],
      [
        [
          71,
          2
        ],
        [
          0,
          1
        ]
      ],
      [[
          0,
          2
        ]]
    ],
    [
      [[
          137,
          1
        ]],
      [
        [
          136,
          0
        ],
        [
          138,
          0
        ],
        [
          0,
          1
        ]
      ]
    ],
    [
      [[
          139,
          1
        ]],
      [
        [
          2,
          2
        ],
        [
          140,
          3
        ]
      ],
      [[
          0,
          2
        ]],
      [
        [
          139,
          1
        ],
        [
          2,
          2
        ]
      ]
    ],
    [
      [[
          69,
          1
        ]],
      [
        [
          44,
          2
        ],
        [
          0,
          1
        ]
      ],
      [[
          0,
          2
        ]]
    ],
    [
      [
        [
          141,
          1
        ],
        [
          142,
          1
        ],
        [
          143,
          1
        ],
        [
          144,
          1
        ],
        [
          145,
          1
        ],
        [
          146,
          1
        ],
        [
          147,
          1
        ],
        [
          148,
          1
        ],
        [
          149,
          1
        ]
      ],
      [[
          0,
          1
        ]]
    ],
    [
      [
        [
          1,
          1
        ],
        [
          3,
          1
        ]
      ],
      [[
          0,
          1
        ]]
    ],
    [
      [
        [
          44,
          1
        ],
        [
          69,
          2
        ],
        [
          97,
          3
        ]
      ],
      [
        [
          69,
          2
        ],
        [
          0,
          1
        ]
      ],
      [
        [
          44,
          4
        ],
        [
          150,
          5
        ],
        [
          0,
          2
        ]
      ],
      [[
          97,
          6
        ]],
      [
        [
          150,
          5
        ],
        [
          0,
          4
        ]
      ],
      [[
          0,
          5
        ]],
      [[
          97,
          5
        ]]
    ],
    [
      [[
          151,
          1
        ]],
      [
        [
          45,
          2
        ],
        [
          0,
          1
        ]
      ],
      [
        [
          151,
          1
        ],
        [
          0,
          2
        ]
      ]
    ],
    [
      [
        [
          1,
          1
        ],
        [
          2,
          2
        ]
      ],
      [[
          0,
          1
        ]],
      [[
          152,
          3
        ]],
      [[
          105,
          4
        ]],
      [
        [
          153,
          1
        ],
        [
          105,
          4
        ]
      ]
    ],
    [
      [[
          104,
          1
        ]],
      [
        [
          154,
          0
        ],
        [
          41,
          0
        ],
        [
          155,
          0
        ],
        [
          156,
          0
        ],
        [
          0,
          1
        ]
      ]
    ],
    [
      [
        [
          115,
          1
        ],
        [
          157,
          2
        ]
      ],
      [
        [
          30,
          3
        ],
        [
          0,
          1
        ]
      ],
      [[
          0,
          2
        ]],
      [[
          115,
          4
        ]],
      [[
          111,
          5
        ]],
      [[
          44,
          2
        ]]
    ],
    [
      [[
          44,
          1
        ]],
      [
        [
          45,
          2
        ],
        [
          0,
          1
        ]
      ],
      [
        [
          44,
          1
        ],
        [
          0,
          2
        ]
      ]
    ],
    [
      [[
          44,
          1
        ]],
      [
        [
          45,
          0
        ],
        [
          0,
          1
        ]
      ]
    ],
    [
      [[
          44,
          1
        ]],
      [
        [
          46,
          2
        ],
        [
          45,
          3
        ],
        [
          0,
          1
        ]
      ],
      [[
          0,
          2
        ]],
      [
        [
          44,
          4
        ],
        [
          0,
          3
        ]
      ],
      [
        [
          45,
          3
        ],
        [
          0,
          4
        ]
      ]
    ],
    [
      [[
          117,
          1
        ]],
      [
        [
          45,
          2
        ],
        [
          0,
          1
        ]
      ],
      [[
          117,
          3
        ]],
      [
        [
          45,
          4
        ],
        [
          0,
          3
        ]
      ],
      [
        [
          117,
          3
        ],
        [
          0,
          4
        ]
      ]
    ],
    [
      [
        [
          28,
          1
        ],
        [
          97,
          2
        ],
        [
          11,
          3
        ]
      ],
      [
        [
          51,
          4
        ],
        [
          92,
          5
        ]
      ],
      [[
          20,
          4
        ]],
      [[
          158,
          6
        ]],
      [[
          0,
          4
        ]],
      [[
          51,
          4
        ]],
      [[
          50,
          4
        ]]
    ],
    [
      [[
          14,
          1
        ]],
      [[
          69,
          2
        ]],
      [[
          70,
          3
        ]],
      [
        [
          159,
          4
        ],
        [
          160,
          5
        ]
      ],
      [[
          69,
          6
        ]],
      [[
          69,
          7
        ]],
      [[
          70,
          8
        ]],
      [[
          70,
          9
        ]],
      [
        [
          159,
          4
        ],
        [
          111,
          10
        ],
        [
          160,
          5
        ],
        [
          0,
          8
        ]
      ],
      [[
          0,
          9
        ]],
      [[
          69,
          11
        ]],
      [[
          70,
          12
        ]],
      [
        [
          160,
          5
        ],
        [
          0,
          12
        ]
      ]
    ],
    [
      [
        [
          41,
          1
        ],
        [
          113,
          2
        ],
        [
          43,
          3
        ]
      ],
      [[
          20,
          4
        ]],
      [
        [
          47,
          5
        ],
        [
          45,
          6
        ],
        [
          0,
          2
        ]
      ],
      [[
          20,
          7
        ]],
      [
        [
          45,
          8
        ],
        [
          0,
          4
        ]
      ],
      [[
          44,
          9
        ]],
      [
        [
          41,
          1
        ],
        [
          113,
          2
        ],
        [
          43,
          3
        ],
        [
          0,
          6
        ]
      ],
      [[
          0,
          7
        ]],
      [[
          43,
          3
        ]],
      [
        [
          45,
          6
        ],
        [
          0,
          9
        ]
      ]
    ],
    [
      [[
          16,
          1
        ]],
      [[
          44,
          2
        ]],
      [[
          69,
          3
        ]],
      [[
          70,
          4
        ]],
      [
        [
          111,
          5
        ],
        [
          0,
          4
        ]
      ],
      [[
          69,
          6
        ]],
      [[
          70,
          7
        ]],
      [[
          0,
          7
        ]]
    ],
    [
      [[
          34,
          1
        ]],
      [[
          44,
          2
        ]],
      [
        [
          69,
          3
        ],
        [
          161,
          4
        ]
      ],
      [[
          70,
          5
        ]],
      [[
          69,
          3
        ]],
      [[
          0,
          5
        ]]
    ],
    [
      [[
          95,
          1
        ]],
      [[
          80,
          2
        ]],
      [[
          0,
          2
        ]]
    ],
    [
      [[
          162,
          1
        ]],
      [
        [
          163,
          0
        ],
        [
          0,
          1
        ]
      ]
    ],
    [
      [[
          25,
          1
        ]],
      [
        [
          71,
          2
        ],
        [
          0,
          1
        ]
      ],
      [[
          0,
          2
        ]]
    ],
    [
      [[
          53,
          1
        ]],
      [[
          0,
          1
        ]]
    ]
  ],
  labels: [
    [
      0,
      'EMPTY'
    ],
    [
      319,
      null
    ],
    [
      4,
      null
    ],
    [
      269,
      null
    ],
    [
      1,
      'def'
    ],
    [
      1,
      'raise'
    ],
    [
      32,
      null
    ],
    [
      1,
      'not'
    ],
    [
      2,
      null
    ],
    [
      26,
      null
    ],
    [
      1,
      'class'
    ],
    [
      9,
      null
    ],
    [
      1,
      'print'
    ],
    [
      25,
      null
    ],
    [
      1,
      'try'
    ],
    [
      1,
      'exec'
    ],
    [
      1,
      'while'
    ],
    [
      3,
      null
    ],
    [
      1,
      'return'
    ],
    [
      1,
      'assert'
    ],
    [
      1,
      null
    ],
    [
      1,
      'del'
    ],
    [
      1,
      'pass'
    ],
    [
      1,
      'import'
    ],
    [
      15,
      null
    ],
    [
      1,
      'yield'
    ],
    [
      1,
      'global'
    ],
    [
      1,
      'for'
    ],
    [
      7,
      null
    ],
    [
      1,
      'from'
    ],
    [
      1,
      'if'
    ],
    [
      1,
      'break'
    ],
    [
      1,
      'continue'
    ],
    [
      50,
      null
    ],
    [
      1,
      'with'
    ],
    [
      14,
      null
    ],
    [
      1,
      'lambda'
    ],
    [
      318,
      null
    ],
    [
      19,
      null
    ],
    [
      308,
      null
    ],
    [
      1,
      'and'
    ],
    [
      16,
      null
    ],
    [
      260,
      null
    ],
    [
      36,
      null
    ],
    [
      327,
      null
    ],
    [
      12,
      null
    ],
    [
      293,
      null
    ],
    [
      22,
      null
    ],
    [
      326,
      null
    ],
    [
      307,
      null
    ],
    [
      10,
      null
    ],
    [
      8,
      null
    ],
    [
      330,
      null
    ],
    [
      339,
      null
    ],
    [
      275,
      null
    ],
    [
      27,
      null
    ],
    [
      329,
      null
    ],
    [
      46,
      null
    ],
    [
      39,
      null
    ],
    [
      41,
      null
    ],
    [
      47,
      null
    ],
    [
      42,
      null
    ],
    [
      43,
      null
    ],
    [
      37,
      null
    ],
    [
      44,
      null
    ],
    [
      49,
      null
    ],
    [
      40,
      null
    ],
    [
      38,
      null
    ],
    [
      45,
      null
    ],
    [
      11,
      null
    ],
    [
      325,
      null
    ],
    [
      328,
      null
    ],
    [
      29,
      null
    ],
    [
      21,
      null
    ],
    [
      28,
      null
    ],
    [
      1,
      'in'
    ],
    [
      30,
      null
    ],
    [
      1,
      'is'
    ],
    [
      31,
      null
    ],
    [
      20,
      null
    ],
    [
      283,
      null
    ],
    [
      267,
      null
    ],
    [
      333,
      null
    ],
    [
      297,
      null
    ],
    [
      289,
      null
    ],
    [
      266,
      null
    ],
    [
      336,
      null
    ],
    [
      335,
      null
    ],
    [
      292,
      null
    ],
    [
      271,
      null
    ],
    [
      273,
      null
    ],
    [
      278,
      null
    ],
    [
      259,
      null
    ],
    [
      272,
      null
    ],
    [
      285,
      null
    ],
    [
      1,
      'as'
    ],
    [
      276,
      null
    ],
    [
      23,
      null
    ],
    [
      0,
      null
    ],
    [
      1,
      'except'
    ],
    [
      338,
      null
    ],
    [
      18,
      null
    ],
    [
      264,
      null
    ],
    [
      314,
      null
    ],
    [
      286,
      null
    ],
    [
      322,
      null
    ],
    [
      265,
      null
    ],
    [
      270,
      null
    ],
    [
      316,
      null
    ],
    [
      317,
      null
    ],
    [
      340,
      null
    ],
    [
      1,
      'else'
    ],
    [
      291,
      null
    ],
    [
      290,
      null
    ],
    [
      312,
      null
    ],
    [
      311,
      null
    ],
    [
      295,
      null
    ],
    [
      310,
      null
    ],
    [
      294,
      null
    ],
    [
      1,
      'elif'
    ],
    [
      298,
      null
    ],
    [
      299,
      null
    ],
    [
      277,
      null
    ],
    [
      301,
      null
    ],
    [
      300,
      null
    ],
    [
      334,
      null
    ],
    [
      331,
      null
    ],
    [
      306,
      null
    ],
    [
      304,
      null
    ],
    [
      305,
      null
    ],
    [
      268,
      null
    ],
    [
      309,
      null
    ],
    [
      258,
      null
    ],
    [
      1,
      'or'
    ],
    [
      263,
      null
    ],
    [
      332,
      null
    ],
    [
      35,
      null
    ],
    [
      261,
      null
    ],
    [
      34,
      null
    ],
    [
      321,
      null
    ],
    [
      13,
      null
    ],
    [
      288,
      null
    ],
    [
      262,
      null
    ],
    [
      284,
      null
    ],
    [
      313,
      null
    ],
    [
      315,
      null
    ],
    [
      274,
      null
    ],
    [
      282,
      null
    ],
    [
      296,
      null
    ],
    [
      302,
      null
    ],
    [
      320,
      null
    ],
    [
      323,
      null
    ],
    [
      5,
      null
    ],
    [
      6,
      null
    ],
    [
      48,
      null
    ],
    [
      17,
      null
    ],
    [
      24,
      null
    ],
    [
      303,
      null
    ],
    [
      324,
      null
    ],
    [
      281,
      null
    ],
    [
      1,
      'finally'
    ],
    [
      337,
      null
    ],
    [
      257,
      null
    ],
    [
      33,
      null
    ]
  ],
  keywords: {
    'and': 40,
    'as': 95,
    'assert': 19,
    'break': 31,
    'class': 10,
    'continue': 32,
    'def': 4,
    'del': 21,
    'elif': 119,
    'else': 111,
    'except': 99,
    'exec': 15,
    'finally': 160,
    'for': 27,
    'from': 29,
    'global': 26,
    'if': 30,
    'import': 23,
    'in': 75,
    'is': 77,
    'lambda': 36,
    'not': 7,
    'or': 133,
    'pass': 22,
    'print': 12,
    'raise': 5,
    'return': 18,
    'try': 14,
    'while': 16,
    'with': 34,
    'yield': 25
  },
  tokens: {
    0: 98,
    1: 20,
    2: 8,
    3: 17,
    4: 2,
    5: 152,
    6: 153,
    7: 28,
    8: 51,
    9: 11,
    10: 50,
    11: 69,
    12: 45,
    13: 140,
    14: 35,
    15: 24,
    16: 41,
    17: 155,
    18: 101,
    19: 38,
    20: 79,
    21: 73,
    22: 47,
    23: 97,
    24: 156,
    25: 13,
    26: 9,
    27: 55,
    28: 74,
    29: 72,
    30: 76,
    31: 78,
    32: 6,
    33: 163,
    34: 138,
    35: 136,
    36: 43,
    37: 63,
    38: 67,
    39: 58,
    40: 66,
    41: 59,
    42: 61,
    43: 62,
    44: 64,
    45: 68,
    46: 57,
    47: 60,
    48: 154,
    49: 65,
    50: 33
  },
  start: 256
};
function Parser(filename, grammar) {
  this.filename = filename;
  this.grammar = grammar;
  return this;
}
Parser.prototype.setup = function (start) {
  start = start || this.grammar.start;
  var newnode = {
      type: start,
      value: null,
      context: null,
      children: []
    };
  var stackentry = {
      dfa: this.grammar.dfas[start],
      state: 0,
      node: newnode
    };
  this.stack = [stackentry];
  this.used_names = {};
};
function findInDfa(a, obj) {
  var i = a.length;
  while (i--) {
    if (a[i][0] === obj[0] && a[i][1] === obj[1]) {
      return true;
    }
  }
  return false;
}
Parser.prototype.addtoken = function (type, value, context) {
  var ilabel = this.classify(type, value, context);
  OUTERWHILE:
    while (true) {
      var tp = this.stack[this.stack.length - 1];
      var states = tp.dfa[0];
      var first = tp.dfa[1];
      var arcs = states[tp.state];
      for (var a = 0; a < arcs.length; ++a) {
        var i = arcs[a][0];
        var newstate = arcs[a][1];
        var t = this.grammar.labels[i][0];
        var v = this.grammar.labels[i][1];
        if (ilabel === i) {
          goog.asserts.assert(t < 256);
          this.shift(type, value, newstate, context);
          var state = newstate;
          while (states[state].length === 1 && states[state][0][0] === 0 && states[state][0][1] === state) {
            this.pop();
            if (this.stack.length === 0) {
              return true;
            }
            tp = this.stack[this.stack.length - 1];
            state = tp.state;
            states = tp.dfa[0];
            first = tp.dfa[1];
          }
          return false;
        } else if (t >= 256) {
          var itsdfa = this.grammar.dfas[t];
          var itsfirst = itsdfa[1];
          if (itsfirst.hasOwnProperty(ilabel)) {
            this.push(t, this.grammar.dfas[t], newstate, context);
            continue OUTERWHILE;
          }
        }
      }
      if (findInDfa(arcs, [
          0,
          tp.state
        ])) {
        this.pop();
        if (this.stack.length === 0) {
          throw new Sk.builtin.ParseError('too much input', this.filename);
        }
      } else {
        var errline = context[0][0];
        throw new Sk.builtin.ParseError('bad input', this.filename, errline, context);
      }
    }
};
Parser.prototype.classify = function (type, value, context) {
  var ilabel;
  if (type === Sk.Tokenizer.Tokens.T_NAME) {
    this.used_names[value] = true;
    ilabel = this.grammar.keywords.hasOwnProperty(value) && this.grammar.keywords[value];
    if (ilabel) {
      return ilabel;
    }
  }
  ilabel = this.grammar.tokens.hasOwnProperty(type) && this.grammar.tokens[type];
  if (!ilabel) {
    throw new Sk.builtin.ParseError('bad token', this.filename, context[0][0], context);
  }
  return ilabel;
};
Parser.prototype.shift = function (type, value, newstate, context) {
  var dfa = this.stack[this.stack.length - 1].dfa;
  var state = this.stack[this.stack.length - 1].state;
  var node = this.stack[this.stack.length - 1].node;
  var newnode = {
      type: type,
      value: value,
      lineno: context[0][0],
      col_offset: context[0][1],
      children: null
    };
  if (newnode) {
    node.children.push(newnode);
  }
  this.stack[this.stack.length - 1] = {
    dfa: dfa,
    state: newstate,
    node: node
  };
};
Parser.prototype.push = function (type, newdfa, newstate, context) {
  var dfa = this.stack[this.stack.length - 1].dfa;
  var node = this.stack[this.stack.length - 1].node;
  var newnode = {
      type: type,
      value: null,
      lineno: context[0][0],
      col_offset: context[0][1],
      children: []
    };
  this.stack[this.stack.length - 1] = {
    dfa: dfa,
    state: newstate,
    node: node
  };
  this.stack.push({
    dfa: newdfa,
    state: 0,
    node: newnode
  });
};
Parser.prototype.pop = function () {
  var pop = this.stack.pop();
  var newnode = pop.node;
  if (newnode) {
    if (this.stack.length !== 0) {
      var node = this.stack[this.stack.length - 1].node;
      node.children.push(newnode);
    } else {
      this.rootnode = newnode;
      this.rootnode.used_names = this.used_names;
    }
  }
};
function makeParser(filename, style) {
  if (style === undefined)
    style = 'file_input';
  var p = new Parser(filename, Sk.ParseTables);
  if (style === 'file_input')
    p.setup(Sk.ParseTables.sym.file_input);
  else
    goog.asserts.fail('todo;');
  var curIndex = 0;
  var lineno = 1;
  var column = 0;
  var prefix = '';
  var T_COMMENT = Sk.Tokenizer.Tokens.T_COMMENT;
  var T_NL = Sk.Tokenizer.Tokens.T_NL;
  var T_OP = Sk.Tokenizer.Tokens.T_OP;
  var tokenizer = new Sk.Tokenizer(filename, style === 'single_input', function (type, value, start, end, line) {
      var s_lineno = start[0];
      var s_column = start[1];
      if (type === T_COMMENT || type === T_NL) {
        prefix += value;
        lineno = end[0];
        column = end[1];
        if (value[value.length - 1] === '\n') {
          lineno += 1;
          column = 0;
        }
        return undefined;
      }
      if (type === T_OP) {
        type = Sk.OpMap[value];
      }
      if (p.addtoken(type, value, [
          start,
          end,
          line
        ])) {
        return true;
      }
    });
  return function (line) {
    var ret = tokenizer.generateTokens(line);
    if (ret) {
      if (ret !== 'done') {
        throw new Sk.builtin.ParseError('incomplete input', this.filename);
      }
      return p.rootnode;
    }
    return false;
  };
}
Sk.parse = function parse(filename, input) {
  var parseFunc = makeParser(filename);
  if (input.substr(input.length - 1, 1) !== '\n')
    input += '\n';
  var lines = input.split('\n');
  var ret;
  for (var i = 0; i < lines.length; ++i) {
    ret = parseFunc(lines[i] + (i === lines.length - 1 ? '' : '\n'));
  }
  return ret;
};
Sk.parseTreeDump = function parseTreeDump(n, indent) {
  indent = indent || '';
  var ret = '';
  ret += indent;
  if (n.type >= 256) {
    ret += Sk.ParseTables.number2symbol[n.type] + '\n';
    for (var i = 0; i < n.children.length; ++i) {
      ret += Sk.parseTreeDump(n.children[i], indent + '  ');
    }
  } else {
    ret += Sk.Tokenizer.tokenNames[n.type] + ': ' + new Sk.builtin.str(n.value).tp$repr().v + '\n';
  }
  return ret;
};
goog.exportSymbol('Sk.parse', Sk.parse);
goog.exportSymbol('Sk.parseTreeDump', Sk.parseTreeDump);
function Load() {
}
function Store() {
}
function Del() {
}
function AugLoad() {
}
function AugStore() {
}
function Param() {
}
function And() {
}
function Or() {
}
function Add() {
}
function Sub() {
}
function Mult() {
}
function Div() {
}
function Mod() {
}
function Pow() {
}
function LShift() {
}
function RShift() {
}
function BitOr() {
}
function BitXor() {
}
function BitAnd() {
}
function FloorDiv() {
}
function Invert() {
}
function Not() {
}
function UAdd() {
}
function USub() {
}
function Eq() {
}
function NotEq() {
}
function Lt() {
}
function LtE() {
}
function Gt() {
}
function GtE() {
}
function Is() {
}
function IsNot() {
}
function In_() {
}
function NotIn() {
}
function Module(body) {
  this.body = body;
  return this;
}
function Interactive(body) {
  this.body = body;
  return this;
}
function Expression(body) {
  goog.asserts.assert(body !== null && body !== undefined);
  this.body = body;
  return this;
}
function Suite(body) {
  this.body = body;
  return this;
}
function FunctionDef(name, args, body, decorator_list, lineno, col_offset) {
  goog.asserts.assert(name !== null && name !== undefined);
  goog.asserts.assert(args !== null && args !== undefined);
  this.name = name;
  this.args = args;
  this.body = body;
  this.decorator_list = decorator_list;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function ClassDef(name, bases, body, decorator_list, lineno, col_offset) {
  goog.asserts.assert(name !== null && name !== undefined);
  this.name = name;
  this.bases = bases;
  this.body = body;
  this.decorator_list = decorator_list;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Return_(value, lineno, col_offset) {
  this.value = value;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Delete_(targets, lineno, col_offset) {
  this.targets = targets;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Assign(targets, value, lineno, col_offset) {
  goog.asserts.assert(value !== null && value !== undefined);
  this.targets = targets;
  this.value = value;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function AugAssign(target, op, value, lineno, col_offset) {
  goog.asserts.assert(target !== null && target !== undefined);
  goog.asserts.assert(op !== null && op !== undefined);
  goog.asserts.assert(value !== null && value !== undefined);
  this.target = target;
  this.op = op;
  this.value = value;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Print(dest, values, nl, lineno, col_offset) {
  this.dest = dest;
  this.values = values;
  this.nl = nl;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function For_(target, iter, body, orelse, lineno, col_offset) {
  goog.asserts.assert(target !== null && target !== undefined);
  goog.asserts.assert(iter !== null && iter !== undefined);
  this.target = target;
  this.iter = iter;
  this.body = body;
  this.orelse = orelse;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function While_(test, body, orelse, lineno, col_offset) {
  goog.asserts.assert(test !== null && test !== undefined);
  this.test = test;
  this.body = body;
  this.orelse = orelse;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function If_(test, body, orelse, lineno, col_offset) {
  goog.asserts.assert(test !== null && test !== undefined);
  this.test = test;
  this.body = body;
  this.orelse = orelse;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function With_(context_expr, optional_vars, body, lineno, col_offset) {
  goog.asserts.assert(context_expr !== null && context_expr !== undefined);
  this.context_expr = context_expr;
  this.optional_vars = optional_vars;
  this.body = body;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Raise(type, inst, tback, lineno, col_offset) {
  this.type = type;
  this.inst = inst;
  this.tback = tback;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function TryExcept(body, handlers, orelse, lineno, col_offset) {
  this.body = body;
  this.handlers = handlers;
  this.orelse = orelse;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function TryFinally(body, finalbody, lineno, col_offset) {
  this.body = body;
  this.finalbody = finalbody;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Assert(test, msg, lineno, col_offset) {
  goog.asserts.assert(test !== null && test !== undefined);
  this.test = test;
  this.msg = msg;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Import_(names, lineno, col_offset) {
  this.names = names;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function ImportFrom(module, names, level, lineno, col_offset) {
  goog.asserts.assert(module !== null && module !== undefined);
  this.module = module;
  this.names = names;
  this.level = level;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Exec(body, globals, locals, lineno, col_offset) {
  goog.asserts.assert(body !== null && body !== undefined);
  this.body = body;
  this.globals = globals;
  this.locals = locals;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Global(names, lineno, col_offset) {
  this.names = names;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Expr(value, lineno, col_offset) {
  goog.asserts.assert(value !== null && value !== undefined);
  this.value = value;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Pass(lineno, col_offset) {
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Break_(lineno, col_offset) {
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Continue_(lineno, col_offset) {
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function BoolOp(op, values, lineno, col_offset) {
  goog.asserts.assert(op !== null && op !== undefined);
  this.op = op;
  this.values = values;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function BinOp(left, op, right, lineno, col_offset) {
  goog.asserts.assert(left !== null && left !== undefined);
  goog.asserts.assert(op !== null && op !== undefined);
  goog.asserts.assert(right !== null && right !== undefined);
  this.left = left;
  this.op = op;
  this.right = right;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function UnaryOp(op, operand, lineno, col_offset) {
  goog.asserts.assert(op !== null && op !== undefined);
  goog.asserts.assert(operand !== null && operand !== undefined);
  this.op = op;
  this.operand = operand;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Lambda(args, body, lineno, col_offset) {
  goog.asserts.assert(args !== null && args !== undefined);
  goog.asserts.assert(body !== null && body !== undefined);
  this.args = args;
  this.body = body;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function IfExp(test, body, orelse, lineno, col_offset) {
  goog.asserts.assert(test !== null && test !== undefined);
  goog.asserts.assert(body !== null && body !== undefined);
  goog.asserts.assert(orelse !== null && orelse !== undefined);
  this.test = test;
  this.body = body;
  this.orelse = orelse;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Dict(keys, values, lineno, col_offset) {
  this.keys = keys;
  this.values = values;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function ListComp(elt, generators, lineno, col_offset) {
  goog.asserts.assert(elt !== null && elt !== undefined);
  this.elt = elt;
  this.generators = generators;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function GeneratorExp(elt, generators, lineno, col_offset) {
  goog.asserts.assert(elt !== null && elt !== undefined);
  this.elt = elt;
  this.generators = generators;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Yield(value, lineno, col_offset) {
  this.value = value;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Compare(left, ops, comparators, lineno, col_offset) {
  goog.asserts.assert(left !== null && left !== undefined);
  this.left = left;
  this.ops = ops;
  this.comparators = comparators;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Call(func, args, keywords, starargs, kwargs, lineno, col_offset) {
  goog.asserts.assert(func !== null && func !== undefined);
  this.func = func;
  this.args = args;
  this.keywords = keywords;
  this.starargs = starargs;
  this.kwargs = kwargs;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Num(n, lineno, col_offset) {
  goog.asserts.assert(n !== null && n !== undefined);
  this.n = n;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Str(s, lineno, col_offset) {
  goog.asserts.assert(s !== null && s !== undefined);
  this.s = s;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Attribute(value, attr, ctx, lineno, col_offset) {
  goog.asserts.assert(value !== null && value !== undefined);
  goog.asserts.assert(attr !== null && attr !== undefined);
  goog.asserts.assert(ctx !== null && ctx !== undefined);
  this.value = value;
  this.attr = attr;
  this.ctx = ctx;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Subscript(value, slice, ctx, lineno, col_offset) {
  goog.asserts.assert(value !== null && value !== undefined);
  goog.asserts.assert(slice !== null && slice !== undefined);
  goog.asserts.assert(ctx !== null && ctx !== undefined);
  this.value = value;
  this.slice = slice;
  this.ctx = ctx;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Name(id, ctx, lineno, col_offset) {
  goog.asserts.assert(id !== null && id !== undefined);
  goog.asserts.assert(ctx !== null && ctx !== undefined);
  this.id = id;
  this.ctx = ctx;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function List(elts, ctx, lineno, col_offset) {
  goog.asserts.assert(ctx !== null && ctx !== undefined);
  this.elts = elts;
  this.ctx = ctx;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Tuple(elts, ctx, lineno, col_offset) {
  goog.asserts.assert(ctx !== null && ctx !== undefined);
  this.elts = elts;
  this.ctx = ctx;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function Ellipsis() {
  return this;
}
function Slice(lower, upper, step) {
  this.lower = lower;
  this.upper = upper;
  this.step = step;
  return this;
}
function ExtSlice(dims) {
  this.dims = dims;
  return this;
}
function Index(value) {
  goog.asserts.assert(value !== null && value !== undefined);
  this.value = value;
  return this;
}
function comprehension(target, iter, ifs) {
  goog.asserts.assert(target !== null && target !== undefined);
  goog.asserts.assert(iter !== null && iter !== undefined);
  this.target = target;
  this.iter = iter;
  this.ifs = ifs;
  return this;
}
function ExceptHandler(type, name, body, lineno, col_offset) {
  this.type = type;
  this.name = name;
  this.body = body;
  this.lineno = lineno;
  this.col_offset = col_offset;
  return this;
}
function arguments_(args, vararg, kwarg, defaults) {
  this.args = args;
  this.vararg = vararg;
  this.kwarg = kwarg;
  this.defaults = defaults;
  return this;
}
function keyword(arg, value) {
  goog.asserts.assert(arg !== null && arg !== undefined);
  goog.asserts.assert(value !== null && value !== undefined);
  this.arg = arg;
  this.value = value;
  return this;
}
function alias(name, asname) {
  goog.asserts.assert(name !== null && name !== undefined);
  this.name = name;
  this.asname = asname;
  return this;
}
Module.prototype._astname = 'Module';
Module.prototype._fields = [
  'body',
  function (n) {
    return n.body;
  }
];
Interactive.prototype._astname = 'Interactive';
Interactive.prototype._fields = [
  'body',
  function (n) {
    return n.body;
  }
];
Expression.prototype._astname = 'Expression';
Expression.prototype._fields = [
  'body',
  function (n) {
    return n.body;
  }
];
Suite.prototype._astname = 'Suite';
Suite.prototype._fields = [
  'body',
  function (n) {
    return n.body;
  }
];
FunctionDef.prototype._astname = 'FunctionDef';
FunctionDef.prototype._fields = [
  'name',
  function (n) {
    return n.name;
  },
  'args',
  function (n) {
    return n.args;
  },
  'body',
  function (n) {
    return n.body;
  },
  'decorator_list',
  function (n) {
    return n.decorator_list;
  }
];
ClassDef.prototype._astname = 'ClassDef';
ClassDef.prototype._fields = [
  'name',
  function (n) {
    return n.name;
  },
  'bases',
  function (n) {
    return n.bases;
  },
  'body',
  function (n) {
    return n.body;
  },
  'decorator_list',
  function (n) {
    return n.decorator_list;
  }
];
Return_.prototype._astname = 'Return';
Return_.prototype._fields = [
  'value',
  function (n) {
    return n.value;
  }
];
Delete_.prototype._astname = 'Delete';
Delete_.prototype._fields = [
  'targets',
  function (n) {
    return n.targets;
  }
];
Assign.prototype._astname = 'Assign';
Assign.prototype._fields = [
  'targets',
  function (n) {
    return n.targets;
  },
  'value',
  function (n) {
    return n.value;
  }
];
AugAssign.prototype._astname = 'AugAssign';
AugAssign.prototype._fields = [
  'target',
  function (n) {
    return n.target;
  },
  'op',
  function (n) {
    return n.op;
  },
  'value',
  function (n) {
    return n.value;
  }
];
Print.prototype._astname = 'Print';
Print.prototype._fields = [
  'dest',
  function (n) {
    return n.dest;
  },
  'values',
  function (n) {
    return n.values;
  },
  'nl',
  function (n) {
    return n.nl;
  }
];
For_.prototype._astname = 'For';
For_.prototype._fields = [
  'target',
  function (n) {
    return n.target;
  },
  'iter',
  function (n) {
    return n.iter;
  },
  'body',
  function (n) {
    return n.body;
  },
  'orelse',
  function (n) {
    return n.orelse;
  }
];
While_.prototype._astname = 'While';
While_.prototype._fields = [
  'test',
  function (n) {
    return n.test;
  },
  'body',
  function (n) {
    return n.body;
  },
  'orelse',
  function (n) {
    return n.orelse;
  }
];
If_.prototype._astname = 'If';
If_.prototype._fields = [
  'test',
  function (n) {
    return n.test;
  },
  'body',
  function (n) {
    return n.body;
  },
  'orelse',
  function (n) {
    return n.orelse;
  }
];
With_.prototype._astname = 'With';
With_.prototype._fields = [
  'context_expr',
  function (n) {
    return n.context_expr;
  },
  'optional_vars',
  function (n) {
    return n.optional_vars;
  },
  'body',
  function (n) {
    return n.body;
  }
];
Raise.prototype._astname = 'Raise';
Raise.prototype._fields = [
  'type',
  function (n) {
    return n.type;
  },
  'inst',
  function (n) {
    return n.inst;
  },
  'tback',
  function (n) {
    return n.tback;
  }
];
TryExcept.prototype._astname = 'TryExcept';
TryExcept.prototype._fields = [
  'body',
  function (n) {
    return n.body;
  },
  'handlers',
  function (n) {
    return n.handlers;
  },
  'orelse',
  function (n) {
    return n.orelse;
  }
];
TryFinally.prototype._astname = 'TryFinally';
TryFinally.prototype._fields = [
  'body',
  function (n) {
    return n.body;
  },
  'finalbody',
  function (n) {
    return n.finalbody;
  }
];
Assert.prototype._astname = 'Assert';
Assert.prototype._fields = [
  'test',
  function (n) {
    return n.test;
  },
  'msg',
  function (n) {
    return n.msg;
  }
];
Import_.prototype._astname = 'Import';
Import_.prototype._fields = [
  'names',
  function (n) {
    return n.names;
  }
];
ImportFrom.prototype._astname = 'ImportFrom';
ImportFrom.prototype._fields = [
  'module',
  function (n) {
    return n.module;
  },
  'names',
  function (n) {
    return n.names;
  },
  'level',
  function (n) {
    return n.level;
  }
];
Exec.prototype._astname = 'Exec';
Exec.prototype._fields = [
  'body',
  function (n) {
    return n.body;
  },
  'globals',
  function (n) {
    return n.globals;
  },
  'locals',
  function (n) {
    return n.locals;
  }
];
Global.prototype._astname = 'Global';
Global.prototype._fields = [
  'names',
  function (n) {
    return n.names;
  }
];
Expr.prototype._astname = 'Expr';
Expr.prototype._fields = [
  'value',
  function (n) {
    return n.value;
  }
];
Pass.prototype._astname = 'Pass';
Pass.prototype._fields = [];
Break_.prototype._astname = 'Break';
Break_.prototype._fields = [];
Continue_.prototype._astname = 'Continue';
Continue_.prototype._fields = [];
BoolOp.prototype._astname = 'BoolOp';
BoolOp.prototype._fields = [
  'op',
  function (n) {
    return n.op;
  },
  'values',
  function (n) {
    return n.values;
  }
];
BinOp.prototype._astname = 'BinOp';
BinOp.prototype._fields = [
  'left',
  function (n) {
    return n.left;
  },
  'op',
  function (n) {
    return n.op;
  },
  'right',
  function (n) {
    return n.right;
  }
];
UnaryOp.prototype._astname = 'UnaryOp';
UnaryOp.prototype._fields = [
  'op',
  function (n) {
    return n.op;
  },
  'operand',
  function (n) {
    return n.operand;
  }
];
Lambda.prototype._astname = 'Lambda';
Lambda.prototype._fields = [
  'args',
  function (n) {
    return n.args;
  },
  'body',
  function (n) {
    return n.body;
  }
];
IfExp.prototype._astname = 'IfExp';
IfExp.prototype._fields = [
  'test',
  function (n) {
    return n.test;
  },
  'body',
  function (n) {
    return n.body;
  },
  'orelse',
  function (n) {
    return n.orelse;
  }
];
Dict.prototype._astname = 'Dict';
Dict.prototype._fields = [
  'keys',
  function (n) {
    return n.keys;
  },
  'values',
  function (n) {
    return n.values;
  }
];
ListComp.prototype._astname = 'ListComp';
ListComp.prototype._fields = [
  'elt',
  function (n) {
    return n.elt;
  },
  'generators',
  function (n) {
    return n.generators;
  }
];
GeneratorExp.prototype._astname = 'GeneratorExp';
GeneratorExp.prototype._fields = [
  'elt',
  function (n) {
    return n.elt;
  },
  'generators',
  function (n) {
    return n.generators;
  }
];
Yield.prototype._astname = 'Yield';
Yield.prototype._fields = [
  'value',
  function (n) {
    return n.value;
  }
];
Compare.prototype._astname = 'Compare';
Compare.prototype._fields = [
  'left',
  function (n) {
    return n.left;
  },
  'ops',
  function (n) {
    return n.ops;
  },
  'comparators',
  function (n) {
    return n.comparators;
  }
];
Call.prototype._astname = 'Call';
Call.prototype._fields = [
  'func',
  function (n) {
    return n.func;
  },
  'args',
  function (n) {
    return n.args;
  },
  'keywords',
  function (n) {
    return n.keywords;
  },
  'starargs',
  function (n) {
    return n.starargs;
  },
  'kwargs',
  function (n) {
    return n.kwargs;
  }
];
Num.prototype._astname = 'Num';
Num.prototype._fields = [
  'n',
  function (n) {
    return n.n;
  }
];
Str.prototype._astname = 'Str';
Str.prototype._fields = [
  's',
  function (n) {
    return n.s;
  }
];
Attribute.prototype._astname = 'Attribute';
Attribute.prototype._fields = [
  'value',
  function (n) {
    return n.value;
  },
  'attr',
  function (n) {
    return n.attr;
  },
  'ctx',
  function (n) {
    return n.ctx;
  }
];
Subscript.prototype._astname = 'Subscript';
Subscript.prototype._fields = [
  'value',
  function (n) {
    return n.value;
  },
  'slice',
  function (n) {
    return n.slice;
  },
  'ctx',
  function (n) {
    return n.ctx;
  }
];
Name.prototype._astname = 'Name';
Name.prototype._fields = [
  'id',
  function (n) {
    return n.id;
  },
  'ctx',
  function (n) {
    return n.ctx;
  }
];
List.prototype._astname = 'List';
List.prototype._fields = [
  'elts',
  function (n) {
    return n.elts;
  },
  'ctx',
  function (n) {
    return n.ctx;
  }
];
Tuple.prototype._astname = 'Tuple';
Tuple.prototype._fields = [
  'elts',
  function (n) {
    return n.elts;
  },
  'ctx',
  function (n) {
    return n.ctx;
  }
];
Load.prototype._astname = 'Load';
Load.prototype._isenum = true;
Store.prototype._astname = 'Store';
Store.prototype._isenum = true;
Del.prototype._astname = 'Del';
Del.prototype._isenum = true;
AugLoad.prototype._astname = 'AugLoad';
AugLoad.prototype._isenum = true;
AugStore.prototype._astname = 'AugStore';
AugStore.prototype._isenum = true;
Param.prototype._astname = 'Param';
Param.prototype._isenum = true;
Ellipsis.prototype._astname = 'Ellipsis';
Ellipsis.prototype._fields = [];
Slice.prototype._astname = 'Slice';
Slice.prototype._fields = [
  'lower',
  function (n) {
    return n.lower;
  },
  'upper',
  function (n) {
    return n.upper;
  },
  'step',
  function (n) {
    return n.step;
  }
];
ExtSlice.prototype._astname = 'ExtSlice';
ExtSlice.prototype._fields = [
  'dims',
  function (n) {
    return n.dims;
  }
];
Index.prototype._astname = 'Index';
Index.prototype._fields = [
  'value',
  function (n) {
    return n.value;
  }
];
And.prototype._astname = 'And';
And.prototype._isenum = true;
Or.prototype._astname = 'Or';
Or.prototype._isenum = true;
Add.prototype._astname = 'Add';
Add.prototype._isenum = true;
Sub.prototype._astname = 'Sub';
Sub.prototype._isenum = true;
Mult.prototype._astname = 'Mult';
Mult.prototype._isenum = true;
Div.prototype._astname = 'Div';
Div.prototype._isenum = true;
Mod.prototype._astname = 'Mod';
Mod.prototype._isenum = true;
Pow.prototype._astname = 'Pow';
Pow.prototype._isenum = true;
LShift.prototype._astname = 'LShift';
LShift.prototype._isenum = true;
RShift.prototype._astname = 'RShift';
RShift.prototype._isenum = true;
BitOr.prototype._astname = 'BitOr';
BitOr.prototype._isenum = true;
BitXor.prototype._astname = 'BitXor';
BitXor.prototype._isenum = true;
BitAnd.prototype._astname = 'BitAnd';
BitAnd.prototype._isenum = true;
FloorDiv.prototype._astname = 'FloorDiv';
FloorDiv.prototype._isenum = true;
Invert.prototype._astname = 'Invert';
Invert.prototype._isenum = true;
Not.prototype._astname = 'Not';
Not.prototype._isenum = true;
UAdd.prototype._astname = 'UAdd';
UAdd.prototype._isenum = true;
USub.prototype._astname = 'USub';
USub.prototype._isenum = true;
Eq.prototype._astname = 'Eq';
Eq.prototype._isenum = true;
NotEq.prototype._astname = 'NotEq';
NotEq.prototype._isenum = true;
Lt.prototype._astname = 'Lt';
Lt.prototype._isenum = true;
LtE.prototype._astname = 'LtE';
LtE.prototype._isenum = true;
Gt.prototype._astname = 'Gt';
Gt.prototype._isenum = true;
GtE.prototype._astname = 'GtE';
GtE.prototype._isenum = true;
Is.prototype._astname = 'Is';
Is.prototype._isenum = true;
IsNot.prototype._astname = 'IsNot';
IsNot.prototype._isenum = true;
In_.prototype._astname = 'In';
In_.prototype._isenum = true;
NotIn.prototype._astname = 'NotIn';
NotIn.prototype._isenum = true;
comprehension.prototype._astname = 'comprehension';
comprehension.prototype._fields = [
  'target',
  function (n) {
    return n.target;
  },
  'iter',
  function (n) {
    return n.iter;
  },
  'ifs',
  function (n) {
    return n.ifs;
  }
];
ExceptHandler.prototype._astname = 'ExceptHandler';
ExceptHandler.prototype._fields = [
  'type',
  function (n) {
    return n.type;
  },
  'name',
  function (n) {
    return n.name;
  },
  'body',
  function (n) {
    return n.body;
  }
];
arguments_.prototype._astname = 'arguments';
arguments_.prototype._fields = [
  'args',
  function (n) {
    return n.args;
  },
  'vararg',
  function (n) {
    return n.vararg;
  },
  'kwarg',
  function (n) {
    return n.kwarg;
  },
  'defaults',
  function (n) {
    return n.defaults;
  }
];
keyword.prototype._astname = 'keyword';
keyword.prototype._fields = [
  'arg',
  function (n) {
    return n.arg;
  },
  'value',
  function (n) {
    return n.value;
  }
];
alias.prototype._astname = 'alias';
alias.prototype._fields = [
  'name',
  function (n) {
    return n.name;
  },
  'asname',
  function (n) {
    return n.asname;
  }
];
var SYM = Sk.ParseTables.sym;
var TOK = Sk.Tokenizer.Tokens;
function Compiling(encoding, filename) {
  this.c_encoding = encoding;
  this.c_filename = filename;
}
function NCH(n) {
  goog.asserts.assert(n !== undefined);
  if (n.children === null)
    return 0;
  return n.children.length;
}
function CHILD(n, i) {
  goog.asserts.assert(n !== undefined);
  goog.asserts.assert(i !== undefined);
  return n.children[i];
}
function REQ(n, type) {
  goog.asserts.assert(n.type === type, 'node wasn\'t expected type');
}
function strobj(s) {
  goog.asserts.assert(typeof s === 'string', 'expecting string, got ' + typeof s);
  return new Sk.builtin.str(s);
}
function numStmts(n) {
  switch (n.type) {
  case SYM.single_input:
    if (CHILD(n, 0).type === TOK.T_NEWLINE)
      return 0;
    else
      return numStmts(CHILD(n, 0));
  case SYM.file_input:
    var cnt = 0;
    for (var i = 0; i < NCH(n); ++i) {
      var ch = CHILD(n, i);
      if (ch.type === SYM.stmt)
        cnt += numStmts(ch);
    }
    return cnt;
  case SYM.stmt:
    return numStmts(CHILD(n, 0));
  case SYM.compound_stmt:
    return 1;
  case SYM.simple_stmt:
    return Math.floor(NCH(n) / 2);
  case SYM.suite:
    if (NCH(n) === 1)
      return numStmts(CHILD(n, 0));
    else {
      var cnt = 0;
      for (var i = 2; i < NCH(n) - 1; ++i)
        cnt += numStmts(CHILD(n, i));
      return cnt;
    }
  default:
    goog.asserts.fail('Non-statement found');
  }
  return 0;
}
function forbiddenCheck(c, n, x, lineno) {
  if (x === 'None')
    throw new Sk.builtin.SyntaxError('assignment to None', c.c_filename, lineno);
  if (x === 'True' || x === 'False')
    throw new Sk.builtin.SyntaxError('assignment to True or False is forbidden', c.c_filename, lineno);
}
function setContext(c, e, ctx, n) {
  goog.asserts.assert(ctx !== AugStore && ctx !== AugLoad);
  var s = null;
  var exprName = null;
  switch (e.constructor) {
  case Attribute:
  case Name:
    if (ctx === Store)
      forbiddenCheck(c, n, e.attr, n.lineno);
    e.ctx = ctx;
    break;
  case Subscript:
    e.ctx = ctx;
    break;
  case List:
    e.ctx = ctx;
    s = e.elts;
    break;
  case Tuple:
    if (e.elts.length === 0)
      throw new Sk.builtin.SyntaxError('can\'t assign to ()', c.c_filename, n.lineno);
    e.ctx = ctx;
    s = e.elts;
    break;
  case Lambda:
    exprName = 'lambda';
    break;
  case Call:
    exprName = 'function call';
    break;
  case BoolOp:
  case BinOp:
  case UnaryOp:
    exprName = 'operator';
    break;
  case GeneratorExp:
    exprName = 'generator expression';
    break;
  case Yield:
    exprName = 'yield expression';
    break;
  case ListComp:
    exprName = 'list comprehension';
    break;
  case Dict:
  case Num:
  case Str:
    exprName = 'literal';
    break;
  case Compare:
    exprName = 'comparison';
    break;
  case IfExp:
    exprName = 'conditional expression';
    break;
  default:
    goog.asserts.fail('unhandled expression in assignment');
  }
  if (exprName) {
    throw new Sk.builtin.SyntaxError('can\'t ' + (ctx === Store ? 'assign to' : 'delete') + ' ' + exprName, c.c_filename, n.lineno);
  }
  if (s) {
    for (var i = 0; i < s.length; ++i) {
      setContext(c, s[i], ctx, n);
    }
  }
}
var operatorMap = {};
(function () {
  operatorMap[TOK.T_VBAR] = BitOr;
  operatorMap[TOK.T_VBAR] = BitOr;
  operatorMap[TOK.T_CIRCUMFLEX] = BitXor;
  operatorMap[TOK.T_AMPER] = BitAnd;
  operatorMap[TOK.T_LEFTSHIFT] = LShift;
  operatorMap[TOK.T_RIGHTSHIFT] = RShift;
  operatorMap[TOK.T_PLUS] = Add;
  operatorMap[TOK.T_MINUS] = Sub;
  operatorMap[TOK.T_STAR] = Mult;
  operatorMap[TOK.T_SLASH] = Div;
  operatorMap[TOK.T_DOUBLESLASH] = FloorDiv;
  operatorMap[TOK.T_PERCENT] = Mod;
}());
function getOperator(n) {
  goog.asserts.assert(operatorMap[n.type] !== undefined);
  return operatorMap[n.type];
}
function astForCompOp(c, n) {
  REQ(n, SYM.comp_op);
  if (NCH(n) === 1) {
    n = CHILD(n, 0);
    switch (n.type) {
    case TOK.T_LESS:
      return Lt;
    case TOK.T_GREATER:
      return Gt;
    case TOK.T_EQEQUAL:
      return Eq;
    case TOK.T_LESSEQUAL:
      return LtE;
    case TOK.T_GREATEREQUAL:
      return GtE;
    case TOK.T_NOTEQUAL:
      return NotEq;
    case TOK.T_NAME:
      if (n.value === 'in')
        return In_;
      if (n.value === 'is')
        return Is;
    }
  } else if (NCH(n) === 2) {
    if (CHILD(n, 0).type === TOK.T_NAME) {
      if (CHILD(n, 1).value === 'in')
        return NotIn;
      if (CHILD(n, 0).value === 'is')
        return IsNot;
    }
  }
  goog.asserts.fail('invalid comp_op');
}
function seqForTestlist(c, n) {
  goog.asserts.assert(n.type === SYM.testlist || n.type === SYM.listmaker || n.type === SYM.testlist_gexp || n.type === SYM.testlist_safe || n.type === SYM.testlist1);
  var seq = [];
  for (var i = 0; i < NCH(n); i += 2) {
    goog.asserts.assert(CHILD(n, i).type === SYM.test || CHILD(n, i).type === SYM.old_test);
    seq[i / 2] = astForExpr(c, CHILD(n, i));
  }
  return seq;
}
function astForSuite(c, n) {
  REQ(n, SYM.suite);
  var seq = [];
  var pos = 0;
  var ch;
  if (CHILD(n, 0).type === SYM.simple_stmt) {
    n = CHILD(n, 0);
    var end = NCH(n) - 1;
    if (CHILD(n, end - 1).type === TOK.T_SEMI)
      end -= 1;
    for (var i = 0; i < end; i += 2)
      seq[pos++] = astForStmt(c, CHILD(n, i));
  } else {
    for (var i = 2; i < NCH(n) - 1; ++i) {
      ch = CHILD(n, i);
      REQ(ch, SYM.stmt);
      var num = numStmts(ch);
      if (num === 1) {
        seq[pos++] = astForStmt(c, ch);
      } else {
        ch = CHILD(ch, 0);
        REQ(ch, SYM.simple_stmt);
        for (var j = 0; j < NCH(ch); j += 2) {
          if (NCH(CHILD(ch, j)) === 0) {
            goog.asserts.assert(j + 1 === NCH(ch));
            break;
          }
          seq[pos++] = astForStmt(c, CHILD(ch, j));
        }
      }
    }
  }
  goog.asserts.assert(pos === numStmts(n));
  return seq;
}
function astForExceptClause(c, exc, body) {
  REQ(exc, SYM.except_clause);
  REQ(body, SYM.suite);
  if (NCH(exc) === 1)
    return new ExceptHandler(null, null, astForSuite(c, body), exc.lineno, exc.col_offset);
  else if (NCH(exc) === 2)
    return new ExceptHandler(astForExpr(c, CHILD(exc, 1)), null, astForSuite(c, body), exc.lineno, exc.col_offset);
  else if (NCH(exc) === 4) {
    var e = astForExpr(c, CHILD(exc, 3));
    setContext(c, e, Store, CHILD(exc, 3));
    return new ExceptHandler(astForExpr(c, CHILD(exc, 1)), e, astForSuite(c, body), exc.lineno, exc.col_offset);
  }
  goog.asserts.fail('wrong number of children for except clause');
}
function astForTryStmt(c, n) {
  var nc = NCH(n);
  var nexcept = (nc - 3) / 3;
  var body, orelse = [], finally_ = null;
  REQ(n, SYM.try_stmt);
  body = astForSuite(c, CHILD(n, 2));
  if (CHILD(n, nc - 3).type === TOK.T_NAME) {
    if (CHILD(n, nc - 3).value === 'finally') {
      if (nc >= 9 && CHILD(n, nc - 6).type === TOK.T_NAME) {
        orelse = astForSuite(c, CHILD(n, nc - 4));
        nexcept--;
      }
      finally_ = astForSuite(c, CHILD(n, nc - 1));
      nexcept--;
    } else {
      orelse = astForSuite(c, CHILD(n, nc - 1));
      nexcept--;
    }
  } else if (CHILD(n, nc - 3).type !== SYM.except_clause) {
    throw new Sk.builtin.SyntaxError('malformed \'try\' statement', c.c_filename, n.lineno);
  }
  if (nexcept > 0) {
    var handlers = [];
    for (var i = 0; i < nexcept; ++i)
      handlers[i] = astForExceptClause(c, CHILD(n, 3 + i * 3), CHILD(n, 5 + i * 3));
    var exceptSt = new TryExcept(body, handlers, orelse, n.lineno, n.col_offset);
    if (!finally_)
      return exceptSt;
    body = [exceptSt];
  }
  goog.asserts.assert(finally_ !== null);
  return new TryFinally(body, finally_, n.lineno, n.col_offset);
}
function astForDottedName(c, n) {
  REQ(n, SYM.dotted_name);
  var lineno = n.lineno;
  var col_offset = n.col_offset;
  var id = strobj(CHILD(n, 0).value);
  var e = new Name(id, Load, lineno, col_offset);
  for (var i = 2; i < NCH(n); i += 2) {
    id = strobj(CHILD(n, i).value);
    e = new Attribute(e, id, Load, lineno, col_offset);
  }
  return e;
}
function astForDecorator(c, n) {
  REQ(n, SYM.decorator);
  REQ(CHILD(n, 0), TOK.T_AT);
  REQ(CHILD(n, NCH(n) - 1), TOK.T_NEWLINE);
  var nameExpr = astForDottedName(c, CHILD(n, 1));
  var d;
  if (NCH(n) === 3)
    return nameExpr;
  else if (NCH(n) === 5)
    return new Call(nameExpr, [], [], null, null, n.lineno, n.col_offset);
  else
    return astForCall(c, CHILD(n, 3), nameExpr);
}
function astForDecorators(c, n) {
  REQ(n, SYM.decorators);
  var decoratorSeq = [];
  for (var i = 0; i < NCH(n); ++i)
    decoratorSeq[i] = astForDecorator(c, CHILD(n, i));
  return decoratorSeq;
}
function astForDecorated(c, n) {
  REQ(n, SYM.decorated);
  var decoratorSeq = astForDecorators(c, CHILD(n, 0));
  goog.asserts.assert(CHILD(n, 1).type === SYM.funcdef || CHILD(n, 1).type === SYM.classdef);
  var thing = null;
  if (CHILD(n, 1).type === SYM.funcdef)
    thing = astForFuncdef(c, CHILD(n, 1), decoratorSeq);
  else if (CHILD(n, 1) === SYM.classdef)
    thing = astForClassdef(c, CHILD(n, 1), decoratorSeq);
  if (thing) {
    thing.lineno = n.lineno;
    thing.col_offset = n.col_offset;
  }
  return thing;
}
function astForWithVar(c, n) {
  REQ(n, SYM.with_var);
  return astForExpr(c, CHILD(n, 1));
}
function astForWithStmt(c, n) {
  var suiteIndex = 3;
  goog.asserts.assert(n.type === SYM.with_stmt);
  var contextExpr = astForExpr(c, CHILD(n, 1));
  if (CHILD(n, 2).type === SYM.with_var) {
    var optionalVars = astForWithVar(c, CHILD(n, 2));
    setContext(c, optionalVars, Store, n);
    suiteIndex = 4;
  }
  return new With_(contextExpr, optionalVars, astForSuite(c, CHILD(n, suiteIndex)), n.lineno, n.col_offset);
}
function astForExecStmt(c, n) {
  var expr1, globals = null, locals = null;
  var nchildren = NCH(n);
  goog.asserts.assert(nchildren === 2 || nchildren === 4 || nchildren === 6);
  REQ(n, SYM.exec_stmt);
  var expr1 = astForExpr(c, CHILD(n, 1));
  if (nchildren >= 4)
    globals = astForExpr(c, CHILD(n, 3));
  if (nchildren === 6)
    locals = astForExpr(c, CHILD(n, 5));
  return new Exec(expr1, globals, locals, n.lineno, n.col_offset);
}
function astForIfStmt(c, n) {
  REQ(n, SYM.if_stmt);
  if (NCH(n) === 4)
    return new If_(astForExpr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), [], n.lineno, n.col_offset);
  var s = CHILD(n, 4).value;
  var decider = s.charAt(2);
  if (decider === 's') {
    return new If_(astForExpr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), astForSuite(c, CHILD(n, 6)), n.lineno, n.col_offset);
  } else if (decider === 'i') {
    var nElif = NCH(n) - 4;
    var hasElse = false;
    var orelse = [];
    if (CHILD(n, nElif + 1).type === TOK.T_NAME && CHILD(n, nElif + 1).value.charAt(2) === 's') {
      hasElse = true;
      nElif -= 3;
    }
    nElif /= 4;
    if (hasElse) {
      orelse = [new If_(astForExpr(c, CHILD(n, NCH(n) - 6)), astForSuite(c, CHILD(n, NCH(n) - 4)), astForSuite(c, CHILD(n, NCH(n) - 1)), CHILD(n, NCH(n) - 6).lineno, CHILD(n, NCH(n) - 6).col_offset)];
      nElif--;
    }
    for (var i = 0; i < nElif; ++i) {
      var off = 5 + (nElif - i - 1) * 4;
      orelse = [new If_(astForExpr(c, CHILD(n, off)), astForSuite(c, CHILD(n, off + 2)), orelse, CHILD(n, off).lineno, CHILD(n, off).col_offset)];
    }
    return new If_(astForExpr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), orelse, n.lineno, n.col_offset);
  }
  goog.asserts.fail('unexpected token in \'if\' statement');
}
function astForExprlist(c, n, context) {
  REQ(n, SYM.exprlist);
  var seq = [];
  for (var i = 0; i < NCH(n); i += 2) {
    var e = astForExpr(c, CHILD(n, i));
    seq[i / 2] = e;
    if (context)
      setContext(c, e, context, CHILD(n, i));
  }
  return seq;
}
function astForDelStmt(c, n) {
  REQ(n, SYM.del_stmt);
  return new Delete_(astForExprlist(c, CHILD(n, 1), Del), n.lineno, n.col_offset);
}
function astForGlobalStmt(c, n) {
  REQ(n, SYM.global_stmt);
  var s = [];
  for (var i = 1; i < NCH(n); i += 2) {
    s[(i - 1) / 2] = strobj(CHILD(n, i).value);
  }
  return new Global(s, n.lineno, n.col_offset);
}
function astForAssertStmt(c, n) {
  REQ(n, SYM.assert_stmt);
  if (NCH(n) === 2)
    return new Assert(astForExpr(c, CHILD(n, 1)), null, n.lineno, n.col_offset);
  else if (NCH(n) === 4)
    return new Assert(astForExpr(c, CHILD(n, 1)), astForExpr(c, CHILD(n, 3)), n.lineno, n.col_offset);
  goog.asserts.fail('improper number of parts to assert stmt');
}
function aliasForImportName(c, n) {
  loop:
    while (true) {
      switch (n.type) {
      case SYM.import_as_name:
        var str = null;
        var name = strobj(CHILD(n, 0).value);
        if (NCH(n) === 3)
          str = CHILD(n, 2).value;
        return new alias(name, str == null ? null : strobj(str));
      case SYM.dotted_as_name:
        if (NCH(n) === 1) {
          n = CHILD(n, 0);
          continue loop;
        } else {
          var a = aliasForImportName(c, CHILD(n, 0));
          goog.asserts.assert(!a.asname);
          a.asname = strobj(CHILD(n, 2).value);
          return a;
        }
      case SYM.dotted_name:
        if (NCH(n) === 1)
          return new alias(strobj(CHILD(n, 0).value), null);
        else {
          var str = '';
          for (var i = 0; i < NCH(n); i += 2)
            str += CHILD(n, i).value + '.';
          return new alias(strobj(str.substr(0, str.length - 1)), null);
        }
      case TOK.T_STAR:
        return new alias(strobj('*'), null);
      default:
        throw new Sk.builtin.SyntaxError('unexpected import name', c.c_filename, n.lineno);
      }
      break;
    }
}
function astForImportStmt(c, n) {
  REQ(n, SYM.import_stmt);
  var lineno = n.lineno;
  var col_offset = n.col_offset;
  n = CHILD(n, 0);
  if (n.type === SYM.import_name) {
    n = CHILD(n, 1);
    REQ(n, SYM.dotted_as_names);
    var aliases = [];
    for (var i = 0; i < NCH(n); i += 2)
      aliases[i / 2] = aliasForImportName(c, CHILD(n, i));
    return new Import_(aliases, lineno, col_offset);
  } else if (n.type === SYM.import_from) {
    var mod = null;
    var ndots = 0;
    var nchildren;
    for (var idx = 1; idx < NCH(n); ++idx) {
      if (CHILD(n, idx).type === SYM.dotted_name) {
        mod = aliasForImportName(c, CHILD(n, idx));
        idx++;
        break;
      } else if (CHILD(n, idx).type !== TOK.T_DOT)
        break;
      ndots++;
    }
    ++idx;
    switch (CHILD(n, idx).type) {
    case TOK.T_STAR:
      n = CHILD(n, idx);
      nchildren = 1;
      break;
    case TOK.T_LPAR:
      n = CHILD(n, idx + 1);
      nchildren = NCH(n);
      break;
    case SYM.import_as_names:
      n = CHILD(n, idx);
      nchildren = NCH(n);
      if (nchildren % 2 === 0)
        throw new Sk.builtin.SyntaxError('trailing comma not allowed without surrounding parentheses', c.c_filename, n.lineno);
      break;
    default:
      throw new Sk.builtin.SyntaxError('Unexpected node-type in from-import', c.c_filename, n.lineno);
    }
    var aliases = [];
    if (n.type === TOK.T_STAR)
      aliases[0] = aliasForImportName(c, n);
    else
      for (var i = 0; i < NCH(n); i += 2)
        aliases[i / 2] = aliasForImportName(c, CHILD(n, i));
    var modname = mod ? mod.name.v : '';
    return new ImportFrom(strobj(modname), aliases, ndots, lineno, col_offset);
  }
  throw new Sk.builtin.SyntaxError('unknown import statement', c.c_filename, n.lineno);
}
function astForTestlistGexp(c, n) {
  goog.asserts.assert(n.type === SYM.testlist_gexp || n.type === SYM.argument);
  if (NCH(n) > 1 && CHILD(n, 1).type === SYM.gen_for)
    return astForGenexp(c, n);
  return astForTestlist(c, n);
}
function astForListcomp(c, n) {
  function countListFors(c, n) {
    var nfors = 0;
    var ch = CHILD(n, 1);
    count_list_for:
      while (true) {
        nfors++;
        REQ(ch, SYM.list_for);
        if (NCH(ch) === 5)
          ch = CHILD(ch, 4);
        else
          return nfors;
        count_list_iter:
          while (true) {
            REQ(ch, SYM.list_iter);
            ch = CHILD(ch, 0);
            if (ch.type === SYM.list_for)
              continue count_list_for;
            else if (ch.type === SYM.list_if) {
              if (NCH(ch) === 3) {
                ch = CHILD(ch, 2);
                continue count_list_iter;
              } else
                return nfors;
            }
            break;
          }
        break;
      }
  }
  function countListIfs(c, n) {
    var nifs = 0;
    while (true) {
      REQ(n, SYM.list_iter);
      if (CHILD(n, 0).type === SYM.list_for)
        return nifs;
      n = CHILD(n, 0);
      REQ(n, SYM.list_if);
      nifs++;
      if (NCH(n) == 2)
        return nifs;
      n = CHILD(n, 2);
    }
  }
  REQ(n, SYM.listmaker);
  goog.asserts.assert(NCH(n) > 1);
  var elt = astForExpr(c, CHILD(n, 0));
  var nfors = countListFors(c, n);
  var listcomps = [];
  var ch = CHILD(n, 1);
  for (var i = 0; i < nfors; ++i) {
    REQ(ch, SYM.list_for);
    var forch = CHILD(ch, 1);
    var t = astForExprlist(c, forch, Store);
    var expression = astForTestlist(c, CHILD(ch, 3));
    var lc;
    if (NCH(forch) === 1)
      lc = new comprehension(t[0], expression, []);
    else
      lc = new comprehension(new Tuple(t, Store, ch.lineno, ch.col_offset), expression, []);
    if (NCH(ch) === 5) {
      ch = CHILD(ch, 4);
      var nifs = countListIfs(c, ch);
      var ifs = [];
      for (var j = 0; j < nifs; ++j) {
        REQ(ch, SYM.list_iter);
        ch = CHILD(ch, 0);
        REQ(ch, SYM.list_if);
        ifs[j] = astForExpr(c, CHILD(ch, 1));
        if (NCH(ch) === 3)
          ch = CHILD(ch, 2);
      }
      if (ch.type === SYM.list_iter)
        ch = CHILD(ch, 0);
      lc.ifs = ifs;
    }
    listcomps[i] = lc;
  }
  return new ListComp(elt, listcomps, n.lineno, n.col_offset);
}
function astForFactor(c, n) {
  if (CHILD(n, 0).type === TOK.T_MINUS && NCH(n) === 2) {
    var pfactor = CHILD(n, 1);
    if (pfactor.type === SYM.factor && NCH(pfactor) === 1) {
      var ppower = CHILD(pfactor, 0);
      if (ppower.type === SYM.power && NCH(ppower) === 1) {
        var patom = CHILD(ppower, 0);
        if (patom.type === SYM.atom) {
          var pnum = CHILD(patom, 0);
          if (pnum.type === TOK.T_NUMBER) {
            pnum.value = '-' + pnum.value;
            return astForAtom(c, patom);
          }
        }
      }
    }
  }
  var expression = astForExpr(c, CHILD(n, 1));
  switch (CHILD(n, 0).type) {
  case TOK.T_PLUS:
    return new UnaryOp(UAdd, expression, n.lineno, n.col_offset);
  case TOK.T_MINUS:
    return new UnaryOp(USub, expression, n.lineno, n.col_offset);
  case TOK.T_TILDE:
    return new UnaryOp(Invert, expression, n.lineno, n.col_offset);
  }
  goog.asserts.fail('unhandled factor');
}
function astForForStmt(c, n) {
  var seq = [];
  REQ(n, SYM.for_stmt);
  if (NCH(n) === 9)
    seq = astForSuite(c, CHILD(n, 8));
  var nodeTarget = CHILD(n, 1);
  var _target = astForExprlist(c, nodeTarget, Store);
  var target;
  if (NCH(nodeTarget) === 1)
    target = _target[0];
  else
    target = new Tuple(_target, Store, n.lineno, n.col_offset);
  return new For_(target, astForTestlist(c, CHILD(n, 3)), astForSuite(c, CHILD(n, 5)), seq, n.lineno, n.col_offset);
}
function astForCall(c, n, func) {
  REQ(n, SYM.arglist);
  var nargs = 0;
  var nkeywords = 0;
  var ngens = 0;
  for (var i = 0; i < NCH(n); ++i) {
    var ch = CHILD(n, i);
    if (ch.type === SYM.argument) {
      if (NCH(ch) === 1)
        nargs++;
      else if (CHILD(ch, 1).type === SYM.gen_for)
        ngens++;
      else
        nkeywords++;
    }
  }
  if (ngens > 1 || ngens && (nargs || nkeywords))
    throw new Sk.builtin.SyntaxError('Generator expression must be parenthesized if not sole argument', c.c_filename, n.lineno);
  if (nargs + nkeywords + ngens > 255)
    throw new Sk.builtin.SyntaxError('more than 255 arguments', c.c_filename, n.lineno);
  var args = [];
  var keywords = [];
  nargs = 0;
  nkeywords = 0;
  var vararg = null;
  var kwarg = null;
  for (var i = 0; i < NCH(n); ++i) {
    var ch = CHILD(n, i);
    if (ch.type === SYM.argument) {
      if (NCH(ch) === 1) {
        if (nkeywords)
          throw new Sk.builtin.SyntaxError('non-keyword arg after keyword arg', c.c_filename, n.lineno);
        if (vararg)
          throw new Sk.builtin.SyntaxError('only named arguments may follow *expression', c.c_filename, n.lineno);
        args[nargs++] = astForExpr(c, CHILD(ch, 0));
      } else if (CHILD(ch, 1).type === SYM.gen_for)
        args[nargs++] = astForGenexp(c, ch);
      else {
        var e = astForExpr(c, CHILD(ch, 0));
        if (e.constructor === Lambda)
          throw new Sk.builtin.SyntaxError('lambda cannot contain assignment', c.c_filename, n.lineno);
        else if (e.constructor !== Name)
          throw new Sk.builtin.SyntaxError('keyword can\'t be an expression', c.c_filename, n.lineno);
        var key = e.id;
        forbiddenCheck(c, CHILD(ch, 0), key, n.lineno);
        for (var k = 0; k < nkeywords; ++k) {
          var tmp = keywords[k].arg;
          if (tmp === key)
            throw new Sk.builtin.SyntaxError('keyword argument repeated', c.c_filename, n.lineno);
        }
        keywords[nkeywords++] = new keyword(key, astForExpr(c, CHILD(ch, 2)));
      }
    } else if (ch.type === TOK.T_STAR)
      vararg = astForExpr(c, CHILD(n, ++i));
    else if (ch.type === TOK.T_DOUBLESTAR)
      kwarg = astForExpr(c, CHILD(n, ++i));
  }
  return new Call(func, args, keywords, vararg, kwarg, func.lineno, func.col_offset);
}
function astForTrailer(c, n, leftExpr) {
  REQ(n, SYM.trailer);
  if (CHILD(n, 0).type === TOK.T_LPAR) {
    if (NCH(n) === 2)
      return new Call(leftExpr, [], [], null, null, n.lineno, n.col_offset);
    else
      return astForCall(c, CHILD(n, 1), leftExpr);
  } else if (CHILD(n, 0).type === TOK.T_DOT)
    return new Attribute(leftExpr, strobj(CHILD(n, 1).value), Load, n.lineno, n.col_offset);
  else {
    REQ(CHILD(n, 0), TOK.T_LSQB);
    REQ(CHILD(n, 2), TOK.T_RSQB);
    n = CHILD(n, 1);
    if (NCH(n) === 1)
      return new Subscript(leftExpr, astForSlice(c, CHILD(n, 0)), Load, n.lineno, n.col_offset);
    else {
      var simple = true;
      var slices = [];
      for (var j = 0; j < NCH(n); j += 2) {
        var slc = astForSlice(c, CHILD(n, j));
        if (slc.constructor !== Index)
          simple = false;
        slices[j / 2] = slc;
      }
      if (!simple) {
        return new Subscript(leftExpr, new ExtSlice(slices), Load, n.lineno, n.col_offset);
      }
      var elts = [];
      for (var j = 0; j < slices.length; ++j) {
        var slc = slices[j];
        goog.asserts.assert(slc.constructor === Index && slc.value !== null && slc.value !== undefined);
        elts[j] = slc.value;
      }
      var e = new Tuple(elts, Load, n.lineno, n.col_offset);
      return new Subscript(leftExpr, new Index(e), Load, n.lineno, n.col_offset);
    }
  }
}
function astForFlowStmt(c, n) {
  var ch;
  REQ(n, SYM.flow_stmt);
  ch = CHILD(n, 0);
  switch (ch.type) {
  case SYM.break_stmt:
    return new Break_(n.lineno, n.col_offset);
  case SYM.continue_stmt:
    return new Continue_(n.lineno, n.col_offset);
  case SYM.yield_stmt:
    return new Expr(astForExpr(c, CHILD(ch, 0)), n.lineno, n.col_offset);
  case SYM.return_stmt:
    if (NCH(ch) === 1)
      return new Return_(null, n.lineno, n.col_offset);
    else
      return new Return_(astForTestlist(c, CHILD(ch, 1)), n.lineno, n.col_offset);
  case SYM.raise_stmt:
    if (NCH(ch) === 1)
      return new Raise(null, null, null, n.lineno, n.col_offset);
    else if (NCH(ch) === 2)
      return new Raise(astForExpr(c, CHILD(ch, 1)), null, null, n.lineno, n.col_offset);
    else if (NCH(ch) === 4)
      return new Raise(astForExpr(c, CHILD(ch, 1)), astForExpr(c, CHILD(ch, 3)), null, n.lineno, n.col_offset);
    else if (NCH(ch) === 6)
      return new Raise(astForExpr(c, CHILD(ch, 1)), astForExpr(c, CHILD(ch, 3)), astForExpr(c, CHILD(ch, 5)), n.lineno, n.col_offset);
  default:
    goog.asserts.fail('unexpected flow_stmt');
  }
  goog.asserts.fail('unhandled flow statement');
}
function astForArguments(c, n) {
  var ch;
  var vararg = null;
  var kwarg = null;
  if (n.type === SYM.parameters) {
    if (NCH(n) === 2)
      return new arguments_([], null, null, []);
    n = CHILD(n, 1);
  }
  REQ(n, SYM.varargslist);
  var args = [];
  var defaults = [];
  var foundDefault = false;
  var i = 0;
  var j = 0;
  var k = 0;
  while (i < NCH(n)) {
    ch = CHILD(n, i);
    switch (ch.type) {
    case SYM.fpdef:
      var complexArgs = 0;
      var parenthesized = 0;
      handle_fpdef:
        while (true) {
          if (i + 1 < NCH(n) && CHILD(n, i + 1).type === TOK.T_EQUAL) {
            defaults[j++] = astForExpr(c, CHILD(n, i + 2));
            i += 2;
            foundDefault = true;
          } else if (foundDefault) {
            if (parenthesized && !complexArgs)
              throw new Sk.builtin.SyntaxError('parenthesized arg with default', c.c_filename, n.lineno);
            throw new Sk.builtin.SyntaxError('non-default argument follows default argument', c.c_filename, n.lineno);
          }
          if (NCH(ch) === 3) {
            ch = CHILD(ch, 1);
            if (NCH(ch) !== 1) {
              throw new Sk.builtin.SyntaxError('tuple parameter unpacking has been removed', c.c_filename, n.lineno);
            } else {
              parenthesized = true;
              ch = CHILD(ch, 0);
              goog.asserts.assert(ch.type === SYM.fpdef);
              continue handle_fpdef;
            }
          }
          if (CHILD(ch, 0).type === TOK.T_NAME) {
            forbiddenCheck(c, n, CHILD(ch, 0).value, n.lineno);
            var id = strobj(CHILD(ch, 0).value);
            args[k++] = new Name(id, Param, ch.lineno, ch.col_offset);
          }
          i += 2;
          if (parenthesized)
            throw new Sk.builtin.SyntaxError('parenthesized argument names are invalid', c.c_filename, n.lineno);
          break;
        }
      break;
    case TOK.T_STAR:
      forbiddenCheck(c, CHILD(n, i + 1), CHILD(n, i + 1).value, n.lineno);
      vararg = strobj(CHILD(n, i + 1).value);
      i += 3;
      break;
    case TOK.T_DOUBLESTAR:
      forbiddenCheck(c, CHILD(n, i + 1), CHILD(n, i + 1).value, n.lineno);
      kwarg = strobj(CHILD(n, i + 1).value);
      i += 3;
      break;
    default:
      goog.asserts.fail('unexpected node in varargslist');
    }
  }
  return new arguments_(args, vararg, kwarg, defaults);
}
function astForFuncdef(c, n, decoratorSeq) {
  REQ(n, SYM.funcdef);
  var name = strobj(CHILD(n, 1).value);
  forbiddenCheck(c, CHILD(n, 1), CHILD(n, 1).value, n.lineno);
  var args = astForArguments(c, CHILD(n, 2));
  var body = astForSuite(c, CHILD(n, 4));
  return new FunctionDef(name, args, body, decoratorSeq, n.lineno, n.col_offset);
}
function astForClassBases(c, n) {
  goog.asserts.assert(NCH(n) > 0);
  REQ(n, SYM.testlist);
  if (NCH(n) === 1)
    return [astForExpr(c, CHILD(n, 0))];
  return seqForTestlist(c, n);
}
function astForClassdef(c, n, decoratorSeq) {
  REQ(n, SYM.classdef);
  forbiddenCheck(c, n, CHILD(n, 1).value, n.lineno);
  var classname = strobj(CHILD(n, 1).value);
  if (NCH(n) === 4)
    return new ClassDef(classname, [], astForSuite(c, CHILD(n, 3)), decoratorSeq, n.lineno, n.col_offset);
  if (CHILD(n, 3).type === TOK.T_RPAR)
    return new ClassDef(classname, [], astForSuite(c, CHILD(n, 5)), decoratorSeq, n.lineno, n.col_offset);
  var bases = astForClassBases(c, CHILD(n, 3));
  var s = astForSuite(c, CHILD(n, 6));
  return new ClassDef(classname, bases, s, decoratorSeq, n.lineno, n.col_offset);
}
function astForLambdef(c, n) {
  var args;
  var expression;
  if (NCH(n) === 3) {
    args = new arguments_([], null, null, []);
    expression = astForExpr(c, CHILD(n, 2));
  } else {
    args = astForArguments(c, CHILD(n, 1));
    expression = astForExpr(c, CHILD(n, 3));
  }
  return new Lambda(args, expression, n.lineno, n.col_offset);
}
function astForGenexp(c, n) {
  goog.asserts.assert(n.type === SYM.testlist_gexp || n.type === SYM.argument);
  goog.asserts.assert(NCH(n) > 1);
  function countGenFors(c, n) {
    var nfors = 0;
    var ch = CHILD(n, 1);
    count_gen_for:
      while (true) {
        nfors++;
        REQ(ch, SYM.gen_for);
        if (NCH(ch) === 5)
          ch = CHILD(ch, 4);
        else
          return nfors;
        count_gen_iter:
          while (true) {
            REQ(ch, SYM.gen_iter);
            ch = CHILD(ch, 0);
            if (ch.type === SYM.gen_for)
              continue count_gen_for;
            else if (ch.type === SYM.gen_if) {
              if (NCH(ch) === 3) {
                ch = CHILD(ch, 2);
                continue count_gen_iter;
              } else
                return nfors;
            }
            break;
          }
        break;
      }
    goog.asserts.fail('logic error in countGenFors');
  }
  function countGenIfs(c, n) {
    var nifs = 0;
    while (true) {
      REQ(n, SYM.gen_iter);
      if (CHILD(n, 0).type === SYM.gen_for)
        return nifs;
      n = CHILD(n, 0);
      REQ(n, SYM.gen_if);
      nifs++;
      if (NCH(n) == 2)
        return nifs;
      n = CHILD(n, 2);
    }
  }
  var elt = astForExpr(c, CHILD(n, 0));
  var nfors = countGenFors(c, n);
  var genexps = [];
  var ch = CHILD(n, 1);
  for (var i = 0; i < nfors; ++i) {
    REQ(ch, SYM.gen_for);
    var forch = CHILD(ch, 1);
    var t = astForExprlist(c, forch, Store);
    var expression = astForExpr(c, CHILD(ch, 3));
    var ge;
    if (NCH(forch) === 1)
      ge = new comprehension(t[0], expression, []);
    else
      ge = new comprehension(new Tuple(t, Store, ch.lineno, ch.col_offset), expression, []);
    if (NCH(ch) === 5) {
      ch = CHILD(ch, 4);
      var nifs = countGenIfs(c, ch);
      var ifs = [];
      for (var j = 0; j < nifs; ++j) {
        REQ(ch, SYM.gen_iter);
        ch = CHILD(ch, 0);
        REQ(ch, SYM.gen_if);
        expression = astForExpr(c, CHILD(ch, 1));
        ifs[j] = expression;
        if (NCH(ch) === 3)
          ch = CHILD(ch, 2);
      }
      if (ch.type === SYM.gen_iter)
        ch = CHILD(ch, 0);
      ge.ifs = ifs;
    }
    genexps[i] = ge;
  }
  return new GeneratorExp(elt, genexps, n.lineno, n.col_offset);
}
function astForWhileStmt(c, n) {
  REQ(n, SYM.while_stmt);
  if (NCH(n) === 4)
    return new While_(astForExpr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), [], n.lineno, n.col_offset);
  else if (NCH(n) === 7)
    return new While_(astForExpr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), astForSuite(c, CHILD(n, 6)), n.lineno, n.col_offset);
  goog.asserts.fail('wrong number of tokens for \'while\' stmt');
}
function astForAugassign(c, n) {
  REQ(n, SYM.augassign);
  n = CHILD(n, 0);
  switch (n.value.charAt(0)) {
  case '+':
    return Add;
  case '-':
    return Sub;
  case '/':
    if (n.value.charAt(1) === '/')
      return FloorDiv;
    return Div;
  case '%':
    return Mod;
  case '<':
    return LShift;
  case '>':
    return RShift;
  case '&':
    return BitAnd;
  case '^':
    return BitXor;
  case '|':
    return BitOr;
  case '*':
    if (n.value.charAt(1) === '*')
      return Pow;
    return Mult;
  default:
    goog.asserts.fail('invalid augassign');
  }
}
function astForBinop(c, n) {
  var result = new BinOp(astForExpr(c, CHILD(n, 0)), getOperator(CHILD(n, 1)), astForExpr(c, CHILD(n, 2)), n.lineno, n.col_offset);
  var nops = (NCH(n) - 1) / 2;
  for (var i = 1; i < nops; ++i) {
    var nextOper = CHILD(n, i * 2 + 1);
    var newoperator = getOperator(nextOper);
    var tmp = astForExpr(c, CHILD(n, i * 2 + 2));
    result = new BinOp(result, newoperator, tmp, nextOper.lineno, nextOper.col_offset);
  }
  return result;
}
function astForTestlist(c, n) {
  goog.asserts.assert(NCH(n) > 0);
  if (n.type === SYM.testlist_gexp) {
    if (NCH(n) > 1) {
      goog.asserts.assert(CHILD(n, 1).type !== SYM.gen_for);
    }
  } else {
    goog.asserts.assert(n.type === SYM.testlist || n.type === SYM.testlist_safe || n.type === SYM.testlist1);
  }
  if (NCH(n) === 1) {
    return astForExpr(c, CHILD(n, 0));
  } else {
    return new Tuple(seqForTestlist(c, n), Load, n.lineno, n.col_offset);
  }
}
function astForExprStmt(c, n) {
  REQ(n, SYM.expr_stmt);
  if (NCH(n) === 1)
    return new Expr(astForTestlist(c, CHILD(n, 0)), n.lineno, n.col_offset);
  else if (CHILD(n, 1).type === SYM.augassign) {
    var ch = CHILD(n, 0);
    var expr1 = astForTestlist(c, ch);
    switch (expr1.constructor) {
    case GeneratorExp:
      throw new Sk.builtin.SyntaxError('augmented assignment to generator expression not possible', c.c_filename, n.lineno);
    case Yield:
      throw new Sk.builtin.SyntaxError('augmented assignment to yield expression not possible', c.c_filename, n.lineno);
    case Name:
      var varName = expr1.id;
      forbiddenCheck(c, ch, varName, n.lineno);
      break;
    case Attribute:
    case Subscript:
      break;
    default:
      throw new Sk.builtin.SyntaxError('illegal expression for augmented assignment', c.c_filename, n.lineno);
    }
    setContext(c, expr1, Store, ch);
    ch = CHILD(n, 2);
    var expr2;
    if (ch.type === SYM.testlist)
      expr2 = astForTestlist(c, ch);
    else
      expr2 = astForExpr(c, ch);
    return new AugAssign(expr1, astForAugassign(c, CHILD(n, 1)), expr2, n.lineno, n.col_offset);
  } else {
    REQ(CHILD(n, 1), TOK.T_EQUAL);
    var targets = [];
    for (var i = 0; i < NCH(n) - 2; i += 2) {
      var ch = CHILD(n, i);
      if (ch.type === SYM.yield_expr)
        throw new Sk.builtin.SyntaxError('assignment to yield expression not possible', c.c_filename, n.lineno);
      var e = astForTestlist(c, ch);
      setContext(c, e, Store, CHILD(n, i));
      targets[i / 2] = e;
    }
    var value = CHILD(n, NCH(n) - 1);
    var expression;
    if (value.type === SYM.testlist)
      expression = astForTestlist(c, value);
    else
      expression = astForExpr(c, value);
    return new Assign(targets, expression, n.lineno, n.col_offset);
  }
}
function astForIfexpr(c, n) {
  goog.asserts.assert(NCH(n) === 5);
  return new IfExp(astForExpr(c, CHILD(n, 2)), astForExpr(c, CHILD(n, 0)), astForExpr(c, CHILD(n, 4)), n.lineno, n.col_offset);
}
function parsestr(c, s) {
  var encodeUtf8 = function (s) {
    return unescape(encodeURIComponent(s));
  };
  var decodeUtf8 = function (s) {
    return decodeURIComponent(escape(s));
  };
  var decodeEscape = function (s, quote) {
    var len = s.length;
    var ret = '';
    for (var i = 0; i < len; ++i) {
      var c = s.charAt(i);
      if (c === '\\') {
        ++i;
        c = s.charAt(i);
        if (c === 'n')
          ret += '\n';
        else if (c === '\\')
          ret += '\\';
        else if (c === 't')
          ret += '\t';
        else if (c === 'r')
          ret += '\r';
        else if (c === 'b')
          ret += '\b';
        else if (c === 'f')
          ret += '\f';
        else if (c === 'v')
          ret += '\x0B';
        else if (c === '0')
          ret += '\0';
        else if (c === '"')
          ret += '"';
        else if (c === '\'')
          ret += '\'';
        else if (c === '\n') {
        } else if (c === 'x') {
          var d0 = s.charAt(++i);
          var d1 = s.charAt(++i);
          ret += String.fromCharCode(parseInt(d0 + d1, 16));
        } else if (c === 'u' || c === 'U') {
          var d0 = s.charAt(++i);
          var d1 = s.charAt(++i);
          var d2 = s.charAt(++i);
          var d3 = s.charAt(++i);
          ret += String.fromCharCode(parseInt(d0 + d1, 16), parseInt(d2 + d3, 16));
        } else {
          ret += '\\' + c;
        }
      } else {
        ret += c;
      }
    }
    return ret;
  };
  var quote = s.charAt(0);
  var rawmode = false;
  if (quote === 'u' || quote === 'U') {
    s = s.substr(1);
    quote = s.charAt(0);
  } else if (quote === 'r' || quote === 'R') {
    s = s.substr(1);
    quote = s.charAt(0);
    rawmode = true;
  }
  goog.asserts.assert(quote !== 'b' && quote !== 'B', 'todo; haven\'t done b\'\' strings yet');
  goog.asserts.assert(quote === '\'' || quote === '"' && s.charAt(s.length - 1) === quote);
  s = s.substr(1, s.length - 2);
  if (s.length >= 4 && s.charAt(0) === quote && s.charAt(1) === quote) {
    goog.asserts.assert(s.charAt(s.length - 1) === quote && s.charAt(s.length - 2) === quote);
    s = s.substr(2, s.length - 4);
  }
  if (rawmode || s.indexOf('\\') === -1) {
    return strobj(decodeUtf8(s));
  }
  return strobj(decodeEscape(s, quote));
}
function parsestrplus(c, n) {
  REQ(CHILD(n, 0), TOK.T_STRING);
  var ret = new Sk.builtin.str('');
  for (var i = 0; i < NCH(n); ++i) {
    try {
      ret = ret.sq$concat(parsestr(c, CHILD(n, i).value));
    } catch (x) {
      throw new Sk.builtin.SyntaxError('invalid string (possibly contains a unicode character)', c.c_filename, CHILD(n, i).lineno);
    }
  }
  return ret;
}
function parsenumber(c, s, lineno) {
  var end = s.charAt(s.length - 1);
  if (end === 'j' || end === 'J') {
    throw new Sk.builtin.SyntaxError('complex numbers are currently unsupported', c.c_filename, lineno);
  }
  if (end === 'l' || end === 'L') {
    return Sk.longFromStr(s.substr(0, s.length - 1), 0);
  }
  if (s.indexOf('.') !== -1) {
    return new Sk.builtin.nmber(parseFloat(s), Sk.builtin.nmber.float$);
  }
  var tmp = s;
  var val;
  var neg = false;
  if (s.charAt(0) === '-') {
    tmp = s.substr(1);
    neg = true;
  }
  if (tmp.charAt(0) === '0' && (tmp.charAt(1) === 'x' || tmp.charAt(1) === 'X')) {
    tmp = tmp.substring(2);
    val = parseInt(tmp, 16);
  } else if (s.indexOf('e') !== -1 || s.indexOf('E') !== -1) {
    return new Sk.builtin.nmber(parseFloat(s), Sk.builtin.nmber.float$);
  } else if (tmp.charAt(0) === '0' && (tmp.charAt(1) === 'b' || tmp.charAt(1) === 'B')) {
    tmp = tmp.substring(2);
    val = parseInt(tmp, 2);
  } else if (tmp.charAt(0) === '0') {
    if (tmp === '0') {
      val = 0;
    } else {
      tmp = tmp.substring(1);
      if (tmp.charAt(0) === 'o' || tmp.charAt(0) === 'O') {
        tmp = tmp.substring(1);
      }
      val = parseInt(tmp, 8);
    }
  } else {
    val = parseInt(tmp, 10);
  }
  if (val > Sk.builtin.lng.threshold$ && Math.floor(val) === val && (s.indexOf('e') === -1 && s.indexOf('E') === -1)) {
    return Sk.longFromStr(s, 0);
  }
  if (neg) {
    return new Sk.builtin.nmber(-val, Sk.builtin.int$);
  } else {
    return new Sk.builtin.nmber(val, Sk.builtin.int$);
  }
}
function astForSlice(c, n) {
  REQ(n, SYM.subscript);
  var ch = CHILD(n, 0);
  var lower = null;
  var upper = null;
  var step = null;
  if (ch.type === TOK.T_DOT)
    return new Ellipsis();
  if (NCH(n) === 1 && ch.type === SYM.test)
    return new Index(astForExpr(c, ch));
  if (ch.type === SYM.test)
    lower = astForExpr(c, ch);
  if (ch.type === TOK.T_COLON) {
    if (NCH(n) > 1) {
      var n2 = CHILD(n, 1);
      if (n2.type === SYM.test)
        upper = astForExpr(c, n2);
    }
  } else if (NCH(n) > 2) {
    var n2 = CHILD(n, 2);
    if (n2.type === SYM.test)
      upper = astForExpr(c, n2);
  }
  ch = CHILD(n, NCH(n) - 1);
  if (ch.type === SYM.sliceop) {
    if (NCH(ch) === 1) {
      ch = CHILD(ch, 0);
      step = new Name(strobj('None'), Load, ch.lineno, ch.col_offset);
    } else {
      ch = CHILD(ch, 1);
      if (ch.type === SYM.test)
        step = astForExpr(c, ch);
    }
  }
  return new Slice(lower, upper, step);
}
function astForAtom(c, n) {
  var ch = CHILD(n, 0);
  switch (ch.type) {
  case TOK.T_NAME:
    return new Name(strobj(ch.value), Load, n.lineno, n.col_offset);
  case TOK.T_STRING:
    return new Str(parsestrplus(c, n), n.lineno, n.col_offset);
  case TOK.T_NUMBER:
    return new Num(parsenumber(c, ch.value, n.lineno), n.lineno, n.col_offset);
  case TOK.T_LPAR:
    ch = CHILD(n, 1);
    if (ch.type === TOK.T_RPAR)
      return new Tuple([], Load, n.lineno, n.col_offset);
    if (ch.type === SYM.yield_expr)
      return astForExpr(c, ch);
    if (NCH(ch) > 1 && CHILD(ch, 1).type === SYM.gen_for)
      return astForGenexp(c, ch);
    return astForTestlistGexp(c, ch);
  case TOK.T_LSQB:
    ch = CHILD(n, 1);
    if (ch.type === TOK.T_RSQB)
      return new List([], Load, n.lineno, n.col_offset);
    REQ(ch, SYM.listmaker);
    if (NCH(ch) === 1 || CHILD(ch, 1).type === TOK.T_COMMA)
      return new List(seqForTestlist(c, ch), Load, n.lineno, n.col_offset);
    else
      return astForListcomp(c, ch);
  case TOK.T_LBRACE:
    ch = CHILD(n, 1);
    var size = Math.floor((NCH(ch) + 1) / 4);
    var keys = [];
    var values = [];
    for (var i = 0; i < NCH(ch); i += 4) {
      keys[i / 4] = astForExpr(c, CHILD(ch, i));
      values[i / 4] = astForExpr(c, CHILD(ch, i + 2));
    }
    return new Dict(keys, values, n.lineno, n.col_offset);
  case TOK.T_BACKQUOTE:
    throw new Sk.builtin.SyntaxError('backquote not supported, use repr()', c.c_filename, n.lineno);
  default:
    goog.asserts.fail('unhandled atom', ch.type);
  }
}
function astForPower(c, n) {
  REQ(n, SYM.power);
  var e = astForAtom(c, CHILD(n, 0));
  if (NCH(n) === 1)
    return e;
  for (var i = 1; i < NCH(n); ++i) {
    var ch = CHILD(n, i);
    if (ch.type !== SYM.trailer)
      break;
    var tmp = astForTrailer(c, ch, e);
    tmp.lineno = e.lineno;
    tmp.col_offset = e.col_offset;
    e = tmp;
  }
  if (CHILD(n, NCH(n) - 1).type === SYM.factor) {
    var f = astForExpr(c, CHILD(n, NCH(n) - 1));
    e = new BinOp(e, Pow, f, n.lineno, n.col_offset);
  }
  return e;
}
function astForExpr(c, n) {
  LOOP:
    while (true) {
      switch (n.type) {
      case SYM.test:
      case SYM.old_test:
        if (CHILD(n, 0).type === SYM.lambdef || CHILD(n, 0).type === SYM.old_lambdef)
          return astForLambdef(c, CHILD(n, 0));
        else if (NCH(n) > 1)
          return astForIfexpr(c, n);
      case SYM.or_test:
      case SYM.and_test:
        if (NCH(n) === 1) {
          n = CHILD(n, 0);
          continue LOOP;
        }
        var seq = [];
        for (var i = 0; i < NCH(n); i += 2)
          seq[i / 2] = astForExpr(c, CHILD(n, i));
        if (CHILD(n, 1).value === 'and')
          return new BoolOp(And, seq, n.lineno, n.col_offset);
        goog.asserts.assert(CHILD(n, 1).value === 'or');
        return new BoolOp(Or, seq, n.lineno, n.col_offset);
      case SYM.not_test:
        if (NCH(n) === 1) {
          n = CHILD(n, 0);
          continue LOOP;
        } else {
          return new UnaryOp(Not, astForExpr(c, CHILD(n, 1)), n.lineno, n.col_offset);
        }
      case SYM.comparison:
        if (NCH(n) === 1) {
          n = CHILD(n, 0);
          continue LOOP;
        } else {
          var ops = [];
          var cmps = [];
          for (var i = 1; i < NCH(n); i += 2) {
            ops[(i - 1) / 2] = astForCompOp(c, CHILD(n, i));
            cmps[(i - 1) / 2] = astForExpr(c, CHILD(n, i + 1));
          }
          return new Compare(astForExpr(c, CHILD(n, 0)), ops, cmps, n.lineno, n.col_offset);
        }
      case SYM.expr:
      case SYM.xor_expr:
      case SYM.and_expr:
      case SYM.shift_expr:
      case SYM.arith_expr:
      case SYM.term:
        if (NCH(n) === 1) {
          n = CHILD(n, 0);
          continue LOOP;
        }
        return astForBinop(c, n);
      case SYM.yield_expr:
        var exp = null;
        if (NCH(n) === 2) {
          exp = astForTestlist(c, CHILD(n, 1));
        }
        return new Yield(exp, n.lineno, n.col_offset);
      case SYM.factor:
        if (NCH(n) === 1) {
          n = CHILD(n, 0);
          continue LOOP;
        }
        return astForFactor(c, n);
      case SYM.power:
        return astForPower(c, n);
      default:
        goog.asserts.fail('unhandled expr', 'n.type: %d', n.type);
      }
      break;
    }
}
function astForPrintStmt(c, n) {
  var start = 1;
  var dest = null;
  REQ(n, SYM.print_stmt);
  if (NCH(n) >= 2 && CHILD(n, 1).type === TOK.T_RIGHTSHIFT) {
    dest = astForExpr(c, CHILD(n, 2));
    start = 4;
  }
  var seq = [];
  for (var i = start, j = 0; i < NCH(n); i += 2, ++j) {
    seq[j] = astForExpr(c, CHILD(n, i));
  }
  var nl = CHILD(n, NCH(n) - 1).type === TOK.T_COMMA ? false : true;
  return new Print(dest, seq, nl, n.lineno, n.col_offset);
}
function astForStmt(c, n) {
  if (n.type === SYM.stmt) {
    goog.asserts.assert(NCH(n) === 1);
    n = CHILD(n, 0);
  }
  if (n.type === SYM.simple_stmt) {
    goog.asserts.assert(numStmts(n) === 1);
    n = CHILD(n, 0);
  }
  if (n.type === SYM.small_stmt) {
    REQ(n, SYM.small_stmt);
    n = CHILD(n, 0);
    switch (n.type) {
    case SYM.expr_stmt:
      return astForExprStmt(c, n);
    case SYM.print_stmt:
      return astForPrintStmt(c, n);
    case SYM.del_stmt:
      return astForDelStmt(c, n);
    case SYM.pass_stmt:
      return new Pass(n.lineno, n.col_offset);
    case SYM.flow_stmt:
      return astForFlowStmt(c, n);
    case SYM.import_stmt:
      return astForImportStmt(c, n);
    case SYM.global_stmt:
      return astForGlobalStmt(c, n);
    case SYM.exec_stmt:
      return astForExecStmt(c, n);
    case SYM.assert_stmt:
      return astForAssertStmt(c, n);
    default:
      goog.asserts.fail('unhandled small_stmt');
    }
  } else {
    var ch = CHILD(n, 0);
    REQ(n, SYM.compound_stmt);
    switch (ch.type) {
    case SYM.if_stmt:
      return astForIfStmt(c, ch);
    case SYM.while_stmt:
      return astForWhileStmt(c, ch);
    case SYM.for_stmt:
      return astForForStmt(c, ch);
    case SYM.try_stmt:
      return astForTryStmt(c, ch);
    case SYM.with_stmt:
      return astForWithStmt(c, ch);
    case SYM.funcdef:
      return astForFuncdef(c, ch, []);
    case SYM.classdef:
      return astForClassdef(c, ch, []);
    case SYM.decorated:
      return astForDecorated(c, ch);
    default:
      goog.asserts.assert('unhandled compound_stmt');
    }
  }
}
Sk.astFromParse = function (n, filename) {
  var c = new Compiling('utf-8', filename);
  var stmts = [];
  var ch;
  var k = 0;
  switch (n.type) {
  case SYM.file_input:
    for (var i = 0; i < NCH(n) - 1; ++i) {
      var ch = CHILD(n, i);
      if (n.type === TOK.T_NEWLINE)
        continue;
      REQ(ch, SYM.stmt);
      var num = numStmts(ch);
      if (num === 1) {
        stmts[k++] = astForStmt(c, ch);
      } else {
        ch = CHILD(ch, 0);
        REQ(ch, SYM.simple_stmt);
        for (var j = 0; j < num; ++j) {
          stmts[k++] = astForStmt(c, CHILD(ch, j * 2));
        }
      }
    }
    return new Module(stmts);
  case SYM.eval_input:
    goog.asserts.fail('todo;');
  case SYM.single_input:
    goog.asserts.fail('todo;');
  default:
    goog.asserts.fail('todo;');
  }
};
Sk.astDump = function (node) {
  var spaces = function (n) {
    var ret = '';
    for (var i = 0; i < n; ++i)
      ret += ' ';
    return ret;
  };
  var _format = function (node, indent) {
    if (node === null) {
      return indent + 'None';
    } else if (node.prototype && node.prototype._astname !== undefined && node.prototype._isenum) {
      return indent + node.prototype._astname + '()';
    } else if (node._astname !== undefined) {
      var namelen = spaces(node._astname.length + 1);
      var fields = [];
      for (var i = 0; i < node._fields.length; i += 2) {
        var a = node._fields[i];
        var b = node._fields[i + 1](node);
        var fieldlen = spaces(a.length + 1);
        fields.push([
          a,
          _format(b, indent + namelen + fieldlen)
        ]);
      }
      var attrs = [];
      for (var i = 0; i < fields.length; ++i) {
        var field = fields[i];
        attrs.push(field[0] + '=' + field[1].replace(/^\s+/, ''));
      }
      var fieldstr = attrs.join(',\n' + indent + namelen);
      return indent + node._astname + '(' + fieldstr + ')';
    } else if (goog.isArrayLike(node)) {
      var elems = [];
      for (var i = 0; i < node.length; ++i) {
        var x = node[i];
        elems.push(_format(x, indent + ' '));
      }
      var elemsstr = elems.join(',\n');
      return indent + '[' + elemsstr.replace(/^\s+/, '') + ']';
    } else {
      var ret;
      if (node === true)
        ret = 'True';
      else if (node === false)
        ret = 'False';
      else if (node instanceof Sk.builtin.lng)
        ret = node.tp$str().v;
      else if (node instanceof Sk.builtin.str)
        ret = node.tp$repr().v;
      else
        ret = '' + node;
      return indent + ret;
    }
  };
  return _format(node, '');
};
goog.exportSymbol('Sk.astFromParse', Sk.astFromParse);
goog.exportSymbol('Sk.astDump', Sk.astDump);
var DEF_GLOBAL = 1;
var DEF_LOCAL = 2;
var DEF_PARAM = 2 << 1;
var USE = 2 << 2;
var DEF_STAR = 2 << 3;
var DEF_DOUBLESTAR = 2 << 4;
var DEF_INTUPLE = 2 << 5;
var DEF_FREE = 2 << 6;
var DEF_FREE_GLOBAL = 2 << 7;
var DEF_FREE_CLASS = 2 << 8;
var DEF_IMPORT = 2 << 9;
var DEF_BOUND = DEF_LOCAL | DEF_PARAM | DEF_IMPORT;
var SCOPE_OFF = 11;
var SCOPE_MASK = 7;
var LOCAL = 1;
var GLOBAL_EXPLICIT = 2;
var GLOBAL_IMPLICIT = 3;
var FREE = 4;
var CELL = 5;
var OPT_IMPORT_STAR = 1;
var OPT_EXEC = 2;
var OPT_BARE_EXEC = 4;
var OPT_TOPLEVEL = 8;
var GENERATOR = 2;
var GENERATOR_EXPRESSION = 2;
var ModuleBlock = 'module';
var FunctionBlock = 'function';
var ClassBlock = 'class';
function Symbol(name, flags, namespaces) {
  this.__name = name;
  this.__flags = flags;
  this.__scope = flags >> SCOPE_OFF & SCOPE_MASK;
  this.__namespaces = namespaces || [];
}
;
Symbol.prototype.get_name = function () {
  return this.__name;
};
Symbol.prototype.is_referenced = function () {
  return !!(this.__flags & USE);
};
Symbol.prototype.is_parameter = function () {
  return !!(this.__flags & DEF_PARAM);
};
Symbol.prototype.is_global = function () {
  return this.__scope === GLOBAL_IMPLICIT || this.__scope == GLOBAL_EXPLICIT;
};
Symbol.prototype.is_declared_global = function () {
  return this.__scope == GLOBAL_EXPLICIT;
};
Symbol.prototype.is_local = function () {
  return !!(this.__flags & DEF_BOUND);
};
Symbol.prototype.is_free = function () {
  return this.__scope == FREE;
};
Symbol.prototype.is_imported = function () {
  return !!(this.__flags & DEF_IMPORT);
};
Symbol.prototype.is_assigned = function () {
  return !!(this.__flags & DEF_LOCAL);
};
Symbol.prototype.is_namespace = function () {
  return this.__namespaces && this.__namespaces.length > 0;
};
Symbol.prototype.get_namespaces = function () {
  return this.__namespaces;
};
var astScopeCounter = 0;
function SymbolTableScope(table, name, type, ast, lineno) {
  this.symFlags = {};
  this.name = name;
  this.varnames = [];
  this.children = [];
  this.blockType = type;
  this.isNested = false;
  this.hasFree = false;
  this.childHasFree = false;
  this.generator = false;
  this.varargs = false;
  this.varkeywords = false;
  this.returnsValue = false;
  this.lineno = lineno;
  this.table = table;
  if (table.cur && (table.cur.nested || table.cur.blockType === FunctionBlock))
    this.isNested = true;
  ast.scopeId = astScopeCounter++;
  table.stss[ast.scopeId] = this;
  this.symbols = {};
}
SymbolTableScope.prototype.get_type = function () {
  return this.blockType;
};
SymbolTableScope.prototype.get_name = function () {
  return this.name;
};
SymbolTableScope.prototype.get_lineno = function () {
  return this.lineno;
};
SymbolTableScope.prototype.is_nested = function () {
  return this.isNested;
};
SymbolTableScope.prototype.has_children = function () {
  return this.children.length > 0;
};
SymbolTableScope.prototype.get_identifiers = function () {
  return this._identsMatching(function (x) {
    return true;
  });
};
SymbolTableScope.prototype.lookup = function (name) {
  var sym;
  if (!this.symbols.hasOwnProperty(name)) {
    var flags = this.symFlags[name];
    var namespaces = this.__check_children(name);
    sym = this.symbols[name] = new Symbol(name, flags, namespaces);
  } else {
    sym = this.symbols[name];
  }
  return sym;
};
SymbolTableScope.prototype.__check_children = function (name) {
  var ret = [];
  for (var i = 0; i < this.children.length; ++i) {
    var child = this.children[i];
    if (child.name === name)
      ret.push(child);
  }
  return ret;
};
SymbolTableScope.prototype._identsMatching = function (f) {
  var ret = [];
  for (var k in this.symFlags) {
    if (this.symFlags.hasOwnProperty(k)) {
      if (f(this.symFlags[k]))
        ret.push(k);
    }
  }
  ret.sort();
  return ret;
};
SymbolTableScope.prototype.get_parameters = function () {
  goog.asserts.assert(this.get_type() == 'function', 'get_parameters only valid for function scopes');
  if (!this._funcParams)
    this._funcParams = this._identsMatching(function (x) {
      return x & DEF_PARAM;
    });
  return this._funcParams;
};
SymbolTableScope.prototype.get_locals = function () {
  goog.asserts.assert(this.get_type() == 'function', 'get_locals only valid for function scopes');
  if (!this._funcLocals)
    this._funcLocals = this._identsMatching(function (x) {
      return x & DEF_BOUND;
    });
  return this._funcLocals;
};
SymbolTableScope.prototype.get_globals = function () {
  goog.asserts.assert(this.get_type() == 'function', 'get_globals only valid for function scopes');
  if (!this._funcGlobals) {
    this._funcGlobals = this._identsMatching(function (x) {
      var masked = x >> SCOPE_OFF & SCOPE_MASK;
      return masked == GLOBAL_IMPLICIT || masked == GLOBAL_EXPLICIT;
    });
  }
  return this._funcGlobals;
};
SymbolTableScope.prototype.get_frees = function () {
  goog.asserts.assert(this.get_type() == 'function', 'get_frees only valid for function scopes');
  if (!this._funcFrees) {
    this._funcFrees = this._identsMatching(function (x) {
      var masked = x >> SCOPE_OFF & SCOPE_MASK;
      return masked == FREE;
    });
  }
  return this._funcFrees;
};
SymbolTableScope.prototype.get_methods = function () {
  goog.asserts.assert(this.get_type() == 'class', 'get_methods only valid for class scopes');
  if (!this._classMethods) {
    var all = [];
    for (var i = 0; i < this.children.length; ++i)
      all.push(this.children[i].name);
    all.sort();
    this._classMethods = all;
  }
  return this._classMethods;
};
SymbolTableScope.prototype.getScope = function (name) {
  var v = this.symFlags[name];
  if (v === undefined)
    return 0;
  return v >> SCOPE_OFF & SCOPE_MASK;
};
function SymbolTable(filename) {
  this.filename = filename;
  this.cur = null;
  this.top = null;
  this.stack = [];
  this.global = null;
  this.curClass = null;
  this.tmpname = 0;
  this.stss = {};
}
SymbolTable.prototype.getStsForAst = function (ast) {
  goog.asserts.assert(ast.scopeId !== undefined, 'ast wasn\'t added to st?');
  var v = this.stss[ast.scopeId];
  goog.asserts.assert(v !== undefined, 'unknown sym tab entry');
  return v;
};
SymbolTable.prototype.SEQStmt = function (nodes) {
  goog.asserts.assert(goog.isArrayLike(nodes), 'SEQ: nodes isn\'t array? got %s', nodes);
  var len = nodes.length;
  for (var i = 0; i < len; ++i) {
    var val = nodes[i];
    if (val)
      this.visitStmt(val);
  }
};
SymbolTable.prototype.SEQExpr = function (nodes) {
  goog.asserts.assert(goog.isArrayLike(nodes), 'SEQ: nodes isn\'t array? got %s', nodes);
  var len = nodes.length;
  for (var i = 0; i < len; ++i) {
    var val = nodes[i];
    if (val)
      this.visitExpr(val);
  }
};
SymbolTable.prototype.enterBlock = function (name, blockType, ast, lineno) {
  name = fixReservedNames(name);
  var prev = null;
  if (this.cur) {
    prev = this.cur;
    this.stack.push(this.cur);
  }
  this.cur = new SymbolTableScope(this, name, blockType, ast, lineno);
  if (name === 'top') {
    this.global = this.cur.symFlags;
  }
  if (prev) {
    prev.children.push(this.cur);
  }
};
SymbolTable.prototype.exitBlock = function () {
  this.cur = null;
  if (this.stack.length > 0)
    this.cur = this.stack.pop();
};
SymbolTable.prototype.visitParams = function (args, toplevel) {
  for (var i = 0; i < args.length; ++i) {
    var arg = args[i];
    if (arg.constructor === Name) {
      goog.asserts.assert(arg.ctx === Param || arg.ctx === Store && !toplevel);
      this.addDef(arg.id, DEF_PARAM, arg.lineno);
    } else {
      throw new Sk.builtin.SyntaxError('invalid expression in parameter list', this.filename);
    }
  }
};
SymbolTable.prototype.visitArguments = function (a, lineno) {
  if (a.args)
    this.visitParams(a.args, true);
  if (a.vararg) {
    this.addDef(a.vararg, DEF_PARAM, lineno);
    this.cur.varargs = true;
  }
  if (a.kwarg) {
    this.addDef(a.kwarg, DEF_PARAM, lineno);
    this.cur.varkeywords = true;
  }
};
SymbolTable.prototype.newTmpname = function (lineno) {
  this.addDef(new Sk.builtin.str('_[' + ++this.tmpname + ']'), DEF_LOCAL, lineno);
};
SymbolTable.prototype.addDef = function (name, flag, lineno) {
  var mangled = mangleName(this.curClass, new Sk.builtin.str(name)).v;
  mangled = fixReservedNames(mangled);
  var val = this.cur.symFlags[mangled];
  if (val !== undefined) {
    if (flag & DEF_PARAM && val & DEF_PARAM) {
      throw new Sk.builtin.SyntaxError('duplicate argument \'' + name.v + '\' in function definition', this.filename, lineno);
    }
    val |= flag;
  } else {
    val = flag;
  }
  this.cur.symFlags[mangled] = val;
  if (flag & DEF_PARAM) {
    this.cur.varnames.push(mangled);
  } else if (flag & DEF_GLOBAL) {
    val = flag;
    var fromGlobal = this.global[mangled];
    if (fromGlobal !== undefined)
      val |= fromGlobal;
    this.global[mangled] = val;
  }
};
SymbolTable.prototype.visitSlice = function (s) {
  switch (s.constructor) {
  case Slice:
    if (s.lower)
      this.visitExpr(s.lower);
    if (s.upper)
      this.visitExpr(s.upper);
    if (s.step)
      this.visitExpr(s.step);
    break;
  case ExtSlice:
    for (var i = 0; i < s.dims.length; ++i)
      this.visitSlice(s.dims[i]);
    break;
  case Index:
    this.visitExpr(s.value);
    break;
  case Ellipsis:
    break;
  }
};
SymbolTable.prototype.visitStmt = function (s) {
  goog.asserts.assert(s !== undefined, 'visitStmt called with undefined');
  switch (s.constructor) {
  case FunctionDef:
    this.addDef(s.name, DEF_LOCAL, s.lineno);
    if (s.args.defaults)
      this.SEQExpr(s.args.defaults);
    if (s.decorator_list)
      this.SEQExpr(s.decorator_list);
    this.enterBlock(s.name.v, FunctionBlock, s, s.lineno);
    this.visitArguments(s.args, s.lineno);
    this.SEQStmt(s.body);
    this.exitBlock();
    break;
  case ClassDef:
    this.addDef(s.name, DEF_LOCAL, s.lineno);
    this.SEQExpr(s.bases);
    if (s.decorator_list)
      this.SEQExpr(s.decorator_list);
    this.enterBlock(s.name.v, ClassBlock, s, s.lineno);
    var tmp = this.curClass;
    this.curClass = s.name;
    this.SEQStmt(s.body);
    this.curCalss = tmp;
    this.exitBlock();
    break;
  case Return_:
    if (s.value) {
      this.visitExpr(s.value);
      this.cur.returnsValue = true;
      if (this.cur.generator)
        throw new Sk.builtin.SyntaxError('\'return\' with argument inside generator', this.filename);
    }
    break;
  case Delete_:
    this.SEQExpr(s.targets);
    break;
  case Assign:
    this.SEQExpr(s.targets);
    this.visitExpr(s.value);
    break;
  case AugAssign:
    this.visitExpr(s.target);
    this.visitExpr(s.value);
    break;
  case Print:
    if (s.dest)
      this.visitExpr(s.dest);
    this.SEQExpr(s.values);
    break;
  case For_:
    this.visitExpr(s.target);
    this.visitExpr(s.iter);
    this.SEQStmt(s.body);
    if (s.orelse)
      this.SEQStmt(s.orelse);
    break;
  case While_:
    this.visitExpr(s.test);
    this.SEQStmt(s.body);
    if (s.orelse)
      this.SEQStmt(s.orelse);
    break;
  case If_:
    this.visitExpr(s.test);
    this.SEQStmt(s.body);
    if (s.orelse)
      this.SEQStmt(s.orelse);
    break;
  case Raise:
    if (s.type) {
      this.visitExpr(s.type);
      if (s.inst) {
        this.visitExpr(s.inst);
        if (s.tback)
          this.visitExpr(s.tback);
      }
    }
    break;
  case TryExcept:
    this.SEQStmt(s.body);
    this.SEQStmt(s.orelse);
    this.visitExcepthandlers(s.handlers);
    break;
  case TryFinally:
    this.SEQStmt(s.body);
    this.SEQStmt(s.finalbody);
    break;
  case Assert:
    this.visitExpr(s.test);
    if (s.msg)
      this.visitExpr(s.msg);
    break;
  case Import_:
  case ImportFrom:
    this.visitAlias(s.names, s.lineno);
    break;
  case Exec:
    this.visitExpr(s.body);
    if (s.globals) {
      this.visitExpr(s.globals);
      if (s.locals)
        this.visitExpr(s.locals);
    }
    break;
  case Global:
    var nameslen = s.names.length;
    for (var i = 0; i < nameslen; ++i) {
      var name = mangleName(this.curClass, s.names[i]).v;
      name = fixReservedNames(name);
      var cur = this.cur.symFlags[name];
      if (cur & (DEF_LOCAL | USE)) {
        if (cur & DEF_LOCAL) {
          throw new Sk.builtin.SyntaxError('name \'' + name + '\' is assigned to before global declaration', this.filename, s.lineno);
        } else
          throw new Sk.builtin.SyntaxError('name \'' + name + '\' is used prior to global declaration', this.filename, s.lineno);
      }
      this.addDef(new Sk.builtin.str(name), DEF_GLOBAL, s.lineno);
    }
    break;
  case Expr:
    this.visitExpr(s.value);
    break;
  case Pass:
  case Break_:
  case Continue_:
    break;
  case With_:
    this.newTmpname(s.lineno);
    this.visitExpr(s.context_expr);
    if (s.optional_vars) {
      this.newTmpname(s.lineno);
      this.visitExpr(s.optional_vars);
    }
    this.SEQStmt(s.body);
    break;
  default:
    goog.asserts.fail('Unhandled type ' + s.constructor.name + ' in visitStmt');
  }
};
SymbolTable.prototype.visitExpr = function (e) {
  goog.asserts.assert(e !== undefined, 'visitExpr called with undefined');
  switch (e.constructor) {
  case BoolOp:
    this.SEQExpr(e.values);
    break;
  case BinOp:
    this.visitExpr(e.left);
    this.visitExpr(e.right);
    break;
  case UnaryOp:
    this.visitExpr(e.operand);
    break;
  case Lambda:
    this.addDef(new Sk.builtin.str('lambda'), DEF_LOCAL, e.lineno);
    if (e.args.defaults)
      this.SEQExpr(e.args.defaults);
    this.enterBlock('lambda', FunctionBlock, e, e.lineno);
    this.visitArguments(e.args, e.lineno);
    this.visitExpr(e.body);
    this.exitBlock();
    break;
  case IfExp:
    this.visitExpr(e.test);
    this.visitExpr(e.body);
    this.visitExpr(e.orelse);
    break;
  case Dict:
    this.SEQExpr(e.keys);
    this.SEQExpr(e.values);
    break;
  case ListComp:
    this.newTmpname(e.lineno);
    this.visitExpr(e.elt);
    this.visitComprehension(e.generators, 0);
    break;
  case GeneratorExp:
    this.visitGenexp(e);
    break;
  case Yield:
    if (e.value)
      this.visitExpr(e.value);
    this.cur.generator = true;
    if (this.cur.returnsValue)
      throw new Sk.builtin.SyntaxError('\'return\' with argument inside generator', this.filename);
    break;
  case Compare:
    this.visitExpr(e.left);
    this.SEQExpr(e.comparators);
    break;
  case Call:
    this.visitExpr(e.func);
    this.SEQExpr(e.args);
    for (var i = 0; i < e.keywords.length; ++i)
      this.visitExpr(e.keywords[i].value);
    if (e.starargs)
      this.visitExpr(e.starargs);
    if (e.kwargs)
      this.visitExpr(e.kwargs);
    break;
  case Num:
  case Str:
    break;
  case Attribute:
    this.visitExpr(e.value);
    break;
  case Subscript:
    this.visitExpr(e.value);
    this.visitSlice(e.slice);
    break;
  case Name:
    this.addDef(e.id, e.ctx === Load ? USE : DEF_LOCAL, e.lineno);
    break;
  case List:
  case Tuple:
    this.SEQExpr(e.elts);
    break;
  default:
    goog.asserts.fail('Unhandled type ' + e.constructor.name + ' in visitExpr');
  }
};
SymbolTable.prototype.visitComprehension = function (lcs, startAt) {
  var len = lcs.length;
  for (var i = startAt; i < len; ++i) {
    var lc = lcs[i];
    this.visitExpr(lc.target);
    this.visitExpr(lc.iter);
    this.SEQExpr(lc.ifs);
  }
};
SymbolTable.prototype.visitAlias = function (names, lineno) {
  for (var i = 0; i < names.length; ++i) {
    var a = names[i];
    var name = a.asname === null ? a.name.v : a.asname.v;
    var storename = name;
    var dot = name.indexOf('.');
    if (dot !== -1)
      storename = name.substr(0, dot);
    if (name !== '*')
      this.addDef(new Sk.builtin.str(storename), DEF_IMPORT, lineno);
    else {
      if (this.cur.blockType !== ModuleBlock)
        throw new Sk.builtin.SyntaxError('import * only allowed at module level', this.filename);
    }
  }
};
SymbolTable.prototype.visitGenexp = function (e) {
  var outermost = e.generators[0];
  this.visitExpr(outermost.iter);
  this.enterBlock('genexpr', FunctionBlock, e, e.lineno);
  this.cur.generator = true;
  this.addDef(new Sk.builtin.str('.0'), DEF_PARAM, e.lineno);
  this.visitExpr(outermost.target);
  this.SEQExpr(outermost.ifs);
  this.visitComprehension(e.generators, 1);
  this.visitExpr(e.elt);
  this.exitBlock();
};
SymbolTable.prototype.visitExcepthandlers = function (handlers) {
  for (var i = 0, eh; eh = handlers[i]; ++i) {
    if (eh.type)
      this.visitExpr(eh.type);
    if (eh.name)
      this.visitExpr(eh.name);
    this.SEQStmt(eh.body);
  }
};
function _dictUpdate(a, b) {
  for (var kb in b) {
    a[kb] = b[kb];
  }
}
SymbolTable.prototype.analyzeBlock = function (ste, bound, free, global) {
  var local = {};
  var scope = {};
  var newglobal = {};
  var newbound = {};
  var newfree = {};
  if (ste.blockType == ClassBlock) {
    _dictUpdate(newglobal, global);
    if (bound)
      _dictUpdate(newbound, bound);
  }
  for (var name in ste.symFlags) {
    var flags = ste.symFlags[name];
    this.analyzeName(ste, scope, name, flags, bound, local, free, global);
  }
  if (ste.blockType !== ClassBlock) {
    if (ste.blockType === FunctionBlock)
      _dictUpdate(newbound, local);
    if (bound)
      _dictUpdate(newbound, bound);
    _dictUpdate(newglobal, global);
  }
  var allfree = {};
  var childlen = ste.children.length;
  for (var i = 0; i < childlen; ++i) {
    var c = ste.children[i];
    this.analyzeChildBlock(c, newbound, newfree, newglobal, allfree);
    if (c.hasFree || c.childHasFree)
      ste.childHasFree = true;
  }
  _dictUpdate(newfree, allfree);
  if (ste.blockType === FunctionBlock)
    this.analyzeCells(scope, newfree);
  this.updateSymbols(ste.symFlags, scope, bound, newfree, ste.blockType === ClassBlock);
  _dictUpdate(free, newfree);
};
SymbolTable.prototype.analyzeChildBlock = function (entry, bound, free, global, childFree) {
  var tempBound = {};
  _dictUpdate(tempBound, bound);
  var tempFree = {};
  _dictUpdate(tempFree, free);
  var tempGlobal = {};
  _dictUpdate(tempGlobal, global);
  this.analyzeBlock(entry, tempBound, tempFree, tempGlobal);
  _dictUpdate(childFree, tempFree);
};
SymbolTable.prototype.analyzeCells = function (scope, free) {
  for (var name in scope) {
    var flags = scope[name];
    if (flags !== LOCAL)
      continue;
    if (free[name] === undefined)
      continue;
    scope[name] = CELL;
    delete free[name];
  }
};
SymbolTable.prototype.updateSymbols = function (symbols, scope, bound, free, classflag) {
  for (var name in symbols) {
    var flags = symbols[name];
    var w = scope[name];
    flags |= w << SCOPE_OFF;
    symbols[name] = flags;
  }
  var freeValue = FREE << SCOPE_OFF;
  var pos = 0;
  for (var name in free) {
    var o = symbols[name];
    if (o !== undefined) {
      if (classflag && o & (DEF_BOUND | DEF_GLOBAL)) {
        var i = o | DEF_FREE_CLASS;
        symbols[name] = i;
      }
      continue;
    }
    if (bound[name] === undefined)
      continue;
    symbols[name] = freeValue;
  }
};
SymbolTable.prototype.analyzeName = function (ste, dict, name, flags, bound, local, free, global) {
  if (flags & DEF_GLOBAL) {
    if (flags & DEF_PARAM)
      throw new Sk.builtin.SyntaxError('name \'' + name + '\' is local and global', this.filename, ste.lineno);
    dict[name] = GLOBAL_EXPLICIT;
    global[name] = null;
    if (bound && bound[name] !== undefined)
      delete bound[name];
    return;
  }
  if (flags & DEF_BOUND) {
    dict[name] = LOCAL;
    local[name] = null;
    delete global[name];
    return;
  }
  if (bound && bound[name] !== undefined) {
    dict[name] = FREE;
    ste.hasFree = true;
    free[name] = null;
  } else if (global && global[name] !== undefined) {
    dict[name] = GLOBAL_IMPLICIT;
  } else {
    if (ste.isNested)
      ste.hasFree = true;
    dict[name] = GLOBAL_IMPLICIT;
  }
};
SymbolTable.prototype.analyze = function () {
  var free = {};
  var global = {};
  this.analyzeBlock(this.top, null, free, global);
};
Sk.symboltable = function (ast, filename) {
  var ret = new SymbolTable(filename);
  ret.enterBlock('top', ModuleBlock, ast, 0);
  ret.top = ret.cur;
  for (var i = 0; i < ast.body.length; ++i)
    ret.visitStmt(ast.body[i]);
  ret.exitBlock();
  ret.analyze();
  return ret;
};
Sk.dumpSymtab = function (st) {
  var pyBoolStr = function (b) {
    return b ? 'True' : 'False';
  };
  var pyList = function (l) {
    var ret = [];
    for (var i = 0; i < l.length; ++i) {
      ret.push(new Sk.builtin.str(l[i]).tp$repr().v);
    }
    return '[' + ret.join(', ') + ']';
  };
  var getIdents = function (obj, indent) {
    if (indent === undefined)
      indent = '';
    var ret = '';
    ret += indent + 'Sym_type: ' + obj.get_type() + '\n';
    ret += indent + 'Sym_name: ' + obj.get_name() + '\n';
    ret += indent + 'Sym_lineno: ' + obj.get_lineno() + '\n';
    ret += indent + 'Sym_nested: ' + pyBoolStr(obj.is_nested()) + '\n';
    ret += indent + 'Sym_haschildren: ' + pyBoolStr(obj.has_children()) + '\n';
    if (obj.get_type() === 'class') {
      ret += indent + 'Class_methods: ' + pyList(obj.get_methods()) + '\n';
    } else if (obj.get_type() === 'function') {
      ret += indent + 'Func_params: ' + pyList(obj.get_parameters()) + '\n';
      ret += indent + 'Func_locals: ' + pyList(obj.get_locals()) + '\n';
      ret += indent + 'Func_globals: ' + pyList(obj.get_globals()) + '\n';
      ret += indent + 'Func_frees: ' + pyList(obj.get_frees()) + '\n';
    }
    ret += indent + '-- Identifiers --\n';
    var objidents = obj.get_identifiers();
    var objidentslen = objidents.length;
    for (var i = 0; i < objidentslen; ++i) {
      var info = obj.lookup(objidents[i]);
      ret += indent + 'name: ' + info.get_name() + '\n';
      ret += indent + '  is_referenced: ' + pyBoolStr(info.is_referenced()) + '\n';
      ret += indent + '  is_imported: ' + pyBoolStr(info.is_imported()) + '\n';
      ret += indent + '  is_parameter: ' + pyBoolStr(info.is_parameter()) + '\n';
      ret += indent + '  is_global: ' + pyBoolStr(info.is_global()) + '\n';
      ret += indent + '  is_declared_global: ' + pyBoolStr(info.is_declared_global()) + '\n';
      ret += indent + '  is_local: ' + pyBoolStr(info.is_local()) + '\n';
      ret += indent + '  is_free: ' + pyBoolStr(info.is_free()) + '\n';
      ret += indent + '  is_assigned: ' + pyBoolStr(info.is_assigned()) + '\n';
      ret += indent + '  is_namespace: ' + pyBoolStr(info.is_namespace()) + '\n';
      var nss = info.get_namespaces();
      var nsslen = nss.length;
      ret += indent + '  namespaces: [\n';
      var sub = [];
      for (var j = 0; j < nsslen; ++j) {
        var ns = nss[j];
        sub.push(getIdents(ns, indent + '    '));
      }
      ret += sub.join('\n');
      ret += indent + '  ]\n';
    }
    return ret;
  };
  return getIdents(st.top, '');
};
goog.exportSymbol('Sk.symboltable', Sk.symboltable);
goog.exportSymbol('Sk.dumpSymtab', Sk.dumpSymtab);
var out;
Sk.gensymcount = 0;
function Compiler(filename, st, flags, sourceCodeForAnnotation) {
  this.filename = filename;
  this.st = st;
  this.flags = flags;
  this.interactive = false;
  this.nestlevel = 0;
  this.u = null;
  this.stack = [];
  this.result = [];
  this.allUnits = [];
  this.source = sourceCodeForAnnotation ? sourceCodeForAnnotation.split('\n') : false;
}
function CompilerUnit() {
  this.ste = null;
  this.name = null;
  this.private_ = null;
  this.firstlineno = 0;
  this.lineno = 0;
  this.linenoSet = false;
  this.localnames = [];
  this.blocknum = 0;
  this.blocks = [];
  this.curblock = 0;
  this.scopename = null;
  this.prefixCode = '';
  this.varDeclsCode = '';
  this.switchCode = '';
  this.suffixCode = '';
  this.breakBlocks = [];
  this.continueBlocks = [];
  this.exceptBlocks = [];
  this.finallyBlocks = [];
}
CompilerUnit.prototype.activateScope = function () {
  var self = this;
  out = function () {
    var b = self.blocks[self.curblock];
    for (var i = 0; i < arguments.length; ++i)
      b.push(arguments[i]);
  };
};
Compiler.prototype.getSourceLine = function (lineno) {
  goog.asserts.assert(this.source);
  return this.source[lineno - 1];
};
Compiler.prototype.annotateSource = function (ast) {
  if (this.source) {
    var lineno = ast.lineno;
    var col_offset = ast.col_offset;
    out('\n//\n// line ', lineno, ':\n// ', this.getSourceLine(lineno), '\n// ');
    for (var i = 0; i < col_offset; ++i)
      out(' ');
    out('^\n//\n');
    out('\nSk.currLineNo = ', lineno, ';\nSk.currColNo = ', col_offset, '\n\n');
    out('\nSk.currFilename = \'', this.filename, '\';\n\n');
  }
};
Compiler.prototype.gensym = function (hint) {
  hint = hint || '';
  hint = '$' + hint;
  hint += Sk.gensymcount++;
  return hint;
};
Compiler.prototype.niceName = function (roughName) {
  return this.gensym(roughName.replace('<', '').replace('>', '').replace(' ', '_'));
};
var reservedWords_ = {
    'abstract': true,
    'as': true,
    'boolean': true,
    'break': true,
    'byte': true,
    'case': true,
    'catch': true,
    'char': true,
    'class': true,
    'continue': true,
    'const': true,
    'debugger': true,
    'default': true,
    'delete': true,
    'do': true,
    'double': true,
    'else': true,
    'enum': true,
    'export': true,
    'extends': true,
    'false': true,
    'final': true,
    'finally': true,
    'float': true,
    'for': true,
    'function': true,
    'goto': true,
    'if': true,
    'implements': true,
    'import': true,
    'in': true,
    'instanceof': true,
    'int': true,
    'interface': true,
    'is': true,
    'long': true,
    'namespace': true,
    'native': true,
    'new': true,
    'null': true,
    'package': true,
    'private': true,
    'protected': true,
    'public': true,
    'return': true,
    'short': true,
    'static': true,
    'super': false,
    'switch': true,
    'synchronized': true,
    'this': true,
    'throw': true,
    'throws': true,
    'transient': true,
    'true': true,
    'try': true,
    'typeof': true,
    'use': true,
    'var': true,
    'void': true,
    'volatile': true,
    'while': true,
    'with': true
  };
function fixReservedWords(name) {
  if (reservedWords_[name] !== true)
    return name;
  return name + '_$rw$';
}
var reservedNames_ = {
    '__defineGetter__': true,
    '__defineSetter__': true,
    'apply': true,
    'call': true,
    'eval': true,
    'hasOwnProperty': true,
    'isPrototypeOf': true,
    '__lookupGetter__': true,
    '__lookupSetter__': true,
    '__noSuchMethod__': true,
    'propertyIsEnumerable': true,
    'toSource': true,
    'toLocaleString': true,
    'toString': true,
    'unwatch': true,
    'valueOf': true,
    'watch': true,
    'length': true
  };
function fixReservedNames(name) {
  if (reservedNames_[name])
    return name + '_$rn$';
  return name;
}
Sk.mangleName = function (name) {
  return fixReservedNames(name);
};
goog.exportSymbol('Sk.mangleName', Sk.mangleName);
function mangleName(priv, ident) {
  var name = ident.v;
  var strpriv = null;
  if (priv === null || name === null || name.charAt(0) !== '_' || name.charAt(1) !== '_')
    return ident;
  if (name.charAt(name.length - 1) === '_' && name.charAt(name.length - 2) === '_')
    return ident;
  strpriv = priv.v;
  strpriv.replace(/_/g, '');
  if (strpriv === '')
    return ident;
  strpriv = priv.v;
  strpriv.replace(/^_*/, '');
  strpriv = new Sk.builtin.str('_' + strpriv + name);
  return strpriv;
}
Compiler.prototype._gr = function (hint, rest) {
  var v = this.gensym(hint);
  out('var ', v, '=');
  for (var i = 1; i < arguments.length; ++i) {
    out(arguments[i]);
  }
  out(';');
  return v;
};
Compiler.prototype._interruptTest = function () {
  out('if (Sk.execStart === undefined) {Sk.execStart=new Date()}');
  out('if (Sk.execLimit != null && new Date() - Sk.execStart > Sk.execLimit) {throw new Sk.builtin.TimeLimitError(Sk.timeoutMsg())}');
};
Compiler.prototype._jumpfalse = function (test, block) {
  var cond = this._gr('jfalse', '(', test, '===false||!Sk.misceval.isTrue(', test, '))');
  this._interruptTest();
  out('if(', cond, '){/*test failed */$blk=', block, ';continue;}');
};
Compiler.prototype._jumpundef = function (test, block) {
  this._interruptTest();
  out('if(', test, '===undefined){$blk=', block, ';continue;}');
};
Compiler.prototype._jumptrue = function (test, block) {
  var cond = this._gr('jtrue', '(', test, '===true||Sk.misceval.isTrue(', test, '))');
  this._interruptTest();
  out('if(', cond, '){/*test passed */$blk=', block, ';continue;}');
};
Compiler.prototype._jump = function (block) {
  this._interruptTest();
  out('$blk=', block, ';/* jump */continue;');
};
Compiler.prototype.ctupleorlist = function (e, data, tuporlist) {
  goog.asserts.assert(tuporlist === 'tuple' || tuporlist === 'list');
  if (e.ctx === Store) {
    for (var i = 0; i < e.elts.length; ++i) {
      this.vexpr(e.elts[i], 'Sk.abstr.objectGetItem(' + data + ',' + i + ')');
    }
  } else if (e.ctx === Load) {
    var items = [];
    for (var i = 0; i < e.elts.length; ++i) {
      items.push(this._gr('elem', this.vexpr(e.elts[i])));
    }
    return this._gr('load' + tuporlist, 'new Sk.builtins[\'', tuporlist, '\']([', items, '])');
  }
};
Compiler.prototype.cdict = function (e) {
  goog.asserts.assert(e.values.length === e.keys.length);
  var items = [];
  for (var i = 0; i < e.values.length; ++i) {
    var v = this.vexpr(e.values[i]);
    items.push(this.vexpr(e.keys[i]));
    items.push(v);
  }
  return this._gr('loaddict', 'new Sk.builtins[\'dict\']([', items, '])');
};
Compiler.prototype.clistcompgen = function (tmpname, generators, genIndex, elt) {
  var start = this.newBlock('list gen start');
  var skip = this.newBlock('list gen skip');
  var anchor = this.newBlock('list gen anchor');
  var l = generators[genIndex];
  var toiter = this.vexpr(l.iter);
  var iter = this._gr('iter', 'Sk.abstr.iter(', toiter, ')');
  this._jump(start);
  this.setBlock(start);
  var nexti = this._gr('next', 'Sk.abstr.iternext(', iter, ')');
  this._jumpundef(nexti, anchor);
  var target = this.vexpr(l.target, nexti);
  var n = l.ifs.length;
  for (var i = 0; i < n; ++i) {
    var ifres = this.vexpr(l.ifs[i]);
    this._jumpfalse(ifres, start);
  }
  if (++genIndex < generators.length) {
    this.clistcompgen(tmpname, generators, genIndex, elt);
  }
  if (genIndex >= generators.length) {
    var velt = this.vexpr(elt);
    out(tmpname, '.v.push(', velt, ');');
    this._jump(skip);
    this.setBlock(skip);
  }
  this._jump(start);
  this.setBlock(anchor);
  return tmpname;
};
Compiler.prototype.clistcomp = function (e) {
  goog.asserts.assert(e instanceof ListComp);
  var tmp = this._gr('_compr', 'new Sk.builtins[\'list\']([])');
  return this.clistcompgen(tmp, e.generators, 0, e.elt);
};
Compiler.prototype.cyield = function (e) {
  if (this.u.ste.blockType !== FunctionBlock)
    throw new SyntaxError('\'yield\' outside function');
  var val = 'null';
  if (e.value)
    val = this.vexpr(e.value);
  var nextBlock = this.newBlock('after yield');
  out('return [/*resume*/', nextBlock, ',/*ret*/', val, '];');
  this.setBlock(nextBlock);
  return '$gen.gi$sentvalue';
};
Compiler.prototype.ccompare = function (e) {
  goog.asserts.assert(e.ops.length === e.comparators.length);
  var cur = this.vexpr(e.left);
  var n = e.ops.length;
  var done = this.newBlock('done');
  var fres = this._gr('compareres', 'null');
  for (var i = 0; i < n; ++i) {
    var rhs = this.vexpr(e.comparators[i]);
    var res = this._gr('compare', 'Sk.builtin.bool(Sk.misceval.richCompareBool(', cur, ',', rhs, ',\'', e.ops[i].prototype._astname, '\'))');
    out(fres, '=', res, ';');
    this._jumpfalse(res, done);
    cur = rhs;
  }
  this._jump(done);
  this.setBlock(done);
  return fres;
};
Compiler.prototype.ccall = function (e) {
  var func = this.vexpr(e.func);
  var args = this.vseqexpr(e.args);
  if (e.keywords.length > 0 || e.starargs || e.kwargs) {
    var kwarray = [];
    for (var i = 0; i < e.keywords.length; ++i) {
      kwarray.push('\'' + e.keywords[i].arg.v + '\'');
      kwarray.push(this.vexpr(e.keywords[i].value));
    }
    var keywords = '[' + kwarray.join(',') + ']';
    var starargs = 'undefined';
    var kwargs = 'undefined';
    if (e.starargs)
      starargs = this.vexpr(e.starargs);
    if (e.kwargs)
      kwargs = this.vexpr(e.kwargs);
    return this._gr('call', 'Sk.misceval.call(', func, ',', kwargs, ',', starargs, ',', keywords, args.length > 0 ? ',' : '', args, ')');
  } else {
    return this._gr('call', 'Sk.misceval.callsim(', func, args.length > 0 ? ',' : '', args, ')');
  }
};
Compiler.prototype.cslice = function (s) {
  goog.asserts.assert(s instanceof Slice);
  var low = s.lower ? this.vexpr(s.lower) : 'null';
  var high = s.upper ? this.vexpr(s.upper) : 'null';
  var step = s.step ? this.vexpr(s.step) : 'null';
  return this._gr('slice', 'new Sk.builtins[\'slice\'](', low, ',', high, ',', step, ')');
};
Compiler.prototype.vslicesub = function (s) {
  var subs;
  switch (s.constructor) {
  case Number:
  case String:
    subs = s;
    break;
  case Index:
    subs = this.vexpr(s.value);
    break;
  case Slice:
    subs = this.cslice(s);
    break;
  case Ellipsis:
  case ExtSlice:
    goog.asserts.fail('todo;');
    break;
  default:
    goog.asserts.fail('invalid subscript kind');
  }
  return subs;
};
Compiler.prototype.vslice = function (s, ctx, obj, dataToStore) {
  var subs = this.vslicesub(s);
  return this.chandlesubscr(ctx, obj, subs, dataToStore);
};
Compiler.prototype.chandlesubscr = function (ctx, obj, subs, data) {
  if (ctx === Load || ctx === AugLoad)
    return this._gr('lsubscr', 'Sk.abstr.objectGetItem(', obj, ',', subs, ')');
  else if (ctx === Store || ctx === AugStore)
    out('Sk.abstr.objectSetItem(', obj, ',', subs, ',', data, ');');
  else if (ctx === Del)
    out('Sk.abstr.objectDelItem(', obj, ',', subs, ');');
  else
    goog.asserts.fail('handlesubscr fail');
};
Compiler.prototype.cboolop = function (e) {
  goog.asserts.assert(e instanceof BoolOp);
  var jtype;
  var ifFailed;
  if (e.op === And)
    jtype = this._jumpfalse;
  else
    jtype = this._jumptrue;
  var end = this.newBlock('end of boolop');
  var s = e.values;
  var n = s.length;
  var retval;
  for (var i = 0; i < n; ++i) {
    var expres = this.vexpr(s[i]);
    if (i === 0) {
      retval = this._gr('boolopsucc', expres);
    }
    out(retval, '=', expres, ';');
    jtype.call(this, expres, end);
  }
  this._jump(end);
  this.setBlock(end);
  return retval;
};
Compiler.prototype.vexpr = function (e, data, augstoreval) {
  if (e.lineno > this.u.lineno) {
    this.u.lineno = e.lineno;
    this.u.linenoSet = false;
  }
  switch (e.constructor) {
  case BoolOp:
    return this.cboolop(e);
  case BinOp:
    return this._gr('binop', 'Sk.abstr.numberBinOp(', this.vexpr(e.left), ',', this.vexpr(e.right), ',\'', e.op.prototype._astname, '\')');
  case UnaryOp:
    return this._gr('unaryop', 'Sk.abstr.numberUnaryOp(', this.vexpr(e.operand), ',\'', e.op.prototype._astname, '\')');
  case Lambda:
    return this.clambda(e);
  case IfExp:
    return this.cifexp(e);
  case Dict:
    return this.cdict(e);
  case ListComp:
    return this.clistcomp(e);
  case GeneratorExp:
    return this.cgenexp(e);
  case Yield:
    return this.cyield(e);
  case Compare:
    return this.ccompare(e);
  case Call:
    var result = this.ccall(e);
    this.annotateSource(e);
    return result;
  case Num:
    if (typeof e.n === 'number')
      return e.n;
    else if (e.n instanceof Sk.builtin.nmber)
      return 'new Sk.builtin.nmber(' + e.n.v + ',\'' + e.n.skType + '\')';
    else if (e.n instanceof Sk.builtin.lng)
      return 'Sk.longFromStr(\'' + e.n.tp$str().v + '\')';
    goog.asserts.fail('unhandled Num type');
  case Str:
    return this._gr('str', 'new Sk.builtins[\'str\'](', e.s.tp$repr().v, ')');
  case Attribute:
    var val;
    if (e.ctx !== AugStore)
      val = this.vexpr(e.value);
    var mangled = e.attr.tp$repr().v;
    mangled = mangled.substring(1, mangled.length - 1);
    mangled = mangleName(this.u.private_, new Sk.builtin.str(mangled)).v;
    mangled = fixReservedWords(mangled);
    mangled = fixReservedNames(mangled);
    switch (e.ctx) {
    case AugLoad:
    case Load:
      return this._gr('lattr', 'Sk.abstr.gattr(', val, ',\'', mangled, '\')');
    case AugStore:
      out('if(', data, '!==undefined){');
      val = this.vexpr(augstoreval || null);
      out('Sk.abstr.sattr(', val, ',\'', mangled, '\',', data, ');');
      out('}');
      break;
    case Store:
      out('Sk.abstr.sattr(', val, ',\'', mangled, '\',', data, ');');
      break;
    case Del:
      goog.asserts.fail('todo;');
      break;
    case Param:
    default:
      goog.asserts.fail('invalid attribute expression');
    }
    break;
  case Subscript:
    var val;
    switch (e.ctx) {
    case AugLoad:
    case Load:
    case Store:
    case Del:
      return this.vslice(e.slice, e.ctx, this.vexpr(e.value), data);
    case AugStore:
      out('if(', data, '!==undefined){');
      val = this.vexpr(augstoreval || null);
      this.vslice(e.slice, e.ctx, val, data);
      out('}');
      break;
    case Param:
    default:
      goog.asserts.fail('invalid subscript expression');
    }
    break;
  case Name:
    return this.nameop(e.id, e.ctx, data);
  case List:
    return this.ctupleorlist(e, data, 'list');
  case Tuple:
    return this.ctupleorlist(e, data, 'tuple');
  default:
    goog.asserts.fail('unhandled case in vexpr');
  }
};
Compiler.prototype.vseqexpr = function (exprs, data) {
  goog.asserts.assert(data === undefined || exprs.length === data.length);
  var ret = [];
  for (var i = 0; i < exprs.length; ++i)
    ret.push(this.vexpr(exprs[i], data === undefined ? undefined : data[i]));
  return ret;
};
Compiler.prototype.caugassign = function (s) {
  goog.asserts.assert(s instanceof AugAssign);
  var e = s.target;
  switch (e.constructor) {
  case Attribute:
    var auge = new Attribute(e.value, e.attr, AugLoad, e.lineno, e.col_offset);
    var aug = this.vexpr(auge);
    var val = this.vexpr(s.value);
    var res = this._gr('inplbinopattr', 'Sk.abstr.numberInplaceBinOp(', aug, ',', val, ',\'', s.op.prototype._astname, '\')');
    auge.ctx = AugStore;
    return this.vexpr(auge, res, e.value);
  case Subscript:
    var augsub = this.vslicesub(e.slice);
    var auge = new Subscript(e.value, augsub, AugLoad, e.lineno, e.col_offset);
    var aug = this.vexpr(auge);
    var val = this.vexpr(s.value);
    var res = this._gr('inplbinopsubscr', 'Sk.abstr.numberInplaceBinOp(', aug, ',', val, ',\'', s.op.prototype._astname, '\')');
    auge.ctx = AugStore;
    return this.vexpr(auge, res, e.value);
  case Name:
    var to = this.nameop(e.id, Load);
    var val = this.vexpr(s.value);
    var res = this._gr('inplbinop', 'Sk.abstr.numberInplaceBinOp(', to, ',', val, ',\'', s.op.prototype._astname, '\')');
    return this.nameop(e.id, Store, res);
  default:
    goog.asserts.fail('unhandled case in augassign');
  }
};
Compiler.prototype.exprConstant = function (e) {
  switch (e.constructor) {
  case Num:
    return Sk.misceval.isTrue(e.n);
  case Str:
    return Sk.misceval.isTrue(e.s);
  case Name:
  default:
    return -1;
  }
};
Compiler.prototype.newBlock = function (name) {
  var ret = this.u.blocknum++;
  this.u.blocks[ret] = [];
  this.u.blocks[ret]._name = name || '<unnamed>';
  return ret;
};
Compiler.prototype.setBlock = function (n) {
  goog.asserts.assert(n >= 0 && n < this.u.blocknum);
  this.u.curblock = n;
};
Compiler.prototype.pushBreakBlock = function (n) {
  goog.asserts.assert(n >= 0 && n < this.u.blocknum);
  this.u.breakBlocks.push(n);
};
Compiler.prototype.popBreakBlock = function () {
  this.u.breakBlocks.pop();
};
Compiler.prototype.pushContinueBlock = function (n) {
  goog.asserts.assert(n >= 0 && n < this.u.blocknum);
  this.u.continueBlocks.push(n);
};
Compiler.prototype.popContinueBlock = function () {
  this.u.continueBlocks.pop();
};
Compiler.prototype.pushExceptBlock = function (n) {
  goog.asserts.assert(n >= 0 && n < this.u.blocknum);
  this.u.exceptBlocks.push(n);
};
Compiler.prototype.popExceptBlock = function () {
  this.u.exceptBlocks.pop();
};
Compiler.prototype.pushFinallyBlock = function (n) {
  goog.asserts.assert(n >= 0 && n < this.u.blocknum);
  this.u.finallyBlocks.push(n);
};
Compiler.prototype.popFinallyBlock = function () {
  this.u.finallyBlocks.pop();
};
Compiler.prototype.setupExcept = function (eb) {
  out('$exc.push(', eb, ');');
};
Compiler.prototype.endExcept = function () {
  out('$exc.pop();');
};
Compiler.prototype.outputLocals = function (unit) {
  var have = {};
  for (var i = 0; unit.argnames && i < unit.argnames.length; ++i)
    have[unit.argnames[i]] = true;
  unit.localnames.sort();
  var output = [];
  for (var i = 0; i < unit.localnames.length; ++i) {
    var name = unit.localnames[i];
    if (have[name] === undefined) {
      output.push(name);
      have[name] = true;
    }
  }
  if (output.length > 0)
    return 'var ' + output.join(',') + '; /* locals */';
  return '';
};
Compiler.prototype.outputAllUnits = function () {
  var ret = '';
  for (var j = 0; j < this.allUnits.length; ++j) {
    var unit = this.allUnits[j];
    ret += unit.prefixCode;
    ret += this.outputLocals(unit);
    ret += unit.varDeclsCode;
    ret += unit.switchCode;
    var blocks = unit.blocks;
    for (var i = 0; i < blocks.length; ++i) {
      ret += 'case ' + i + ': /* --- ' + blocks[i]._name + ' --- */';
      ret += blocks[i].join('');
      ret += 'throw new Sk.builtin.SystemError(\'internal error: unterminated block\');';
    }
    ret += unit.suffixCode;
  }
  return ret;
};
Compiler.prototype.cif = function (s) {
  goog.asserts.assert(s instanceof If_);
  var constant = this.exprConstant(s.test);
  if (constant === 0) {
    if (s.orelse)
      this.vseqstmt(s.orelse);
  } else if (constant === 1) {
    this.vseqstmt(s.body);
  } else {
    var end = this.newBlock('end of if');
    var next = this.newBlock('next branch of if');
    var test = this.vexpr(s.test);
    this._jumpfalse(test, next);
    this.vseqstmt(s.body);
    this._jump(end);
    this.setBlock(next);
    if (s.orelse)
      this.vseqstmt(s.orelse);
    this._jump(end);
  }
  this.setBlock(end);
};
Compiler.prototype.cwhile = function (s) {
  var constant = this.exprConstant(s.test);
  if (constant === 0) {
    if (s.orelse)
      this.vseqstmt(s.orelse);
  } else {
    var top = this.newBlock('while test');
    this._jump(top);
    this.setBlock(top);
    var next = this.newBlock('after while');
    var orelse = s.orelse.length > 0 ? this.newBlock('while orelse') : null;
    var body = this.newBlock('while body');
    this._jumpfalse(this.vexpr(s.test), orelse ? orelse : next);
    this._jump(body);
    this.pushBreakBlock(next);
    this.pushContinueBlock(top);
    this.setBlock(body);
    this.vseqstmt(s.body);
    this._jump(top);
    this.popContinueBlock();
    this.popBreakBlock();
    if (s.orelse.length > 0) {
      this.setBlock(orelse);
      this.vseqstmt(s.orelse);
      this._jump(next);
    }
    this.setBlock(next);
  }
};
Compiler.prototype.cfor = function (s) {
  var start = this.newBlock('for start');
  var cleanup = this.newBlock('for cleanup');
  var end = this.newBlock('for end');
  this.pushBreakBlock(end);
  this.pushContinueBlock(start);
  var toiter = this.vexpr(s.iter);
  var iter;
  if (this.u.ste.generator) {
    iter = '$loc.' + this.gensym('iter');
    out(iter, '=Sk.abstr.iter(', toiter, ');');
  } else
    iter = this._gr('iter', 'Sk.abstr.iter(', toiter, ')');
  this._jump(start);
  this.setBlock(start);
  var nexti = this._gr('next', 'Sk.abstr.iternext(', iter, ')');
  this._jumpundef(nexti, cleanup);
  var target = this.vexpr(s.target, nexti);
  this.vseqstmt(s.body);
  this._jump(start);
  this.setBlock(cleanup);
  this.popContinueBlock();
  this.popBreakBlock();
  this.vseqstmt(s.orelse);
  this._jump(end);
  this.setBlock(end);
};
Compiler.prototype.craise = function (s) {
  if (s && s.type && s.type.id && s.type.id.v === 'StopIteration') {
    out('return undefined;');
  } else {
    var inst = '';
    if (s.inst) {
      inst = this.vexpr(s.inst);
      out('throw ', this.vexpr(s.type), '(', inst, ');');
    } else if (s.type) {
      if (s.type.func) {
        out('throw ', this.vexpr(s.type), ';');
      } else {
        out('throw ', this.vexpr(s.type), '(\'\');');
      }
    } else {
      out('throw $err;');
    }
  }
};
Compiler.prototype.ctryexcept = function (s) {
  var n = s.handlers.length;
  var handlers = [];
  for (var i = 0; i < n; ++i) {
    handlers.push(this.newBlock('except_' + i + '_'));
  }
  var unhandled = this.newBlock('unhandled');
  var orelse = this.newBlock('orelse');
  var end = this.newBlock('end');
  this.setupExcept(handlers[0]);
  this.vseqstmt(s.body);
  this.endExcept();
  this._jump(orelse);
  for (var i = 0; i < n; ++i) {
    this.setBlock(handlers[i]);
    var handler = s.handlers[i];
    if (!handler.type && i < n - 1) {
      throw new SyntaxError('default \'except:\' must be last');
    }
    if (handler.type) {
      var handlertype = this.vexpr(handler.type);
      var next = i == n - 1 ? unhandled : handlers[i + 1];
      var check = this._gr('instance', '$err instanceof ', handlertype);
      this._jumpfalse(check, next);
    }
    if (handler.name) {
      this.vexpr(handler.name, '$err');
    }
    this.vseqstmt(handler.body);
    this._jump(end);
  }
  this.setBlock(unhandled);
  out('throw $err;');
  this.setBlock(orelse);
  this.vseqstmt(s.orelse);
  this._jump(end);
  this.setBlock(end);
};
Compiler.prototype.ctryfinally = function (s) {
  out('/*todo; tryfinally*/');
  this.ctryexcept(s.body[0]);
};
Compiler.prototype.cassert = function (s) {
  var test = this.vexpr(s.test);
  var end = this.newBlock('end');
  this._jumptrue(test, end);
  out('throw new Sk.builtin.AssertionError(', s.msg ? this.vexpr(s.msg) : '', ');');
  this.setBlock(end);
};
Compiler.prototype.cimportas = function (name, asname, mod) {
  var src = name.v;
  var dotLoc = src.indexOf('.');
  var cur = mod;
  if (dotLoc !== -1) {
    src = src.substr(dotLoc + 1);
    while (dotLoc !== -1) {
      dotLoc = src.indexOf('.');
      var attr = dotLoc !== -1 ? src.substr(0, dotLoc) : src;
      cur = this._gr('lattr', 'Sk.abstr.gattr(', cur, ',\'', attr, '\')');
      src = src.substr(dotLoc + 1);
    }
  }
  return this.nameop(asname, Store, cur);
};
Compiler.prototype.cimport = function (s) {
  var n = s.names.length;
  for (var i = 0; i < n; ++i) {
    var alias = s.names[i];
    var mod = this._gr('module', 'Sk.builtin.__import__(', alias.name.tp$repr().v, ',$gbl,$loc,[])');
    if (alias.asname) {
      this.cimportas(alias.name, alias.asname, mod);
    } else {
      var tmp = alias.name;
      var lastDot = tmp.v.indexOf('.');
      if (lastDot !== -1)
        tmp = new Sk.builtin.str(tmp.v.substr(0, lastDot));
      this.nameop(tmp, Store, mod);
    }
  }
};
Compiler.prototype.cfromimport = function (s) {
  var n = s.names.length;
  var names = [];
  for (var i = 0; i < n; ++i)
    names[i] = s.names[i].name.tp$repr().v;
  var mod = this._gr('module', 'Sk.builtin.__import__(', s.module.tp$repr().v, ',$gbl,$loc,[', names, '])');
  for (var i = 0; i < n; ++i) {
    var alias = s.names[i];
    if (i === 0 && alias.name.v === '*') {
      goog.asserts.assert(n === 1);
      out('Sk.importStar(', mod, ',$loc, $gbl);');
      return;
    }
    var got = this._gr('item', 'Sk.abstr.gattr(', mod, ',', alias.name.tp$repr().v, ')');
    var storeName = alias.name;
    if (alias.asname)
      storeName = alias.asname;
    this.nameop(storeName, Store, got);
  }
};
Compiler.prototype.buildcodeobj = function (n, coname, decorator_list, args, callback) {
  var decos = [];
  var defaults = [];
  var vararg = null;
  var kwarg = null;
  if (decorator_list)
    decos = this.vseqexpr(decorator_list);
  if (args && args.defaults)
    defaults = this.vseqexpr(args.defaults);
  if (args && args.vararg)
    vararg = args.vararg;
  if (args && args.kwarg)
    kwarg = args.kwarg;
  var containingHasFree = this.u.ste.hasFree;
  var containingHasCell = this.u.ste.childHasFree;
  var scopename = this.enterScope(coname, n, n.lineno);
  var isGenerator = this.u.ste.generator;
  var hasFree = this.u.ste.hasFree;
  var hasCell = this.u.ste.childHasFree;
  var descendantOrSelfHasFree = this.u.ste.hasFree;
  var entryBlock = this.newBlock('codeobj entry');
  this.u.prefixCode = 'var ' + scopename + '=(function ' + this.niceName(coname.v) + '$(';
  var funcArgs = [];
  if (isGenerator) {
    if (kwarg) {
      throw new SyntaxError(coname.v + '(): keyword arguments in generators not supported');
    }
    if (vararg) {
      throw new SyntaxError(coname.v + '(): variable number of arguments in generators not supported');
    }
    funcArgs.push('$gen');
  } else {
    if (kwarg)
      funcArgs.push('$kwa');
    for (var i = 0; args && i < args.args.length; ++i)
      funcArgs.push(this.nameop(args.args[i].id, Param));
  }
  if (descendantOrSelfHasFree) {
    funcArgs.push('$free');
  }
  this.u.prefixCode += funcArgs.join(',');
  this.u.prefixCode += '){';
  if (isGenerator)
    this.u.prefixCode += '\n// generator\n';
  if (containingHasFree)
    this.u.prefixCode += '\n// containing has free\n';
  if (containingHasCell)
    this.u.prefixCode += '\n// containing has cell\n';
  if (hasFree)
    this.u.prefixCode += '\n// has free\n';
  if (hasCell)
    this.u.prefixCode += '\n// has cell\n';
  var locals = '{}';
  if (isGenerator) {
    entryBlock = '$gen.gi$resumeat';
    locals = '$gen.gi$locals';
  }
  var cells = '';
  if (hasCell)
    cells = ',$cell={}';
  this.u.varDeclsCode += 'var $blk=' + entryBlock + ',$exc=[],$loc=' + locals + cells + ',$gbl=this,$err=undefined;';
  for (var i = 0; args && i < args.args.length; ++i) {
    var id = args.args[i].id;
    if (this.isCell(id))
      this.u.varDeclsCode += '$cell.' + id.v + '=' + id.v + ';';
  }
  if (!isGenerator) {
    var minargs = args ? args.args.length - defaults.length : 0;
    var maxargs = vararg ? Infinity : args ? args.args.length : 0;
    var kw = kwarg ? true : false;
    this.u.varDeclsCode += 'Sk.builtin.pyCheckArgs("' + coname.v + '", arguments, ' + minargs + ', ' + maxargs + ', ' + kw + ', ' + descendantOrSelfHasFree + ');';
  }
  if (defaults.length > 0) {
    var offset = args.args.length - defaults.length;
    for (var i = 0; i < defaults.length; ++i) {
      var argname = this.nameop(args.args[i + offset].id, Param);
      this.u.varDeclsCode += 'if(' + argname + '===undefined)' + argname + '=' + scopename + '.$defaults[' + i + '];';
    }
  }
  if (vararg) {
    var start = funcArgs.length;
    this.u.varDeclsCode += vararg.v + '=new Sk.builtins[\'tuple\'](Array.prototype.slice.call(arguments,' + start + ')); /*vararg*/';
  }
  if (kwarg) {
    this.u.varDeclsCode += kwarg.v + '=new Sk.builtins[\'dict\']($kwa);';
  }
  this.u.switchCode = 'while(true){try{ switch($blk){';
  this.u.suffixCode = '} }catch(err){if ($exc.length>0) { $err = err; $blk=$exc.pop(); continue; } else { throw err; }} }});';
  callback.call(this, scopename);
  var argnames;
  if (args && args.args.length > 0) {
    var argnamesarr = [];
    for (var i = 0; i < args.args.length; ++i)
      argnamesarr.push(args.args[i].id.v);
    argnames = argnamesarr.join('\', \'');
    this.u.argnames = argnamesarr;
  }
  this.exitScope();
  if (defaults.length > 0)
    out(scopename, '.$defaults=[', defaults.join(','), '];');
  if (argnames) {
    out(scopename, '.co_varnames=[\'', argnames, '\'];');
  }
  if (kwarg) {
    out(scopename, '.co_kwargs=1;');
  }
  var frees = '';
  if (hasFree) {
    frees = ',$cell';
    if (containingHasFree)
      frees += ',$free';
  }
  if (isGenerator)
    if (args && args.args.length > 0)
      return this._gr('gener', '(function(){var $origargs=Array.prototype.slice.call(arguments);Sk.builtin.pyCheckArgs("', coname.v, '",arguments,', args.args.length - defaults.length, ',', args.args.length, ');return new Sk.builtins[\'generator\'](', scopename, ',$gbl,$origargs', frees, ');})');
    else
      return this._gr('gener', '(function(){Sk.builtin.pyCheckArgs("', coname.v, '",arguments,0,0);return new Sk.builtins[\'generator\'](', scopename, ',$gbl,[]', frees, ');})');
  else
    return this._gr('funcobj', 'new Sk.builtins[\'function\'](', scopename, ',$gbl', frees, ')');
};
Compiler.prototype.cfunction = function (s) {
  goog.asserts.assert(s instanceof FunctionDef);
  var funcorgen = this.buildcodeobj(s, s.name, s.decorator_list, s.args, function (scopename) {
      this.vseqstmt(s.body);
      out('return Sk.builtin.none.none$;');
    });
  this.nameop(s.name, Store, funcorgen);
};
Compiler.prototype.clambda = function (e) {
  goog.asserts.assert(e instanceof Lambda);
  var func = this.buildcodeobj(e, new Sk.builtin.str('<lambda>'), null, e.args, function (scopename) {
      var val = this.vexpr(e.body);
      out('return ', val, ';');
    });
  return func;
};
Compiler.prototype.cifexp = function (e) {
  var next = this.newBlock('next of ifexp');
  var end = this.newBlock('end of ifexp');
  var ret = this._gr('res', 'null');
  var test = this.vexpr(e.test);
  this._jumpfalse(test, next);
  out(ret, '=', this.vexpr(e.body), ';');
  this._jump(end);
  this.setBlock(next);
  out(ret, '=', this.vexpr(e.orelse), ';');
  this._jump(end);
  this.setBlock(end);
  return ret;
};
Compiler.prototype.cgenexpgen = function (generators, genIndex, elt) {
  var start = this.newBlock('start for ' + genIndex);
  var skip = this.newBlock('skip for ' + genIndex);
  var ifCleanup = this.newBlock('if cleanup for ' + genIndex);
  var end = this.newBlock('end for ' + genIndex);
  var ge = generators[genIndex];
  var iter;
  if (genIndex === 0) {
    iter = '$loc.$iter0';
  } else {
    var toiter = this.vexpr(ge.iter);
    iter = '$loc.' + this.gensym('iter');
    out(iter, '=', 'Sk.abstr.iter(', toiter, ');');
  }
  this._jump(start);
  this.setBlock(start);
  var nexti = this._gr('next', 'Sk.abstr.iternext(', iter, ')');
  this._jumpundef(nexti, end);
  var target = this.vexpr(ge.target, nexti);
  var n = ge.ifs.length;
  for (var i = 0; i < n; ++i) {
    var ifres = this.vexpr(ge.ifs[i]);
    this._jumpfalse(ifres, start);
  }
  if (++genIndex < generators.length) {
    this.cgenexpgen(generators, genIndex, elt);
  }
  if (genIndex >= generators.length) {
    var velt = this.vexpr(elt);
    out('return [', skip, '/*resume*/,', velt, '/*ret*/];');
    this.setBlock(skip);
  }
  this._jump(start);
  this.setBlock(end);
  if (genIndex === 1)
    out('return null;');
};
Compiler.prototype.cgenexp = function (e) {
  var gen = this.buildcodeobj(e, new Sk.builtin.str('<genexpr>'), null, null, function (scopename) {
      this.cgenexpgen(e.generators, 0, e.elt);
    });
  var gener = this._gr('gener', gen, '()');
  out(gener, '.gi$locals.$iter0=Sk.abstr.iter(', this.vexpr(e.generators[0].iter), ');');
  return gener;
};
Compiler.prototype.cclass = function (s) {
  goog.asserts.assert(s instanceof ClassDef);
  var decos = s.decorator_list;
  var bases = this.vseqexpr(s.bases);
  var scopename = this.enterScope(s.name, s, s.lineno);
  var entryBlock = this.newBlock('class entry');
  this.u.prefixCode = 'var ' + scopename + '=(function $' + s.name.v + '$class_outer($globals,$locals,$rest){var $gbl=$globals,$loc=$locals;';
  this.u.switchCode += 'return(function ' + s.name.v + '(){';
  this.u.switchCode += 'var $blk=' + entryBlock + ',$exc=[];while(true){switch($blk){';
  this.u.suffixCode = '}break;}}).apply(null,$rest);});';
  this.u.private_ = s.name;
  this.cbody(s.body);
  out('break;');
  this.exitScope();
  var wrapped = this._gr('built', 'Sk.misceval.buildClass($gbl,', scopename, ',', s.name.tp$repr().v, ',[', bases, '])');
  this.nameop(s.name, Store, wrapped);
};
Compiler.prototype.ccontinue = function (s) {
  if (this.u.continueBlocks.length === 0)
    throw new SyntaxError('\'continue\' outside loop');
  this._jump(this.u.continueBlocks[this.u.continueBlocks.length - 1]);
};
Compiler.prototype.vstmt = function (s) {
  this.u.lineno = s.lineno;
  this.u.linenoSet = false;
  this.annotateSource(s);
  switch (s.constructor) {
  case FunctionDef:
    this.cfunction(s);
    break;
  case ClassDef:
    this.cclass(s);
    break;
  case Return_:
    if (this.u.ste.blockType !== FunctionBlock)
      throw new SyntaxError('\'return\' outside function');
    if (s.value)
      out('return ', this.vexpr(s.value), ';');
    else
      out('return null;');
    break;
  case Delete_:
    this.vseqexpr(s.targets);
    break;
  case Assign:
    var n = s.targets.length;
    var val = this.vexpr(s.value);
    for (var i = 0; i < n; ++i)
      this.vexpr(s.targets[i], val);
    break;
  case AugAssign:
    return this.caugassign(s);
  case Print:
    this.cprint(s);
    break;
  case For_:
    return this.cfor(s);
  case While_:
    return this.cwhile(s);
  case If_:
    return this.cif(s);
  case Raise:
    return this.craise(s);
  case TryExcept:
    return this.ctryexcept(s);
  case TryFinally:
    return this.ctryfinally(s);
  case Assert:
    return this.cassert(s);
  case Import_:
    return this.cimport(s);
  case ImportFrom:
    return this.cfromimport(s);
  case Global:
    break;
  case Expr:
    this.vexpr(s.value);
    break;
  case Pass:
    break;
  case Break_:
    if (this.u.breakBlocks.length === 0)
      throw new SyntaxError('\'break\' outside loop');
    this._jump(this.u.breakBlocks[this.u.breakBlocks.length - 1]);
    break;
  case Continue_:
    this.ccontinue(s);
    break;
  default:
    goog.asserts.fail('unhandled case in vstmt');
  }
};
Compiler.prototype.vseqstmt = function (stmts) {
  for (var i = 0; i < stmts.length; ++i)
    this.vstmt(stmts[i]);
};
var OP_FAST = 0;
var OP_GLOBAL = 1;
var OP_DEREF = 2;
var OP_NAME = 3;
var D_NAMES = 0;
var D_FREEVARS = 1;
var D_CELLVARS = 2;
Compiler.prototype.isCell = function (name) {
  var mangled = mangleName(this.u.private_, name).v;
  var scope = this.u.ste.getScope(mangled);
  var dict = null;
  if (scope === CELL)
    return true;
  return false;
};
Compiler.prototype.nameop = function (name, ctx, dataToStore) {
  if ((ctx === Store || ctx === AugStore || ctx === Del) && name.v === '__debug__')
    throw new Sk.builtin.SyntaxError('can not assign to __debug__');
  if ((ctx === Store || ctx === AugStore || ctx === Del) && name.v === 'None')
    throw new Sk.builtin.SyntaxError('can not assign to None');
  if (name.v === 'None')
    return 'Sk.builtin.none.none$';
  if (name.v === 'True')
    return 'Sk.builtin.bool.true$';
  if (name.v === 'False')
    return 'Sk.builtin.bool.false$';
  var mangled = mangleName(this.u.private_, name).v;
  mangled = fixReservedNames(mangled);
  var op = 0;
  var optype = OP_NAME;
  var scope = this.u.ste.getScope(mangled);
  var dict = null;
  switch (scope) {
  case FREE:
    dict = '$free';
    optype = OP_DEREF;
    break;
  case CELL:
    dict = '$cell';
    optype = OP_DEREF;
    break;
  case LOCAL:
    if (this.u.ste.blockType === FunctionBlock && !this.u.ste.generator)
      optype = OP_FAST;
    break;
  case GLOBAL_IMPLICIT:
    if (this.u.ste.blockType === FunctionBlock)
      optype = OP_GLOBAL;
    break;
  case GLOBAL_EXPLICIT:
    optype = OP_GLOBAL;
  default:
    break;
  }
  mangled = fixReservedWords(mangled);
  goog.asserts.assert(scope || name.v.charAt(1) === '_');
  var mangledNoPre = mangled;
  if (this.u.ste.generator || this.u.ste.blockType !== FunctionBlock)
    mangled = '$loc.' + mangled;
  else if (optype === OP_FAST || optype === OP_NAME)
    this.u.localnames.push(mangled);
  switch (optype) {
  case OP_FAST:
    switch (ctx) {
    case Load:
    case Param:
      out('if (', mangled, ' === undefined) { throw new Error(\'local variable \\\'', mangled, '\\\' referenced before assignment\'); }\n');
      return mangled;
    case Store:
      out(mangled, '=', dataToStore, ';');
      break;
    case Del:
      out('delete ', mangled, ';');
      break;
    default:
      goog.asserts.fail('unhandled');
    }
    break;
  case OP_NAME:
    switch (ctx) {
    case Load:
      var v = this.gensym('loadname');
      out('var ', v, '=', mangled, '!==undefined?', mangled, ':Sk.misceval.loadname(\'', mangledNoPre, '\',$gbl);');
      return v;
    case Store:
      out(mangled, '=', dataToStore, ';');
      break;
    case Del:
      out('delete ', mangled, ';');
      break;
    case Param:
      return mangled;
    default:
      goog.asserts.fail('unhandled');
    }
    break;
  case OP_GLOBAL:
    switch (ctx) {
    case Load:
      return this._gr('loadgbl', 'Sk.misceval.loadname(\'', mangledNoPre, '\',$gbl)');
    case Store:
      out('$gbl.', mangledNoPre, '=', dataToStore, ';');
      break;
    case Del:
      out('delete $gbl.', mangledNoPre);
      break;
    default:
      goog.asserts.fail('unhandled case in name op_global');
    }
    break;
  case OP_DEREF:
    switch (ctx) {
    case Load:
      return dict + '.' + mangledNoPre;
    case Store:
      out(dict, '.', mangledNoPre, '=', dataToStore, ';');
      break;
    case Param:
      return mangledNoPre;
    default:
      goog.asserts.fail('unhandled case in name op_deref');
    }
    break;
  default:
    goog.asserts.fail('unhandled case');
  }
};
Compiler.prototype.enterScope = function (name, key, lineno) {
  var u = new CompilerUnit();
  u.ste = this.st.getStsForAst(key);
  u.name = name;
  u.firstlineno = lineno;
  if (this.u && this.u.private_)
    u.private_ = this.u.private_;
  this.stack.push(this.u);
  this.allUnits.push(u);
  var scopeName = this.gensym('scope');
  u.scopename = scopeName;
  this.u = u;
  this.u.activateScope();
  this.nestlevel++;
  return scopeName;
};
Compiler.prototype.exitScope = function () {
  var prev = this.u;
  this.nestlevel--;
  if (this.stack.length - 1 >= 0)
    this.u = this.stack.pop();
  else
    this.u = null;
  if (this.u)
    this.u.activateScope();
  if (prev.name.v !== '<module>') {
    var mangled = prev.name.tp$repr().v;
    mangled = mangled.substring(1, mangled.length - 1);
    mangled = fixReservedWords(mangled);
    mangled = fixReservedNames(mangled);
    out(prev.scopename, '.co_name=new Sk.builtins[\'str\'](\'', mangled, '\');');
  }
};
Compiler.prototype.cbody = function (stmts) {
  for (var i = 0; i < stmts.length; ++i)
    this.vstmt(stmts[i]);
};
Compiler.prototype.cprint = function (s) {
  goog.asserts.assert(s instanceof Print);
  var dest = 'null';
  if (s.dest)
    dest = this.vexpr(s.dest);
  var n = s.values.length;
  for (var i = 0; i < n; ++i)
    out('Sk.misceval.print_(', 'new Sk.builtins[\'str\'](', this.vexpr(s.values[i]), ').v);');
  if (s.nl)
    out('Sk.misceval.print_(', '"\\n");');
};
Compiler.prototype.cmod = function (mod) {
  var modf = this.enterScope(new Sk.builtin.str('<module>'), mod, 0);
  var entryBlock = this.newBlock('module entry');
  this.u.prefixCode = 'var ' + modf + '=(function($modname){';
  this.u.varDeclsCode = 'var $blk=' + entryBlock + ',$exc=[],$gbl={},$loc=$gbl,$err=undefined;$gbl.__name__=$modname;Sk.globals=$gbl;';
  this.u.switchCode = 'try { while(true){try{ switch($blk){';
  this.u.suffixCode = '} }catch(err){if ($exc.length>0) { $err = err; $blk=$exc.pop(); continue; } else { throw err; }} } }catch(err){ if (err instanceof Sk.builtin.SystemExit && !Sk.throwSystemExit) { Sk.misceval.print_(err.toString() + \'\\n\'); return $loc; } else { throw err; } } });';
  switch (mod.constructor) {
  case Module:
    this.cbody(mod.body);
    out('return $loc;');
    break;
  default:
    goog.asserts.fail('todo; unhandled case in compilerMod');
  }
  this.exitScope();
  this.result.push(this.outputAllUnits());
  return modf;
};
Sk.compile = function (source, filename, mode) {
  var cst = Sk.parse(filename, source);
  var ast = Sk.astFromParse(cst, filename);
  var st = Sk.symboltable(ast, filename);
  var c = new Compiler(filename, st, 0, source);
  var funcname = c.cmod(ast);
  var ret = c.result.join('');
  return {
    funcname: funcname,
    code: ret
  };
};
goog.exportSymbol('Sk.compile', Sk.compile);
Sk.resetCompiler = function () {
  Sk.gensymcount = 0;
};
goog.exportSymbol('Sk.resetCompiler', Sk.resetCompiler);
Sk.sysmodules = new Sk.builtin.dict([]);
Sk.realsyspath = undefined;
Sk.importSearchPathForName = function (name, ext, failok) {
  var L = Sk.realsyspath;
  for (var it = L.tp$iter(), i = it.tp$iternext(); i !== undefined; i = it.tp$iternext()) {
    var nameAsPath = name.replace(/\./g, '/');
    var fns = [
        i.v + '/' + nameAsPath + ext,
        i.v + '/' + nameAsPath + '/__init__' + ext
      ];
    for (var j = 0; j < fns.length; ++j) {
      var fn = fns[j];
      try {
        Sk.read(fn);
        return fn;
      } catch (e) {
      }
      ;
    }
  }
  if (!failok)
    throw new Sk.builtin.ImportError('No module named ' + name);
};
Sk.doOneTimeInitialization = function () {
  Sk.builtin.type.basesStr_ = new Sk.builtin.str('__bases__');
  Sk.builtin.type.mroStr_ = new Sk.builtin.str('__mro__');
  Sk.builtin.object['$d'] = new Sk.builtin.dict([]);
  Sk.builtin.object['$d'].mp$ass_subscript(Sk.builtin.type.basesStr_, new Sk.builtin.tuple([]));
  Sk.builtin.object['$d'].mp$ass_subscript(Sk.builtin.type.mroStr_, new Sk.builtin.tuple([Sk.builtin.object]));
};
Sk.importSetUpPath = function () {
  if (!Sk.realsyspath) {
    var paths = [
        new Sk.builtin.str('src/builtin'),
        new Sk.builtin.str('src/lib'),
        new Sk.builtin.str('.')
      ];
    for (var i = 0; i < Sk.syspath.length; ++i) {
      paths.push(new Sk.builtin.str(Sk.syspath[i]));
    }
    Sk.realsyspath = new Sk.builtin.list(paths);
    Sk.doOneTimeInitialization();
  }
};
if (COMPILED) {
  var js_beautify = function (x) {
    return x;
  };
}
Sk.importModuleInternal_ = function (name, dumpJS, modname, suppliedPyBody) {
  Sk.importSetUpPath();
  if (modname === undefined)
    modname = name;
  var toReturn = null;
  var modNameSplit = modname.split('.');
  var parentModName;
  try {
    var prev = Sk.sysmodules.mp$subscript(modname);
    if (modNameSplit.length > 1)
      return Sk.sysmodules.mp$subscript(modNameSplit[0]);
    else
      return prev;
  } catch (x) {
  }
  if (modNameSplit.length > 1) {
    parentModName = modNameSplit.slice(0, modNameSplit.length - 1).join('.');
    toReturn = Sk.importModuleInternal_(parentModName, dumpJS);
  }
  var module = new Sk.builtin.module();
  Sk.sysmodules.mp$ass_subscript(name, module);
  var filename, co, googClosure;
  if (suppliedPyBody) {
    filename = name + '.py';
    co = Sk.compile(suppliedPyBody, filename, 'exec');
  } else {
    var builtinfn = Sk.importSearchPathForName(name, '.js', true);
    if (builtinfn) {
      filename = builtinfn;
      co = {
        funcname: '$builtinmodule',
        code: Sk.read(filename)
      };
    } else {
      filename = Sk.importSearchPathForName(name, '.py');
      co = Sk.compile(Sk.read(filename), filename, 'exec');
    }
  }
  module.$js = co.code;
  var finalcode = co.code;
  if (Sk.dateSet == null || !Sk.dateSet) {
    finalcode = 'Sk.execStart = new Date();\n' + co.code;
    Sk.dateSet = true;
  }
  {
    if (dumpJS) {
      var withLineNumbers = function (code) {
        var beaut = js_beautify(co.code);
        var lines = beaut.split('\n');
        for (var i = 1; i <= lines.length; ++i) {
          var width = ('' + i).length;
          var pad = '';
          for (var j = width; j < 5; ++j)
            pad += ' ';
          lines[i - 1] = '/* ' + pad + i + ' */ ' + lines[i - 1];
        }
        return lines.join('\n');
      };
      finalcode = withLineNumbers(co.code);
      Sk.debugout(finalcode);
    }
  }
  var namestr = 'new Sk.builtin.str(\'' + modname + '\')';
  finalcode += '\n' + co.funcname + '(' + namestr + ');';
  var modlocs = goog.global['eval'](finalcode);
  if (!modlocs['__name__'])
    modlocs['__name__'] = new Sk.builtin.str(modname);
  module['$d'] = modlocs;
  if (toReturn) {
    var parentModule = Sk.sysmodules.mp$subscript(parentModName);
    parentModule.tp$setattr(modNameSplit[modNameSplit.length - 1], module);
    return toReturn;
  }
  return module;
};
Sk.importModule = function (name, dumpJS) {
  return Sk.importModuleInternal_(name, dumpJS);
};
Sk.importMain = function (name, dumpJS) {
  Sk.dateSet = false;
  Sk.filesLoaded = false;
  Sk.sysmodules = new Sk.builtin.dict([]);
  Sk.realsyspath = undefined;
  Sk.resetCompiler();
  return Sk.importModuleInternal_(name, dumpJS, '__main__');
};
goog.exportSymbol('Sk.importMain', Sk.importMain);
Sk.importMainWithBody = function (name, dumpJS, body) {
  Sk.dateSet = false;
  Sk.filesLoaded = false;
  Sk.sysmodules = new Sk.builtin.dict([]);
  Sk.realsyspath = undefined;
  Sk.resetCompiler();
  return Sk.importModuleInternal_(name, dumpJS, '__main__', body);
};
goog.exportSymbol('Sk.importMainWithBody', Sk.importMainWithBody);
Sk.builtin.__import__ = function (name, globals, locals, fromlist) {
  var ret = Sk.importModuleInternal_(name);
  if (!fromlist || fromlist.length === 0)
    return ret;
  ret = Sk.sysmodules.mp$subscript(name);
  goog.asserts.assert(ret);
  return ret;
};
goog.exportSymbol('Sk.builtin.__import__', Sk.builtin.__import__);
Sk.importStar = function (module, loc) {
  var props = Object['getOwnPropertyNames'](module['$d']);
  for (var i in props) {
    loc[props[i]] = module['$d'][props[i]];
  }
};
goog.exportSymbol('Sk.importStar', Sk.importStar);
Sk.builtin.timSort = function (list, length) {
  this.list = new Sk.builtin.list(list.v);
  this.MIN_GALLOP = 7;
  if (length) {
    this.listlength = length;
  } else {
    this.listlength = list.sq$length();
  }
};
Sk.builtin.timSort.prototype.lt = function (a, b) {
  return Sk.misceval.richCompareBool(a, b, 'Lt');
};
Sk.builtin.timSort.prototype.le = function (a, b) {
  return !this.lt(b, a);
};
Sk.builtin.timSort.prototype.setitem = function (item, value) {
  this.list.v[item] = value;
};
Sk.builtin.timSort.prototype.binary_sort = function (a, sorted) {
  for (var start = a.base + sorted; start < a.base + a.len; start++) {
    var l = a.base;
    var r = start;
    var pivot = a.getitem(r);
    while (l < r) {
      var p = l + (r - l >> 1);
      if (this.lt(pivot, a.getitem(p))) {
        r = p;
      } else {
        l = p + 1;
      }
    }
    goog.asserts.assert(l === r);
    for (var p = start; p > l; p--) {
      a.setitem(p, a.getitem(p - 1));
    }
    a.setitem(l, pivot);
  }
};
Sk.builtin.timSort.prototype.count_run = function (a) {
  var descending;
  if (a.len <= 1) {
    var n = a.len;
    descending = false;
  } else {
    var n = 2;
    if (this.lt(a.getitem(a.base + 1), a.getitem(a.base))) {
      descending = true;
      for (var p = a.base + 2; p < a.base + a.len; p++) {
        if (this.lt(a.getitem(p), a.getitem(p - 1))) {
          n++;
        } else {
          break;
        }
      }
    } else {
      descending = false;
      for (p = a.base + 2; p < a.base + a.len; p++) {
        if (this.lt(a.getitem(p), a.getitem(p - 1))) {
          break;
        } else {
          n++;
        }
      }
    }
  }
  return {
    'run': new Sk.builtin.listSlice(a.list, a.base, n),
    'descending': descending
  };
};
Sk.builtin.timSort.prototype.sort = function () {
  var remaining = new Sk.builtin.listSlice(this.list, 0, this.listlength);
  if (remaining.len < 2) {
    return;
  }
  this.merge_init();
  var minrun = this.merge_compute_minrun(remaining.len);
  while (remaining.len > 0) {
    var cr = this.count_run(remaining);
    if (cr.descending) {
      cr.run.reverse();
    }
    if (cr.run.len < minrun) {
      var sorted = cr.run.len;
      if (minrun < remaining.len) {
        cr.run.len = minrun;
      } else {
        cr.run.len = remaining.len;
      }
      this.binary_sort(cr.run, sorted);
    }
    remaining.advance(cr.run.len);
    this.pending.push(cr.run);
    this.merge_collapse();
  }
  goog.asserts.assert(remaining.base == this.listlength);
  this.merge_force_collapse();
  goog.asserts.assert(this.pending.length == 1);
  goog.asserts.assert(this.pending[0].base == 0);
  goog.asserts.assert(this.pending[0].len == this.listlength);
};
Sk.builtin.timSort.prototype.gallop = function (key, a, hint, rightmost) {
  goog.asserts.assert(0 <= hint && hint < a.len);
  var lower;
  var self = this;
  if (rightmost) {
    lower = function (a, b) {
      return self.le(a, b);
    };
  } else {
    lower = function (a, b) {
      return self.lt(a, b);
    };
  }
  var p = a.base + hint;
  var lastofs = 0;
  var ofs = 1;
  var maxofs;
  if (lower(a.getitem(p), key)) {
    maxofs = a.len - hint;
    while (ofs < maxofs) {
      if (lower(a.getitem(p + ofs), key)) {
        lastofs = ofs;
        try {
          ofs = (ofs << 1) + 1;
        } catch (err) {
          ofs = maxofs;
        }
      } else {
        break;
      }
    }
    if (ofs > maxofs) {
      ofs = maxofs;
    }
    lastofs += hint;
    ofs += hint;
  } else {
    maxofs = hint + 1;
    while (ofs < maxofs) {
      if (lower(a.getitem(p - ofs), key)) {
        break;
      } else {
        lastofs = ofs;
        try {
          ofs = (ofs << 1) + 1;
        } catch (err) {
          ofs = maxofs;
        }
      }
    }
    if (ofs > maxofs) {
      ofs = maxofs;
    }
    var hintminofs = hint - ofs;
    var hintminlastofs = hint - lastofs;
    lastofs = hintminofs;
    ofs = hintminlastofs;
  }
  goog.asserts.assert(-1 <= lastofs < ofs <= a.len);
  lastofs += 1;
  while (lastofs < ofs) {
    var m = lastofs + (ofs - lastofs >> 1);
    if (lower(a.getitem(a.base + m), key)) {
      lastofs = m + 1;
    } else {
      ofs = m;
    }
  }
  goog.asserts.assert(lastofs == ofs);
  return ofs;
};
Sk.builtin.timSort.prototype.merge_init = function () {
  this.min_gallop = this.MIN_GALLOP;
  this.pending = [];
};
Sk.builtin.timSort.prototype.merge_lo = function (a, b) {
  goog.asserts.assert(a.len > 0 && b.len > 0 && a.base + a.len == b.base);
  var min_gallop = this.min_gallop;
  var dest = a.base;
  a = a.copyitems();
  try {
    this.setitem(dest, b.popleft());
    dest++;
    if (a.len == 1 || b.len == 0) {
      return;
    }
    var acount, bcount;
    while (true) {
      acount = 0;
      bcount = 0;
      while (true) {
        if (this.lt(b.getitem(b.base), a.getitem(a.base))) {
          this.setitem(dest, b.popleft());
          dest++;
          if (b.len == 0) {
            return;
          }
          bcount++;
          acount = 0;
          if (bcount >= min_gallop) {
            break;
          }
        } else {
          this.setitem(dest, a.popleft());
          dest++;
          if (a.len == 1) {
            return;
          }
          acount++;
          bcount = 0;
          if (acount >= min_gallop) {
            break;
          }
        }
      }
      min_gallop += 1;
      while (true) {
        min_gallop -= min_gallop > 1;
        this.min_gallop = min_gallop;
        acount = this.gallop(b.getitem(b.base), a, 0, true);
        for (var p = a.base; p < a.base + acount; p++) {
          this.setitem(dest, a.getitem(p));
          dest++;
        }
        a.advance(acount);
        if (a.len <= 1) {
          return;
        }
        this.setitem(dest, b.popleft());
        dest++;
        if (b.len == 0) {
          return;
        }
        bcount = this.gallop(a.getitem(a.base), b, 0, false);
        for (var p = b.base; p < b.base + bcount; p++) {
          this.setitem(dest, b.getitem(p));
          dest++;
        }
        b.advance(bcount);
        if (b.len == 0) {
          return;
        }
        this.setitem(dest, a.popleft());
        dest++;
        if (a.len == 1) {
          return;
        }
        if (acount < this.MIN_GALLOP && bcount < this.MIN_GALLOP) {
          break;
        }
        min_gallop++;
        this.min_gallop = min_gallop;
      }
    }
  } finally {
    goog.asserts.assert(a.len >= 0 && b.len >= 0);
    for (var p = b.base; p < b.base + b.len; p++) {
      this.setitem(dest, b.getitem(p));
      dest++;
    }
    for (var p = a.base; p < a.base + a.len; p++) {
      this.setitem(dest, a.getitem(p));
      dest++;
    }
  }
};
Sk.builtin.timSort.prototype.merge_hi = function (a, b) {
  goog.asserts.assert(a.len > 0 && b.len > 0 && a.base + a.len == b.base);
  var min_gallop = this.min_gallop;
  var dest = b.base + b.len;
  b = b.copyitems();
  try {
    dest--;
    this.setitem(dest, a.popright());
    if (a.len == 0 || b.len == 1) {
      return;
    }
    var acount, bcount, nexta, nextb;
    while (true) {
      acount = 0;
      bcount = 0;
      while (true) {
        nexta = a.getitem(a.base + a.len - 1);
        nextb = b.getitem(b.base + b.len - 1);
        if (this.lt(nextb, nexta)) {
          dest--;
          this.setitem(dest, nexta);
          a.len--;
          if (a.len == 0) {
            return;
          }
          acount++;
          bcount = 0;
          if (acount >= min_gallop) {
            break;
          }
        } else {
          dest--;
          this.setitem(dest, nextb);
          b.len--;
          if (b.len == 1) {
            return;
          }
          bcount++;
          acount = 0;
          if (bcount >= min_gallop) {
            break;
          }
        }
      }
      min_gallop += 1;
      while (true) {
        min_gallop -= min_gallop > 1;
        this.min_gallop = min_gallop;
        nextb = b.getitem(b.base + b.len - 1);
        var k = this.gallop(nextb, a, a.len - 1, true);
        acount = a.len - k;
        for (var p = a.base + a.len - 1; p > a.base + k - 1; p--) {
          dest--;
          this.setitem(dest, a.getitem(p));
        }
        a.len -= acount;
        if (a.len == 0) {
          return;
        }
        dest--;
        this.setitem(dest, b.popright());
        if (b.len == 1) {
          return;
        }
        nexta = a.getitem(a.base + a.len - 1);
        k = this.gallop(nexta, b, b.len - 1, false);
        bcount = b.len - k;
        for (var p = b.base + b.len - 1; p > b.base + k - 1; p--) {
          dest--;
          this.setitem(dest, b.getitem(p));
        }
        b.len -= bcount;
        if (b.len <= 1) {
          return;
        }
        dest--;
        this.setitem(dest, a.popright());
        if (a.len == 0) {
          return;
        }
        if (acount < this.MIN_GALLOP && bcount < this.MIN_GALLOP) {
          break;
        }
        min_gallop++;
        this.min_gallop = min_gallop;
      }
    }
  } finally {
    goog.asserts.assert(a.len >= 0 && b.len >= 0);
    for (var p = a.base + a.len - 1; p > a.base - 1; p--) {
      dest--;
      this.setitem(dest, a.getitem(p));
    }
    for (var p = b.base + b.len - 1; p > b.base - 1; p--) {
      dest--;
      this.setitem(dest, b.getitem(p));
    }
  }
};
Sk.builtin.timSort.prototype.merge_at = function (i) {
  if (i < 0) {
    i = this.pending.length + i;
  }
  var a = this.pending[i];
  var b = this.pending[i + 1];
  goog.asserts.assert(a.len > 0 && b.len > 0);
  goog.asserts.assert(a.base + a.len == b.base);
  this.pending[i] = new Sk.builtin.listSlice(this.list, a.base, a.len + b.len);
  this.pending.splice(i + 1, 1);
  var k = this.gallop(b.getitem(b.base), a, 0, true);
  a.advance(k);
  if (a.len == 0) {
    return;
  }
  b.len = this.gallop(a.getitem(a.base + a.len - 1), b, b.len - 1, false);
  if (b.len == 0) {
    return;
  }
  if (a.len <= b.len) {
    this.merge_lo(a, b);
  } else {
    this.merge_hi(a, b);
  }
};
Sk.builtin.timSort.prototype.merge_collapse = function () {
  var p = this.pending;
  while (p.length > 1) {
    if (p.length >= 3 && p[p.length - 3].len <= p[p.length - 2].len + p[p.length - 1].len) {
      if (p[p.length - 3].len < p[p.length - 1].len) {
        this.merge_at(-3);
      } else {
        this.merge_at(-2);
      }
    } else if (p[p.length - 2].len <= p[p.length - 1].len) {
      this.merge_at(-2);
    } else {
      break;
    }
  }
};
Sk.builtin.timSort.prototype.merge_force_collapse = function () {
  var p = this.pending;
  while (p.length > 1) {
    if (p.length >= 3 && p[p.length - 3].len < p[p.length - 1].len) {
      this.merge_at(-3);
    } else {
      this.merge_at(-2);
    }
  }
};
Sk.builtin.timSort.prototype.merge_compute_minrun = function (n) {
  var r = 0;
  while (n >= 64) {
    r = r | n & 1;
    n >>= 1;
  }
  return n + r;
};
Sk.builtin.listSlice = function (list, base, len) {
  this.list = list;
  this.base = base;
  this.len = len;
};
Sk.builtin.listSlice.prototype.copyitems = function () {
  var start = this.base;
  var stop = this.base + this.len;
  goog.asserts.assert(0 <= start <= stop);
  return new Sk.builtin.listSlice(new Sk.builtin.list(this.list.v.slice(start, stop)), 0, this.len);
};
Sk.builtin.listSlice.prototype.advance = function (n) {
  this.base += n;
  this.len -= n;
  goog.asserts.assert(this.base <= this.list.sq$length());
};
Sk.builtin.listSlice.prototype.getitem = function (item) {
  return this.list.v[item];
};
Sk.builtin.listSlice.prototype.setitem = function (item, value) {
  this.list.v[item] = value;
};
Sk.builtin.listSlice.prototype.popleft = function () {
  var result = this.list.v[this.base];
  this.base++;
  this.len--;
  return result;
};
Sk.builtin.listSlice.prototype.popright = function () {
  this.len--;
  return this.list.v[this.base + this.len];
};
Sk.builtin.listSlice.prototype.reverse = function () {
  var list = this.list;
  var lo = this.base;
  var hi = lo + this.len - 1;
  while (lo < hi) {
    var list_hi = list.v[hi];
    var list_lo = list.v[lo];
    list.v[lo] = list_hi;
    list.v[hi] = list_lo;
    lo++;
    hi--;
  }
};
goog.exportSymbol('Sk.builtin.listSlice', Sk.builtin.listSlice);
goog.exportSymbol('Sk.builtin.timSort', Sk.builtin.timSort);
Sk.builtins = {
  'range': Sk.builtin.range,
  'round': Sk.builtin.round,
  'len': Sk.builtin.len,
  'min': Sk.builtin.min,
  'max': Sk.builtin.max,
  'sum': Sk.builtin.sum,
  'zip': Sk.builtin.zip,
  'abs': Sk.builtin.abs,
  'fabs': Sk.builtin.abs,
  'ord': Sk.builtin.ord,
  'chr': Sk.builtin.chr,
  'hex': Sk.builtin.hex,
  'oct': Sk.builtin.oct,
  'bin': Sk.builtin.bin,
  'dir': Sk.builtin.dir,
  'repr': Sk.builtin.repr,
  'open': Sk.builtin.open,
  'isinstance': Sk.builtin.isinstance,
  'hash': Sk.builtin.hash,
  'getattr': Sk.builtin.getattr,
  'float_$rw$': Sk.builtin.float_,
  'int_$rw$': Sk.builtin.int_,
  'hasattr': Sk.builtin.hasattr,
  'map': Sk.builtin.map,
  'filter': Sk.builtin.filter,
  'reduce': Sk.builtin.reduce,
  'sorted': Sk.builtin.sorted,
  'bool': Sk.builtin.bool,
  'any': Sk.builtin.any,
  'all': Sk.builtin.all,
  'enumerate': Sk.builtin.enumerate,
  'AttributeError': Sk.builtin.AttributeError,
  'ValueError': Sk.builtin.ValueError,
  'Exception': Sk.builtin.Exception,
  'ZeroDivisionError': Sk.builtin.ZeroDivisionError,
  'AssertionError': Sk.builtin.AssertionError,
  'ImportError': Sk.builtin.ImportError,
  'IndentationError': Sk.builtin.IndentationError,
  'IndexError': Sk.builtin.IndexError,
  'KeyError': Sk.builtin.KeyError,
  'TypeError': Sk.builtin.TypeError,
  'NameError': Sk.builtin.NameError,
  'IOError': Sk.builtin.IOError,
  'NotImplementedError': Sk.builtin.NotImplementedError,
  'SystemExit': Sk.builtin.SystemExit,
  'OverflowError': Sk.builtin.OverflowError,
  'OperationError': Sk.builtin.OperationError,
  'dict': Sk.builtin.dict,
  'file': Sk.builtin.file,
  'function': Sk.builtin.func,
  'generator': Sk.builtin.generator,
  'list': Sk.builtin.list,
  'long_$rw$': Sk.builtin.lng,
  'method': Sk.builtin.method,
  'object': Sk.builtin.object,
  'slice': Sk.builtin.slice,
  'str': Sk.builtin.str,
  'set': Sk.builtin.set,
  'tuple': Sk.builtin.tuple,
  'type': Sk.builtin.type,
  'input': Sk.builtin.input,
  'raw_input': Sk.builtin.raw_input,
  'jseval': Sk.builtin.jseval,
  'jsmillis': Sk.builtin.jsmillis,
  'quit': Sk.builtin.quit,
  'exit': Sk.builtin.quit,
  'bytearray': Sk.builtin.bytearray,
  'callable': Sk.builtin.callable,
  'complex': Sk.builtin.complex,
  'delattr': Sk.builtin.delattr,
  'divmod': Sk.builtin.divmod,
  'eval_$rn$': Sk.builtin.eval_,
  'execfile': Sk.builtin.execfile,
  'format': Sk.builtin.format,
  'frozenset': Sk.builtin.frozenset,
  'globals': Sk.builtin.globals,
  'help': Sk.builtin.help,
  'issubclass': Sk.builtin.issubclass,
  'iter': Sk.builtin.iter,
  'locals': Sk.builtin.locals,
  'memoryview': Sk.builtin.memoryview,
  'next': Sk.builtin.next_,
  'pow': Sk.builtin.pow,
  'property': Sk.builtin.property,
  'reload': Sk.builtin.reload,
  'reversed': Sk.builtin.reversed,
  'super': Sk.builtin.superbi,
  'unichr': Sk.builtin.unichr,
  'vars': Sk.builtin.vars,
  'xrange': Sk.builtin.xrange,
  'apply_$rn$': Sk.builtin.apply_,
  'buffer': Sk.builtin.buffer,
  'coerce': Sk.builtin.coerce,
  'intern': Sk.builtin.intern
};
goog.exportSymbol('Sk.builtins', Sk.builtins);
Sk.stdlib = Sk.stdlib || {};
Sk.stdlib.direction = function (x, y, z) {
  if (x) {
    return 0;
  } else if (y) {
    return 1;
  } else {
    return 2;
  }
};
goog.exportSymbol('Sk.stdlib.direction', Sk.stdlib.direction);
Sk.stdlib.orientation = function (x, y, z) {
  if (x > 0) {
    return +1;
  } else if (x < 0) {
    return -1;
  } else if (y > 0) {
    return +1;
  } else if (y < 0) {
    return -1;
  } else if (z > 0) {
    return +1;
  } else if (z < 0) {
    return -1;
  } else {
    return 2;
  }
};
goog.exportSymbol('Sk.stdlib.orientation', Sk.stdlib.orientation);
Sk.math = Sk.math || {};
Sk.math.PI_TIMES_1_OVER_4 = Math.PI / 4;
Sk.math.PI_TIMES_2_OVER_4 = Math.PI / 2;
Sk.math.PI_TIMES_3_OVER_4 = 3 * Math.PI / 4;
Sk.math.PI_TIMES_4_OVER_4 = Math.PI;
Sk.math.PI_TIMES_5_OVER_4 = 5 * Math.PI / 4;
Sk.math.PI_TIMES_6_OVER_4 = 3 * Math.PI / 2;
Sk.math.PI_TIMES_7_OVER_4 = 7 * Math.PI / 4;
Sk.math.PI_TIMES_8_OVER_4 = 2 * Math.PI;
Sk.math.EPSILON = 1e-9;
Sk.math.isCloseTo = function (x1, x2, epsilon) {
  return Math.abs(x1 - x2) < epsilon;
};
Sk.math.cos = function (x) {
  if (Sk.math.isCloseTo(Math.abs(x), 0, Sk.math.EPSILON)) {
    return +1;
  } else if (Sk.math.isCloseTo(Math.abs(x), Sk.math.PI_TIMES_1_OVER_4, Sk.math.EPSILON)) {
    return +Math.SQRT1_2;
  } else if (Sk.math.isCloseTo(Math.abs(x), Sk.math.PI_TIMES_2_OVER_4, Sk.math.EPSILON)) {
    return 0;
  } else if (Sk.math.isCloseTo(Math.abs(x), Sk.math.PI_TIMES_3_OVER_4, Sk.math.EPSILON)) {
    return -Math.SQRT1_2;
  } else if (Sk.math.isCloseTo(Math.abs(x), Sk.math.PI_TIMES_4_OVER_4, Sk.math.EPSILON)) {
    return -1;
  } else if (Sk.math.isCloseTo(Math.abs(x), Sk.math.PI_TIMES_5_OVER_4, Sk.math.EPSILON)) {
    return -Math.SQRT1_2;
  } else if (Sk.math.isCloseTo(Math.abs(x), Sk.math.PI_TIMES_6_OVER_4, Sk.math.EPSILON)) {
    return 0;
  } else if (Sk.math.isCloseTo(Math.abs(x), Sk.math.PI_TIMES_7_OVER_4, Sk.math.EPSILON)) {
    return +Math.SQRT1_2;
  } else if (Sk.math.isCloseTo(Math.abs(x), Sk.math.PI_TIMES_8_OVER_4, Sk.math.EPSILON)) {
    return +1;
  } else {
    return Math.cos(x);
  }
};
Sk.math.sin = function (x) {
  if (Sk.math.isCloseTo(x, 0, Sk.math.EPSILON)) {
    return 0;
  } else if (Sk.math.isCloseTo(x, +Sk.math.PI_TIMES_1_OVER_4, Sk.math.EPSILON)) {
    return Math.SQRT1_2;
  } else if (Sk.math.isCloseTo(x, +Sk.math.PI_TIMES_2_OVER_4, Sk.math.EPSILON)) {
    return +1;
  } else if (Sk.math.isCloseTo(x, +Sk.math.PI_TIMES_3_OVER_4, Sk.math.EPSILON)) {
    return Math.SQRT1_2;
  } else if (Sk.math.isCloseTo(x, +Sk.math.PI_TIMES_4_OVER_4, Sk.math.EPSILON)) {
    return 0;
  } else if (Sk.math.isCloseTo(x, +Sk.math.PI_TIMES_5_OVER_4, Sk.math.EPSILON)) {
    return -Math.SQRT1_2;
  } else if (Sk.math.isCloseTo(x, +Sk.math.PI_TIMES_6_OVER_4, Sk.math.EPSILON)) {
    return -1;
  } else if (Sk.math.isCloseTo(x, +Sk.math.PI_TIMES_7_OVER_4, Sk.math.EPSILON)) {
    return -Math.SQRT1_2;
  } else if (Sk.math.isCloseTo(x, +Sk.math.PI_TIMES_8_OVER_4, Sk.math.EPSILON)) {
    return 0;
  } else if (Sk.math.isCloseTo(x, -Sk.math.PI_TIMES_1_OVER_4, Sk.math.EPSILON)) {
    return -Math.SQRT1_2;
  } else if (Sk.math.isCloseTo(x, -Sk.math.PI_TIMES_2_OVER_4, Sk.math.EPSILON)) {
    return -1;
  } else if (Sk.math.isCloseTo(x, -Sk.math.PI_TIMES_3_OVER_4, Sk.math.EPSILON)) {
    return -Math.SQRT1_2;
  } else if (Sk.math.isCloseTo(x, -Sk.math.PI_TIMES_4_OVER_4, Sk.math.EPSILON)) {
    return 0;
  } else if (Sk.math.isCloseTo(x, -Sk.math.PI_TIMES_5_OVER_4, Sk.math.EPSILON)) {
    return +Math.SQRT1_2;
  } else if (Sk.math.isCloseTo(x, -Sk.math.PI_TIMES_6_OVER_4, Sk.math.EPSILON)) {
    return +1;
  } else if (Sk.math.isCloseTo(x, -Sk.math.PI_TIMES_7_OVER_4, Sk.math.EPSILON)) {
    return +Math.SQRT1_2;
  } else if (Sk.math.isCloseTo(x, -Sk.math.PI_TIMES_8_OVER_4, Sk.math.EPSILON)) {
    return 0;
  } else {
    return Math.sin(x);
  }
};
(function () {
  Sk.builtin.defineMath = function (mod) {
    Sk.ffi.checkFunctionArgs('defineMath', arguments, 1, 1);
    var ANGLE = 'angle';
    var NUMBER = 'Number';
    mod.e = Sk.ffi.numberToFloatPy(Math.E);
    mod.pi = Sk.ffi.numberToFloatPy(Math.PI);
    mod.sqrt2 = Sk.ffi.numberToFloatPy(Math.SQRT2);
    mod.sqrt1_2 = Sk.ffi.numberToFloatPy(Math.SQRT1_2);
    mod.tao = Sk.ffi.numberToFloatPy(2 * Math.PI);
    mod.cliffordConjugate = Sk.ffi.functionPy(function (x) {
      Sk.ffi.checkFunctionArgs('cliffordConjugate', arguments, 1, 1);
      if (Sk.ffi.isNum(x)) {
        return x;
      } else {
        return Sk.ffh.cliffordConjugate(x);
      }
    });
    mod.fabs = Sk.ffi.functionPy(function (x) {
      Sk.ffi.checkFunctionArgs('fabs', arguments, 1, 1);
      Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(x));
      return new Sk.builtin.nmber(Math.abs(Sk.builtin.asnum$(x)), Sk.builtin.nmber.float$);
    });
    mod.asin = Sk.ffi.functionPy(function (rad) {
      Sk.ffi.checkFunctionArgs('asin', arguments, 1, 1);
      Sk.builtin.pyCheckType('rad', 'number', Sk.builtin.checkNumber(rad));
      return new Sk.builtin.nmber(Math.asin(Sk.builtin.asnum$(rad)), Sk.builtin.nmber.float$);
    });
    mod.acos = Sk.ffi.functionPy(function (rad) {
      Sk.ffi.checkFunctionArgs('acos', arguments, 1, 1);
      Sk.builtin.pyCheckType('rad', 'number', Sk.builtin.checkNumber(rad));
      return new Sk.builtin.nmber(Math.acos(Sk.builtin.asnum$(rad)), Sk.builtin.nmber.float$);
    });
    mod.atan = Sk.ffi.functionPy(function (rad) {
      Sk.ffi.checkFunctionArgs('atan', arguments, 1, 1);
      Sk.builtin.pyCheckType('rad', 'number', Sk.builtin.checkNumber(rad));
      return new Sk.builtin.nmber(Math.atan(Sk.builtin.asnum$(rad)), Sk.builtin.nmber.float$);
    });
    mod.atan2 = Sk.ffi.functionPy(function (y, x) {
      Sk.ffi.checkFunctionArgs('atan2', arguments, 2, 2);
      Sk.builtin.pyCheckType('y', 'number', Sk.builtin.checkNumber(y));
      Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(x));
      return new Sk.builtin.nmber(Math.atan2(Sk.builtin.asnum$(y), Sk.builtin.asnum$(x)), Sk.builtin.nmber.float$);
    });
    mod.exp = Sk.ffi.functionPy(function (anglePy) {
      Sk.ffi.checkFunctionArgs('exp', arguments, 1, 1);
      if (Sk.ffi.isNum(anglePy)) {
        return Sk.ffi.numberToFloatPy(Math.exp(Sk.ffi.remapToJs(anglePy)));
      } else {
        return Sk.ffh.exp(anglePy);
      }
    });
    function makeTrigFunction(name, f1, f2) {
      return function (anglePy) {
        Sk.ffi.checkFunctionArgs(name, arguments, 1, 1);
        if (Sk.ffi.isNum(anglePy)) {
          return Sk.ffi.numberToFloatPy(f1(Sk.ffi.remapToJs(anglePy)));
        } else {
          return f2(anglePy);
        }
      };
    }
    mod.cos = Sk.ffi.functionPy(makeTrigFunction('cos', Sk.math.cos, Sk.ffh.cos));
    mod.sin = Sk.ffi.functionPy(makeTrigFunction('sin', Sk.math.sin, Sk.ffh.sin));
    mod.tan = Sk.ffi.functionPy(makeTrigFunction('tan', Math.tan, Sk.ffh.tan));
    mod.asinh = Sk.ffi.functionPy(function (x) {
      Sk.ffi.checkFunctionArgs('asinh', arguments, 1, 1);
      Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(x));
      x = Sk.builtin.asnum$(x);
      var L = x + Math.sqrt(x * x + 1);
      return new Sk.builtin.nmber(Math.log(L), Sk.builtin.nmber.float$);
    });
    mod.acosh = Sk.ffi.functionPy(function (x) {
      Sk.ffi.checkFunctionArgs('acosh', arguments, 1, 1);
      Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(x));
      x = Sk.builtin.asnum$(x);
      var L = x + Math.sqrt(x * x - 1);
      return new Sk.builtin.nmber(Math.log(L), Sk.builtin.nmber.float$);
    });
    mod.atanh = Sk.ffi.functionPy(function (x) {
      Sk.ffi.checkFunctionArgs('atanh', arguments, 1, 1);
      Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(x));
      x = Sk.builtin.asnum$(x);
      var L = (1 + x) / (1 - x);
      return new Sk.builtin.nmber(Math.log(L) / 2, Sk.builtin.nmber.float$);
    });
    mod.sinh = Sk.ffi.functionPy(function (x) {
      Sk.ffi.checkFunctionArgs('sinh', arguments, 1, 1);
      Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(x));
      x = Sk.builtin.asnum$(x);
      var e = Math.E;
      var p = Math.pow(e, x);
      var n = 1 / p;
      var result = (p - n) / 2;
      return new Sk.builtin.nmber(result, Sk.builtin.nmber.float$);
    });
    mod.cosh = Sk.ffi.functionPy(function (x) {
      Sk.ffi.checkFunctionArgs('cosh', arguments, 1, 1);
      Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(x));
      x = Sk.builtin.asnum$(x);
      var e = Math.E;
      var p = Math.pow(e, x);
      var n = 1 / p;
      var result = (p + n) / 2;
      return new Sk.builtin.nmber(result, Sk.builtin.nmber.float$);
    });
    mod.tanh = Sk.ffi.functionPy(function (x) {
      Sk.ffi.checkFunctionArgs('tanh', arguments, 1, 1);
      Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(x));
      x = Sk.builtin.asnum$(x);
      var e = Math.E;
      var p = Math.pow(e, x);
      var n = 1 / p;
      var result = (p - n) / 2 / ((p + n) / 2);
      return new Sk.builtin.nmber(result, Sk.builtin.nmber.float$);
    });
    mod.ceil = Sk.ffi.functionPy(function (x) {
      Sk.ffi.checkFunctionArgs('ceil', arguments, 1, 1);
      Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(x));
      return new Sk.builtin.nmber(Math.ceil(Sk.builtin.asnum$(x)), Sk.builtin.nmber.float$);
    });
    mod.floor = Sk.ffi.functionPy(function (x) {
      Sk.ffi.checkFunctionArgs('floor', arguments, 1, 1);
      Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(x));
      return new Sk.builtin.nmber(Math.floor(Sk.builtin.asnum$(x)), Sk.builtin.nmber.float$);
    });
    mod.sqrt = Sk.ffi.functionPy(function (x) {
      Sk.ffi.checkFunctionArgs('sqrt', arguments, 1, 1);
      if (Sk.ffi.isNum(x)) {
        return Sk.ffi.numberToFloatPy(Math.sqrt(Sk.ffi.remapToJs(x)));
      } else {
        return Sk.ffh.sqrt(x);
      }
    });
    mod.trunc = Sk.ffi.functionPy(function (x) {
      Sk.ffi.checkFunctionArgs('trunc', arguments, 1, 1);
      Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(x));
      return new Sk.builtin.nmber(Sk.builtin.asnum$(x) | 0, Sk.builtin.nmber.float$);
    });
    mod.log = Sk.ffi.functionPy(function (x, base) {
      Sk.ffi.checkFunctionArgs('log', arguments, 1, 2);
      Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(x));
      if (base === undefined) {
        return new Sk.builtin.nmber(Math.log(Sk.builtin.asnum$(x)), Sk.builtin.nmber.float$);
      } else {
        Sk.builtin.pyCheckType('base', 'number', Sk.builtin.checkNumber(base));
        var ret = Math.log(Sk.builtin.asnum$(x)) / Math.log(Sk.builtin.asnum$(base));
        return new Sk.builtin.nmber(ret, Sk.builtin.nmber.float$);
      }
    });
    mod.log10 = Sk.ffi.functionPy(function (x) {
      Sk.ffi.checkFunctionArgs('log10', arguments, 1, 1);
      Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(x));
      var ret = Math.log(Sk.builtin.asnum$(x)) / Math.log(10);
      return new Sk.builtin.nmber(ret, Sk.builtin.nmber.float$);
    });
    mod.pow = Sk.ffi.functionPy(function (x, y) {
      Sk.ffi.checkFunctionArgs('pow', arguments, 2, 2);
      Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(x));
      Sk.builtin.pyCheckType('y', 'number', Sk.builtin.checkNumber(y));
      return new Sk.builtin.nmber(Math.pow(Sk.builtin.asnum$(x), Sk.builtin.asnum$(y)), Sk.builtin.nmber.float$);
    });
    mod.radians = Sk.ffi.functionPy(function (deg) {
      Sk.ffi.checkFunctionArgs('radians', arguments, 1, 1);
      Sk.builtin.pyCheckType('deg', 'number', Sk.builtin.checkNumber(deg));
      var ret = Math.PI / 180 * Sk.builtin.asnum$(deg);
      return new Sk.builtin.nmber(ret, Sk.builtin.nmber.float$);
    });
    mod.degrees = Sk.ffi.functionPy(function (rad) {
      Sk.ffi.checkFunctionArgs('degrees', arguments, 1, 1);
      Sk.builtin.pyCheckType('rad', 'number', Sk.builtin.checkNumber(rad));
      var ret = 180 / Math.PI * Sk.builtin.asnum$(rad);
      return new Sk.builtin.nmber(ret, Sk.builtin.nmber.float$);
    });
    mod.hypot = Sk.ffi.functionPy(function (x, y) {
      Sk.ffi.checkFunctionArgs('hypot', arguments, 2, 2);
      Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(x));
      Sk.builtin.pyCheckType('y', 'number', Sk.builtin.checkNumber(y));
      x = Sk.builtin.asnum$(x);
      y = Sk.builtin.asnum$(y);
      return new Sk.builtin.nmber(Math.sqrt(x * x + y * y), Sk.builtin.nmber.float$);
    });
    mod.factorial = Sk.ffi.functionPy(function (x) {
      Sk.ffi.checkFunctionArgs('factorial', arguments, 1, 1);
      Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(x));
      x = Math.floor(Sk.builtin.asnum$(x));
      var r = 1;
      for (var i = 2; i <= x; i++)
        r *= i;
      return new Sk.builtin.nmber(r, Sk.builtin.nmber.int$);
    });
    mod.conjugate = Sk.ffi.functionPy(function (numberPy) {
      Sk.ffi.checkFunctionArgs('conjugate', arguments, 1, 1);
      if (Sk.ffi.isNum(numberPy)) {
        return numberPy;
      } else {
        return Sk.ffh.conjugate(numberPy);
      }
    });
    mod.magnitude = Sk.ffi.functionPy(function (numberPy) {
      Sk.ffi.checkFunctionArgs('magnitude', arguments, 1, 1);
      return Sk.ffh.magnitude(numberPy);
    });
    mod.quadrance = Sk.ffi.functionPy(function (numberPy) {
      Sk.ffi.checkFunctionArgs('quadrance', arguments, 1, 1);
      return Sk.ffh.quadrance(numberPy);
    });
  };
}.call(this));
Sk.matrix = Sk.matrix || {};
Sk.matrix.MATRIX_2x1 = 'Matrix2x1';
Sk.matrix.MATRIX_2x2 = 'Matrix2x2';
Sk.matrix.MATRIX_1x2 = 'Matrix1x2';
(function () {
  Sk.builtin.defineMatrix = function (mod) {
    Sk.ffi.checkFunctionArgs('defineMatrix', arguments, 1, 1);
    var ARG_OTHER = 'other';
    var ARG_INDEX = 'index';
    var NUMBER = 'Number';
    var OP_MUL = '*';
    var METHOD_CONJUGATE = 'conjugate';
    var METHOD_TRANSPOSE = 'transpose';
    var LPAREN = '(';
    var RPAREN = ')';
    var LSQB = '[';
    var RSQB = ']';
    var NEWLINE = '\n';
    var COMMA = ',';
    var SPACE = ' ';
    mod[Sk.matrix.MATRIX_2x1] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, onePy, twoPy) {
        Sk.ffi.checkMethodArgs(Sk.matrix.MATRIX_2x1, arguments, 2, 2);
        Sk.ffi.referenceToPy({
          'elements': [
            onePy,
            twoPy
          ]
        }, Sk.matrix.MATRIX_2x1, undefined, selfPy);
      });
      $loc.__add__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var lhs = Sk.ffi.remapToJs(selfPy).elements;
        var rhs = Sk.ffi.remapToJs(otherPy).elements;
        var onePy = Sk.ffh.add(lhs[0], rhs[0]);
        var twoPy = Sk.ffh.add(lhs[1], rhs[1]);
        return Sk.ffi.callsim(mod[Sk.matrix.MATRIX_2x1], onePy, twoPy);
      });
      $loc.__sub__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var lhs = Sk.ffi.remapToJs(selfPy).elements;
        var rhs = Sk.ffi.remapToJs(otherPy).elements;
        var onePy = Sk.ffh.subtract(lhs[0], rhs[0]);
        var twoPy = Sk.ffh.subtract(lhs[1], rhs[1]);
        return Sk.ffi.callsim(mod[Sk.matrix.MATRIX_2x1], onePy, twoPy);
      });
      $loc.__mul__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        if (Sk.ffi.isInstance(otherPy, Sk.matrix.MATRIX_2x1)) {
          throw Sk.ffi.assertionError('multiplication with 2x1 is not supported.');
        } else {
          var lhs = Sk.ffi.remapToJs(selfPy).elements;
          var onePy = Sk.ffh.multiply(lhs[0], otherPy);
          var twoPy = Sk.ffh.multiply(lhs[1], otherPy);
          return Sk.ffi.callsim(mod[Sk.matrix.MATRIX_2x1], onePy, twoPy);
        }
      });
      $loc.__rmul__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var rhs = Sk.ffi.remapToJs(selfPy).elements;
        var onePy = Sk.ffh.multiply(otherPy, rhs[0]);
        var twoPy = Sk.ffh.multiply(otherPy, rhs[1]);
        return Sk.ffi.callsim(mod[Sk.matrix.MATRIX_2x1], onePy, twoPy);
      });
      $loc.__div__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var lhs = Sk.ffi.remapToJs(selfPy).elements;
        var onePy = Sk.ffh.divide(lhs[0], otherPy);
        var twoPy = Sk.ffh.divide(lhs[1], otherPy);
        return Sk.ffi.callsim(mod[Sk.matrix.MATRIX_2x1], onePy, twoPy);
      });
      $loc.__conjugate__ = Sk.ffi.functionPy(function (selfPy) {
        Sk.ffi.checkMethodArgs(METHOD_CONJUGATE, arguments, 0, 0);
        return Sk.ffi.callsim(mod[Sk.matrix.MATRIX_2x1], Sk.ffh.conjugate(Sk.ffh.getitem(selfPy, 0)), Sk.ffh.conjugate(Sk.ffh.getitem(selfPy, 1)));
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var matrix = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case METHOD_TRANSPOSE: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy) {
              Sk.ffi.checkMethodArgs(name, arguments, 0, 0);
              return Sk.ffi.callsim(mod[Sk.matrix.MATRIX_1x2], Sk.ffh.getitem(selfPy, 0), Sk.ffh.getitem(selfPy, 1));
            });
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(Sk.matrix.MATRIX_2x1);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        switch (name) {
        default: {
            throw Sk.ffi.err.attribute(name).isNotSetableOnType(Sk.matrix.MATRIX_2x1);
          }
        }
      });
      $loc.__getitem__ = Sk.ffi.functionPy(function (selfPy, indexPy) {
        Sk.ffi.checkMethodArgs('[]', arguments, 1, 1);
        Sk.ffi.checkArgType(ARG_INDEX, Sk.ffi.PyType.INT, Sk.ffi.isInt(indexPy), indexPy);
        var index = Sk.ffi.remapToJs(indexPy);
        var self = Sk.ffi.remapToJs(selfPy);
        var xs = self.elements;
        switch (index) {
        case 0: {
            return xs[0];
          }
        case 1: {
            return xs[1];
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var x = self.elements;
        var args = [
            x[0],
            x[1]
          ].map(function (xPy) {
            return Sk.ffi.remapToJs(Sk.ffh.str(xPy));
          }).join(COMMA + SPACE);
        return Sk.ffi.stringToPy(LPAREN + args + RPAREN);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var x = self.elements;
        var args = [
            x[0],
            x[1]
          ].map(function (xPy) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(xPy));
          }).join(COMMA + SPACE);
        return Sk.ffi.stringToPy(Sk.matrix.MATRIX_2x1 + LPAREN + args + RPAREN);
      });
    }, Sk.matrix.MATRIX_2x1, []);
    mod[Sk.matrix.MATRIX_1x2] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, onePy, twoPy) {
        Sk.ffi.checkMethodArgs(Sk.matrix.MATRIX_1x2, arguments, 2, 2);
        Sk.ffi.referenceToPy({
          'elements': [
            onePy,
            twoPy
          ]
        }, Sk.matrix.MATRIX_1x2, undefined, selfPy);
      });
      $loc.__add__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var lhs = Sk.ffi.remapToJs(selfPy).elements;
        var rhs = Sk.ffi.remapToJs(otherPy).elements;
        var onePy = Sk.ffh.add(lhs[0], rhs[0]);
        var twoPy = Sk.ffh.add(lhs[1], rhs[1]);
        return Sk.ffi.callsim(mod[Sk.matrix.MATRIX_1x2], onePy, twoPy);
      });
      $loc.__sub__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var lhs = Sk.ffi.remapToJs(selfPy).elements;
        var rhs = Sk.ffi.remapToJs(otherPy).elements;
        var onePy = Sk.ffh.subtract(lhs[0], rhs[0]);
        var twoPy = Sk.ffh.subtract(lhs[1], rhs[1]);
        return Sk.ffi.callsim(mod[Sk.matrix.MATRIX_1x2], onePy, twoPy);
      });
      $loc.__mul__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        if (Sk.ffi.isInstance(otherPy, Sk.matrix.MATRIX_2x1)) {
          return Sk.ffh.add(Sk.ffh.multiply(Sk.ffh.getitem(selfPy, 0), Sk.ffh.getitem(otherPy, 0)), Sk.ffh.multiply(Sk.ffh.getitem(selfPy, 1), Sk.ffh.getitem(otherPy, 1)));
        } else if (Sk.ffi.isInstance(otherPy, Sk.matrix.MATRIX_1x2)) {
          throw Sk.ffi.assertionError('multiplication with 2x1 is not supported.');
        } else {
          var lhs = Sk.ffi.remapToJs(selfPy).elements;
          var onePy = Sk.ffh.multiply(lhs[0], otherPy);
          var twoPy = Sk.ffh.multiply(lhs[1], otherPy);
          return Sk.ffi.callsim(mod[Sk.matrix.MATRIX_1x2], onePy, twoPy);
        }
      });
      $loc.__rmul__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var rhs = Sk.ffi.remapToJs(selfPy).elements;
        var onePy = Sk.ffh.multiply(otherPy, rhs[0]);
        var twoPy = Sk.ffh.multiply(otherPy, rhs[1]);
        return Sk.ffi.callsim(mod[Sk.matrix.MATRIX_1x2], onePy, twoPy);
      });
      $loc.__div__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var lhs = Sk.ffi.remapToJs(selfPy).elements;
        var onePy = Sk.ffh.divide(lhs[0], otherPy);
        var twoPy = Sk.ffh.divide(lhs[1], otherPy);
        return Sk.ffi.callsim(mod[Sk.matrix.MATRIX_1x2], onePy, twoPy);
      });
      $loc.__conjugate__ = Sk.ffi.functionPy(function (selfPy) {
        Sk.ffi.checkMethodArgs(METHOD_CONJUGATE, arguments, 0, 0);
        return Sk.ffi.callsim(mod[Sk.matrix.MATRIX_1x2], Sk.ffh.conjugate(Sk.ffh.getitem(selfPy, 0)), Sk.ffh.conjugate(Sk.ffh.getitem(selfPy, 1)));
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var matrix = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case METHOD_TRANSPOSE: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy) {
              Sk.ffi.checkMethodArgs(name, arguments, 0, 0);
              return Sk.ffi.callsim(mod[Sk.matrix.MATRIX_2x1], Sk.ffh.getitem(selfPy, 0), Sk.ffh.getitem(selfPy, 1));
            });
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(Sk.matrix.MATRIX_1x2);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        switch (name) {
        default: {
            throw Sk.ffi.err.attribute(name).isNotSetableOnType(Sk.matrix.MATRIX_1x2);
          }
        }
      });
      $loc.__getitem__ = Sk.ffi.functionPy(function (selfPy, indexPy) {
        Sk.ffi.checkMethodArgs('[]', arguments, 1, 1);
        Sk.ffi.checkArgType(ARG_INDEX, Sk.ffi.PyType.INT, Sk.ffi.isInt(indexPy), indexPy);
        var index = Sk.ffi.remapToJs(indexPy);
        var self = Sk.ffi.remapToJs(selfPy);
        var xs = self.elements;
        switch (index) {
        case 0: {
            return xs[0];
          }
        case 1: {
            return xs[1];
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var args = [
            Sk.ffh.getitem(selfPy, 0),
            Sk.ffh.getitem(selfPy, 1)
          ].map(function (xPy) {
            return Sk.ffi.remapToJs(Sk.ffh.str(xPy));
          }).join(SPACE);
        return Sk.ffi.stringToPy(LSQB + args + RSQB);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var args = [
            Sk.ffh.getitem(selfPy, 0),
            Sk.ffh.getitem(selfPy, 1)
          ].map(function (xPy) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(xPy));
          }).join(COMMA + SPACE);
        return Sk.ffi.stringToPy(Sk.matrix.MATRIX_1x2 + LPAREN + args + RPAREN);
      });
    }, Sk.matrix.MATRIX_1x2, []);
    mod[Sk.matrix.MATRIX_2x2] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, onePy, twoPy) {
        Sk.ffi.checkMethodArgs(Sk.matrix.MATRIX_2x2, arguments, 2, 2);
        Sk.ffi.checkArgType('one', Sk.matrix.MATRIX_2x1, Sk.ffi.isInstance(onePy, Sk.matrix.MATRIX_2x1), onePy);
        Sk.ffi.checkArgType('two', Sk.matrix.MATRIX_2x1, Sk.ffi.isInstance(twoPy, Sk.matrix.MATRIX_2x1), twoPy);
        Sk.ffi.referenceToPy({
          'elements': [
            onePy,
            twoPy
          ]
        }, Sk.matrix.MATRIX_2x2, undefined, selfPy);
      });
      $loc.__add__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var lhs = Sk.ffi.remapToJs(selfPy).elements;
        var rhs = Sk.ffi.remapToJs(otherPy).elements;
        var onePy = Sk.ffh.add(lhs[0], rhs[0]);
        var twoPy = Sk.ffh.add(lhs[1], rhs[1]);
        return Sk.ffi.callsim(mod[Sk.matrix.MATRIX_2x2], onePy, twoPy);
      });
      $loc.__sub__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var lhs = Sk.ffi.remapToJs(selfPy).elements;
        var rhs = Sk.ffi.remapToJs(otherPy).elements;
        var onePy = Sk.ffh.subtract(lhs[0], rhs[0]);
        var twoPy = Sk.ffh.subtract(lhs[1], rhs[1]);
        return Sk.ffi.callsim(mod[Sk.matrix.MATRIX_2x2], onePy, twoPy);
      });
      $loc.__mul__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var a00 = Sk.ffh.getitem(Sk.ffh.getitem(selfPy, 0), 0);
        var a01 = Sk.ffh.getitem(Sk.ffh.getitem(selfPy, 0), 1);
        var a10 = Sk.ffh.getitem(Sk.ffh.getitem(selfPy, 1), 0);
        var a11 = Sk.ffh.getitem(Sk.ffh.getitem(selfPy, 1), 1);
        if (Sk.ffi.isInstance(otherPy, Sk.matrix.MATRIX_2x2)) {
          var b00 = Sk.ffh.getitem(Sk.ffh.getitem(otherPy, 0), 0);
          var b01 = Sk.ffh.getitem(Sk.ffh.getitem(otherPy, 0), 1);
          var b10 = Sk.ffh.getitem(Sk.ffh.getitem(otherPy, 1), 0);
          var b11 = Sk.ffh.getitem(Sk.ffh.getitem(otherPy, 1), 1);
          var x00 = Sk.ffh.add(Sk.ffh.multiply(a00, b00), Sk.ffh.multiply(a10, b01));
          var x01 = Sk.ffh.add(Sk.ffh.multiply(a01, b00), Sk.ffh.multiply(a11, b01));
          var x10 = Sk.ffh.add(Sk.ffh.multiply(a00, b10), Sk.ffh.multiply(a10, b11));
          var x11 = Sk.ffh.add(Sk.ffh.multiply(a01, b10), Sk.ffh.multiply(a11, b11));
          var onePy = Sk.ffi.callsim(mod[Sk.matrix.MATRIX_2x1], x00, x01);
          var twoPy = Sk.ffi.callsim(mod[Sk.matrix.MATRIX_2x1], x10, x11);
          return Sk.ffi.callsim(mod[Sk.matrix.MATRIX_2x2], onePy, twoPy);
        } else if (Sk.ffi.isInstance(otherPy, Sk.matrix.MATRIX_2x1)) {
          var b0 = Sk.ffh.getitem(otherPy, 0);
          var b1 = Sk.ffh.getitem(otherPy, 1);
          var onePy = Sk.ffh.add(Sk.ffh.multiply(a00, b0), Sk.ffh.multiply(a10, b1));
          var twoPy = Sk.ffh.add(Sk.ffh.multiply(a01, b0), Sk.ffh.multiply(a11, b1));
          return Sk.ffi.callsim(mod[Sk.matrix.MATRIX_2x1], onePy, twoPy);
        } else {
          var x00 = Sk.ffh.multiply(a00, otherPy);
          var x01 = Sk.ffh.multiply(a01, otherPy);
          var x10 = Sk.ffh.multiply(a10, otherPy);
          var x11 = Sk.ffh.multiply(a11, otherPy);
          var onePy = Sk.ffi.callsim(mod[Sk.matrix.MATRIX_2x1], x00, x01);
          var twoPy = Sk.ffi.callsim(mod[Sk.matrix.MATRIX_2x1], x10, x11);
          return Sk.ffi.callsim(mod[Sk.matrix.MATRIX_2x2], onePy, twoPy);
        }
      });
      $loc.__rmul__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var a00 = Sk.ffh.getitem(Sk.ffh.getitem(selfPy, 0), 0);
        var a01 = Sk.ffh.getitem(Sk.ffh.getitem(selfPy, 0), 1);
        var a10 = Sk.ffh.getitem(Sk.ffh.getitem(selfPy, 1), 0);
        var a11 = Sk.ffh.getitem(Sk.ffh.getitem(selfPy, 1), 1);
        if (Sk.ffi.isInstance(otherPy, Sk.matrix.MATRIX_1x2)) {
          var b00 = Sk.ffh.getitem(Sk.ffh.getitem(otherPy, 0), 0);
          var b01 = Sk.ffh.getitem(Sk.ffh.getitem(otherPy, 0), 1);
          var b10 = Sk.ffh.getitem(Sk.ffh.getitem(otherPy, 1), 0);
          var b11 = Sk.ffh.getitem(Sk.ffh.getitem(otherPy, 1), 1);
          var x00 = Sk.ffh.add(Sk.ffh.multiply(a00, b00), Sk.ffh.multiply(a10, b01));
          var x01 = Sk.ffh.add(Sk.ffh.multiply(a01, b00), Sk.ffh.multiply(a11, b01));
          var x10 = Sk.ffh.add(Sk.ffh.multiply(a00, b10), Sk.ffh.multiply(a10, b11));
          var x11 = Sk.ffh.add(Sk.ffh.multiply(a01, b10), Sk.ffh.multiply(a11, b11));
          var onePy = Sk.ffi.callsim(mod[Sk.matrix.MATRIX_2x1], x00, x01);
          var twoPy = Sk.ffi.callsim(mod[Sk.matrix.MATRIX_2x1], x10, x11);
          return Sk.ffi.callsim(mod[Sk.matrix.MATRIX_2x2], onePy, twoPy);
        } else {
          var x00 = Sk.ffh.multiply(otherPy, a00);
          var x01 = Sk.ffh.multiply(otherPy, a01);
          var x10 = Sk.ffh.multiply(otherPy, a10);
          var x11 = Sk.ffh.multiply(otherPy, a11);
          var onePy = Sk.ffi.callsim(mod[Sk.matrix.MATRIX_2x1], x00, x01);
          var twoPy = Sk.ffi.callsim(mod[Sk.matrix.MATRIX_2x1], x10, x11);
          return Sk.ffi.callsim(mod[Sk.matrix.MATRIX_2x2], onePy, twoPy);
        }
      });
      $loc.__div__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var lhs = Sk.ffi.remapToJs(selfPy).elements;
        var onePy = Sk.ffh.divide(lhs[0], otherPy);
        var twoPy = Sk.ffh.divide(lhs[1], otherPy);
        return Sk.ffi.callsim(mod[Sk.matrix.MATRIX_2x2], onePy, twoPy);
      });
      $loc.__conjugate__ = Sk.ffi.functionPy(function (selfPy) {
        Sk.ffi.checkMethodArgs(METHOD_CONJUGATE, arguments, 0, 0);
        return Sk.ffi.callsim(mod[Sk.matrix.MATRIX_2x2], Sk.ffh.conjugate(Sk.ffh.getitem(selfPy, 0)), Sk.ffh.conjugate(Sk.ffh.getitem(selfPy, 1)));
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var matrix = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case METHOD_TRANSPOSE: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy) {
              Sk.ffi.checkMethodArgs(name, arguments, 0, 0);
              var c0 = Sk.ffh.getitem(selfPy, 0);
              var c1 = Sk.ffh.getitem(selfPy, 1);
              var onePy = Sk.ffi.callsim(mod[Sk.matrix.MATRIX_2x1], Sk.ffh.getitem(c0, 0), Sk.ffh.getitem(c1, 0));
              var twoPy = Sk.ffi.callsim(mod[Sk.matrix.MATRIX_2x1], Sk.ffh.getitem(c0, 1), Sk.ffh.getitem(c1, 1));
              return Sk.ffi.callsim(mod[Sk.matrix.MATRIX_2x2], onePy, twoPy);
            });
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(Sk.matrix.MATRIX_2x2);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        switch (name) {
        default: {
            throw Sk.ffi.err.attribute(name).isNotSetableOnType(Sk.matrix.MATRIX_2x2);
          }
        }
      });
      $loc.__getitem__ = Sk.ffi.functionPy(function (selfPy, indexPy) {
        Sk.ffi.checkMethodArgs('[]', arguments, 1, 1);
        Sk.ffi.checkArgType(ARG_INDEX, Sk.ffi.PyType.INT, Sk.ffi.isInt(indexPy), indexPy);
        var index = Sk.ffi.remapToJs(indexPy);
        var self = Sk.ffi.remapToJs(selfPy);
        var xs = self.elements;
        switch (index) {
        case 0: {
            return xs[0];
          }
        case 1: {
            return xs[1];
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var args = [
            Sk.ffh.getitem(selfPy, 0),
            Sk.ffh.getitem(selfPy, 1)
          ].map(function (xPy) {
            return Sk.ffi.remapToJs(Sk.ffh.str(xPy));
          }).join(SPACE);
        return Sk.ffi.stringToPy(LSQB + args + RSQB);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var args = [
            Sk.ffh.getitem(selfPy, 0),
            Sk.ffh.getitem(selfPy, 1)
          ].map(function (xPy) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(xPy));
          }).join(COMMA + SPACE);
        return Sk.ffi.stringToPy(Sk.matrix.MATRIX_2x2 + LPAREN + args + RPAREN);
      });
    }, Sk.matrix.MATRIX_2x2, []);
  };
}.call(this));
(function () {
  Sk.builtin.defineComplex = function (mod, COMPLEX) {
    Sk.ffi.checkFunctionArgs('defineComplex', arguments, 2, 2);
    var PROP_REAL = 'real';
    var PROP_IMAG = 'imag';
    var METHOD_ABS = 'abs';
    var METHOD_CONJUGATE = 'conjugate';
    var METHOD_COS = 'cos';
    var METHOD_EXP = 'exp';
    var NUM = [
        Sk.ffi.PyType.FLOAT,
        Sk.ffi.PyType.INT,
        Sk.ffi.PyType.LONG
      ];
    var ARG_OTHER = 'other';
    var OP_ADD = '+';
    var OP_SUB = '-';
    var OP_MUL = '*';
    var OP_DIV = '/';
    function isComplexPy(valuePy) {
      return Sk.ffi.isInstance(valuePy, COMPLEX);
    }
    ;
    function phase(x, y) {
      return Math.atan2(y, x);
    }
    function norm(x, y) {
      return Math.sqrt(x * x + y * y);
    }
    function cosh(x) {
      return (Math.pow(Math.E, x) + Math.pow(Math.E, -x)) / 2;
    }
    function sinh(x) {
      return (Math.pow(Math.E, x) - Math.pow(Math.E, -x)) / 2;
    }
    function stringFromCoordinates(coordinates, labels, multiplier) {
      var append, i, sb, str, _i, _ref;
      sb = [];
      append = function (number, label) {
        var n;
        if (number !== 0) {
          if (number >= 0) {
            if (sb.length > 0) {
              sb.push('+');
            }
          } else {
            sb.push('-');
          }
          n = Math.abs(number);
          if (n === 1) {
            return sb.push(label);
          } else {
            sb.push(n.toString());
            if (label !== '1') {
              sb.push(multiplier);
              return sb.push(label);
            }
          }
        }
      };
      for (i = _i = 0, _ref = coordinates.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        append(coordinates[i], labels[i]);
      }
      if (sb.length > 0) {
        str = sb.join('');
      } else {
        str = '0';
      }
      return str;
    }
    function cartesianJsToComplexPy(x, y) {
      return Sk.ffi.callsim(mod[COMPLEX], Sk.ffi.numberToFloatPy(x), Sk.ffi.numberToFloatPy(y));
    }
    mod[COMPLEX] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, rePy, imPy) {
        Sk.ffi.checkMethodArgs(COMPLEX, arguments, 2, 2);
        Sk.ffi.checkArgType(PROP_REAL, NUM, Sk.ffi.isNum(rePy), rePy);
        Sk.ffi.checkArgType(PROP_IMAG, NUM, Sk.ffi.isNum(imPy), imPy);
        Sk.ffi.referenceToPy({
          x: Sk.ffi.remapToJs(rePy),
          y: Sk.ffi.remapToJs(imPy)
        }, COMPLEX, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var z = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case PROP_REAL: {
            return Sk.ffi.numberToFloatPy(z.x);
          }
        case PROP_IMAG: {
            return Sk.ffi.numberToFloatPy(z.y);
          }
        case METHOD_ABS: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy) {
              return Sk.ffi.numberToFloatPy(Math.sqrt(z.x * z.x + z.y * z.y));
            });
          }
        case METHOD_CONJUGATE: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy) {
              return cartesianJsToComplexPy(z.x, -z.y);
            });
          }
        case METHOD_EXP: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy) {
              var e = Math.exp(z.x);
              var c = Sk.math.cos(z.y);
              var s = Sk.math.sin(z.y);
              return cartesianJsToComplexPy(e * c, e * s);
            });
          }
        }
      });
      $loc.__add__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var a = Sk.ffi.remapToJs(selfPy);
        var b = Sk.ffi.remapToJs(otherPy);
        if (isComplexPy(otherPy)) {
          return cartesianJsToComplexPy(a.x + b.x, a.y + b.y);
        } else if (Sk.ffi.isNum(otherPy)) {
          return cartesianJsToComplexPy(a.x + b, a.y);
        } else {
          throw Sk.ffi.err.argument(ARG_OTHER).mustHaveType(COMPLEX);
        }
      });
      $loc.__radd__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkArgType(ARG_OTHER, NUM, Sk.ffi.isNum(otherPy), otherPy);
        var a = Sk.ffi.remapToJs(otherPy);
        var b = Sk.ffi.remapToJs(selfPy);
        return cartesianJsToComplexPy(a + b.x, b.y);
      });
      $loc.__iadd__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var a = Sk.ffi.remapToJs(selfPy);
        var b = Sk.ffi.remapToJs(otherPy);
        if (Sk.ffi.isNum(otherPy)) {
          a.x += b;
        } else if (isComplexPy(otherPy)) {
          a.x += b.x;
          a.y += b.y;
        } else {
          throw Sk.ffi.err.argument(ARG_OTHER).mustHaveType([
            COMPLEX,
            NUM
          ]);
        }
        return selfPy;
      });
      $loc.__sub__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var a = Sk.ffi.remapToJs(selfPy);
        var b = Sk.ffi.remapToJs(otherPy);
        if (isComplexPy(otherPy)) {
          return cartesianJsToComplexPy(a.x - b.x, a.y - b.y);
        } else if (Sk.ffi.isNum(otherPy)) {
          return cartesianJsToComplexPy(a.x - b, a.y);
        } else {
          throw Sk.ffi.err.argument(ARG_OTHER).mustHaveType([
            COMPLEX,
            NUM
          ]);
        }
      });
      $loc.__rsub__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var x, y;
        var a = Sk.ffi.remapToJs(otherPy);
        var b = Sk.ffi.remapToJs(selfPy);
        if (Sk.ffi.isNum(otherPy)) {
          x = a - b.x;
          y = -b.y;
          return cartesianJsToComplexPy(x, y);
        } else {
          throw Sk.ffi.err.argument(ARG_OTHER).mustHaveType(NUM);
        }
      });
      $loc.__isub__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var a = Sk.ffi.remapToJs(selfPy);
        var b = Sk.ffi.remapToJs(otherPy);
        if (Sk.ffi.isNum(otherPy)) {
          a.x -= b;
        } else {
          a.x -= b.x;
          a.y -= b.y;
        }
        return selfPy;
      });
      $loc.__mul__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var x, y;
        var a = Sk.ffi.remapToJs(selfPy);
        var b = Sk.ffi.remapToJs(otherPy);
        if (isComplexPy(otherPy)) {
          x = a.x * b.x - a.y * b.y;
          y = a.y * b.x + a.x * b.y;
          return cartesianJsToComplexPy(x, y);
        } else if (Sk.ffi.isNum(otherPy)) {
          x = a.x * b;
          y = a.y * b;
          return cartesianJsToComplexPy(x, y);
        } else {
          return undefined;
        }
      });
      $loc.__rmul__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var x, y;
        var a = Sk.ffi.remapToJs(otherPy);
        var b = Sk.ffi.remapToJs(selfPy);
        if (isComplexPy(otherPy)) {
          x = b.x * a.x - b.y * a.y;
          y = b.y * a.x + b.x * a.y;
          return cartesianJsToComplexPy(x, y);
        } else if (Sk.ffi.isNum(otherPy)) {
          x = a * b.x;
          y = a * b.y;
          return cartesianJsToComplexPy(x, y);
        } else {
          return undefined;
        }
      });
      $loc.__imul__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var a = Sk.ffi.remapToJs(selfPy);
        var aX = a.x;
        var aY = a.y;
        var b = Sk.ffi.remapToJs(otherPy);
        if (Sk.ffi.isNum(otherPy)) {
          a.x *= b;
          a.y *= b;
        } else {
          a.x = aX * b.x - aY * b.y;
          a.y = aY * b.x + aX * b.y;
        }
        return selfPy;
      });
      $loc.__div__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var a = Sk.ffi.remapToJs(selfPy);
        var b = Sk.ffi.remapToJs(otherPy);
        if (isComplexPy(otherPy)) {
          var factor = b.x * b.x + b.y * b.y;
          return cartesianJsToComplexPy((a.x * b.x + a.y * b.y) / factor, (a.y * b.x - a.x * b.y) / factor);
        } else if (Sk.ffi.isNum(otherPy)) {
          return cartesianJsToComplexPy(a.x / b, a.y / b);
        } else {
          Sk.ffi.checkArgType(ARG_OTHER, [
            COMPLEX,
            NUM
          ], false, otherPy);
        }
      });
      $loc.__rdiv__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkArgType(ARG_OTHER, NUM, Sk.ffi.isNum(otherPy), otherPy);
        var a = Sk.ffi.remapToJs(otherPy);
        var b = Sk.ffi.remapToJs(selfPy);
        if (Sk.ffi.isNum(otherPy)) {
          var factor = b.x * b.x + b.y * b.y;
          return cartesianJsToComplexPy(a * b.x / factor, -a * b.y / factor);
        } else {
          throw Sk.ffi.err.argument(ARG_OTHER).mustHaveType(NUM);
        }
      });
      $loc.__idiv__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var a = Sk.ffi.remapToJs(selfPy);
        var aX = a.x;
        var aY = a.y;
        var b = Sk.ffi.remapToJs(otherPy);
        if (Sk.ffi.isNum(otherPy)) {
          a.x /= b;
          a.y /= b;
        } else {
          var factor = b.x * b.x + b.y * b.y;
          a.x = (aX * b.x + aY * b.y) / factor;
          a.y = (aY * b.x - aX * b.y) / factor;
        }
        return selfPy;
      });
      $loc.__abs__ = Sk.ffi.functionPy(function (selfPy) {
        var z = Sk.ffi.remapToJs(selfPy);
        return Sk.ffi.numberToFloatPy(Math.sqrt(z.x * z.x + z.y * z.y));
      });
      $loc.__conjugate__ = Sk.ffi.functionPy(function (selfPy) {
        var z = Sk.ffi.remapToJs(selfPy);
        return cartesianJsToComplexPy(z.x, -z.y);
      });
      $loc.__cos__ = Sk.ffi.functionPy(function (selfPy) {
        var z = Sk.ffi.remapToJs(selfPy);
        var x = z.x;
        var y = z.y;
        var cosX = Sk.math.cos(x);
        var coshY = cosh(y);
        var sinX = Sk.math.sin(x);
        var sinhY = sinh(y);
        return cartesianJsToComplexPy(cosX * coshY, -sinX * sinhY);
      });
      $loc.__sin__ = Sk.ffi.functionPy(function (selfPy) {
        var z = Sk.ffi.remapToJs(selfPy);
        var x = z.x;
        var y = z.y;
        var cosX = Sk.math.cos(x);
        var coshY = cosh(y);
        var sinX = Sk.math.sin(x);
        var sinhY = sinh(y);
        return cartesianJsToComplexPy(sinX * coshY, cosX * sinhY);
      });
      $loc.__exp__ = Sk.ffi.functionPy(function (selfPy) {
        var z = Sk.ffi.remapToJs(selfPy);
        var e = Math.exp(z.x);
        var c = Sk.math.cos(z.y);
        var s = Sk.math.sin(z.y);
        return cartesianJsToComplexPy(e * c, e * s);
      });
      $loc.__magnitude__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffh.sqrt(Sk.ffh.quadrance(selfPy));
      });
      $loc.__quadrance__ = Sk.ffi.functionPy(function (selfPy) {
        var z = Sk.ffi.remapToJs(selfPy);
        return cartesianJsToComplexPy(z.x * z.x + z.y * z.y, 0);
      });
      $loc.__sqrt__ = Sk.ffi.functionPy(function (selfPy) {
        var z = Sk.ffi.remapToJs(selfPy);
        if (z.y !== 0) {
          if (z.x !== 0) {
            var a = Math.sqrt((z.x + Math.sqrt(z.x * z.x + z.y * z.y)) / 2);
            var b = z.y / (2 * a);
            return cartesianJsToComplexPy(a, b);
          } else {
            var a = Math.sqrt(Math.abs(z.y) / 2);
            var b = z.y / (2 * a);
            return cartesianJsToComplexPy(a, b);
          }
        } else {
          if (z.x !== 0) {
            if (z.x > 0) {
              return cartesianJsToComplexPy(Math.sqrt(z.x), 0);
            } else {
              return cartesianJsToComplexPy(0, Math.sqrt(-z.x));
            }
          } else {
            return cartesianJsToComplexPy(0, 0);
          }
        }
      });
      $loc.__pos__ = Sk.ffi.functionPy(function (selfPy) {
        return selfPy;
      });
      $loc.__neg__ = Sk.ffi.functionPy(function (selfPy) {
        var z = Sk.ffi.remapToJs(selfPy);
        return cartesianJsToComplexPy(-z.x, -z.y);
      });
      $loc.__invert__ = Sk.ffi.functionPy(function (selfPy) {
        var onePy = cartesianJsToComplexPy(1, 0);
        return Sk.ffi.callsim(selfPy['__div__'], onePy, selfPy);
      });
      $loc.__str__ = Sk.ffi.functionPy(function (z) {
        z = Sk.ffi.remapToJs(z);
        return Sk.ffi.stringToPy(stringFromCoordinates([
          z.x,
          z.y
        ], [
          '1',
          'i'
        ], ''));
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (z) {
        z = Sk.ffi.remapToJs(z);
        return Sk.ffi.stringToPy(COMPLEX + '(' + z.x + ', ' + z.y + ')');
      });
      $loc.__eq__ = Sk.ffi.functionPy(function (a, b) {
        a = Sk.ffi.remapToJs(a);
        b = Sk.ffi.remapToJs(b);
        return a.x === b.x && a.y === b.y;
      });
      $loc.__ne__ = Sk.ffi.functionPy(function (a, b) {
        a = Sk.ffi.remapToJs(a);
        b = Sk.ffi.remapToJs(b);
        return a.x !== b.x || a.y !== b.y;
      });
    }, COMPLEX, []);
    mod.phase = Sk.ffi.functionPy(function (xPy) {
      Sk.ffi.checkFunctionArgs('phase', arguments, 1, 1);
      if (isComplexPy(xPy)) {
        var z = Sk.ffi.remapToJs(xPy);
        return Sk.ffi.numberToFloatPy(phase(z.x, z.y));
      } else if (Sk.ffi.isNum(xPy)) {
        return Sk.ffi.numberToFloatPy(Math.atan2(0, Sk.ffi.remapToJs(xPy)));
      } else {
        Sk.ffi.checkArgType('x', COMPLEX, false, xPy);
      }
    });
    mod.polar = Sk.ffi.functionPy(function (xPy) {
      Sk.ffi.checkFunctionArgs('polar', arguments, 1, 1);
      if (isComplexPy(xPy)) {
        var z = Sk.ffi.remapToJs(xPy);
        return Sk.ffi.tuplePy([
          Sk.ffi.numberToFloatPy(norm(z.x, z.y)),
          Sk.ffi.numberToFloatPy(phase(z.x, z.y))
        ]);
      } else if (Sk.ffi.isNum(xPy)) {
        return Sk.ffi.tuplePy([
          Sk.ffi.numberToFloatPy(norm(Sk.ffi.remapToJs(xPy), 0)),
          Sk.ffi.numberToFloatPy(0)
        ]);
      } else {
        Sk.ffi.checkArgType('x', COMPLEX, false, xPy);
      }
    });
  };
}.call(this));
(function () {
  Sk.builtin.defineQuaternion = function (mod, THREE) {
    Sk.ffi.checkFunctionArgs('defineQuaternion', arguments, 2, 2);
    var QUATERNION = 'Quaternion';
    var PROP_X = 'x';
    var PROP_Y = 'y';
    var PROP_Z = 'z';
    var PROP_W = 'w';
    var NUMBER = [
        Sk.ffi.PyType.FLOAT,
        Sk.ffi.PyType.INT,
        Sk.ffi.PyType.LONG
      ];
    var OP_ADD = '+';
    var OP_SUB = '-';
    var OP_MUL = '*';
    var OP_DIV = '/';
    var METHOD_CLONE = 'clone';
    var METHOD_CONJUGATE = 'conjugate';
    var METHOD_COPY = 'copy';
    var METHOD_INVERSE = 'inverse';
    var METHOD_MAGNITUDE = 'magnitude';
    var METHOD_QUADRANCE = 'quadrance';
    var METHOD_NORMALIZE = 'normalize';
    var METHOD_SET = 'set';
    var METHOD_SET_FROM_AXIS_ANGLE = 'setFromAxisAngle';
    var METHOD_SET_FROM_EULER = 'setFromEuler';
    var ARG_OTHER = 'other';
    function isQuaternionPy(valuePy) {
      return Sk.ffi.isInstance(valuePy, QUATERNION);
    }
    ;
    function stringFromCoordinates(coordinates, labels, multiplier) {
      var append, i, sb, str, _i, _ref;
      sb = [];
      append = function (number, label) {
        var n;
        if (number !== 0) {
          if (number >= 0) {
            if (sb.length > 0) {
              sb.push('+');
            }
          } else {
            sb.push('-');
          }
          n = Math.abs(number);
          if (n === 1) {
            return sb.push(label);
          } else {
            sb.push(n.toString());
            if (label !== '1') {
              sb.push(multiplier);
              return sb.push(label);
            }
          }
        }
      };
      for (i = _i = 0, _ref = coordinates.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        append(coordinates[i], labels[i]);
      }
      if (sb.length > 0) {
        str = sb.join('');
      } else {
        str = '0';
      }
      return str;
    }
    function wxyzToPy(w, x, y, z) {
      return Sk.ffi.callsim(mod[QUATERNION], Sk.ffi.numberToFloatPy(x), Sk.ffi.numberToFloatPy(y), Sk.ffi.numberToFloatPy(z), Sk.ffi.numberToFloatPy(w));
    }
    mod[QUATERNION] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, xPy, yPy, zPy, wPy) {
        if (isQuaternionPy(xPy)) {
          Sk.ffi.referenceToPy(Sk.ffi.remapToJs(xPy), QUATERNION, undefined, selfPy);
        } else {
          var x = Sk.ffi.remapToJs(xPy);
          var y = Sk.ffi.remapToJs(yPy);
          var z = Sk.ffi.remapToJs(zPy);
          var w = Sk.ffi.remapToJs(wPy);
          Sk.ffi.referenceToPy(new THREE[QUATERNION](x, y, z, w), QUATERNION, undefined, selfPy);
        }
      });
      $loc.__add__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var a = Sk.ffi.remapToJs(selfPy);
        var b = Sk.ffi.remapToJs(otherPy);
        if (Sk.ffi.isNum(otherPy)) {
          return wxyzToPy(a.w + b, a.x, a.y, a.z);
        } else {
          var w = a.w + b.w;
          var x = a.x + b.x;
          var y = a.y + b.y;
          var z = a.z + b.z;
          return wxyzToPy(w, x, y, z);
        }
      });
      $loc.__radd__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var a = Sk.ffi.remapToJs(otherPy);
        var b = Sk.ffi.remapToJs(selfPy);
        if (Sk.ffi.isNum(otherPy)) {
          return wxyzToPy(a + b.w, b.x, b.y, b.z);
        } else {
          throw Sk.ffi.err.operand(ARG_OTHER).toOperation(OP_ADD).mustHaveType(QUATERNION);
        }
      });
      $loc.__iadd__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var other = Sk.ffi.remapToJs(otherPy);
        if (Sk.ffi.isNum(otherPy)) {
          self.w += other;
        } else {
          self.w += other.w;
          self.x += other.x;
          self.y += other.y;
          self.z += other.z;
        }
        return selfPy;
      });
      $loc.__sub__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var a = Sk.ffi.remapToJs(selfPy);
        var b = Sk.ffi.remapToJs(otherPy);
        if (Sk.ffi.isNum(otherPy)) {
          return wxyzToPy(a.w - b, a.x, a.y, a.z);
        } else {
          var w = a.w - b.w;
          var x = a.x - b.x;
          var y = a.y - b.y;
          var z = a.z - b.z;
          return wxyzToPy(w, x, y, z);
        }
      });
      $loc.__rsub__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var a = Sk.ffi.remapToJs(otherPy);
        var b = Sk.ffi.remapToJs(selfPy);
        if (Sk.ffi.isNum(otherPy)) {
          return wxyzToPy(a - b.w, -b.x, -b.y, -b.z);
        } else {
          throw Sk.ffi.err.operand(ARG_OTHER).toOperation(OP_SUB).mustHaveType(QUATERNION);
        }
      });
      $loc.__isub__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var other = Sk.ffi.remapToJs(otherPy);
        if (Sk.ffi.isNum(otherPy)) {
          self.w -= other;
        } else {
          self.w -= other.w;
          self.x -= other.x;
          self.y -= other.y;
          self.z -= other.z;
        }
        return selfPy;
      });
      $loc.__mul__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var a = Sk.ffi.remapToJs(selfPy);
        var b = Sk.ffi.remapToJs(otherPy);
        if (Sk.ffi.isNum(otherPy)) {
          return wxyzToPy(a.w * b, a.x * b, a.y * b, a.z * b);
        } else {
          var ab = new THREE[QUATERNION](0, 0, 0, 1)['multiplyQuaternions'](a, b);
          return Sk.ffi.callsim(mod[QUATERNION], Sk.ffi.referenceToPy(ab, QUATERNION));
        }
      });
      $loc.__rmul__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var a = Sk.ffi.remapToJs(otherPy);
        var b = Sk.ffi.remapToJs(selfPy);
        if (Sk.ffi.isNum(otherPy)) {
          return wxyzToPy(a * b.w, a * b.x, a * b.y, a * b.z);
        } else {
          throw Sk.ffi.err.operand(ARG_OTHER).toOperation(OP_MUL).mustHaveType(QUATERNION);
        }
      });
      $loc.__imul__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var a = Sk.ffi.remapToJs(selfPy);
        var b = Sk.ffi.remapToJs(otherPy);
        var a0 = a.w;
        var a1 = a.x;
        var a2 = a.y;
        var a3 = a.z;
        var b0, b1, b2, b3, b4, b5, b6, b7;
        if (Sk.ffi.isNum(otherPy)) {
          a.w *= b;
          a.x *= b;
          a.y *= b;
          a.z *= b;
        } else {
          a.multiply(b);
        }
        return selfPy;
      });
      $loc.nb$positive = function () {
        return this;
      };
      $loc.nu$negative = function () {
        var q = Sk.ffi.remapToJs(this);
        return wxyzToPy(-q.w, -q.x, -q.y, -q.z);
      };
      $loc.__eq__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        if (isQuaternionPy(otherPy)) {
          var a = Sk.ffi.remapToJs(selfPy);
          var b = Sk.ffi.remapToJs(otherPy);
          return Sk.ffi.booleanToPy(a.w === b.w && a.x === b.x && a.y === b.y && a.z === b.z);
        } else {
          return Sk.ffi.bool.False;
        }
      });
      $loc.__ne__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        if (isQuaternionPy(otherPy)) {
          var a = Sk.ffi.remapToJs(selfPy);
          var b = Sk.ffi.remapToJs(otherPy);
          return Sk.ffi.booleanToPy(a.w !== b.w || a.x !== b.x || a.y !== b.y || a.z !== b.z);
        } else {
          return Sk.ffi.bool.True;
        }
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (quaternionPy, name) {
        var quaternion = Sk.ffi.remapToJs(quaternionPy);
        switch (name) {
        case PROP_X: {
            return Sk.ffi.numberToFloatPy(quaternion.x);
          }
        case PROP_Y: {
            return Sk.ffi.numberToFloatPy(quaternion.y);
          }
        case PROP_Z: {
            return Sk.ffi.numberToFloatPy(quaternion.z);
          }
        case PROP_W: {
            return Sk.ffi.numberToFloatPy(quaternion.w);
          }
        case METHOD_COPY: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (methodPy) {
                Sk.ffi.referenceToPy(null, METHOD_COPY, null, methodPy);
              });
              $loc.__call__ = Sk.ffi.functionPy(function (methodPy, qPy) {
                Sk.ffi.checkMethodArgs(METHOD_COPY, arguments, 1, 1);
                Sk.ffi.checkArgType('q', QUATERNION, isQuaternionPy(qPy), qPy);
                var q = Sk.ffi.remapToJs(qPy);
                quaternion.copy(q);
                return quaternionPy;
              });
            }, METHOD_COPY, []));
          }
        case METHOD_SET_FROM_AXIS_ANGLE: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (methodPy) {
                Sk.ffi.referenceToPy(null, METHOD_SET_FROM_AXIS_ANGLE, null, methodPy);
              });
              $loc.__call__ = Sk.ffi.functionPy(function (self, axisPy, anglePy) {
                var axis = Sk.ffi.remapToJs(axisPy);
                var angle = Sk.ffi.remapToJs(anglePy);
                quaternion[METHOD_SET_FROM_AXIS_ANGLE](axis, angle);
                return quaternionPy;
              });
            }, METHOD_SET_FROM_AXIS_ANGLE, []));
          }
        case METHOD_SET_FROM_EULER: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (methodPy) {
                Sk.ffi.referenceToPy(null, METHOD_SET_FROM_EULER, null, methodPy);
              });
              $loc.__call__ = Sk.ffi.functionPy(function (self, vectorPy, orderPy) {
                var vector = Sk.ffi.remapToJs(vectorPy);
                var order = Sk.ffi.remapToJs(orderPy);
                quaternion[METHOD_SET_FROM_EULER](vector, order);
                return quaternionPy;
              });
            }, METHOD_SET_FROM_EULER, []));
          }
        case METHOD_SET: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (methodPy) {
                Sk.ffi.referenceToPy(null, METHOD_SET, null, methodPy);
              });
              $loc.__call__ = Sk.ffi.functionPy(function (self, x, y, z, w) {
                quaternion.x = Sk.ffi.remapToJs(x);
                quaternion.y = Sk.ffi.remapToJs(y);
                quaternion.z = Sk.ffi.remapToJs(z);
                quaternion.w = Sk.ffi.remapToJs(w);
                return quaternionPy;
              });
            }, METHOD_SET, []));
          }
        case METHOD_CLONE: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (methodPy) {
                Sk.ffi.referenceToPy(null, METHOD_CLONE, null, methodPy);
              });
              $loc.__call__ = Sk.ffi.functionPy(function (self) {
                return wxyzToPy(quaternion.w, quaternion.x, quaternion.y, quaternion.z);
              });
            }, METHOD_CLONE, []));
          }
        case METHOD_CONJUGATE: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (methodPy) {
                Sk.ffi.referenceToPy(null, METHOD_CONJUGATE, null, methodPy);
              });
              $loc.__call__ = Sk.ffi.functionPy(function (methodPy) {
                quaternion[METHOD_CONJUGATE]();
                return quaternionPy;
              });
            }, METHOD_CONJUGATE, []));
          }
        case METHOD_INVERSE: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (methodPy) {
                Sk.ffi.referenceToPy(null, METHOD_INVERSE, null, methodPy);
              });
              $loc.__call__ = Sk.ffi.functionPy(function (methodPy) {
                var k = 1 / quaternion['lengthSq']();
                quaternion[METHOD_CONJUGATE]();
                quaternion.w *= k;
                quaternion.x *= k;
                quaternion.y *= k;
                quaternion.z *= k;
                return quaternionPy;
              });
            }, METHOD_INVERSE, []));
          }
        case METHOD_MAGNITUDE: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (methodPy) {
                Sk.ffi.referenceToPy(null, METHOD_MAGNITUDE, null, methodPy);
              });
              $loc.__call__ = Sk.ffi.functionPy(function (methodPy) {
                return Sk.ffi.numberToFloatPy(quaternion.length());
              });
            }, METHOD_MAGNITUDE, []));
          }
        case METHOD_QUADRANCE: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (methodPy) {
                Sk.ffi.referenceToPy(null, METHOD_QUADRANCE, null, methodPy);
              });
              $loc.__call__ = Sk.ffi.functionPy(function (methodPy) {
                return Sk.ffi.numberToFloatPy(quaternion['lengthSq']());
              });
            }, METHOD_QUADRANCE, []));
          }
        case METHOD_NORMALIZE: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (methodPy) {
                Sk.ffi.referenceToPy(null, METHOD_NORMALIZE, null, methodPy);
              });
              $loc.__call__ = Sk.ffi.functionPy(function (methodPy) {
                quaternion[METHOD_NORMALIZE]();
                return quaternionPy;
              });
            }, METHOD_NORMALIZE, []));
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(QUATERNION);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (quaternionPy, name, valuePy) {
        var quaternion = Sk.ffi.remapToJs(quaternionPy);
        var value = Sk.ffi.remapToJs(valuePy);
        switch (name) {
        case PROP_X: {
            quaternion.x = value;
          }
          break;
        case PROP_Y: {
            quaternion.y = value;
          }
          break;
        case PROP_Z: {
            quaternion.z = value;
          }
          break;
        case PROP_W: {
            quaternion.w = value;
          }
          break;
        default: {
            throw Sk.ffi.err.attribute(name).isNotSetableOnType(QUATERNION);
          }
        }
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (quaternionPy) {
        var quaternion = Sk.ffi.remapToJs(quaternionPy);
        var args = [
            quaternion.x,
            quaternion.y,
            quaternion.z,
            quaternion.w
          ];
        return Sk.ffi.stringToPy(QUATERNION + '(' + args.join(', ') + ')');
      });
      $loc.__str__ = Sk.ffi.functionPy(function (quaternionPy) {
        var quaternion = Sk.ffi.remapToJs(quaternionPy);
        return Sk.ffi.stringToPy(stringFromCoordinates([
          quaternion.w,
          quaternion.x,
          quaternion.y,
          quaternion.z
        ], [
          '1',
          'i',
          'j',
          'k'
        ]));
      });
    }, QUATERNION, []);
  };
}.call(this));
Sk.builtin.buildDocumentClass = function (mod) {
  var DOCUMENT_CLASS = 'Document';
  var EVENT = 'Event';
  var NODE = 'Node';
  var PROP_BODY = 'body';
  var PROP_TITLE = 'title';
  var PROP_WEBKIT_HIDDEN = 'webkitHidden';
  var METHOD_ADD_EVENT_LISTENER = 'addEventListener';
  var METHOD_CREATE_ELEMENT = 'createElement';
  var METHOD_GET_ELEMENT_BY_ID = 'getElementById';
  var METHOD_GET_ELEMENTS_BY_TAG_NAME = 'getElementsByTagName';
  var METHOD_REMOVE_ELEMENTS_BY_TAG_NAME = 'removeElementsByTagName';
  var METHOD_REMOVE_EVENT_LISTENER = 'removeEventListener';
  var METHOD_WRITE = 'write';
  var ARG_ID = 'id';
  var ARG_TAG_NAME = 'tagName';
  var nodeToPy = function (node) {
    if (node) {
      return Sk.ffi.callsim(mod[NODE], Sk.ffi.referenceToPy(node, NODE));
    } else {
      return Sk.ffi.none.None;
    }
  };
  var docListeners = {};
  mod[DOCUMENT_CLASS] = Sk.misceval.buildClass(mod, function ($gbl, $loc) {
    $loc.__init__ = Sk.ffi.functionPy(function (selfPy, documentPy) {
      Sk.ffi.checkMethodArgs(DOCUMENT_CLASS, arguments, 1, 1);
      Sk.ffi.referenceToPy(Sk.ffi.remapToJs(documentPy), DOCUMENT_CLASS, undefined, selfPy);
    });
    $loc.__getattr__ = Sk.ffi.functionPy(function (documentPy, name) {
      var documentJs = Sk.ffi.remapToJs(documentPy);
      switch (name) {
      case PROP_BODY: {
          return nodeToPy(documentJs.body);
        }
      case PROP_WEBKIT_HIDDEN: {
          return Sk.ffi.booleanToPy(documentJs[PROP_WEBKIT_HIDDEN]);
        }
      case METHOD_ADD_EVENT_LISTENER: {
          return Sk.ffi.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = Sk.ffi.functionPy(function (self) {
            });
            $loc.__call__ = Sk.ffi.functionPy(function (self, typePy, listenerPy, useCapture) {
              var type = Sk.ffi.remapToJs(typePy);
              var listener = function (event) {
                var eventPy = Sk.ffi.callsim(mod[EVENT], Sk.ffi.referenceToPy(event, EVENT));
                Sk.ffi.callsim(listenerPy, eventPy);
              };
              docListeners[type] = listener;
              documentJs[METHOD_ADD_EVENT_LISTENER](type, listener, useCapture);
            });
          }, METHOD_ADD_EVENT_LISTENER, []));
        }
      case METHOD_REMOVE_EVENT_LISTENER: {
          return Sk.ffi.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = Sk.ffi.functionPy(function (self) {
            });
            $loc.__call__ = Sk.ffi.functionPy(function (self, typePy, listener, useCapture) {
              var type = Sk.ffi.remapToJs(typePy);
              var listener = docListeners[type];
              delete docListeners[type];
              documentJs[METHOD_REMOVE_EVENT_LISTENER](type, listener, useCapture);
            });
          }, METHOD_REMOVE_EVENT_LISTENER, []));
        }
      case METHOD_CREATE_ELEMENT: {
          return Sk.ffi.callableToPy(mod, METHOD_CREATE_ELEMENT, function (methodPy, tagNamePy, attributesPy) {
            Sk.ffi.checkMethodArgs(METHOD_CREATE_ELEMENT, arguments, 1, 2);
            Sk.ffi.checkArgType(ARG_TAG_NAME, Sk.ffi.PyType.STR, Sk.ffi.isStr(tagNamePy), tagNamePy);
            var element = documentJs.createElement(Sk.ffi.remapToJs(tagNamePy));
            if (attributesPy instanceof Sk.builtin.dict) {
              for (var iter = attributesPy.tp$iter(), k = iter.tp$iternext(); k !== undefined; k = iter.tp$iternext()) {
                var v = attributesPy.mp$subscript(k);
                if (v === undefined) {
                  v = null;
                }
                var kAsJs = Sk.ffi.remapToJs(k);
                var vAsJs = Sk.ffi.remapToJs(v);
                element.setAttribute(kAsJs, vAsJs);
              }
            }
            return nodeToPy(element);
          });
        }
      case METHOD_GET_ELEMENT_BY_ID: {
          return Sk.ffi.callableToPy(mod, METHOD_GET_ELEMENT_BY_ID, function (methodPy, idPy) {
            Sk.ffi.checkMethodArgs(METHOD_GET_ELEMENT_BY_ID, arguments, 1, 1);
            Sk.ffi.checkArgType(ARG_ID, Sk.ffi.PyType.STR, Sk.ffi.isStr(idPy), idPy);
            return nodeToPy(documentJs.getElementById(Sk.ffi.remapToJs(idPy)));
          });
        }
      case METHOD_GET_ELEMENTS_BY_TAG_NAME: {
          return Sk.ffi.callableToPy(mod, METHOD_GET_ELEMENTS_BY_TAG_NAME, function (methodPy, tagNamePy) {
            Sk.ffi.checkMethodArgs(METHOD_GET_ELEMENTS_BY_TAG_NAME, arguments, 1, 1);
            Sk.ffi.checkArgType(ARG_TAG_NAME, Sk.ffi.PyType.STR, Sk.ffi.isStr(tagNamePy), tagNamePy);
            var elements = documentJs.getElementsByTagName(Sk.ffi.remapToJs(tagNamePy));
            var valuesPy = [];
            for (var i = elements.length - 1; i >= 0; i--) {
              valuesPy.push(nodeToPy(elements[i]));
            }
            return Sk.ffi.listPy(valuesPy);
          });
        }
      case METHOD_REMOVE_ELEMENTS_BY_TAG_NAME: {
          return Sk.ffi.callableToPy(mod, METHOD_REMOVE_ELEMENTS_BY_TAG_NAME, function (methodPy, tagNamePy) {
            Sk.ffi.checkMethodArgs(METHOD_REMOVE_ELEMENTS_BY_TAG_NAME, arguments, 1, 1);
            Sk.ffi.checkArgType(ARG_TAG_NAME, Sk.ffi.PyType.STR, Sk.ffi.isStr(tagNamePy), tagNamePy);
            var elements = documentJs.getElementsByTagName(Sk.ffi.remapToJs(tagNamePy));
            var valuesPy = [];
            for (var i = elements.length - 1; i >= 0; i--) {
              var e = elements[i];
              e.parentNode.removeChild(e);
              valuesPy.push(nodeToPy(e));
            }
            return Sk.ffi.listPy(valuesPy);
          });
        }
      case METHOD_WRITE: {
          return Sk.ffi.callableToPy(mod, METHOD_WRITE, function (methodPy, expPy) {
            Sk.ffi.checkMethodArgs(METHOD_WRITE, arguments, 0, 1);
            Sk.ffi.checkArgType('exp1', Sk.ffi.PyType.STR, Sk.ffi.isStr(expPy), expPy);
            documentJs.write(Sk.ffi.remapToJs(expPy));
          });
        }
      default: {
          throw Sk.ffi.err.attribute(name).isNotGetableOnType(DOCUMENT_CLASS);
        }
      }
    });
    $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
      var documentJs = Sk.ffi.remapToJs(selfPy);
      switch (name) {
      case PROP_TITLE: {
          Sk.ffi.checkArgType(name, [Sk.ffi.PyType.STR], Sk.ffi.isStr(valuePy), valuePy);
          documentJs[name] = Sk.ffi.remapToJs(valuePy);
        }
        break;
      default: {
          throw Sk.ffi.err.attribute(name).isNotSetableOnType(DOCUMENT_CLASS);
        }
      }
    });
    $loc.__str__ = Sk.ffi.functionPy(function (self) {
      return Sk.ffi.stringToPy(DOCUMENT_CLASS);
    });
    $loc.__repr__ = Sk.ffi.functionPy(function (self) {
      return Sk.ffi.stringToPy(DOCUMENT_CLASS);
    });
  }, DOCUMENT_CLASS, []);
  return mod[DOCUMENT_CLASS];
};
(function () {
  Sk.builtin.defineEasel = function (mod, createjs, BLADE) {
    Sk.ffi.checkFunctionArgs('defineEasel', arguments, 3, 3);
    Sk.builtin.defineEuclidean2(mod, BLADE);
    Sk.builtin.defineEvent(mod);
    var CONTAINER = 'Container';
    var EASE = 'Ease';
    var EUCLIDEAN_2 = 'Euclidean2';
    var EVENT = 'Event';
    var GRAPHICS = 'Graphics';
    var INT = Sk.ffi.PyType.INT;
    var MOVIE_CLIP = 'MovieClip';
    var NODE = 'Node';
    var NUM = [
        Sk.ffi.PyType.FLOAT,
        Sk.ffi.PyType.INT,
        Sk.ffi.PyType.LONG
      ];
    var POINT = 'Point';
    var SHAPE = 'Shape';
    var STAGE = 'Stage';
    var TEXT = 'Text';
    var TICKER = 'Ticker';
    var TWEEN = 'Tween';
    var PROP_ALPHA = 'alpha';
    var PROP_AUTO_CLEAR = 'autoClear';
    var PROP_BOUNCE_OUT = 'bounceOut';
    var PROP_CANVAS = 'canvas';
    var PROP_FONT = 'font';
    var PROP_GRAPHICS = 'graphics';
    var PROP_HIT_AREA = 'hitArea';
    var PROP_MOUSE_IN_BOUNDS = 'mouseInBounds';
    var PROP_MOUSE_MOVE_OUTSIDE = 'mouseMoveOutside';
    var PROP_MOUSE_X = 'mouseX';
    var PROP_MOUSE_Y = 'mouseY';
    var PROP_NAME = 'name';
    var PROP_ROTATION = 'rotation';
    var PROP_TEXT = 'text';
    var PROP_TEXT_ALIGN = 'textAlign';
    var PROP_TIMELINE = 'timeline';
    var PROP_W = 'w';
    var PROP_X = 'x';
    var PROP_Y = 'y';
    var PROP_XY = 'xy';
    var METHOD_ADD_CHILD = 'addChild';
    var METHOD_ADD_EVENT_LISTENER = 'addEventListener';
    var METHOD_ADD_TWEEN = 'addTween';
    var METHOD_BEGIN_FILL = 'beginFill';
    var METHOD_BEGIN_STROKE = 'beginStroke';
    var METHOD_CALL = 'onComplete';
    var METHOD_CLONE = 'clone';
    var METHOD_DRAW_CIRCLE = 'drawCircle';
    var METHOD_DRAW_RECT = 'drawRect';
    var METHOD_DRAW_ROUND_RECT = 'drawRoundRect';
    var METHOD_ENABLE_MOUSE_OVER = 'enableMouseOver';
    var METHOD_END_FILL = 'endFill';
    var METHOD_END_STROKE = 'endStroke';
    var METHOD_GET = 'get';
    var METHOD_GET_CHILD_AT = 'getChildAt';
    var METHOD_GET_HSL = 'getHSL';
    var METHOD_GET_NUM_CHILDREN = 'getNumChildren';
    var METHOD_GET_MEASURED_HEIGHT = 'getMeasuredHeight';
    var METHOD_GET_MEASURED_WIDTH = 'getMeasuredWidth';
    var METHOD_GLOBAL_TO_LOCAL = 'globalToLocal';
    var METHOD_GOTO_AND_PLAY = 'gotoAndPlay';
    var METHOD_HIT_TEST = 'hitTest';
    var METHOD_LOCAL_TO_LOCAL = 'localToLocal';
    var METHOD_LINE_TO = 'lineTo';
    var METHOD_MOVE_TO = 'moveTo';
    var METHOD_REMOVE_EVENT_LISTENER = 'removeEventListener';
    var METHOD_RENDER = 'render';
    var METHOD_SET_STROKE_STYLE = 'setStrokeStyle';
    var METHOD_TO = 'to';
    var METHOD_UPDATE = 'update';
    var METHOD_WAIT = 'wait';
    var ARG_X = 'x';
    var ARG_Y = 'y';
    var ARG_WIDTH = 'width';
    var ARG_HEIGHT = 'height';
    var ARG_RADIUS = 'radius';
    mod[GRAPHICS] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, graphicsPy) {
        Sk.ffi.checkMethodArgs(GRAPHICS, arguments, 0, 1);
        if (Sk.ffi.isDefined(graphicsPy)) {
          Sk.ffi.referenceToPy(Sk.ffi.remapToJs(graphicsPy), GRAPHICS, undefined, selfPy);
        } else {
          Sk.ffi.referenceToPy(new createjs[GRAPHICS](), GRAPHICS, undefined, selfPy);
        }
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (graphicsPy, name) {
        var graphics = Sk.ffi.remapToJs(graphicsPy);
        switch (name) {
        case METHOD_BEGIN_FILL: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (selfPy) {
                Sk.ffi.referenceToPy(graphics[METHOD_BEGIN_FILL], METHOD_BEGIN_FILL, undefined, selfPy);
              });
              $loc.__call__ = Sk.ffi.functionPy(function (self, color) {
                color = Sk.ffi.remapToJs(color);
                graphics[METHOD_BEGIN_FILL](color);
                return graphicsPy;
              });
            }, METHOD_BEGIN_FILL, []));
          }
        case METHOD_BEGIN_STROKE: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (selfPy) {
                Sk.ffi.referenceToPy(graphics[METHOD_BEGIN_STROKE], METHOD_BEGIN_STROKE, undefined, selfPy);
              });
              $loc.__call__ = Sk.ffi.functionPy(function (self, color) {
                color = Sk.ffi.remapToJs(color);
                graphics[METHOD_BEGIN_STROKE](color);
                return graphicsPy;
              });
            }, METHOD_BEGIN_STROKE, []));
          }
        case METHOD_DRAW_CIRCLE: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (self) {
                self.tp$name = METHOD_DRAW_CIRCLE;
                self.v = graphics[METHOD_DRAW_CIRCLE];
              });
              $loc.__call__ = Sk.ffi.functionPy(function (self, x, y, radius) {
                x = Sk.ffi.remapToJs(x);
                y = Sk.ffi.remapToJs(y);
                radius = Sk.ffi.remapToJs(radius);
                graphics[METHOD_DRAW_CIRCLE](x, y, radius);
                return graphicsPy;
              });
            }, METHOD_DRAW_CIRCLE, []));
          }
        case METHOD_DRAW_RECT: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (self) {
                self.tp$name = METHOD_DRAW_RECT;
                self.v = graphics[METHOD_DRAW_RECT];
              });
              $loc.__call__ = Sk.ffi.functionPy(function (self, x, y, w, h) {
                x = Sk.ffi.remapToJs(x);
                y = Sk.ffi.remapToJs(y);
                w = Sk.ffi.remapToJs(w);
                h = Sk.ffi.remapToJs(h);
                graphics[METHOD_DRAW_RECT](x, y, w, h);
                return graphicsPy;
              });
            }, METHOD_DRAW_RECT, []));
          }
        case METHOD_DRAW_ROUND_RECT: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy, xPy, yPy, widthPy, heightPy, radiusPy) {
              Sk.ffi.checkMethodArgs(METHOD_DRAW_ROUND_RECT, arguments, 5, 5);
              Sk.ffi.checkArgType(ARG_X, NUM, Sk.ffi.isNum(xPy), xPy);
              Sk.ffi.checkArgType(ARG_Y, NUM, Sk.ffi.isNum(yPy), yPy);
              Sk.ffi.checkArgType(ARG_WIDTH, NUM, Sk.ffi.isNum(widthPy), widthPy);
              Sk.ffi.checkArgType(ARG_HEIGHT, NUM, Sk.ffi.isNum(heightPy), heightPy);
              Sk.ffi.checkArgType(ARG_RADIUS, NUM, Sk.ffi.isNum(radiusPy), radiusPy);
              var x = Sk.ffi.remapToJs(xPy);
              var y = Sk.ffi.remapToJs(yPy);
              var w = Sk.ffi.remapToJs(widthPy);
              var h = Sk.ffi.remapToJs(heightPy);
              var radius = Sk.ffi.remapToJs(radiusPy);
              graphics[METHOD_DRAW_ROUND_RECT](x, y, w, h, radius);
              return graphicsPy;
            });
          }
        case METHOD_END_FILL: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (self) {
                self.tp$name = METHOD_END_FILL;
                self.v = graphics[METHOD_END_FILL];
              });
              $loc.__call__ = Sk.ffi.functionPy(function (self) {
                graphics[METHOD_END_FILL]();
                return graphicsPy;
              });
            }, METHOD_END_FILL, []));
          }
        case METHOD_END_STROKE: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (self) {
                self.tp$name = METHOD_END_STROKE;
                self.v = graphics[METHOD_END_STROKE];
              });
              $loc.__call__ = Sk.ffi.functionPy(function (self) {
                graphics[METHOD_END_STROKE]();
                return graphicsPy;
              });
            }, METHOD_END_STROKE, []));
          }
        case METHOD_LINE_TO: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (self) {
                self.tp$name = METHOD_LINE_TO;
                self.v = graphics[METHOD_LINE_TO];
              });
              $loc.__call__ = Sk.ffi.functionPy(function (self, x, y) {
                x = Sk.ffi.remapToJs(x);
                y = Sk.ffi.remapToJs(y);
                graphics[METHOD_LINE_TO](x, y);
                return graphicsPy;
              });
            }, METHOD_LINE_TO, []));
          }
        case METHOD_MOVE_TO: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (self) {
                self.tp$name = METHOD_MOVE_TO;
                self.v = graphics[METHOD_MOVE_TO];
              });
              $loc.__call__ = Sk.ffi.functionPy(function (self, x, y) {
                x = Sk.ffi.remapToJs(x);
                y = Sk.ffi.remapToJs(y);
                graphics[METHOD_MOVE_TO](x, y);
                return graphicsPy;
              });
            }, METHOD_MOVE_TO, []));
          }
        case METHOD_SET_STROKE_STYLE: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (self) {
                self.tp$name = METHOD_SET_STROKE_STYLE;
                self.v = graphics[METHOD_SET_STROKE_STYLE];
              });
              $loc.__call__ = Sk.ffi.functionPy(function (self, thickness, caps, joints, miterLimit, ignoreScale) {
                thickness = Sk.ffi.remapToJs(thickness);
                caps = Sk.ffi.remapToJs(caps);
                joints = Sk.ffi.remapToJs(joints);
                miterLimit = Sk.ffi.remapToJs(miterLimit);
                ignoreScale = Sk.ffi.remapToJs(ignoreScale);
                graphics[METHOD_SET_STROKE_STYLE](thickness, caps, joints, miterLimit, ignoreScale);
                return graphicsPy;
              });
            }, METHOD_SET_STROKE_STYLE, []));
          }
        }
      });
    }, GRAPHICS, []);
    mod[MOVIE_CLIP] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, modePy, startPositionPy, loopPy, labelsPy) {
        var mode = modePy !== null ? Sk.ffi.remapToJs(modePy) : null;
        var startPosition = Sk.ffi.remapToJs(startPositionPy);
        var loop = Sk.ffi.remapToJs(loopPy);
        var labels = Sk.ffi.remapToJs(labelsPy);
        Sk.ffi.referenceToPy(new createjs[MOVIE_CLIP](mode, startPosition, loop, labels), MOVIE_CLIP, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (movieClipPy, name) {
        var movieClip = Sk.ffi.remapToJs(movieClipPy);
        switch (name) {
        case PROP_TIMELINE: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (self) {
                self.tp$name = PROP_TIMELINE;
                self.v = movieClip[PROP_TIMELINE];
              });
              $loc.__getattr__ = Sk.ffi.functionPy(function (timelinePy, name) {
                var timeline = Sk.ffi.remapToJs(timelinePy);
                switch (name) {
                case METHOD_ADD_TWEEN: {
                    return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
                      $loc.__init__ = Sk.ffi.functionPy(function (self) {
                        self.tp$name = METHOD_ADD_TWEEN;
                        self.v = timeline[METHOD_ADD_TWEEN];
                      });
                      $loc.__call__ = Sk.ffi.functionPy(function (self, tweenPy) {
                        var tween = Sk.ffi.remapToJs(tweenPy);
                        timeline[METHOD_ADD_TWEEN](tween);
                      });
                    }, METHOD_ADD_TWEEN, []));
                  }
                  break;
                }
              });
            }, PROP_TIMELINE, []));
          }
          break;
        case METHOD_GOTO_AND_PLAY: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (self) {
                self.tp$name = METHOD_GOTO_AND_PLAY;
                self.v = movieClip[METHOD_GOTO_AND_PLAY];
              });
              $loc.__call__ = Sk.ffi.functionPy(function (self, labelPy) {
                var label = Sk.ffi.remapToJs(labelPy);
                movieClip[METHOD_GOTO_AND_PLAY](label);
              });
            }, METHOD_GOTO_AND_PLAY, []));
          }
          break;
        }
      });
    }, MOVIE_CLIP, []);
    function shapeGetAttr(shapePy, name, className) {
      var shape = Sk.ffi.remapToJs(shapePy);
      switch (name) {
      case PROP_ALPHA: {
          return Sk.ffi.numberToFloatPy(shape[PROP_ALPHA]);
        }
      case PROP_GRAPHICS: {
          return Sk.ffi.callsim(mod[GRAPHICS], Sk.ffi.referenceToPy(shape[PROP_GRAPHICS], GRAPHICS));
        }
      case PROP_NAME: {
          return Sk.ffi.stringToPy(shape[PROP_NAME]);
        }
      case PROP_X: {
          return Sk.ffi.numberToFloatPy(shape[PROP_X]);
        }
      case PROP_Y: {
          return Sk.ffi.numberToFloatPy(shape[PROP_Y]);
        }
      case PROP_ROTATION: {
          return Sk.ffi.numberToFloatPy(shape[PROP_ROTATION]);
        }
      case METHOD_ADD_EVENT_LISTENER: {
          return Sk.builtin.addEventListener(mod, shape);
        }
      case METHOD_REMOVE_EVENT_LISTENER: {
          return Sk.builtin.removeEventListener(mod, shape);
        }
      case METHOD_GLOBAL_TO_LOCAL: {
          return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = Sk.ffi.functionPy(function (self) {
              self.tp$name = METHOD_GLOBAL_TO_LOCAL;
              self.v = shape[METHOD_GLOBAL_TO_LOCAL];
            });
            $loc.__call__ = Sk.ffi.functionPy(function (methodPy, x, y) {
              var point = shape[METHOD_GLOBAL_TO_LOCAL](Sk.ffi.remapToJs(x), Sk.ffi.remapToJs(y));
              return Sk.ffi.callsim(mod[POINT], Sk.ffi.referenceToPy(point, POINT));
            });
          }, METHOD_GLOBAL_TO_LOCAL, []));
        }
      case METHOD_HIT_TEST: {
          return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = Sk.ffi.functionPy(function (self) {
              self.tp$name = METHOD_HIT_TEST;
              self.v = shape[METHOD_HIT_TEST];
            });
            $loc.__call__ = Sk.ffi.functionPy(function (methodPy, x, y) {
              return Sk.ffi.booleanToPy(shape[METHOD_HIT_TEST](Sk.ffi.remapToJs(x), Sk.ffi.remapToJs(y)));
            });
          }, METHOD_HIT_TEST, []));
        }
      case METHOD_LOCAL_TO_LOCAL: {
          return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = Sk.ffi.functionPy(function (self) {
              self.tp$name = METHOD_LOCAL_TO_LOCAL;
              self.v = shape[METHOD_LOCAL_TO_LOCAL];
            });
            $loc.__call__ = Sk.ffi.functionPy(function (methodPy, x, y, target) {
              var point = shape[METHOD_LOCAL_TO_LOCAL](Sk.ffi.remapToJs(x), Sk.ffi.remapToJs(y), Sk.ffi.remapToJs(target));
              return Sk.ffi.callsim(mod[POINT], Sk.ffi.referenceToPy(point, POINT));
            });
          }, METHOD_LOCAL_TO_LOCAL, []));
        }
      default: {
          throw Sk.ffi.err.attribute(name).isNotGetableOnType(className);
        }
      }
    }
    function shapeSetAttr(shapePy, name, valuePy, className) {
      var shape = Sk.ffi.remapToJs(shapePy);
      var value = Sk.ffi.remapToJs(valuePy);
      switch (name) {
      case PROP_ALPHA: {
          Sk.ffi.checkArgType(PROP_ALPHA, NUM, Sk.ffi.isNum(valuePy), valuePy);
          shape[PROP_ALPHA] = value;
        }
        break;
      case PROP_NAME: {
          Sk.ffi.checkArgType(PROP_NAME, Sk.ffi.PyType.STR, Sk.ffi.isStr(valuePy), valuePy);
          shape[PROP_NAME] = value;
        }
        break;
      case PROP_X:
      case PROP_Y: {
          Sk.ffi.checkArgType(name, NUM, Sk.ffi.isNum(valuePy), valuePy);
          shape[name] = value;
        }
        break;
      case PROP_ROTATION: {
          Sk.ffi.checkArgType(PROP_ROTATION, NUM, Sk.ffi.isNum(valuePy), valuePy);
          shape[PROP_ROTATION] = value;
        }
        break;
      default: {
          throw Sk.ffi.err.attribute(name).isNotSetableOnType(className);
        }
      }
    }
    mod[SHAPE] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, argPy) {
        Sk.ffi.checkMethodArgs(SHAPE, arguments, 0, 1);
        if (Sk.ffi.isUndefined(argPy)) {
          Sk.ffi.referenceToPy(new createjs[SHAPE](), SHAPE, undefined, selfPy);
        } else {
          Sk.ffi.checkArgType(PROP_GRAPHICS, GRAPHICS, Sk.ffi.isInstance(argPy), argPy);
          switch (Sk.ffi.typeName(argPy)) {
          case SHAPE: {
              Sk.ffi.referenceToPy(Sk.ffi.remapToJs(argPy), SHAPE, undefined, selfPy);
            }
            break;
          case GRAPHICS: {
              Sk.ffi.referenceToPy(new createjs[SHAPE](Sk.ffi.remapToJs(argPy)), SHAPE, undefined, selfPy);
            }
            break;
          default: {
              Sk.ffi.checkArgType(PROP_GRAPHICS, GRAPHICS, false, argPy);
            }
          }
        }
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (shapePy, name) {
        return shapeGetAttr(shapePy, name, SHAPE);
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (shapePy, name, valuePy) {
        return shapeSetAttr(shapePy, name, valuePy, SHAPE);
      });
    }, SHAPE, []);
    mod[STAGE] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, canvasPy) {
        Sk.ffi.checkMethodArgs(STAGE, arguments, 1, 1);
        Sk.ffi.checkArgType(PROP_CANVAS, NODE, Sk.ffi.isObject(canvasPy) || Sk.ffi.isInstance(canvasPy, NODE), canvasPy);
        var canvas = Sk.ffi.remapToJs(canvasPy);
        Sk.ffi.referenceToPy(new createjs[STAGE](canvas), STAGE, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (stagePy, name) {
        var stage = Sk.ffi.remapToJs(stagePy);
        switch (name) {
        case PROP_MOUSE_IN_BOUNDS: {
            return Sk.ffi.booleanToPy(stage[PROP_MOUSE_IN_BOUNDS]);
          }
        case PROP_MOUSE_MOVE_OUTSIDE: {
            return Sk.ffi.booleanToPy(stage[PROP_MOUSE_MOVE_OUTSIDE]);
          }
        case PROP_MOUSE_X: {
            return Sk.ffi.numberToIntPy(stage[PROP_MOUSE_X]);
          }
        case PROP_MOUSE_Y: {
            return Sk.ffi.numberToIntPy(stage[PROP_MOUSE_Y]);
          }
        case METHOD_ADD_CHILD: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (self) {
                self.tp$name = METHOD_ADD_CHILD;
                self.v = stage[METHOD_ADD_CHILD];
              });
              $loc.__call__ = Sk.ffi.functionPy(function (self, childPy) {
                stage[METHOD_ADD_CHILD](Sk.ffi.remapToJs(childPy));
                return childPy;
              });
            }, METHOD_ADD_CHILD, []));
          }
        case METHOD_ENABLE_MOUSE_OVER: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (self) {
                self.tp$name = METHOD_ENABLE_MOUSE_OVER;
                self.v = stage[METHOD_ENABLE_MOUSE_OVER];
              });
              $loc.__call__ = Sk.ffi.functionPy(function (updatePy) {
                stage[METHOD_ENABLE_MOUSE_OVER]();
              });
            }, METHOD_ENABLE_MOUSE_OVER, []));
          }
        case METHOD_RENDER:
        case METHOD_UPDATE: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy) {
              stage[METHOD_UPDATE]();
            });
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(STAGE);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (stagePy, name, valuePy) {
        var stage = Sk.ffi.remapToJs(stagePy);
        var value = Sk.ffi.remapToJs(valuePy);
        switch (name) {
        case PROP_AUTO_CLEAR: {
            stage[PROP_AUTO_CLEAR] = value;
          }
          break;
        case PROP_MOUSE_MOVE_OUTSIDE: {
            stage[PROP_MOUSE_MOVE_OUTSIDE] = value;
          }
          break;
        default: {
            throw Sk.ffi.err.attribute(name).isNotSetableOnType(STAGE);
          }
        }
      });
    }, STAGE, []);
    mod[TEXT] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, textPy, fontPy, colorPy) {
        Sk.ffi.checkArgType(PROP_TEXT, Sk.ffi.PyType.STR, Sk.ffi.isStr(textPy), textPy);
        Sk.ffi.checkArgType(PROP_FONT, Sk.ffi.PyType.STR, Sk.ffi.isStr(fontPy), fontPy);
        var text = Sk.ffi.remapToJs(textPy);
        var font = Sk.ffi.remapToJs(fontPy);
        var color = Sk.ffi.remapToJs(colorPy);
        Sk.ffi.referenceToPy(new createjs[TEXT](text, font, color), TEXT, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (textPy, name) {
        var text = Sk.ffi.remapToJs(textPy);
        switch (name) {
        case PROP_TEXT: {
            return Sk.ffi.stringToPy(text[PROP_TEXT]);
          }
        case PROP_TEXT_ALIGN: {
            return Sk.ffi.stringToPy(text[PROP_TEXT_ALIGN]);
          }
        case METHOD_GET_MEASURED_WIDTH: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (methodPy) {
                methodPy.tp$name = METHOD_GET_MEASURED_WIDTH;
                methodPy.v = text[METHOD_GET_MEASURED_WIDTH];
              });
              $loc.__call__ = Sk.ffi.functionPy(function (methodPy, childPy) {
                return Sk.builtin.assk$(text[METHOD_GET_MEASURED_WIDTH](), Sk.builtin.nmber.float$);
              });
            }, METHOD_GET_MEASURED_WIDTH, []));
          }
        case METHOD_GET_MEASURED_HEIGHT: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (methodPy) {
                methodPy.tp$name = METHOD_GET_MEASURED_HEIGHT;
                methodPy.v = text[METHOD_GET_MEASURED_HEIGHT];
              });
              $loc.__call__ = Sk.ffi.functionPy(function (methodPy, childPy) {
                return Sk.builtin.assk$(text[METHOD_GET_MEASURED_HEIGHT](), Sk.builtin.nmber.float$);
              });
            }, METHOD_GET_MEASURED_HEIGHT, []));
          }
        default: {
            return shapeGetAttr(textPy, name, TEXT);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (textPy, name, valuePy) {
        var text = Sk.ffi.remapToJs(textPy);
        var value = Sk.ffi.remapToJs(valuePy);
        switch (name) {
        case PROP_HIT_AREA: {
            text[PROP_HIT_AREA] = value;
          }
          break;
        case PROP_TEXT: {
            text[PROP_TEXT] = Sk.ffi.remapToJs(Sk.ffi.isStr(valuePy) ? valuePy : Sk.ffh.str(valuePy));
          }
          break;
        case PROP_TEXT_ALIGN: {
            text[PROP_TEXT_ALIGN] = value;
          }
          break;
        default: {
            return shapeSetAttr(textPy, name, valuePy, TEXT);
          }
        }
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        return Sk.ffi.stringToPy(TEXT + '(' + self.x + ', ' + self.y + ')');
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        return Sk.ffi.stringToPy('[' + self.x + ', ' + self.y + ']');
      });
    }, TEXT, []);
    mod[TICKER] = Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (self) {
        self.tp$name = TICKER;
        self.v = createjs[TICKER];
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (tickerPy, name) {
        var ticker = Sk.ffi.remapToJs(tickerPy);
        switch (name) {
        case METHOD_ADD_EVENT_LISTENER: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (self) {
                self.tp$name = METHOD_ADD_EVENT_LISTENER;
              });
              $loc.__call__ = Sk.ffi.functionPy(function (self, typePy, listenerPy, useCapture) {
                var type = Sk.ffi.remapToJs(typePy);
                var listener = Sk.ffi.remapToJs(listenerPy);
                if (typeof listener === 'object') {
                  ticker[METHOD_ADD_EVENT_LISTENER](type, listener, useCapture);
                } else {
                  var listener = function (event) {
                    Sk.ffi.callsim(listenerPy);
                  };
                  ticker[METHOD_ADD_EVENT_LISTENER](type, listener, useCapture);
                }
              });
            }, METHOD_ADD_EVENT_LISTENER, []));
          }
          break;
        }
      });
    }, TICKER, []));
    mod[TWEEN] = Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (self) {
        self.tp$name = TWEEN;
        self.v = createjs[TWEEN];
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (entryPointPy, name) {
        var entryPoint = Sk.ffi.remapToJs(entryPointPy);
        switch (name) {
        case METHOD_GET: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (self) {
                self.tp$name = METHOD_GET;
              });
              $loc.__call__ = Sk.ffi.functionPy(function (self, target, props, pluginData, override) {
                target = Sk.ffi.remapToJs(target);
                props = Sk.ffi.remapToJs(props);
                pluginData = Sk.ffi.remapToJs(pluginData);
                override = Sk.ffi.remapToJs(override);
                var tween = entryPoint[METHOD_GET](target, props, pluginData, override);
                return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
                  $loc.__init__ = Sk.ffi.functionPy(function (self) {
                    self.tp$name = TWEEN;
                    self.v = tween;
                  });
                  $loc.__getattr__ = Sk.ffi.functionPy(function (tweenPy, name) {
                    var tween = Sk.ffi.remapToJs(tweenPy);
                    switch (name) {
                    case METHOD_TO: {
                        return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
                          $loc.__init__ = Sk.ffi.functionPy(function (self) {
                            self.tp$name = METHOD_TO;
                          });
                          $loc.__call__ = Sk.ffi.functionPy(function (self, props, duration, ease) {
                            props = Sk.ffi.remapToJs(props);
                            duration = Sk.ffi.remapToJs(duration);
                            ease = Sk.ffi.remapToJs(ease);
                            tween[METHOD_TO](props, duration, ease);
                            return tweenPy;
                          });
                        }, METHOD_TO, []));
                      }
                      break;
                    case METHOD_CALL: {
                        return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
                          $loc.__init__ = Sk.ffi.functionPy(function (self) {
                            self.tp$name = METHOD_CALL;
                          });
                          $loc.__call__ = Sk.ffi.functionPy(function (self, callbackPy, argsPy) {
                            var callbackJS = function (argsJs) {
                              Sk.ffi.callsim(callbackPy, Sk.ffi.remapToPy(argsJs));
                            };
                            var argsJs = Sk.ffi.remapToJs(argsPy);
                            tween.call(callbackJS, argsJs);
                            return tweenPy;
                          });
                        }, METHOD_CALL, []));
                      }
                      break;
                    case METHOD_WAIT: {
                        return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
                          $loc.__init__ = Sk.ffi.functionPy(function (self) {
                            self.tp$name = METHOD_WAIT;
                          });
                          $loc.__call__ = Sk.ffi.functionPy(function (self, duration) {
                            duration = Sk.ffi.remapToJs(duration);
                            tween[METHOD_WAIT](duration);
                            return tweenPy;
                          });
                        }, METHOD_WAIT, []));
                      }
                      break;
                    }
                  });
                }, TWEEN, []));
              });
            }, METHOD_GET, []));
          }
          break;
        }
      });
    }, TWEEN, []));
    mod[CONTAINER] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, argPy) {
        if (Sk.ffi.isUndefined(argPy)) {
          Sk.ffi.referenceToPy(new createjs[CONTAINER](), CONTAINER, undefined, selfPy);
        } else {
          Sk.ffi.referenceToPy(Sk.ffi.remapToJs(argPy), CONTAINER, undefined, selfPy);
        }
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (containerPy, name) {
        var container = Sk.ffi.remapToJs(containerPy);
        switch (name) {
        case PROP_NAME: {
            return Sk.ffi.stringToPy(container[PROP_NAME]);
          }
        case PROP_X: {
            return Sk.builtin.assk$(container[PROP_X], Sk.builtin.nmber.float$);
          }
        case PROP_Y: {
            return Sk.builtin.assk$(container[PROP_Y], Sk.builtin.nmber.float$);
          }
        case PROP_ROTATION: {
            return Sk.builtin.assk$(container[PROP_ROTATION], Sk.builtin.nmber.float$);
          }
        case METHOD_ADD_CHILD: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (methodPy) {
                methodPy.tp$name = METHOD_ADD_CHILD;
                methodPy.v = container[METHOD_ADD_CHILD];
              });
              $loc.__call__ = Sk.ffi.functionPy(function (methodPy, childPy) {
                var child = container[METHOD_ADD_CHILD](Sk.ffi.remapToJs(childPy));
                return childPy;
              });
            }, METHOD_ADD_CHILD, []));
          }
        case METHOD_ADD_EVENT_LISTENER: {
            return Sk.builtin.addEventListener(mod, container);
          }
        case METHOD_GET_CHILD_AT: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (methodPy) {
                methodPy.tp$name = METHOD_GET_CHILD_AT;
                methodPy.v = container[METHOD_GET_CHILD_AT];
              });
              $loc.__call__ = Sk.ffi.functionPy(function (methodPy, indexPy) {
                var child = container[METHOD_GET_CHILD_AT](Sk.ffi.remapToJs(indexPy));
                return Sk.ffi.callsim(mod[SHAPE], Sk.ffi.referenceToPy(child, SHAPE));
              });
            }, METHOD_GET_CHILD_AT, []));
          }
        case METHOD_GET_NUM_CHILDREN: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (methodPy) {
                methodPy.tp$name = METHOD_GET_NUM_CHILDREN;
                methodPy.v = container[METHOD_GET_NUM_CHILDREN];
              });
              $loc.__call__ = Sk.ffi.functionPy(function (methodPy, childPy) {
                return Sk.builtin.assk$(container[METHOD_GET_NUM_CHILDREN](), Sk.builtin.nmber.int$);
              });
            }, METHOD_GET_NUM_CHILDREN, []));
          }
        case METHOD_REMOVE_EVENT_LISTENER: {
            return Sk.builtin.removeEventListener(mod, container);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (containerPy, name, valuePy) {
        var container = Sk.ffi.remapToJs(containerPy);
        var value = Sk.ffi.remapToJs(valuePy);
        switch (name) {
        case PROP_NAME: {
            container[PROP_NAME] = value;
          }
          break;
        case PROP_X: {
            container[PROP_X] = value;
          }
          break;
        case PROP_Y: {
            container[PROP_Y] = value;
          }
          break;
        case PROP_ROTATION: {
            container[PROP_ROTATION] = value;
          }
          break;
        default: {
            throw new Sk.builtin.AttributeError(name + ' is not a writeable attribute of ' + CONTAINER);
          }
        }
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        return Sk.ffi.stringToPy(CONTAINER + '(' + self.x + ', ' + self.y + ')');
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        return Sk.ffi.stringToPy('[' + self.x + ', ' + self.y + ']');
      });
    }, CONTAINER, []);
    mod[EASE] = Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (self) {
        self.tp$name = EASE;
        self.v = createjs[EASE];
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (self, name) {
        switch (name) {
        case PROP_BOUNCE_OUT: {
            var fn = createjs[EASE][PROP_BOUNCE_OUT];
            return { 'v': fn };
          }
        }
      });
    }, EASE, []));
    mod[POINT] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (self, x, y) {
        Sk.builtin.pyCheckArgs(POINT, arguments, 1, 3);
        self.tp$name = POINT;
        switch (arguments.length) {
        case 1: {
            self.v = new createjs[POINT]();
          }
          break;
        case 2: {
            x = Sk.ffi.remapToJs(x);
            self.tp$name = POINT;
            self.v = x;
          }
          break;
        case 3: {
            Sk.builtin.pyCheckType('x', 'number', Sk.builtin.checkNumber(x));
            Sk.builtin.pyCheckType('y', 'number', Sk.builtin.checkNumber(y));
            x = Sk.ffi.remapToJs(x);
            y = Sk.ffi.remapToJs(y);
            self.tp$name = POINT;
            self.v = new createjs[POINT](x, y);
          }
          break;
        }
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (pointPy, name) {
        var point = Sk.ffi.remapToJs(pointPy);
        switch (name) {
        case PROP_X: {
            return Sk.ffi.numberToFloatPy(point.x);
          }
        case PROP_Y: {
            return Sk.ffi.numberToFloatPy(point.y);
          }
        case METHOD_CLONE: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (methodPy) {
                methodPy.tp$name = METHOD_CLONE;
              });
              $loc.__call__ = Sk.ffi.functionPy(function (methodPy) {
                return Sk.ffi.callsim(mod[POINT], Sk.ffi.numberToFloatPy(point.x), Sk.ffi.numberToFloatPy(point.y));
              });
            }, METHOD_CLONE, []));
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (pointPy, name, valuePy) {
        var point = Sk.ffi.remapToJs(pointPy);
        var value = Sk.ffi.remapToJs(valuePy);
        switch (name) {
        case PROP_X: {
            point.x = value;
          }
          break;
        case PROP_Y: {
            point.y = value;
          }
          break;
        }
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (pointPy) {
        var point = Sk.ffi.remapToJs(pointPy);
        return Sk.ffi.stringToPy(POINT + '(' + point.x + ', ' + point.y + ')');
      });
      $loc.__str__ = Sk.ffi.functionPy(function (pointPy) {
        var point = Sk.ffi.remapToJs(pointPy);
        return Sk.ffi.stringToPy('[' + point.x + ', ' + point.y + ']');
      });
    }, POINT, []);
    mod[METHOD_GET_HSL] = Sk.ffi.functionPy(function (hue, saturation, lightness, alpha) {
      hue = Sk.ffi.remapToJs(hue);
      saturation = Sk.ffi.remapToJs(saturation);
      lightness = Sk.ffi.remapToJs(lightness);
      alpha = Sk.ffi.remapToJs(alpha);
      return Sk.ffi.stringToPy(createjs[GRAPHICS][METHOD_GET_HSL](hue, saturation, lightness, alpha));
    });
  };
}.call(this));
Sk.builtin.defineEvent = function (mod) {
  var EVENT = 'Event';
  var PROP_ALT_KEY = 'altKey';
  var PROP_BUBBLES = 'bubbles';
  var PROP_BUTTON = 'button';
  var PROP_CANCELABLE = 'cancelable';
  var PROP_CLIENT_X = 'clientX';
  var PROP_CLIENT_Y = 'clientY';
  var PROP_CTRL_KEY = 'ctrlKey';
  var PROP_DEFAULT_PREVENTED = 'defaultPrevented';
  var PROP_KEY_CODE = 'keyCode';
  var PROP_SCREEN_X = 'screenX';
  var PROP_SCREEN_Y = 'screenY';
  var PROP_SHIFT_KEY = 'shiftKey';
  var PROP_TARGET = 'target';
  var PROP_TYPE = 'type';
  var METHOD_ADD_EVENT_LISTENER = 'addEventListener';
  var METHOD_PREVENT_DEFAULT = 'preventDefault';
  var METHOD_STOP_IMMEDIATE_PROPAGATION = 'stopImmediatePropagation';
  var METHOD_STOP_PROPAGATION = 'stopPropagation';
  mod[EVENT] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
    $loc.__init__ = Sk.ffi.functionPy(function (selfPy, eventRefPy) {
      Sk.ffi.referenceToPy(Sk.ffi.remapToJs(eventRefPy), EVENT, undefined, selfPy);
    });
    $loc.__getattr__ = Sk.ffi.functionPy(function (eventPy, name) {
      var event = Sk.ffi.remapToJs(eventPy);
      switch (name) {
      case PROP_ALT_KEY: {
          return Sk.ffi.booleanToPy(event[PROP_ALT_KEY]);
        }
      case PROP_BUBBLES: {
          return Sk.ffi.booleanToPy(event[PROP_BUBBLES]);
        }
      case PROP_BUTTON: {
          return Sk.ffi.numberToIntPy(event[PROP_BUTTON]);
        }
      case PROP_CANCELABLE: {
          return Sk.ffi.booleanToPy(event[PROP_CANCELABLE]);
        }
      case PROP_CLIENT_X: {
          return Sk.ffi.numberToIntPy(event[PROP_CLIENT_X]);
        }
      case PROP_CLIENT_Y: {
          return Sk.ffi.numberToIntPy(event[PROP_CLIENT_Y]);
        }
      case PROP_CTRL_KEY: {
          return Sk.ffi.booleanToPy(event[PROP_CTRL_KEY]);
        }
      case PROP_DEFAULT_PREVENTED: {
          return Sk.ffi.booleanToPy(event[PROP_DEFAULT_PREVENTED]);
        }
      case PROP_KEY_CODE: {
          return Sk.ffi.numberToIntPy(event[PROP_KEY_CODE]);
        }
      case PROP_SCREEN_X: {
          return Sk.ffi.numberToIntPy(event[PROP_SCREEN_X]);
        }
      case PROP_SCREEN_Y: {
          return Sk.ffi.numberToIntPy(event[PROP_SCREEN_Y]);
        }
      case PROP_SHIFT_KEY: {
          return Sk.ffi.booleanToPy(event[PROP_SHIFT_KEY]);
        }
      case PROP_TARGET: {
          return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = Sk.ffi.functionPy(function (selfPy) {
              Sk.ffi.referenceToPy(event.target, PROP_TARGET, undefined, selfPy);
            });
            $loc.__getattr__ = Sk.ffi.functionPy(function (targetPy, name) {
              return Sk.ffi.remapToPy(event.target[name], '');
            });
            $loc.__setattr__ = Sk.ffi.functionPy(function (targetPy, name, valuePy) {
              event.target[name] = Sk.ffi.remapToJs(valuePy);
            });
            $loc.__str__ = Sk.ffi.functionPy(function (targetPy) {
              var target = Sk.ffi.remapToJs(targetPy);
              return Sk.ffi.stringToPy('' + target);
            });
            $loc.__repr__ = Sk.ffi.functionPy(function (targetPy) {
              var target = Sk.ffi.remapToJs(targetPy);
              return Sk.ffi.stringToPy('' + target);
            });
          }, PROP_TARGET, []));
        }
      case PROP_TYPE: {
          return Sk.ffi.stringToPy(event[PROP_TYPE]);
        }
      case METHOD_ADD_EVENT_LISTENER: {
          return Sk.builtin.addEventListener(mod, event);
        }
      case METHOD_PREVENT_DEFAULT: {
          return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = Sk.ffi.functionPy(function (self) {
              self.tp$name = METHOD_PREVENT_DEFAULT;
            });
            $loc.__call__ = Sk.ffi.functionPy(function (self) {
              event[METHOD_PREVENT_DEFAULT]();
            });
            $loc.__str__ = Sk.ffi.functionPy(function (self) {
              return Sk.ffi.stringToPy(METHOD_PREVENT_DEFAULT);
            });
            $loc.__repr__ = Sk.ffi.functionPy(function (self) {
              return Sk.ffi.stringToPy(METHOD_PREVENT_DEFAULT);
            });
          }, METHOD_PREVENT_DEFAULT, []));
        }
      case METHOD_STOP_IMMEDIATE_PROPAGATION: {
          return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = Sk.ffi.functionPy(function (self) {
              self.tp$name = METHOD_STOP_IMMEDIATE_PROPAGATION;
            });
            $loc.__call__ = Sk.ffi.functionPy(function (self) {
              event[METHOD_STOP_IMMEDIATE_PROPAGATION]();
            });
            $loc.__str__ = Sk.ffi.functionPy(function (self) {
              return Sk.ffi.stringToPy(METHOD_STOP_IMMEDIATE_PROPAGATION);
            });
            $loc.__repr__ = Sk.ffi.functionPy(function (self) {
              return Sk.ffi.stringToPy(METHOD_STOP_IMMEDIATE_PROPAGATION);
            });
          }, METHOD_STOP_IMMEDIATE_PROPAGATION, []));
        }
      case METHOD_STOP_PROPAGATION: {
          return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = Sk.ffi.functionPy(function (self) {
              self.tp$name = METHOD_STOP_PROPAGATION;
            });
            $loc.__call__ = Sk.ffi.functionPy(function (self) {
              event[METHOD_STOP_PROPAGATION]();
            });
            $loc.__str__ = Sk.ffi.functionPy(function (self) {
              return Sk.ffi.stringToPy(METHOD_STOP_PROPAGATION);
            });
            $loc.__repr__ = Sk.ffi.functionPy(function (self) {
              return Sk.ffi.stringToPy(METHOD_STOP_PROPAGATION);
            });
          }, METHOD_STOP_PROPAGATION, []));
        }
      default: {
          return Sk.ffi.remapToPy(event[name], '');
        }
      }
    });
    $loc.__str__ = Sk.ffi.functionPy(function (eventPy) {
      var event = Sk.ffi.remapToJs(eventPy);
      return Sk.ffi.stringToPy('' + event);
    });
    $loc.__repr__ = Sk.ffi.functionPy(function (eventPy) {
      var event = Sk.ffi.remapToJs(eventPy);
      return Sk.ffi.stringToPy('' + event);
    });
  }, EVENT, []);
};
Sk.builtin.addEventListener = function (mod, eventTarget) {
  var EVENT = 'Event';
  var METHOD_ADD_EVENT_LISTENER = 'addEventListener';
  return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
    $loc.__init__ = Sk.ffi.functionPy(function (selfPy) {
      Sk.ffi.referenceToPy(eventTarget[METHOD_ADD_EVENT_LISTENER], METHOD_ADD_EVENT_LISTENER, undefined, selfPy);
    });
    $loc.__call__ = Sk.ffi.functionPy(function (selfPy, typePy, listenerPy, useCapturePy) {
      var type = Sk.ffi.remapToJs(typePy);
      var listenerJs = function (event) {
        var eventPy = Sk.ffi.callsim(mod[EVENT], Sk.ffi.referenceToPy(event, EVENT));
        Sk.ffi.callsim(listenerPy, eventPy);
      };
      var useCapture = Sk.ffi.remapToJs(useCapturePy);
      eventTarget[METHOD_ADD_EVENT_LISTENER](type, listenerJs, useCapture);
    });
  }, METHOD_ADD_EVENT_LISTENER, []));
};
Sk.builtin.removeEventListener = function (mod, eventTarget) {
  var EVENT = 'Event';
  var METHOD_REMOVE_EVENT_LISTENER = 'removeEventListener';
  return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
    $loc.__init__ = Sk.ffi.functionPy(function (selfPy) {
      Sk.ffi.referenceToPy(eventTarget[METHOD_REMOVE_EVENT_LISTENER], METHOD_REMOVE_EVENT_LISTENER, undefined, selfPy);
    });
    $loc.__call__ = Sk.ffi.functionPy(function (selfPy, typePy, listenerPy, useCapturePy) {
      var type = Sk.ffi.remapToJs(typePy);
      var listenerJs = function (event) {
        var eventPy = Sk.ffi.callsim(mod[EVENT], Sk.ffi.referenceToPy(event, EVENT));
        Sk.ffi.callsim(listenerPy, eventPy);
      };
      var useCapture = Sk.ffi.remapToJs(useCapturePy);
      eventTarget[METHOD_REMOVE_EVENT_LISTENER](type, listenerJs, useCapture);
    });
  }, METHOD_REMOVE_EVENT_LISTENER, []));
};
Sk.geometry = Sk.geometry || {};
Sk.geometry.ARROW_BUILDER = 'ArrowBuilder';
Sk.geometry.CYLINDER_BUILDER = 'CylinderBuilder';
Sk.geometry.VORTEX_BUILDER = 'VortexBuilder';
Sk.geometry.VOLUME_BUILDER = 'VolumeBuilder';
Sk.geometry.VOLUME = 'Volume';
(function () {
  Sk.builtin.defineGeometry = function (mod, THREE, moduleName) {
    Sk.ffi.checkFunctionArgs('defineGeometry', arguments, 3, 3);
    var CARTESIAN_SPACE = 'CartesianSpace';
    var EUCLIDEAN_3 = 'Euclidean3';
    var COLOR = 'Color';
    var SCENE = 'Scene';
    var PERSPECTIVE_CAMERA = 'PerspectiveCamera';
    var CANVAS_RENDERER = 'CanvasRenderer';
    var WEBGL_RENDERER = 'WebGLRenderer';
    var PROP_ATTITUDE = 'attitude';
    var PROP_AXIS = 'axis';
    var PROP_ORIGIN = 'origin';
    var PROP_ORIENTATION = 'orientation';
    var PROP_CAMERA = 'camera';
    var PROP_RENDERER = 'renderer';
    var PROP_VERTICES = 'vertices';
    var PROP_SCENE = 'scene';
    var PROP_COLOR = 'color';
    var PROP_DEPTH = 'depth';
    var PROP_HEIGHT = 'height';
    var PROP_MAGNITUDE = 'magnitude';
    var PROP_MATERIAL = 'material';
    var PROP_NAME = 'name';
    var PROP_RADIUS = 'radius';
    var PROP_RADIUS_TOP = 'radiusTop';
    var PROP_RADIUS_BOTTOM = 'radiusBottom';
    var PROP_SCALE = 'scale';
    var PROP_SEGMENTS = 'segments';
    var PROP_VOLUME = 'volume';
    var PROP_WIDTH = 'width';
    var PROP_WIREFRAME = 'wireframe';
    var PROP_WIREFRAME_LINEWIDTH = 'wireframeLinewidth';
    var PROP_POSITION = 'position';
    var PROP_UP = 'up';
    var METHOD_ADD = 'add';
    var METHOD_BUILD = 'build';
    var METHOD_LOOK_AT = 'lookAt';
    var METHOD_NORMALIZE = 'normalize';
    var METHOD_SET_CLEAR_COLOR = 'setClearColor';
    var METHOD_RENDER = 'render';
    var METHOD_VIEW_SIZE = 'viewSize';
    var METHOD_SET_SIZE = 'setSize';
    var METHOD_UPDATE_PROJECTION_MATRIX = 'updateProjectionMatrix';
    var WORLD = 'world';
    var CONE_BUILDER = 'ConeBuilder';
    var CUBE_BUILDER = 'CubeBuilder';
    var PLANE_BUILDER = 'PlaneBuilder';
    var SPHERE_BUILDER = 'SphereBuilder';
    var AMBIENT_LIGHT = 'AmbientLight';
    var POINT_LIGHT = 'PointLight';
    var LINE_BASIC_MATERIAL = 'LineBasicMaterial';
    var MESH_BASIC_MATERIAL = 'MeshBasicMaterial';
    var MESH_LAMBERT_MATERIAL = 'MeshLambertMaterial';
    var MESH_NORMAL_MATERIAL = 'MeshNormalMaterial';
    var CUBE_GEOMETRY = 'CubeGeometry';
    var CYLINDER_GEOMETRY = 'CylinderGeometry';
    var PLANE_GEOMETRY = 'PlaneGeometry';
    var SPHERE_GEOMETRY = 'SphereGeometry';
    var TORUS_GEOMETRY = 'TorusGeometry';
    var LINE = 'Line';
    var MESH = 'Mesh';
    var GEOMETRY = 'Geometry';
    var QUATERNION = 'Quaternion';
    var VECTOR_3 = 'Vector3';
    var NUMBER = [
        Sk.ffi.PyType.FLOAT,
        Sk.ffi.PyType.INT,
        Sk.ffi.PyType.LONG
      ];
    var DEFAULT_CUBE_LENGTH = 1;
    var DEFAULT_CYLINDER_RADIUS = 0.5;
    var DEFAULT_CYLINDER_HEIGHT = 1;
    var DEFAULT_SPHERE_RADIUS = 0.5;
    var DEFAULT_COLOR = 16777215;
    var COMMA = ',';
    var SPACE = ' ';
    var EQUAL = '=';
    var LPAREN = '(';
    var RPAREN = ')';
    var COLOR_GRID = 6726098;
    var MATERIAL_GRID_MAJOR = new THREE[LINE_BASIC_MATERIAL]({
        'color': COLOR_GRID,
        'opacity': 0.2,
        'transparent': true
      });
    var MATERIAL_GRID_MINOR = new THREE[LINE_BASIC_MATERIAL]({
        'color': COLOR_GRID,
        'opacity': 0.02,
        'transparent': true
      });
    var e1 = new THREE[VECTOR_3](1, 0, 0);
    var e2 = new THREE[VECTOR_3](0, 1, 0);
    var e3 = new THREE[VECTOR_3](0, 0, 1);
    var E3 = new THREE[EUCLIDEAN_3](new THREE[VECTOR_3](0, 0, 1), new THREE[QUATERNION](0, 0, 0, 0), 0, false);
    var one = new THREE[EUCLIDEAN_3](new THREE[VECTOR_3](0, 0, 0), new THREE[QUATERNION](0, 0, 0, 1), 0, false);
    function isEuclidean3Py(valuePy) {
      return Sk.ffi.isInstance(valuePy, EUCLIDEAN_3);
    }
    function isVector3Py(valuePy) {
      return Sk.ffi.isInstance(valuePy, VECTOR_3);
    }
    function methodName(targetPy) {
      var target = Sk.ffi.remapToJs(targetPy);
      return Sk.ffi.callableToPy(mod, PROP_NAME, function (methodPy, namePy) {
        Sk.ffi.checkMethodArgs(PROP_NAME, arguments, 1, 1);
        Sk.ffi.checkArgType(PROP_NAME, Sk.ffi.PyType.STR, Sk.ffi.isStr(namePy), namePy);
        target[PROP_NAME] = Sk.ffi.remapToJs(namePy);
        return targetPy;
      });
    }
    function createMaterialPy(parameters) {
      if (parameters[PROP_MATERIAL]) {
        return parameters[PROP_MATERIAL];
      } else {
        var args = {};
        if (typeof parameters[PROP_COLOR] !== 'undefined') {
          args[PROP_COLOR] = parameters[PROP_COLOR];
        } else {
          args[PROP_COLOR] = DEFAULT_COLOR;
        }
        if (typeof parameters[PROP_WIREFRAME_LINEWIDTH] !== 'undefined') {
          args[PROP_WIREFRAME_LINEWIDTH] = parameters[PROP_WIREFRAME_LINEWIDTH];
        }
        if (typeof parameters[PROP_WIREFRAME] !== 'undefined') {
          args[PROP_WIREFRAME] = parameters[PROP_WIREFRAME];
          if (parameters[PROP_WIREFRAME]) {
            return Sk.ffi.callsim(mod[MESH_BASIC_MATERIAL], Sk.ffi.remapToPy(args));
          } else {
            return Sk.ffi.callsim(mod[MESH_LAMBERT_MATERIAL], Sk.ffi.remapToPy(args));
          }
        } else {
          args[PROP_WIREFRAME] = false;
          return Sk.ffi.callsim(mod[MESH_LAMBERT_MATERIAL], Sk.ffi.remapToPy(args));
        }
      }
    }
    function completeMesh(geometryPy, parameters) {
      function modifyMesh(meshPy) {
        var mesh = Sk.ffi.remapToJs(meshPy);
        if (parameters[PROP_NAME]) {
          mesh.name = parameters[PROP_NAME];
        }
        return meshPy;
      }
      if (parameters[PROP_MATERIAL]) {
        return modifyMesh(Sk.ffi.callsim(mod[MESH], geometryPy, parameters[PROP_MATERIAL]));
      } else {
        var args = {};
        if (typeof parameters[PROP_COLOR] !== 'undefined') {
          args[PROP_COLOR] = parameters[PROP_COLOR];
        } else {
          args[PROP_COLOR] = DEFAULT_COLOR;
        }
        if (typeof parameters[PROP_WIREFRAME_LINEWIDTH] !== 'undefined') {
          args[PROP_WIREFRAME_LINEWIDTH] = parameters[PROP_WIREFRAME_LINEWIDTH];
        }
        if (typeof parameters[PROP_WIREFRAME] !== 'undefined') {
          args[PROP_WIREFRAME] = parameters[PROP_WIREFRAME];
          if (parameters[PROP_WIREFRAME]) {
            var materialPy = Sk.ffi.callsim(mod[MESH_BASIC_MATERIAL], Sk.ffi.remapToPy(args));
            return modifyMesh(Sk.ffi.callsim(mod[MESH], geometryPy, materialPy));
          } else {
            var materialPy = Sk.ffi.callsim(mod[MESH_LAMBERT_MATERIAL], Sk.ffi.remapToPy(args));
            return modifyMesh(Sk.ffi.callsim(mod[MESH], geometryPy, materialPy));
          }
        } else {
          args[PROP_WIREFRAME] = false;
          var materialPy = Sk.ffi.callsim(mod[MESH_LAMBERT_MATERIAL], Sk.ffi.remapToPy(args));
          return modifyMesh(Sk.ffi.callsim(mod[MESH], geometryPy, materialPy));
        }
      }
    }
    mod[WORLD] = Sk.ffi.functionPy(function () {
      Sk.ffi.checkFunctionArgs(WORLD, arguments, 0, 0);
      var scenePy = Sk.ffi.callsim(mod[SCENE]);
      var scene = Sk.ffi.remapToJs(scenePy);
      function addPointLight(x, y, z) {
        var pointLight = new THREE[POINT_LIGHT](16777215);
        pointLight.position.set(x, y, z);
        scene.add(pointLight);
      }
      addPointLight(+5, +5, +5);
      scene.add(new THREE[AMBIENT_LIGHT](2236962));
      return scenePy;
    });
    function createCartesianAxes(size) {
      var COLOR_X_AXIS = 16711680;
      var COLOR_Y_AXIS = 65280;
      var COLOR_Z_AXIS = 255;
      var geometries = [
          [
            +size,
            0,
            0
          ],
          [
            0,
            +size,
            0
          ],
          [
            0,
            0,
            +size
          ],
          [
            -size,
            0,
            0
          ],
          [
            0,
            -size,
            0
          ],
          [
            0,
            0,
            -size
          ]
        ].map(function (v) {
          var geometry = new THREE[GEOMETRY]();
          geometry[PROP_VERTICES].push(new THREE[VECTOR_3](0, 0, 0));
          geometry[PROP_VERTICES].push(new THREE[VECTOR_3](v[0], v[1], v[2]));
          return geometry;
        });
      var axes = new THREE[Sk.three.OBJECT_3D]();
      axes.add(new THREE[LINE](geometries[0], new THREE[LINE_BASIC_MATERIAL]({
        'color': COLOR_X_AXIS,
        'opacity': 0.5,
        'transparent': true
      })));
      axes.add(new THREE[LINE](geometries[1], new THREE[LINE_BASIC_MATERIAL]({
        'color': COLOR_Y_AXIS,
        'opacity': 0.5,
        'transparent': true
      })));
      axes.add(new THREE[LINE](geometries[2], new THREE[LINE_BASIC_MATERIAL]({
        'color': COLOR_Z_AXIS,
        'opacity': 0.5,
        'transparent': true
      })));
      axes.add(new THREE[LINE](geometries[3], new THREE[LINE_BASIC_MATERIAL]({
        'color': COLOR_X_AXIS,
        'opacity': 0.2,
        'transparent': true
      })));
      axes.add(new THREE[LINE](geometries[4], new THREE[LINE_BASIC_MATERIAL]({
        'color': COLOR_Y_AXIS,
        'opacity': 0.2,
        'transparent': true
      })));
      axes.add(new THREE[LINE](geometries[5], new THREE[LINE_BASIC_MATERIAL]({
        'color': COLOR_Z_AXIS,
        'opacity': 0.2,
        'transparent': true
      })));
      return axes;
    }
    function createCartesianLines(majorSteps, minorsPerMajorMark, majorScale, e, o) {
      var grid = new THREE[Sk.three.OBJECT_3D]();
      var steps = majorSteps * minorsPerMajorMark;
      var minorScale = majorScale / minorsPerMajorMark;
      var extent = majorSteps * majorScale;
      var extentX = o.x * extent;
      var extentY = o.y * extent;
      var extentZ = o.z * extent;
      for (var i = -steps; i <= steps; i += 1) {
        if (i != 0) {
          var t = i * minorScale;
          var gridLineGeometry = new THREE[GEOMETRY]();
          gridLineGeometry[PROP_VERTICES].push(new THREE[VECTOR_3](e.x * t - extentX, e.y * t - extentY, e.z * t - extentZ));
          gridLineGeometry[PROP_VERTICES].push(new THREE[VECTOR_3](e.x * t + extentX, e.y * t + extentY, e.z * t + extentZ));
          var material = i % minorsPerMajorMark === 0 ? MATERIAL_GRID_MAJOR : MATERIAL_GRID_MINOR;
          var line = new THREE[LINE](gridLineGeometry, material);
          grid.add(line);
        }
      }
      return grid;
    }
    mod[CARTESIAN_SPACE] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, scenePy, rendererPy) {
        var scene;
        var renderer;
        Sk.ffi.checkMethodArgs(CARTESIAN_SPACE, arguments, 0, 2);
        if (Sk.ffi.isDefined(scenePy)) {
          Sk.ffi.checkArgType(PROP_SCENE, SCENE, Sk.ffi.isInstance(scenePy, SCENE), scenePy);
        } else {
          scenePy = Sk.ffi.callsim(mod[WORLD]);
        }
        scene = Sk.ffi.remapToJs(scenePy);
        if (Sk.ffi.isDefined(rendererPy)) {
          Sk.ffi.checkArgType(PROP_RENDERER, [
            CANVAS_RENDERER,
            WEBGL_RENDERER
          ], Sk.ffi.isInstance(rendererPy, WEBGL_RENDERER) || Sk.ffi.isInstance(rendererPy, CANVAS_RENDERER), rendererPy);
        } else {
          rendererPy = Sk.ffi.callsim(mod[WEBGL_RENDERER], Sk.ffi.remapToPy({ 'antialias': true }));
        }
        renderer = Sk.ffi.remapToJs(rendererPy);
        var cameraPy = Sk.ffi.callsim(mod[PERSPECTIVE_CAMERA], Sk.ffi.numberToFloatPy(45), Sk.ffi.numberToFloatPy(1), Sk.ffi.numberToFloatPy(0.1), Sk.ffi.numberToFloatPy(10000));
        var camera = Sk.ffi.remapToJs(cameraPy);
        camera[PROP_UP].set(0, 0, 1);
        camera[PROP_POSITION].set(+8, +4, +5);
        camera[METHOD_LOOK_AT](scene.position);
        renderer[METHOD_SET_CLEAR_COLOR](526344, 1);
        scene.add(createCartesianAxes(1000));
        scene.add(createCartesianLines(5, 10, 1, e1, e2));
        scene.add(createCartesianLines(5, 10, 1, e2, e1));
        Sk.ffi.referenceToPy({
          scenePy: scenePy,
          cameraPy: cameraPy,
          rendererPy: rendererPy
        }, CARTESIAN_SPACE, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var space = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case PROP_CAMERA: {
            return space.cameraPy;
          }
        case PROP_ORIGIN: {
            return Sk.ffi.gattr(space.scenePy, PROP_POSITION);
          }
        case PROP_RENDERER: {
            return space.rendererPy;
          }
        case PROP_SCENE: {
            return space.scenePy;
          }
        case METHOD_ADD: {
            return Sk.ffi.gattr(space.scenePy, METHOD_ADD);
          }
        case METHOD_RENDER: {
            return Sk.ffi.callableToPy(mod, METHOD_RENDER, function (methodPy) {
              methodPy = Sk.ffi.gattr(space.rendererPy, METHOD_RENDER);
              return Sk.ffi.callsim(methodPy, space.scenePy, space.cameraPy);
            });
          }
        case METHOD_VIEW_SIZE: {
            return Sk.ffi.callableToPy(mod, METHOD_RENDER, function (methodPy, widthPy, heightPy) {
              Sk.ffi.checkMethodArgs(METHOD_VIEW_SIZE, arguments, 2, 2);
              Sk.ffi.checkArgType(PROP_WIDTH, Sk.ffi.PyType.INT, Sk.ffi.isInt(widthPy), widthPy);
              Sk.ffi.checkArgType(PROP_HEIGHT, Sk.ffi.PyType.INT, Sk.ffi.isInt(heightPy), heightPy);
              var width = Sk.ffi.remapToJs(widthPy);
              var height = Sk.ffi.remapToJs(heightPy);
              var renderer = Sk.ffi.remapToJs(space.rendererPy);
              renderer.setSize(width, height);
              var camera = Sk.ffi.remapToJs(space.cameraPy);
              camera.aspect = width / height;
              camera[METHOD_UPDATE_PROJECTION_MATRIX]();
            });
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(CARTESIAN_SPACE);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffi.stringToPy(CARTESIAN_SPACE);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffi.stringToPy(CARTESIAN_SPACE);
      });
    }, CARTESIAN_SPACE, []);
    function builderGetAttr(selfPy, name, className) {
      var self = Sk.ffi.remapToJs(selfPy);
      switch (name) {
      case PROP_ATTITUDE: {
          return Sk.ffi.callableToPy(mod, name, function (methodPy, attitudePy) {
            Sk.ffi.checkMethodArgs(name, arguments, 1, 1);
            Sk.ffi.checkArgType(name, EUCLIDEAN_3, isEuclidean3Py(attitudePy), attitudePy);
            self[name] = Sk.ffi.remapToJs(attitudePy);
            return selfPy;
          });
        }
      case PROP_COLOR: {
          return Sk.ffi.callableToPy(mod, name, function (methodPy, colorPy) {
            Sk.ffi.checkMethodArgs(name, arguments, 1, 1);
            Sk.ffi.checkArgType(name, NUMBER, Sk.ffi.isNum(colorPy) || Sk.ffi.isStr(colorPy) || Sk.ffi.isInstance(colorPy, COLOR), colorPy);
            self[name] = Sk.ffi.remapToJs(colorPy);
            return selfPy;
          });
        }
      case PROP_MATERIAL: {
          return Sk.ffi.callableToPy(mod, PROP_MATERIAL, function (methodPy, materialPy) {
            Sk.ffi.checkMethodArgs(PROP_MATERIAL, arguments, 1, 1);
            Sk.ffi.checkArgType(PROP_MATERIAL, Sk.three.MATERIAL, Sk.ffi.isInstance(materialPy), materialPy);
            self[PROP_MATERIAL] = materialPy;
            return selfPy;
          });
        }
      case PROP_NAME: {
          return methodName(selfPy);
        }
      case PROP_SCALE: {
          return Sk.ffi.callableToPy(mod, PROP_SCALE, function (methodPy, lengthPy) {
            Sk.ffi.checkMethodArgs(PROP_SCALE, arguments, 1, 1);
            Sk.ffi.checkArgType(PROP_SCALE, [
              NUMBER,
              Sk.ffi.PyType.NONE
            ], Sk.ffi.isNum(lengthPy) || Sk.ffi.isNone(lengthPy), lengthPy);
            self[PROP_SCALE] = Sk.ffi.remapToJs(lengthPy);
            return selfPy;
          });
        }
      case PROP_VOLUME: {
          return Sk.ffi.callableToPy(mod, PROP_VOLUME, function (methodPy, volumePy) {
            Sk.ffi.checkMethodArgs(PROP_VOLUME, arguments, 1, 1);
            Sk.ffi.checkArgType(PROP_VOLUME, NUMBER, Sk.ffi.isNum(volumePy) || Sk.ffi.isNone(volumePy), volumePy);
            self[PROP_VOLUME] = Sk.ffi.remapToJs(volumePy);
            return selfPy;
          });
        }
      case PROP_WIREFRAME: {
          return Sk.ffi.callableToPy(mod, name, function (methodPy, wireframePy) {
            Sk.ffi.checkMethodArgs(name, arguments, 1, 1);
            Sk.ffi.checkArgType(name, Sk.ffi.PyType.BOOL, Sk.ffi.isBool(wireframePy), wireframePy);
            self[name] = Sk.ffi.remapToJs(wireframePy);
            return selfPy;
          });
        }
      case PROP_WIREFRAME_LINEWIDTH: {
          return Sk.ffi.callableToPy(mod, name, function (methodPy, wireframeLinewidthPy) {
            Sk.ffi.checkMethodArgs(name, arguments, 1, 1);
            Sk.ffi.checkArgType(name, Sk.ffi.PyType.INT, Sk.ffi.isInt(wireframeLinewidthPy), wireframeLinewidthPy);
            self[name] = Sk.ffi.remapToJs(wireframeLinewidthPy);
            return selfPy;
          });
        }
      default: {
          throw Sk.ffi.err.attribute(name).isNotGetableOnType(className);
        }
      }
    }
    Sk.geometry.ArrowBuilder = function () {
      this._innerPy = Sk.ffi.callsim(mod[Sk.geometry.ARROW_BUILDER]);
    };
    Sk.geometry.ArrowBuilder.prototype = {
      constructor: Sk.geometry.ArrowBuilder,
      axis: function (x, y, z) {
        var xPy = Sk.ffi.numberToFloatPy(x);
        var yPy = Sk.ffi.numberToFloatPy(y);
        var zPy = Sk.ffi.numberToFloatPy(z);
        var directionPy = Sk.ffi.callsim(mod[Sk.e3ga.VECTOR_E3], xPy, yPy, zPy);
        Sk.ffi.callsim(Sk.ffi.gattr(this._innerPy, PROP_AXIS), directionPy);
        return this;
      },
      material: function (material) {
        var materialPy = Sk.ffi.callsim(mod[Sk.three.MATERIAL], Sk.ffi.referenceToPy(material, Sk.three.MATERIAL));
        Sk.ffi.callsim(Sk.ffi.gattr(this._innerPy, PROP_MATERIAL), materialPy);
        return this;
      },
      radius: function (radius) {
        var radiusPy = Sk.ffi.numberToFloatPy(radius);
        Sk.ffi.callsim(Sk.ffi.gattr(this._innerPy, PROP_RADIUS), radiusPy);
        return this;
      },
      build: function () {
        return Sk.ffi.remapToJs(Sk.ffi.callsim(Sk.ffi.gattr(this._innerPy, METHOD_BUILD)));
      }
    };
    mod[Sk.geometry.ARROW_BUILDER] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy) {
        Sk.ffi.checkMethodArgs(Sk.geometry.ARROW_BUILDER, arguments, 0, 0);
        Sk.ffi.referenceToPy({}, Sk.geometry.ARROW_BUILDER, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var arrow = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case PROP_MAGNITUDE: {
            return Sk.ffi.callableToPy(mod, PROP_MAGNITUDE, function (methodPy, lengthPy) {
              Sk.ffi.checkMethodArgs(PROP_MAGNITUDE, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_MAGNITUDE, [
                NUMBER,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(lengthPy) || Sk.ffi.isNone(lengthPy), lengthPy);
              arrow[PROP_MAGNITUDE] = Sk.ffi.remapToJs(lengthPy);
              return selfPy;
            });
          }
        case PROP_AXIS: {
            return Sk.ffi.callableToPy(mod, PROP_AXIS, function (methodPy, axisPy) {
              Sk.ffi.checkMethodArgs(PROP_AXIS, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_AXIS, [
                EUCLIDEAN_3,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isInstance(axisPy, EUCLIDEAN_3) || Sk.ffi.isNone(axisPy), axisPy);
              arrow[PROP_AXIS] = Sk.ffi.remapToJs(axisPy);
              return selfPy;
            });
          }
        case PROP_RADIUS: {
            return Sk.ffi.callableToPy(mod, PROP_RADIUS, function (methodPy, radiusPy) {
              Sk.ffi.checkMethodArgs(PROP_RADIUS, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_RADIUS, [
                NUMBER,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(radiusPy) || Sk.ffi.isNone(radiusPy), radiusPy);
              arrow[PROP_RADIUS] = Sk.ffi.remapToJs(radiusPy);
              return selfPy;
            });
          }
        case PROP_SEGMENTS: {
            return Sk.ffi.callableToPy(mod, PROP_SEGMENTS, function (methodPy, segmentsPy) {
              Sk.ffi.checkMethodArgs(PROP_SEGMENTS, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_SEGMENTS, [
                Sk.ffi.PyType.INT,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isInt(segmentsPy) || Sk.ffi.isNone(segmentsPy), segmentsPy);
              arrow[PROP_SEGMENTS] = Sk.ffi.remapToJs(segmentsPy);
              return selfPy;
            });
          }
        case METHOD_BUILD: {
            return Sk.ffi.callableToPy(mod, METHOD_BUILD, function (methodPy) {
              function dimensionArrow() {
                var dims = {};
                dims.attitude = arrow.attitude ? arrow.attitude : one;
                dims.axis = arrow[PROP_AXIS] ? arrow[PROP_AXIS] : E3;
                if (arrow.volume) {
                  var s = arrow.scale ? arrow.scale : 1;
                  var h = arrow.length ? arrow.length : DEFAULT_CYLINDER_HEIGHT;
                  var r = arrow.radius ? arrow.radius : DEFAULT_CYLINDER_RADIUS;
                  var alpha = r / h;
                  dims.radius = Math.pow(3 * alpha * arrow.volume / Math.PI, 1 / 3);
                  dims.length = dims.radius / alpha;
                } else {
                  dims.scale = arrow.scale ? arrow.scale : 1;
                  dims.radius = arrow.radius ? arrow.radius : DEFAULT_CYLINDER_RADIUS;
                  dims.length = arrow.length ? arrow.length : DEFAULT_CYLINDER_HEIGHT;
                }
                return dims;
              }
              Sk.ffi.checkMethodArgs(METHOD_BUILD, arguments, 0, 0);
              var dimensions = dimensionArrow();
              var scalePy = Sk.ffi.numberToFloatPy(dimensions[PROP_SCALE]);
              var attitudePy = Sk.ffi.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(dimensions[PROP_ATTITUDE], EUCLIDEAN_3));
              var segmentsPy = Sk.ffi.numberToIntPy(arrow[PROP_SEGMENTS] ? arrow[PROP_SEGMENTS] : 32);
              var lengthPy = Sk.ffi.numberToFloatPy(dimensions[PROP_MAGNITUDE]);
              var axisPy = Sk.ffi.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(dimensions[PROP_AXIS], EUCLIDEAN_3));
              var geometryPy = Sk.ffi.callsim(mod[Sk.three.ARROW_GEOMETRY], scalePy, attitudePy, segmentsPy, lengthPy, undefined, undefined, undefined, axisPy);
              return completeMesh(geometryPy, arrow);
            });
          }
        case METHOD_NORMALIZE: {
            return Sk.ffi.callableToPy(mod, METHOD_NORMALIZE, function (methodPy) {
              Sk.ffi.checkMethodArgs(METHOD_NORMALIZE, arguments, 0, 0);
              return selfPy;
            });
          }
        default: {
            return builderGetAttr(selfPy, name, Sk.geometry.ARROW_BUILDER);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        return Sk.ffi.stringToPy('' + self);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffi.stringToPy(Sk.geometry.ARROW_BUILDER + '(' + ')');
      });
    }, Sk.geometry.ARROW_BUILDER, []);
    mod[CONE_BUILDER] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy) {
        Sk.ffi.checkMethodArgs(CONE_BUILDER, arguments, 0, 0);
        Sk.ffi.referenceToPy({}, CONE_BUILDER, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var cone = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case PROP_HEIGHT: {
            return Sk.ffi.callableToPy(mod, PROP_HEIGHT, function (methodPy, heightPy) {
              Sk.ffi.checkMethodArgs(PROP_HEIGHT, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_HEIGHT, [
                NUMBER,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(heightPy) || Sk.ffi.isNone(heightPy), heightPy);
              cone[PROP_HEIGHT] = Sk.ffi.remapToJs(heightPy);
              return selfPy;
            });
          }
        case PROP_RADIUS: {
            return Sk.ffi.callableToPy(mod, PROP_RADIUS, function (methodPy, radiusPy) {
              Sk.ffi.checkMethodArgs(PROP_RADIUS, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_RADIUS, [
                NUMBER,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(radiusPy) || Sk.ffi.isNone(radiusPy), radiusPy);
              cone[PROP_RADIUS] = Sk.ffi.remapToJs(radiusPy);
              return selfPy;
            });
          }
        case PROP_SEGMENTS: {
            return Sk.ffi.callableToPy(mod, PROP_SEGMENTS, function (methodPy, segmentsPy) {
              Sk.ffi.checkMethodArgs(PROP_SEGMENTS, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_SEGMENTS, [
                Sk.ffi.PyType.INT,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isInt(segmentsPy) || Sk.ffi.isNone(segmentsPy), segmentsPy);
              cone[PROP_SEGMENTS] = Sk.ffi.remapToJs(segmentsPy);
              return selfPy;
            });
          }
        case METHOD_BUILD: {
            return Sk.ffi.callableToPy(mod, METHOD_BUILD, function (methodPy) {
              function dimensionCone() {
                var dims = {};
                if (cone.volume) {
                  var r = cone.radius ? cone.radius : DEFAULT_CYLINDER_RADIUS;
                  var h = cone.height ? cone.height : DEFAULT_CYLINDER_HEIGHT;
                  var alpha = r / h;
                  dims.radius = Math.pow(3 * alpha * cone.volume / Math.PI, 1 / 3);
                  dims.height = dims.radius / alpha;
                } else {
                  dims.radius = cone.radius ? cone.radius : DEFAULT_CYLINDER_RADIUS;
                  dims.height = cone.height ? cone.height : DEFAULT_CYLINDER_HEIGHT;
                }
                return dims;
              }
              Sk.ffi.checkMethodArgs(METHOD_BUILD, arguments, 0, 0);
              var dimensions = dimensionCone();
              var radiusTop = Sk.ffi.numberToFloatPy(0);
              var radiusBottom = Sk.ffi.numberToFloatPy(dimensions[PROP_RADIUS]);
              var height = Sk.ffi.numberToFloatPy(dimensions[PROP_HEIGHT]);
              var radialSegments = Sk.ffi.numberToIntPy(cone[PROP_SEGMENTS] ? cone[PROP_SEGMENTS] : 32);
              var heightSegments = Sk.ffi.numberToIntPy(1);
              var openEnded = Sk.ffi.booleanToPy(false);
              var geometryPy = Sk.ffi.callsim(mod[CYLINDER_GEOMETRY], radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded);
              return completeMesh(geometryPy, cone);
            });
          }
        case METHOD_NORMALIZE: {
            return Sk.ffi.callableToPy(mod, METHOD_NORMALIZE, function (methodPy) {
              Sk.ffi.checkMethodArgs(METHOD_NORMALIZE, arguments, 0, 0);
              return selfPy;
            });
          }
        default: {
            return builderGetAttr(selfPy, name, CONE_BUILDER);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        return Sk.ffi.stringToPy('' + self);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffi.stringToPy(CONE_BUILDER + '(' + ')');
      });
    }, CONE_BUILDER, []);
    mod[CUBE_BUILDER] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy) {
        Sk.ffi.checkMethodArgs(CUBE_BUILDER, arguments, 0, 0);
        Sk.ffi.referenceToPy({}, CUBE_BUILDER, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var cube = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case PROP_DEPTH: {
            return Sk.ffi.callableToPy(mod, PROP_DEPTH, function (methodPy, depthPy) {
              Sk.ffi.checkMethodArgs(PROP_DEPTH, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_DEPTH, [
                NUMBER,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(depthPy) || Sk.ffi.isNone(depthPy), depthPy);
              cube[PROP_DEPTH] = Sk.ffi.remapToJs(depthPy);
              return selfPy;
            });
          }
        case PROP_HEIGHT: {
            return Sk.ffi.callableToPy(mod, PROP_HEIGHT, function (methodPy, heightPy) {
              Sk.ffi.checkMethodArgs(PROP_HEIGHT, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_HEIGHT, [
                NUMBER,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(heightPy) || Sk.ffi.isNone(heightPy), heightPy);
              cube[PROP_HEIGHT] = Sk.ffi.remapToJs(heightPy);
              return selfPy;
            });
          }
        case PROP_WIDTH: {
            return Sk.ffi.callableToPy(mod, PROP_WIDTH, function (methodPy, widthPy) {
              Sk.ffi.checkMethodArgs(PROP_WIDTH, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_WIDTH, [
                NUMBER,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(widthPy) || Sk.ffi.isNone(widthPy), widthPy);
              cube[PROP_WIDTH] = Sk.ffi.remapToJs(widthPy);
              return selfPy;
            });
          }
        case PROP_SEGMENTS: {
            return Sk.ffi.callableToPy(mod, PROP_SEGMENTS, function (methodPy, segmentsPy) {
              Sk.ffi.checkMethodArgs(PROP_SEGMENTS, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_SEGMENTS, [
                Sk.ffi.PyType.INT,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isInt(segmentsPy) || Sk.ffi.isNone(segmentsPy), segmentsPy);
              cube[PROP_SEGMENTS] = Sk.ffi.remapToJs(segmentsPy);
              return selfPy;
            });
          }
        case METHOD_BUILD: {
            return Sk.ffi.callableToPy(mod, METHOD_BUILD, function (methodPy) {
              function dimensionCube() {
                var dims = {};
                if (cube[PROP_VOLUME]) {
                  var w = cube.width ? cube.width : DEFAULT_CUBE_LENGTH;
                  var h = cube.height ? cube.height : DEFAULT_CUBE_LENGTH;
                  var d = cube.depth ? cube.depth : DEFAULT_CUBE_LENGTH;
                  var alpha = Math.pow(cube[PROP_VOLUME] / (w * h * d), 1 / 3);
                  dims.width = alpha * w;
                  dims.height = alpha * h;
                  dims.depth = alpha * d;
                } else {
                  dims.width = cube.width ? cube.width : DEFAULT_CUBE_LENGTH;
                  dims.height = cube.height ? cube.height : DEFAULT_CUBE_LENGTH;
                  dims.depth = cube.depth ? cube.depth : DEFAULT_CUBE_LENGTH;
                }
                return dims;
              }
              Sk.ffi.checkMethodArgs(METHOD_BUILD, arguments, 0, 0);
              var dimensions = dimensionCube();
              var width = Sk.ffi.numberToFloatPy(dimensions[PROP_WIDTH]);
              var height = Sk.ffi.numberToFloatPy(dimensions[PROP_HEIGHT]);
              var depth = Sk.ffi.numberToFloatPy(dimensions[PROP_DEPTH]);
              var segments = Sk.ffi.numberToIntPy(cube[PROP_SEGMENTS] ? cube[PROP_SEGMENTS] : 1);
              var geometryPy = Sk.ffi.callsim(mod[CUBE_GEOMETRY], width, height, depth, segments, segments, segments);
              return completeMesh(geometryPy, cube);
            });
          }
        case METHOD_NORMALIZE: {
            return Sk.ffi.callableToPy(mod, METHOD_NORMALIZE, function (methodPy) {
              Sk.ffi.checkMethodArgs(METHOD_NORMALIZE, arguments, 0, 0);
              cube[PROP_DEPTH] = 1;
              cube[PROP_WIDTH] = 1;
              cube[PROP_HEIGHT] = 1;
              return selfPy;
            });
          }
        default: {
            return builderGetAttr(selfPy, name, CUBE_BUILDER);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        return Sk.ffi.stringToPy('' + self);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffi.stringToPy(CUBE_BUILDER + '(' + ')');
      });
    }, CUBE_BUILDER, []);
    Sk.geometry.CylinderBuilder = function () {
      this._innerPy = Sk.ffi.callsim(mod[Sk.geometry.CYLINDER_BUILDER]);
    };
    Sk.geometry.CylinderBuilder.prototype = {
      constructor: Sk.geometry.CylinderBuilder,
      axis: function (x, y, z) {
        var xPy = Sk.ffi.numberToFloatPy(x);
        var yPy = Sk.ffi.numberToFloatPy(y);
        var zPy = Sk.ffi.numberToFloatPy(z);
        var directionPy = Sk.ffi.callsim(mod[Sk.e3ga.VECTOR_E3], xPy, yPy, zPy);
        Sk.ffi.callsim(Sk.ffi.gattr(this._innerPy, PROP_AXIS), directionPy);
        return this;
      },
      material: function (material) {
        var materialPy = Sk.ffi.callsim(mod[Sk.three.MATERIAL], Sk.ffi.referenceToPy(material, Sk.three.MATERIAL));
        Sk.ffi.callsim(Sk.ffi.gattr(this._innerPy, PROP_MATERIAL), materialPy);
        return this;
      },
      radius: function (radius) {
        var radiusPy = Sk.ffi.numberToFloatPy(radius);
        Sk.ffi.callsim(Sk.ffi.gattr(this._innerPy, PROP_RADIUS), radiusPy);
        return this;
      },
      build: function () {
        return Sk.ffi.remapToJs(Sk.ffi.callsim(Sk.ffi.gattr(this._innerPy, METHOD_BUILD)));
      }
    };
    mod[Sk.geometry.CYLINDER_BUILDER] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy) {
        Sk.ffi.checkMethodArgs(Sk.geometry.CYLINDER_BUILDER, arguments, 0, 0);
        var self = {};
        self[PROP_RADIUS_TOP] = DEFAULT_CYLINDER_RADIUS;
        self[PROP_RADIUS_BOTTOM] = DEFAULT_CYLINDER_RADIUS;
        self[PROP_HEIGHT] = DEFAULT_CYLINDER_HEIGHT;
        Sk.ffi.referenceToPy(self, Sk.geometry.CYLINDER_BUILDER, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var cylinder = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case PROP_AXIS: {
            return Sk.ffi.callableToPy(mod, PROP_AXIS, function (methodPy, axisPy) {
              Sk.ffi.checkMethodArgs(PROP_AXIS, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_AXIS, [
                EUCLIDEAN_3,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isInstance(axisPy, EUCLIDEAN_3) || Sk.ffi.isNone(axisPy), axisPy);
              cylinder[PROP_AXIS] = Sk.ffi.remapToJs(axisPy);
              return selfPy;
            });
          }
        case PROP_HEIGHT: {
            return Sk.ffi.callableToPy(mod, PROP_HEIGHT, function (methodPy, heightPy) {
              Sk.ffi.checkMethodArgs(PROP_HEIGHT, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_HEIGHT, [
                NUMBER,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(heightPy) || Sk.ffi.isNone(heightPy), heightPy);
              cylinder[PROP_HEIGHT] = Sk.ffi.remapToJs(heightPy);
              return selfPy;
            });
          }
        case PROP_RADIUS: {
            return Sk.ffi.callableToPy(mod, PROP_RADIUS, function (methodPy, radiusPy) {
              Sk.ffi.checkMethodArgs(PROP_RADIUS, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_RADIUS, [
                NUMBER,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(radiusPy) || Sk.ffi.isNone(radiusPy), radiusPy);
              cylinder[PROP_RADIUS_TOP] = Sk.ffi.remapToJs(radiusPy);
              cylinder[PROP_RADIUS_BOTTOM] = Sk.ffi.remapToJs(radiusPy);
              return selfPy;
            });
          }
        case PROP_RADIUS_TOP: {
            return Sk.ffi.callableToPy(mod, PROP_RADIUS_TOP, function (methodPy, radiusTopPy) {
              Sk.ffi.checkMethodArgs(PROP_RADIUS_TOP, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_RADIUS_TOP, [
                NUMBER,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(radiusTopPy) || Sk.ffi.isNone(radiusTopPy), radiusTopPy);
              cylinder[PROP_RADIUS_TOP] = Sk.ffi.remapToJs(radiusTopPy);
              return selfPy;
            });
          }
        case PROP_RADIUS_BOTTOM: {
            return Sk.ffi.callableToPy(mod, PROP_RADIUS_BOTTOM, function (methodPy, radiusBottomPy) {
              Sk.ffi.checkMethodArgs(PROP_RADIUS_BOTTOM, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_RADIUS_BOTTOM, [
                NUMBER,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(radiusBottomPy) || Sk.ffi.isNone(radiusBottomPy), radiusBottomPy);
              cylinder[PROP_RADIUS_BOTTOM] = Sk.ffi.remapToJs(radiusBottomPy);
              return selfPy;
            });
          }
        case PROP_SEGMENTS: {
            return Sk.ffi.callableToPy(mod, PROP_SEGMENTS, function (methodPy, segmentsPy) {
              Sk.ffi.checkMethodArgs(PROP_SEGMENTS, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_SEGMENTS, [
                Sk.ffi.PyType.INT,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isInt(segmentsPy) || Sk.ffi.isNone(segmentsPy), segmentsPy);
              cylinder[PROP_SEGMENTS] = Sk.ffi.remapToJs(segmentsPy);
              return selfPy;
            });
          }
        case METHOD_BUILD: {
            return Sk.ffi.callableToPy(mod, METHOD_BUILD, function (methodPy) {
              function dimensionCylinder() {
                var dims = {};
                dims.axis = cylinder[PROP_AXIS] ? cylinder[PROP_AXIS] : E3;
                if (cylinder.volume) {
                  var a = typeof cylinder.radiusTop === 'number' ? cylinder.radiusTop : DEFAULT_CYLINDER_RADIUS;
                  var b = typeof cylinder.radiusBottom === 'number' ? cylinder.radiusBottom : DEFAULT_CYLINDER_RADIUS;
                  var h = typeof cylinder.height === 'number' ? cylinder.height : DEFAULT_CYLINDER_HEIGHT;
                  var alpha = Math.pow(3 * cylinder.volume / (b * (b + a) * h * Math.PI), 1 / 3);
                  dims.a = alpha * a;
                  dims.b = alpha * b;
                  dims.h = alpha * h;
                } else {
                  dims.a = typeof cylinder.radiusTop === 'number' ? cylinder.radiusTop : DEFAULT_CYLINDER_RADIUS;
                  dims.b = typeof cylinder.radiusBottom === 'number' ? cylinder.radiusBottom : DEFAULT_CYLINDER_RADIUS;
                  dims.h = typeof cylinder.height === 'number' ? cylinder.height : DEFAULT_CYLINDER_HEIGHT;
                }
                return dims;
              }
              Sk.ffi.checkMethodArgs(METHOD_BUILD, arguments, 0, 0);
              var dimensions = dimensionCylinder();
              var radiusTop = Sk.ffi.numberToFloatPy(dimensions.a);
              var radiusBottom = Sk.ffi.numberToFloatPy(dimensions.b);
              var height = Sk.ffi.numberToFloatPy(dimensions.h);
              var radialSegments = Sk.ffi.numberToIntPy(cylinder[PROP_SEGMENTS] ? cylinder[PROP_SEGMENTS] : 32);
              var heightSegments = Sk.ffi.numberToIntPy(1);
              var openEnded = Sk.ffi.booleanToPy(false);
              var axisPy = Sk.ffi.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(dimensions[PROP_AXIS], EUCLIDEAN_3));
              var geometryPy = Sk.ffi.callsim(mod[CYLINDER_GEOMETRY], radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, axisPy);
              return completeMesh(geometryPy, cylinder);
            });
          }
        case METHOD_NORMALIZE: {
            return Sk.ffi.callableToPy(mod, METHOD_NORMALIZE, function (methodPy) {
              Sk.ffi.checkMethodArgs(METHOD_NORMALIZE, arguments, 0, 0);
              return selfPy;
            });
          }
        default: {
            return builderGetAttr(selfPy, name, Sk.geometry.CYLINDER_BUILDER);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        return Sk.ffi.stringToPy('' + self);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffi.stringToPy(Sk.geometry.CYLINDER_BUILDER + '(' + ')');
      });
    }, Sk.geometry.CYLINDER_BUILDER, []);
    mod[PLANE_BUILDER] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy) {
        Sk.ffi.checkMethodArgs(PLANE_BUILDER, arguments, 0, 0);
        Sk.ffi.referenceToPy({}, PLANE_BUILDER, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var plane = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case PROP_HEIGHT: {
            return Sk.ffi.callableToPy(mod, PROP_HEIGHT, function (methodPy, heightPy) {
              Sk.ffi.checkMethodArgs(PROP_HEIGHT, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_HEIGHT, [
                NUMBER,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(heightPy) || Sk.ffi.isNone(heightPy), heightPy);
              plane[PROP_HEIGHT] = Sk.ffi.remapToJs(heightPy);
              return selfPy;
            });
          }
        case PROP_WIDTH: {
            return Sk.ffi.callableToPy(mod, PROP_WIDTH, function (methodPy, widthPy) {
              Sk.ffi.checkMethodArgs(PROP_WIDTH, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_WIDTH, [
                NUMBER,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(widthPy) || Sk.ffi.isNone(widthPy), widthPy);
              plane[PROP_WIDTH] = Sk.ffi.remapToJs(widthPy);
              return selfPy;
            });
          }
        case PROP_SEGMENTS: {
            return Sk.ffi.callableToPy(mod, PROP_SEGMENTS, function (methodPy, segmentsPy) {
              Sk.ffi.checkMethodArgs(PROP_SEGMENTS, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_SEGMENTS, [
                Sk.ffi.PyType.INT,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isInt(segmentsPy) || Sk.ffi.isNone(segmentsPy), segmentsPy);
              plane[PROP_SEGMENTS] = Sk.ffi.remapToJs(segmentsPy);
              return selfPy;
            });
          }
        case METHOD_BUILD: {
            return Sk.ffi.callableToPy(mod, METHOD_BUILD, function (methodPy) {
              function dimensionPlane() {
                var dims = {};
                if (plane[PROP_VOLUME]) {
                  var w = plane.width ? plane.width : DEFAULT_CUBE_LENGTH;
                  var h = plane.height ? plane.height : DEFAULT_CUBE_LENGTH;
                  var alpha = Math.pow(plane[PROP_VOLUME] / (w * h), 1 / 2);
                  dims.width = alpha * w;
                  dims.height = alpha * h;
                } else {
                  dims.width = plane.width ? plane.width : DEFAULT_CUBE_LENGTH;
                  dims.height = plane.height ? plane.height : DEFAULT_CUBE_LENGTH;
                }
                return dims;
              }
              Sk.ffi.checkMethodArgs(METHOD_BUILD, arguments, 0, 0);
              var dimensions = dimensionPlane();
              var width = Sk.ffi.numberToFloatPy(dimensions[PROP_WIDTH]);
              var height = Sk.ffi.numberToFloatPy(dimensions[PROP_HEIGHT]);
              var segments = Sk.ffi.numberToIntPy(plane[PROP_SEGMENTS] ? plane[PROP_SEGMENTS] : 1);
              var geometryPy = Sk.ffi.callsim(mod[PLANE_GEOMETRY], width, height, segments, segments);
              return completeMesh(geometryPy, plane);
            });
          }
        case METHOD_NORMALIZE: {
            return Sk.ffi.callableToPy(mod, METHOD_NORMALIZE, function (methodPy) {
              Sk.ffi.checkMethodArgs(METHOD_NORMALIZE, arguments, 0, 0);
              return selfPy;
            });
          }
        default: {
            return builderGetAttr(selfPy, name, PLANE_BUILDER);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        return Sk.ffi.stringToPy('' + self);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffi.stringToPy(PLANE_BUILDER + '(' + ')');
      });
    }, PLANE_BUILDER, []);
    mod[SPHERE_BUILDER] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy) {
        Sk.ffi.checkMethodArgs(SPHERE_BUILDER, arguments, 0, 0);
        Sk.ffi.referenceToPy({}, SPHERE_BUILDER, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var args = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case PROP_RADIUS: {
            return Sk.ffi.callableToPy(mod, PROP_RADIUS, function (methodPy, radiusPy) {
              Sk.ffi.checkMethodArgs(PROP_RADIUS, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_RADIUS, [
                NUMBER,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(radiusPy) || Sk.ffi.isNone(radiusPy), radiusPy);
              args[PROP_RADIUS] = Sk.ffi.remapToJs(radiusPy);
              return selfPy;
            });
          }
        case PROP_SEGMENTS: {
            return Sk.ffi.callableToPy(mod, PROP_SEGMENTS, function (methodPy, segmentsPy) {
              Sk.ffi.checkMethodArgs(PROP_SEGMENTS, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_SEGMENTS, [
                Sk.ffi.PyType.INT,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isInt(segmentsPy) || Sk.ffi.isNone(segmentsPy), segmentsPy);
              args[PROP_SEGMENTS] = Sk.ffi.remapToJs(segmentsPy);
              return selfPy;
            });
          }
        case METHOD_BUILD: {
            return Sk.ffi.callableToPy(mod, METHOD_BUILD, function (methodPy) {
              function dimensionSphere() {
                var dims = {};
                if (args[PROP_VOLUME]) {
                  var r = args.radius ? args.radius : DEFAULT_SPHERE_RADIUS;
                  dims.radius = Math.pow(3 * args[PROP_VOLUME] / (4 * Math.PI), 1 / 3);
                } else {
                  dims.radius = args.radius ? args.radius : DEFAULT_SPHERE_RADIUS;
                }
                return dims;
              }
              Sk.ffi.checkMethodArgs(METHOD_BUILD, arguments, 0, 0);
              var dimensions = dimensionSphere();
              var radius = Sk.ffi.numberToFloatPy(dimensions.radius);
              var widthSegments = Sk.ffi.numberToIntPy(args[PROP_SEGMENTS] ? args[PROP_SEGMENTS] : 24);
              var heightSegments = Sk.ffi.numberToIntPy(args[PROP_SEGMENTS] ? args[PROP_SEGMENTS] : 18);
              var geometryPy = Sk.ffi.callsim(mod[SPHERE_GEOMETRY], radius, widthSegments, heightSegments);
              return completeMesh(geometryPy, args);
            });
          }
        case METHOD_NORMALIZE: {
            return Sk.ffi.callableToPy(mod, METHOD_NORMALIZE, function (methodPy) {
              Sk.ffi.checkMethodArgs(METHOD_NORMALIZE, arguments, 0, 0);
              args[PROP_RADIUS] = Math.pow(3 / (4 * Math.PI), 1 / 3);
              return selfPy;
            });
          }
        default: {
            return builderGetAttr(selfPy, name, SPHERE_BUILDER);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        return Sk.ffi.stringToPy('' + self);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffi.stringToPy(SPHERE_BUILDER + '(' + ')');
      });
    }, SPHERE_BUILDER, []);
    mod[Sk.geometry.VOLUME_BUILDER] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy) {
        Sk.ffi.checkMethodArgs(Sk.geometry.VOLUME_BUILDER, arguments, 0, 0);
        Sk.ffi.referenceToPy({}, Sk.geometry.VOLUME_BUILDER, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var args = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case PROP_RADIUS: {
            return Sk.ffi.callableToPy(mod, PROP_RADIUS, function (methodPy, radiusPy) {
              Sk.ffi.checkMethodArgs(PROP_RADIUS, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_RADIUS, [
                NUMBER,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(radiusPy) || Sk.ffi.isNone(radiusPy), radiusPy);
              args[PROP_RADIUS] = Sk.ffi.remapToJs(radiusPy);
              return selfPy;
            });
          }
        case PROP_SEGMENTS: {
            return Sk.ffi.callableToPy(mod, PROP_SEGMENTS, function (methodPy, segmentsPy) {
              Sk.ffi.checkMethodArgs(PROP_SEGMENTS, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_SEGMENTS, [
                Sk.ffi.PyType.INT,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isInt(segmentsPy) || Sk.ffi.isNone(segmentsPy), segmentsPy);
              args[PROP_SEGMENTS] = Sk.ffi.remapToJs(segmentsPy);
              return selfPy;
            });
          }
        case METHOD_BUILD: {
            return Sk.ffi.callableToPy(mod, METHOD_BUILD, function (methodPy) {
              function dimensionPlane() {
                var dims = {};
                if (args[PROP_VOLUME]) {
                  var w = args.radius ? args.radius : DEFAULT_CUBE_LENGTH;
                  var h = args.height ? args.height : DEFAULT_CUBE_LENGTH;
                  var alpha = Math.pow(args[PROP_VOLUME] / (w * h), 1 / 2);
                  dims.width = alpha * w;
                  dims.height = alpha * h;
                } else {
                  dims.radius = args.radius ? args.radius : DEFAULT_CUBE_LENGTH;
                  dims.height = args.height ? args.height : DEFAULT_CUBE_LENGTH;
                }
                return dims;
              }
              Sk.ffi.checkMethodArgs(METHOD_BUILD, arguments, 0, 0);
              var dimensions = dimensionPlane();
              var radius = Sk.ffi.numberToFloatPy(dimensions[PROP_RADIUS]);
              var radiusCone = Sk.ffi.numberToFloatPy(0.08);
              var radiusShaft = Sk.ffi.numberToFloatPy(0.01);
              var lengthCone = Sk.ffi.numberToFloatPy(0.2);
              var lengthShaft = Sk.ffi.numberToFloatPy(0.8);
              var arrows = Sk.ffi.numberToIntPy(6);
              var segments = Sk.ffi.numberToIntPy(args[PROP_SEGMENTS] ? args[PROP_SEGMENTS] : 32);
              return Sk.ffi.callsim(mod[Sk.geometry.VOLUME], createMaterialPy(args));
            });
          }
        case METHOD_NORMALIZE: {
            return Sk.ffi.callableToPy(mod, METHOD_NORMALIZE, function (methodPy) {
              Sk.ffi.checkMethodArgs(METHOD_NORMALIZE, arguments, 0, 0);
              args[PROP_RADIUS] = Math.sqrt(1 / Math.PI);
              return selfPy;
            });
          }
        default: {
            return builderGetAttr(selfPy, name, Sk.geometry.VOLUME_BUILDER);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        return Sk.ffi.stringToPy('' + self);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffi.stringToPy(Sk.geometry.VOLUME_BUILDER + '(' + ')');
      });
    }, Sk.geometry.VOLUME_BUILDER, []);
    mod[Sk.geometry.VOLUME] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, materialPy) {
        Sk.ffi.checkMethodArgs(Sk.geometry.VOLUME, arguments, 1, 1);
        var composite = new THREE[Sk.three.OBJECT_3D]();
        var cylinder;
        var arrow;
        var cb = new Sk.geometry.CylinderBuilder();
        cb.radius(0.01).material(Sk.ffi.remapToJs(materialPy));
        cb.axis(1, 0, 0);
        cylinder = cb.build();
        cylinder.position.set(+0, +0.5, +0.5);
        composite.add(cylinder);
        cylinder = cb.build();
        cylinder.position.set(+0, +0.5, -0.5);
        cylinder.name = 'c1';
        composite.add(cylinder);
        cylinder = cb.build();
        cylinder.position.set(+0, -0.5, +0.5);
        composite.add(cylinder);
        cb.axis(0, 1, 0);
        cylinder = cb.build();
        cylinder.position.set(+0.5, +0, +0.5);
        composite.add(cylinder);
        cylinder = cb.build();
        cylinder.position.set(-0.5, +0, +0.5);
        composite.add(cylinder);
        cylinder = cb.build();
        cylinder.position.set(-0.5, +0, -0.5);
        cylinder.name = 'c2';
        composite.add(cylinder);
        cb.axis(0, 0, 1);
        cylinder = cb.build();
        cylinder.position.set(+0.5, -0.5, +0);
        composite.add(cylinder);
        cylinder = cb.build();
        cylinder.position.set(-0.5, +0.5, +0);
        composite.add(cylinder);
        cylinder = cb.build();
        cylinder.position.set(-0.5, -0.5, +0);
        composite.add(cylinder);
        var ab = new Sk.geometry.ArrowBuilder();
        ab.radius(0.01).material(Sk.ffi.remapToJs(materialPy));
        ab.axis(1, 0, 0);
        arrow = ab.build();
        arrow.name = 'e1';
        arrow.position.set(+0, -0.5, -0.5);
        composite.add(arrow);
        ab.axis(0, 1, 0);
        arrow = ab.build();
        arrow.name = 'e2';
        arrow.position.set(+0.5, +0, -0.5);
        composite.add(arrow);
        ab.axis(0, 0, 1);
        arrow = ab.build();
        arrow.position.set(+0.5, +0.5, +0);
        composite.add(arrow);
        Sk.ffi.referenceToPy(composite, Sk.geometry.VOLUME, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var composite = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        default: {
            return Sk.three.object3DGetAttr(Sk.geometry.VOLUME, selfPy, name);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        var composite = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case PROP_ORIENTATION: {
            Sk.ffi.checkArgType(name, Sk.ffi.PyType.BOOL, Sk.ffi.isBool(valuePy), valuePy);
            var orientation = Sk.ffi.remapToJs(valuePy);
            var e1 = composite.getObjectByName('e1');
            var c1 = composite.getObjectByName('c1');
            var e2 = composite.getObjectByName('e2');
            var c2 = composite.getObjectByName('c2');
            if (orientation) {
              e1.position.set(+0, -0.5, -0.5);
              c1.position.set(+0, +0.5, -0.5);
              e2.position.set(+0.5, +0, -0.5);
              c2.position.set(-0.5, +0, -0.5);
            } else {
              e1.position.set(+0, +0.5, -0.5);
              c1.position.set(+0, -0.5, -0.5);
              e2.position.set(-0.5, +0, -0.5);
              c2.position.set(+0.5, +0, -0.5);
            }
          }
          break;
        default: {
            return Sk.three.object3DSetAttr(Sk.geometry.VOLUME, selfPy, name, valuePy);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var names = [];
        var args = names.map(function (name) {
            return [
              name,
              Sk.ffi.remapToJs(Sk.ffh.str(Sk.ffi.gattr(selfPy, name)))
            ].join(EQUAL);
          });
        return Sk.ffi.stringToPy(Sk.geometry.VOLUME + LPAREN + args.join(COMMA + SPACE) + RPAREN);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var names = [];
        var argsPy = names.map(function (name) {
            return Sk.ffi.gattr(selfPy, name);
          });
        var args = argsPy.map(function (valuePy) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(valuePy));
          });
        return Sk.ffi.stringToPy(Sk.geometry.VOLUME + LPAREN + args.join(COMMA + SPACE) + RPAREN);
      });
    }, Sk.geometry.VOLUME, []);
    mod[Sk.geometry.VORTEX_BUILDER] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy) {
        Sk.ffi.checkMethodArgs(Sk.geometry.VORTEX_BUILDER, arguments, 0, 0);
        Sk.ffi.referenceToPy({}, Sk.geometry.VORTEX_BUILDER, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var args = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case PROP_RADIUS: {
            return Sk.ffi.callableToPy(mod, PROP_RADIUS, function (methodPy, radiusPy) {
              Sk.ffi.checkMethodArgs(PROP_RADIUS, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_RADIUS, [
                NUMBER,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isNum(radiusPy) || Sk.ffi.isNone(radiusPy), radiusPy);
              args[PROP_RADIUS] = Sk.ffi.remapToJs(radiusPy);
              return selfPy;
            });
          }
        case PROP_SEGMENTS: {
            return Sk.ffi.callableToPy(mod, PROP_SEGMENTS, function (methodPy, segmentsPy) {
              Sk.ffi.checkMethodArgs(PROP_SEGMENTS, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_SEGMENTS, [
                Sk.ffi.PyType.INT,
                Sk.ffi.PyType.NONE
              ], Sk.ffi.isInt(segmentsPy) || Sk.ffi.isNone(segmentsPy), segmentsPy);
              args[PROP_SEGMENTS] = Sk.ffi.remapToJs(segmentsPy);
              return selfPy;
            });
          }
        case METHOD_BUILD: {
            return Sk.ffi.callableToPy(mod, METHOD_BUILD, function (methodPy) {
              function dimensionPlane() {
                var dims = {};
                if (args[PROP_VOLUME]) {
                  var w = args.radius ? args.radius : DEFAULT_CUBE_LENGTH;
                  var h = args.height ? args.height : DEFAULT_CUBE_LENGTH;
                  var alpha = Math.pow(args[PROP_VOLUME] / (w * h), 1 / 2);
                  dims.width = alpha * w;
                  dims.height = alpha * h;
                } else {
                  dims.radius = args.radius ? args.radius : DEFAULT_CUBE_LENGTH;
                  dims.height = args.height ? args.height : DEFAULT_CUBE_LENGTH;
                }
                return dims;
              }
              Sk.ffi.checkMethodArgs(METHOD_BUILD, arguments, 0, 0);
              var dimensions = dimensionPlane();
              var radius = Sk.ffi.numberToFloatPy(dimensions[PROP_RADIUS]);
              var radiusCone = Sk.ffi.numberToFloatPy(0.08);
              var radiusShaft = Sk.ffi.numberToFloatPy(0.01);
              var lengthCone = Sk.ffi.numberToFloatPy(0.2);
              var lengthShaft = Sk.ffi.numberToFloatPy(0.8);
              var arrows = Sk.ffi.numberToIntPy(6);
              var segments = Sk.ffi.numberToIntPy(args[PROP_SEGMENTS] ? args[PROP_SEGMENTS] : 32);
              var geometryPy = Sk.ffi.callsim(mod[Sk.three.VORTEX_GEOMETRY], radius, radiusCone, radiusShaft, lengthCone, lengthShaft, arrows, segments);
              return completeMesh(geometryPy, args);
            });
          }
        case METHOD_NORMALIZE: {
            return Sk.ffi.callableToPy(mod, METHOD_NORMALIZE, function (methodPy) {
              Sk.ffi.checkMethodArgs(METHOD_NORMALIZE, arguments, 0, 0);
              args[PROP_RADIUS] = Math.sqrt(1 / Math.PI);
              return selfPy;
            });
          }
        default: {
            return builderGetAttr(selfPy, name, Sk.geometry.VORTEX_BUILDER);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        return Sk.ffi.stringToPy('' + self);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffi.stringToPy(Sk.geometry.VORTEX_BUILDER + '(' + ')');
      });
    }, Sk.geometry.VORTEX_BUILDER, []);
  };
}.call(this));
(function () {
  Sk.builtin.defineHttp = function (mod) {
    Sk.ffi.checkFunctionArgs('defineHttp', arguments, 1, 1);
    var XML_HTTP_REQUEST = 'XMLHttpRequest';
    var METHOD_OPEN = 'open';
    var METHOD_SEND = 'send';
    var PROP_ONLOAD = 'onload';
    var PROP_RESPONSE_TYPE = 'responseType';
    mod[XML_HTTP_REQUEST] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy) {
        var requestJs = new XMLHttpRequest();
        Sk.ffi.referenceToPy(requestJs, XML_HTTP_REQUEST, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var requestJs = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case METHOD_OPEN: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (mPy) {
                Sk.ffi.referenceToPy(null, METHOD_OPEN, null, mPy);
              });
              $loc.__call__ = Sk.ffi.functionPy(function (mPy, methodPy, urlPy, asyncPy, userPy, passwordPy) {
                Sk.ffi.checkMethodArgs(METHOD_OPEN, arguments, 2, 5);
                Sk.ffi.checkArgType('method', [Sk.ffi.PyType.STR], Sk.ffi.isStr(methodPy), methodPy);
                Sk.ffi.checkArgType('url', [Sk.ffi.PyType.STR], Sk.ffi.isStr(urlPy), urlPy);
                Sk.ffi.checkArgType('async', [Sk.ffi.PyType.BOOL], Sk.ffi.isBool(asyncPy), asyncPy);
                var method = Sk.ffi.remapToJs(methodPy);
                var url = Sk.ffi.remapToJs(urlPy);
                var async = Sk.ffi.remapToJs(asyncPy);
                requestJs.open(method, url, async);
              });
            }, METHOD_OPEN, []));
          }
        case METHOD_SEND: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (mPy) {
                Sk.ffi.referenceToPy(null, METHOD_SEND, null, mPy);
              });
              $loc.__call__ = Sk.ffi.functionPy(function (mPy, dataPy) {
                Sk.ffi.checkMethodArgs(METHOD_SEND, arguments, 0, 1);
                requestJs.send();
              });
            }, METHOD_SEND, []));
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(XML_HTTP_REQUEST);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        var requestJs = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case PROP_ONLOAD: {
            Sk.ffi.checkArgType(name, [Sk.ffi.PyType.FUNCTION], Sk.ffi.isFunction(valuePy), valuePy);
            requestJs.onload = Sk.ffi.remapToJs(valuePy);
          }
          break;
        case PROP_RESPONSE_TYPE: {
            Sk.ffi.checkArgType(name, [Sk.ffi.PyType.STR], Sk.ffi.isStr(valuePy), valuePy);
            requestJs.responseType = Sk.ffi.remapToJs(valuePy);
          }
          break;
        default: {
            throw Sk.ffi.err.attribute(name).isNotSetableOnType(XML_HTTP_REQUEST);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var selfJs = Sk.ffi.remapToJs(selfPy);
        return Sk.ffi.stringToPy(XML_HTTP_REQUEST);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var selfJs = Sk.ffi.remapToJs(selfPy);
        return Sk.ffi.stringToPy(XML_HTTP_REQUEST + '()');
      });
    }, XML_HTTP_REQUEST, []);
  };
}.call(this));
(function () {
  Sk.builtin.defineNode = function (mod) {
    Sk.ffi.checkFunctionArgs('defineNode', arguments, 1, 1);
    var NODE = 'Node';
    var CANVAS_GRADIENT_CLASS = 'CanvasGradient';
    var CANVAS_RENDERING_CONTEXT_2D = 'CanvasRenderingContext2D';
    var PROP_CLIENT_HEIGHT = 'clientHeight';
    var PROP_CLIENT_WIDTH = 'clientWidth';
    var PROP_DIR = 'dir';
    var PROP_FILL_STYLE = 'fillStyle';
    var PROP_FIRST_CHILD = 'firstChild';
    var PROP_FONT = 'font';
    var PROP_HEIGHT = 'height';
    var PROP_INNER_HTML = 'innerHTML';
    var PROP_LAST_CHILD = 'lastChild';
    var PROP_LEFT = 'left';
    var PROP_LINE_CAP = 'lineCap';
    var PROP_LINE_JOIN = 'lineJoin';
    var PROP_LINE_WIDTH = 'lineWidth';
    var PROP_NEXT_SIBLING = 'nextSibling';
    var PROP_OFFSET_HEIGHT = 'offsetHeight';
    var PROP_OFFSET_WIDTH = 'offsetWidth';
    var PROP_PARENT_NODE = 'parentNode';
    var PROP_POSITION = 'position';
    var PROP_PREVIOUS_SIBLING = 'previousSibling';
    var PROP_SHADOW_BLUR = 'shadowBlur';
    var PROP_SHADOW_COLOR = 'shadowColor';
    var PROP_SHADOW_OFFSET_X = 'shadowOffsetX';
    var PROP_SHADOW_OFFSET_Y = 'shadowOffsetY';
    var PROP_STYLE = 'style';
    var PROP_STROKE_STYLE = 'strokeStyle';
    var PROP_TEXT_ALIGN = 'textAlign';
    var PROP_TEXT_BASELINE = 'textBaseline';
    var PROP_TOP = 'top';
    var PROP_WEBKIT_BACKING_STORE_PIXEL_RATIO = 'webkitBackingStorePixelRatio';
    var PROP_WIDTH = 'width';
    var METHOD_ADD_COLOR_STOP = 'addColorStop';
    var METHOD_APPEND_CHILD = 'appendChild';
    var METHOD_ARC = 'arc';
    var METHOD_ARC_TO = 'arcTo';
    var METHOD_BEGIN_PATH = 'beginPath';
    var METHOD_BEZIER_CURVE_TO = 'bezierCurveTo';
    var METHOD_CLEAR_RECT = 'clearRect';
    var METHOD_CLIP = 'clip';
    var METHOD_CLOSE_PATH = 'closePath';
    var METHOD_CREATE_LINEAR_GRADIENT = 'createLinearGradient';
    var METHOD_FILL = 'fill';
    var METHOD_FILL_RECT = 'fillRect';
    var METHOD_FILL_TEXT = 'fillText';
    var METHOD_GET_CONTEXT = 'getContext';
    var METHOD_INSERT_BEFORE = 'insertBefore';
    var METHOD_LINE_TO = 'lineTo';
    var METHOD_MOVE_TO = 'moveTo';
    var METHOD_QUADRATIC_CURVE_TO = 'quadraticCurveTo';
    var METHOD_RECT = 'rect';
    var METHOD_REMOVE_CHILD = 'removeChild';
    var METHOD_RESTORE = 'restore';
    var METHOD_ROTATE = 'rotate';
    var METHOD_SAVE = 'save';
    var METHOD_SCALE = 'scale';
    var METHOD_SET_ATTRIBUTE = 'setAttribute';
    var METHOD_SET_TRANSFORM = 'setTransform';
    var METHOD_STROKE = 'stroke';
    var METHOD_STROKE_RECT = 'strokeRect';
    var METHOD_STROKE_TEXT = 'strokeText';
    var METHOD_TRANSFORM = 'transform';
    var METHOD_TRANSLATE = 'translate';
    var ARG_CHILD = 'child';
    var ARG_NAME = 'name';
    var nodeToPy = function (node) {
      if (node) {
        return Sk.ffi.callsim(mod[NODE], Sk.ffi.referenceToPy(node, NODE));
      } else {
        return Sk.ffi.none.None;
      }
    };
    mod[NODE] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, nodePy) {
        Sk.ffi.checkMethodArgs(NODE, arguments, 1, 1);
        Sk.ffi.checkArgType('node', NODE, Sk.ffi.isInstance(nodePy, NODE), nodePy);
        Sk.ffi.referenceToPy(Sk.ffi.remapToJs(nodePy), NODE, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (nodePy, name) {
        var node = Sk.ffi.remapToJs(nodePy);
        switch (name) {
        case PROP_CLIENT_HEIGHT: {
            return Sk.ffi.numberToFloatPy(node[PROP_CLIENT_HEIGHT]);
          }
        case PROP_CLIENT_WIDTH: {
            return Sk.ffi.numberToFloatPy(node[PROP_CLIENT_WIDTH]);
          }
        case PROP_DIR: {
            return Sk.ffi.stringToPy(node[PROP_DIR]);
          }
        case PROP_FIRST_CHILD: {
            return nodeToPy(node[PROP_FIRST_CHILD]);
          }
        case PROP_LAST_CHILD: {
            return nodeToPy(node[PROP_LAST_CHILD]);
          }
        case PROP_NEXT_SIBLING: {
            return nodeToPy(node[PROP_NEXT_SIBLING]);
          }
        case PROP_OFFSET_HEIGHT: {
            return Sk.ffi.numberToIntPy(node[PROP_OFFSET_HEIGHT]);
          }
        case PROP_OFFSET_WIDTH: {
            return Sk.ffi.numberToIntPy(node[PROP_OFFSET_WIDTH]);
          }
        case PROP_PARENT_NODE: {
            return nodeToPy(node[PROP_PARENT_NODE]);
          }
        case PROP_PREVIOUS_SIBLING: {
            return nodeToPy(node[PROP_PREVIOUS_SIBLING]);
          }
        case PROP_HEIGHT: {
            return Sk.builtin.assk$(node[PROP_HEIGHT], Sk.builtin.nmber.int$);
          }
        case PROP_WIDTH: {
            return Sk.builtin.assk$(node[PROP_WIDTH], Sk.builtin.nmber.int$);
          }
        case PROP_STYLE: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (self) {
                self.tp$name = PROP_STYLE;
                self.v = node.style;
              });
              $loc.__getattr__ = Sk.ffi.functionPy(function (stylePy, name) {
                var style = Sk.ffi.remapToJs(stylePy);
                switch (name) {
                case PROP_HEIGHT: {
                    return Sk.ffi.stringToPy(style[PROP_HEIGHT]);
                  }
                case PROP_LEFT: {
                    return Sk.ffi.stringToPy(style[PROP_LEFT]);
                  }
                case PROP_POSITION: {
                    return Sk.ffi.stringToPy(style[PROP_POSITION]);
                  }
                case PROP_TOP: {
                    return Sk.ffi.stringToPy(style[PROP_TOP]);
                  }
                case PROP_WIDTH: {
                    return Sk.ffi.stringToPy(style[PROP_WIDTH]);
                  }
                }
              });
              $loc.__setattr__ = Sk.ffi.functionPy(function (stylePy, name, valuePy) {
                var style = Sk.ffi.remapToJs(stylePy);
                var value = Sk.ffi.remapToJs(valuePy);
                switch (name) {
                case PROP_HEIGHT: {
                    style[PROP_HEIGHT] = value;
                  }
                  break;
                case PROP_LEFT: {
                    style[PROP_LEFT] = value;
                  }
                  break;
                case PROP_POSITION: {
                    style[PROP_POSITION] = value;
                  }
                  break;
                case PROP_TOP: {
                    style[PROP_TOP] = value;
                  }
                  break;
                case PROP_WIDTH: {
                    style[PROP_WIDTH] = value;
                  }
                  break;
                default: {
                    throw new Sk.builtin.AssertionError(name + ' is not a writeable attribute of ' + PROP_STYLE);
                  }
                }
              });
              $loc.__str__ = Sk.ffi.functionPy(function (self) {
                return Sk.ffi.stringToPy(PROP_STYLE);
              });
              $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                return Sk.ffi.stringToPy(PROP_STYLE);
              });
            }, PROP_STYLE, []));
          }
        case METHOD_APPEND_CHILD: {
            return Sk.ffi.callableToPy(mod, METHOD_APPEND_CHILD, function (methodPy, childNodePy) {
              Sk.ffi.checkMethodArgs(METHOD_APPEND_CHILD, arguments, 1, 1);
              Sk.ffi.checkArgType(ARG_CHILD, NODE, Sk.ffi.isInstance(childNodePy, NODE), childNodePy);
              var childNode = Sk.ffi.remapToJs(childNodePy);
              return nodeToPy(node.appendChild(childNode));
            });
          }
        case METHOD_GET_CONTEXT: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (self) {
                self.tp$name = METHOD_GET_CONTEXT;
              });
              $loc.__call__ = Sk.ffi.functionPy(function (self, contextIdPy, contextAttributePy) {
                var contextId = Sk.ffi.remapToJs(contextIdPy);
                var contextAttribute = Sk.ffi.remapToJs(contextAttributePy);
                var context = node.getContext(contextId, contextAttribute);
                return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
                  $loc.__init__ = Sk.ffi.functionPy(function (self) {
                    self.tp$name = CANVAS_RENDERING_CONTEXT_2D;
                    self.v = context;
                  });
                  $loc.__getattr__ = Sk.ffi.functionPy(function (contextPy, name) {
                    switch (name) {
                    case PROP_FILL_STYLE: {
                        return Sk.ffi.stringToPy(context[PROP_FILL_STYLE]);
                      }
                    case PROP_FONT: {
                        return Sk.ffi.stringToPy(context[PROP_FONT]);
                      }
                    case PROP_LINE_CAP: {
                        return Sk.ffi.stringToPy(context[PROP_LINE_CAP]);
                      }
                    case PROP_LINE_JOIN: {
                        return Sk.ffi.stringToPy(context[PROP_LINE_JOIN]);
                      }
                    case PROP_LINE_WIDTH: {
                        return Sk.builtin.assk$(context[PROP_LINE_WIDTH], Sk.builtin.nmber.int$);
                      }
                    case PROP_SHADOW_BLUR: {
                        return Sk.builtin.assk$(context[PROP_SHADOW_BLUR], Sk.builtin.nmber.int$);
                      }
                    case PROP_SHADOW_COLOR: {
                        return Sk.ffi.stringToPy(context[PROP_SHADOW_COLOR]);
                      }
                    case PROP_SHADOW_OFFSET_X: {
                        return Sk.builtin.assk$(context[PROP_SHADOW_OFFSET_X], Sk.builtin.nmber.int$);
                      }
                    case PROP_SHADOW_OFFSET_Y: {
                        return Sk.builtin.assk$(context[PROP_SHADOW_OFFSET_Y], Sk.builtin.nmber.int$);
                      }
                    case PROP_STROKE_STYLE: {
                        return Sk.ffi.stringToPy(context[PROP_STROKE_STYLE]);
                      }
                    case PROP_TEXT_ALIGN: {
                        return Sk.ffi.stringToPy(context[PROP_TEXT_ALIGN]);
                      }
                    case PROP_TEXT_BASELINE: {
                        return Sk.ffi.stringToPy(context[PROP_TEXT_BASELINE]);
                      }
                    case PROP_WEBKIT_BACKING_STORE_PIXEL_RATIO: {
                        return Sk.builtin.assk$(context[PROP_WEBKIT_BACKING_STORE_PIXEL_RATIO], Sk.builtin.nmber.int$);
                      }
                    case METHOD_ARC: {
                        return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
                          $loc.__init__ = Sk.ffi.functionPy(function (self) {
                            self.tp$name = METHOD_ARC;
                          });
                          $loc.__call__ = Sk.ffi.functionPy(function (self, x, y, radius, startAngle, endAngle, anticlockwise) {
                            x = Sk.ffi.remapToJs(x);
                            y = Sk.ffi.remapToJs(y);
                            radius = Sk.ffi.remapToJs(radius);
                            startAngle = Sk.ffi.remapToJs(startAngle);
                            endAngle = Sk.ffi.remapToJs(endAngle);
                            anticlockwise = Sk.ffi.remapToJs(anticlockwise);
                            context[METHOD_ARC](x, y, radius, startAngle, endAngle, anticlockwise);
                          });
                          $loc.__str__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_ARC);
                          });
                          $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_ARC);
                          });
                        }, METHOD_ARC, []));
                      }
                    case METHOD_ARC_TO: {
                        return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
                          $loc.__init__ = Sk.ffi.functionPy(function (self) {
                            self.tp$name = METHOD_ARC_TO;
                          });
                          $loc.__call__ = Sk.ffi.functionPy(function (self, x1, y1, x2, y2, radiusX, radiusY, rotation) {
                            x1 = Sk.ffi.remapToJs(x1);
                            y1 = Sk.ffi.remapToJs(y1);
                            x2 = Sk.ffi.remapToJs(x2);
                            y2 = Sk.ffi.remapToJs(y2);
                            radiusX = Sk.ffi.remapToJs(radiusX);
                            radiusY = Sk.ffi.remapToJs(radiusY);
                            rotation = Sk.ffi.remapToJs(rotation);
                            context[METHOD_ARC_TO](x1, y1, x2, y2, radiusX, radiusY, rotation);
                          });
                          $loc.__str__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_ARC_TO);
                          });
                          $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_ARC_TO);
                          });
                        }, METHOD_ARC_TO, []));
                      }
                    case METHOD_BEGIN_PATH: {
                        return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
                          $loc.__init__ = Sk.ffi.functionPy(function (self) {
                            self.tp$name = METHOD_BEGIN_PATH;
                          });
                          $loc.__call__ = Sk.ffi.functionPy(function (self) {
                            context[METHOD_BEGIN_PATH]();
                          });
                          $loc.__str__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_BEGIN_PATH);
                          });
                          $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_BEGIN_PATH);
                          });
                        }, METHOD_BEGIN_PATH, []));
                      }
                    case METHOD_BEZIER_CURVE_TO: {
                        return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
                          $loc.__init__ = Sk.ffi.functionPy(function (self) {
                            self.tp$name = METHOD_BEZIER_CURVE_TO;
                          });
                          $loc.__call__ = Sk.ffi.functionPy(function (self, cp1x, cp1y, cp2x, cp2y, x, y) {
                            cp1x = Sk.ffi.remapToJs(cp1x);
                            cp1y = Sk.ffi.remapToJs(cp1y);
                            cp2x = Sk.ffi.remapToJs(cp2x);
                            cp2y = Sk.ffi.remapToJs(cp2y);
                            x = Sk.ffi.remapToJs(x);
                            y = Sk.ffi.remapToJs(y);
                            context[METHOD_BEZIER_CURVE_TO](cp1x, cp1y, cp2x, cp2y, x, y);
                          });
                          $loc.__str__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_BEZIER_CURVE_TO);
                          });
                          $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_BEZIER_CURVE_TO);
                          });
                        }, METHOD_BEZIER_CURVE_TO, []));
                      }
                    case METHOD_CLEAR_RECT: {
                        return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
                          $loc.__init__ = Sk.ffi.functionPy(function (self) {
                            self.tp$name = METHOD_CLEAR_RECT;
                          });
                          $loc.__call__ = Sk.ffi.functionPy(function (self, x, y, w, h) {
                            x = Sk.ffi.remapToJs(x);
                            y = Sk.ffi.remapToJs(y);
                            w = Sk.ffi.remapToJs(w);
                            h = Sk.ffi.remapToJs(h);
                            context[METHOD_CLEAR_RECT](x, y, w, h);
                          });
                          $loc.__str__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_CLEAR_RECT);
                          });
                          $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_CLEAR_RECT);
                          });
                        }, METHOD_CLEAR_RECT, []));
                      }
                    case METHOD_CLIP: {
                        return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
                          $loc.__init__ = Sk.ffi.functionPy(function (self) {
                            self.tp$name = METHOD_CLIP;
                          });
                          $loc.__call__ = Sk.ffi.functionPy(function (self) {
                            context[METHOD_CLIP]();
                          });
                          $loc.__str__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_CLIP);
                          });
                          $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_CLIP);
                          });
                        }, METHOD_CLIP, []));
                      }
                    case METHOD_CLOSE_PATH: {
                        return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
                          $loc.__init__ = Sk.ffi.functionPy(function (self) {
                            self.tp$name = METHOD_CLOSE_PATH;
                          });
                          $loc.__call__ = Sk.ffi.functionPy(function (self) {
                            context[METHOD_CLOSE_PATH]();
                          });
                          $loc.__str__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_CLOSE_PATH);
                          });
                          $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_CLOSE_PATH);
                          });
                        }, METHOD_CLOSE_PATH, []));
                      }
                    case METHOD_CREATE_LINEAR_GRADIENT: {
                        return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
                          $loc.__init__ = Sk.ffi.functionPy(function (self) {
                            self.tp$name = METHOD_CREATE_LINEAR_GRADIENT;
                          });
                          $loc.__call__ = Sk.ffi.functionPy(function (self, x0, y0, x1, y1) {
                            x0 = Sk.ffi.remapToJs(x0);
                            y0 = Sk.ffi.remapToJs(y0);
                            x1 = Sk.ffi.remapToJs(x1);
                            y1 = Sk.ffi.remapToJs(y1);
                            var gradient = context[METHOD_CREATE_LINEAR_GRADIENT](x0, y0, x1, y1);
                            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
                              $loc.__init__ = Sk.ffi.functionPy(function (self) {
                                self.tp$name = CANVAS_GRADIENT_CLASS;
                                self.v = gradient;
                              });
                              $loc.__getattr__ = Sk.ffi.functionPy(function (gradientPy, name) {
                                switch (name) {
                                case METHOD_ADD_COLOR_STOP: {
                                    return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
                                      $loc.__init__ = Sk.ffi.functionPy(function (self) {
                                        self.tp$name = METHOD_ADD_COLOR_STOP;
                                      });
                                      $loc.__call__ = Sk.ffi.functionPy(function (self, offset, color) {
                                        offset = Sk.ffi.remapToJs(offset);
                                        color = Sk.ffi.remapToJs(color);
                                        gradient[METHOD_ADD_COLOR_STOP](offset, color);
                                      });
                                      $loc.__str__ = Sk.ffi.functionPy(function (self) {
                                        return Sk.ffi.stringToPy(METHOD_ADD_COLOR_STOP);
                                      });
                                      $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                                        return Sk.ffi.stringToPy(METHOD_ADD_COLOR_STOP);
                                      });
                                    }, METHOD_ADD_COLOR_STOP, []));
                                  }
                                }
                              });
                              $loc.__setattr__ = Sk.ffi.functionPy(function (gradientPy, name, valuePy) {
                                var value = Sk.ffi.remapToJs(valuePy);
                                switch (name) {
                                default: {
                                    throw new Sk.builtin.AssertionError(name + ' is not a writeable attribute of ' + CANVAS_GRADIENT_CLASS);
                                  }
                                }
                              });
                              $loc.__str__ = Sk.ffi.functionPy(function (self) {
                                return Sk.ffi.stringToPy(CANVAS_GRADIENT_CLASS);
                              });
                              $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                                return Sk.ffi.stringToPy(CANVAS_GRADIENT_CLASS);
                              });
                            }, CANVAS_GRADIENT_CLASS, []));
                          });
                          $loc.__str__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_CREATE_LINEAR_GRADIENT);
                          });
                          $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_CREATE_LINEAR_GRADIENT);
                          });
                        }, METHOD_CREATE_LINEAR_GRADIENT, []));
                      }
                    case METHOD_FILL: {
                        return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
                          $loc.__init__ = Sk.ffi.functionPy(function (self) {
                            self.tp$name = METHOD_FILL;
                          });
                          $loc.__call__ = Sk.ffi.functionPy(function (self) {
                            context[METHOD_FILL]();
                          });
                          $loc.__str__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_FILL);
                          });
                          $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_FILL);
                          });
                        }, METHOD_FILL, []));
                      }
                    case METHOD_FILL_RECT: {
                        return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
                          $loc.__init__ = Sk.ffi.functionPy(function (self) {
                            self.tp$name = METHOD_FILL_RECT;
                          });
                          $loc.__call__ = Sk.ffi.functionPy(function (self, x, y, w, h) {
                            x = Sk.ffi.remapToJs(x);
                            y = Sk.ffi.remapToJs(y);
                            w = Sk.ffi.remapToJs(w);
                            h = Sk.ffi.remapToJs(h);
                            context[METHOD_FILL_RECT](x, y, w, h);
                          });
                          $loc.__str__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_FILL_RECT);
                          });
                          $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_FILL_RECT);
                          });
                        }, METHOD_FILL_RECT, []));
                      }
                    case METHOD_FILL_TEXT: {
                        return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
                          $loc.__init__ = Sk.ffi.functionPy(function (self) {
                            self.tp$name = METHOD_FILL_TEXT;
                          });
                          $loc.__call__ = Sk.ffi.functionPy(function (self, text, x, y, maxWidthPy) {
                            text = Sk.ffi.remapToJs(text);
                            x = Sk.ffi.remapToJs(x);
                            y = Sk.ffi.remapToJs(y);
                            var maxWidth = Sk.ffi.remapToJs(maxWidthPy);
                            if (typeof maxWidth === 'undefined') {
                              context[METHOD_FILL_TEXT](text, x, y);
                            } else if (typeof maxWidth === 'number') {
                              context[METHOD_FILL_TEXT](text, x, y, maxWidth);
                            } else {
                              throw new Sk.builtin.TypeError('maxWidth');
                            }
                          });
                          $loc.__str__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_FILL_TEXT);
                          });
                          $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_FILL_TEXT);
                          });
                        }, METHOD_FILL_TEXT, []));
                      }
                    case METHOD_LINE_TO: {
                        return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
                          $loc.__init__ = Sk.ffi.functionPy(function (self) {
                            self.tp$name = METHOD_LINE_TO;
                          });
                          $loc.__call__ = Sk.ffi.functionPy(function (self, x, y) {
                            x = Sk.ffi.remapToJs(x);
                            y = Sk.ffi.remapToJs(y);
                            context[METHOD_LINE_TO](x, y);
                          });
                          $loc.__str__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_LINE_TO);
                          });
                          $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_LINE_TO);
                          });
                        }, METHOD_LINE_TO, []));
                      }
                    case METHOD_MOVE_TO: {
                        return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
                          $loc.__init__ = Sk.ffi.functionPy(function (self) {
                            self.tp$name = METHOD_MOVE_TO;
                          });
                          $loc.__call__ = Sk.ffi.functionPy(function (self, x, y) {
                            x = Sk.ffi.remapToJs(x);
                            y = Sk.ffi.remapToJs(y);
                            context[METHOD_MOVE_TO](x, y);
                          });
                          $loc.__str__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_MOVE_TO);
                          });
                          $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_MOVE_TO);
                          });
                        }, METHOD_MOVE_TO, []));
                      }
                    case METHOD_QUADRATIC_CURVE_TO: {
                        return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
                          $loc.__init__ = Sk.ffi.functionPy(function (self) {
                            self.tp$name = METHOD_QUADRATIC_CURVE_TO;
                          });
                          $loc.__call__ = Sk.ffi.functionPy(function (self, cpx, cpy, x, y) {
                            cpx = Sk.ffi.remapToJs(cpx);
                            cpy = Sk.ffi.remapToJs(cpy);
                            x = Sk.ffi.remapToJs(x);
                            y = Sk.ffi.remapToJs(y);
                            context[METHOD_QUADRATIC_CURVE_TO](cpx, cpy, x, y);
                          });
                          $loc.__str__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_QUADRATIC_CURVE_TO);
                          });
                          $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_QUADRATIC_CURVE_TO);
                          });
                        }, METHOD_QUADRATIC_CURVE_TO, []));
                      }
                    case METHOD_RECT: {
                        return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
                          $loc.__init__ = Sk.ffi.functionPy(function (self) {
                            self.tp$name = METHOD_RECT;
                          });
                          $loc.__call__ = Sk.ffi.functionPy(function (self, x, y, w, h) {
                            x = Sk.ffi.remapToJs(x);
                            y = Sk.ffi.remapToJs(y);
                            w = Sk.ffi.remapToJs(w);
                            h = Sk.ffi.remapToJs(h);
                            context[METHOD_RECT](x, y, w, h);
                          });
                          $loc.__str__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_RECT);
                          });
                          $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_RECT);
                          });
                        }, METHOD_RECT, []));
                      }
                    case METHOD_RESTORE: {
                        return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
                          $loc.__init__ = Sk.ffi.functionPy(function (self) {
                            self.tp$name = METHOD_RESTORE;
                          });
                          $loc.__call__ = Sk.ffi.functionPy(function (self) {
                            context[METHOD_RESTORE]();
                          });
                          $loc.__str__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_RESTORE);
                          });
                          $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_RESTORE);
                          });
                        }, METHOD_RESTORE, []));
                      }
                    case METHOD_ROTATE: {
                        return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
                          $loc.__init__ = Sk.ffi.functionPy(function (self) {
                            self.tp$name = METHOD_ROTATE;
                          });
                          $loc.__call__ = Sk.ffi.functionPy(function (self, angle) {
                            angle = Sk.ffi.remapToJs(angle);
                            context[METHOD_ROTATE](angle);
                          });
                          $loc.__str__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_ROTATE);
                          });
                          $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_ROTATE);
                          });
                        }, METHOD_ROTATE, []));
                      }
                    case METHOD_SAVE: {
                        return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
                          $loc.__init__ = Sk.ffi.functionPy(function (self) {
                            self.tp$name = METHOD_SAVE;
                          });
                          $loc.__call__ = Sk.ffi.functionPy(function (self) {
                            context[METHOD_SAVE]();
                          });
                          $loc.__str__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_SAVE);
                          });
                          $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_SAVE);
                          });
                        }, METHOD_SAVE, []));
                      }
                    case METHOD_SCALE: {
                        return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
                          $loc.__init__ = Sk.ffi.functionPy(function (self) {
                            self.tp$name = METHOD_SCALE;
                          });
                          $loc.__call__ = Sk.ffi.functionPy(function (self, x, y) {
                            x = Sk.ffi.remapToJs(x);
                            y = Sk.ffi.remapToJs(y);
                            context[METHOD_SCALE](x, y);
                          });
                          $loc.__str__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_SCALE);
                          });
                          $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_SCALE);
                          });
                        }, METHOD_SCALE, []));
                      }
                    case METHOD_SET_TRANSFORM: {
                        return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
                          $loc.__init__ = Sk.ffi.functionPy(function (self) {
                            self.tp$name = METHOD_SET_TRANSFORM;
                          });
                          $loc.__call__ = Sk.ffi.functionPy(function (self, a, b, c, d, e, f) {
                            a = Sk.ffi.remapToJs(a);
                            b = Sk.ffi.remapToJs(b);
                            c = Sk.ffi.remapToJs(c);
                            d = Sk.ffi.remapToJs(d);
                            e = Sk.ffi.remapToJs(e);
                            f = Sk.ffi.remapToJs(f);
                            context[METHOD_SET_TRANSFORM](a, b, c, d, e, f);
                          });
                          $loc.__str__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_SET_TRANSFORM);
                          });
                          $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_SET_TRANSFORM);
                          });
                        }, METHOD_SET_TRANSFORM, []));
                      }
                    case METHOD_STROKE: {
                        return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
                          $loc.__init__ = Sk.ffi.functionPy(function (self) {
                            self.tp$name = METHOD_STROKE;
                          });
                          $loc.__call__ = Sk.ffi.functionPy(function (self) {
                            context[METHOD_STROKE]();
                          });
                          $loc.__str__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_STROKE);
                          });
                          $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_STROKE);
                          });
                        }, METHOD_STROKE, []));
                      }
                    case METHOD_STROKE_RECT: {
                        return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
                          $loc.__init__ = Sk.ffi.functionPy(function (self) {
                            self.tp$name = METHOD_STROKE_RECT;
                          });
                          $loc.__call__ = Sk.ffi.functionPy(function (self, x, y, w, h) {
                            x = Sk.ffi.remapToJs(x);
                            y = Sk.ffi.remapToJs(y);
                            w = Sk.ffi.remapToJs(w);
                            h = Sk.ffi.remapToJs(h);
                            context[METHOD_STROKE_RECT](x, y, w, h);
                          });
                          $loc.__str__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_STROKE_RECT);
                          });
                          $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_STROKE_RECT);
                          });
                        }, METHOD_STROKE_RECT, []));
                      }
                    case METHOD_STROKE_TEXT: {
                        return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
                          $loc.__init__ = Sk.ffi.functionPy(function (self) {
                            self.tp$name = METHOD_STROKE_TEXT;
                          });
                          $loc.__call__ = Sk.ffi.functionPy(function (self, text, x, y, maxWidthPy) {
                            text = Sk.ffi.remapToJs(text);
                            x = Sk.ffi.remapToJs(x);
                            y = Sk.ffi.remapToJs(y);
                            var maxWidth = Sk.ffi.remapToJs(maxWidthPy);
                            if (typeof maxWidth === 'undefined') {
                              context[METHOD_STROKE_TEXT](text, x, y);
                            } else if (typeof maxWidth === 'number') {
                              context[METHOD_STROKE_TEXT](text, x, y, maxWidth);
                            } else {
                              throw new Sk.builtin.TypeError('maxWidth');
                            }
                          });
                          $loc.__str__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_STROKE_TEXT);
                          });
                          $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_STROKE_TEXT);
                          });
                        }, METHOD_STROKE_TEXT, []));
                      }
                    case METHOD_TRANSFORM: {
                        return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
                          $loc.__init__ = Sk.ffi.functionPy(function (self) {
                            self.tp$name = METHOD_TRANSFORM;
                          });
                          $loc.__call__ = Sk.ffi.functionPy(function (self, a, b, c, d, e, f) {
                            a = Sk.ffi.remapToJs(a);
                            b = Sk.ffi.remapToJs(b);
                            c = Sk.ffi.remapToJs(c);
                            d = Sk.ffi.remapToJs(d);
                            e = Sk.ffi.remapToJs(e);
                            f = Sk.ffi.remapToJs(f);
                            context[METHOD_TRANSFORM](a, b, c, d, e, f);
                          });
                          $loc.__str__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_TRANSFORM);
                          });
                          $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_TRANSFORM);
                          });
                        }, METHOD_TRANSFORM, []));
                      }
                    case METHOD_TRANSLATE: {
                        return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
                          $loc.__init__ = Sk.ffi.functionPy(function (self) {
                            self.tp$name = METHOD_TRANSLATE;
                          });
                          $loc.__call__ = Sk.ffi.functionPy(function (self, x, y) {
                            x = Sk.ffi.remapToJs(x);
                            y = Sk.ffi.remapToJs(y);
                            context[METHOD_TRANSLATE](x, y);
                          });
                          $loc.__str__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_TRANSLATE);
                          });
                          $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                            return Sk.ffi.stringToPy(METHOD_TRANSLATE);
                          });
                        }, METHOD_TRANSLATE, []));
                      }
                    }
                  });
                  $loc.__setattr__ = Sk.ffi.functionPy(function (contextPy, name, valuePy) {
                    var context = Sk.ffi.remapToJs(contextPy);
                    var value = Sk.ffi.remapToJs(valuePy);
                    switch (name) {
                    case PROP_FILL_STYLE: {
                        context[PROP_FILL_STYLE] = value;
                      }
                      break;
                    case PROP_FONT: {
                        context[PROP_FONT] = value;
                      }
                      break;
                    case PROP_LINE_CAP: {
                        context[PROP_LINE_CAP] = value;
                      }
                      break;
                    case PROP_LINE_JOIN: {
                        context[PROP_LINE_JOIN] = value;
                      }
                      break;
                    case PROP_LINE_WIDTH: {
                        context[PROP_LINE_WIDTH] = value;
                      }
                      break;
                    case PROP_SHADOW_BLUR: {
                        context[PROP_SHADOW_BLUR] = value;
                      }
                      break;
                    case PROP_SHADOW_COLOR: {
                        context[PROP_SHADOW_COLOR] = value;
                      }
                      break;
                    case PROP_SHADOW_OFFSET_X: {
                        context[PROP_SHADOW_OFFSET_X] = value;
                      }
                      break;
                    case PROP_SHADOW_OFFSET_Y: {
                        context[PROP_SHADOW_OFFSET_Y] = value;
                      }
                      break;
                    case PROP_STROKE_STYLE: {
                        context[PROP_STROKE_STYLE] = value;
                      }
                      break;
                    case PROP_TEXT_ALIGN: {
                        context[PROP_TEXT_ALIGN] = value;
                      }
                      break;
                    case PROP_TEXT_BASELINE: {
                        context[PROP_TEXT_BASELINE] = value;
                      }
                      break;
                    default: {
                        throw new Sk.builtin.AssertionError(name + ' is not a writeable attribute of ' + CANVAS_RENDERING_CONTEXT_2D);
                      }
                    }
                  });
                  $loc.__str__ = Sk.ffi.functionPy(function (self) {
                    return Sk.ffi.stringToPy(CANVAS_RENDERING_CONTEXT_2D);
                  });
                  $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                    return Sk.ffi.stringToPy(CANVAS_RENDERING_CONTEXT_2D);
                  });
                }, CANVAS_RENDERING_CONTEXT_2D, []));
              });
              $loc.__str__ = Sk.ffi.functionPy(function (self) {
                return Sk.ffi.stringToPy(METHOD_GET_CONTEXT);
              });
              $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                return Sk.ffi.stringToPy(METHOD_GET_CONTEXT);
              });
            }, METHOD_GET_CONTEXT, []));
          }
        case METHOD_INSERT_BEFORE: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (self) {
                self.tp$name = METHOD_INSERT_BEFORE;
              });
              $loc.__call__ = Sk.ffi.functionPy(function (self, newNode, refNode) {
                return nodeToPy(node.insertBefore(Sk.ffi.remapToJs(newNode), Sk.ffi.remapToJs(refNode)));
              });
              $loc.__str__ = Sk.ffi.functionPy(function (self) {
                return Sk.ffi.stringToPy(METHOD_INSERT_BEFORE);
              });
              $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                return Sk.ffi.stringToPy(METHOD_INSERT_BEFORE);
              });
            }, METHOD_INSERT_BEFORE, []));
          }
        case METHOD_REMOVE_CHILD: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (self) {
                self.tp$name = METHOD_REMOVE_CHILD;
              });
              $loc.__call__ = Sk.ffi.functionPy(function (self, childNode) {
                return nodeToPy(node.removeChild(Sk.ffi.remapToJs(childNode)));
              });
              $loc.__str__ = Sk.ffi.functionPy(function (self) {
                return Sk.ffi.stringToPy(METHOD_REMOVE_CHILD);
              });
              $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                return Sk.ffi.stringToPy(METHOD_REMOVE_CHILD);
              });
            }, METHOD_REMOVE_CHILD, []));
          }
        case METHOD_SET_ATTRIBUTE: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (self) {
                self.tp$name = METHOD_SET_ATTRIBUTE;
              });
              $loc.__call__ = Sk.ffi.functionPy(function (methodPy, namePy, valuePy) {
                Sk.ffi.checkMethodArgs(METHOD_SET_ATTRIBUTE, arguments, 2, 2);
                Sk.ffi.checkArgType(ARG_NAME, Sk.ffi.PyType.STR, Sk.ffi.isStr(namePy), namePy);
                node.setAttribute(Sk.ffi.remapToJs(namePy), Sk.ffi.remapToJs(valuePy));
              });
              $loc.__str__ = Sk.ffi.functionPy(function (self) {
                return Sk.ffi.stringToPy(METHOD_SET_ATTRIBUTE);
              });
              $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                return Sk.ffi.stringToPy(METHOD_SET_ATTRIBUTE);
              });
            }, METHOD_SET_ATTRIBUTE, []));
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(NODE);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (nodePy, name, valuePy) {
        var node = Sk.ffi.remapToJs(nodePy);
        var value = Sk.ffi.remapToJs(valuePy);
        switch (name) {
        case PROP_DIR: {
            node[PROP_DIR] = value;
          }
          break;
        case 'id': {
            node.setAttribute(name, value);
          }
          break;
        case PROP_HEIGHT: {
            node[PROP_HEIGHT] = value;
          }
          break;
        case PROP_INNER_HTML: {
            Sk.ffi.checkArgType(PROP_INNER_HTML, Sk.ffi.PyType.STR, Sk.ffi.isStr(valuePy), valuePy);
            node[PROP_INNER_HTML] = Sk.ffi.remapToJs(valuePy);
          }
          break;
        case PROP_WIDTH: {
            node[PROP_WIDTH] = value;
          }
          break;
        default: {
            throw Sk.ffi.err.attribute(name).isNotSetableOnType(NODE);
          }
        }
      });
      $loc.getCSS = Sk.ffi.functionPy(function (self, key) {
        return Sk.ffi.stringToPy(self.v.style[key.v]);
      });
      $loc.setCSS = Sk.ffi.functionPy(function (self, attr, value) {
        self.v.style[attr.v] = value.v;
      });
      $loc.getAttribute = Sk.ffi.functionPy(function (self, key) {
        var res = self.v.getAttribute(key.v);
        if (res) {
          return Sk.ffi.stringToPy(res);
        } else {
          return null;
        }
      });
      $loc.setAttribute = Sk.ffi.functionPy(function (self, attr, value) {
        self.v.setAttribute(attr.v, value.v);
      });
      $loc.__str__ = Sk.ffi.functionPy(function (self) {
        return Sk.ffi.stringToPy(self.v.tagName);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (self) {
        return Sk.ffi.stringToPy(NODE);
      });
    }, NODE, []);
  };
}.call(this));
(function () {
  Sk.builtin.defineNumPy = function (mod) {
    Sk.ffi.checkFunctionArgs('defineNumPy', arguments, 1, 1);
    var CLASS_NDARRAY = 'ndarray';
    var METHOD_COPY = 'copy';
    var METHOD_FILL = 'fill';
    var METHOD_RESHAPE = 'reshape';
    var METHOD_TOLIST = 'tolist';
    function unpack(objectPy, buffer, state) {
      if (Sk.ffi.isList(objectPy)) {
        var elementsPy = Sk.ffi.remapToJs(objectPy, true);
        state.level += 1;
        if (state.level > state.shape.length) {
          state.shape.push(elementsPy.length);
        } else {
        }
        for (var i = 0, len = elementsPy.length; i < len; i++) {
          unpack(elementsPy[i], buffer, state);
        }
        state.level -= 1;
      } else {
        buffer.push(objectPy);
      }
    }
    function reverse(array) {
      var first = null;
      var last = null;
      var tmp = null;
      var length = array.length;
      for (first = 0, last = length - 1; first < length / 2; first++, last--) {
        tmp = array[first];
        array[first] = array[last];
        array[last] = tmp;
      }
    }
    function computeStrides(shape) {
      var strides = shape.slice(0);
      reverse(strides);
      var prod = 1;
      var temp = 0;
      for (var i = 0, len = strides.length; i < len; i++) {
        var temp = strides[i];
        strides[i] = prod;
        prod *= temp;
      }
      reverse(strides);
      return strides;
    }
    function computeOffset(strides, index) {
      var offset = 0;
      for (var k = 0, len = strides.length; k < len; k++) {
        offset += strides[k] * index[k];
      }
      return offset;
    }
    function prod(numbers) {
      var size = 1;
      for (var i = 0, len = numbers.length; i < len; i++) {
        size *= numbers[i];
      }
      return size;
    }
    function makeNumericBinaryOpLhs(operationPy) {
      return function (selfPy, otherPy) {
        var selfJs = Sk.ffi.remapToJs(selfPy);
        if (Sk.ffi.isInstance(otherPy, CLASS_NDARRAY)) {
          var lhs = selfJs.buffer;
          var rhs = Sk.ffi.remapToJs(otherPy).buffer;
          var buffer = [];
          for (var i = 0, len = lhs.length; i < len; i++) {
            buffer[i] = operationPy(lhs[i], rhs[i]);
          }
          var shapePy = Sk.ffi.tuplePy(selfJs.shape.map(function (x) {
              return Sk.ffi.numberToIntPy(x);
            }));
          var bufferPy = Sk.ffi.listPy(buffer);
          return Sk.ffi.callsim(mod[CLASS_NDARRAY], shapePy, undefined, bufferPy);
        } else {
          var lhs = selfJs.buffer;
          var buffer = [];
          for (var i = 0, len = lhs.length; i < len; i++) {
            buffer[i] = operationPy(lhs[i], otherPy);
          }
          var shapePy = Sk.ffi.tuplePy(selfJs.shape.map(function (x) {
              return Sk.ffi.numberToIntPy(x);
            }));
          var bufferPy = Sk.ffi.listPy(buffer);
          return Sk.ffi.callsim(mod[CLASS_NDARRAY], shapePy, undefined, bufferPy);
        }
      };
    }
    function makeNumericBinaryOpRhs(operationPy) {
      return function (selfPy, otherPy) {
        var selfJs = Sk.ffi.remapToJs(selfPy);
        var rhsBuffer = selfJs.buffer;
        var buffer = [];
        for (var i = 0, len = rhsBuffer.length; i < len; i++) {
          buffer[i] = operationPy(otherPy, rhsBuffer[i]);
        }
        var shapePy = Sk.ffi.tuplePy(selfJs.shape.map(function (x) {
            return Sk.ffi.numberToIntPy(x);
          }));
        var bufferPy = Sk.ffi.listPy(buffer);
        return Sk.ffi.callsim(mod[CLASS_NDARRAY], shapePy, undefined, bufferPy);
      };
    }
    function makeUnaryOp(operationPy) {
      return function (selfPy) {
        var selfJs = Sk.ffi.remapToJs(selfPy);
        var buffer = selfJs.buffer.map(function (valuePy) {
            return operationPy(valuePy);
          });
        var shapePy = Sk.ffi.tuplePy(selfJs.shape.map(function (x) {
            return Sk.ffi.numberToIntPy(x);
          }));
        var bufferPy = Sk.ffi.listPy(buffer);
        return Sk.ffi.callsim(mod[CLASS_NDARRAY], shapePy, undefined, bufferPy);
      };
    }
    function stringify(buffer, shape) {
      var emits = shape.map(function (x) {
          return 0;
        });
      var uBound = shape.length - 1;
      var idxLevel = 0;
      var str = '[';
      var i = 0;
      while (idxLevel !== -1) {
        if (emits[idxLevel] < shape[idxLevel]) {
          if (emits[idxLevel] !== 0) {
            str += ', ';
          }
          if (idxLevel < uBound) {
            str += '[';
            idxLevel += 1;
          } else {
            str += Sk.ffi.remapToJs(Sk.ffh.str(buffer[i++]));
            emits[idxLevel] += 1;
          }
        } else {
          emits[idxLevel] = 0;
          str += ']';
          idxLevel -= 1;
          if (idxLevel >= 0) {
            emits[idxLevel] += 1;
          }
        }
      }
      return str;
    }
    mod[CLASS_NDARRAY] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, shapePy, dtypePy, bufferPy, offsetPy, stridesPy, orderPy) {
        var ndarrayJs = {};
        ndarrayJs.shape = Sk.ffi.remapToJs(shapePy);
        ndarrayJs.strides = computeStrides(ndarrayJs.shape);
        ndarrayJs.dtypePy = dtypePy;
        if (Sk.ffi.isDefined(bufferPy)) {
          Sk.ffi.checkArgType('buffer', [Sk.ffi.PyType.LIST], Sk.ffi.isList(bufferPy), bufferPy);
          ndarrayJs.buffer = Sk.ffi.remapToJs(bufferPy, true);
        }
        Sk.ffi.referenceToPy(ndarrayJs, CLASS_NDARRAY, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var ndarrayJs = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case 'dtype': {
            return ndarrayJs.dtypePy;
          }
        case 'ndim': {
            return Sk.ffi.numberToIntPy(ndarrayJs.shape.length);
          }
        case 'shape': {
            return Sk.ffi.tuplePy(ndarrayJs.shape.map(function (x) {
              return Sk.ffi.numberToIntPy(x);
            }));
          }
        case 'size': {
            return Sk.ffi.numberToIntPy(prod(ndarrayJs.shape));
          }
        case 'strides': {
            return Sk.ffi.tuplePy(ndarrayJs.strides.map(function (x) {
              return Sk.ffi.numberToIntPy(x);
            }));
          }
        case 'buffer': {
            return Sk.ffi.listPy(ndarrayJs.buffer);
          }
        case METHOD_COPY: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (methodPy) {
                Sk.ffi.referenceToPy(null, METHOD_COPY, null, methodPy);
              });
              $loc.__call__ = Sk.ffi.functionPy(function (methodPy) {
                Sk.ffi.checkMethodArgs(METHOD_COPY, arguments, 0, 0);
                var shapePy = Sk.ffi.tuplePy(ndarrayJs.shape.map(function (x) {
                    return Sk.ffi.numberToIntPy(x);
                  }));
                var buffer = ndarrayJs.buffer.map(function (x) {
                    return x;
                  });
                return Sk.ffi.callsim(mod[CLASS_NDARRAY], shapePy, ndarrayJs.dtypePy, Sk.ffi.listPy(buffer));
              });
            }, METHOD_COPY, []));
          }
        case METHOD_FILL: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (methodPy) {
                Sk.ffi.referenceToPy(null, METHOD_FILL, null, methodPy);
              });
              $loc.__call__ = Sk.ffi.functionPy(function (methodPy, valuePy) {
                Sk.ffi.checkMethodArgs(METHOD_FILL, arguments, 1, 1);
                for (var i = 0, len = ndarrayJs.buffer.length; i < len; i++) {
                  if (ndarrayJs.dtypePy) {
                    ndarrayJs.buffer[i] = Sk.misceval.callsim(ndarrayJs.dtypePy, valuePy);
                  }
                }
              });
            }, METHOD_FILL, []));
          }
        case METHOD_RESHAPE: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (methodPy) {
                Sk.ffi.referenceToPy(null, METHOD_RESHAPE, null, methodPy);
              });
              $loc.__call__ = Sk.ffi.functionPy(function (methodPy, shapePy) {
                Sk.ffi.checkMethodArgs(METHOD_RESHAPE, arguments, 0, 1);
                return Sk.ffi.callsim(mod[CLASS_NDARRAY], shapePy, ndarrayJs.dtypePy, Sk.ffi.listPy(ndarrayJs.buffer));
              });
            }, METHOD_RESHAPE, []));
          }
        case METHOD_TOLIST: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (methodPy) {
                Sk.ffi.referenceToPy(null, METHOD_TOLIST, null, methodPy);
              });
              $loc.__call__ = Sk.ffi.functionPy(function (methodPy) {
                Sk.ffi.checkMethodArgs(METHOD_TOLIST, arguments, 0, 0);
                var buffer = ndarrayJs.buffer.map(function (x) {
                    return x;
                  });
                return Sk.ffi.listPy(buffer);
              });
            }, METHOD_TOLIST, []));
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(CLASS_NDARRAY);
          }
        }
      });
      $loc.__getitem__ = Sk.ffi.functionPy(function (selfPy, indexPy) {
        var ndarrayJs = Sk.ffi.remapToJs(selfPy);
        Sk.ffi.checkMethodArgs('[]', arguments, 1, 1);
        if (Sk.ffi.isInt(indexPy)) {
          var offset = Sk.ffi.remapToJs(indexPy);
          if (ndarrayJs.shape.length > 1) {
            var stride = ndarrayJs.strides[0];
            var buffer = [];
            var index = 0;
            for (var i = offset * stride, ubound = (offset + 1) * stride; i < ubound; i++) {
              buffer[index++] = ndarrayJs.buffer[i];
            }
            var bufferPy = Sk.ffi.listPy(buffer);
            var shapePy = Sk.ffi.tuplePy(Array.prototype.slice.call(ndarrayJs.shape, 1).map(function (x) {
                return Sk.ffi.numberToIntPy(x);
              }));
            return Sk.ffi.callsim(mod[CLASS_NDARRAY], shapePy, undefined, bufferPy);
          } else {
            if (offset >= 0 && offset < ndarrayJs.buffer.length) {
              return ndarrayJs.buffer[offset];
            } else {
              throw new Sk.builtin.IndexError('array index out of range');
            }
          }
        } else if (Sk.ffi.isTuple(indexPy)) {
          var keyJs = Sk.ffi.remapToJs(indexPy);
          return ndarrayJs.buffer[computeOffset(ndarrayJs.strides, keyJs)];
        } else if (Sk.ffi.isFunction(indexPy)) {
          var indices = indexPy.indices();
          var start = typeof indices[0] !== 'undefined' ? indices[0] : 0;
          var stop = typeof indices[1] !== 'undefined' ? indices[1] : ndarrayJs.buffer.length;
          stop = stop > ndarrayJs.buffer.length ? ndarrayJs.buffer.length : stop;
          var step = typeof indices[2] !== 'undefined' ? indices[2] : 1;
          var buffer = [];
          var index = 0;
          if (step > 0) {
            for (var i = start; i < stop; i += step) {
              buffer[index++] = ndarrayJs.buffer[i];
            }
          }
          var bufferPy = Sk.ffi.listPy(buffer);
          var shapePy = Sk.ffi.tuplePy([buffer.length].map(function (x) {
              return Sk.ffi.numberToIntPy(x);
            }));
          return Sk.ffi.callsim(mod[CLASS_NDARRAY], shapePy, undefined, bufferPy);
        } else {
          Sk.ffi.checkArgType('index', [
            Sk.ffi.PyType.INT,
            Sk.ffi.PyType.TUPLE,
            Sk.ffi.PyType.FUNCTION
          ], false, indexPy);
        }
      });
      $loc.__setitem__ = Sk.ffi.functionPy(function (selfPy, indexPy, valuePy) {
        var ndarrayJs = Sk.ffi.remapToJs(selfPy);
        Sk.ffi.checkMethodArgs('[]', arguments, 2, 2);
        if (Sk.ffi.isInt(indexPy)) {
          var offset = Sk.ffi.remapToJs(indexPy);
          if (ndarrayJs.shape.length > 1) {
            var valueJs = Sk.ffi.remapToJs(valuePy);
            var stride = ndarrayJs.strides[0];
            var index = 0;
            for (var i = offset * stride, ubound = (offset + 1) * stride; i < ubound; i++) {
              ndarrayJs.buffer[i] = valueJs.buffer[index++];
            }
          } else {
            if (offset >= 0 && offset < ndarrayJs.buffer.length) {
              ndarrayJs.buffer[offset] = valuePy;
            } else {
              throw new Sk.builtin.IndexError('array index out of range');
            }
          }
        } else if (Sk.ffi.isTuple(indexPy)) {
          var keyJs = Sk.ffi.remapToJs(indexPy);
          var ndarrayJs = Sk.ffi.remapToJs(selfPy);
          ndarrayJs.buffer[computeOffset(ndarrayJs.strides, keyJs)] = valuePy;
        } else {
          Sk.ffi.checkArgType('index', [
            Sk.ffi.PyType.INT,
            Sk.ffi.PyType.TUPLE
          ], false, indexPy);
        }
      });
      $loc.__len__ = Sk.ffi.functionPy(function (selfPy) {
        var selfJs = Sk.ffi.remapToJs(selfPy);
        return Sk.ffi.numberToIntPy(selfJs.shape[0]);
      });
      $loc.__iter__ = Sk.ffi.functionPy(function (selfPy) {
        var ndarrayJs = Sk.ffi.remapToJs(selfPy);
        var ret = {
            tp$iter: function () {
              return ret;
            },
            $obj: ndarrayJs,
            $index: 0,
            tp$iternext: function () {
              if (ret.$index >= ret.$obj.buffer.length)
                return undefined;
              return ret.$obj.buffer[ret.$index++];
            }
          };
        return ret;
      });
      $loc.__add__ = Sk.ffi.functionPy(makeNumericBinaryOpLhs(Sk.ffh.add));
      $loc.__radd__ = Sk.ffi.functionPy(makeNumericBinaryOpRhs(Sk.ffh.add));
      $loc.__sub__ = Sk.ffi.functionPy(makeNumericBinaryOpLhs(Sk.ffh.subtract));
      $loc.__rsub__ = Sk.ffi.functionPy(makeNumericBinaryOpRhs(Sk.ffh.subtract));
      $loc.__mul__ = Sk.ffi.functionPy(makeNumericBinaryOpLhs(Sk.ffh.multiply));
      $loc.__rmul__ = Sk.ffi.functionPy(makeNumericBinaryOpRhs(Sk.ffh.multiply));
      $loc.__div__ = Sk.ffi.functionPy(makeNumericBinaryOpLhs(Sk.ffh.divide));
      $loc.__rdiv__ = Sk.ffi.functionPy(makeNumericBinaryOpRhs(Sk.ffh.divide));
      $loc.__mod__ = Sk.ffi.functionPy(makeNumericBinaryOpLhs(Sk.ffh.mod));
      $loc.__rmod__ = Sk.ffi.functionPy(makeNumericBinaryOpRhs(Sk.ffh.mod));
      $loc.__xor__ = Sk.ffi.functionPy(makeNumericBinaryOpLhs(Sk.ffh.xor));
      $loc.__rxor__ = Sk.ffi.functionPy(makeNumericBinaryOpRhs(Sk.ffh.xor));
      $loc.__lshift__ = Sk.ffi.functionPy(makeNumericBinaryOpLhs(Sk.ffh.lshift));
      $loc.__rlshift__ = Sk.ffi.functionPy(makeNumericBinaryOpRhs(Sk.ffh.lshift));
      $loc.__rshift__ = Sk.ffi.functionPy(makeNumericBinaryOpLhs(Sk.ffh.rshift));
      $loc.__rrshift__ = Sk.ffi.functionPy(makeNumericBinaryOpRhs(Sk.ffh.rshift));
      $loc.__pos__ = Sk.ffi.functionPy(makeUnaryOp(Sk.ffh.positive));
      $loc.__neg__ = Sk.ffi.functionPy(makeUnaryOp(Sk.ffh.negative));
      $loc.__exp__ = Sk.ffi.functionPy(makeUnaryOp(Sk.ffh.exp));
      $loc.__sin__ = Sk.ffi.functionPy(makeUnaryOp(Sk.ffh.sin));
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var selfJs = Sk.ffi.remapToJs(selfPy);
        return Sk.ffi.stringToPy(stringify(selfJs.buffer, selfJs.shape));
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var selfJs = Sk.ffi.remapToJs(selfPy);
        return Sk.ffi.stringToPy('array(' + stringify(selfJs.buffer, selfJs.shape) + ')');
      });
    }, CLASS_NDARRAY, []);
    mod['array'] = Sk.ffi.functionPy(function (objectPy, dtypePy, copyPy, orderPy, subokPy, ndminPy) {
      Sk.ffi.checkFunctionArgs('array', arguments, 1, 6);
      Sk.ffi.checkArgType('object', [Sk.ffi.PyType.LIST], Sk.ffi.isList(objectPy), objectPy);
      if (Sk.ffi.isDefined(copyPy)) {
        Sk.ffi.checkArgType('copy', [Sk.ffi.PyType.BOOL], Sk.ffi.isBool(copyPy), copyPy);
      } else {
      }
      var elementsPy = [];
      var state = {};
      state.level = 0;
      state.shape = [];
      unpack(objectPy, elementsPy, state);
      if (Sk.ffi.isDefined(dtypePy)) {
        Sk.ffi.checkArgType('dtype', [Sk.ffi.PyType.FUNCTION], Sk.ffi.isFunction(dtypePy), dtypePy);
        for (var i = 0, len = elementsPy.length; i < len; i++) {
          elementsPy[i] = Sk.misceval.callsim(dtypePy, elementsPy[i]);
        }
      }
      var shapePy = Sk.ffi.tuplePy(state.shape.map(function (x) {
          return Sk.ffi.numberToFloatPy(x);
        }));
      var bufferPy = Sk.ffi.listPy(elementsPy);
      return Sk.ffi.callsim(mod[CLASS_NDARRAY], shapePy, dtypePy, bufferPy);
    });
    mod['empty'] = Sk.ffi.functionPy(function (shapePy, dtypePy, orderPy) {
      Sk.ffi.checkFunctionArgs('empty', arguments, 1, 3);
    });
    mod['linspace'] = Sk.ffi.functionPy(function (startPy, stopPy, numPy, endpointPy, retstepPy) {
      Sk.ffi.checkFunctionArgs('linspace(start, stop, num=50, endpoint=True, retstep=False)', arguments, 2, 5);
      var num;
      if (Sk.ffi.isDefined(numPy)) {
        Sk.ffi.checkArgType('num', [Sk.ffi.PyType.INT], Sk.ffi.isInt(numPy), numPy);
        num = Sk.ffi.remapToJs(numPy);
      } else {
        num = 50;
        numPy = Sk.ffi.numberToIntPy(50);
      }
      var endpoint;
      if (Sk.ffi.isDefined(endpointPy)) {
        Sk.ffi.checkArgType('endpoint', [Sk.ffi.PyType.BOOL], Sk.ffi.isBool(endpointPy), endpointPy);
        endpoint = Sk.ffi.remapToJs(endpointPy);
      } else {
        endpoint = true;
      }
      var retstep;
      if (Sk.ffi.isDefined(retstepPy)) {
        Sk.ffi.checkArgType('retstep', [Sk.ffi.PyType.BOOL], Sk.ffi.isBool(retstepPy), retstepPy);
        retstep = Sk.ffi.remapToJs(retstepPy);
      } else {
        retstep = false;
      }
      var diffPy = Sk.ffh.subtract(stopPy, startPy);
      var stepPy = endpoint ? Sk.ffh.divide(diffPy, Sk.ffh.subtract(numPy, Sk.ffi.numberToIntPy(1))) : Sk.ffh.divide(diffPy, numPy);
      var buffer = [];
      for (var i = 0; i < num; i++) {
        buffer[i] = Sk.ffh.add(Sk.ffh.multiply(Sk.ffi.numberToFloatPy(i), stepPy), startPy);
      }
      var shapeJs = [];
      shapeJs[0] = numPy;
      var shapePy = Sk.ffi.tuplePy(shapeJs);
      var arrayPy = Sk.ffi.callsim(mod[CLASS_NDARRAY], shapePy, undefined, Sk.ffi.listPy(buffer));
      return retstep ? Sk.ffi.tuplePy([
        arrayPy,
        stepPy
      ]) : arrayPy;
    });
    mod['zeros'] = Sk.ffi.functionPy(function (shapePy, dtypePy, orderPy) {
      Sk.ffi.checkFunctionArgs('zeros', arguments, 1, 2);
      Sk.ffi.checkArgType('shape', [Sk.ffi.PyType.TUPLE], Sk.ffi.isTuple(shapePy), shapePy);
      var shapeJs = Sk.ffi.remapToJs(shapePy);
      var size = prod(shapeJs);
      var buffer = [];
      var zero = Sk.ffi.numberToFloatPy(0);
      for (var i = 0; i < size; i++) {
        buffer[i] = zero;
      }
      return Sk.ffi.callsim(mod[CLASS_NDARRAY], shapePy, dtypePy, Sk.ffi.listPy(buffer));
    });
  };
}.call(this));
(function () {
  Sk.builtin.defineProbeE3 = function (mod, THREE) {
    Sk.ffi.checkFunctionArgs('defineProbeE3', arguments, 2, 2);
    var PROBE_E3 = 'ProbeE3';
    var PROBE_BUILDER_E3 = 'ProbeBuilderE3';
    var CUBE_BUILDER = 'CubeBuilder';
    var SPHERE_BUILDER = 'SphereBuilder';
    var EUCLIDEAN_3 = 'Euclidean3';
    var QUATERNION = 'Quaternion';
    var COLOR = 'Color';
    var NUMBER = [
        Sk.ffi.PyType.FLOAT,
        Sk.ffi.PyType.INT,
        Sk.ffi.PyType.LONG
      ];
    var PROP_COLOR = 'color';
    var PROP_POSITION = 'position';
    var PROP_QUANTITY = 'quantity';
    var PROP_SEGMENTS = 'segments';
    var PROP_WIREFRAME = 'wireframe';
    var PROP_GRADE_0 = 'grade0';
    var PROP_GRADE_1 = 'grade1';
    var PROP_GRADE_2 = 'grade2';
    var PROP_GRADE_3 = 'grade3';
    var PROP_ORIENTATION = 'orientation';
    var METHOD_BUILD = 'build';
    var METHOD_NORMALIZE = 'normalize';
    var METHOD_TRAVERSE = 'traverse';
    mod[PROBE_E3] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, grade0, grade1, grade2, grade3) {
        Sk.ffi.checkMethodArgs(PROBE_E3, arguments, 4, 4);
        var probe = {};
        probe[PROP_GRADE_0] = grade0;
        probe[PROP_GRADE_1] = grade1;
        probe[PROP_GRADE_2] = grade2;
        probe[PROP_GRADE_3] = grade3;
        probe[PROP_QUANTITY] = Sk.ffi.none.None;
        Sk.ffi.referenceToPy(probe, PROBE_E3, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var probe = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case PROP_GRADE_0: {
            return probe[PROP_GRADE_0];
          }
        case PROP_GRADE_1: {
            return probe[PROP_GRADE_1];
          }
        case PROP_GRADE_2: {
            return probe[PROP_GRADE_2];
          }
        case PROP_GRADE_3: {
            return probe[PROP_GRADE_3];
          }
        case PROP_POSITION: {
            return probe[PROP_POSITION];
          }
        case PROP_QUANTITY: {
            return probe[PROP_QUANTITY];
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(PROBE_E3);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        var probe = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case PROP_POSITION: {
            Sk.ffi.checkArgType(PROP_POSITION, EUCLIDEAN_3, Sk.ffi.isInstance(valuePy, EUCLIDEAN_3), valuePy);
            probe[PROP_POSITION] = valuePy;
            var position = Sk.ffi.remapToJs(valuePy).vector;
            var grade0 = Sk.ffi.remapToJs(probe[PROP_GRADE_0]);
            grade0[PROP_POSITION] = position;
            var grade1 = Sk.ffi.remapToJs(probe[PROP_GRADE_1]);
            grade1[PROP_POSITION] = position;
            var grade2 = Sk.ffi.remapToJs(probe[PROP_GRADE_2]);
            grade2[PROP_POSITION] = position;
            var grade3 = Sk.ffi.remapToJs(probe[PROP_GRADE_3]);
            grade3[PROP_POSITION] = position;
          }
          break;
        case PROP_QUANTITY: {
            Sk.ffi.checkArgType(PROP_QUANTITY, EUCLIDEAN_3, Sk.ffi.isInstance(valuePy, EUCLIDEAN_3), valuePy);
            function quaternion(x, y, z) {
              if (z !== -1) {
                var scale = 1 / Math.sqrt(2 * (1 + z));
                var xy = 0;
                var yz = +scale * y;
                var zx = -scale * x;
                return new THREE.Quaternion(-yz, -zx, -xy, scale * (1 + z));
              } else {
                return new THREE.Quaternion(1, 0, 0, 0);
              }
            }
            function show(composite, scale) {
              composite.scale.set(scale, scale, scale);
              composite.traverse(function (x) {
                x.visible = true;
              });
            }
            function hide(composite) {
              composite.traverse(function (x) {
                x.visible = false;
              });
              composite.scale.set(1, 1, 1);
            }
            function signum(x) {
              return typeof x === 'number' ? x ? x < 0 ? -1 : 1 : isNaN(x) ? NaN : 0 : NaN;
            }
            var value = Sk.ffi.remapToJs(valuePy);
            var w = value.w;
            var x = value.x;
            var y = value.y;
            var z = value.z;
            var xy = value.xy;
            var yz = value.yz;
            var zx = value.zx;
            var xyz = value.xyz;
            var grade0 = Sk.ffi.remapToJs(probe[PROP_GRADE_0]);
            var s0 = Math.abs(w);
            if (s0 !== 0) {
              show(grade0, s0);
            } else {
              hide(grade0);
            }
            var grade1 = Sk.ffi.remapToJs(probe[PROP_GRADE_1]);
            if (x !== 0 || y !== 0 || z !== 0) {
              var s1 = Math.sqrt(x * x + y * y + z * z);
              grade1.quaternion = quaternion(x / s1, y / s1, z / s1);
              show(grade1, s1);
            } else {
              hide(grade1);
            }
            var grade2 = Sk.ffi.remapToJs(probe[PROP_GRADE_2]);
            if (xy !== 0 || yz !== 0 || zx !== 0) {
              var norm2 = Math.sqrt(xy * xy + yz * yz + zx * zx);
              var s2 = Math.pow(norm2, 1 / 2);
              grade2.quaternion = quaternion(yz / norm2, zx / norm2, xy / norm2);
              show(grade2, s2);
            } else {
              hide(grade2);
            }
            var grade3 = Sk.ffi.remapToJs(probe[PROP_GRADE_3]);
            if (xyz !== 0) {
              var s3 = Math.pow(Math.abs(xyz), 1 / 3);
              try {
                Sk.ffi.sattr(probe[PROP_GRADE_3], PROP_ORIENTATION, Sk.ffi.booleanToPy(signum(xyz) >= 0));
              } catch (e) {
              }
              show(grade3, s3);
            } else {
              hide(grade3);
            }
            probe[PROP_QUANTITY] = valuePy;
          }
          break;
        case PROP_GRADE_0: {
            probe[PROP_GRADE_0] = valuePy;
          }
          break;
        case PROP_GRADE_1: {
            probe[PROP_GRADE_1] = valuePy;
          }
          break;
        case PROP_GRADE_2: {
            probe[PROP_GRADE_2] = valuePy;
          }
          break;
        case PROP_GRADE_3: {
            probe[PROP_GRADE_3] = valuePy;
          }
          break;
        default: {
            throw Sk.ffi.err.attribute(name).isNotSetableOnType(PROBE_E3);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffi.stringToPy(PROBE_E3);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffi.stringToPy(PROBE_E3);
      });
    }, PROBE_E3, []);
    mod[PROBE_BUILDER_E3] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy) {
        Sk.ffi.checkMethodArgs(PROBE_BUILDER_E3, arguments, 0, 0);
        var args = {};
        args[PROP_SEGMENTS] = 12;
        args[PROP_WIREFRAME] = false;
        Sk.ffi.referenceToPy(args, PROBE_BUILDER_E3, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var args = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case PROP_COLOR: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy, colorPy) {
              Sk.ffi.checkMethodArgs(name, arguments, 1, 1);
              Sk.ffi.checkArgType(name, [
                NUMBER,
                Sk.ffi.PyType.STR,
                COLOR
              ], Sk.ffi.isNum(colorPy) || Sk.ffi.isStr(colorPy) || Sk.ffi.isInstance(colorPy, COLOR), colorPy);
              args[PROP_COLOR] = colorPy;
              return selfPy;
            });
          }
        case PROP_SEGMENTS: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy, segmentsPy) {
              Sk.ffi.checkMethodArgs(name, arguments, 1, 1);
              Sk.ffi.checkArgType(name, Sk.ffi.PyType.INT, Sk.ffi.isInt(segmentsPy), segmentsPy);
              args[PROP_SEGMENTS] = Sk.ffi.remapToJs(segmentsPy);
              return selfPy;
            });
          }
        case PROP_WIREFRAME: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy, wireframePy) {
              Sk.ffi.checkMethodArgs(name, arguments, 1, 1);
              Sk.ffi.checkArgType(name, Sk.ffi.PyType.BOOL, Sk.ffi.isBool(wireframePy), wireframePy);
              args[PROP_WIREFRAME] = Sk.ffi.remapToJs(wireframePy);
              return selfPy;
            });
          }
        case METHOD_BUILD: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy) {
              var builderNames = [
                  SPHERE_BUILDER,
                  Sk.geometry.ARROW_BUILDER,
                  Sk.geometry.VORTEX_BUILDER,
                  Sk.geometry.VOLUME_BUILDER
                ];
              var objects = builderNames.map(function (builderName) {
                  var builderPy = Sk.ffi.callsim(mod[builderName]);
                  if (args[PROP_COLOR]) {
                    Sk.ffi.callsim(Sk.ffi.gattr(builderPy, PROP_COLOR), args[PROP_COLOR]);
                  }
                  Sk.ffi.callsim(Sk.ffi.gattr(builderPy, METHOD_NORMALIZE));
                  Sk.ffi.callsim(Sk.ffi.gattr(builderPy, PROP_SEGMENTS), Sk.ffi.numberToIntPy(args[PROP_SEGMENTS]));
                  Sk.ffi.callsim(Sk.ffi.gattr(builderPy, PROP_WIREFRAME), Sk.ffi.booleanToPy(args[PROP_WIREFRAME]));
                  return Sk.ffi.callsim(Sk.ffi.gattr(builderPy, METHOD_BUILD));
                });
              return Sk.ffi.callsim(mod[PROBE_E3], objects[0], objects[1], objects[2], objects[3]);
            });
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(PROBE_BUILDER_E3);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        var probe = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        default: {
            throw Sk.ffi.err.attribute(name).isNotSetableOnType(PROBE_BUILDER_E3);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffi.stringToPy(PROBE_BUILDER_E3);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffi.stringToPy(PROBE_BUILDER_E3);
      });
    }, PROBE_BUILDER_E3, []);
  };
}.call(this));
Sk.builtin.buildWindowClass = function (mod) {
  var DOCUMENT_CLASS = 'Document';
  var EVENT = 'Event';
  var JS_WRAP_CLASS = 'JavaScriptWrapper';
  var WINDOW_CLASS = 'Window';
  var PROP_ANIMATION_TIME = 'animationTime';
  var PROP_DOCUMENT = 'document';
  var PROP_DEVICE_PIXEL_RATIO = 'devicePixelRatio';
  var PROP_INNER_WIDTH = 'innerWidth';
  var PROP_INNER_HEIGHT = 'innerHeight';
  var METHOD_ADD_EVENT_LISTENER = 'addEventListener';
  var METHOD_ALERT = 'alert';
  var METHOD_CANCEL_ANIMATION_FRAME = 'cancelAnimationFrame';
  var METHOD_CLOSE = 'close';
  var METHOD_CONFIRM = 'confirm';
  var METHOD_OPEN = 'open';
  var METHOD_PROMPT = 'prompt';
  var METHOD_REMOVE_EVENT_LISTENER = 'removeEventListener';
  var METHOD_REQUEST_ANIMATION_FRAME = 'requestAnimationFrame';
  var METHOD_SET_TIMEOUT = 'setTimeout';
  var winListeners = {};
  function isConstructorFunction(name) {
    if (name === 'Value' || name === 'X' || name === 'Y') {
      return false;
    }
    if (name[0] === name[0].toUpperCase()) {
      return true;
    } else {
      return false;
    }
  }
  function remapToPy(valueJs, name) {
    switch (typeof valueJs) {
    case 'number': {
        return Sk.ffi.numberToFloatPy(valueJs);
      }
    case 'boolean': {
        return Sk.ffi.booleanToPy(valueJs);
      }
    case 'string': {
        return Sk.ffi.stringToPy(valueJs);
      }
    case 'undefined': {
        return Sk.ffi.none.None;
      }
    case 'object': {
        if (Object.prototype.toString.apply(valueJs) === '[object Array]') {
          return Sk.ffi.callsim(mod[JS_WRAP_CLASS], Sk.ffi.referenceToPy(valueJs, JS_WRAP_CLASS));
        } else {
          return Sk.ffi.callsim(mod[JS_WRAP_CLASS], Sk.ffi.referenceToPy(valueJs, JS_WRAP_CLASS));
        }
      }
    default: {
        throw Sk.ffi.err.attribute(typeof valueJs).isNotGetableOnType(name);
      }
    }
  }
  function defaultGetAttribute(mod, selfJs, name, className) {
    var propJs = selfJs[name];
    switch (typeof propJs) {
    case 'function': {
        return Sk.ffi.callableToPy(mod, name, function (methodPy) {
          Sk.ffi.checkFunctionArgs(name, arguments, 1);
          var argumentsPy = Array.prototype.slice.call(arguments, 1);
          var argumentsJs = [];
          for (var i = 0; i < argumentsPy.length; ++i) {
            argumentsJs.push(Sk.ffi.remapToJs(argumentsPy[i]));
          }
          if (isConstructorFunction(name)) {
            var that = Object.create(propJs.prototype);
            var other = propJs.apply(that, argumentsJs);
            var valueJs = typeof other === 'object' && other || that;
            return Sk.ffi.callsim(mod[JS_WRAP_CLASS], Sk.ffi.referenceToPy(valueJs, name));
          } else {
            var valueJs = propJs.apply(selfJs, argumentsJs);
            return remapToPy(valueJs, className);
          }
        });
      }
      break;
    case 'object': {
        if (Object.prototype.toString.apply(propJs) === '[object Array]') {
          var valuesPy = [];
          for (var i = 0; i < propJs.length; i++) {
            valuesPy.push(Sk.ffi.remapToPy(propJs[i]));
          }
          return Sk.ffi.listPy(valuesPy);
        } else {
          return Sk.ffi.callsim(mod[JS_WRAP_CLASS], Sk.ffi.referenceToPy(propJs, JS_WRAP_CLASS));
        }
      }
    case 'number': {
        return Sk.ffi.numberToFloatPy(propJs);
      }
    case 'boolean': {
        return Sk.ffi.booleanToPy(propJs);
      }
    case 'string': {
        return Sk.ffi.stringToPy(propJs);
      }
    case 'undefined': {
        return Sk.ffi.none.None;
      }
    default: {
        throw Sk.ffi.err.attribute(typeof propJs).isNotGetableOnType(className);
      }
    }
  }
  mod[JS_WRAP_CLASS] = Sk.misceval.buildClass(mod, function ($gbl, $loc) {
    $loc.__init__ = Sk.ffi.functionPy(function (selfPy, elementPy) {
      Sk.ffi.checkMethodArgs(JS_WRAP_CLASS, arguments, 1, 1);
      Sk.ffi.referenceToPy(Sk.ffi.remapToJs(elementPy), elementPy.tp$name, undefined, selfPy);
    });
    $loc.__add__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
      var lhs = Sk.ffi.remapToJs(selfPy);
      var rhs = Sk.ffi.remapToJs(otherPy);
      var resultJs = lhs.add(rhs);
      return Sk.ffi.callsim(mod[JS_WRAP_CLASS], Sk.ffi.referenceToPy(resultJs, JS_WRAP_CLASS));
    });
    $loc.__sub__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
      var lhs = Sk.ffi.remapToJs(selfPy);
      var rhs = Sk.ffi.remapToJs(otherPy);
      var resultJs = lhs.sub(rhs);
      return Sk.ffi.callsim(mod[JS_WRAP_CLASS], Sk.ffi.referenceToPy(resultJs, JS_WRAP_CLASS));
    });
    $loc.__mul__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
      var lhs = Sk.ffi.remapToJs(selfPy);
      var rhs = Sk.ffi.remapToJs(otherPy);
      var resultJs = lhs.mul(rhs);
      return Sk.ffi.callsim(mod[JS_WRAP_CLASS], Sk.ffi.referenceToPy(resultJs, JS_WRAP_CLASS));
    });
    $loc.__div__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
      var lhs = Sk.ffi.remapToJs(selfPy);
      var rhs = Sk.ffi.remapToJs(otherPy);
      var resultJs = lhs.div(rhs);
      return Sk.ffi.callsim(mod[JS_WRAP_CLASS], Sk.ffi.referenceToPy(resultJs, JS_WRAP_CLASS));
    });
    $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
      return defaultGetAttribute(mod, Sk.ffi.remapToJs(selfPy), name, JS_WRAP_CLASS);
    });
    $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
      var selfJs = Sk.ffi.remapToJs(selfPy);
      var propJs = selfJs[name];
      switch (name) {
      default: {
          switch (typeof propJs) {
          case 'number': {
              selfJs[name] = Sk.ffi.remapToJs(valuePy);
            }
            break;
          default: {
              selfJs[name] = Sk.ffi.remapToJs(valuePy);
            }
          }
        }
      }
    });
    $loc.__getitem__ = Sk.ffi.functionPy(function (selfPy, indexPy) {
      Sk.ffi.checkMethodArgs('[]', arguments, 1, 1);
      Sk.ffi.checkArgType('index', Sk.ffi.PyType.INT, Sk.ffi.isInt(indexPy), indexPy);
      var index = Sk.ffi.remapToJs(indexPy);
      return defaultGetAttribute(mod, Sk.ffi.remapToJs(selfPy), '' + index, JS_WRAP_CLASS);
    });
    $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
      var selfJs = Sk.ffi.remapToJs(selfPy);
      return Sk.ffi.stringToPy(selfJs.toString());
    });
    $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
      return Sk.ffi.stringToPy(JS_WRAP_CLASS);
    });
  }, JS_WRAP_CLASS, []);
  mod[WINDOW_CLASS] = Sk.misceval.buildClass(mod, function ($gbl, $loc) {
    $loc.__init__ = Sk.ffi.functionPy(function (selfPy, windowPy) {
      Sk.ffi.checkMethodArgs(WINDOW_CLASS, arguments, 1, 1);
      Sk.ffi.referenceToPy(Sk.ffi.remapToJs(windowPy), WINDOW_CLASS, undefined, selfPy);
    });
    $loc.__getattr__ = Sk.ffi.functionPy(function (windowPy, name) {
      var windowJs = Sk.ffi.remapToJs(windowPy);
      switch (name) {
      case PROP_ANIMATION_TIME: {
          return Sk.ffi.numberToFloatPy(windowJs[PROP_ANIMATION_TIME]);
        }
      case PROP_DOCUMENT: {
          return Sk.ffi.callsim(mod[DOCUMENT_CLASS], Sk.ffi.referenceToPy(windowJs.document, DOCUMENT_CLASS));
        }
      case PROP_INNER_HEIGHT: {
          return Sk.ffi.numberToIntPy(windowJs[PROP_INNER_HEIGHT]);
        }
      case PROP_INNER_WIDTH: {
          return Sk.ffi.numberToIntPy(windowJs[PROP_INNER_WIDTH]);
        }
      case PROP_DEVICE_PIXEL_RATIO: {
          return Sk.ffi.numberToIntPy(windowJs[PROP_DEVICE_PIXEL_RATIO]);
        }
      case METHOD_ADD_EVENT_LISTENER: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = Sk.ffi.functionPy(function (self) {
              self.tp$name = METHOD_ADD_EVENT_LISTENER;
            });
            $loc.__call__ = Sk.ffi.functionPy(function (self, typePy, listenerPy, useCapture) {
              var type = Sk.ffi.remapToJs(typePy);
              var listener = function (event) {
                var eventPy = Sk.misceval.callsim(mod[EVENT], Sk.ffi.referenceToPy(event, EVENT));
                Sk.misceval.callsim(listenerPy, eventPy);
              };
              winListeners[type] = listener;
              windowJs[METHOD_ADD_EVENT_LISTENER](type, listener, useCapture);
            });
          }, METHOD_ADD_EVENT_LISTENER, []));
        }
      case METHOD_ALERT: {
          return Sk.ffi.callableToPy(mod, METHOD_ALERT, function (methodPy, messagePy) {
            Sk.ffi.checkMethodArgs(METHOD_ALERT, arguments, 0, 1);
            windowJs[METHOD_ALERT](Sk.ffi.remapToJs(messagePy));
          });
        }
      case METHOD_REMOVE_EVENT_LISTENER: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = Sk.ffi.functionPy(function (self) {
              self.tp$name = METHOD_REMOVE_EVENT_LISTENER;
            });
            $loc.__call__ = Sk.ffi.functionPy(function (self, typePy, listener, useCapture) {
              var type = Sk.ffi.remapToJs(typePy);
              var listener = winListeners[type];
              delete winListeners[type];
              windowJs[METHOD_REMOVE_EVENT_LISTENER](type, listener, useCapture);
            });
          }, METHOD_REMOVE_EVENT_LISTENER, []));
        }
      case METHOD_CANCEL_ANIMATION_FRAME: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = Sk.ffi.functionPy(function (self) {
              self.tp$name = METHOD_CANCEL_ANIMATION_FRAME;
            });
            $loc.__call__ = Sk.ffi.functionPy(function (self, requestID) {
              if (requestID) {
                windowJs[METHOD_CANCEL_ANIMATION_FRAME](Sk.ffi.remapToJs(requestID));
              }
            });
          }, METHOD_CANCEL_ANIMATION_FRAME, []));
        }
      case METHOD_CLOSE: {
          return Sk.ffi.callableToPy(mod, METHOD_CLOSE, function (methodPy) {
            Sk.ffi.checkMethodArgs(METHOD_CLOSE, arguments, 0, 0);
            windowJs[METHOD_CLOSE]();
          });
        }
      case METHOD_CONFIRM: {
          return Sk.ffi.callableToPy(mod, METHOD_CONFIRM, function (methodPy, messagePy) {
            Sk.ffi.checkMethodArgs(METHOD_CONFIRM, arguments, 0, 1);
            return Sk.ffi.booleanToPy(windowJs[METHOD_CONFIRM](Sk.ffi.remapToJs(messagePy)));
          });
        }
      case METHOD_OPEN: {
          return Sk.ffi.callableToPy(mod, METHOD_OPEN, function (methodPy, urlPy, namePy, specsPy, replacePy) {
            Sk.ffi.checkMethodArgs(METHOD_OPEN, arguments, 0, 4);
            if (Sk.ffi.isDefined(urlPy)) {
              Sk.ffi.checkArgType('URL', Sk.ffi.PyType.STR, Sk.ffi.isStr(urlPy), urlPy);
            }
            if (Sk.ffi.isDefined(namePy)) {
              Sk.ffi.checkArgType('name', Sk.ffi.PyType.STR, Sk.ffi.isStr(namePy), namePy);
            }
            if (Sk.ffi.isDefined(specsPy)) {
              Sk.ffi.checkArgType('specs', Sk.ffi.PyType.STR, Sk.ffi.isStr(specsPy), specsPy);
            }
            if (Sk.ffi.isDefined(replacePy)) {
              Sk.ffi.checkArgType('replace', Sk.ffi.PyType.BOOL, Sk.ffi.isBool(replacePy), replacePy);
            }
            var w = windowJs[METHOD_OPEN](Sk.ffi.remapToJs(urlPy), Sk.ffi.remapToJs(namePy), Sk.ffi.remapToJs(specsPy), Sk.ffi.remapToJs(replacePy));
            return Sk.ffi.callsim(mod[WINDOW_CLASS], Sk.ffi.referenceToPy(w, WINDOW_CLASS));
          });
        }
      case METHOD_PROMPT: {
          return Sk.ffi.callableToPy(mod, METHOD_PROMPT, function (methodPy, textPy, valuePy) {
            Sk.ffi.checkMethodArgs(METHOD_PROMPT, arguments, 0, 2);
            return Sk.ffi.stringToPy(windowJs[METHOD_PROMPT](Sk.ffi.remapToJs(textPy), Sk.ffi.remapToJs(valuePy)));
          });
        }
      case METHOD_REQUEST_ANIMATION_FRAME: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = Sk.ffi.functionPy(function (self) {
              self.tp$name = METHOD_REQUEST_ANIMATION_FRAME;
            });
            $loc.__call__ = Sk.ffi.functionPy(function (self, callback) {
              var requestID = windowJs[METHOD_REQUEST_ANIMATION_FRAME](function (timestamp) {
                  Sk.misceval.callsim(callback, Sk.ffi.numberToFloatPy(timestamp));
                });
              return Sk.ffi.numberToFloatPy(requestID);
            });
          }, METHOD_REQUEST_ANIMATION_FRAME, []));
        }
      case METHOD_SET_TIMEOUT: {
          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = Sk.ffi.functionPy(function (self) {
              self.tp$name = METHOD_SET_TIMEOUT;
            });
            $loc.__call__ = Sk.ffi.functionPy(function (self, funcPy, delayPy, paramsPy) {
              var delay = Sk.ffi.remapToJs(delayPy);
              var params = Sk.ffi.remapToJs(paramsPy);
              var timeoutID = windowJs[METHOD_SET_TIMEOUT](function () {
                  Sk.misceval.callsim(funcPy);
                }, delay, params);
              return Sk.ffi.numberToFloatPy(timeoutID);
            });
          }, METHOD_SET_TIMEOUT, []));
        }
      default: {
          return defaultGetAttribute(mod, windowJs, name, WINDOW_CLASS);
        }
      }
    });
    $loc.__str__ = Sk.ffi.functionPy(function (self) {
      return Sk.ffi.stringToPy(WINDOW_CLASS);
    });
    $loc.__repr__ = Sk.ffi.functionPy(function (self, arg) {
      return Sk.ffi.stringToPy(WINDOW_CLASS);
    });
  }, WINDOW_CLASS, []);
  return mod[WINDOW_CLASS];
};
(function () {
  Sk.builtin.defineEuclidean2 = function (mod, BLADE) {
    Sk.ffi.checkFunctionArgs('defineEuclidean2', arguments, 2, 2);
    var EUCLIDEAN_2 = 'Euclidean2';
    var SCALAR_E2 = 'ScalarE2';
    var VECTOR_E2 = 'VectorE2';
    var PSEUDOSCALAR_E2 = 'PseudoscalarE2';
    var NUM = [
        Sk.ffi.PyType.FLOAT,
        Sk.ffi.PyType.INT,
        Sk.ffi.PyType.LONG
      ];
    var PROP_W = 'w';
    var PROP_X = 'x';
    var PROP_Y = 'y';
    var PROP_XY = 'xy';
    var METHOD_CLIFFORD_CONJUGATE = 'cliffordConjugate';
    var METHOD_CLONE = 'clone';
    var METHOD_COS = 'cos';
    var METHOD_SIN = 'sin';
    var METHOD_EXP = 'exp';
    var METHOD_MAGNITUDE = 'magnitude';
    var METHOD_SQRT = 'sqrt';
    var OP_ADD = 'add';
    var OP_SUB = 'subtract';
    var OP_MUL = 'multiply';
    var OP_DIV = 'divide';
    var OP_EQ = 'equal';
    var ONE_NAME = '1';
    var E1_NAME = 'e1';
    var E2_NAME = 'e2';
    var PSEUDOSCALAR_NAME = 'I';
    function isNumber(x) {
      return typeof x === 'number';
    }
    var isEuclidean2Py = function (valuePy) {
      return Sk.ffi.isInstance(valuePy, EUCLIDEAN_2);
    };
    function coordsJsToE2Py(s, x, y, xy) {
      return Sk.ffi.callsim(mod[EUCLIDEAN_2], Sk.ffi.numberToFloatPy(s), Sk.ffi.numberToFloatPy(x), Sk.ffi.numberToFloatPy(y), Sk.ffi.numberToFloatPy(xy));
    }
    function stringFromCoordinates(coordinates, labels, multiplier) {
      var append, i, sb, str, _i, _ref;
      sb = [];
      append = function (number, label) {
        var n;
        if (number !== 0) {
          if (number >= 0) {
            if (sb.length > 0) {
              sb.push('+');
            }
          } else {
            sb.push('-');
          }
          n = Math.abs(number);
          if (n === 1) {
            return sb.push(label);
          } else {
            sb.push(n.toString());
            if (label !== ONE_NAME) {
              sb.push(multiplier);
              return sb.push(label);
            }
          }
        }
      };
      for (i = _i = 0, _ref = coordinates.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        append(coordinates[i], labels[i]);
      }
      if (sb.length > 0) {
        str = sb.join('');
      } else {
        str = '0';
      }
      return str;
    }
    function cosh(x) {
      return (Math.pow(Math.E, x) + Math.pow(Math.E, -x)) / 2;
    }
    function sinh(x) {
      return (Math.pow(Math.E, x) - Math.pow(Math.E, -x)) / 2;
    }
    function divide(a00, a01, a10, a11, b00, b01, b10, b11, m) {
      var r00 = +b00;
      var r01 = +b01;
      var r10 = +b10;
      var r11 = -b11;
      var m00 = b00 * r00 + b01 * r01 + b10 * r10 - b11 * r11;
      var m01 = 0;
      var m10 = 0;
      var m11 = 0;
      var c00 = +m00;
      var c01 = -m01;
      var c10 = -m10;
      var c11 = -m11;
      var s00 = r00 * c00 + r01 * c01 + r10 * c10 - r11 * c11;
      var s01 = r00 * c01 + r01 * c00 - r10 * c11 + r11 * c10;
      var s10 = r00 * c10 + r01 * c11 + r10 * c00 - r11 * c01;
      var s11 = r00 * c11 + r01 * c10 - r10 * c01 + r11 * c00;
      var k00 = b00 * s00 + b01 * s01 + b10 * s10 - b11 * s11;
      var i00 = s00 / k00;
      var i01 = s01 / k00;
      var i10 = s10 / k00;
      var i11 = s11 / k00;
      var x00 = a00 * i00 + a01 * i01 + a10 * i10 - a11 * i11;
      var x01 = a00 * i01 + a01 * i00 - a10 * i11 + a11 * i10;
      var x10 = a00 * i10 + a01 * i11 + a10 * i00 - a11 * i01;
      var x11 = a00 * i11 + a01 * i10 - a10 * i01 + a11 * i00;
      if (typeof m !== 'undefined') {
        m[PROP_W] = x00;
        m[PROP_X] = x01;
        m[PROP_Y] = x10;
        m[PROP_XY] = x11;
      } else {
        return coordsJsToE2Py(x00, x01, x10, x11);
      }
    }
    mod[SCALAR_E2] = Sk.ffi.functionPy(function (w) {
      Sk.ffi.checkFunctionArgs(SCALAR_E2, arguments, 1, 1);
      Sk.ffi.checkArgType(PROP_W, NUM, Sk.ffi.isNum(w), w);
      return coordsJsToE2Py(Sk.ffi.remapToJs(w), 0, 0, 0);
    });
    mod[VECTOR_E2] = Sk.ffi.functionPy(function (x, y) {
      Sk.ffi.checkFunctionArgs(VECTOR_E2, arguments, 2, 2);
      Sk.ffi.checkArgType(PROP_X, NUM, Sk.ffi.isNum(x), x);
      Sk.ffi.checkArgType(PROP_Y, NUM, Sk.ffi.isNum(y), y);
      return coordsJsToE2Py(0, Sk.ffi.remapToJs(x), Sk.ffi.remapToJs(y), 0);
    });
    mod[PSEUDOSCALAR_E2] = Sk.ffi.functionPy(function (xy) {
      Sk.ffi.checkFunctionArgs(PSEUDOSCALAR_E2, arguments, 1, 1);
      Sk.ffi.checkArgType(PROP_XY, NUM, Sk.ffi.isNum(xy), xy);
      return coordsJsToE2Py(0, 0, 0, Sk.ffi.remapToJs(xy));
    });
    mod[EUCLIDEAN_2] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, x00, x01, x10, x11) {
        Sk.ffi.checkMethodArgs(EUCLIDEAN_2, arguments, 1, 4);
        switch (Sk.ffi.getType(x00)) {
        case Sk.ffi.PyType.FLOAT:
        case Sk.ffi.PyType.INT:
        case Sk.ffi.PyType.LONG: {
            Sk.ffi.checkMethodArgs(EUCLIDEAN_2, arguments, 4, 4);
            Sk.ffi.checkArgType(PROP_W, NUM, Sk.ffi.isNum(x00), x00);
            Sk.ffi.checkArgType(PROP_X, NUM, Sk.ffi.isNum(x01), x01);
            Sk.ffi.checkArgType(PROP_Y, NUM, Sk.ffi.isNum(x10), x10);
            Sk.ffi.checkArgType(PROP_XY, NUM, Sk.ffi.isNum(x11), x11);
            Sk.ffi.referenceToPy(new BLADE.Euclidean2(Sk.ffi.remapToJs(x00), Sk.ffi.remapToJs(x01), Sk.ffi.remapToJs(x10), Sk.ffi.remapToJs(x11)), EUCLIDEAN_2, undefined, selfPy);
          }
          break;
        case Sk.ffi.PyType.INSTANCE: {
            Sk.ffi.checkMethodArgs(EUCLIDEAN_2, arguments, 1, 1);
            Sk.ffi.checkArgType(PROP_W, NUM, isEuclidean2Py(x00), x00);
            Sk.ffi.referenceToPy(Sk.ffi.remapToJs(x00), EUCLIDEAN_2, undefined, selfPy);
          }
          break;
        default: {
            Sk.ffi.checkArgType(PROP_W, NUM, false, x00);
          }
        }
      });
      $loc.__add__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var lhs = Sk.ffi.remapToJs(selfPy);
        var rhs = Sk.ffi.remapToJs(otherPy);
        if (Sk.ffi.isNum(otherPy)) {
          return coordsJsToE2Py(lhs.w + rhs, lhs.x, lhs.y, lhs.xy);
        } else if (isEuclidean2Py(otherPy)) {
          return coordsJsToE2Py(lhs.w + rhs.w, lhs.x + rhs.x, lhs.y + rhs.y, lhs.xy + rhs.xy);
        } else {
          return undefined;
        }
      });
      $loc.__radd__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkLhsOperandType(OP_ADD, NUM, Sk.ffi.isNum(otherPy), otherPy);
        var lhs = Sk.ffi.remapToJs(otherPy);
        var rhs = Sk.ffi.remapToJs(selfPy);
        return coordsJsToE2Py(lhs + rhs.w, rhs.x, rhs.y, rhs.xy);
      });
      $loc.__iadd__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var other = Sk.ffi.remapToJs(otherPy);
        if (Sk.ffi.isNum(otherPy)) {
          self.w += other;
          return selfPy;
        } else if (isEuclidean2Py(otherPy)) {
          self.w += other.w;
          self.x += other.x;
          self.y += other.y;
          self.xy += other.xy;
          return selfPy;
        } else {
          return undefined;
        }
      });
      $loc.__sub__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var lhs = Sk.ffi.remapToJs(selfPy);
        var rhs = Sk.ffi.remapToJs(otherPy);
        if (Sk.ffi.isNum(otherPy)) {
          return coordsJsToE2Py(lhs.w - rhs, lhs.x, lhs.y, lhs.xy);
        } else if (isEuclidean2Py(otherPy)) {
          return coordsJsToE2Py(lhs.w - rhs.w, lhs.x - rhs.x, lhs.y - rhs.y, lhs.xy - rhs.xy);
        } else {
          return undefined;
        }
      });
      $loc.__rsub__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkLhsOperandType(OP_ADD, NUM, Sk.ffi.isNum(otherPy), otherPy);
        var lhs = Sk.ffi.remapToJs(otherPy);
        var rhs = Sk.ffi.remapToJs(selfPy);
        return coordsJsToE2Py(lhs - rhs.w, -rhs.x, -rhs.y, -rhs.xy);
      });
      $loc.__isub__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var other = Sk.ffi.remapToJs(otherPy);
        if (isNumber(other)) {
          self.w -= other;
          return selfPy;
        } else {
          self.w -= other.w;
          self.x -= other.x;
          self.y -= other.y;
          self.xy -= other.xy;
          return selfPy;
        }
      });
      $loc.__mul__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        switch (Sk.ffi.getType(otherPy)) {
        case Sk.ffi.PyType.INSTANCE: {
            switch (Sk.ffi.typeName(otherPy)) {
            case EUCLIDEAN_2: {
                var a = Sk.ffi.remapToJs(selfPy);
                var b = Sk.ffi.remapToJs(otherPy);
                var a00 = a.w;
                var a01 = a.x;
                var a10 = a.y;
                var a11 = a.xy;
                var b00 = b.w;
                var b01 = b.x;
                var b10 = b.y;
                var b11 = b.xy;
                var x00 = a00 * b00 + a01 * b01 + a10 * b10 - a11 * b11;
                var x01 = a00 * b01 + a01 * b00 - a10 * b11 + a11 * b10;
                var x10 = a00 * b10 + a01 * b11 + a10 * b00 - a11 * b01;
                var x11 = a00 * b11 + a01 * b10 - a10 * b01 + a11 * b00;
                return coordsJsToE2Py(x00, x01, x10, x11);
              }
            default: {
                return undefined;
              }
            }
          }
        case Sk.ffi.PyType.FLOAT:
        case Sk.ffi.PyType.INT:
        case Sk.ffi.PyType.LONG: {
            var a = Sk.ffi.remapToJs(selfPy);
            var b = Sk.ffi.remapToJs(otherPy);
            return coordsJsToE2Py(a.w * b, a.x * b, a.y * b, a.xy * b);
          }
        default: {
            return undefined;
          }
        }
      });
      $loc.__rmul__ = Sk.ffi.functionPy(function (rhs, lhs) {
        lhs = Sk.ffi.remapToJs(lhs);
        rhs = Sk.ffi.remapToJs(rhs);
        if (isNumber(lhs)) {
          return coordsJsToE2Py(lhs * rhs.w, lhs * rhs.x, lhs * rhs.y, lhs * rhs.xy);
        } else {
          return undefined;
        }
      });
      $loc.__imul__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var other = Sk.ffi.remapToJs(otherPy);
        if (isNumber(other)) {
          self.w *= other;
          self.x *= other;
          self.y *= other;
          self.xy *= other;
          return selfPy;
        } else {
          var a00 = self.w;
          var a01 = self.x;
          var a10 = self.y;
          var a11 = self.xy;
          var b00 = other.w;
          var b01 = other.x;
          var b10 = other.y;
          var b11 = other.xy;
          self.w = a00 * b00 + a01 * b01 + a10 * b10 - a11 * b11;
          self.x = a00 * b01 + a01 * b00 - a10 * b11 + a11 * b10;
          self.y = a00 * b10 + a01 * b11 + a10 * b00 - a11 * b01;
          self.xy = a00 * b11 + a01 * b10 - a10 * b01 + a11 * b00;
          return selfPy;
        }
      });
      $loc.__div__ = Sk.ffi.functionPy(function (a, b) {
        a = Sk.ffi.remapToJs(a);
        b = Sk.ffi.remapToJs(b);
        if (isNumber(b)) {
          return divide(a.w, a.x, a.y, a.xy, b, 0, 0, 0, undefined);
        } else {
          return divide(a.w, a.x, a.y, a.xy, b.w, b.x, b.y, b.xy, undefined);
        }
      });
      $loc.__rdiv__ = Sk.ffi.functionPy(function (rhs, lhs) {
        lhs = Sk.ffi.remapToJs(lhs);
        rhs = Sk.ffi.remapToJs(rhs);
        if (isNumber(lhs)) {
          return divide(lhs, 0, 0, 0, rhs.w, rhs.x, rhs.y, rhs.xy, undefined);
        } else {
          throw new Sk.builtin.AssertionError('' + JSON.stringify(lhs, null, 2) + ' / ' + JSON.stringify(rhs, null, 2));
        }
      });
      $loc.__idiv__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var other = Sk.ffi.remapToJs(otherPy);
        if (isNumber(other)) {
          divide(self.w, self.x, self.y, self.xy, other, 0, 0, 0, self);
          return selfPy;
        } else {
          divide(self.w, self.x, self.y, self.xy, other.w, other.x, other.y, other.xy, self);
          return selfPy;
        }
      });
      $loc.__mod__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        switch (Sk.ffi.getType(otherPy)) {
        case Sk.ffi.PyType.INSTANCE: {
            switch (Sk.ffi.typeName(otherPy)) {
            case EUCLIDEAN_2: {
                var a = Sk.ffi.remapToJs(selfPy);
                var b = Sk.ffi.remapToJs(otherPy);
                var a00 = a.w;
                var a01 = a.x;
                var a10 = a.y;
                var a11 = a.xy;
                var b00 = b.w;
                var b01 = b.x;
                var b10 = b.y;
                var b11 = b.xy;
                return coordsJsToE2Py(a.w * b.w + a.x * b.x + a.y * b.y + a.xy * b.xy, 0, 0, 0);
              }
            default: {
                return undefined;
              }
            }
          }
        case Sk.ffi.PyType.FLOAT:
        case Sk.ffi.PyType.INT:
        case Sk.ffi.PyType.LONG: {
            var a = Sk.ffi.remapToJs(selfPy);
            var b = Sk.ffi.remapToJs(otherPy);
            return coordsJsToE2Py(a.w * b, a.x * b, a.y * b, a.xy * b);
          }
        default: {
            return undefined;
          }
        }
      });
      $loc.__rmod__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var rhs = Sk.ffi.remapToJs(selfPy);
        var lhs = Sk.ffi.remapToJs(otherPy);
        if (isNumber(lhs)) {
          return coordsJsToE2Py(lhs * rhs.w, lhs * rhs.x, lhs * rhs.y, lhs * rhs.xy);
        } else {
          return undefined;
        }
      });
      $loc.__xor__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        switch (Sk.ffi.getType(otherPy)) {
        case Sk.ffi.PyType.INSTANCE: {
            switch (Sk.ffi.typeName(otherPy)) {
            case EUCLIDEAN_2: {
                var a = Sk.ffi.remapToJs(selfPy);
                var b = Sk.ffi.remapToJs(otherPy);
                var a00 = a.w;
                var a01 = a.x;
                var a10 = a.y;
                var a11 = a.xy;
                var b00 = b.w;
                var b01 = b.x;
                var b10 = b.y;
                var b11 = b.xy;
                var x00 = a00 * b00;
                var x01 = a00 * b01 + a01 * b00;
                var x10 = a00 * b10 + a10 * b00;
                var x11 = a00 * b11 + a01 * b10 - a10 * b01 + a11 * b00;
                return coordsJsToE2Py(x00, x01, x10, x11);
              }
            default: {
                return undefined;
              }
            }
          }
        case Sk.ffi.PyType.FLOAT:
        case Sk.ffi.PyType.INT:
        case Sk.ffi.PyType.LONG: {
            var a = Sk.ffi.remapToJs(selfPy);
            var b = Sk.ffi.remapToJs(otherPy);
            return coordsJsToE2Py(a.w * b, a.x * b, a.y * b, a.xy * b);
          }
        default: {
            return undefined;
          }
        }
      });
      $loc.__rxor__ = Sk.ffi.functionPy(function (rhs, lhs) {
        lhs = Sk.ffi.remapToJs(lhs);
        rhs = Sk.ffi.remapToJs(rhs);
        if (isNumber(lhs)) {
          return coordsJsToE2Py(lhs * rhs.w, lhs * rhs.x, lhs * rhs.y, lhs * rhs.xy);
        } else {
          return undefined;
        }
      });
      $loc.__ixor__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var other = Sk.ffi.remapToJs(otherPy);
        if (isNumber(other)) {
          self.w *= other;
          self.x *= other;
          self.y *= other;
          self.xy *= other;
          return selfPy;
        } else {
          var a00 = self.w;
          var a01 = self.x;
          var a10 = self.y;
          var a11 = self.xy;
          var b00 = other.w;
          var b01 = other.x;
          var b10 = other.y;
          var b11 = other.xy;
          self.w = a00 * b00;
          self.x = a00 * b01 + a01 * b00;
          self.y = a00 * b10 + a10 * b00;
          self.xy = a00 * b11 + a01 * b10 - a10 * b01 + a11 * b00;
          return selfPy;
        }
      });
      $loc.__lshift__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        switch (Sk.ffi.getType(otherPy)) {
        case Sk.ffi.PyType.INSTANCE: {
            switch (Sk.ffi.typeName(otherPy)) {
            case EUCLIDEAN_2: {
                var a = Sk.ffi.remapToJs(selfPy);
                var b = Sk.ffi.remapToJs(otherPy);
                var a00 = a.w;
                var a01 = a.x;
                var a10 = a.y;
                var a11 = a.xy;
                var b00 = b.w;
                var b01 = b.x;
                var b10 = b.y;
                var b11 = b.xy;
                var x00 = a00 * b00 + a01 * b01 + a10 * b10 - a11 * b11;
                var x01 = a00 * b01 - a10 * b11;
                var x10 = a00 * b10 + a01 * b11;
                var x11 = a00 * b11;
                return coordsJsToE2Py(x00, x01, x10, x11);
              }
            default: {
                return undefined;
              }
            }
          }
        case Sk.ffi.PyType.FLOAT:
        case Sk.ffi.PyType.INT:
        case Sk.ffi.PyType.LONG: {
            var a = Sk.ffi.remapToJs(selfPy);
            var b = Sk.ffi.remapToJs(otherPy);
            return coordsJsToE2Py(a.w * b, 0, 0, 0);
          }
        default: {
            return undefined;
          }
        }
      });
      $loc.__rlshift__ = Sk.ffi.functionPy(function (rhs, lhs) {
        lhs = Sk.ffi.remapToJs(lhs);
        rhs = Sk.ffi.remapToJs(rhs);
        if (isNumber(lhs)) {
          return coordsJsToE2Py(lhs * rhs.w, lhs * rhs.x, lhs * rhs.y, lhs * rhs.xy);
        } else {
          return undefined;
        }
      });
      $loc.__ilshift__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var other = Sk.ffi.remapToJs(otherPy);
        if (isNumber(other)) {
          self.w *= other;
          self.x = 0;
          self.y = 0;
          self.xy = 0;
          return selfPy;
        } else {
          var a00 = self.w;
          var a01 = self.x;
          var a10 = self.y;
          var a11 = self.xy;
          var b00 = other.w;
          var b01 = other.x;
          var b10 = other.y;
          var b11 = other.xy;
          self.w = a00 * b00 + a01 * b01 + a10 * b10 - a11 * b11;
          self.x = a00 * b01 - a10 * b11;
          self.y = a00 * b10 + a01 * b11;
          self.xy = a00 * b11;
          return selfPy;
        }
      });
      $loc.__rshift__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        switch (Sk.ffi.getType(otherPy)) {
        case Sk.ffi.PyType.INSTANCE: {
            switch (Sk.ffi.typeName(otherPy)) {
            case EUCLIDEAN_2: {
                var a = Sk.ffi.remapToJs(selfPy);
                var b = Sk.ffi.remapToJs(otherPy);
                var a00 = a.w;
                var a01 = a.x;
                var a10 = a.y;
                var a11 = a.xy;
                var b00 = b.w;
                var b01 = b.x;
                var b10 = b.y;
                var b11 = b.xy;
                var x00 = a00 * b00 + a01 * b01 + a10 * b10 - a11 * b11;
                var x01 = +a01 * b00 + a11 * b10;
                var x10 = +a10 * b00 - a11 * b01;
                var x11 = a11 * b00;
                return coordsJsToE2Py(x00, x01, x10, x11);
              }
            default: {
                return undefined;
              }
            }
          }
        case Sk.ffi.PyType.FLOAT:
        case Sk.ffi.PyType.INT:
        case Sk.ffi.PyType.LONG: {
            var a = Sk.ffi.remapToJs(selfPy);
            var b = Sk.ffi.remapToJs(otherPy);
            return coordsJsToE2Py(a.w * b, -a.x * b, -a.y * b, a.xy * b);
          }
        default: {
            return undefined;
          }
        }
      });
      $loc.__rrshift__ = Sk.ffi.functionPy(function (rhs, lhs) {
        lhs = Sk.ffi.remapToJs(lhs);
        rhs = Sk.ffi.remapToJs(rhs);
        if (isNumber(lhs)) {
          return coordsJsToE2Py(lhs * rhs.w, 0, 0, 0);
        } else {
          return undefined;
        }
      });
      $loc.__irshift__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var other = Sk.ffi.remapToJs(otherPy);
        if (isNumber(other)) {
          var a00 = self.w;
          var a01 = self.x;
          var a10 = self.y;
          var a11 = self.xy;
          var b00 = other;
          var b01 = 0;
          var b10 = 0;
          var b11 = 0;
          self.w *= other;
          self.x *= -other;
          self.y *= -other;
          self.xy *= other;
          return selfPy;
        } else {
          var a00 = self.w;
          var a01 = self.x;
          var a10 = self.y;
          var a11 = self.xy;
          var b00 = other.w;
          var b01 = other.x;
          var b10 = other.y;
          var b11 = other.xy;
          self.w = a00 * b00 + a01 * b01 + a10 * b10 - a11 * b11;
          self.x = +a01 * b00 + a11 * b10;
          self.y = +a10 * b00 - a11 * b01;
          self.xy = a11 * b00;
          return selfPy;
        }
      });
      $loc.nu$negative = function () {
        var self = Sk.ffi.remapToJs(this);
        return coordsJsToE2Py(-self.w, -self.x, -self.y, -self.xy);
      };
      $loc.nb$positive = function () {
        return this;
      };
      $loc.nb$invert = function () {
        var self = Sk.ffi.remapToJs(this);
        return coordsJsToE2Py(self.w, self.x, self.y, -self.xy);
      };
      $loc.__getitem__ = Sk.ffi.functionPy(function (mv, index) {
        mv = Sk.ffi.remapToJs(mv);
        index = Sk.ffi.remapToJs(index);
        switch (index) {
        case 0: {
            return coordsJsToE2Py(mv.w, 0, 0, 0);
          }
        case 1: {
            return coordsJsToE2Py(0, mv.x, mv.y, 0);
          }
        case 2: {
            return coordsJsToE2Py(0, 0, 0, mv.xy);
          }
        }
      });
      $loc.__cliffordConjugate__ = Sk.ffi.functionPy(function (selfPy) {
        Sk.ffi.checkMethodArgs(METHOD_CLIFFORD_CONJUGATE, arguments, 0, 0);
        var self = Sk.ffi.remapToJs(selfPy);
        return coordsJsToE2Py(self.w, -self.x, -self.y, -self.xy);
      });
      $loc.__cos__ = Sk.ffi.functionPy(function (selfPy) {
        Sk.ffi.checkMethodArgs(METHOD_COS, arguments, 0, 0);
        var mv = Sk.ffi.remapToJs(selfPy);
        var x = mv.w;
        var y = mv.xy;
        var cosX = Sk.math.cos(x);
        var coshY = cosh(y);
        var sinX = Sk.math.sin(x);
        var sinhY = sinh(y);
        return coordsJsToE2Py(cosX * coshY, 0, 0, -sinX * sinhY);
      });
      $loc.__sin__ = Sk.ffi.functionPy(function (selfPy) {
        Sk.ffi.checkMethodArgs(METHOD_SIN, arguments, 0, 0);
        var mv = Sk.ffi.remapToJs(selfPy);
        var x = mv.w;
        var y = mv.xy;
        var cosX = Sk.math.cos(x);
        var coshY = cosh(y);
        var sinX = Sk.math.sin(x);
        var sinhY = sinh(y);
        return coordsJsToE2Py(sinX * coshY, 0, 0, cosX * sinhY);
      });
      $loc.__exp__ = Sk.ffi.functionPy(function (selfPy) {
        Sk.ffi.checkMethodArgs(METHOD_EXP, arguments, 0, 0);
        var mv = Sk.ffi.remapToJs(selfPy);
        var x = mv.w;
        var y = mv.xy;
        var e = Math.exp(x);
        var c = Sk.math.cos(y);
        var s = Sk.math.sin(y);
        return coordsJsToE2Py(e * c, 0, 0, e * s);
      });
      $loc.__abs__ = Sk.ffi.functionPy(function (selfPy) {
        var mv = Sk.ffi.remapToJs(selfPy);
        return Sk.ffi.numberToFloatPy(Math.sqrt(mv.w * mv.w + mv.x * mv.x + mv.y * mv.y + mv.xy * mv.xy));
      });
      $loc.__magnitude__ = Sk.ffi.functionPy(function (selfPy) {
        var mv = Sk.ffi.remapToJs(selfPy);
        return coordsJsToE2Py(Math.sqrt(mv.w * mv.w + mv.x * mv.x + mv.y * mv.y + mv.xy * mv.xy), 0, 0, 0);
      });
      $loc.__quadrance__ = Sk.ffi.functionPy(function (selfPy) {
        var mv = Sk.ffi.remapToJs(selfPy);
        return coordsJsToE2Py(mv.w * mv.w + mv.x * mv.x + mv.y * mv.y + mv.xy * mv.xy, 0, 0, 0);
      });
      $loc.__sqrt__ = Sk.ffi.functionPy(function (selfPy) {
        Sk.ffi.checkMethodArgs(METHOD_SQRT, arguments, 0, 0);
        var mv = Sk.ffi.remapToJs(selfPy);
        return coordsJsToE2Py(Math.sqrt(mv.w), 0, 0, 0);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (mv) {
        mv = Sk.ffi.remapToJs(mv);
        return Sk.ffi.stringToPy(EUCLIDEAN_2 + '(' + [
          mv.w,
          mv.x,
          mv.y,
          mv.xy
        ].map(function (x) {
          return String(x);
        }).join(', ') + ')');
      });
      $loc.__str__ = Sk.ffi.functionPy(function (mv) {
        mv = Sk.ffi.remapToJs(mv);
        if (mv.isNaN()) {
          return Sk.ffi.stringToPy('NaN');
        } else {
          return Sk.ffi.stringToPy(stringFromCoordinates([
            mv.w,
            mv.x,
            mv.y,
            mv.xy
          ], [
            ONE_NAME,
            E1_NAME,
            E2_NAME,
            PSEUDOSCALAR_NAME
          ], '*'));
        }
      });
      $loc.__eq__ = Sk.ffi.functionPy(function (a, b) {
        a = Sk.ffi.remapToJs(a);
        b = Sk.ffi.remapToJs(b);
        return a.w === b.w && a.x === b.x && a.y === b.y && a.xy === b.xy;
      });
      $loc.__ne__ = Sk.ffi.functionPy(function (a, b) {
        a = Sk.ffi.remapToJs(a);
        b = Sk.ffi.remapToJs(b);
        return a.w !== b.w || a.x !== b.x || a.y !== b.y || a.xy !== b.xy;
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (mvPy, name) {
        var mv = Sk.ffi.remapToJs(mvPy);
        switch (name) {
        case PROP_W: {
            return Sk.ffi.numberToFloatPy(mv[PROP_W]);
          }
        case PROP_X: {
            return Sk.ffi.numberToFloatPy(mv[PROP_X]);
          }
        case PROP_Y: {
            return Sk.ffi.numberToFloatPy(mv[PROP_Y]);
          }
        case PROP_XY: {
            return Sk.ffi.numberToFloatPy(mv[PROP_XY]);
          }
        case METHOD_CLONE: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (methodPy) {
              });
              $loc.__call__ = Sk.ffi.functionPy(function (methodPy) {
                return coordsJsToE2Py(mv.w, mv.x, mv.y, mv.xy);
              });
            }, METHOD_CLONE, []));
          }
        case METHOD_MAGNITUDE: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (self) {
              });
              $loc.__call__ = Sk.ffi.functionPy(function (self) {
                return Sk.ffi.numberToFloatPy(Math.sqrt(mv.w * mv.w + mv.x * mv.x + mv.y * mv.y - mv.xy * mv.xy));
              });
            }, METHOD_MAGNITUDE, []));
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(EUCLIDEAN_2);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        var self = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case PROP_W:
        case PROP_X:
        case PROP_Y:
        case PROP_XY: {
            Sk.ffi.checkArgType(name, [
              Sk.ffi.PyType.FLOAT,
              Sk.ffi.PyType.INT,
              Sk.ffi.PyType.LONG
            ], Sk.ffi.isNum(valuePy), valuePy);
            self[name] = Sk.ffi.remapToJs(valuePy);
          }
          break;
        default: {
            throw Sk.ffi.err.attribute(name).isNotSetableOnType(EUCLIDEAN_2);
          }
        }
      });
    }, EUCLIDEAN_2, []);
  };
}.call(this));
Sk.e3ga = Sk.e3ga || {};
Sk.e3ga.EUCLIDEAN_3 = 'Euclidean3';
Sk.e3ga.SCALAR_E3 = 'ScalarE3';
Sk.e3ga.VECTOR_E3 = 'VectorE3';
Sk.e3ga.BIVECTOR_E3 = 'BivectorE3';
Sk.e3ga.PSEUDOSCALAR_E3 = 'PseudoscalarE3';
(function () {
  Sk.builtin.defineEuclidean3 = function (mod, THREE, BLADE) {
    Sk.ffi.checkFunctionArgs('defineEuclidean3', arguments, 3, 3);
    Sk.builtin.defineVector3(mod, THREE);
    Sk.builtin.defineQuaternion(mod, THREE);
    var VECTOR_3 = 'Vector3';
    var QUATERNION = 'Quaternion';
    var DIMENSIONS = 'Dimensions';
    var RATIONAL = 'Rational';
    var PROP_VECTOR = 'vector';
    var PROP_QUATERNION = 'quaternion';
    var PROP_MUTABLE = 'mutable';
    var PROP_W = 'w';
    var PROP_X = 'x';
    var PROP_Y = 'y';
    var PROP_Z = 'z';
    var PROP_XY = 'xy';
    var PROP_YZ = 'yz';
    var PROP_ZX = 'zx';
    var PROP_XYZ = 'xyz';
    var METHOD_ADD = 'add';
    var METHOD_APPLY_MATRIX_3 = 'applyMatrix3';
    var METHOD_APPLY_MATRIX_4 = 'applyMatrix4';
    var METHOD_CLIFFORD_CONJUGATE = 'cliffordConjugate';
    var METHOD_CLONE = 'clone';
    var METHOD_CROSS = 'cross';
    var METHOD_DISTANCE_TO = 'distanceTo';
    var METHOD_DISTANCE_TO_SQUARED = 'distanceToSquared';
    var METHOD_DOT = 'dot';
    var METHOD_EXP = 'exp';
    var METHOD_COPY = 'copy';
    var METHOD_CONSTANTIFY = 'constantify';
    var METHOD_DIVIDE_SCALAR = 'divideScalar';
    var METHOD_MAGNITUDE = 'magnitude';
    var METHOD_MULTIPLY_SCALAR = 'multiplyScalar';
    var METHOD_NORMALIZE = 'normalize';
    var METHOD_SET = 'set';
    var METHOD_SET_X = 'setX';
    var METHOD_SET_Y = 'setY';
    var METHOD_SET_Z = 'setZ';
    var METHOD_SQRT = 'sqrt';
    var METHOD_SUB = 'sub';
    var METHOD_GET_COMPONENT = 'getComponent';
    var METHOD_SET_COMPONENT = 'setComponent';
    var OP_ADD = 'add';
    var OP_SUB = 'subtract';
    var OP_MUL = 'multiply';
    var OP_DIV = 'divide';
    var OP_EQ = 'equal';
    var ARG_INDEX = 'index';
    var ARG_OTHER = 'other';
    var ARG_S = 's';
    var ARG_SELF = 'self';
    var ARG_VALUE = 'value';
    var UNIT_SCALAR_NAME = '1';
    var UNIT_VECTOR_NAME_E1 = 'e1';
    var UNIT_VECTOR_NAME_E2 = 'e2';
    var UNIT_VECTOR_NAME_E3 = 'e3';
    var PSEUDOSCALAR_NAME = 'I';
    var UNIT_BIVECTOR_NAME_E12 = 'e12';
    var UNIT_BIVECTOR_NAME_E23 = 'e23';
    var UNIT_BIVECTOR_NAME_E31 = 'e31';
    THREE.Euclidean3 = function (vector, quaternion, xyz, mutable) {
      if (typeof vector !== 'object') {
        throw new Error('43a75b65-8614-4836-9829-377eaeee7cfe');
      }
      if (typeof quaternion !== 'object') {
        throw new Error('89fb1d18-dc26-4149-913d-58f192c161d7');
      }
      if (typeof xyz !== 'number') {
        throw new Error('09e5e46b-fdf4-4720-9262-5c2503c84dc6');
      }
      this.vector = vector;
      this.quaternion = quaternion;
      this._pseudo = xyz;
      this._mutable = typeof mutable === 'boolean' ? mutable : true;
    };
    THREE.Euclidean3.prototype = {
      constructor: THREE.Euclidean3,
      get w() {
        return this.quaternion.w;
      },
      set w(value) {
        this.checkMutable();
        this.quaternion.w = value;
      },
      get x() {
        return this.vector.x;
      },
      set x(value) {
        this.checkMutable();
        this.vector.x = value;
      },
      get y() {
        return this.vector.y;
      },
      set y(value) {
        this.checkMutable();
        this.vector.y = value;
      },
      get z() {
        return this.vector.z;
      },
      set z(value) {
        this.checkMutable();
        this.vector.z = value;
      },
      get xy() {
        return -this.quaternion.z;
      },
      set xy(value) {
        this.checkMutable();
        this.quaternion.z = -value;
      },
      get yz() {
        return -this.quaternion.x;
      },
      set yz(value) {
        this.checkMutable();
        this.quaternion.x = -value;
      },
      get zx() {
        return -this.quaternion.y;
      },
      set zx(value) {
        this.checkMutable();
        this.quaternion.y = -value;
      },
      get xyz() {
        return this._pseudo;
      },
      set xyz(value) {
        this.checkMutable();
        this._pseudo = value;
      },
      get mutable() {
        return this._mutable;
      },
      set mutable(value) {
        this._mutable = value;
      },
      checkMutable: function () {
        if (!this._mutable) {
          throw Sk.ffi.assertionError('Quantity is not mutable');
        }
      }
    };
    function isNumber(x) {
      return typeof x === 'number';
    }
    function isEuclidean3Py(valuePy) {
      return Sk.ffi.isInstance(valuePy, Sk.e3ga.EUCLIDEAN_3);
    }
    function coordsJsToE3Py(w, x, y, z, xy, yz, zx, xyz, mutable) {
      var wPy = Sk.ffi.numberToFloatPy(w);
      var xPy = Sk.ffi.numberToFloatPy(x);
      var yPy = Sk.ffi.numberToFloatPy(y);
      var zPy = Sk.ffi.numberToFloatPy(z);
      var xyPy = Sk.ffi.numberToFloatPy(xy);
      var yzPy = Sk.ffi.numberToFloatPy(yz);
      var zxPy = Sk.ffi.numberToFloatPy(zx);
      var xyzPy = Sk.ffi.numberToFloatPy(xyz);
      var mutablePy = Sk.ffi.booleanToPy(mutable);
      return Sk.ffi.callsim(mod[Sk.e3ga.EUCLIDEAN_3], wPy, xPy, yPy, zPy, xyPy, yzPy, zxPy, xyzPy, mutablePy);
    }
    function stringFromCoordinates(coordinates, labels) {
      var append, i, sb, str, _i, _ref;
      sb = [];
      append = function (number, label) {
        var n;
        if (number !== 0) {
          if (number >= 0) {
            if (sb.length > 0) {
              sb.push('+');
            }
          } else {
            sb.push('-');
          }
          n = Math.abs(number);
          if (n === 1) {
            return sb.push(label);
          } else {
            sb.push(n.toString());
            if (label !== '1') {
              sb.push('*');
              return sb.push(label);
            }
          }
        }
      };
      for (i = _i = 0, _ref = coordinates.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        append(coordinates[i], labels[i]);
      }
      if (sb.length > 0) {
        str = sb.join('');
      } else {
        str = '0';
      }
      return str;
    }
    function mulE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, index) {
      a0 = +a0;
      a1 = +a1;
      a2 = +a2;
      a3 = +a3;
      a4 = +a4;
      a5 = +a5;
      a6 = +a6;
      a7 = +a7;
      b0 = +b0;
      b1 = +b1;
      b2 = +b2;
      b3 = +b3;
      b4 = +b4;
      b5 = +b5;
      b6 = +b6;
      b7 = +b7;
      index = index | 0;
      var x = 0;
      switch (~~index) {
      case 0: {
          x = +(a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3 - a4 * b4 - a5 * b5 - a6 * b6 - a7 * b7);
        }
        break;
      case 1: {
          x = +(a0 * b1 + a1 * b0 - a2 * b4 + a3 * b6 + a4 * b2 - a5 * b7 - a6 * b3 - a7 * b5);
        }
        break;
      case 2: {
          x = +(a0 * b2 + a1 * b4 + a2 * b0 - a3 * b5 - a4 * b1 + a5 * b3 - a6 * b7 - a7 * b6);
        }
        break;
      case 3: {
          x = +(a0 * b3 - a1 * b6 + a2 * b5 + a3 * b0 - a4 * b7 - a5 * b2 + a6 * b1 - a7 * b4);
        }
        break;
      case 4: {
          x = +(a0 * b4 + a1 * b2 - a2 * b1 + a3 * b7 + a4 * b0 - a5 * b6 + a6 * b5 + a7 * b3);
        }
        break;
      case 5: {
          x = +(a0 * b5 + a1 * b7 + a2 * b3 - a3 * b2 + a4 * b6 + a5 * b0 - a6 * b4 + a7 * b1);
        }
        break;
      case 6: {
          x = +(a0 * b6 - a1 * b3 + a2 * b7 + a3 * b1 - a4 * b5 + a5 * b4 + a6 * b0 + a7 * b2);
        }
        break;
      case 7: {
          x = +(a0 * b7 + a1 * b5 + a2 * b6 + a3 * b4 + a4 * b3 + a5 * b1 + a6 * b2 + a7 * b0);
        }
        break;
      default: {
        }
      }
      return +x;
    }
    function extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, index) {
      a0 = +a0;
      a1 = +a1;
      a2 = +a2;
      a3 = +a3;
      a4 = +a4;
      a5 = +a5;
      a6 = +a6;
      a7 = +a7;
      b0 = +b0;
      b1 = +b1;
      b2 = +b2;
      b3 = +b3;
      b4 = +b4;
      b5 = +b5;
      b6 = +b6;
      b7 = +b7;
      index = index | 0;
      var x = 0;
      switch (~~index) {
      case 0: {
          x = +(a0 * b0);
        }
        break;
      case 1: {
          x = +(a0 * b1 + a1 * b0);
        }
        break;
      case 2: {
          x = +(a0 * b2 + a2 * b0);
        }
        break;
      case 3: {
          x = +(a0 * b3 + a3 * b0);
        }
        break;
      case 4: {
          x = +(a0 * b4 + a1 * b2 - a2 * b1 + a4 * b0);
        }
        break;
      case 5: {
          x = +(a0 * b5 + a2 * b3 - a3 * b2 + a5 * b0);
        }
        break;
      case 6: {
          x = +(a0 * b6 - a1 * b3 + a3 * b1 + a6 * b0);
        }
        break;
      case 7: {
          x = +(a0 * b7 + a1 * b5 + a2 * b6 + a3 * b4 + a4 * b3 + a5 * b1 + a6 * b2 + a7 * b0);
        }
        break;
      default: {
        }
      }
      return +x;
    }
    function lcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, index) {
      a0 = +a0;
      a1 = +a1;
      a2 = +a2;
      a3 = +a3;
      a4 = +a4;
      a5 = +a5;
      a6 = +a6;
      a7 = +a7;
      b0 = +b0;
      b1 = +b1;
      b2 = +b2;
      b3 = +b3;
      b4 = +b4;
      b5 = +b5;
      b6 = +b6;
      b7 = +b7;
      index = index | 0;
      var x = 0;
      switch (~~index) {
      case 0: {
          x = +(a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3 - a4 * b4 - a5 * b5 - a6 * b6 - a7 * b7);
        }
        break;
      case 1: {
          x = +(a0 * b1 - a2 * b4 + a3 * b6 - a5 * b7);
        }
        break;
      case 2: {
          x = +(a0 * b2 + a1 * b4 - a3 * b5 - a6 * b7);
        }
        break;
      case 3: {
          x = +(a0 * b3 - a1 * b6 + a2 * b5 - a4 * b7);
        }
        break;
      case 4: {
          x = +(a0 * b4 + a3 * b7);
        }
        break;
      case 5: {
          x = +(a0 * b5 + a1 * b7);
        }
        break;
      case 6: {
          x = +(a0 * b6 + a2 * b7);
        }
        break;
      case 7: {
          x = +(a0 * b7);
        }
        break;
      default: {
        }
      }
      return +x;
    }
    function rcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, index) {
      a0 = +a0;
      a1 = +a1;
      a2 = +a2;
      a3 = +a3;
      a4 = +a4;
      a5 = +a5;
      a6 = +a6;
      a7 = +a7;
      b0 = +b0;
      b1 = +b1;
      b2 = +b2;
      b3 = +b3;
      b4 = +b4;
      b5 = +b5;
      b6 = +b6;
      b7 = +b7;
      index = index | 0;
      var x = 0;
      switch (~~index) {
      case 0: {
          x = +(a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3 - a4 * b4 - a5 * b5 - a6 * b6 - a7 * b7);
        }
        break;
      case 1: {
          x = +(+a1 * b0 + a4 * b2 - a6 * b3 - a7 * b5);
        }
        break;
      case 2: {
          x = +(+a2 * b0 - a4 * b1 + a5 * b3 - a7 * b6);
        }
        break;
      case 3: {
          x = +(+a3 * b0 - a5 * b2 + a6 * b1 - a7 * b4);
        }
        break;
      case 4: {
          x = +(+a4 * b0 + a7 * b3);
        }
        break;
      case 5: {
          x = +(+a5 * b0 + a7 * b1);
        }
        break;
      case 6: {
          x = +(+a6 * b0 + a7 * b2);
        }
        break;
      case 7: {
          x = +(+a7 * b0);
        }
        break;
      default: {
        }
      }
      return +x;
    }
    function divide(a000, a001, a010, a011, a100, a101, a110, a111, b000, b001, b010, b011, b100, b101, b110, b111, dst) {
      var r000 = +b000;
      var r001 = +b001;
      var r010 = +b010;
      var r011 = -b011;
      var r100 = +b100;
      var r101 = -b101;
      var r110 = -b110;
      var r111 = -b111;
      var m000 = mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, r000, r001, r010, r100, r011, r110, -r101, r111, 0);
      var m001 = mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, r000, r001, r010, r100, r011, r110, -r101, r111, 1);
      var m010 = mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, r000, r001, r010, r100, r011, r110, -r101, r111, 2);
      var m011 = 0;
      var m100 = mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, r000, r001, r010, r100, r011, r110, -r101, r111, 3);
      var m101 = 0;
      var m110 = 0;
      var m111 = 0;
      var c000 = +m000;
      var c001 = -m001;
      var c010 = -m010;
      var c011 = -m011;
      var c100 = -m100;
      var c101 = -m101;
      var c110 = -m110;
      var c111 = +m111;
      var s000 = mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 0);
      var s001 = mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 1);
      var s010 = mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 2);
      var s011 = mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 4);
      var s100 = mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 3);
      var s101 = -mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 6);
      var s110 = mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 5);
      var s111 = mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 7);
      var k000 = mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, s000, s001, s010, s100, s011, s110, -s101, s111, 0);
      var i000 = s000 / k000;
      var i001 = s001 / k000;
      var i010 = s010 / k000;
      var i011 = s011 / k000;
      var i100 = s100 / k000;
      var i101 = s101 / k000;
      var i110 = s110 / k000;
      var i111 = s111 / k000;
      var x000 = mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 0);
      var x001 = mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 1);
      var x010 = mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 2);
      var x011 = mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 4);
      var x100 = mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 3);
      var x101 = -mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 6);
      var x110 = mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 5);
      var x111 = mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 7);
      var w = x000;
      var x = x001;
      var y = x010;
      var z = x100;
      var xy = x011;
      var yz = x110;
      var zx = -x101;
      var xyz = x111;
      if (typeof dst !== 'undefined') {
        dst.w = w;
        dst.x = x;
        dst.y = y;
        dst.z = z;
        dst.xy = xy;
        dst.yz = yz;
        dst.zx = zx;
        dst.xyz = xyz;
      } else {
        return coordsJsToE3Py(w, x, y, z, xy, yz, zx, xyz);
      }
    }
    function coord(mv, index) {
      switch (index) {
      case 0: {
          return mv.w;
        }
      case 1: {
          return mv.x;
        }
      case 2: {
          return mv.y;
        }
      case 3: {
          return mv.z;
        }
      case 4: {
          return mv.xy;
        }
      case 5: {
          return mv.yz;
        }
      case 6: {
          return mv.zx;
        }
      case 7: {
          return mv.xyz;
        }
      default: {
          throw Sk.ffi.assertionError('' + index + ' is not a valid multivector coordinate index');
        }
      }
    }
    function compute(f, a, b, coord, pack) {
      var a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, x0, x1, x2, x3, x4, x5, x6, x7;
      a0 = a.quaternion.w;
      a1 = a.vector.x;
      a2 = a.vector.y;
      a3 = a.vector.z;
      a4 = -a.quaternion.z;
      a5 = -a.quaternion.x;
      a6 = -a.quaternion.y;
      a7 = a.xyz;
      b0 = b.quaternion.w;
      b1 = b.vector.x;
      b2 = b.vector.y;
      b3 = b.vector.z;
      b4 = -b.quaternion.z;
      b5 = -b.quaternion.x;
      b6 = -b.quaternion.y;
      b7 = b.xyz;
      x0 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 0);
      x1 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 1);
      x2 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 2);
      x3 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 3);
      x4 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 4);
      x5 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 5);
      x6 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 6);
      x7 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 7);
      return pack(x0, x1, x2, x3, x4, x5, x6, x7);
    }
    mod[Sk.e3ga.SCALAR_E3] = Sk.ffi.functionPy(function (wPy, mutablePy) {
      Sk.ffi.checkFunctionArgs(Sk.e3ga.SCALAR_E3, arguments, 1, 2);
      Sk.ffi.checkArgType(PROP_W, Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(wPy), wPy);
      if (Sk.ffi.isDefined(mutablePy)) {
        Sk.ffi.checkArgType(PROP_MUTABLE, Sk.ffi.PyType.BOOL, Sk.ffi.isBool(mutablePy), mutablePy);
      }
      return coordsJsToE3Py(Sk.ffi.numberToJs(wPy), 0, 0, 0, 0, 0, 0, 0, Sk.ffi.remapToJs(mutablePy));
    });
    mod[Sk.e3ga.VECTOR_E3] = Sk.ffi.functionPy(function (xPy, yPy, zPy, mutablePy) {
      Sk.ffi.checkFunctionArgs(Sk.e3ga.VECTOR_E3, arguments, 3, 4);
      Sk.ffi.checkArgType(PROP_X, Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(xPy), xPy);
      Sk.ffi.checkArgType(PROP_Y, Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(yPy), yPy);
      Sk.ffi.checkArgType(PROP_Z, Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(zPy), zPy);
      if (Sk.ffi.isDefined(mutablePy)) {
        Sk.ffi.checkArgType(PROP_MUTABLE, Sk.ffi.PyType.BOOL, Sk.ffi.isBool(mutablePy), mutablePy);
      }
      var x = Sk.ffi.numberToJs(xPy);
      var y = Sk.ffi.numberToJs(yPy);
      var z = Sk.ffi.numberToJs(zPy);
      return coordsJsToE3Py(0, x, y, z, 0, 0, 0, 0, Sk.ffi.remapToJs(mutablePy));
    });
    mod[Sk.e3ga.BIVECTOR_E3] = Sk.ffi.functionPy(function (xy, yz, zx, mutablePy) {
      Sk.ffi.checkFunctionArgs(Sk.e3ga.BIVECTOR_E3, arguments, 3, 4);
      Sk.ffi.checkArgType(PROP_XY, Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(xy), xy);
      Sk.ffi.checkArgType(PROP_YZ, Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(yz), yz);
      Sk.ffi.checkArgType(PROP_ZX, Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(zx), zx);
      if (Sk.ffi.isDefined(mutablePy)) {
        Sk.ffi.checkArgType(PROP_MUTABLE, Sk.ffi.PyType.BOOL, Sk.ffi.isBool(mutablePy), mutablePy);
      }
      xy = Sk.ffi.numberToJs(xy);
      yz = Sk.ffi.numberToJs(yz);
      zx = Sk.ffi.numberToJs(zx);
      return coordsJsToE3Py(0, 0, 0, 0, xy, yz, zx, 0, Sk.ffi.remapToJs(mutablePy));
    });
    mod[Sk.e3ga.PSEUDOSCALAR_E3] = Sk.ffi.functionPy(function (xyz, mutablePy) {
      Sk.ffi.checkFunctionArgs(Sk.e3ga.PSEUDOSCALAR_E3, arguments, 1, 2);
      Sk.ffi.checkArgType(PROP_XYZ, Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(xyz), xyz);
      if (Sk.ffi.isDefined(mutablePy)) {
        Sk.ffi.checkArgType(PROP_MUTABLE, Sk.ffi.PyType.BOOL, Sk.ffi.isBool(mutablePy), mutablePy);
      }
      xyz = Sk.ffi.numberToJs(xyz);
      return coordsJsToE3Py(0, 0, 0, 0, 0, 0, 0, xyz, Sk.ffi.remapToJs(mutablePy));
    });
    mod[Sk.e3ga.EUCLIDEAN_3] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (self, w, x, y, z, xy, yz, zx, xyz, mutablePy) {
        Sk.ffi.checkMethodArgs(Sk.e3ga.EUCLIDEAN_3, arguments, 1, 9);
        switch (Sk.ffi.getType(w)) {
        case Sk.ffi.PyType.FLOAT:
        case Sk.ffi.PyType.INT: {
            Sk.ffi.checkMethodArgs(Sk.e3ga.EUCLIDEAN_3, arguments, 8, 9);
            Sk.ffi.checkArgType(PROP_W, Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(w), w);
            Sk.ffi.checkArgType(PROP_X, Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(x), x);
            Sk.ffi.checkArgType(PROP_Y, Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(y), y);
            Sk.ffi.checkArgType(PROP_Z, Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(z), z);
            Sk.ffi.checkArgType(PROP_XY, Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(xy), xy);
            Sk.ffi.checkArgType(PROP_YZ, Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(yz), yz);
            Sk.ffi.checkArgType(PROP_ZX, Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(zx), zx);
            Sk.ffi.checkArgType(PROP_XYZ, Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(xyz), xyz);
            if (Sk.ffi.isDefined(mutablePy)) {
              Sk.ffi.checkArgType(PROP_MUTABLE, Sk.ffi.PyType.BOOL, Sk.ffi.isBool(mutablePy), mutablePy);
            }
            w = Sk.ffi.remapToJs(w);
            x = Sk.ffi.remapToJs(x);
            y = Sk.ffi.remapToJs(y);
            z = Sk.ffi.remapToJs(z);
            xy = Sk.ffi.remapToJs(xy);
            yz = Sk.ffi.remapToJs(yz);
            zx = Sk.ffi.remapToJs(zx);
            xyz = Sk.ffi.remapToJs(xyz);
            var mutable = Sk.ffi.isDefined(mutablePy) ? Sk.ffi.remapToJs(mutablePy) : true;
            var vector = new THREE[VECTOR_3](x, y, z);
            var quaternion = new THREE.Quaternion(-yz, -zx, -xy, w);
            Sk.ffi.referenceToPy(new THREE.Euclidean3(vector, quaternion, xyz, mutable), Sk.e3ga.EUCLIDEAN_3, undefined, self);
          }
          break;
        case Sk.ffi.PyType.INSTANCE: {
            Sk.ffi.checkMethodArgs(Sk.e3ga.EUCLIDEAN_3, arguments, 1, 1);
            Sk.ffi.referenceToPy(Sk.ffi.remapToJs(w), Sk.e3ga.EUCLIDEAN_3, undefined, self);
          }
          break;
        default: {
            throw new Sk.builtin.AssertionError('09eaed05-6d9d-4ded-a499-e4c480a9ed68, getType(w) => ' + Sk.ffi.getType(w));
          }
        }
      });
      $loc.__add__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var vector = self.vector;
        var quaternion = self.quaternion;
        var b = Sk.ffi.remapToJs(otherPy);
        if (Sk.ffi.isNum(otherPy)) {
          return coordsJsToE3Py(quaternion.w + b, vector.x, vector.y, vector.z, -quaternion.z, -quaternion.x, -quaternion.y, self.xyz);
        } else if (Sk.ffi.isInstance(otherPy, Sk.e3ga.EUCLIDEAN_3)) {
          var w = quaternion.w + b.quaternion.w;
          var x = vector.x + b.vector.x;
          var y = vector.y + b.vector.y;
          var z = vector.z + b.vector.z;
          var xy = -(quaternion.z + b.quaternion.z);
          var yz = -(quaternion.x + b.quaternion.x);
          var zx = -(quaternion.y + b.quaternion.y);
          var xyz = self.xyz + b.xyz;
          return coordsJsToE3Py(w, x, y, z, xy, yz, zx, xyz);
        } else {
          return undefined;
        }
      });
      $loc.__radd__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var a = Sk.ffi.remapToJs(otherPy);
        var self = Sk.ffi.remapToJs(selfPy);
        var vector = self.vector;
        var quaternion = self.quaternion;
        if (Sk.ffi.isNum(otherPy)) {
          return coordsJsToE3Py(a + quaternion.w, vector.x, vector.y, vector.z, -quaternion.z, -quaternion.x, -quaternion.y, self.xyz);
        } else {
          return undefined;
        }
      });
      $loc.__iadd__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var vs = self.vector;
        var qs = self.quaternion;
        var other = Sk.ffi.remapToJs(otherPy);
        if (Sk.ffi.isNum(otherPy)) {
          qs.w += other;
        } else if (isEuclidean3Py(otherPy)) {
          var vo = other.vector;
          var qo = other.quaternion;
          qs.w += qo.w;
          vs.x += vo.x;
          vs.y += vo.y;
          vs.z += vo.z;
          qs.z += qo.z;
          qs.x += qo.x;
          qs.y += qo.y;
          self.xyz += other.xyz;
        } else {
          return undefined;
        }
        return selfPy;
      });
      $loc.__sub__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var vs = self.vector;
        var qs = self.quaternion;
        var other = Sk.ffi.remapToJs(otherPy);
        if (Sk.ffi.isNum(otherPy)) {
          return coordsJsToE3Py(qs.w - other, vs.x, vs.y, vs.z, -qs.z, -qs.x, -qs.y, self.xyz);
        } else if (Sk.ffi.isInstance(otherPy, Sk.e3ga.EUCLIDEAN_3)) {
          var vo = other.vector;
          var qo = other.quaternion;
          var w = qs.w - qo.w;
          var x = vs.x - vo.x;
          var y = vs.y - vo.y;
          var z = vs.z - vo.z;
          var xy = -(qs.z - qo.z);
          var yz = -(qs.x - qo.x);
          var zx = -(qs.y - qo.y);
          var xyz = self.xyz - other.xyz;
          return coordsJsToE3Py(w, x, y, z, xy, yz, zx, xyz);
        } else {
          throw Sk.ffi.err.operand(ARG_OTHER).toOperation(OP_SUB).mustHaveType([
            Sk.ffi.PyType.FLOAT,
            Sk.e3ga.EUCLIDEAN_3
          ]);
        }
      });
      $loc.__rsub__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var other = Sk.ffi.remapToJs(otherPy);
        var self = Sk.ffi.remapToJs(selfPy);
        var vs = self.vector;
        var qs = self.quaternion;
        if (Sk.ffi.isNum(otherPy)) {
          return coordsJsToE3Py(other - qs.w, -vs.x, -vs.y, -vs.z, qs.z, qs.x, qs.y, -self.xyz);
        } else {
          throw Sk.ffi.err.operand(ARG_OTHER).toOperation(OP_SUB).mustHaveType([
            Sk.ffi.PyType.FLOAT,
            Sk.e3ga.EUCLIDEAN_3
          ]);
        }
      });
      $loc.__isub__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var vs = self.vector;
        var qs = self.quaternion;
        var other = Sk.ffi.remapToJs(otherPy);
        if (Sk.ffi.isNum(otherPy)) {
          qs.w -= other;
        } else if (isEuclidean3Py(otherPy)) {
          var vo = other.vector;
          var qo = other.quaternion;
          qs.w -= qo.w;
          vs.x -= vo.x;
          vs.y -= vo.y;
          vs.z -= vo.z;
          qs.z -= qo.z;
          qs.x -= qo.x;
          qs.y -= qo.y;
          self.xyz -= other.xyz;
        } else {
          throw Sk.ffi.err.operand(ARG_OTHER).toOperation(OP_SUB).mustHaveType([
            Sk.ffi.PyType.FLOAT,
            Sk.e3ga.EUCLIDEAN_3
          ]);
        }
        return selfPy;
      });
      $loc.__mul__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        switch (Sk.ffi.getType(otherPy)) {
        case Sk.ffi.PyType.INSTANCE: {
            switch (Sk.ffi.typeName(otherPy)) {
            case Sk.e3ga.EUCLIDEAN_3: {
                var lhs = Sk.ffi.remapToJs(selfPy);
                var rhs = Sk.ffi.remapToJs(otherPy);
                return compute(mulE3, lhs, rhs, coord, coordsJsToE3Py);
              }
            default: {
                return undefined;
              }
            }
          }
        case Sk.ffi.PyType.INT:
        case Sk.ffi.PyType.FLOAT: {
            var self = Sk.ffi.remapToJs(selfPy);
            var vector = self.vector;
            var quaternion = self.quaternion;
            var b = Sk.ffi.remapToJs(otherPy);
            return coordsJsToE3Py(quaternion.w * b, vector.x * b, vector.y * b, vector.z * b, -quaternion.z * b, -quaternion.x * b, -quaternion.y * b, self.xyz * b);
          }
        default: {
            return undefined;
          }
        }
      });
      $loc.__rmul__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var vector = self.vector;
        var quaternion = self.quaternion;
        if (Sk.ffi.isNum(otherPy)) {
          var a = Sk.ffi.remapToJs(otherPy);
          return coordsJsToE3Py(a * quaternion.w, a * vector.x, a * vector.y, a * vector.z, -a * quaternion.z, -a * quaternion.x, -a * quaternion.y, a * self.xyz);
        } else {
          return undefined;
        }
      });
      $loc.__imul__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var a = Sk.ffi.remapToJs(selfPy);
        var b = Sk.ffi.remapToJs(otherPy);
        var a0 = a.w;
        var a1 = a.x;
        var a2 = a.y;
        var a3 = a.z;
        var a4 = a.xy;
        var a5 = a.yz;
        var a6 = a.zx;
        var a7 = a.xyz;
        var b0, b1, b2, b3, b4, b5, b6, b7;
        if (isNumber(b)) {
          b0 = b;
          b1 = 0;
          b2 = 0;
          b3 = 0;
          b4 = 0;
          b5 = 0;
          b6 = 0;
          b7 = 0;
        } else {
          b0 = b.w;
          b1 = b.x;
          b2 = b.y;
          b3 = b.z;
          b4 = b.xy;
          b5 = b.yz;
          b6 = b.zx;
          b7 = b.xyz;
        }
        a.w = mulE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 0);
        a.x = mulE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 1);
        a.y = mulE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 2);
        a.z = mulE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 3);
        a.xy = mulE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 4);
        a.yz = mulE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 5);
        a.zx = mulE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 6);
        a.xyz = mulE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 7);
        return selfPy;
      });
      $loc.__div__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        switch (Sk.ffi.getType(otherPy)) {
        case Sk.ffi.PyType.INSTANCE: {
            switch (Sk.ffi.typeName(otherPy)) {
            case Sk.e3ga.EUCLIDEAN_3: {
                var self = Sk.ffi.remapToJs(selfPy);
                var vs = self.vector;
                var qs = self.quaternion;
                var other = Sk.ffi.remapToJs(otherPy);
                var vo = other.vector;
                var qo = other.quaternion;
                return divide(qs.w, vs.x, vs.y, -qs.z, vs.z, qs.y, -qs.x, self.xyz, qo.w, vo.x, vo.y, -qo.z, vo.z, qo.y, -qo.x, other.xyz, undefined);
              }
            default: {
                return undefined;
              }
            }
          }
        case Sk.ffi.PyType.INT:
        case Sk.ffi.PyType.FLOAT: {
            var self = Sk.ffi.remapToJs(selfPy);
            var vs = self.vector;
            var qs = self.quaternion;
            var other = Sk.ffi.remapToJs(otherPy);
            return divide(qs.w, vs.x, vs.y, -qs.z, vs.z, qs.y, -qs.x, self.xyz, other, 0, 0, 0, 0, 0, 0, 0, undefined);
          }
        default: {
            return undefined;
          }
        }
      });
      $loc.__rdiv__ = Sk.ffi.functionPy(function (rhs, lhs) {
        lhs = Sk.ffi.remapToJs(lhs);
        rhs = Sk.ffi.remapToJs(rhs);
        if (isNumber(lhs)) {
          return divide(lhs, 0, 0, 0, 0, 0, 0, 0, rhs.w, rhs.x, rhs.y, rhs.xy, rhs.z, -rhs.zx, rhs.yz, rhs.xyz, undefined);
        } else {
          throw new Sk.builtin.AssertionError('' + JSON.stringify(lhs, null, 2) + ' / ' + JSON.stringify(rhs, null, 2));
        }
      });
      $loc.__idiv__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var a = Sk.ffi.remapToJs(selfPy);
        var b = Sk.ffi.remapToJs(otherPy);
        if (isNumber(b)) {
          divide(a.w, a.x, a.y, a.xy, a.z, -a.zx, a.yz, a.xyz, b, 0, 0, 0, 0, 0, 0, 0, a);
          return selfPy;
        } else {
          divide(a.w, a.x, a.y, a.xy, a.z, -a.zx, a.yz, a.xyz, b.w, b.x, b.y, b.xy, b.z, -b.zx, b.yz, b.xyz, a);
          return selfPy;
        }
      });
      $loc.__mod__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        switch (Sk.ffi.getType(otherPy)) {
        case Sk.ffi.PyType.INSTANCE: {
            switch (Sk.ffi.typeName(otherPy)) {
            case Sk.e3ga.EUCLIDEAN_3: {
                var s = Sk.ffi.remapToJs(selfPy);
                var o = Sk.ffi.remapToJs(otherPy);
                return coordsJsToE3Py(s.x * o.x + s.y * o.y + s.z * o.z, 0, 0, 0, 0, 0, 0, 0);
              }
            default: {
                return undefined;
              }
            }
          }
        case Sk.ffi.PyType.INT:
        case Sk.ffi.PyType.FLOAT: {
            var self = Sk.ffi.remapToJs(selfPy);
            var vector = self.vector;
            var quaternion = self.quaternion;
            var b = Sk.ffi.remapToJs(otherPy);
            return coordsJsToE3Py(quaternion.w * b, vector.x * b, vector.y * b, vector.z * b, -quaternion.z * b, -quaternion.x * b, -quaternion.y * b, self.xyz * b);
          }
        default: {
            return undefined;
          }
        }
      });
      $loc.__xor__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        switch (Sk.ffi.getType(otherPy)) {
        case Sk.ffi.PyType.INSTANCE: {
            switch (Sk.ffi.typeName(otherPy)) {
            case Sk.e3ga.EUCLIDEAN_3: {
                var a = Sk.ffi.remapToJs(selfPy);
                var b = Sk.ffi.remapToJs(otherPy);
                return compute(extE3, a, b, coord, coordsJsToE3Py);
              }
            default: {
                return undefined;
              }
            }
          }
        case Sk.ffi.PyType.INT:
        case Sk.ffi.PyType.FLOAT: {
            var a = Sk.ffi.remapToJs(selfPy);
            var b = Sk.ffi.remapToJs(otherPy);
            return coordsJsToE3Py(a.w * b, a.x * b, a.y * b, a.z * b, a.xy * b, a.yz * b, a.zx * b, a.xyz * b);
          }
        default: {
            return undefined;
          }
        }
      });
      $loc.__rxor__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        if (Sk.ffi.isNum(otherPy)) {
          var a = Sk.ffi.remapToJs(otherPy);
          var b = Sk.ffi.remapToJs(selfPy);
          return coordsJsToE3Py(a * b.w, a * b.x, a * b.y, a * b.z, a * b.xy, a * b.yz, a * b.zx, a * b.xyz);
        } else {
          return undefined;
        }
      });
      $loc.__ixor__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var a = Sk.ffi.remapToJs(selfPy);
        var b = Sk.ffi.remapToJs(otherPy);
        var a0 = a.w;
        var a1 = a.x;
        var a2 = a.y;
        var a3 = a.z;
        var a4 = a.xy;
        var a5 = a.yz;
        var a6 = a.zx;
        var a7 = a.xyz;
        var b0, b1, b2, b3, b4, b5, b6, b7;
        if (isNumber(b)) {
          b0 = b;
          b1 = 0;
          b2 = 0;
          b3 = 0;
          b4 = 0;
          b5 = 0;
          b6 = 0;
          b7 = 0;
        } else {
          b0 = b.w;
          b1 = b.x;
          b2 = b.y;
          b3 = b.z;
          b4 = b.xy;
          b5 = b.yz;
          b6 = b.zx;
          b7 = b.xyz;
        }
        a.w = extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 0);
        a.x = extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 1);
        a.y = extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 2);
        a.z = extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 3);
        a.xy = extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 4);
        a.yz = extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 5);
        a.zx = extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 6);
        a.xyz = extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 7);
        return selfPy;
      });
      $loc.__lshift__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        switch (Sk.ffi.getType(otherPy)) {
        case Sk.ffi.PyType.INSTANCE: {
            switch (Sk.ffi.typeName(otherPy)) {
            case Sk.e3ga.EUCLIDEAN_3: {
                var a = Sk.ffi.remapToJs(selfPy);
                var b = Sk.ffi.remapToJs(otherPy);
                return compute(lcoE3, a, b, coord, coordsJsToE3Py);
              }
            default: {
                return undefined;
              }
            }
          }
        case Sk.ffi.PyType.INT:
        case Sk.ffi.PyType.FLOAT: {
            var a = Sk.ffi.remapToJs(selfPy);
            var b = Sk.ffi.remapToJs(otherPy);
            return coordsJsToE3Py(a.w * b, 0, 0, 0, 0, 0, 0, 0);
          }
        default: {
            return undefined;
          }
        }
      });
      $loc.__rlshift__ = Sk.ffi.functionPy(function (b, a) {
        a = Sk.ffi.remapToJs(a);
        b = Sk.ffi.remapToJs(b);
        if (isNumber(a)) {
          return coordsJsToE3Py(a * b.w, a * b.x, a * b.y, a * b.z, a * b.xy, a * b.yz, a * b.zx, a * b.xyz);
        } else {
          return undefined;
        }
      });
      $loc.__ilshift__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var a = Sk.ffi.remapToJs(selfPy);
        var b = Sk.ffi.remapToJs(otherPy);
        var a0 = a.w;
        var a1 = a.x;
        var a2 = a.y;
        var a3 = a.z;
        var a4 = a.xy;
        var a5 = a.yz;
        var a6 = a.zx;
        var a7 = a.xyz;
        var b0, b1, b2, b3, b4, b5, b6, b7;
        if (isNumber(b)) {
          b0 = b;
          b1 = 0;
          b2 = 0;
          b3 = 0;
          b4 = 0;
          b5 = 0;
          b6 = 0;
          b7 = 0;
        } else {
          b0 = b.w;
          b1 = b.x;
          b2 = b.y;
          b3 = b.z;
          b4 = b.xy;
          b5 = b.yz;
          b6 = b.zx;
          b7 = b.xyz;
        }
        a.w = lcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 0);
        a.x = lcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 1);
        a.y = lcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 2);
        a.z = lcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 3);
        a.xy = lcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 4);
        a.yz = lcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 5);
        a.zx = lcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 6);
        a.xyz = lcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 7);
        return selfPy;
      });
      $loc.__rshift__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        switch (Sk.ffi.getType(otherPy)) {
        case Sk.ffi.PyType.INSTANCE: {
            switch (Sk.ffi.typeName(otherPy)) {
            case Sk.e3ga.EUCLIDEAN_3: {
                var a = Sk.ffi.remapToJs(selfPy);
                var b = Sk.ffi.remapToJs(otherPy);
                return compute(rcoE3, a, b, coord, coordsJsToE3Py);
              }
            default: {
                return undefined;
              }
            }
          }
        case Sk.ffi.PyType.INT:
        case Sk.ffi.PyType.FLOAT: {
            var a = Sk.ffi.remapToJs(selfPy);
            var b = Sk.ffi.remapToJs(otherPy);
            return coordsJsToE3Py(a.w * b, a.x * b, a.y * b, a.z * b, a.xy * b, a.yz * b, a.zx * b, a.xyz * b);
          }
        default: {
            return undefined;
          }
        }
      });
      $loc.__rrshift__ = Sk.ffi.functionPy(function (b, a) {
        a = Sk.ffi.remapToJs(a);
        b = Sk.ffi.remapToJs(b);
        if (isNumber(a)) {
          return coordsJsToE3Py(a * b.w, 0, 0, 0, 0, 0, 0, 0);
        } else {
          return undefined;
        }
      });
      $loc.__irshift__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var a = Sk.ffi.remapToJs(selfPy);
        var b = Sk.ffi.remapToJs(otherPy);
        var a0 = a.w;
        var a1 = a.x;
        var a2 = a.y;
        var a3 = a.z;
        var a4 = a.xy;
        var a5 = a.yz;
        var a6 = a.zx;
        var a7 = a.xyz;
        var b0, b1, b2, b3, b4, b5, b6, b7;
        if (isNumber(b)) {
          b0 = b;
          b1 = 0;
          b2 = 0;
          b3 = 0;
          b4 = 0;
          b5 = 0;
          b6 = 0;
          b7 = 0;
        } else {
          b0 = b.w;
          b1 = b.x;
          b2 = b.y;
          b3 = b.z;
          b4 = b.xy;
          b5 = b.yz;
          b6 = b.zx;
          b7 = b.xyz;
        }
        a.w = rcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 0);
        a.x = rcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 1);
        a.y = rcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 2);
        a.z = rcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 3);
        a.xy = rcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 4);
        a.yz = rcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 5);
        a.zx = rcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 6);
        a.xyz = rcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 7);
        return selfPy;
      });
      $loc.__pow__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        switch (Sk.ffi.getType(otherPy)) {
        case Sk.ffi.PyType.INSTANCE: {
            switch (Sk.ffi.typeName(otherPy)) {
            case Sk.e3ga.EUCLIDEAN_3: {
                var a = Sk.ffi.remapToJs(selfPy);
                var b = Sk.ffi.remapToJs(otherPy);
                return coordsJsToE3Py(Math.pow(a.w, b.w), 0, 0, 0, 0, 0, 0, 0);
              }
            default: {
                return undefined;
              }
            }
          }
        case Sk.ffi.PyType.INT:
        case Sk.ffi.PyType.FLOAT: {
            var a = Sk.ffi.remapToJs(selfPy);
            var b = Sk.ffi.remapToJs(otherPy);
            return coordsJsToE3Py(Math.pow(a.w, b), 0, 0, 0, 0, 0, 0, 0);
          }
        default: {
            return undefined;
          }
        }
      });
      $loc.__len__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffi.numberToFloatPy(8);
      });
      $loc.__pos__ = Sk.ffi.functionPy(function (selfPy) {
        return selfPy;
      });
      $loc.__neg__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var vector = self.vector;
        var quaternion = self.quaternion;
        return coordsJsToE3Py(-quaternion.w, -vector.x, -vector.y, -vector.z, quaternion.z, quaternion.x, quaternion.y, -self.xyz);
      });
      $loc.__invert__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var vector = self.vector;
        var quaternion = self.quaternion;
        return coordsJsToE3Py(quaternion.w, vector.x, vector.y, vector.z, quaternion.z, quaternion.x, quaternion.y, -self.xyz);
      });
      $loc.__eq__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        if (Sk.ffi.isInstance(otherPy, Sk.e3ga.EUCLIDEAN_3)) {
          var self = Sk.ffi.remapToJs(selfPy);
          var va = self.vector;
          var qa = self.quaternion;
          var other = Sk.ffi.remapToJs(otherPy);
          var vb = other.vector;
          var qb = other.quaternion;
          return va.equals(vb) && qa.equals(qb) && self.xyz === other.xyz;
        } else {
          return Sk.ffi.bool.False;
        }
      });
      $loc.__ne__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        if (Sk.ffi.isInstance(otherPy, Sk.e3ga.EUCLIDEAN_3)) {
          var self = Sk.ffi.remapToJs(selfPy);
          var va = self.vector;
          var qa = self.quaternion;
          var other = Sk.ffi.remapToJs(otherPy);
          var vb = other.vector;
          var qb = other.quaternion;
          return !va.equals(vb) || !qa.equals(qb) || self.xyz !== other.xyz;
        } else {
          return Sk.ffi.bool.True;
        }
      });
      $loc.__getitem__ = Sk.ffi.functionPy(function (selfPy, indexPy) {
        Sk.ffi.checkMethodArgs('[]', arguments, 1, 1);
        Sk.ffi.checkArgType(ARG_INDEX, Sk.ffi.PyType.INT, Sk.ffi.isInt(indexPy), indexPy);
        var index = Sk.ffi.remapToJs(indexPy);
        var self = Sk.ffi.remapToJs(selfPy);
        var vector = self.vector;
        var quaternion = self.quaternion;
        switch (index) {
        case 0: {
            return coordsJsToE3Py(quaternion.w, 0, 0, 0, 0, 0, 0, 0);
          }
        case 1: {
            return coordsJsToE3Py(0, vector.x, vector.y, vector.z, 0, 0, 0, 0);
          }
        case 2: {
            return coordsJsToE3Py(0, 0, 0, 0, -quaternion.z, -quaternion.x, -quaternion.y, 0);
          }
        case 3: {
            return coordsJsToE3Py(0, 0, 0, 0, 0, 0, 0, self.xyz);
          }
        }
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var self = Sk.ffi.remapToJs(selfPy);
        var vector = self.vector;
        var quaternion = self.quaternion;
        switch (name) {
        case PROP_W: {
            return Sk.ffi.numberToFloatPy(self.w);
          }
        case PROP_X: {
            return Sk.ffi.numberToFloatPy(self.x);
          }
        case PROP_Y: {
            return Sk.ffi.numberToFloatPy(self.y);
          }
        case PROP_Z: {
            return Sk.ffi.numberToFloatPy(self.z);
          }
        case PROP_XY: {
            return Sk.ffi.numberToFloatPy(self.xy);
          }
        case PROP_YZ: {
            return Sk.ffi.numberToFloatPy(self.yz);
          }
        case PROP_ZX: {
            return Sk.ffi.numberToFloatPy(self.zx);
          }
        case PROP_XYZ: {
            return Sk.ffi.numberToFloatPy(self.xyz);
          }
        case PROP_MUTABLE: {
            return Sk.ffi.booleanToPy(self.mutable);
          }
        case PROP_VECTOR: {
            return Sk.ffi.callsim(mod[VECTOR_3], Sk.ffi.referenceToPy(self.vector, VECTOR_3));
          }
        case PROP_QUATERNION: {
            return Sk.ffi.callsim(mod[QUATERNION], Sk.ffi.referenceToPy(self.quaternion, QUATERNION));
          }
        case METHOD_ADD: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy, otherPy) {
              Sk.ffi.checkMethodArgs(name, arguments, 1, 1);
              Sk.ffi.checkArgType(ARG_OTHER, Sk.e3ga.EUCLIDEAN_3, Sk.ffi.isInstance(otherPy, Sk.e3ga.EUCLIDEAN_3), otherPy);
              var other = Sk.ffi.remapToJs(otherPy);
              quaternion.w += other.quaternion.w;
              vector.x += other.vector.x;
              vector.y += other.vector.y;
              vector.z += other.vector.z;
              quaternion.x += other.quaternion.x;
              quaternion.y += other.quaternion.y;
              quaternion.z += other.quaternion.z;
              self.xyz += other.xyz;
              return selfPy;
            });
          }
        case METHOD_APPLY_MATRIX_3: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy, mPy) {
              Sk.ffi.checkMethodArgs(name, arguments, 1, 1);
              Sk.ffi.checkArgType('m', Sk.three.MATRIX_3, Sk.ffi.isInstance(mPy, Sk.three.MATRIX_3), mPy);
              vector[name](Sk.ffi.remapToJs(mPy));
              return selfPy;
            });
          }
        case METHOD_APPLY_MATRIX_4: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy, mPy) {
              Sk.ffi.checkMethodArgs(name, arguments, 1, 1);
              Sk.ffi.checkArgType('m', Sk.three.MATRIX_4, Sk.ffi.isInstance(mPy, Sk.three.MATRIX_4), mPy);
              vector[name](Sk.ffi.remapToJs(mPy));
              return selfPy;
            });
          }
        case METHOD_SUB: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy, otherPy) {
              Sk.ffi.checkMethodArgs(name, arguments, 1, 1);
              Sk.ffi.checkArgType(ARG_OTHER, Sk.e3ga.EUCLIDEAN_3, Sk.ffi.isInstance(otherPy, Sk.e3ga.EUCLIDEAN_3), otherPy);
              var other = Sk.ffi.remapToJs(otherPy);
              quaternion.w -= other.quaternion.w;
              vector.x -= other.vector.x;
              vector.y -= other.vector.y;
              vector.z -= other.vector.z;
              quaternion.x -= other.quaternion.x;
              quaternion.y -= other.quaternion.y;
              quaternion.z -= other.quaternion.z;
              self.xyz -= other.xyz;
              return selfPy;
            });
          }
        case METHOD_CONSTANTIFY: {
            return Sk.ffi.callableToPy(mod, METHOD_CONSTANTIFY, function (methodPy) {
              Sk.ffi.checkMethodArgs(METHOD_CONSTANTIFY, arguments, 0, 0);
              self.mutable = false;
              return selfPy;
            });
          }
        case METHOD_COPY: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy, otherPy) {
              Sk.ffi.checkMethodArgs(name, arguments, 1, 1);
              Sk.ffi.checkArgType(ARG_OTHER, Sk.e3ga.EUCLIDEAN_3, Sk.ffi.isInstance(otherPy, Sk.e3ga.EUCLIDEAN_3), otherPy);
              var other = Sk.ffi.remapToJs(otherPy);
              quaternion.w = other.quaternion.w;
              vector.x = other.vector.x;
              vector.y = other.vector.y;
              vector.z = other.vector.z;
              quaternion.x = other.quaternion.x;
              quaternion.y = other.quaternion.y;
              quaternion.z = other.quaternion.z;
              self.xyz = other.xyz;
              return selfPy;
            });
          }
        case METHOD_CROSS: {
            return Sk.ffi.callableToPy(mod, METHOD_CROSS, function (methodPy, otherPy) {
              Sk.ffi.checkMethodArgs(METHOD_CROSS, arguments, 1, 1);
              Sk.ffi.checkArgType(ARG_OTHER, Sk.e3ga.EUCLIDEAN_3, Sk.ffi.isInstance(otherPy, Sk.e3ga.EUCLIDEAN_3), otherPy);
              var other = Sk.ffi.remapToJs(otherPy);
              var Ax = self.x;
              var Ay = self.y;
              var Az = self.z;
              var Bx = other.x;
              var By = other.y;
              var Bz = other.z;
              var Cx = Ay * Bz - Az * By;
              var Cy = Az * Bx - Ax * Bz;
              var Cz = Ax * By - Ay * Bx;
              return coordsJsToE3Py(0, Cx, Cy, Cz, 0, 0, 0, 0);
            });
          }
        case METHOD_DISTANCE_TO: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy, pointPy) {
              Sk.ffi.checkMethodArgs(name, arguments, 1, 1);
              Sk.ffi.checkArgType(ARG_OTHER, Sk.e3ga.EUCLIDEAN_3, Sk.ffi.isInstance(pointPy, Sk.e3ga.EUCLIDEAN_3), pointPy);
              var point = Sk.ffi.remapToJs(pointPy);
              return Sk.ffi.numberToFloatPy(vector[METHOD_DISTANCE_TO](point.vector));
            });
          }
        case METHOD_DISTANCE_TO_SQUARED: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy, pointPy) {
              Sk.ffi.checkMethodArgs(name, arguments, 1, 1);
              Sk.ffi.checkArgType(ARG_OTHER, Sk.e3ga.EUCLIDEAN_3, Sk.ffi.isInstance(pointPy, Sk.e3ga.EUCLIDEAN_3), pointPy);
              var point = Sk.ffi.remapToJs(pointPy);
              return Sk.ffi.numberToFloatPy(vector[METHOD_DISTANCE_TO_SQUARED](point.vector));
            });
          }
        case METHOD_DIVIDE_SCALAR: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy, sPy) {
              Sk.ffi.checkMethodArgs(name, arguments, 1, 1);
              Sk.ffi.checkArgType(ARG_S, Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(sPy), sPy);
              var s = Sk.ffi.remapToJs(sPy);
              quaternion.w /= s;
              vector.x /= s;
              vector.y /= s;
              vector.z /= s;
              quaternion.x /= s;
              quaternion.y /= s;
              quaternion.z /= s;
              self.xyz /= s;
              return selfPy;
            });
          }
        case METHOD_DOT: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy, otherPy) {
              Sk.ffi.checkMethodArgs(name, arguments, 1, 1);
              Sk.ffi.checkArgType(ARG_OTHER, Sk.e3ga.EUCLIDEAN_3, Sk.ffi.isInstance(otherPy, Sk.e3ga.EUCLIDEAN_3), otherPy);
              var other = Sk.ffi.remapToJs(otherPy);
              return Sk.ffi.numberToFloatPy(vector[METHOD_DOT](other.vector));
            });
          }
        case METHOD_MULTIPLY_SCALAR: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy, sPy) {
              Sk.ffi.checkMethodArgs(name, arguments, 1, 1);
              Sk.ffi.checkArgType(ARG_S, Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(sPy), sPy);
              var s = Sk.ffi.remapToJs(sPy);
              quaternion.w *= s;
              vector.x *= s;
              vector.y *= s;
              vector.z *= s;
              quaternion.x *= s;
              quaternion.y *= s;
              quaternion.z *= s;
              self.xyz *= s;
              return selfPy;
            });
          }
        case METHOD_SET_X: {
            return Sk.ffi.callableToPy(mod, METHOD_SET_X, function (methodPy, xPy) {
              Sk.ffi.checkMethodArgs(METHOD_SET_X, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_X, Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(xPy), xPy);
              self[PROP_X] = Sk.ffi.remapToJs(xPy);
              return selfPy;
            });
          }
        case METHOD_SET_Y: {
            return Sk.ffi.callableToPy(mod, METHOD_SET_Y, function (methodPy, yPy) {
              Sk.ffi.checkMethodArgs(METHOD_SET_Y, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_Y, Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(yPy), yPy);
              self[PROP_Y] = Sk.ffi.remapToJs(yPy);
              return selfPy;
            });
          }
        case METHOD_SET_Z: {
            return Sk.ffi.callableToPy(mod, METHOD_SET_Z, function (methodPy, zPy) {
              Sk.ffi.checkMethodArgs(METHOD_SET_Z, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_Z, Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(zPy), zPy);
              self[PROP_Z] = Sk.ffi.remapToJs(zPy);
              return selfPy;
            });
          }
        case METHOD_GET_COMPONENT: {
            return Sk.ffi.callableToPy(mod, METHOD_GET_COMPONENT, function (methodPy, indexPy) {
              Sk.ffi.checkMethodArgs(METHOD_GET_COMPONENT, arguments, 1, 1);
              Sk.ffi.checkArgType(ARG_INDEX, Sk.ffi.PyType.INT, Sk.ffi.isInt(indexPy), indexPy);
              var index = Sk.ffi.remapToJs(indexPy);
              return Sk.ffi.numberToFloatPy(vector[METHOD_GET_COMPONENT](index));
            });
          }
        case METHOD_SET_COMPONENT: {
            return Sk.ffi.callableToPy(mod, METHOD_SET_COMPONENT, function (methodPy, indexPy, valuePy) {
              Sk.ffi.checkMethodArgs(METHOD_SET_COMPONENT, arguments, 1, 1);
              Sk.ffi.checkArgType(ARG_INDEX, Sk.ffi.PyType.INT, Sk.ffi.isInt(indexPy), indexPy);
              Sk.ffi.checkArgType(ARG_VALUE, Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(valuePy), valuePy);
              var index = Sk.ffi.remapToJs(indexPy);
              var value = Sk.ffi.remapToJs(valuePy);
              vector[METHOD_SET_COMPONENT](index, value);
              return selfPy;
            });
          }
        case METHOD_SET: {
            return Sk.ffi.callableToPy(mod, METHOD_SET, function (methodPy, xPy, yPy, zPy) {
              Sk.ffi.checkMethodArgs(METHOD_SET, arguments, 3, 3);
              Sk.ffi.checkArgType(PROP_X, Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(xPy), xPy);
              Sk.ffi.checkArgType(PROP_Y, Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(yPy), yPy);
              Sk.ffi.checkArgType(PROP_Z, Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(zPy), zPy);
              var x = Sk.ffi.remapToJs(xPy);
              var y = Sk.ffi.remapToJs(yPy);
              var z = Sk.ffi.remapToJs(zPy);
              vector[METHOD_SET](x, y, z);
              return selfPy;
            });
          }
        case METHOD_CLONE: {
            return Sk.ffi.callableToPy(mod, METHOD_CLONE, function (methodPy) {
              Sk.ffi.checkMethodArgs(METHOD_CLONE, arguments, 0, 0);
              return coordsJsToE3Py(quaternion.w, vector.x, vector.y, vector.z, -quaternion.z, -quaternion.x, -quaternion.y, self.xyz);
            });
          }
        case METHOD_MAGNITUDE: {
            return Sk.ffi.callableToPy(mod, METHOD_MAGNITUDE, function (methodPy) {
              Sk.ffi.checkMethodArgs(METHOD_MAGNITUDE, arguments, 0, 0);
              return Sk.ffi.numberToFloatPy(vector.length());
            });
          }
        case METHOD_NORMALIZE: {
            return Sk.ffi.callableToPy(mod, METHOD_NORMALIZE, function (methodPy) {
              Sk.ffi.checkMethodArgs(METHOD_NORMALIZE, arguments, 0, 0);
              vector[METHOD_NORMALIZE]();
              return selfPy;
            });
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(Sk.e3ga.EUCLIDEAN_3);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        Sk.ffi.checkArgType(ARG_SELF, Sk.e3ga.EUCLIDEAN_3, isEuclidean3Py(selfPy), selfPy);
        var self = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case PROP_W:
        case PROP_X:
        case PROP_Y:
        case PROP_Z:
        case PROP_XY:
        case PROP_YZ:
        case PROP_ZX:
        case PROP_XYZ: {
            Sk.ffi.checkArgType(name, Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(valuePy), valuePy);
            try {
              self[name] = Sk.ffi.remapToJs(valuePy);
            } catch (e) {
              throw Sk.ffi.assertionError(e.message);
            }
          }
          break;
        default: {
            throw Sk.ffi.err.attribute(name).isNotSetableOnType(Sk.e3ga.EUCLIDEAN_3);
          }
        }
      });
      $loc.__cliffordConjugate__ = Sk.ffi.functionPy(function (selfPy) {
        Sk.ffi.checkMethodArgs(METHOD_CLIFFORD_CONJUGATE, arguments, 0, 0);
        var self = Sk.ffi.remapToJs(selfPy);
        return coordsJsToE3Py(self.w, -self.x, -self.y, -self.z, -self.xy, -self.yz, -self.zx, self.xyz);
      });
      $loc.__exp__ = Sk.ffi.functionPy(function (selfPy) {
        Sk.ffi.checkMethodArgs(METHOD_EXP, arguments, 0, 0);
        var self = Sk.ffi.remapToJs(selfPy);
        var quaternion = self.quaternion;
        var xy = -quaternion.z;
        var yz = -quaternion.x;
        var zx = -quaternion.y;
        if (xy === 0 && yz === 0) {
          var c = Sk.math.cos(zx);
          var s = Sk.math.sin(zx);
          return coordsJsToE3Py(c, 0, 0, 0, 0, 0, s, 0);
        } else if (yz === 0 && zx === 0) {
          var c = Sk.math.cos(xy);
          var s = Sk.math.sin(xy);
          return coordsJsToE3Py(c, 0, 0, 0, s, 0, 0, 0);
        } else if (zx === 0 && xy === 0) {
          var c = Sk.math.cos(yz);
          var s = Sk.math.sin(yz);
          return coordsJsToE3Py(c, 0, 0, 0, 0, s, 0, 0);
        } else {
          var angle = Math.sqrt(xy * xy + yz * yz + zx * zx);
          var c = Sk.math.cos(angle);
          var s = Sk.math.sin(angle);
          var k = s / angle;
          return coordsJsToE3Py(c, 0, 0, 0, k * xy, k * yz, k * zx, 0);
        }
      });
      $loc.__abs__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffi.gattr(Sk.ffh.sqrt(Sk.ffh.quadrance(selfPy)), PROP_W);
      });
      $loc.__magnitude__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffh.sqrt(Sk.ffh.quadrance(selfPy));
      });
      $loc.__quadrance__ = Sk.ffi.functionPy(function (selfPy) {
        var s = Sk.ffi.remapToJs(selfPy);
        var w = s.w;
        var x = s.x;
        var y = s.y;
        var z = s.z;
        var xy = s.xy;
        var yz = s.yz;
        var zx = s.zx;
        var xyz = s.xyz;
        return coordsJsToE3Py(w * w + x * x + y * y + z * z + xy * xy + yz * yz + zx * zx + xyz * xyz, 0, 0, 0, 0, 0, 0, 0);
      });
      $loc.__sqrt__ = Sk.ffi.functionPy(function (selfPy) {
        Sk.ffi.checkMethodArgs(METHOD_SQRT, arguments, 0, 0);
        var self = Sk.ffi.remapToJs(selfPy);
        return coordsJsToE3Py(Math.sqrt(self.w), 0, 0, 0, 0, 0, 0, 0);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var vector = self.vector;
        var quaternion = self.quaternion;
        var w = quaternion.w;
        var x = vector.x;
        var y = vector.y;
        var z = vector.z;
        var xy = -quaternion.z;
        var yz = -quaternion.x;
        var zx = -quaternion.y;
        var xyz = self.xyz;
        var grade0 = w !== 0;
        var grade1 = x !== 0 || y != 0 || z !== 0;
        var grade2 = xy !== 0 || yz !== 0 || zx !== 0;
        var grade3 = xyz !== 0;
        if (grade0 && !grade1 && !grade2 && !grade3) {
          var args = [w];
          return Sk.ffi.stringToPy(Sk.e3ga.SCALAR_E3 + '(' + args.join(', ') + ')');
        } else if (!grade0 && grade1 && !grade2 && !grade3) {
          var args = [
              x,
              y,
              z
            ];
          return Sk.ffi.stringToPy(Sk.e3ga.VECTOR_E3 + '(' + args.join(', ') + ')');
        } else if (!grade0 && !grade1 && grade2 && !grade3) {
          var args = [
              xy,
              yz,
              zx
            ];
          return Sk.ffi.stringToPy(Sk.e3ga.BIVECTOR_E3 + '(' + args.join(', ') + ')');
        } else if (!grade0 && !grade1 && !grade2 && grade3) {
          var args = [xyz];
          return Sk.ffi.stringToPy(Sk.e3ga.PSEUDOSCALAR_E3 + '(' + args.join(', ') + ')');
        } else {
          var args = [
              w,
              x,
              y,
              z,
              xy,
              yz,
              zx,
              xyz
            ];
          return Sk.ffi.stringToPy(Sk.e3ga.EUCLIDEAN_3 + '(' + args.join(', ') + ')');
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        Sk.ffi.checkMethodArgs('__str__', arguments, 0, 0);
        Sk.ffi.checkFunctionArgs('str', arguments, 1, 1);
        Sk.ffi.checkArgType(ARG_SELF, Sk.e3ga.EUCLIDEAN_3, isEuclidean3Py(selfPy), selfPy);
        var self = Sk.ffi.remapToJs(selfPy);
        var w = self.w;
        var x = self.x;
        var y = self.y;
        var z = self.z;
        var xy = self.xy;
        var yz = self.yz;
        var zx = self.zx;
        var xyz = self.xyz;
        return Sk.ffi.stringToPy(stringFromCoordinates([
          w,
          x,
          y,
          z,
          xy,
          yz,
          zx,
          xyz
        ], [
          UNIT_SCALAR_NAME,
          UNIT_VECTOR_NAME_E1,
          UNIT_VECTOR_NAME_E2,
          UNIT_VECTOR_NAME_E3,
          UNIT_BIVECTOR_NAME_E12,
          UNIT_BIVECTOR_NAME_E23,
          UNIT_BIVECTOR_NAME_E31,
          PSEUDOSCALAR_NAME
        ]));
      });
    }, Sk.e3ga.EUCLIDEAN_3, []);
  };
}.call(this));
(function () {
  Sk.builtin.defineLorentzian = function (mod, BLADE) {
    Sk.ffi.checkFunctionArgs('defineLorentzian', arguments, 2, 2);
    Sk.builtin.defineUnits(mod, BLADE);
    var LORENTZIAN = 'Lorentzian';
    var SCALAR_L4 = 'ScalarL4';
    var VECTOR_L4 = 'VectorL4';
    var PSEUDOSCALAR_L4 = 'PseudoscalarE2';
    var UNIT = 'Unit';
    var MEASURE = 'Measure';
    var NUM = [
        Sk.ffi.PyType.FLOAT,
        Sk.ffi.PyType.INT,
        Sk.ffi.PyType.LONG
      ];
    var PROP_W = 'w';
    var PROP_X = 'x';
    var PROP_Y = 'y';
    var PROP_Z = 'z';
    var PROP_T = 't';
    var PROP_TX = 'tx';
    var PROP_TY = 'ty';
    var PROP_TZ = 'tz';
    var PROP_XT = 'xt';
    var PROP_XY = 'xy';
    var PROP_XYT = 'xyt';
    var PROP_XYZ = 'xyz';
    var PROP_XYZT = 'xyzt';
    var PROP_XZ = 'xz';
    var PROP_XZT = 'xzt';
    var PROP_YT = 'yt';
    var PROP_YX = 'yx';
    var PROP_YZ = 'yz';
    var PROP_YZT = 'yzt';
    var PROP_ZT = 'zt';
    var PROP_ZX = 'zx';
    var PROP_ZXT = 'zxt';
    var PROP_ZY = 'zy';
    var METHOD_CLONE = 'clone';
    var METHOD_MAGNITUDE = 'magnitude';
    var METHOD_QUADRANCE = 'quadrance';
    var OP_ADD = 'add';
    var OP_SUB = 'subtract';
    var OP_MUL = 'multiply';
    var OP_DIV = 'divide';
    var OP_EQ = 'equal';
    var LORENTZIAN_OR_NUMBER = [
        LORENTZIAN,
        NUM
      ];
    var LORENTZIAN_OR_NUMBER_OR_UNIT = [
        LORENTZIAN,
        UNIT
      ];
    function isNumber(x) {
      return typeof x === 'number';
    }
    var isLorentzianPy = function (valuePy) {
      return Sk.ffi.isInstance(valuePy, LORENTZIAN);
    };
    function coordJsToLorentzianPy(x00, x01, x10, x11) {
      return Sk.ffi.callsim(mod[LORENTZIAN], Sk.ffi.numberToFloatPy(x00), Sk.ffi.numberToFloatPy(x01), Sk.ffi.numberToFloatPy(x10), Sk.ffi.numberToFloatPy(x11));
    }
    function coordPyToLorentzianPy(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, xA, xB, xC, xD, xE, xF) {
      return Sk.ffi.callsim(mod[LORENTZIAN], x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, xA, xB, xC, xD, xE, xF);
    }
    function stringFromCoordinates(coordinates, labels, multiplier) {
      var append, i, sb, str, _i, _ref;
      sb = [];
      append = function (number, label) {
        var n;
        if (number !== 0) {
          if (number >= 0) {
            if (sb.length > 0) {
              sb.push('+');
            }
          } else {
            sb.push('-');
          }
          n = Math.abs(number);
          if (n === 1) {
            return sb.push(label);
          } else {
            sb.push(n.toString());
            if (label !== '1') {
              sb.push(multiplier);
              return sb.push(label);
            }
          }
        }
      };
      for (i = _i = 0, _ref = coordinates.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        append(coordinates[i], labels[i]);
      }
      if (sb.length > 0) {
        str = sb.join('');
      } else {
        str = '0';
      }
      return str;
    }
    function divide(a00, a01, a10, a11, b00, b01, b10, b11, m) {
      var r00 = +b00;
      var r01 = +b01;
      var r10 = +b10;
      var r11 = -b11;
      var m00 = b00 * r00 + b01 * r01 + b10 * r10 - b11 * r11;
      var m01 = 0;
      var m10 = 0;
      var m11 = 0;
      var c00 = +m00;
      var c01 = -m01;
      var c10 = -m10;
      var c11 = -m11;
      var s00 = r00 * c00 + r01 * c01 + r10 * c10 - r11 * c11;
      var s01 = r00 * c01 + r01 * c00 - r10 * c11 + r11 * c10;
      var s10 = r00 * c10 + r01 * c11 + r10 * c00 - r11 * c01;
      var s11 = r00 * c11 + r01 * c10 - r10 * c01 + r11 * c00;
      var k00 = b00 * s00 + b01 * s01 + b10 * s10 - b11 * s11;
      var i00 = s00 / k00;
      var i01 = s01 / k00;
      var i10 = s10 / k00;
      var i11 = s11 / k00;
      var x00 = a00 * i00 + a01 * i01 + a10 * i10 - a11 * i11;
      var x01 = a00 * i01 + a01 * i00 - a10 * i11 + a11 * i10;
      var x10 = a00 * i10 + a01 * i11 + a10 * i00 - a11 * i01;
      var x11 = a00 * i11 + a01 * i10 - a10 * i01 + a11 * i00;
      if (typeof m !== 'undefined') {
        m[PROP_W] = x00;
        m[PROP_X] = x01;
        m[PROP_Y] = x10;
        m[PROP_XY] = x11;
      } else {
        return coordJsToLorentzianPy(x00, x01, x10, x11);
      }
    }
    mod[SCALAR_L4] = Sk.ffi.functionPy(function (valuePy) {
      Sk.ffi.checkFunctionArgs(SCALAR_L4, arguments, 1, 1);
      var zero = Sk.ffi.numberToFloatPy(0);
      var x0 = valuePy;
      var x1 = zero;
      var x2 = zero;
      var x3 = zero;
      var x4 = zero;
      var x5 = zero;
      var x6 = zero;
      var x7 = zero;
      var x8 = zero;
      var x9 = zero;
      var xA = zero;
      var xB = zero;
      var xC = zero;
      var xD = zero;
      var xE = zero;
      var xF = zero;
      return coordPyToLorentzianPy(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, xA, xB, xC, xD, xE, xF);
    });
    mod[VECTOR_L4] = Sk.ffi.functionPy(function (x, y, z, t) {
      Sk.ffi.checkFunctionArgs(VECTOR_L4, arguments, 4, 4);
      var zero = Sk.ffi.numberToFloatPy(0);
      var x0 = zero;
      var x1 = x;
      var x2 = y;
      var x3 = zero;
      var x4 = z;
      var x5 = zero;
      var x6 = zero;
      var x7 = zero;
      var x8 = t;
      var x9 = zero;
      var xA = zero;
      var xB = zero;
      var xC = zero;
      var xD = zero;
      var xE = zero;
      var xF = zero;
      return coordPyToLorentzianPy(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, xA, xB, xC, xD, xE, xF);
    });
    mod[PSEUDOSCALAR_L4] = Sk.ffi.functionPy(function (xy) {
      Sk.ffi.checkFunctionArgs(PSEUDOSCALAR_L4, arguments, 1, 1);
      Sk.ffi.checkArgType(PROP_XY, NUM, Sk.ffi.isNum(xy), xy);
      return coordJsToLorentzianPy(0, 0, 0, Sk.ffi.remapToJs(xy));
    });
    mod[LORENTZIAN] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, xA, xB, xC, xD, xE, xF) {
        Sk.ffi.checkMethodArgs(LORENTZIAN, arguments, 1, 16);
        if (isLorentzianPy(x0)) {
          Sk.ffi.checkMethodArgs(LORENTZIAN, arguments, 1, 1);
          Sk.ffi.referenceToPy(Sk.ffi.remapToJs(x0), LORENTZIAN, undefined, selfPy);
        } else {
          Sk.ffi.checkMethodArgs(LORENTZIAN, arguments, 16, 16);
          var mv = {};
          mv[0] = x0;
          mv[1] = x1;
          mv[2] = x2;
          mv[3] = x3;
          mv[4] = x4;
          mv[5] = x5;
          mv[6] = x6;
          mv[7] = x7;
          mv[8] = x8;
          mv[9] = x9;
          mv[10] = xA;
          mv[11] = xB;
          mv[12] = xC;
          mv[13] = xD;
          mv[14] = xE;
          mv[15] = xF;
          Sk.ffi.referenceToPy(mv, LORENTZIAN, undefined, selfPy);
        }
      });
      $loc.__add__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var lhs = Sk.ffi.remapToJs(selfPy);
        var rhs = Sk.ffi.remapToJs(otherPy);
        if (isLorentzianPy(otherPy)) {
          var zero = Sk.ffi.numberToFloatPy(0);
          var x0 = Sk.ffh.add(lhs[0], rhs[0]);
          var x1 = Sk.ffh.add(lhs[1], rhs[1]);
          var x2 = Sk.ffh.add(lhs[2], rhs[2]);
          var x3 = zero;
          var x4 = Sk.ffh.add(lhs[4], rhs[4]);
          var x5 = zero;
          var x6 = zero;
          var x7 = zero;
          var x8 = Sk.ffh.add(lhs[8], rhs[8]);
          var x9 = zero;
          var xA = zero;
          var xB = zero;
          var xC = zero;
          var xD = zero;
          var xE = zero;
          var xF = zero;
          return coordPyToLorentzianPy(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, xA, xB, xC, xD, xE, xF);
        } else if (Sk.ffi.isNum(otherPy)) {
          var zero = Sk.ffi.numberToFloatPy(0);
          var x0 = Sk.ffh.add(lhs[0], rhs);
          var x1 = lhs[1];
          var x2 = lhs[2];
          var x3 = zero;
          var x4 = lhs[4];
          var x5 = zero;
          var x6 = zero;
          var x7 = zero;
          var x8 = lhs[8];
          var x9 = zero;
          var xA = zero;
          var xB = zero;
          var xC = zero;
          var xD = zero;
          var xE = zero;
          var xF = zero;
          return coordPyToLorentzianPy(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, xA, xB, xC, xD, xE, xF);
        } else {
          Sk.ffi.checkRhsOperandType(OP_ADD, LORENTZIAN_OR_NUMBER, false, otherPy);
        }
      });
      $loc.__radd__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkLhsOperandType(OP_ADD, LORENTZIAN_OR_NUMBER, Sk.ffi.isNum(otherPy), otherPy);
        var lhs = Sk.ffi.remapToJs(otherPy);
        var rhs = Sk.ffi.remapToJs(selfPy);
        var zero = Sk.ffi.numberToFloatPy(0);
        var x0;
        try {
          x0 = Sk.ffh.add(lhs, rhs[0]);
        } catch (e) {
          x0 = Sk.ffh.add(rhs[0], lhs);
        }
        var x1 = rhs[1];
        var x2 = rhs[2];
        var x3 = zero;
        var x4 = rhs[4];
        var x5 = zero;
        var x6 = zero;
        var x7 = zero;
        var x8 = rhs[8];
        var x9 = zero;
        var xA = zero;
        var xB = zero;
        var xC = zero;
        var xD = zero;
        var xE = zero;
        var xF = zero;
        return coordPyToLorentzianPy(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, xA, xB, xC, xD, xE, xF);
      });
      $loc.__iadd__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var other = Sk.ffi.remapToJs(otherPy);
        if (Sk.ffi.isNum(otherPy)) {
          self.w += other;
          return selfPy;
        } else if (isLorentzianPy(otherPy)) {
          self.w += other.w;
          self.x += other.x;
          self.y += other.y;
          self.xy += other.xy;
          return selfPy;
        } else {
          Sk.ffi.checkRhsOperandType(OP_ADD, LORENTZIAN_OR_NUMBER, Sk.ffi.isNum(otherPy), otherPy);
        }
      });
      $loc.__sub__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var lhs = Sk.ffi.remapToJs(selfPy);
        var rhs = Sk.ffi.remapToJs(otherPy);
        if (Sk.ffi.isNum(otherPy)) {
          return coordJsToLorentzianPy(lhs.w - rhs, lhs.x, lhs.y, lhs.xy);
        } else if (isLorentzianPy(otherPy)) {
          return coordJsToLorentzianPy(lhs.w - rhs.w, lhs.x - rhs.x, lhs.y - rhs.y, lhs.xy - rhs.xy);
        } else {
          Sk.ffi.checkRhsOperandType(OP_SUB, LORENTZIAN_OR_NUMBER, Sk.ffi.isNum(otherPy), otherPy);
        }
      });
      $loc.__rsub__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkLhsOperandType(OP_ADD, LORENTZIAN_OR_NUMBER, Sk.ffi.isNum(otherPy), otherPy);
        var lhs = Sk.ffi.remapToJs(otherPy);
        var rhs = Sk.ffi.remapToJs(selfPy);
        return coordJsToLorentzianPy(lhs - rhs.w, -rhs.x, -rhs.y, -rhs.xy);
      });
      $loc.__isub__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var other = Sk.ffi.remapToJs(otherPy);
        if (isNumber(other)) {
          self.w -= other;
          return selfPy;
        } else {
          self.w -= other.w;
          self.x -= other.x;
          self.y -= other.y;
          self.xy -= other.xy;
          return selfPy;
        }
      });
      $loc.__mul__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var lhs = Sk.ffi.remapToJs(selfPy);
        var rhs = Sk.ffi.remapToJs(otherPy);
        function sum(numbers) {
          var total = Sk.ffi.numberToIntPy(0);
          for (var i = 0; i < numbers.length; i++) {
            total = Sk.ffh.add(total, numbers[i]);
          }
          return total;
        }
        function expand(es) {
          return es.map(function (e) {
            var signum = e[0];
            var a = lhs[e[1]];
            var b = rhs[e[2]];
            var c = Sk.ffh.multiply(a, b);
            if (signum > 0) {
              return c;
            } else {
              return Sk.ffh.negative(c);
            }
          });
        }
        if (isLorentzianPy(otherPy)) {
          var zero = Sk.ffi.numberToFloatPy(0);
          var x0 = sum(expand([
              [
                +1,
                0,
                0
              ],
              [
                +1,
                1,
                1
              ],
              [
                +1,
                2,
                2
              ],
              [
                -1,
                3,
                3
              ],
              [
                +1,
                4,
                4
              ],
              [
                -1,
                5,
                5
              ],
              [
                -1,
                6,
                6
              ],
              [
                -1,
                7,
                7
              ],
              [
                +1,
                8,
                8
              ],
              [
                -1,
                9,
                9
              ],
              [
                -1,
                10,
                10
              ],
              [
                +1,
                11,
                11
              ],
              [
                -1,
                12,
                12
              ],
              [
                +1,
                13,
                13
              ],
              [
                +1,
                14,
                14
              ],
              [
                -1,
                15,
                15
              ]
            ]));
          var x1 = sum(expand([
              [
                +1,
                1,
                0
              ],
              [
                +1,
                0,
                1
              ],
              [
                +1,
                3,
                2
              ],
              [
                -1,
                2,
                3
              ],
              [
                +1,
                5,
                4
              ],
              [
                -1,
                4,
                5
              ],
              [
                -1,
                7,
                6
              ],
              [
                -1,
                6,
                7
              ],
              [
                -1,
                9,
                8
              ],
              [
                +1,
                8,
                9
              ],
              [
                -1,
                11,
                10
              ]
            ]));
          var x2 = sum(expand([
              [
                +1,
                2,
                0
              ],
              [
                -1,
                3,
                1
              ],
              [
                +1,
                0,
                2
              ]
            ]));
          var x3 = sum(expand([
              [
                +1,
                3,
                0
              ],
              [
                -1,
                2,
                1
              ],
              [
                +1,
                1,
                2
              ],
              [
                +1,
                0,
                3
              ],
              [
                +1,
                7,
                4
              ],
              [
                +1,
                6,
                5
              ],
              [
                -1,
                5,
                6
              ],
              [
                +1,
                4,
                7
              ],
              [
                -1,
                11,
                8
              ],
              [
                -1,
                10,
                9
              ],
              [
                +1,
                9,
                10
              ],
              [
                -1,
                8,
                11
              ],
              [
                -1,
                15,
                12
              ],
              [
                -1,
                14,
                13
              ],
              [
                +1,
                13,
                14
              ],
              [
                +1,
                12,
                15
              ]
            ]));
          var x4 = sum(expand([[
                +1,
                4,
                0
              ]]));
          var x5 = sum(expand([[
                +1,
                5,
                0
              ]]));
          var x6 = sum(expand([[
                +1,
                6,
                0
              ]]));
          var x7 = sum(expand([[
                +1,
                7,
                0
              ]]));
          var x8 = sum(expand([[
                +1,
                8,
                0
              ]]));
          var x9 = sum(expand([[
                +1,
                9,
                0
              ]]));
          var xA = sum(expand([[
                +1,
                10,
                0
              ]]));
          var xB = sum(expand([[
                +1,
                11,
                0
              ]]));
          var xC = sum(expand([[
                +1,
                12,
                0
              ]]));
          var xD = sum(expand([[
                +1,
                13,
                0
              ]]));
          var xE = sum(expand([[
                +1,
                14,
                0
              ]]));
          var xF = sum(expand([[
                +1,
                15,
                0
              ]]));
          return coordPyToLorentzianPy(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, xA, xB, xC, xD, xE, xF);
        } else if (Sk.ffi.isNum(otherPy)) {
          var x0 = Sk.ffh.add(lhs[0], rhs);
          var x1 = Sk.ffh.add(lhs[1], rhs);
          var x2 = Sk.ffh.add(lhs[2], rhs);
          var x3 = Sk.ffh.add(lhs[3], rhs);
          var x4 = Sk.ffh.add(lhs[4], rhs);
          var x5 = Sk.ffh.add(lhs[5], rhs);
          var x6 = Sk.ffh.add(lhs[6], rhs);
          var x7 = Sk.ffh.add(lhs[7], rhs);
          var x8 = Sk.ffh.add(lhs[8], rhs);
          var x9 = Sk.ffh.add(lhs[9], rhs);
          var xA = Sk.ffh.add(lhs[10], rhs);
          var xB = Sk.ffh.add(lhs[11], rhs);
          var xC = Sk.ffh.add(lhs[12], rhs);
          var xD = Sk.ffh.add(lhs[13], rhs);
          var xE = Sk.ffh.add(lhs[14], rhs);
          var xF = Sk.ffh.add(lhs[15], rhs);
          return coordPyToLorentzianPy(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, xA, xB, xC, xD, xE, xF);
        } else {
          Sk.ffi.checkRhsOperandType(OP_MUL, LORENTZIAN_OR_NUMBER, false, otherPy);
        }
      });
      $loc.__rmul__ = Sk.ffi.functionPy(function (rhs, lhs) {
        lhs = Sk.ffi.remapToJs(lhs);
        rhs = Sk.ffi.remapToJs(rhs);
        if (isNumber(lhs)) {
          return coordJsToLorentzianPy(lhs * rhs.w, lhs * rhs.x, lhs * rhs.y, lhs * rhs.xy);
        } else {
          throw new Sk.builtin.AssertionError('' + JSON.stringify(lhs, null, 2) + ' * ' + JSON.stringify(rhs, null, 2));
        }
      });
      $loc.__imul__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var other = Sk.ffi.remapToJs(otherPy);
        if (isNumber(other)) {
          self.w *= other;
          self.x *= other;
          self.y *= other;
          self.xy *= other;
          return selfPy;
        } else {
          var a00 = self.w;
          var a01 = self.x;
          var a10 = self.y;
          var a11 = self.xy;
          var b00 = other.w;
          var b01 = other.x;
          var b10 = other.y;
          var b11 = other.xy;
          self.w = a00 * b00 + a01 * b01 + a10 * b10 - a11 * b11;
          self.x = a00 * b01 + a01 * b00 - a10 * b11 + a11 * b10;
          self.y = a00 * b10 + a01 * b11 + a10 * b00 - a11 * b01;
          self.xy = a00 * b11 + a01 * b10 - a10 * b01 + a11 * b00;
          return selfPy;
        }
      });
      $loc.__div__ = Sk.ffi.functionPy(function (a, b) {
        a = Sk.ffi.remapToJs(a);
        b = Sk.ffi.remapToJs(b);
        if (isNumber(b)) {
          return divide(a.w, a.x, a.y, a.xy, b, 0, 0, 0, undefined);
        } else {
          return divide(a.w, a.x, a.y, a.xy, b.w, b.x, b.y, b.xy, undefined);
        }
      });
      $loc.__rdiv__ = Sk.ffi.functionPy(function (rhs, lhs) {
        lhs = Sk.ffi.remapToJs(lhs);
        rhs = Sk.ffi.remapToJs(rhs);
        if (isNumber(lhs)) {
          return divide(lhs, 0, 0, 0, rhs.w, rhs.x, rhs.y, rhs.xy, undefined);
        } else {
          throw new Sk.builtin.AssertionError('' + JSON.stringify(lhs, null, 2) + ' / ' + JSON.stringify(rhs, null, 2));
        }
      });
      $loc.__idiv__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var other = Sk.ffi.remapToJs(otherPy);
        if (isNumber(other)) {
          divide(self.w, self.x, self.y, self.xy, other, 0, 0, 0, self);
          return selfPy;
        } else {
          divide(self.w, self.x, self.y, self.xy, other.w, other.x, other.y, other.xy, self);
          return selfPy;
        }
      });
      $loc.__xor__ = Sk.ffi.functionPy(function (a, b) {
        a = Sk.ffi.remapToJs(a);
        b = Sk.ffi.remapToJs(b);
        if (isNumber(b)) {
          return coordJsToLorentzianPy(a.w * b, a.x * b, a.y * b, a.xy * b);
        } else {
          var a00 = a.w;
          var a01 = a.x;
          var a10 = a.y;
          var a11 = a.xy;
          var b00 = b.w;
          var b01 = b.x;
          var b10 = b.y;
          var b11 = b.xy;
          var x00 = a00 * b00;
          var x01 = a00 * b01 + a01 * b00;
          var x10 = a00 * b10 + a10 * b00;
          var x11 = a00 * b11 + a01 * b10 - a10 * b01 + a11 * b00;
          return coordJsToLorentzianPy(x00, x01, x10, x11);
        }
      });
      $loc.__rxor__ = Sk.ffi.functionPy(function (rhs, lhs) {
        lhs = Sk.ffi.remapToJs(lhs);
        rhs = Sk.ffi.remapToJs(rhs);
        if (isNumber(lhs)) {
          return coordJsToLorentzianPy(lhs * rhs.w, lhs * rhs.x, lhs * rhs.y, lhs * rhs.xy);
        } else {
          throw new Sk.builtin.AssertionError('' + JSON.stringify(lhs, null, 2) + ' ^ ' + JSON.stringify(rhs, null, 2));
        }
      });
      $loc.__ixor__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var other = Sk.ffi.remapToJs(otherPy);
        if (isNumber(other)) {
          self.w *= other;
          self.x *= other;
          self.y *= other;
          self.xy *= other;
          return selfPy;
        } else {
          var a00 = self.w;
          var a01 = self.x;
          var a10 = self.y;
          var a11 = self.xy;
          var b00 = other.w;
          var b01 = other.x;
          var b10 = other.y;
          var b11 = other.xy;
          self.w = a00 * b00;
          self.x = a00 * b01 + a01 * b00;
          self.y = a00 * b10 + a10 * b00;
          self.xy = a00 * b11 + a01 * b10 - a10 * b01 + a11 * b00;
          return selfPy;
        }
      });
      $loc.__lshift__ = Sk.ffi.functionPy(function (a, b) {
        a = Sk.ffi.remapToJs(a);
        b = Sk.ffi.remapToJs(b);
        if (isNumber(b)) {
          return coordJsToLorentzianPy(a.w * b, 0, 0, 0);
        } else {
          var a00 = a.w;
          var a01 = a.x;
          var a10 = a.y;
          var a11 = a.xy;
          var b00 = b.w;
          var b01 = b.x;
          var b10 = b.y;
          var b11 = b.xy;
          var x00 = a00 * b00 + a01 * b01 + a10 * b10 - a11 * b11;
          var x01 = a00 * b01 - a10 * b11;
          var x10 = a00 * b10 + a01 * b11;
          var x11 = a00 * b11;
          return coordJsToLorentzianPy(x00, x01, x10, x11);
        }
      });
      $loc.__rlshift__ = Sk.ffi.functionPy(function (rhs, lhs) {
        lhs = Sk.ffi.remapToJs(lhs);
        rhs = Sk.ffi.remapToJs(rhs);
        if (isNumber(lhs)) {
          return coordJsToLorentzianPy(lhs * rhs.w, lhs * rhs.x, lhs * rhs.y, lhs * rhs.xy);
        } else {
          throw new Sk.builtin.AssertionError('' + JSON.stringify(lhs, null, 2) + ' << ' + JSON.stringify(rhs, null, 2));
        }
      });
      $loc.__ilshift__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var other = Sk.ffi.remapToJs(otherPy);
        if (isNumber(other)) {
          self.w *= other;
          self.x = 0;
          self.y = 0;
          self.xy = 0;
          return selfPy;
        } else {
          var a00 = self.w;
          var a01 = self.x;
          var a10 = self.y;
          var a11 = self.xy;
          var b00 = other.w;
          var b01 = other.x;
          var b10 = other.y;
          var b11 = other.xy;
          self.w = a00 * b00 + a01 * b01 + a10 * b10 - a11 * b11;
          self.x = a00 * b01 - a10 * b11;
          self.y = a00 * b10 + a01 * b11;
          self.xy = a00 * b11;
          return selfPy;
        }
      });
      $loc.__rshift__ = Sk.ffi.functionPy(function (a, b) {
        a = Sk.ffi.remapToJs(a);
        b = Sk.ffi.remapToJs(b);
        if (isNumber(b)) {
          return coordJsToLorentzianPy(a.w * b, -a.x * b, -a.y * b, a.xy * b);
        } else {
          var a00 = a.w;
          var a01 = a.x;
          var a10 = a.y;
          var a11 = a.xy;
          var b00 = b.w;
          var b01 = b.x;
          var b10 = b.y;
          var b11 = b.xy;
          var x00 = a00 * b00 + a01 * b01 + a10 * b10 - a11 * b11;
          var x01 = +a01 * b00 + a11 * b10;
          var x10 = +a10 * b00 - a11 * b01;
          var x11 = a11 * b00;
          return coordJsToLorentzianPy(x00, x01, x10, x11);
        }
      });
      $loc.__rrshift__ = Sk.ffi.functionPy(function (rhs, lhs) {
        lhs = Sk.ffi.remapToJs(lhs);
        rhs = Sk.ffi.remapToJs(rhs);
        if (isNumber(lhs)) {
          return coordJsToLorentzianPy(lhs * rhs.w, 0, 0, 0);
        } else {
          throw new Sk.builtin.AssertionError('' + JSON.stringify(lhs, null, 2) + ' >> ' + JSON.stringify(rhs, null, 2));
        }
      });
      $loc.__irshift__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var other = Sk.ffi.remapToJs(otherPy);
        if (isNumber(other)) {
          var a00 = self.w;
          var a01 = self.x;
          var a10 = self.y;
          var a11 = self.xy;
          var b00 = other;
          var b01 = 0;
          var b10 = 0;
          var b11 = 0;
          self.w *= other;
          self.x *= -other;
          self.y *= -other;
          self.xy *= other;
          return selfPy;
        } else {
          var a00 = self.w;
          var a01 = self.x;
          var a10 = self.y;
          var a11 = self.xy;
          var b00 = other.w;
          var b01 = other.x;
          var b10 = other.y;
          var b11 = other.xy;
          self.w = a00 * b00 + a01 * b01 + a10 * b10 - a11 * b11;
          self.x = +a01 * b00 + a11 * b10;
          self.y = +a10 * b00 - a11 * b01;
          self.xy = a11 * b00;
          return selfPy;
        }
      });
      $loc.nu$negative = function () {
        var self = Sk.ffi.remapToJs(this);
        return coordJsToLorentzianPy(-self.w, -self.x, -self.y, -self.xy);
      };
      $loc.nb$positive = function () {
        return this;
      };
      $loc.nb$invert = function () {
        var self = Sk.ffi.remapToJs(this);
        return coordJsToLorentzianPy(self.w, self.x, self.y, -self.xy);
      };
      $loc.__getitem__ = Sk.ffi.functionPy(function (mv, index) {
        mv = Sk.ffi.remapToJs(mv);
        index = Sk.ffi.remapToJs(index);
        switch (index) {
        case 0: {
            return coordJsToLorentzianPy(mv.w, 0, 0, 0);
          }
        case 1: {
            return coordJsToLorentzianPy(0, mv.x, mv.y, 0);
          }
        case 2: {
            return coordJsToLorentzianPy(0, 0, 0, mv.xy);
          }
        }
      });
      $loc.__abs__ = Sk.ffi.functionPy(function (selfPy) {
        var mv = Sk.ffi.remapToJs(selfPy);
        return Sk.ffi.numberToFloatPy(Math.sqrt(mv.w * mv.w + mv.x * mv.x + mv.y * mv.y - mv.xy * mv.xy));
      });
      $loc.__exp__ = Sk.ffi.functionPy(function (selfPy) {
        var mv = Sk.ffi.remapToJs(selfPy);
        var e = Math.exp(mv.w);
        var c = Sk.math.cos(mv.xy);
        var s = Sk.math.sin(mv.xy);
        return coordJsToLorentzianPy(e * c, 0, 0, e * s);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (mv) {
        mv = Sk.ffi.remapToJs(mv);
        return Sk.ffi.stringToPy(LORENTZIAN + '(' + [
          mv.w,
          mv.x,
          mv.y,
          mv.xy
        ].map(function (x) {
          return String(x);
        }).join(', ') + ')');
      });
      $loc.__str__ = Sk.ffi.functionPy(function (mv) {
        mv = Sk.ffi.remapToJs(mv);
        if (mv.isNaN()) {
          return Sk.ffi.stringToPy('NaN');
        } else {
          return Sk.ffi.stringToPy(stringFromCoordinates([
            mv.w,
            mv.x,
            mv.y,
            mv.xy
          ], [
            '1',
            'i',
            'j',
            'I'
          ], '*'));
        }
      });
      $loc.__eq__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        return Sk.ffi.bool.True;
      });
      $loc.__ne__ = Sk.ffi.functionPy(function (a, b) {
        a = Sk.ffi.remapToJs(a);
        b = Sk.ffi.remapToJs(b);
        return a.w !== b.w || a.x !== b.x || a.y !== b.y || a.xy !== b.xy;
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (mvPy, name) {
        var mv = Sk.ffi.remapToJs(mvPy);
        switch (name) {
        case PROP_W: {
            return mv[0];
          }
        case PROP_X: {
            return mv[1];
          }
        case PROP_Y: {
            return mv[2];
          }
        case PROP_XY: {
            return mv[3];
          }
        case PROP_YX: {
            return Sk.ffh.negative(mv[3]);
          }
        case PROP_Z: {
            return mv[4];
          }
        case PROP_XZ: {
            return mv[5];
          }
        case PROP_ZX: {
            return Sk.ffh.negative(mv[5]);
          }
        case PROP_YZ: {
            return mv[6];
          }
        case PROP_ZY: {
            return Sk.ffh.negative(mv[6]);
          }
        case PROP_XYZ: {
            return mv[7];
          }
        case PROP_T: {
            return mv[8];
          }
        case PROP_XT: {
            return mv[9];
          }
        case PROP_TX: {
            return Sk.ffh.negative(mv[9]);
          }
        case PROP_YT: {
            return mv[10];
          }
        case PROP_TY: {
            return Sk.ffh.negative(mv[10]);
          }
        case PROP_XYT: {
            return mv[11];
          }
        case PROP_ZT: {
            return mv[12];
          }
        case PROP_TZ: {
            return Sk.ffh.negative(mv[12]);
          }
        case PROP_XZT: {
            return mv[13];
          }
        case PROP_ZXT: {
            return Sk.ffh.negative(mv[13]);
          }
        case PROP_YZT: {
            return mv[14];
          }
        case PROP_XYZT: {
            return mv[15];
          }
        case METHOD_CLONE: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (methodPy) {
              });
              $loc.__call__ = Sk.ffi.functionPy(function (methodPy) {
                return coordJsToLorentzianPy(mv.w, mv.x, mv.y, mv.xy);
              });
            }, METHOD_CLONE, []));
          }
        case METHOD_MAGNITUDE: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (self) {
              });
              $loc.__call__ = Sk.ffi.functionPy(function (self) {
                return Sk.ffi.numberToFloatPy(Math.sqrt(mv.w * mv.w + mv.x * mv.x + mv.y * mv.y - mv.xy * mv.xy));
              });
            }, METHOD_MAGNITUDE, []));
          }
        case METHOD_QUADRANCE: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy) {
              var quadrance = Sk.ffh.multiply(mv[0], mv[0]);
              quadrance = Sk.ffh.add(quadrance, Sk.ffh.multiply(mv[1], mv[1]));
              quadrance = Sk.ffh.add(quadrance, Sk.ffh.multiply(mv[2], mv[2]));
              quadrance = Sk.ffh.add(quadrance, Sk.ffh.multiply(mv[4], mv[4]));
              quadrance = Sk.ffh.subtract(quadrance, Sk.ffh.multiply(mv[8], mv[8]));
              return quadrance;
            });
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(LORENTZIAN);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        var self = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case PROP_W:
        case PROP_X:
        case PROP_Y:
        case PROP_XY: {
            Sk.ffi.checkArgType(name, [
              Sk.ffi.PyType.FLOAT,
              Sk.ffi.PyType.INT,
              Sk.ffi.PyType.LONG
            ], Sk.ffi.isNum(valuePy), valuePy);
            self[name] = Sk.ffi.remapToJs(valuePy);
          }
          break;
        default: {
            throw Sk.ffi.err.attribute(name).isNotSetableOnType(LORENTZIAN);
          }
        }
      });
    }, LORENTZIAN, []);
  };
}.call(this));
Sk.symbolic = Sk.symbolic || {};
Sk.symbolic.VARIABLE = 'Variable';
(function () {
  Sk.builtin.defineSymbolic = function (mod, SYMBOLIC) {
    Sk.ffi.checkFunctionArgs('defineSymbolic', arguments, 2, 2);
    var BINDING = 'Binding';
    var PROP_CLASS_NAME = 'className';
    var ASSOC_L = 'AssocL';
    var ASSOC_R = 'AssocR';
    var COMMUTE = 'Commute';
    var DISTRIB_L = 'DistribL';
    var DISTRIB_R = 'DistribR';
    var FACTOR_L = 'FactorL';
    var FACTOR_R = 'FactorR';
    var PROP_ANCESTOR_AXIS = 'ancestorAxis';
    var PROP_CHILD_AXIS = 'childAxis';
    var ENVIRONMENT = 'Environment';
    var POINT_E2 = 'PointE2';
    var VARIABLE = 'Variable';
    var ADD = 'Add';
    var SUBTRACT = 'Subtract';
    var MULTIPLY = 'Multiply';
    var PROP_BINDINGS = 'bindings';
    var PROP_CONTEXT_NODE = 'contextNode';
    var PROP_ENV = 'env';
    var PROP_EXPR = 'expr';
    var PROP_NAME = 'name';
    var PROP_PARENT = 'parent';
    var PROP_LHS = 'lhs';
    var PROP_RHS = 'rhs';
    var PROP_UUID = 'uuid';
    var PROP_X = 'x';
    var PROP_Y = 'y';
    var METHOD_EVALUATE = 'evaluate';
    var METHOD_EXECUTE = 'execute';
    var METHOD_LOOKUP = 'lookup';
    var METHOD_MOVE_TO_FIRST_CHILD = 'moveToFirstChild';
    var METHOD_MOVE_TO_LAST_CHILD = 'moveToLastChild';
    var METHOD_MOVE_TO_PARENT = 'moveToParent';
    var ARG_BINDING = 'binding';
    var OP_SYMBOL_ADD = '+';
    var OP_SYMBOL_SUBTRACT = '-';
    var OP_SYMBOL_MULTIPLY = '*';
    var COMMA = ',';
    var SPACE = ' ';
    var LPAREN = '(';
    var RPAREN = ')';
    var TREE_WALKER = 'TreeWalker';
    Sk.symbolic.treeGetAttr = function (className, selfPy, name) {
      var self = Sk.ffi.remapToJs(selfPy);
      switch (name) {
      case PROP_CHILD_AXIS: {
          return Sk.ffi.listPy(self[name]);
        }
      case PROP_UUID: {
          return Sk.ffi.stringToPy(self[name]);
        }
      default: {
          throw Sk.ffi.err.attribute(name).isNotGetableOnType(className);
        }
      }
    };
    Sk.symbolic.treeSetAttr = function (className, selfPy, name, valuePy) {
      var self = Sk.ffi.remapToJs(selfPy);
      switch (name) {
      default: {
          throw Sk.ffi.err.attribute(name).isNotSetableOnType(className);
        }
      }
    };
    mod[ENVIRONMENT] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, parentPy, bindingPy) {
        Sk.ffi.checkMethodArgs(ENVIRONMENT, arguments, 0, 2);
        var env = {};
        env[PROP_BINDINGS] = {};
        if (typeof parentPy !== 'undefined' && !Sk.ffi.isNone(parentPy)) {
          Sk.ffi.checkArgType(PROP_PARENT, ENVIRONMENT, Sk.ffi.isInstance(parentPy, ENVIRONMENT), parentPy);
          env[PROP_PARENT] = parentPy;
        }
        if (typeof bindingPy !== 'undefined' && !Sk.ffi.isNone(bindingPy)) {
          Sk.ffi.checkArgType(ARG_BINDING, BINDING, Sk.ffi.isInstance(bindingPy, BINDING), bindingPy);
          var namePy = Sk.ffi.gattr(bindingPy, PROP_NAME);
          Sk.ffi.checkArgType(PROP_NAME, Sk.ffi.PyType.STR, Sk.ffi.isStr(namePy), namePy);
          var exprPy = Sk.ffi.gattr(bindingPy, PROP_EXPR);
          env[PROP_BINDINGS][Sk.ffi.remapToJs(namePy)] = exprPy;
        }
        Sk.ffi.referenceToPy(env, ENVIRONMENT, undefined, selfPy);
      });
      $loc.__add__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkMethodArgs(OP_SYMBOL_ADD, arguments, 1, 1);
        return Sk.ffi.callsim(mod[ENVIRONMENT], selfPy, otherPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var env = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case METHOD_LOOKUP: {
            return Sk.ffi.callableToPy(mod, METHOD_LOOKUP, function (methodPy, namePy) {
              Sk.ffi.checkMethodArgs(METHOD_LOOKUP, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_NAME, Sk.ffi.PyType.STR, Sk.ffi.isStr(namePy), namePy);
              var name = Sk.ffi.remapToJs(namePy);
              if (typeof env[PROP_BINDINGS][name] !== 'undefined') {
                return env[PROP_BINDINGS][name];
              } else if (typeof env[PROP_PARENT] !== 'undefined') {
                return Sk.ffi.callsim(Sk.ffi.gattr(env[PROP_PARENT], METHOD_LOOKUP), namePy);
              } else {
                return Sk.ffi.none.None;
              }
            });
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(ENVIRONMENT);
          }
        }
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        return Sk.ffi.stringToPy(ENVIRONMENT + '(' + ')');
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        return Sk.ffi.stringToPy(ENVIRONMENT);
      });
    }, ENVIRONMENT, []);
    mod[VARIABLE] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, namePy) {
        Sk.ffi.checkMethodArgs(VARIABLE, arguments, 1, 1);
        Sk.ffi.checkArgType(PROP_NAME, Sk.ffi.PyType.STR, Sk.ffi.isStr(namePy), namePy);
        var node = {};
        node[PROP_NAME] = namePy;
        node[PROP_UUID] = THREE.Math.generateUUID();
        node[PROP_CHILD_AXIS] = [];
        Sk.ffi.referenceToPy(node, VARIABLE, undefined, selfPy);
      });
      $loc.__add__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkMethodArgs(OP_SYMBOL_ADD, arguments, 1, 1);
        return Sk.ffi.callsim(mod[ADD], selfPy, otherPy);
      });
      $loc.__radd__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkMethodArgs(OP_SYMBOL_ADD, arguments, 1, 1);
        return Sk.ffi.callsim(mod[ADD], otherPy, selfPy);
      });
      $loc.__sub__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkMethodArgs(OP_SYMBOL_SUBTRACT, arguments, 1, 1);
        return Sk.ffi.callsim(mod[SUBTRACT], selfPy, otherPy);
      });
      $loc.__mul__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkMethodArgs(OP_SYMBOL_MULTIPLY, arguments, 1, 1);
        return Sk.ffi.callsim(mod[MULTIPLY], selfPy, otherPy);
      });
      $loc.__rmul__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkMethodArgs(OP_SYMBOL_MULTIPLY, arguments, 1, 1);
        return Sk.ffi.callsim(mod[MULTIPLY], otherPy, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var self = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case METHOD_EVALUATE: {
            return Sk.ffi.callableToPy(mod, METHOD_EVALUATE, function (methodPy, envPy) {
              Sk.ffi.checkMethodArgs(METHOD_EVALUATE, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_ENV, ENVIRONMENT, Sk.ffi.isInstance(envPy, ENVIRONMENT), envPy);
              var lookup = Sk.ffi.gattr(envPy, METHOD_LOOKUP);
              var valuePy = Sk.ffi.callsim(lookup, self[PROP_NAME]);
              if (!Sk.ffi.isNone(valuePy)) {
                return valuePy;
              } else {
                return selfPy;
              }
            });
          }
        default: {
            return Sk.symbolic.treeGetAttr(VARIABLE, selfPy, name);
          }
        }
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        return Sk.ffi.stringToPy(VARIABLE + '("' + Sk.ffi.remapToJs(self[PROP_NAME]) + '")');
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        return self[PROP_NAME];
      });
    }, VARIABLE, []);
    mod[TREE_WALKER] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, nodePy) {
        Sk.ffi.checkMethodArgs(TREE_WALKER, arguments, 1, 1);
        var self = {};
        self[PROP_ANCESTOR_AXIS] = [];
        self[PROP_CONTEXT_NODE] = nodePy;
        self[PROP_CHILD_AXIS] = Sk.ffi.gattr(self[PROP_CONTEXT_NODE], PROP_CHILD_AXIS);
        Sk.ffi.referenceToPy(self, TREE_WALKER, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var self = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case PROP_ANCESTOR_AXIS: {
            return Sk.ffi.listPy(self[name]);
          }
        case PROP_CONTEXT_NODE: {
            return self[name];
          }
        case METHOD_MOVE_TO_FIRST_CHILD: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy) {
              var children = Sk.ffi.remapToJs(self[PROP_CHILD_AXIS]);
              if (children.length > 0) {
                var parentNodePy = self[PROP_CONTEXT_NODE];
                self[PROP_ANCESTOR_AXIS].push(parentNodePy);
                self[PROP_CONTEXT_NODE] = children[0];
                self[PROP_CHILD_AXIS] = Sk.ffi.gattr(self[PROP_CONTEXT_NODE], PROP_CHILD_AXIS);
                return Sk.ffi.booleanToPy(true);
              } else {
                return Sk.ffi.booleanToPy(false);
              }
            });
          }
        case METHOD_MOVE_TO_LAST_CHILD: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy) {
              var children = Sk.ffi.remapToJs(self[PROP_CHILD_AXIS]);
              if (children.length > 0) {
                var parentNodePy = self[PROP_CONTEXT_NODE];
                self[PROP_ANCESTOR_AXIS].push(parentNodePy);
                self[PROP_CONTEXT_NODE] = children[children.length - 1];
                self[PROP_CHILD_AXIS] = Sk.ffi.gattr(self[PROP_CONTEXT_NODE], PROP_CHILD_AXIS);
                return Sk.ffi.booleanToPy(true);
              } else {
                return Sk.ffi.booleanToPy(false);
              }
            });
          }
        case METHOD_MOVE_TO_PARENT: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy) {
              var children = Sk.ffi.remapToJs(self[PROP_CHILD_AXIS]);
              if (self[PROP_ANCESTOR_AXIS].length > 0) {
                var contextNodePy = self[PROP_ANCESTOR_AXIS].pop();
                self[PROP_CONTEXT_NODE] = contextNodePy;
                self[PROP_CHILD_AXIS] = Sk.ffi.gattr(self[PROP_CONTEXT_NODE], PROP_CHILD_AXIS);
                return Sk.ffi.booleanToPy(true);
              } else {
                return Sk.ffi.booleanToPy(false);
              }
            });
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(TREE_WALKER);
          }
        }
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        return Sk.ffi.stringToPy(TREE_WALKER + '(' + ')');
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        return Sk.ffi.stringToPy(TREE_WALKER);
      });
    }, TREE_WALKER, []);
    mod[BINDING] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, namePy, exprPy) {
        Sk.ffi.checkMethodArgs(BINDING, arguments, 2, 2);
        Sk.ffi.checkArgType(PROP_NAME, Sk.ffi.PyType.STR, Sk.ffi.isStr(namePy), namePy);
        var binding = {};
        binding[PROP_NAME] = namePy;
        binding[PROP_EXPR] = exprPy;
        Sk.ffi.referenceToPy(binding, BINDING, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var self = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case PROP_NAME: {
            return self[PROP_NAME];
          }
        case PROP_EXPR: {
            return self[PROP_EXPR];
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(BINDING);
          }
        }
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var args = [
            '"' + Sk.ffi.remapToJs(self[PROP_NAME]) + '"',
            Sk.ffi.remapToJs(Sk.ffh.repr(self[PROP_EXPR]))
          ].join(', ');
        return Sk.ffi.stringToPy(BINDING + '(' + args + ')');
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var s = [
            Sk.ffi.remapToJs(self[PROP_NAME]),
            Sk.ffi.remapToJs(Sk.ffh.str(self[PROP_EXPR]))
          ].join(' => ');
        return Sk.ffi.stringToPy(s);
      });
    }, BINDING, []);
    mod[ADD] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, lhsPy, rhsPy) {
        Sk.ffi.checkMethodArgs(ADD, arguments, 2, 2);
        var node = {};
        node[PROP_LHS] = lhsPy;
        node[PROP_RHS] = rhsPy;
        node[PROP_UUID] = THREE.Math.generateUUID();
        node[PROP_CHILD_AXIS] = [
          lhsPy,
          rhsPy
        ];
        Sk.ffi.referenceToPy(node, ADD, undefined, selfPy);
      });
      $loc.__add__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkMethodArgs(OP_SYMBOL_ADD, arguments, 1, 1);
        return Sk.ffi.callsim(mod[ADD], selfPy, otherPy);
      });
      $loc.__sub__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkMethodArgs(OP_SYMBOL_SUBTRACT, arguments, 1, 1);
        return Sk.ffi.callsim(mod[SUBTRACT], selfPy, otherPy);
      });
      $loc.__mul__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkMethodArgs(OP_SYMBOL_MULTIPLY, arguments, 1, 1);
        return Sk.ffi.callsim(mod[MULTIPLY], selfPy, otherPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var self = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case PROP_CLASS_NAME: {
            return Sk.ffi.stringToPy(ADD);
          }
        case PROP_LHS:
        case PROP_RHS: {
            return self[name];
          }
        case METHOD_EVALUATE: {
            return Sk.ffi.callableToPy(mod, METHOD_EVALUATE, function (methodPy, envPy) {
              Sk.ffi.checkMethodArgs(METHOD_EVALUATE, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_ENV, ENVIRONMENT, Sk.ffi.isInstance(envPy, ENVIRONMENT), envPy);
              var lhs = Sk.ffh.evaluate(self[PROP_LHS], envPy);
              var rhs = Sk.ffh.evaluate(self[PROP_RHS], envPy);
              return Sk.ffh.add(lhs, rhs);
            });
          }
        default: {
            return Sk.symbolic.treeGetAttr(ADD, selfPy, name);
          }
        }
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var args = [
            self[PROP_LHS],
            self[PROP_RHS]
          ].map(function (coord) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(coord));
          }).join(', ');
        return Sk.ffi.stringToPy(ADD + '(' + args + ')');
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var args = [
            self[PROP_LHS],
            self[PROP_RHS]
          ].map(function (arg) {
            return Sk.ffi.remapToJs(Sk.ffh.str(arg));
          }).join(' + ');
        return Sk.ffi.stringToPy(LPAREN + args + RPAREN);
      });
    }, ADD, []);
    mod[SUBTRACT] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, lhsPy, rhsPy) {
        Sk.ffi.checkMethodArgs(SUBTRACT, arguments, 2, 2);
        var node = {};
        node[PROP_LHS] = lhsPy;
        node[PROP_RHS] = rhsPy;
        node[PROP_UUID] = THREE.Math.generateUUID();
        node[PROP_CHILD_AXIS] = [
          lhsPy,
          rhsPy
        ];
        Sk.ffi.referenceToPy(node, SUBTRACT, undefined, selfPy);
      });
      $loc.__add__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkMethodArgs(OP_SYMBOL_ADD, arguments, 1, 1);
        return Sk.ffi.callsim(mod[ADD], selfPy, otherPy);
      });
      $loc.__mul__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkMethodArgs(OP_SYMBOL_MULTIPLY, arguments, 1, 1);
        return Sk.ffi.callsim(mod[MULTIPLY], selfPy, otherPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var self = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case METHOD_EVALUATE: {
            return Sk.ffi.callableToPy(mod, METHOD_EVALUATE, function (methodPy, envPy) {
              Sk.ffi.checkMethodArgs(METHOD_EVALUATE, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_ENV, ENVIRONMENT, Sk.ffi.isInstance(envPy, ENVIRONMENT), envPy);
              var lhs = Sk.ffh.evaluate(self[PROP_LHS], envPy);
              var rhs = Sk.ffh.evaluate(self[PROP_RHS], envPy);
              return Sk.ffh.subtract(lhs, rhs);
            });
          }
        default: {
            return Sk.symbolic.treeGetAttr(SUBTRACT, selfPy, name);
          }
        }
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var args = [
            self[PROP_LHS],
            self[PROP_RHS]
          ].map(function (coord) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(coord));
          }).join(COMMA + SPACE);
        return Sk.ffi.stringToPy(SUBTRACT + '(' + args + ')');
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var args = [
            self[PROP_LHS],
            self[PROP_RHS]
          ].map(function (arg) {
            return Sk.ffi.remapToJs(Sk.ffh.str(arg));
          }).join(SPACE + OP_SYMBOL_SUBTRACT + SPACE);
        return Sk.ffi.stringToPy(LPAREN + args + RPAREN);
      });
    }, SUBTRACT, []);
    mod[MULTIPLY] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, lhsPy, rhsPy) {
        Sk.ffi.checkMethodArgs(MULTIPLY, arguments, 2, 2);
        var node = {};
        node[PROP_LHS] = lhsPy;
        node[PROP_RHS] = rhsPy;
        node[PROP_UUID] = THREE.Math.generateUUID();
        node[PROP_CHILD_AXIS] = [
          lhsPy,
          rhsPy
        ];
        Sk.ffi.referenceToPy(node, MULTIPLY, undefined, selfPy);
      });
      $loc.__add__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkMethodArgs(OP_SYMBOL_ADD, arguments, 1, 1);
        return Sk.ffi.callsim(mod[ADD], selfPy, otherPy);
      });
      $loc.__mul__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkMethodArgs(OP_SYMBOL_MULTIPLY, arguments, 1, 1);
        return Sk.ffi.callsim(mod[MULTIPLY], selfPy, otherPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var self = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case PROP_CLASS_NAME: {
            return Sk.ffi.stringToPy(MULTIPLY);
          }
        case PROP_LHS:
        case PROP_RHS: {
            return self[name];
          }
        case METHOD_EVALUATE: {
            return Sk.ffi.callableToPy(mod, METHOD_EVALUATE, function (methodPy, envPy) {
              Sk.ffi.checkMethodArgs(METHOD_EVALUATE, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_ENV, ENVIRONMENT, Sk.ffi.isInstance(envPy, ENVIRONMENT), envPy);
              var lhs = Sk.ffh.evaluate(self[PROP_LHS], envPy);
              var rhs = Sk.ffh.evaluate(self[PROP_RHS], envPy);
              return Sk.ffh.multiply(lhs, rhs);
            });
          }
        default: {
            return Sk.symbolic.treeGetAttr(MULTIPLY, selfPy, name);
          }
        }
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var args = [
            self[PROP_LHS],
            self[PROP_RHS]
          ].map(function (coord) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(coord));
          }).join(', ');
        return Sk.ffi.stringToPy(MULTIPLY + '(' + args + ')');
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var args = [
            self[PROP_LHS],
            self[PROP_RHS]
          ].map(function (arg) {
            return Sk.ffi.remapToJs(Sk.ffh.str(arg));
          }).join(' * ');
        return Sk.ffi.stringToPy(LPAREN + args + RPAREN);
      });
    }, MULTIPLY, []);
    mod[POINT_E2] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, x, y) {
        Sk.ffi.checkMethodArgs(POINT_E2, arguments, 2, 2);
        var point = {};
        point[PROP_X] = x;
        point[PROP_Y] = y;
        Sk.ffi.referenceToPy(point, POINT_E2, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var point = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case METHOD_EVALUATE: {
            return Sk.ffi.callableToPy(mod, METHOD_EVALUATE, function (methodPy, envPy) {
              Sk.ffi.checkMethodArgs(METHOD_EVALUATE, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_ENV, ENVIRONMENT, Sk.ffi.isInstance(envPy, ENVIRONMENT), envPy);
              var x = Sk.ffh.evaluate(point[PROP_X], envPy);
              var y = Sk.ffh.evaluate(point[PROP_Y], envPy);
              return Sk.ffi.callsim(mod[POINT_E2], x, y);
            });
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(POINT_E2);
          }
        }
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var args = [
            self.x,
            self.y
          ].map(function (coord) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(coord));
          }).join(', ');
        return Sk.ffi.stringToPy(POINT_E2 + '(' + args + ')');
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var args = [
            self.x,
            self.y
          ].map(function (coord) {
            return Sk.ffi.remapToJs(Sk.ffh.str(coord));
          }).join(', ');
        return Sk.ffi.stringToPy('[' + args + ']');
      });
    }, POINT_E2, []);
    mod[COMMUTE] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy) {
        Sk.ffi.checkMethodArgs(COMMUTE, arguments, 0, 0);
        Sk.ffi.referenceToPy({}, COMMUTE, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var point = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case METHOD_EXECUTE: {
            return Sk.ffi.callableToPy(mod, METHOD_EVALUATE, function (methodPy, nodePy) {
              var className = Sk.ffi.remapToJs(Sk.ffi.gattr(nodePy, PROP_CLASS_NAME));
              var lhsPy = Sk.ffi.gattr(nodePy, PROP_LHS);
              var rhsPy = Sk.ffi.gattr(nodePy, PROP_RHS);
              Sk.ffi.checkMethodArgs(METHOD_EVALUATE, arguments, 1, 1);
              return Sk.ffi.callsim(mod[className], rhsPy, lhsPy);
            });
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(COMMUTE);
          }
        }
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffi.stringToPy(COMMUTE);
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffi.stringToPy(COMMUTE);
      });
    }, COMMUTE, []);
    mod[DISTRIB_L] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy) {
        Sk.ffi.checkMethodArgs(DISTRIB_L, arguments, 0, 0);
        Sk.ffi.referenceToPy({}, DISTRIB_L, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var point = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case METHOD_EXECUTE: {
            return Sk.ffi.callableToPy(mod, METHOD_EVALUATE, function (methodPy, nodePy) {
              Sk.ffi.checkMethodArgs(METHOD_EVALUATE, arguments, 1, 1);
              var nameOne = Sk.ffi.remapToJs(Sk.ffi.gattr(nodePy, PROP_CLASS_NAME));
              var aPy = Sk.ffi.gattr(nodePy, PROP_LHS);
              var tempPy = Sk.ffi.gattr(nodePy, PROP_RHS);
              var nameTwo = Sk.ffi.remapToJs(Sk.ffi.gattr(tempPy, PROP_CLASS_NAME));
              var bPy = Sk.ffi.gattr(tempPy, PROP_LHS);
              var cPy = Sk.ffi.gattr(tempPy, PROP_RHS);
              var lhsPy = Sk.ffi.callsim(mod[nameOne], aPy, bPy);
              var rhsPy = Sk.ffi.callsim(mod[nameOne], aPy, cPy);
              return Sk.ffi.callsim(mod[nameTwo], lhsPy, rhsPy);
            });
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(DISTRIB_L);
          }
        }
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffi.stringToPy(DISTRIB_L);
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffi.stringToPy(DISTRIB_L);
      });
    }, DISTRIB_L, []);
    mod[DISTRIB_R] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy) {
        Sk.ffi.checkMethodArgs(DISTRIB_R, arguments, 0, 0);
        Sk.ffi.referenceToPy({}, DISTRIB_R, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var point = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case METHOD_EXECUTE: {
            return Sk.ffi.callableToPy(mod, METHOD_EVALUATE, function (methodPy, nodePy) {
              Sk.ffi.checkMethodArgs(METHOD_EVALUATE, arguments, 1, 1);
              var nameOne = Sk.ffi.remapToJs(Sk.ffi.gattr(nodePy, PROP_CLASS_NAME));
              var tempPy = Sk.ffi.gattr(nodePy, PROP_LHS);
              var nameTwo = Sk.ffi.remapToJs(Sk.ffi.gattr(tempPy, PROP_CLASS_NAME));
              var aPy = Sk.ffi.gattr(tempPy, PROP_LHS);
              var bPy = Sk.ffi.gattr(tempPy, PROP_RHS);
              var cPy = Sk.ffi.gattr(nodePy, PROP_RHS);
              return Sk.ffi.callsim(mod[nameTwo], Sk.ffi.callsim(mod[nameOne], aPy, cPy), Sk.ffi.callsim(mod[nameOne], bPy, cPy));
            });
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(DISTRIB_R);
          }
        }
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffi.stringToPy(DISTRIB_R);
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffi.stringToPy(DISTRIB_R);
      });
    }, DISTRIB_R, []);
    mod[FACTOR_L] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy) {
        Sk.ffi.checkMethodArgs(FACTOR_L, arguments, 0, 0);
        Sk.ffi.referenceToPy({}, FACTOR_L, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var point = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case METHOD_EXECUTE: {
            return Sk.ffi.callableToPy(mod, METHOD_EVALUATE, function (methodPy, nodePy) {
              Sk.ffi.checkMethodArgs(METHOD_EVALUATE, arguments, 1, 1);
              var nameOne = Sk.ffi.remapToJs(Sk.ffi.gattr(nodePy, PROP_CLASS_NAME));
              var lhsPy = Sk.ffi.gattr(nodePy, PROP_LHS);
              var rhsPy = Sk.ffi.gattr(nodePy, PROP_RHS);
              var aPy = Sk.ffi.gattr(lhsPy, PROP_LHS);
              var bPy = Sk.ffi.gattr(lhsPy, PROP_RHS);
              var aPy = Sk.ffi.gattr(rhsPy, PROP_LHS);
              var cPy = Sk.ffi.gattr(rhsPy, PROP_RHS);
              var nameLhs = Sk.ffi.remapToJs(Sk.ffi.gattr(lhsPy, PROP_CLASS_NAME));
              var nameRhs = Sk.ffi.remapToJs(Sk.ffi.gattr(rhsPy, PROP_CLASS_NAME));
              return Sk.ffi.callsim(mod[nameLhs], aPy, Sk.ffi.callsim(mod[nameOne], bPy, cPy));
            });
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(FACTOR_L);
          }
        }
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffi.stringToPy(FACTOR_L);
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffi.stringToPy(FACTOR_L);
      });
    }, FACTOR_L, []);
    mod[FACTOR_R] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy) {
        Sk.ffi.checkMethodArgs(FACTOR_R, arguments, 0, 0);
        Sk.ffi.referenceToPy({}, FACTOR_R, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var point = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case METHOD_EXECUTE: {
            return Sk.ffi.callableToPy(mod, METHOD_EVALUATE, function (methodPy, nodePy) {
              Sk.ffi.checkMethodArgs(METHOD_EVALUATE, arguments, 1, 1);
              var nameOne = Sk.ffi.remapToJs(Sk.ffi.gattr(nodePy, PROP_CLASS_NAME));
              var lhsPy = Sk.ffi.gattr(nodePy, PROP_LHS);
              var rhsPy = Sk.ffi.gattr(nodePy, PROP_RHS);
              var aPy = Sk.ffi.gattr(lhsPy, PROP_LHS);
              var cPy = Sk.ffi.gattr(lhsPy, PROP_RHS);
              var bPy = Sk.ffi.gattr(rhsPy, PROP_LHS);
              var cPy = Sk.ffi.gattr(rhsPy, PROP_RHS);
              var nameLhs = Sk.ffi.remapToJs(Sk.ffi.gattr(lhsPy, PROP_CLASS_NAME));
              var nameRhs = Sk.ffi.remapToJs(Sk.ffi.gattr(rhsPy, PROP_CLASS_NAME));
              return Sk.ffi.callsim(mod[nameLhs], Sk.ffi.callsim(mod[nameOne], aPy, bPy), cPy);
            });
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(FACTOR_R);
          }
        }
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffi.stringToPy(FACTOR_R);
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffi.stringToPy(FACTOR_R);
      });
    }, FACTOR_R, []);
    mod[ASSOC_L] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy) {
        Sk.ffi.checkMethodArgs(ASSOC_L, arguments, 0, 0);
        Sk.ffi.referenceToPy({}, ASSOC_L, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var point = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case METHOD_EXECUTE: {
            return Sk.ffi.callableToPy(mod, METHOD_EVALUATE, function (methodPy, nodePy) {
              Sk.ffi.checkMethodArgs(METHOD_EVALUATE, arguments, 1, 1);
              var nameOne = Sk.ffi.remapToJs(Sk.ffi.gattr(nodePy, PROP_CLASS_NAME));
              var aPy = Sk.ffi.gattr(nodePy, PROP_LHS);
              var tempPy = Sk.ffi.gattr(nodePy, PROP_RHS);
              var bPy = Sk.ffi.gattr(tempPy, PROP_LHS);
              var cPy = Sk.ffi.gattr(tempPy, PROP_RHS);
              return Sk.ffi.callsim(mod[nameOne], Sk.ffi.callsim(mod[nameOne], aPy, bPy), cPy);
            });
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(ASSOC_L);
          }
        }
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffi.stringToPy(ASSOC_L);
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffi.stringToPy(ASSOC_L);
      });
    }, ASSOC_L, []);
    mod[ASSOC_R] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy) {
        Sk.ffi.checkMethodArgs(ASSOC_R, arguments, 0, 0);
        Sk.ffi.referenceToPy({}, ASSOC_R, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var point = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case METHOD_EXECUTE: {
            return Sk.ffi.callableToPy(mod, METHOD_EVALUATE, function (methodPy, nodePy) {
              Sk.ffi.checkMethodArgs(METHOD_EVALUATE, arguments, 1, 1);
              var nameOne = Sk.ffi.remapToJs(Sk.ffi.gattr(nodePy, PROP_CLASS_NAME));
              var tempPy = Sk.ffi.gattr(nodePy, PROP_LHS);
              var aPy = Sk.ffi.gattr(tempPy, PROP_LHS);
              var bPy = Sk.ffi.gattr(tempPy, PROP_RHS);
              var cPy = Sk.ffi.gattr(nodePy, PROP_RHS);
              return Sk.ffi.callsim(mod[nameOne], aPy, Sk.ffi.callsim(mod[nameOne], bPy, cPy));
            });
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(ASSOC_R);
          }
        }
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffi.stringToPy(ASSOC_R);
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffi.stringToPy(ASSOC_R);
      });
    }, ASSOC_R, []);
  };
}.call(this));
Sk.units = Sk.units || {};
(function () {
  Sk.builtin.defineUnits = function (mod, BLADE) {
    Sk.ffi.checkFunctionArgs('defineUnits', arguments, 2, 2);
    mod.yocto = Sk.ffi.numberToFloatPy(1e-24);
    mod.zepto = Sk.ffi.numberToFloatPy(1e-21);
    mod.atto = Sk.ffi.numberToFloatPy(1e-18);
    mod.femto = Sk.ffi.numberToFloatPy(1e-15);
    mod.pico = Sk.ffi.numberToFloatPy(1e-12);
    mod.nano = Sk.ffi.numberToFloatPy(1e-9);
    mod.micro = Sk.ffi.numberToFloatPy(0.000001);
    mod.milli = Sk.ffi.numberToFloatPy(0.001);
    mod.centi = Sk.ffi.numberToFloatPy(0.01);
    mod.deci = Sk.ffi.numberToFloatPy(0.1);
    mod.deka = Sk.ffi.numberToFloatPy(10);
    mod.hecto = Sk.ffi.numberToFloatPy(100);
    mod.kilo = Sk.ffi.numberToFloatPy(1000);
    mod.mega = Sk.ffi.numberToFloatPy(1000000);
    mod.giga = Sk.ffi.numberToFloatPy(1000000000);
    mod.tera = Sk.ffi.numberToFloatPy(1000000000000);
    mod.peta = Sk.ffi.numberToFloatPy(1000000000000000);
    mod.exa = Sk.ffi.numberToFloatPy(1000000000000000000);
    mod.zetta = Sk.ffi.numberToFloatPy(1e+21);
    mod.yotta = Sk.ffi.numberToFloatPy(1e+24);
    var DIMENSIONS = 'Dimensions';
    var MEASURE = 'Measure';
    var RATIONAL = 'Rational';
    var UNIT = 'Unit';
    var NUMBER = [
        Sk.ffi.PyType.FLOAT,
        Sk.ffi.PyType.INT,
        Sk.ffi.PyType.LONG
      ];
    var PROP_NAME = 'name';
    var PROP_QUANTITY = 'quantity';
    var PROP_UOM = 'uom';
    var PROP_SCALE = 'scale';
    var PROP_DIMENSIONS = 'dimensions';
    var PROP_LABELS = 'labels';
    var PROP_M = 'M';
    var PROP_L = 'L';
    var PROP_T = 'T';
    var PROP_Q = 'Q';
    var PROP_TEMPERATURE = 'temperature';
    var PROP_AMOUNT = 'amount';
    var PROP_INTENSITY = 'intensity';
    var METHOD_COMPATIBLE = 'compatible';
    var METHOD_COS = 'cos';
    var METHOD_EXP = 'exp';
    var METHOD_MAGNITUDE = 'magnitude';
    var METHOD_SIN = 'sin';
    var OP_ADD = 'add';
    var OP_SUB = 'subtract';
    var OP_MUL = 'multiply';
    var OP_DIV = 'divide';
    var OP_EQ = 'equal';
    var ARG_OTHER = 'other';
    var GRAM = 'gram';
    var KILOGRAM = 'kilogram';
    var METER = 'meter';
    var CM = 'cm';
    var SECOND = 'second';
    var COULOMB = 'coulomb';
    var KELVIN = 'kelvin';
    var MOLE = 'mole';
    var CANDELA = 'candela';
    var SI_LABELS = [
        'kg',
        'm',
        's',
        'C',
        'K',
        'mol',
        'cd'
      ];
    var NEWTON = 'newton';
    var JOULE = 'joule';
    var WATT = 'watt';
    var AMPERE = 'ampere';
    var VOLT = 'volt';
    var TESLA = 'tesla';
    var RADIAN = 'radian';
    var DEGREE = 'degree';
    var DIMLESS = 'dimensionless';
    var isMeasurePy = function (valuePy) {
      return Sk.ffi.isInstance(valuePy, MEASURE);
    };
    var isDimensionsPy = function (valuePy) {
      return Sk.ffi.isInstance(valuePy, DIMENSIONS);
    };
    var isUnitPy = function (valuePy) {
      return Sk.ffi.isInstance(valuePy, UNIT);
    };
    var isQuantityPy = function (valuePy) {
      if (Sk.ffi.isNum(valuePy)) {
        return true;
      } else if (Sk.ffi.isInstance(valuePy, 'Euclidean3')) {
        return true;
      } else if (Sk.ffi.isInstance(valuePy, 'Euclidean2')) {
        return true;
      } else if (Sk.ffi.isInstance(valuePy, 'complex')) {
        return true;
      } else if (Sk.ffi.isInstance(valuePy, 'Rational')) {
        return true;
      } else if (Sk.ffi.isInstance(valuePy, 'Fraction')) {
        return true;
      } else {
        return false;
      }
    };
    Sk.builtin.defineFractions(mod, RATIONAL, function (n, d) {
      return new BLADE.Rational(n, d);
    });
    mod[DIMENSIONS] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, M, L, T, Q, temperaturePy, amountPy, intensityPy) {
        Sk.ffi.checkMethodArgs(DIMENSIONS, arguments, 1, 7);
        Sk.ffi.checkArgType(PROP_M, RATIONAL, Sk.ffi.isInstance(M, RATIONAL) || Sk.ffi.isInstance(M, DIMENSIONS), M);
        switch (Sk.ffi.typeName(M)) {
        case RATIONAL: {
            Sk.ffi.checkMethodArgs(DIMENSIONS, arguments, 7, 7);
            Sk.ffi.checkArgType(PROP_L, RATIONAL, Sk.ffi.isInstance(L, RATIONAL), L);
            Sk.ffi.checkArgType(PROP_T, RATIONAL, Sk.ffi.isInstance(T, RATIONAL), T);
            Sk.ffi.checkArgType(PROP_Q, RATIONAL, Sk.ffi.isInstance(Q, RATIONAL), Q);
            Sk.ffi.checkArgType(PROP_TEMPERATURE, RATIONAL, Sk.ffi.isInstance(temperaturePy, RATIONAL), temperaturePy);
            Sk.ffi.checkArgType(PROP_AMOUNT, RATIONAL, Sk.ffi.isInstance(amountPy, RATIONAL), amountPy);
            Sk.ffi.checkArgType(PROP_INTENSITY, RATIONAL, Sk.ffi.isInstance(intensityPy, RATIONAL), intensityPy);
            Sk.ffi.referenceToPy(new BLADE.Dimensions(Sk.ffi.remapToJs(M), Sk.ffi.remapToJs(L), Sk.ffi.remapToJs(T), Sk.ffi.remapToJs(Q), Sk.ffi.remapToJs(temperaturePy), Sk.ffi.remapToJs(amountPy), Sk.ffi.remapToJs(intensityPy)), DIMENSIONS, undefined, selfPy);
          }
          break;
        case DIMENSIONS: {
            Sk.ffi.checkMethodArgs(DIMENSIONS, arguments, 1, 1);
            Sk.ffi.referenceToPy(Sk.ffi.remapToJs(M), DIMENSIONS, undefined, selfPy);
          }
          break;
        default: {
            throw Sk.ffi.err.argument(PROP_M).inFunction(DIMENSIONS).mustHaveType([
              RATIONAL,
              DIMENSIONS
            ]);
          }
        }
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (dimensionsPy, name) {
        var dimensions = Sk.ffi.remapToJs(dimensionsPy);
        switch (name) {
        case PROP_M: {
            return Sk.ffi.callsim(mod[RATIONAL], Sk.ffi.referenceToPy(dimensions[PROP_M], RATIONAL));
          }
        case PROP_L: {
            return Sk.ffi.callsim(mod[RATIONAL], Sk.ffi.referenceToPy(dimensions[PROP_L], RATIONAL));
          }
        case PROP_T: {
            return Sk.ffi.callsim(mod[RATIONAL], Sk.ffi.referenceToPy(dimensions[PROP_T], RATIONAL));
          }
        case PROP_Q: {
            return Sk.ffi.callsim(mod[RATIONAL], Sk.ffi.referenceToPy(dimensions[PROP_Q], RATIONAL));
          }
        case PROP_TEMPERATURE: {
            return Sk.ffi.callsim(mod[RATIONAL], Sk.ffi.referenceToPy(dimensions[PROP_TEMPERATURE], RATIONAL));
          }
        case PROP_AMOUNT: {
            return Sk.ffi.callsim(mod[RATIONAL], Sk.ffi.referenceToPy(dimensions[PROP_AMOUNT], RATIONAL));
          }
        case PROP_INTENSITY: {
            return Sk.ffi.callsim(mod[RATIONAL], Sk.ffi.referenceToPy(dimensions[PROP_INTENSITY], RATIONAL));
          }
        }
      });
      $loc.__mul__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkRhsOperandType(OP_MUL, DIMENSIONS, isDimensionsPy(otherPy), otherPy);
        var a = Sk.ffi.remapToJs(selfPy);
        var b = Sk.ffi.remapToJs(otherPy);
        var c = a.mul(b);
        return Sk.ffi.callsim(mod[DIMENSIONS], Sk.ffi.referenceToPy(c.M, RATIONAL), Sk.ffi.referenceToPy(c.L, RATIONAL), Sk.ffi.referenceToPy(c.T, RATIONAL), Sk.ffi.referenceToPy(c.Q, RATIONAL), Sk.ffi.referenceToPy(c.temperature, RATIONAL), Sk.ffi.referenceToPy(c.amount, RATIONAL), Sk.ffi.referenceToPy(c.intensity, RATIONAL));
      });
      $loc.__div__ = Sk.ffi.functionPy(function (aPy, bPy) {
        var a = Sk.ffi.remapToJs(aPy);
        var b = Sk.ffi.remapToJs(bPy);
        var c = a.div(b);
        return Sk.ffi.callsim(mod[DIMENSIONS], Sk.ffi.referenceToPy(c.M, RATIONAL), Sk.ffi.referenceToPy(c.L, RATIONAL), Sk.ffi.referenceToPy(c.T, RATIONAL), Sk.ffi.referenceToPy(c.Q, RATIONAL), Sk.ffi.referenceToPy(c.temperature, RATIONAL), Sk.ffi.referenceToPy(c.amount, RATIONAL), Sk.ffi.referenceToPy(c.intensity, RATIONAL));
      });
      $loc.__pow__ = Sk.ffi.functionPy(function (basePy, exponentPy) {
        Sk.ffi.checkFunctionArgs('**', arguments, 2, 2);
        var base = Sk.ffi.remapToJs(basePy);
        var exponent = Sk.ffi.remapToJs(exponentPy);
        var x = base.pow(exponent);
        return Sk.ffi.callsim(mod[DIMENSIONS], Sk.ffi.referenceToPy(x.M, RATIONAL), Sk.ffi.referenceToPy(x.L, RATIONAL), Sk.ffi.referenceToPy(x.T, RATIONAL), Sk.ffi.referenceToPy(x.Q, RATIONAL), Sk.ffi.referenceToPy(x.temperature, RATIONAL), Sk.ffi.referenceToPy(x.amount, RATIONAL), Sk.ffi.referenceToPy(x.intensity, RATIONAL));
      });
      $loc.__str__ = Sk.ffi.functionPy(function (dimensionsPy) {
        var dimensions = Sk.ffi.remapToJs(dimensionsPy);
        return Sk.ffi.stringToPy('' + dimensions);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (dimensionsPy) {
        var names = [
            PROP_M,
            PROP_L,
            PROP_T,
            PROP_Q,
            PROP_TEMPERATURE,
            PROP_AMOUNT,
            PROP_INTENSITY
          ];
        var attrs = names.map(function (name) {
            return Sk.ffi.gattr(dimensionsPy, name);
          });
        var reprs = attrs.map(function (attr) {
            return Sk.ffi.remapToJs(Sk.ffi.callsim(attr['__repr__'], attr));
          });
        return Sk.ffi.stringToPy(DIMENSIONS + '(' + reprs.join(' , ') + ')');
      });
    }, DIMENSIONS, []);
    mod[UNIT] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, scalePy, dimensionsPy, labelsPy, namePy) {
        Sk.ffi.checkMethodArgs(UNIT, arguments, 1, 4);
        var custom = {};
        custom[PROP_NAME] = Sk.ffi.remapToJs(namePy);
        switch (Sk.ffi.getType(scalePy)) {
        case Sk.ffi.PyType.FLOAT:
        case Sk.ffi.PyType.INT:
        case Sk.ffi.PyType.LONG: {
            Sk.ffi.checkMethodArgs(UNIT, arguments, 3, 4);
            var scale = Sk.ffi.remapToJs(scalePy);
            var dimensions = Sk.ffi.remapToJs(dimensionsPy);
            var labels = Sk.ffi.remapToJs(labelsPy);
            Sk.ffi.referenceToPy(new BLADE.Unit(scale, dimensions, labels), UNIT, custom, selfPy);
          }
          break;
        case Sk.ffi.PyType.INSTANCE: {
            Sk.ffi.checkMethodArgs(UNIT, arguments, 1, 1);
            Sk.ffi.referenceToPy(Sk.ffi.remapToJs(scalePy), UNIT, custom, selfPy);
          }
          break;
        default: {
            throw new Error(UNIT + ' (__init__) ' + Sk.ffi.getType(scalePy));
          }
        }
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (unitPy, name) {
        var unitJs = Sk.ffi.remapToJs(unitPy);
        switch (name) {
        case PROP_SCALE: {
            return Sk.ffi.numberToFloatPy(unitJs[PROP_SCALE]);
          }
        case PROP_DIMENSIONS: {
            return Sk.ffi.callsim(mod[DIMENSIONS], Sk.ffi.referenceToPy(unitJs[PROP_DIMENSIONS], DIMENSIONS));
          }
        case PROP_LABELS: {
            return Sk.ffi.remapToPy(unitJs[PROP_LABELS]);
          }
        case PROP_NAME: {
            if (unitPy.custom[PROP_NAME]) {
              return Sk.ffi.stringToPy(unitPy.custom[PROP_NAME]);
            } else {
              return Sk.ffi.none.None;
            }
          }
        case METHOD_COMPATIBLE: {
            return Sk.ffi.callableToPy(mod, METHOD_COMPATIBLE, function (methodPy, otherPy) {
              Sk.ffi.checkMethodArgs(METHOD_COMPATIBLE, arguments, 1, 1);
              Sk.ffi.checkArgType('other', UNIT, isUnitPy(otherPy), otherPy);
              var other = Sk.ffi.remapToJs(otherPy);
              try {
                unitJs.compatible(other);
              } catch (e) {
                throw Sk.ffi.assertionError(e.message);
              }
              return unitPy;
            });
          }
        case METHOD_COS: {
            return Sk.ffi.callableToPy(mod, METHOD_COS, function (methodPy) {
              Sk.ffi.checkMethodArgs(METHOD_COS, arguments, 0, 0);
              var angle = unitJs.scale;
              var dimensions = unitJs.dimensions;
              var labels = unitJs.labels;
              var cosAngle = new BLADE[UNIT](Sk.math.cos(angle), dimensions, labels);
              return Sk.ffi.callsim(mod[UNIT], Sk.ffi.referenceToPy(cosAngle, UNIT));
            });
          }
        case METHOD_SIN: {
            return Sk.ffi.callableToPy(mod, METHOD_SIN, function (methodPy) {
              Sk.ffi.checkMethodArgs(METHOD_SIN, arguments, 0, 0);
              var angle = unitJs.scale;
              var dimensions = unitJs.dimensions;
              var labels = unitJs.labels;
              var cosAngle = new BLADE[UNIT](Sk.math.sin(angle), dimensions, labels);
              return Sk.ffi.callsim(mod[UNIT], Sk.ffi.referenceToPy(cosAngle, UNIT));
            });
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(UNIT);
          }
        }
      });
      $loc.__add__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var lhs = Sk.ffi.remapToJs(selfPy);
        var rhs = Sk.ffi.remapToJs(otherPy);
        try {
          var c = lhs.add(rhs);
          return Sk.ffi.callsim(mod[UNIT], Sk.ffi.numberToFloatPy(c.scale), Sk.ffi.referenceToPy(c.dimensions, DIMENSIONS), Sk.ffi.remapToPy(c.labels));
        } catch (e) {
          throw Sk.ffi.assertionError(e.message);
        }
      });
      $loc.__sub__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var lhs = Sk.ffi.remapToJs(selfPy);
        var rhs = Sk.ffi.remapToJs(otherPy);
        try {
          var c = lhs.sub(rhs);
          return Sk.ffi.callsim(mod[UNIT], Sk.ffi.numberToFloatPy(c.scale), Sk.ffi.referenceToPy(c.dimensions, DIMENSIONS), Sk.ffi.remapToPy(c.labels));
        } catch (e) {
          throw Sk.ffi.assertionError(e.message);
        }
      });
      $loc.__mod__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var selfJs = Sk.ffi.remapToJs(selfPy);
        if (isMeasurePy(otherPy)) {
          var quantityPy = Sk.ffi.gattr(otherPy, PROP_QUANTITY);
          var uomPy = Sk.ffi.gattr(otherPy, PROP_UOM);
          return Sk.ffi.callsim(mod[MEASURE], quantityPy, Sk.ffh.multiply(selfPy, uomPy));
        } else if (Sk.ffi.isNum(otherPy) || isUnitPy(otherPy)) {
          return Sk.ffi.callsim(mod[UNIT], Sk.ffi.referenceToPy(selfJs.mul(Sk.ffi.remapToJs(otherPy)), UNIT));
        } else {
          return Sk.ffi.callsim(mod[MEASURE], otherPy, selfPy);
        }
      });
      $loc.__rmod__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        return Sk.ffi.callsim(mod[MEASURE], otherPy, selfPy);
      });
      $loc.__mul__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var selfJs = Sk.ffi.remapToJs(selfPy);
        if (isMeasurePy(otherPy)) {
          var quantityPy = Sk.ffi.gattr(otherPy, PROP_QUANTITY);
          var uomPy = Sk.ffi.gattr(otherPy, PROP_UOM);
          return Sk.ffi.callsim(mod[MEASURE], quantityPy, Sk.ffh.multiply(selfPy, uomPy));
        } else if (Sk.ffi.isNum(otherPy) || isUnitPy(otherPy)) {
          return Sk.ffi.callsim(mod[UNIT], Sk.ffi.referenceToPy(selfJs.mul(Sk.ffi.remapToJs(otherPy)), UNIT));
        } else {
          return Sk.ffi.callsim(mod[MEASURE], otherPy, selfPy);
        }
      });
      $loc.__rmul__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkLhsOperandType(OP_MUL, NUMBER, Sk.ffi.isNum(otherPy), otherPy);
        var lhs = Sk.ffi.remapToJs(otherPy);
        var rhs = Sk.ffi.remapToJs(selfPy);
        return Sk.ffi.callsim(mod[UNIT], Sk.ffi.numberToFloatPy(lhs * rhs.scale), Sk.ffi.referenceToPy(rhs.dimensions, DIMENSIONS), Sk.ffi.remapToPy(rhs.labels));
      });
      $loc.__div__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var selfJs = Sk.ffi.remapToJs(selfPy);
        if (isMeasurePy(otherPy)) {
          var quantityPy = Sk.ffi.gattr(otherPy, PROP_QUANTITY);
          var uomPy = Sk.ffi.gattr(otherPy, PROP_UOM);
          return Sk.ffi.callsim(mod[MEASURE], Sk.ffh.divide(Sk.ffi.numberToFloatPy(1), quantityPy), Sk.ffh.divide(selfPy, uomPy));
        } else if (Sk.ffi.isNum(otherPy) || isUnitPy(otherPy)) {
          return Sk.ffi.callsim(mod[UNIT], Sk.ffi.referenceToPy(selfJs.div(Sk.ffi.remapToJs(otherPy)), UNIT));
        } else {
          return Sk.ffi.callsim(mod[MEASURE], otherPy, selfPy);
        }
      });
      $loc.__rdiv__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkLhsOperandType(OP_MUL, NUMBER, Sk.ffi.isNum(otherPy), otherPy);
        var other = Sk.ffi.remapToJs(otherPy);
        var rhs = Sk.ffi.remapToJs(selfPy);
        var scale = other / rhs.scale;
        var M = new BLADE[RATIONAL](-rhs.dimensions.M.numer, rhs.dimensions.M.denom);
        var L = new BLADE[RATIONAL](-rhs.dimensions.L.numer, rhs.dimensions.L.denom);
        var T = new BLADE[RATIONAL](-rhs.dimensions.T.numer, rhs.dimensions.T.denom);
        var Q = new BLADE[RATIONAL](-rhs.dimensions.Q.numer, rhs.dimensions.Q.denom);
        var temperature = new BLADE[RATIONAL](-rhs.dimensions.temperature.numer, rhs.dimensions.temperature.denom);
        var amount = new BLADE[RATIONAL](-rhs.dimensions.amount.numer, rhs.dimensions.amount.denom);
        var intensity = new BLADE[RATIONAL](-rhs.dimensions.intensity.numer, rhs.dimensions.intensity.denom);
        var dimensions = new BLADE[DIMENSIONS](M, L, T, Q, temperature, amount, intensity);
        var labels = rhs.labels;
        return Sk.ffi.callsim(mod[UNIT], Sk.ffi.numberToFloatPy(scale), Sk.ffi.referenceToPy(dimensions, DIMENSIONS), Sk.ffi.remapToPy(labels));
      });
      $loc.__pow__ = Sk.ffi.functionPy(function (lhsPy, rhsPy) {
        var lhs = Sk.ffi.remapToJs(lhsPy);
        var rhs = Sk.ffi.remapToJs(rhsPy);
        var c = lhs.pow(rhs);
        return Sk.ffi.callsim(mod[UNIT], Sk.ffi.numberToFloatPy(c.scale), Sk.ffi.referenceToPy(c.dimensions, DIMENSIONS), Sk.ffi.remapToPy(c.labels));
      });
      $loc.__abs__ = Sk.ffi.functionPy(function (unitPy) {
        var unitJs = Sk.ffi.remapToJs(unitPy);
        return Sk.ffi.callsim(mod[UNIT], Sk.ffi.numberToFloatPy(Math.abs(unitJs.scale)), Sk.ffi.referenceToPy(unitJs.dimensions, DIMENSIONS), Sk.ffi.remapToPy(unitJs.labels));
      });
      $loc.__magnitude__ = Sk.ffi.functionPy(function (unitPy) {
        var unitJs = Sk.ffi.remapToJs(unitPy);
        return Sk.ffi.callsim(mod[UNIT], Sk.ffi.numberToFloatPy(Math.abs(unitJs.scale)), Sk.ffi.referenceToPy(unitJs.dimensions, DIMENSIONS), Sk.ffi.remapToPy(unitJs.labels));
      });
      $loc.__quadrance__ = Sk.ffi.functionPy(function (unitPy) {
        var unitJs = Sk.ffi.remapToJs(unitPy);
        return Sk.ffi.callsim(mod[UNIT], Sk.ffi.referenceToPy(unitJs.pow(2), UNIT));
      });
      $loc.__sqrt__ = Sk.ffi.functionPy(function (unitPy) {
        var unitJs = Sk.ffi.remapToJs(unitPy);
        return Sk.ffi.callsim(mod[UNIT], Sk.ffi.referenceToPy(unitJs.pow(0.5), UNIT));
      });
      $loc.__str__ = Sk.ffi.functionPy(function (unitPy) {
        var unitJs = Sk.ffi.remapToJs(unitPy);
        var custom = Sk.ffi.customToJs(unitPy);
        if (custom.name) {
          return Sk.ffi.stringToPy(custom.name);
        } else {
          var patterns = [
              [
                -1,
                1,
                -3,
                1,
                2,
                1,
                2,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                'F/m'
              ],
              [
                -1,
                1,
                -2,
                1,
                1,
                1,
                2,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                'S'
              ],
              [
                -1,
                1,
                -2,
                1,
                2,
                1,
                2,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                'F'
              ],
              [
                -1,
                1,
                3,
                1,
                -2,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                'N\xb7m ** 2/kg ** 2'
              ],
              [
                0,
                1,
                0,
                1,
                -1,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                'Hz'
              ],
              [
                0,
                1,
                0,
                1,
                -1,
                1,
                1,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                'A'
              ],
              [
                0,
                1,
                1,
                1,
                -2,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                'm/s ** 2'
              ],
              [
                0,
                1,
                1,
                1,
                -1,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                'm/s'
              ],
              [
                1,
                1,
                1,
                1,
                -1,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                'kg\xb7m/s'
              ],
              [
                1,
                1,
                -1,
                1,
                -2,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                'Pa'
              ],
              [
                1,
                1,
                -1,
                1,
                -1,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                'Pa\xb7s'
              ],
              [
                1,
                1,
                0,
                1,
                -3,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                'W/m ** 2'
              ],
              [
                1,
                1,
                0,
                1,
                -2,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                'N/m'
              ],
              [
                1,
                1,
                0,
                1,
                -1,
                1,
                -1,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                'T'
              ],
              [
                1,
                1,
                1,
                1,
                -3,
                1,
                0,
                1,
                -1,
                1,
                0,
                1,
                0,
                1,
                'W/(m\xb7K)'
              ],
              [
                1,
                1,
                1,
                1,
                -2,
                1,
                -1,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                'V/m'
              ],
              [
                1,
                1,
                1,
                1,
                -2,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                'N'
              ],
              [
                1,
                1,
                1,
                1,
                0,
                1,
                -2,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                'H/m'
              ],
              [
                1,
                1,
                2,
                1,
                -2,
                1,
                0,
                1,
                -1,
                1,
                0,
                1,
                0,
                1,
                'J/K'
              ],
              [
                0,
                1,
                2,
                1,
                -2,
                1,
                0,
                1,
                -1,
                1,
                0,
                1,
                0,
                1,
                'J/(kg\xb7K)'
              ],
              [
                1,
                1,
                2,
                1,
                -2,
                1,
                0,
                1,
                -1,
                1,
                -1,
                1,
                0,
                1,
                'J/(mol\xb7K)'
              ],
              [
                1,
                1,
                2,
                1,
                -2,
                1,
                0,
                1,
                0,
                1,
                -1,
                1,
                0,
                1,
                'J/mol'
              ],
              [
                1,
                1,
                2,
                1,
                -2,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                'J'
              ],
              [
                1,
                1,
                2,
                1,
                -1,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                'J\xb7s'
              ],
              [
                1,
                1,
                2,
                1,
                -3,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                'W'
              ],
              [
                1,
                1,
                2,
                1,
                -2,
                1,
                -1,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                'V'
              ],
              [
                1,
                1,
                2,
                1,
                -1,
                1,
                -2,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                '\u03a9'
              ],
              [
                1,
                1,
                2,
                1,
                0,
                1,
                -2,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                'H'
              ],
              [
                1,
                1,
                2,
                1,
                -1,
                1,
                -1,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                'Wb'
              ]
            ];
          var M = unitJs.dimensions.M;
          var L = unitJs.dimensions.L;
          var T = unitJs.dimensions.T;
          var Q = unitJs.dimensions.Q;
          var temperature = unitJs.dimensions.temperature;
          var amount = unitJs.dimensions.amount;
          var intensity = unitJs.dimensions.intensity;
          for (var i = 0, len = patterns.length; i < len; i++) {
            var pattern = patterns[i];
            if (M.numer === pattern[0] && M.denom === pattern[1] && L.numer === pattern[2] && L.denom === pattern[3] && T.numer === pattern[4] && T.denom === pattern[5] && Q.numer === pattern[6] && Q.denom === pattern[7] && temperature.numer === pattern[8] && temperature.denom === pattern[9] && amount.numer === pattern[10] && amount.denom === pattern[11] && intensity.numer === pattern[12] && intensity.denom === pattern[13]) {
              if (unitJs.scale !== 1) {
                return Sk.ffi.stringToPy(unitJs.scale + ' * ' + pattern[14]);
              } else {
                return Sk.ffi.stringToPy(pattern[14]);
              }
            }
          }
          return Sk.ffi.stringToPy('' + unitJs);
        }
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (unitPy) {
        var props = [{
              'name': PROP_DIMENSIONS,
              'kind': '__repr__'
            }];
        var attrs = props.map(function (prop) {
            return {
              'value': Sk.ffi.gattr(unitPy, prop.name),
              'prop': prop
            };
          });
        var reprs = attrs.map(function (attr) {
            return Sk.ffi.remapToJs(Sk.ffi.callsim(attr.value[attr.prop.kind], attr.value));
          });
        var unitJs = Sk.ffi.remapToJs(unitPy);
        var scale = '' + unitJs.scale;
        var dimensions = reprs[0];
        var labels = '[' + unitJs.labels.map(function (label) {
            return '\'' + label + '\'';
          }).join(' , ') + ']';
        return Sk.ffi.stringToPy(UNIT + '(' + [
          scale,
          dimensions,
          labels
        ].join(' , ') + ')');
      });
    }, UNIT, []);
    mod[MEASURE] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      var QTY_PY = 'qtyPy';
      var UOM_PY = 'uomPy';
      var getQuantityPy = function (measurePy) {
        return Sk.ffi.gattr(measurePy, PROP_QUANTITY);
      };
      var getUomPy = function (measurePy) {
        return Sk.ffi.gattr(measurePy, PROP_UOM);
      };
      var makeMeasureLhsBinary = function (op) {
        return function (selfPy, otherPy) {
          var self = Sk.ffi.remapToJs(selfPy);
          if (isMeasurePy(otherPy)) {
            var other = Sk.ffi.remapToJs(otherPy);
            return Sk.ffi.callsim(mod[MEASURE], op(self[QTY_PY], other[QTY_PY]), Sk.ffh.multiply(self[UOM_PY], other[UOM_PY]));
          } else if (isQuantityPy(otherPy)) {
            var quantityPy = op(self[QTY_PY], otherPy);
            if (typeof quantityPy !== 'undefined') {
              return Sk.ffi.callsim(mod[MEASURE], quantityPy, self[UOM_PY]);
            } else {
              return undefined;
            }
          } else {
            return undefined;
          }
        };
      };
      var makeMeasureRhsBinary = function (op) {
        return function (selfPy, otherPy) {
          if (isQuantityPy(otherPy)) {
            var quantityPy = op(otherPy, getQuantityPy(selfPy));
            if (typeof quantityPy !== 'undefined') {
              return Sk.ffi.callsim(mod[MEASURE], quantityPy, getUomPy(selfPy));
            } else {
              return undefined;
            }
          } else {
            return undefined;
          }
        };
      };
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, qtyPy, uomPy) {
        Sk.ffi.checkMethodArgs(MEASURE, arguments, 1, 2);
        if (Sk.ffi.typeName(qtyPy) === MEASURE) {
          Sk.ffi.referenceToPy(Sk.ffi.remapToJs(qtyPy), MEASURE, qtyPy.custom, selfPy);
        } else {
          var scalePy = Sk.ffi.gattr(uomPy, PROP_SCALE);
          if (Sk.ffi.remapToJs(scalePy) === 1) {
            var measure = {};
            measure[QTY_PY] = qtyPy;
            measure[UOM_PY] = uomPy;
            Sk.ffi.referenceToPy(measure, MEASURE, undefined, selfPy);
          } else {
            var measure = {};
            measure[QTY_PY] = Sk.ffh.multiply(qtyPy, scalePy);
            measure[UOM_PY] = Sk.ffi.callsim(mod[UNIT], Sk.ffi.numberToFloatPy(1), Sk.ffi.gattr(uomPy, PROP_DIMENSIONS), Sk.ffi.gattr(uomPy, PROP_LABELS), Sk.ffi.gattr(uomPy, PROP_NAME));
            Sk.ffi.referenceToPy(measure, MEASURE, undefined, selfPy);
          }
        }
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (measurePy, name) {
        var measure = Sk.ffi.remapToJs(measurePy);
        switch (name) {
        case PROP_QUANTITY: {
            return measure[QTY_PY];
          }
        case PROP_UOM: {
            return measure[UOM_PY];
          }
        case METHOD_EXP: {
            return Sk.ffi.callableToPy(mod, METHOD_EXP, function (methodPy) {
              Sk.ffi.checkMethodArgs(METHOD_EXP, arguments, 0, 0);
              return Sk.ffi.callsim(mod[MEASURE], Sk.ffi.callsim(Sk.ffi.gattr(measure[QTY_PY], METHOD_EXP)), measure[UOM_PY]);
            });
          }
        case METHOD_MAGNITUDE: {
            return Sk.ffi.callableToPy(mod, METHOD_MAGNITUDE, function (methodPy) {
              Sk.ffi.checkMethodArgs(METHOD_MAGNITUDE, arguments, 0, 0);
              return Sk.ffi.callsim(mod[MEASURE], Sk.ffi.callsim(Sk.ffi.gattr(measure[QTY_PY], METHOD_MAGNITUDE)), measure[UOM_PY]);
            });
          }
        }
      });
      $loc.__add__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkArgType(ARG_OTHER, MEASURE, isMeasurePy(otherPy), otherPy);
        var self = Sk.ffi.remapToJs(selfPy);
        var other = Sk.ffi.remapToJs(otherPy);
        var quantityPy = Sk.ffh.add(self[QTY_PY], other[QTY_PY]);
        var uomPy = Sk.ffi.callsim(Sk.ffi.gattr(self[UOM_PY], METHOD_COMPATIBLE), other[UOM_PY]);
        return Sk.ffi.callsim(mod[MEASURE], quantityPy, uomPy);
      });
      $loc.__sub__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkArgType(ARG_OTHER, MEASURE, isMeasurePy(otherPy), otherPy);
        var self = Sk.ffi.remapToJs(selfPy);
        var other = Sk.ffi.remapToJs(otherPy);
        return Sk.ffi.callsim(mod[MEASURE], Sk.ffh.subtract(self[QTY_PY], other[QTY_PY]), Sk.ffi.callsim(Sk.ffi.gattr(self[UOM_PY], METHOD_COMPATIBLE), other[UOM_PY]));
      });
      $loc.__mod__ = Sk.ffi.functionPy(makeMeasureLhsBinary(Sk.ffh.mod));
      $loc.__rmod__ = Sk.ffi.functionPy(makeMeasureRhsBinary(Sk.ffh.mod));
      $loc.__mul__ = Sk.ffi.functionPy(makeMeasureLhsBinary(Sk.ffh.multiply));
      $loc.__rmul__ = Sk.ffi.functionPy(makeMeasureRhsBinary(Sk.ffh.multiply));
      $loc.__div__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        if (isMeasurePy(otherPy)) {
          var other = Sk.ffi.remapToJs(otherPy);
          return Sk.ffi.callsim(mod[MEASURE], Sk.ffh.divide(self[QTY_PY], other[QTY_PY]), Sk.ffh.divide(self[UOM_PY], other[UOM_PY]));
        } else if (Sk.ffi.isNum(otherPy)) {
          return Sk.ffi.callsim(mod[MEASURE], Sk.ffh.divide(self[QTY_PY], otherPy), self[UOM_PY]);
        } else if (isUnitPy(otherPy)) {
          return Sk.ffi.callsim(mod[MEASURE], self[QTY_PY], Sk.ffh.divide(self[UOM_PY], otherPy));
        } else {
          Sk.ffi.checkArgType(ARG_OTHER, [
            MEASURE,
            NUMBER,
            UNIT
          ], false, otherPy);
        }
      });
      $loc.__rdiv__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        return Sk.ffi.callsim(mod[MEASURE], Sk.ffh.divide(otherPy, self[QTY_PY]), Sk.ffh.divide(Sk.ffi.numberToFloatPy(1), self[UOM_PY]));
      });
      $loc.__xor__ = Sk.ffi.functionPy(makeMeasureLhsBinary(Sk.ffh.xor));
      $loc.__rxor__ = Sk.ffi.functionPy(makeMeasureRhsBinary(Sk.ffh.xor));
      $loc.__lshift__ = Sk.ffi.functionPy(makeMeasureLhsBinary(Sk.ffh.lshift));
      $loc.__rlshift__ = Sk.ffi.functionPy(makeMeasureRhsBinary(Sk.ffh.lshift));
      $loc.__rshift__ = Sk.ffi.functionPy(makeMeasureLhsBinary(Sk.ffh.rshift));
      $loc.__rrshift__ = Sk.ffi.functionPy(makeMeasureRhsBinary(Sk.ffh.rshift));
      $loc.__pow__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var isMeasure = isMeasurePy(otherPy);
        Sk.ffi.checkArgType(ARG_OTHER, [
          MEASURE,
          NUMBER
        ], Sk.ffi.isNum(otherPy) || isMeasure, otherPy);
        var self = Sk.ffi.remapToJs(selfPy);
        var other = Sk.ffi.remapToJs(otherPy);
        var quantityPy = Sk.ffh.pow(self[QTY_PY], isMeasure ? other[QTY_PY] : otherPy);
        var uomPy = Sk.ffh.pow(self[UOM_PY], isMeasure ? other[UOM_PY] : otherPy);
        return Sk.ffi.callsim(mod[MEASURE], quantityPy, uomPy);
      });
      $loc.__pos__ = Sk.ffi.functionPy(function (selfPy) {
        var quantityPy = Sk.ffh.positive(Sk.ffi.gattr(selfPy, PROP_QUANTITY));
        var uomPy = Sk.ffi.gattr(selfPy, PROP_UOM);
        return Sk.ffi.callsim(mod[MEASURE], quantityPy, uomPy);
      });
      $loc.__neg__ = Sk.ffi.functionPy(function (selfPy) {
        var quantityPy = Sk.ffh.negative(Sk.ffi.gattr(selfPy, PROP_QUANTITY));
        var uomPy = Sk.ffi.gattr(selfPy, PROP_UOM);
        return Sk.ffi.callsim(mod[MEASURE], quantityPy, uomPy);
      });
      $loc.__invert__ = Sk.ffi.functionPy(function (selfPy) {
        var quantityPy = Sk.ffh.invert(Sk.ffi.gattr(selfPy, PROP_QUANTITY));
        var uomPy = Sk.ffi.gattr(selfPy, PROP_UOM);
        return Sk.ffi.callsim(mod[MEASURE], quantityPy, uomPy);
      });
      $loc.__cos__ = Sk.ffi.functionPy(function (selfPy) {
        var quantityPy;
        var uomPy = Sk.ffi.gattr(selfPy, PROP_UOM);
        var uomJs = Sk.ffi.remapToJs(uomPy);
        var custom = Sk.ffi.customToJs(uomPy);
        Sk.ffi.checkArgType(PROP_UOM, 'dimensionless', uomJs.dimensions.dimensionless(), uomPy);
        switch (custom.name) {
        case RADIAN: {
            quantityPy = Sk.ffh.cos(Sk.ffi.gattr(selfPy, PROP_QUANTITY));
          }
          break;
        case DEGREE: {
            quantityPy = Sk.ffi.gattr(selfPy, PROP_QUANTITY);
            quantityPy = Sk.ffh.multiply(quantityPy, Sk.ffi.numberToFloatPy(Math.PI / 180));
            quantityPy = Sk.ffh.cos(quantityPy);
          }
          break;
        default: {
            quantityPy = Sk.ffh.cos(Sk.ffi.gattr(selfPy, PROP_QUANTITY));
          }
        }
        return Sk.ffi.callsim(mod[MEASURE], quantityPy, Sk.ffi.gattr(mod[DIMLESS], PROP_UOM));
      });
      $loc.__sin__ = Sk.ffi.functionPy(function (selfPy) {
        var quantityPy;
        var uomPy = Sk.ffi.gattr(selfPy, PROP_UOM);
        var uomJs = Sk.ffi.remapToJs(uomPy);
        var custom = Sk.ffi.customToJs(uomPy);
        Sk.ffi.checkArgType(PROP_UOM, 'dimensionless', uomJs.dimensions.dimensionless(), uomPy);
        switch (custom.name) {
        case RADIAN: {
            quantityPy = Sk.ffh.sin(Sk.ffi.gattr(selfPy, PROP_QUANTITY));
          }
          break;
        case DEGREE: {
            quantityPy = Sk.ffi.gattr(selfPy, PROP_QUANTITY);
            quantityPy = Sk.ffh.multiply(quantityPy, Sk.ffi.numberToFloatPy(Math.PI / 180));
            quantityPy = Sk.ffh.sin(quantityPy);
          }
          break;
        default: {
            quantityPy = Sk.ffh.sin(Sk.ffi.gattr(selfPy, PROP_QUANTITY));
          }
        }
        return Sk.ffi.callsim(mod[MEASURE], quantityPy, Sk.ffi.gattr(mod[DIMLESS], PROP_UOM));
      });
      $loc.__tan__ = Sk.ffi.functionPy(function (selfPy) {
        var quantityPy;
        var uomPy = Sk.ffi.gattr(selfPy, PROP_UOM);
        var uomJs = Sk.ffi.remapToJs(uomPy);
        var custom = Sk.ffi.customToJs(uomPy);
        Sk.ffi.checkArgType(PROP_UOM, 'dimensionless', uomJs.dimensions.dimensionless(), uomPy);
        switch (custom.name) {
        case RADIAN: {
            quantityPy = Sk.ffh.tan(Sk.ffi.gattr(selfPy, PROP_QUANTITY));
          }
          break;
        case DEGREE: {
            quantityPy = Sk.ffi.gattr(selfPy, PROP_QUANTITY);
            quantityPy = Sk.ffh.multiply(quantityPy, Sk.ffi.numberToFloatPy(Math.PI / 180));
            quantityPy = Sk.ffh.tan(quantityPy);
          }
          break;
        default: {
            quantityPy = Sk.ffh.tan(Sk.ffi.gattr(selfPy, PROP_QUANTITY));
          }
        }
        return Sk.ffi.callsim(mod[MEASURE], quantityPy, Sk.ffi.gattr(mod[DIMLESS], PROP_UOM));
      });
      $loc.__exp__ = Sk.ffi.functionPy(function (selfPy) {
        var quantityPy = Sk.ffh.exp(Sk.ffi.gattr(selfPy, PROP_QUANTITY));
        var uomPy = Sk.ffi.gattr(selfPy, PROP_UOM);
        return Sk.ffi.callsim(mod[MEASURE], quantityPy, uomPy);
      });
      $loc.__abs__ = Sk.ffi.functionPy(function (selfPy) {
        var quantityPy = Sk.ffh.abs(Sk.ffi.gattr(selfPy, PROP_QUANTITY));
        var uomPy = Sk.ffh.abs(Sk.ffi.gattr(selfPy, PROP_UOM));
        return Sk.ffi.callsim(mod[MEASURE], quantityPy, uomPy);
      });
      $loc.__magnitude__ = Sk.ffi.functionPy(function (selfPy) {
        var quantityPy = Sk.ffh.magnitude(Sk.ffi.gattr(selfPy, PROP_QUANTITY));
        var uomPy = Sk.ffh.magnitude(Sk.ffi.gattr(selfPy, PROP_UOM));
        return Sk.ffi.callsim(mod[MEASURE], quantityPy, uomPy);
      });
      $loc.__quadrance__ = Sk.ffi.functionPy(function (selfPy) {
        var quantityPy = Sk.ffh.quadrance(Sk.ffi.gattr(selfPy, PROP_QUANTITY));
        var uomPy = Sk.ffh.quadrance(Sk.ffi.gattr(selfPy, PROP_UOM));
        return Sk.ffi.callsim(mod[MEASURE], quantityPy, uomPy);
      });
      $loc.__sqrt__ = Sk.ffi.functionPy(function (selfPy) {
        var quantityPy = Sk.ffh.sqrt(Sk.ffi.gattr(selfPy, PROP_QUANTITY));
        var uomPy = Sk.ffh.sqrt(Sk.ffi.gattr(selfPy, PROP_UOM));
        return Sk.ffi.callsim(mod[MEASURE], quantityPy, uomPy);
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var qtyStr = Sk.ffi.remapToJs(Sk.ffh.str(self[QTY_PY]));
        var uomStr = Sk.ffi.remapToJs(Sk.ffh.str(self[UOM_PY]));
        return Sk.ffi.stringToPy(('' + qtyStr + ' ' + uomStr).trim());
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var qtyRepr = Sk.ffi.remapToJs(Sk.ffh.repr(self[QTY_PY]));
        var uomRepr = Sk.ffi.remapToJs(Sk.ffh.repr(self[UOM_PY]));
        return Sk.ffi.stringToPy(MEASURE + '(' + qtyRepr + ', ' + uomRepr + ')');
      });
    }, MEASURE, []);
    (function () {
      var onePy = Sk.ffi.numberToFloatPy(1);
      function makeUnitPy(unitJs) {
        var unitPy = Sk.ffi.callsim(mod[UNIT], Sk.ffi.referenceToPy(unitJs, UNIT));
        return Sk.ffi.callsim(mod[MEASURE], onePy, unitPy);
      }
      mod[DIMLESS] = makeUnitPy(new BLADE.Unit(1, new BLADE.Dimensions(0, 0, 0, 0, 0, 0, 0), SI_LABELS));
      mod[KILOGRAM] = makeUnitPy(BLADE.UNIT_KILOGRAM);
      mod[METER] = makeUnitPy(BLADE.UNIT_METER);
      mod[SECOND] = makeUnitPy(BLADE.UNIT_SECOND);
      mod[AMPERE] = makeUnitPy(BLADE.UNIT_AMPERE);
      mod[KELVIN] = makeUnitPy(BLADE.UNIT_KELVIN);
      mod[MOLE] = makeUnitPy(BLADE.UNIT_MOLE);
      mod[CANDELA] = makeUnitPy(BLADE.UNIT_CANDELA);
      mod[COULOMB] = makeUnitPy(BLADE.UNIT_COULOMB);
      mod[GRAM] = Sk.ffh.multiply(mod.milli, mod[KILOGRAM]);
      mod[CM] = Sk.ffh.multiply(mod.centi, mod[METER]);
      mod[NEWTON] = Sk.ffh.divide(Sk.ffh.multiply(mod[KILOGRAM], mod[METER]), Sk.ffh.multiply(mod[SECOND], mod[SECOND]));
      mod[JOULE] = Sk.ffh.multiply(mod[NEWTON], mod[METER]);
      mod[WATT] = Sk.ffh.divide(mod[JOULE], mod[SECOND]);
      mod[VOLT] = Sk.ffh.divide(mod[JOULE], mod[COULOMB]);
      mod[TESLA] = makeUnitPy(new BLADE.Unit(1, new BLADE.Dimensions(1, 0, -1, -1, 0, 0, 0), SI_LABELS));
      var radianPy = Sk.ffi.callsim(mod[UNIT], onePy, Sk.ffi.referenceToPy(new BLADE.Dimensions(0, 0, 0, 0, 0, 0, 0), DIMENSIONS), Sk.ffi.remapToPy(SI_LABELS), Sk.ffi.stringToPy('radian'));
      mod[RADIAN] = makeUnitPy(Sk.ffi.remapToJs(radianPy));
      var degreePy = Sk.ffi.callsim(mod[UNIT], onePy, Sk.ffi.referenceToPy(new BLADE.Dimensions(0, 0, 0, 0, 0, 0, 0), DIMENSIONS), Sk.ffi.remapToPy(SI_LABELS), Sk.ffi.stringToPy('degree'));
      mod[DEGREE] = makeUnitPy(Sk.ffi.remapToJs(degreePy));
    }());
  };
}.call(this));
Sk.three = Sk.three || {};
Sk.three.FACE_3 = 'Face3';
Sk.three.MATERIAL = 'Material';
Sk.three.MATRIX_3 = 'Matrix3';
Sk.three.MATRIX_4 = 'Matrix4';
Sk.three.MESH = 'Mesh';
Sk.three.OBJECT_3D = 'Object3D';
Sk.three.PARTICLE_SYSTEM = 'ParticleSystem';
Sk.three.PARTICLE_SYSTEM_MATERIAL = 'ParticleSystemMaterial';
Sk.three.ARROW_GEOMETRY = 'ArrowGeometry';
Sk.three.VORTEX_GEOMETRY = 'VortexGeometry';
Sk.three.cardinal = function (x, y, z) {
  function signum(x) {
    return typeof x === 'number' ? x ? x < 0 ? -1 : 1 : isNaN(x) ? NaN : 0 : NaN;
  }
  var ax = Math.abs(x);
  var ay = Math.abs(y);
  var az = Math.abs(z);
  if (ax >= ay) {
    if (ax >= az) {
      return new THREE.Vector3(signum(x), 0, 0);
    } else {
      return new THREE.Vector3(0, 0, signum(z));
    }
  } else {
    if (ay >= az) {
      return new THREE.Vector3(0, signum(y), 0);
    } else {
      return new THREE.Vector3(0, 0, signum(z));
    }
  }
};
goog.exportSymbol('Sk.three.cardinal', Sk.three.cardinal);
Sk.three.vector3Cycle = function (x, y, z, cycle) {
  switch (cycle % 3) {
  case 0: {
      return new THREE.Vector3(x, y, z);
    }
  case 1: {
      return new THREE.Vector3(z, x, y);
    }
  case 2: {
      return new THREE.Vector3(y, z, x);
    }
  }
};
goog.exportSymbol('Sk.three.vector3Cycle', Sk.three.vector3Cycle);
(function () {
  Sk.stdlib.defineThree = function (mod, BLADE) {
    Sk.ffi.checkFunctionArgs('defineThree', arguments, 2, 2);
    Sk.builtin.defineNode(mod);
    var NODE = 'Node';
    var INT = Sk.ffi.PyType.INT;
    var NUM = [
        Sk.ffi.PyType.FLOAT,
        Sk.ffi.PyType.INT,
        Sk.ffi.PyType.LONG
      ];
    var EUCLIDEAN_3 = 'Euclidean3';
    var INTERSECTION = 'Intersection';
    var VECTOR_2 = 'Vector2';
    var VECTOR_3 = 'Vector3';
    var QUATERNION = 'Quaternion';
    var SCENE = 'Scene';
    var CANVAS_RENDERER = 'CanvasRenderer';
    var WEBGL_RENDERER = 'WebGLRenderer';
    var COLOR = 'Color';
    var ORTHOGRAPHIC_CAMERA = 'OrthographicCamera';
    var PERSPECTIVE_CAMERA = 'PerspectiveCamera';
    var GEOMETRY = 'Geometry';
    var AMBIENT_LIGHT = 'AmbientLight';
    var DIRECTIONAL_LIGHT = 'DirectionalLight';
    var POINT_LIGHT = 'PointLight';
    var LINE = 'Line';
    var LINE_BASIC_MATERIAL = 'LineBasicMaterial';
    var MESH_BASIC_MATERIAL = 'MeshBasicMaterial';
    var MESH_LAMBERT_MATERIAL = 'MeshLambertMaterial';
    var MESH_NORMAL_MATERIAL = 'MeshNormalMaterial';
    var MESH_PHONG_MATERIAL = 'MeshPhongMaterial';
    var CIRCLE_GEOMETRY = 'CircleGeometry';
    var CUBE_GEOMETRY = 'CubeGeometry';
    var CYLINDER_GEOMETRY = 'CylinderGeometry';
    var ICOSAHEDRON_GEOMETRY = 'IcosahedronGeometry';
    var LATHE_GEOMETRY = 'LatheGeometry';
    var OCTAHEDRON_GEOMETRY = 'OctahedronGeometry';
    var PLANE = 'Plane';
    var PLANE_GEOMETRY = 'PlaneGeometry';
    var PROJECTOR = 'Projector';
    var RAY = 'Ray';
    var RAYCASTER = 'Raycaster';
    var REVOLUTION_GEOMETRY = 'RevolutionGeometry';
    var SPHERE = 'Sphere';
    var SPHERE_GEOMETRY = 'SphereGeometry';
    var TEXT_GEOMETRY = 'TextGeometry';
    var TETRAHEDRON_GEOMETRY = 'TetrahedronGeometry';
    var TORUS_GEOMETRY = 'TorusGeometry';
    var PROP_A = 'a';
    var PROP_ASPECT = 'aspect';
    var PROP_ATTITUDE = 'attitude';
    var PROP_AUTO_CLEAR_COLOR = 'autoClearColor';
    var PROP_AXIS = 'axis';
    var PROP_B = 'b';
    var PROP_BOTTOM = 'bottom';
    var PROP_C = 'c';
    var PROP_CANVAS = 'canvas';
    var PROP_CENTER = 'center';
    var PROP_CENTROID = 'centroid';
    var PROP_CHARGE = 'charge';
    var PROP_CHILDREN = 'children';
    var PROP_COLOR = 'color';
    var PROP_COLORS = 'colors';
    var PROP_CONSTANT = 'constant';
    var PROP_DEPTH = 'depth';
    var PROP_DEPTH_SEGMENTS = 'depthSegments';
    var PROP_DETAIL = 'detail';
    var PROP_DOM_ELEMENT = 'domElement';
    var PROP_DIRECTION = 'direction';
    var PROP_DISTANCE = 'distance';
    var PROP_EMISSIVE = 'emissive';
    var PROP_EULER_ORDER = 'eulerOrder';
    var PROP_FACE = 'face';
    var PROP_FACES = 'faces';
    var PROP_FAR = 'far';
    var PROP_FOG = 'fog';
    var PROP_FOV = 'fov';
    var PROP_GENERATOR = 'generator';
    var PROP_GEOMETRY = 'geometry';
    var PROP_HEIGHT = 'height';
    var PROP_HEIGHT_SEGMENTS = 'heightSegments';
    var PROP_ID = 'id';
    var PROP_LEFT = 'left';
    var PROP_MASS = 'mass';
    var PROP_MOMENTUM = 'momentum';
    var PROP_MATERIAL = 'material';
    var PROP_MATRIX_AUTO_UPDATE = 'matrixAutoUpdate';
    var PROP_MATRIX_WORLD = 'matrixWorld';
    var PROP_NAME = 'name';
    var PROP_NEAR = 'near';
    var PROP_NEEDS_UPDATE = 'needsUpdate';
    var PROP_NORMAL = 'normal';
    var PROP_OFFSET = 'offset';
    var PROP_OPACITY = 'opacity';
    var PROP_ORIGIN = 'origin';
    var PROP_OVERDRAW = 'overdraw';
    var PROP_PHI_START = 'phiStart';
    var PROP_PHI_LENGTH = 'phiLength';
    var PROP_PLANE = 'plane';
    var PROP_POINT = 'point';
    var PROP_POINTS = 'points';
    var PROP_POSITION = 'position';
    var PROP_QUATERNION = 'quaternion';
    var PROP_RADIUS = 'radius';
    var PROP_RADIUS_CONE = 'radiusCone';
    var PROP_RADIUS_SHAFT = 'radiusShaft';
    var PROP_RADIUS_TOP = 'radiusTop';
    var PROP_RADIUS_BOTTOM = 'radiusBottom';
    var PROP_RAY = 'ray';
    var PROP_SIZE = 'size';
    var PROP_SIZE_ATTENUATION = 'sizeAttenuation';
    var PROP_SPHERE = 'sphere';
    var PROP_INTENSITY = 'intensity';
    var PROP_OBJECT = 'object';
    var PROP_OBJECTS = 'objects';
    var PROP_OPEN_ENDED = 'openEnded';
    var PROP_RADIAL_SEGMENTS = 'radialSegments';
    var PROP_RIGHT = 'right';
    var PROP_ROTATION = 'rotation';
    var PROP_SCALE = 'scale';
    var PROP_SEGMENTS = 'segments';
    var PROP_SORT_OBJECTS = 'sortObjects';
    var PROP_THETA_START = 'thetaStart';
    var PROP_THETA_LENGTH = 'thetaLength';
    var PROP_TOP = 'top';
    var PROP_TRANSPARENT = 'transparent';
    var PROP_TYPE = 'type';
    var PROP_UP = 'up';
    var PROP_UUID = 'uuid';
    var PROP_USE_QUATERNION = 'useQuaternion';
    var PROP_VELOCITY = 'velocity';
    var PROP_VERTEX_COLORS = 'vertexColors';
    var PROP_VERTEX_NORMALS = 'vertexNormals';
    var PROP_VERTICES = 'vertices';
    var PROP_VISIBLE = 'visible';
    var PROP_WIDTH = 'width';
    var PROP_WIDTH_SEGMENTS = 'widthSegments';
    var PROP_WIREFRAME = 'wireframe';
    var PROP_WIREFRAME_LINEWIDTH = 'wireframeLinewidth';
    var PROP_VECTOR = 'vector';
    var PROP_W = 'w';
    var PROP_X = 'x';
    var PROP_Y = 'y';
    var PROP_Z = 'z';
    var PROP_XY = 'xy';
    var PROP_YZ = 'yz';
    var PROP_ZX = 'zx';
    var PROP_XYZ = 'xyz';
    var METHOD_APPEND = 'append';
    var METHOD_APPLY_MATRIX = 'applyMatrix';
    var METHOD_CLONE = 'clone';
    var METHOD_CONTAINS_POINT = 'containsPoint';
    var METHOD_COPY = 'copy';
    var METHOD_DETERMINANT = 'determinant';
    var METHOD_DISTANCE_TO_POINT = 'distanceToPoint';
    var METHOD_DISTANCE_TO_SPHERE = 'distanceToSphere';
    var PROP_HEX = 'hex';
    var METHOD_GET_HEX = 'getHex';
    var METHOD_SET_HEX = 'setHex';
    var METHOD_GET_HEX_STRING = 'getHexString';
    var METHOD_GET_NORMAL_MATRIX = 'getNormalMatrix';
    var METHOD_IDENTITY = 'identity';
    var METHOD_INTERSECTS_SPHERE = 'intersectsSphere';
    var METHOD_INTERSECT_OBJECTS = 'intersectObjects';
    var METHOD_MAKE_ROTATION_X = 'makeRotationX';
    var METHOD_MAKE_ROTATION_Y = 'makeRotationY';
    var METHOD_MAKE_ROTATION_Z = 'makeRotationZ';
    var METHOD_PICKING_RAY = 'pickingRay';
    var METHOD_PROJECT_VECTOR = 'projectVector';
    var METHOD_ROTATE_ON_AXIS = 'rotateOnAxis';
    var METHOD_ROTATE_X = 'rotateX';
    var METHOD_ROTATE_Y = 'rotateY';
    var METHOD_ROTATE_Z = 'rotateZ';
    var METHOD_SET = 'set';
    var METHOD_SET_X = 'setX';
    var METHOD_SET_Y = 'setY';
    var METHOD_SET_Z = 'setZ';
    var METHOD_GET_COMPONENT = 'getComponent';
    var METHOD_SET_COMPONENT = 'setComponent';
    var METHOD_SET_GEOMETRY = 'setGeometry';
    var METHOD_TRANSPOSE = 'transpose';
    var METHOD_TRANSLATE_ON_AXIS = 'translateOnAxis';
    var METHOD_TRANSLATE_X = 'translateX';
    var METHOD_TRANSLATE_Y = 'translateY';
    var METHOD_TRANSLATE_Z = 'translateZ';
    var METHOD_TRAVERSE = 'traverse';
    var METHOD_UNPROJECT_VECTOR = 'unprojectVector';
    var UPDATE_PROJECTION_MATRIX = 'updateProjectionMatrix';
    var METHOD_UPDATE_MATRIX = 'updateMatrix';
    var METHOD_ADD = 'add';
    var METHOD_CROSS = 'cross';
    var METHOD_COMPUTE_CENTROIDS = 'computeCentroids';
    var METHOD_COMPUTE_FACE_NORMALS = 'computeFaceNormals';
    var METHOD_DOT = 'dot';
    var METHOD_LOOK_AT = 'lookAt';
    var METHOD_REMOVE = 'remove';
    var METHOD_SET_RGB = 'setRGB';
    var ARG_ALPHA = 'alpha';
    var ARG_ASPECT = PROP_ASPECT;
    var ARG_AXIS = 'axis';
    var ARG_CALLBACK = 'callback';
    var ARG_COLOR = PROP_COLOR;
    var ARG_DEPTH = PROP_DEPTH;
    var ARG_DETAIL = PROP_DETAIL;
    var ARG_FAR = PROP_FAR;
    var ARG_FOV = PROP_FOV;
    var ARG_LENGTH = 'length';
    var ARG_NEAR = PROP_NEAR;
    var ARG_RADIUS = PROP_RADIUS;
    var ARG_RADIUS_CONE = PROP_RADIUS_CONE;
    var ARG_RADIUS_SHAFT = PROP_RADIUS_SHAFT;
    var ARG_OTHER = 'other';
    var ARG_THETA = 'theta';
    var ARG_MATRIX = 'matrix';
    var ARG_VECTOR = 'vector';
    var ARG_WIDTH = PROP_WIDTH;
    var COMMA = ',';
    var SPACE = ' ';
    var EQUAL = '=';
    var LPAREN = '(';
    var RPAREN = ')';
    var NEWLINE = '\n';
    var OP_MUL = '*';
    Sk.stdlib.CylinderGeometry = function (radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, axis) {
      THREE[GEOMETRY].call(this);
      this.radiusTop = radiusTop = radiusTop !== undefined ? radiusTop : 20;
      this.radiusBottom = radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
      this.height = height = height !== undefined ? height : 100;
      this.radialSegments = radialSegments = radialSegments || 8;
      this.heightSegments = heightSegments = heightSegments || 1;
      this.openEnded = openEnded = openEnded !== undefined ? openEnded : false;
      var heightHalf = height / 2;
      var direction = Sk.stdlib.direction(axis.x, axis.y, axis.z);
      var orientation = Sk.stdlib.orientation(axis.x, axis.y, axis.z);
      var idxAngle;
      var idxSlice;
      var vertices = [];
      var uvs = [];
      for (idxSlice = 0; idxSlice <= heightSegments; idxSlice++) {
        var verticesRow = [];
        var uvsRow = [];
        var v = idxSlice / heightSegments;
        var z = -v * height + heightHalf;
        var radius = v * (radiusBottom - radiusTop) + radiusTop;
        for (idxAngle = 0; idxAngle < radialSegments; idxAngle++) {
          var u = idxAngle / radialSegments;
          var theta = u * Math.PI * 2;
          var vertex = Sk.three.vector3Cycle(z, radius * Sk.math.cos(theta), radius * Sk.math.sin(theta), direction);
          this.vertices.push(vertex);
          verticesRow.push(this.vertices.length - 1);
          uvsRow.push(new THREE.Vector2(u, 1 - v));
        }
        vertices.push(verticesRow);
        uvs.push(uvsRow);
      }
      var tanTheta = (radiusBottom - radiusTop) / height;
      var na, nb;
      var c0, c1;
      for (idxAngle = 0; idxAngle < radialSegments; idxAngle++) {
        var idxThetaLo = (idxAngle + 0) % radialSegments;
        var idxThetaHi = (idxAngle + 1) % radialSegments;
        if (radiusTop !== 0) {
          na = this.vertices[vertices[0][idxThetaLo]].clone();
          nb = this.vertices[vertices[0][idxThetaHi]].clone();
        } else {
          na = this.vertices[vertices[1][idxThetaLo]].clone();
          nb = this.vertices[vertices[1][idxThetaHi]].clone();
        }
        c0 = na.getComponent((direction + 2) % 3);
        c1 = na.getComponent((direction + 1) % 3);
        na.setComponent((direction + 0) % 3, Math.sqrt(c0 * c0 + c1 * c1) * tanTheta);
        na.normalize();
        c0 = nb.getComponent((direction + 2) % 3);
        c1 = nb.getComponent((direction + 1) % 3);
        nb.setComponent((direction + 0) % 3, Math.sqrt(c0 * c0 + c1 * c1) * tanTheta);
        nb.normalize();
        for (idxSlice = 0; idxSlice < heightSegments; idxSlice++) {
          var v1 = vertices[idxSlice][idxThetaLo];
          var v2 = vertices[idxSlice + 1][idxThetaLo];
          var v3 = vertices[idxSlice + 1][idxThetaHi];
          var v4 = vertices[idxSlice][idxThetaHi];
          var n1 = na.clone();
          var n2 = na.clone();
          var n3 = nb.clone();
          var n4 = nb.clone();
          var uv1 = uvs[idxSlice][idxThetaLo].clone();
          var uv2 = uvs[idxSlice + 1][idxThetaLo].clone();
          var uv3 = uvs[idxSlice + 1][idxThetaHi].clone();
          var uv4 = uvs[idxSlice][idxThetaHi].clone();
          this.faces.push(new THREE.Face3(v1, v2, v4, [
            n1,
            n2,
            n4
          ]));
          this.faceVertexUvs[0].push([
            uv1,
            uv2,
            uv4
          ]);
          this.faces.push(new THREE.Face3(v2, v3, v4, [
            n2,
            n3,
            n4
          ]));
          this.faceVertexUvs[0].push([
            uv2,
            uv3,
            uv4
          ]);
        }
      }
      if (openEnded === false && radiusTop > 0) {
        this.vertices.push(Sk.three.vector3Cycle(+heightHalf, 0, 0, direction));
        for (idxAngle = 0; idxAngle < radialSegments; idxAngle++) {
          var idxThetaLo = (idxAngle + 0) % radialSegments;
          var idxThetaHi = (idxAngle + 1) % radialSegments;
          var v1 = vertices[0][idxThetaLo];
          var v2 = vertices[0][idxThetaHi];
          var v3 = this.vertices.length - 1;
          var n1 = Sk.three.vector3Cycle(+1, 0, 0, direction);
          var n2 = Sk.three.vector3Cycle(+1, 0, 0, direction);
          var n3 = Sk.three.vector3Cycle(+1, 0, 0, direction);
          var uv1 = uvs[0][idxThetaLo].clone();
          var uv2 = uvs[0][idxThetaHi].clone();
          var uv3 = new THREE.Vector2(uv2.u, 0);
          this.faces.push(new THREE.Face3(v1, v2, v3, [
            n1,
            n2,
            n3
          ]));
          this.faceVertexUvs[0].push([
            uv1,
            uv2,
            uv3
          ]);
        }
      }
      if (openEnded === false && radiusBottom > 0) {
        this.vertices.push(Sk.three.vector3Cycle(-heightHalf, 0, 0, direction));
        for (idxAngle = 0; idxAngle < radialSegments; idxAngle++) {
          var idxThetaLo = (idxAngle + 0) % radialSegments;
          var idxThetaHi = (idxAngle + 1) % radialSegments;
          var v1 = vertices[heightSegments][idxThetaHi];
          var v2 = vertices[heightSegments][idxThetaLo];
          var v3 = this.vertices.length - 1;
          var n1 = Sk.three.vector3Cycle(-1, 0, 0, direction);
          var n2 = Sk.three.vector3Cycle(-1, 0, 0, direction);
          var n3 = Sk.three.vector3Cycle(-1, 0, 0, direction);
          var uv1 = uvs[heightSegments][idxThetaHi].clone();
          var uv2 = uvs[heightSegments][idxThetaLo].clone();
          var uv3 = new THREE.Vector2(uv2.u, 1);
          this.faces.push(new THREE.Face3(v1, v2, v3, [
            n1,
            n2,
            n3
          ]));
          this.faceVertexUvs[0].push([
            uv1,
            uv2,
            uv3
          ]);
        }
      }
      this.computeCentroids();
      this.computeFaceNormals();
    };
    Sk.stdlib.CylinderGeometry.prototype = Object.create(THREE['Geometry'].prototype);
    Sk.stdlib.PlaneGeometry = function (width, height, widthSegments, heightSegments) {
      THREE[GEOMETRY].call(this);
      this.width = width;
      this.height = height;
      this.widthSegments = widthSegments || 1;
      this.heightSegments = heightSegments || 1;
      var ix, iz;
      var width_half = width / 2;
      var height_half = height / 2;
      var gridX = this.widthSegments;
      var gridZ = this.heightSegments;
      var gridX1 = gridX + 1;
      var gridZ1 = gridZ + 1;
      var segment_width = this.width / gridX;
      var segment_height = this.height / gridZ;
      var normal = new THREE.Vector3(0, 0, 1);
      for (iz = 0; iz < gridZ1; iz++) {
        for (ix = 0; ix < gridX1; ix++) {
          var x = ix * segment_width - width_half;
          var y = iz * segment_height - height_half;
          this['vertices'].push(new THREE.Vector3(x, -y, 0));
        }
      }
      for (iz = 0; iz < gridZ; iz++) {
        for (ix = 0; ix < gridX; ix++) {
          var a = ix + gridX1 * iz;
          var b = ix + gridX1 * (iz + 1);
          var c = ix + 1 + gridX1 * (iz + 1);
          var d = ix + 1 + gridX1 * iz;
          var uva = new THREE.Vector2(ix / gridX, 1 - iz / gridZ);
          var uvb = new THREE.Vector2(ix / gridX, 1 - (iz + 1) / gridZ);
          var uvc = new THREE.Vector2((ix + 1) / gridX, 1 - (iz + 1) / gridZ);
          var uvd = new THREE.Vector2((ix + 1) / gridX, 1 - iz / gridZ);
          var face = new THREE.Face3(a, b, d);
          face.normal.copy(normal);
          face.vertexNormals.push(normal.clone(), normal.clone(), normal.clone());
          this['faces'].push(face);
          this['faceVertexUvs'][0].push([
            uva,
            uvb,
            uvd
          ]);
          face = new THREE.Face3(b, c, d);
          face.normal.copy(normal);
          face.vertexNormals.push(normal.clone(), normal.clone(), normal.clone());
          this['faces'].push(face);
          this['faceVertexUvs'][0].push([
            uvb.clone(),
            uvc,
            uvd.clone()
          ]);
        }
      }
      this['computeCentroids']();
    };
    Sk.stdlib.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype);
    Sk.stdlib.RevolutionGeometry = function (points, generator, segments, phiStart, phiLength, attitude) {
      THREE[GEOMETRY].call(this);
      segments = segments || 12;
      phiStart = phiStart || 0;
      phiLength = phiLength || 2 * Math.PI;
      var isClosed = Math.abs(2 * Math.PI - Math.abs(phiLength - phiStart)) < 0.0001;
      var halfPlanes = isClosed ? segments : segments + 1;
      var inverseSegments = 1 / segments;
      var phiStep = (phiLength - phiStart) * inverseSegments;
      for (var i = 0, il = halfPlanes; i < il; i++) {
        var phi = phiStart + i * phiStep;
        var halfAngle = phi / 2;
        var cosHA = Sk.math.cos(halfAngle);
        var sinHA = Sk.math.sin(halfAngle);
        var rotor = new THREE.Quaternion(generator.x * sinHA, generator.y * sinHA, generator.z * sinHA, cosHA);
        for (var j = 0, jl = points.length; j < jl; j++) {
          var pt = points[j];
          var vertex = new THREE.Vector3(pt.x, pt.y, pt.z);
          vertex.applyQuaternion(rotor);
          if (attitude) {
            vertex.applyQuaternion(attitude);
          }
          this['vertices'].push(vertex);
        }
      }
      var inversePointLength = 1 / (points.length - 1);
      var np = points.length;
      var wrap = np * halfPlanes;
      for (var i = 0, il = segments; i < il; i++) {
        for (var j = 0, jl = points.length - 1; j < jl; j++) {
          var base = j + np * i;
          var a = base % wrap;
          var b = (base + np) % wrap;
          var c = (base + 1 + np) % wrap;
          var d = (base + 1) % wrap;
          var u0 = i * inverseSegments;
          var v0 = j * inversePointLength;
          var u1 = u0 + inverseSegments;
          var v1 = v0 + inversePointLength;
          this['faces'].push(new THREE.Face3(d, b, a));
          this['faceVertexUvs'][0].push([
            new THREE.Vector2(u0, v0),
            new THREE.Vector2(u1, v0),
            new THREE.Vector2(u0, v1)
          ]);
          this['faces'].push(new THREE.Face3(d, c, b));
          this['faceVertexUvs'][0].push([
            new THREE.Vector2(u1, v0),
            new THREE.Vector2(u1, v1),
            new THREE.Vector2(u0, v1)
          ]);
        }
      }
      this['computeCentroids']();
      this['computeFaceNormals']();
      this['computeVertexNormals']();
    };
    Sk.stdlib.RevolutionGeometry.prototype = Object.create(THREE.Geometry.prototype);
    Sk.stdlib.TorusGeometry = function (radius, tube, radialSegments, tubularSegments, arc) {
      THREE[GEOMETRY].call(this);
      var scope = this;
      this.radius = radius || 100;
      this.tube = tube || 40;
      this.radialSegments = radialSegments || 8;
      this.tubularSegments = tubularSegments || 6;
      this.arc = arc || Math.PI * 2;
      var center = new THREE.Vector3(), uvs = [], normals = [];
      for (var j = 0; j <= this.radialSegments; j++) {
        for (var i = 0; i <= this.tubularSegments; i++) {
          var u = i / this.tubularSegments * this.arc;
          var v = j / this.radialSegments * Math.PI * 2;
          center.x = this.radius * Sk.math.cos(u);
          center.y = this.radius * Sk.math.sin(u);
          var vertex = new THREE.Vector3();
          vertex.x = (this.radius + this.tube * Sk.math.cos(v)) * Sk.math.cos(u);
          vertex.y = (this.radius + this.tube * Sk.math.cos(v)) * Sk.math.sin(u);
          vertex.z = this.tube * Sk.math.sin(v);
          this['vertices'].push(vertex);
          uvs.push(new THREE.Vector2(i / this.tubularSegments, j / this.radialSegments));
          normals.push(vertex.clone().sub(center).normalize());
        }
      }
      for (var j = 1; j <= this.radialSegments; j++) {
        for (var i = 1; i <= this.tubularSegments; i++) {
          var a = (this.tubularSegments + 1) * j + i - 1;
          var b = (this.tubularSegments + 1) * (j - 1) + i - 1;
          var c = (this.tubularSegments + 1) * (j - 1) + i;
          var d = (this.tubularSegments + 1) * j + i;
          var face = new THREE.Face3(a, b, d, [
              normals[a],
              normals[b],
              normals[d]
            ]);
          face.normal.add(normals[a]);
          face.normal.add(normals[b]);
          face.normal.add(normals[d]);
          face.normal.normalize();
          this['faces'].push(face);
          this['faceVertexUvs'][0].push([
            uvs[a].clone(),
            uvs[b].clone(),
            uvs[d].clone()
          ]);
          face = new THREE.Face3(b, c, d, [
            normals[b],
            normals[c],
            normals[d]
          ]);
          face.normal.add(normals[b]);
          face.normal.add(normals[c]);
          face.normal.add(normals[d]);
          face.normal.normalize();
          this['faces'].push(face);
          this['faceVertexUvs'][0].push([
            uvs[b].clone(),
            uvs[c].clone(),
            uvs[d].clone()
          ]);
        }
      }
      this['computeCentroids']();
    };
    Sk.stdlib.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype);
    Sk.stdlib.VortexGeometry = function (radius, radiusCone, radiusShaft, lengthCone, lengthShaft, arrowSegments, radialSegments) {
      THREE[GEOMETRY].call(this);
      var scope = this;
      var n = 9;
      this.radius = radius || 1;
      this.radiusCone = radiusCone || 0.08;
      this.radiusShaft = radiusShaft || 0.01;
      this.lengthCone = lengthCone || 0.2;
      this.lengthShaft = lengthShaft || 0.8;
      arrowSegments = arrowSegments || 6;
      this.circleSegments = arrowSegments * n;
      this.radialSegments = radialSegments || 8;
      var twoPI = Math.PI * 2;
      var R = this.radius;
      var center = new THREE.Vector3();
      var uvs = [];
      var normals = [];
      var alpha = this.lengthShaft / (this.lengthCone + this.lengthShaft);
      var factor = twoPI / arrowSegments;
      var theta = alpha / (n - 2);
      function computeAngle(circleSegments, i) {
        var m = i % n;
        if (m === n - 1) {
          return computeAngle(circleSegments, i - 1);
        } else {
          var a = (i - m) / n;
          return factor * (a + m * theta);
        }
      }
      function computeRadius(i) {
        var m = i % n;
        if (m === n - 1) {
          return radiusCone;
        } else {
          return radiusShaft;
        }
      }
      for (var j = 0; j <= this.radialSegments; j++) {
        var v = twoPI * j / this.radialSegments;
        var cosV = Sk.math.cos(v);
        var sinV = Sk.math.sin(v);
        for (var i = 0; i <= this.circleSegments; i++) {
          var u = computeAngle(this.circleSegments, i);
          var cosU = Sk.math.cos(u);
          var sinU = Sk.math.sin(u);
          center.x = R * cosU;
          center.y = R * sinU;
          var vertex = new THREE.Vector3();
          var r = computeRadius(i);
          vertex.x = (R + r * cosV) * cosU;
          vertex.y = (R + r * cosV) * sinU;
          vertex.z = r * sinV;
          this['vertices'].push(vertex);
          uvs.push(new THREE.Vector2(i / this.circleSegments, j / this.radialSegments));
          normals.push(vertex.clone().sub(center).normalize());
        }
      }
      for (var j = 1; j <= this.radialSegments; j++) {
        for (var i = 1; i <= this.circleSegments; i++) {
          var a = (this.circleSegments + 1) * j + i - 1;
          var b = (this.circleSegments + 1) * (j - 1) + i - 1;
          var c = (this.circleSegments + 1) * (j - 1) + i;
          var d = (this.circleSegments + 1) * j + i;
          var face = new THREE.Face3(a, b, d, [
              normals[a],
              normals[b],
              normals[d]
            ]);
          face.normal.add(normals[a]);
          face.normal.add(normals[b]);
          face.normal.add(normals[d]);
          face.normal.normalize();
          this['faces'].push(face);
          this['faceVertexUvs'][0].push([
            uvs[a].clone(),
            uvs[b].clone(),
            uvs[d].clone()
          ]);
          face = new THREE.Face3(b, c, d, [
            normals[b],
            normals[c],
            normals[d]
          ]);
          face.normal.add(normals[b]);
          face.normal.add(normals[c]);
          face.normal.add(normals[d]);
          face.normal.normalize();
          this['faces'].push(face);
          this['faceVertexUvs'][0].push([
            uvs[b].clone(),
            uvs[c].clone(),
            uvs[d].clone()
          ]);
        }
      }
      this['computeCentroids']();
    };
    Sk.stdlib.VortexGeometry.prototype = Object.create(THREE.Geometry.prototype);
    function checkArgBool(name, valuePy) {
      Sk.ffi.checkArgType(name, Sk.ffi.PyType.BOOL, Sk.ffi.isBool(valuePy), valuePy);
      return Sk.ffi.remapToJs(valuePy);
    }
    function isBoolean(x) {
      return typeof x === 'boolean';
    }
    function isFunction(x) {
      return typeof x === 'function';
    }
    function isNumber(x) {
      return typeof x === 'number';
    }
    function isObject(x) {
      return typeof x === 'object';
    }
    function isString(x) {
      return typeof x === 'string';
    }
    function isUndefined(x) {
      return typeof x === 'undefined';
    }
    function isDefined(x) {
      return typeof x !== 'undefined';
    }
    function isNull(x) {
      return typeof x === 'object' && x === null;
    }
    function isEuclidean3Py(valuePy) {
      return Sk.ffi.isInstance(valuePy, EUCLIDEAN_3);
    }
    function isQuaternionPy(valuePy) {
      return Sk.ffi.isInstance(valuePy, QUATERNION);
    }
    function isVector3Py(valuePy) {
      return Sk.ffi.isInstance(valuePy, VECTOR_3);
    }
    function isGeometryPy(valuePy) {
      return Sk.ffi.isInstance(valuePy) && Sk.ffi.typeName(valuePy) === GEOMETRY;
    }
    function quaternionToEuclidean3Py(quaternion) {
      var euclidean = new THREE[EUCLIDEAN_3](new THREE.Vector3(0, 0, 0), quaternion, 0);
      return Sk.ffi.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(euclidean, EUCLIDEAN_3));
    }
    function setQuaternionProperty(className, targetPy, name, valuePy, aliasName) {
      Sk.ffi.checkArgType('target', className, Sk.ffi.isInstance(targetPy, className), targetPy);
      aliasName = aliasName || name;
      Sk.ffi.checkArgType(aliasName, EUCLIDEAN_3, isEuclidean3Py(valuePy), valuePy);
      var quaternionPy = Sk.ffi.gattr(valuePy, PROP_QUATERNION);
      Sk.ffi.checkArgType(aliasName, QUATERNION, isQuaternionPy(quaternionPy), quaternionPy);
      Sk.ffi.remapToJs(targetPy)[name] = Sk.ffi.remapToJs(quaternionPy);
    }
    function vectorToEuclidean3Py(vector) {
      var euclidean = new THREE[EUCLIDEAN_3](vector, new THREE.Quaternion(0, 0, 0, 0), 0);
      return Sk.ffi.callsim(mod[EUCLIDEAN_3], Sk.ffi.referenceToPy(euclidean, EUCLIDEAN_3));
    }
    function remapToVector3(name, euclidean3Py) {
      if (isDefined(euclidean3Py)) {
        Sk.ffi.checkArgType(name, EUCLIDEAN_3, isEuclidean3Py(euclidean3Py), euclidean3Py);
        var vectorPy = Sk.ffi.gattr(euclidean3Py, PROP_VECTOR);
        Sk.ffi.checkArgType(name, VECTOR_3, isVector3Py(vectorPy), vectorPy);
        return Sk.ffi.remapToJs(vectorPy);
      } else {
        return undefined;
      }
    }
    function setVectorProperty(obj, name, valuePy, aliasName) {
      aliasName = aliasName || name;
      obj[name] = remapToVector3(aliasName, valuePy);
    }
    function methodAdd(target) {
      if (!isObject(target)) {
        throw Sk.ffi.assertionError('target must be an object.');
      }
      if (!isFunction(target[METHOD_ADD])) {
        throw Sk.ffi.assertionError('target must have an \'add\' function.');
      }
      return Sk.ffi.callableToPy(mod, METHOD_ADD, function (methodPy, childPy) {
        var child = Sk.ffi.remapToJs(childPy);
        target.add(child);
      });
    }
    function methodLookAt(targetPy) {
      return Sk.ffi.callableToPy(mod, METHOD_LOOK_AT, function (methodPy, euclideanPy) {
        Sk.ffi.checkMethodArgs(METHOD_LOOK_AT, arguments, 1, 1);
        Sk.ffi.checkArgType(ARG_VECTOR, EUCLIDEAN_3, isEuclidean3Py(euclideanPy), euclideanPy);
        var vectorPy = Sk.ffi.gattr(euclideanPy, PROP_VECTOR);
        Sk.ffi.checkArgType(ARG_VECTOR, VECTOR_3, isVector3Py(vectorPy), vectorPy);
        Sk.ffi.remapToJs(targetPy)[METHOD_LOOK_AT](Sk.ffi.remapToJs(vectorPy));
        return targetPy;
      });
    }
    function methodRemove(target) {
      if (!isObject(target)) {
        throw Sk.ffi.assertionError('target must be an object.');
      }
      if (!isFunction(target[METHOD_REMOVE])) {
        throw Sk.ffi.assertionError('target must have a \'remove\' function.');
      }
      return Sk.ffi.callableToPy(mod, METHOD_ADD, function (methodPy, childPy) {
        var child = Sk.ffi.remapToJs(childPy);
        target.remove(child);
      });
    }
    function mutableVertexListPy(vertices) {
      return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
        $loc.__init__ = Sk.ffi.functionPy(function (selfPy) {
          var custom = {};
          custom[METHOD_APPEND] = Sk.ffi.callableToPy(mod, METHOD_APPEND, function (methodPy, vectorPy) {
            vertices.push(remapToVector3(PROP_VECTOR, vectorPy));
          });
          Sk.ffi.referenceToPy(vertices, PROP_VERTICES, custom, selfPy);
        });
        $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
          var self = Sk.ffi.remapToJs(selfPy);
          switch (name) {
          case METHOD_APPEND: {
              return selfPy.custom[METHOD_APPEND];
            }
          }
        });
        $loc.__getitem__ = Sk.ffi.functionPy(function (selfPy, indexPy) {
          var index = Sk.ffi.remapToJs(indexPy);
          return vectorToEuclidean3Py(vertices[index]);
        });
        $loc.mp$length = function () {
          return vertices.length;
        };
        $loc.__str__ = Sk.ffi.functionPy(function (self) {
          return Sk.ffh.str(Sk.ffi.listPy(vertices.map(function (vertexJs) {
            return vectorToEuclidean3Py(vertexJs);
          })));
        });
        $loc.__repr__ = Sk.ffi.functionPy(function (self) {
          return Sk.ffi.stringToPy(PROP_VERTICES);
        });
      }, PROP_VERTICES, []));
    }
    function mutableFaceListPy(elements) {
      return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
        $loc.__init__ = Sk.ffi.functionPy(function (selfPy) {
          Sk.ffi.referenceToPy(elements, PROP_FACES, undefined, selfPy);
        });
        $loc.__getattr__ = Sk.ffi.functionPy(function (verticesPy, name) {
          switch (name) {
          case METHOD_APPEND: {
              return Sk.ffi.callableToPy(mod, METHOD_APPEND, function (methodPy, elementPy) {
                elements.push(Sk.ffi.remapToJs(elementPy));
              });
            }
          }
        });
        $loc.__getitem__ = Sk.ffi.functionPy(function (verticesPy, indexPy) {
          var index = Sk.ffi.remapToJs(indexPy);
          return faceToFace3Py(elements[index]);
        });
        $loc.mp$length = function () {
          return elements.length;
        };
        $loc.__str__ = Sk.ffi.functionPy(function (self) {
          return Sk.ffh.str(Sk.ffi.listPy(elements.map(function (elementJs) {
            return faceToFace3Py(elementJs);
          })));
        });
        $loc.__repr__ = Sk.ffi.functionPy(function (self) {
          return Sk.ffi.stringToPy(PROP_FACES);
        });
      }, PROP_FACES, []));
    }
    function faceToFace3Py(face) {
      return Sk.ffi.callsim(mod[Sk.three.FACE_3], Sk.ffi.referenceToPy(face, Sk.three.FACE_3));
    }
    function colorToColorPy(color) {
      return Sk.ffi.callsim(mod[COLOR], Sk.ffi.referenceToPy(color, COLOR));
    }
    function mutableColorListPy(colors) {
      return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
        $loc.__init__ = Sk.ffi.functionPy(function (selfPy) {
          Sk.ffi.referenceToPy(colors, PROP_COLORS, undefined, selfPy);
        });
        $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
          switch (name) {
          case METHOD_APPEND: {
              return Sk.ffi.callableToPy(mod, METHOD_APPEND, function (methodPy, colorPy) {
                colors.push(Sk.ffi.remapToJs(colorPy));
              });
            }
          }
        });
        $loc.__getitem__ = Sk.ffi.functionPy(function (selfPy, indexPy) {
          var index = Sk.ffi.remapToJs(indexPy);
          return colorToColorPy(colors[index]);
        });
        $loc.mp$length = function () {
          return colors.length;
        };
        $loc.__str__ = Sk.ffi.functionPy(function (self) {
          return Sk.ffh.str(Sk.ffi.listPy(colors.map(function (colorJs) {
            return colorToColorPy(colorJs);
          })));
        });
        $loc.__repr__ = Sk.ffi.functionPy(function (self) {
          return Sk.ffi.stringToPy(PROP_COLORS);
        });
      }, PROP_VERTICES, []));
    }
    function isColor(x) {
      if (isDefined(x)) {
        if (x.hasOwnProperty('r') && x.hasOwnProperty('g') && x.hasOwnProperty('b')) {
          return isNumber(x['r']) && isNumber(x['g']) && isNumber(x['b']);
        } else {
          return false;
        }
      } else {
        return false;
      }
    }
    function isColorPy(valuePy) {
      return Sk.ffi.isInstance(valuePy, COLOR);
    }
    function webGLSupported() {
      try {
        if (window.WebGLRenderingContext) {
          if (document.createElement('canvas').getContext('experimental-webgl')) {
            return true;
          } else {
            return false;
          }
        } else {
          return false;
        }
      } catch (e) {
        return false;
      }
    }
    function numberFromArg(arg, argName, functionName, lax) {
      if (isUndefined(argName)) {
        throw new Error('argName must be specified');
      }
      if (isUndefined(functionName)) {
        throw new Error('functionName must be specified');
      }
      lax = isUndefined(lax) ? true : isBoolean(lax) ? lax : true;
      if (isUndefined(arg)) {
        if (lax) {
          return arg;
        } else {
          throw new Sk.builtin.TypeError(functionName + '.' + argName + ' must be convertible to a number, but was Missing.');
        }
      } else if (isNull(arg)) {
        if (lax) {
          return arg;
        } else {
          throw new Sk.builtin.TypeError(functionName + '.' + argName + ' must be convertible to a number, but was None.');
        }
      }
      if (isBoolean(arg)) {
        throw new Sk.builtin.TypeError(functionName + '.' + argName + ' must be convertible to a number, but was a Boolean.');
      }
      if (arg.skType) {
        switch (arg.skType) {
        case 'float': {
            return arg.v;
          }
        case 'int': {
            return arg.v;
          }
        default: {
            throw new Sk.builtin.TypeError(functionName + '(' + argName + ': ' + arg.skType + ') must be convertible to a number.');
          }
        }
      } else if (arg.v) {
        if (isString(arg.v)) {
          throw new Sk.builtin.TypeError(functionName + '.' + argName + ' must be convertible to a number, but was a String.');
        } else {
          throw new Sk.builtin.AssertionError(functionName + '.' + argName + ' is unknown.');
        }
      } else {
        throw new Sk.builtin.AssertionError(functionName + '.' + argName + ' is unknown.');
      }
    }
    Sk.builtin.defineEuclidean3(mod, THREE, BLADE);
    mod[SCENE] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, sceneRefPy) {
        if (Sk.ffi.isUndefined(sceneRefPy)) {
          Sk.ffi.checkMethodArgs(SCENE, arguments, 0, 0);
          Sk.ffi.referenceToPy(new THREE[SCENE](), SCENE, undefined, selfPy);
        } else if (Sk.ffi.isInstance(sceneRefPy, SCENE)) {
          Sk.ffi.referenceToPy(Sk.ffi.remapToJs(sceneRefPy), SCENE, undefined, selfPy);
        } else {
          Sk.ffi.checkMethodArgs(SCENE, arguments, 0, 0);
        }
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (scenePy, name) {
        var scene = Sk.ffi.remapToJs(scenePy);
        switch (name) {
        case PROP_CHILDREN: {
            return Sk.ffi.listPy(scene[PROP_CHILDREN].map(function (objectJs) {
              return Sk.ffi.callsim(mod[Sk.three.OBJECT_3D], Sk.ffi.referenceToPy(objectJs, Sk.three.OBJECT_3D));
            }));
          }
        case PROP_POSITION: {
            return vectorToEuclidean3Py(scene[PROP_POSITION]);
          }
        case PROP_QUATERNION: {
            return Sk.ffi.callsim(mod[QUATERNION], Sk.ffi.referenceToPy(scene[PROP_QUATERNION], QUATERNION));
          }
        case PROP_ROTATION: {
            return vectorToEuclidean3Py(scene[PROP_ROTATION]);
          }
        case PROP_EULER_ORDER: {
            return Sk.ffi.stringToPy(scene[PROP_EULER_ORDER]);
          }
        case PROP_SCALE: {
            return vectorToEuclidean3Py(scene[PROP_SCALE]);
          }
        case PROP_UP: {
            return vectorToEuclidean3Py(scene[PROP_UP]);
          }
        case PROP_USE_QUATERNION: {
            return scene[PROP_USE_QUATERNION];
          }
        case METHOD_LOOK_AT: {
            return methodLookAt(scenePy);
          }
        case METHOD_ADD: {
            return methodAdd(scene);
          }
        case METHOD_REMOVE: {
            return methodRemove(scene);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (scenePy, name, valuePy) {
        var scene = Sk.ffi.remapToJs(scenePy);
        var value = Sk.ffi.remapToJs(valuePy);
        switch (name) {
        case PROP_POSITION:
        case PROP_ROTATION:
        case PROP_SCALE:
        case PROP_UP: {
            setVectorProperty(scene, name, valuePy);
          }
          break;
        case PROP_QUATERNION: {
            scene[PROP_QUATERNION] = value;
          }
          break;
        case PROP_EULER_ORDER: {
            if (isString(value)) {
              scene[PROP_EULER_ORDER] = value;
            } else {
              throw new Error(name + ' must be a string');
            }
          }
          break;
        case PROP_USE_QUATERNION: {
            scene[PROP_USE_QUATERNION] = value;
          }
          break;
        default: {
            throw new Error(name + ' is not a write attribute of ' + SCENE);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (self) {
        return Sk.ffi.stringToPy(SCENE);
      });
    }, SCENE, []);
    mod[CANVAS_RENDERER] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      var PROP_AUTO_CLEAR = 'autoClear';
      var PROP_CLEAR_COLOR = 'clearColor';
      var PROP_GAMMA_INPUT = 'gammaInput';
      var PROP_GAMMA_OUTPUT = 'gammaOutput';
      var PROP_SORT_OBJECTS = 'sortObjects';
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, parametersPy) {
        var parameters = Sk.ffi.remapToJs(parametersPy);
        Sk.ffi.referenceToPy(new THREE[CANVAS_RENDERER](parameters), CANVAS_RENDERER, undefined, selfPy);
      });
      $loc.setSize = Sk.ffi.functionPy(function (self, width, height) {
        self.v.setSize(Sk.builtin.asnum$(width), Sk.builtin.asnum$(height));
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (self, name) {
        var METHOD_RENDER = 'render';
        var METHOD_GET_CLEAR_COLOR = 'getClearColor';
        var METHOD_SET_CLEAR_COLOR = 'setClearColor';
        var METHOD_SET_SIZE = 'setSize';
        var renderer = Sk.ffi.remapToJs(self);
        switch (name) {
        case PROP_AUTO_CLEAR: {
            return renderer[PROP_AUTO_CLEAR];
          }
        case PROP_GAMMA_INPUT: {
            return renderer[PROP_GAMMA_INPUT];
          }
        case PROP_GAMMA_OUTPUT: {
            return renderer[PROP_GAMMA_OUTPUT];
          }
        case PROP_SORT_OBJECTS: {
            return renderer[PROP_SORT_OBJECTS];
          }
        case PROP_CANVAS:
        case PROP_DOM_ELEMENT: {
            return Sk.ffi.callsim(mod[NODE], Sk.ffi.referenceToPy(renderer[PROP_DOM_ELEMENT], NODE));
          }
        case METHOD_RENDER: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (self) {
                self.tp$name = METHOD_RENDER;
              });
              $loc.__call__ = Sk.ffi.functionPy(function (self, scene, camera) {
                scene = Sk.ffi.remapToJs(scene);
                camera = Sk.ffi.remapToJs(camera);
                renderer[METHOD_RENDER](scene, camera);
              });
              $loc.__str__ = Sk.ffi.functionPy(function (self) {
                return Sk.ffi.stringToPy(METHOD_RENDER);
              });
              $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                return Sk.ffi.stringToPy(METHOD_RENDER);
              });
            }, METHOD_RENDER, []));
          }
        case METHOD_GET_CLEAR_COLOR: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (self) {
                self.tp$name = METHOD_GET_CLEAR_COLOR;
              });
              $loc.__call__ = Sk.ffi.functionPy(function (self) {
                return Sk.ffi.callsim(mod[COLOR], Sk.ffi.referenceToPy(renderer[METHOD_GET_CLEAR_COLOR](), COLOR));
              });
              $loc.__str__ = Sk.ffi.functionPy(function (self) {
                return Sk.ffi.stringToPy(METHOD_GET_CLEAR_COLOR);
              });
              $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                return Sk.ffi.stringToPy(METHOD_GET_CLEAR_COLOR);
              });
            }, METHOD_GET_CLEAR_COLOR, []));
          }
        case METHOD_SET_CLEAR_COLOR: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (self) {
                self.tp$name = METHOD_SET_CLEAR_COLOR;
              });
              $loc.__call__ = Sk.ffi.functionPy(function (self, color, alpha) {
                color = Sk.ffi.remapToJs(color);
                alpha = Sk.ffi.remapToJs(alpha);
                renderer[METHOD_SET_CLEAR_COLOR](color, alpha);
              });
              $loc.__str__ = Sk.ffi.functionPy(function (self) {
                return Sk.ffi.stringToPy(METHOD_SET_CLEAR_COLOR);
              });
              $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                return Sk.ffi.stringToPy(METHOD_SET_CLEAR_COLOR);
              });
            }, METHOD_SET_CLEAR_COLOR, []));
          }
        case METHOD_SET_SIZE: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (self) {
                self.tp$name = METHOD_SET_SIZE;
              });
              $loc.__call__ = Sk.ffi.functionPy(function (self, width, height, updateStyle) {
                width = Sk.ffi.remapToJs(width);
                height = Sk.ffi.remapToJs(height);
                updateStyle = Sk.ffi.remapToJs(updateStyle);
                renderer.setSize(width, height, updateStyle);
              });
              $loc.__str__ = Sk.ffi.functionPy(function (self) {
                return Sk.ffi.stringToPy(METHOD_SET_SIZE);
              });
              $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                return Sk.ffi.stringToPy(METHOD_SET_SIZE);
              });
            }, METHOD_SET_SIZE, []));
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(CANVAS_RENDERER);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (self, name, value) {
        var renderer = Sk.ffi.remapToJs(self);
        value = Sk.ffi.remapToJs(value);
        switch (name) {
        case PROP_AUTO_CLEAR: {
            if (isBoolean(value)) {
              renderer[PROP_AUTO_CLEAR] = value;
            } else {
              throw new Sk.builtin.TypeError('\'' + PROP_AUTO_CLEAR + '\' attribute must be a <type \'bool\'>.');
            }
          }
          break;
        case PROP_GAMMA_INPUT: {
            if (isBoolean(value)) {
              renderer[PROP_GAMMA_INPUT] = value;
            } else {
              throw new Sk.builtin.TypeError('\'' + PROP_GAMMA_INPUT + '\' attribute must be a <type \'bool\'>.');
            }
          }
          break;
        case PROP_GAMMA_OUTPUT: {
            if (isBoolean(value)) {
              renderer[PROP_GAMMA_OUTPUT] = value;
            } else {
              throw new Sk.builtin.TypeError('\'' + PROP_GAMMA_OUTPUT + '\' attribute must be a <type \'bool\'>.');
            }
          }
          break;
        case PROP_SORT_OBJECTS: {
            if (isBoolean(value)) {
              renderer[PROP_SORT_OBJECTS] = value;
            } else {
              throw new Sk.builtin.TypeError('\'' + PROP_SORT_OBJECTS + '\' attribute must be a <type \'bool\'>.');
            }
          }
          break;
        case 'size': {
            var width = Sk.builtin.asnum$(value[0]);
            var height = Sk.builtin.asnum$(value[1]);
            renderer.setSize(width, height);
          }
          break;
        default: {
            throw Sk.ffi.err.attribute(name).isNotSetableOnType(CANVAS_RENDERER);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (self) {
        var renderer = self.v;
        var args = {};
        args[PROP_AUTO_CLEAR] = renderer[PROP_AUTO_CLEAR];
        args[PROP_GAMMA_INPUT] = renderer[PROP_GAMMA_INPUT];
        args[PROP_GAMMA_OUTPUT] = renderer[PROP_GAMMA_OUTPUT];
        return Sk.ffi.stringToPy(CANVAS_RENDERER + '(' + JSON.stringify(args) + ')');
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (self) {
        var renderer = self.v;
        var autoClear = renderer[PROP_AUTO_CLEAR];
        var args = [{ 'autoClear': autoClear }];
        return Sk.ffi.stringToPy(CANVAS_RENDERER + '(' + args.map(function (x) {
          return JSON.stringify(x);
        }).join(', ') + ')');
      });
    }, CANVAS_RENDERER, []);
    mod[WEBGL_RENDERER] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      var PROP_AUTO_CLEAR = 'autoClear';
      var PROP_CLEAR_COLOR = 'clearColor';
      var PROP_GAMMA_INPUT = 'gammaInput';
      var PROP_GAMMA_OUTPUT = 'gammaOutput';
      var PROP_SORT_OBJECTS = 'sortObjects';
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, parametersPy) {
        if (Sk.ffi.checkMethodArgs(WEBGL_RENDERER, arguments, 0, 1) > 0) {
          Sk.ffi.checkArgType('parameters', [
            Sk.ffi.PyType.OBJECT,
            Sk.ffi.PyType.DICT
          ], Sk.ffi.isObject(parametersPy) || Sk.ffi.isDict(parametersPy), parametersPy);
        }
        var parameters = Sk.ffi.remapToJs(parametersPy);
        Sk.ffi.referenceToPy(new THREE[WEBGL_RENDERER](parameters), WEBGL_RENDERER, undefined, selfPy);
      });
      $loc.setSize = Sk.ffi.functionPy(function (self, width, height) {
        self.v.setSize(Sk.builtin.asnum$(width), Sk.builtin.asnum$(height));
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (self, name) {
        var METHOD_RENDER = 'render';
        var METHOD_GET_CLEAR_COLOR = 'getClearColor';
        var METHOD_SET_CLEAR_COLOR = 'setClearColor';
        var METHOD_SET_SIZE = 'setSize';
        var renderer = Sk.ffi.remapToJs(self);
        switch (name) {
        case PROP_AUTO_CLEAR: {
            return Sk.ffi.booleanToPy(renderer[PROP_AUTO_CLEAR]);
          }
        case PROP_AUTO_CLEAR_COLOR: {
            return Sk.ffi.booleanToPy(renderer[PROP_AUTO_CLEAR_COLOR]);
          }
        case PROP_GAMMA_INPUT: {
            return Sk.ffi.booleanToPy(renderer[PROP_GAMMA_INPUT]);
          }
        case PROP_GAMMA_OUTPUT: {
            return Sk.ffi.booleanToPy(renderer[PROP_GAMMA_OUTPUT]);
          }
        case PROP_SORT_OBJECTS: {
            return renderer[PROP_SORT_OBJECTS];
          }
        case PROP_CANVAS:
        case PROP_DOM_ELEMENT: {
            return Sk.ffi.callsim(mod[NODE], Sk.ffi.referenceToPy(renderer[PROP_DOM_ELEMENT], NODE));
          }
        case METHOD_RENDER: {
            return Sk.ffi.callableToPy(mod, METHOD_RENDER, function (methodPy, scenePy, cameraPy) {
              Sk.ffi.checkMethodArgs(METHOD_RENDER, arguments, 2, 2);
              var scene = Sk.ffi.remapToJs(scenePy);
              var camera = Sk.ffi.remapToJs(cameraPy);
              return Sk.ffi.remapToPy(renderer[METHOD_RENDER](scene, camera));
            });
          }
        case METHOD_GET_CLEAR_COLOR: {
            return Sk.ffi.callableToPy(mod, METHOD_GET_CLEAR_COLOR, function (methodPy) {
              Sk.ffi.checkMethodArgs(METHOD_GET_CLEAR_COLOR, arguments, 0, 0);
              return Sk.ffi.callsim(mod[COLOR], Sk.ffi.referenceToPy(renderer[METHOD_GET_CLEAR_COLOR](), COLOR));
            });
          }
        case METHOD_SET_CLEAR_COLOR: {
            return Sk.ffi.callableToPy(mod, METHOD_SET_CLEAR_COLOR, function (methodPy, colorPy, alphaPy) {
              Sk.ffi.checkMethodArgs(METHOD_SET_CLEAR_COLOR, arguments, 2, 2);
              Sk.ffi.checkArgType(ARG_COLOR, [
                COLOR,
                Sk.ffi.PyType.INT
              ], isColorPy(colorPy) || Sk.ffi.isInt(colorPy), colorPy);
              Sk.ffi.checkArgType(ARG_ALPHA, NUM, Sk.ffi.isNum(alphaPy), alphaPy);
              var color = Sk.ffi.remapToJs(colorPy);
              var alpha = Sk.ffi.remapToJs(alphaPy);
              return Sk.ffi.remapToPy(renderer[METHOD_SET_CLEAR_COLOR](color, alpha));
            });
          }
        case METHOD_SET_SIZE: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (self) {
                self.tp$name = METHOD_SET_SIZE;
              });
              $loc.__call__ = Sk.ffi.functionPy(function (self, width, height, updateStyle) {
                width = Sk.ffi.remapToJs(width);
                height = Sk.ffi.remapToJs(height);
                updateStyle = Sk.ffi.remapToJs(updateStyle);
                renderer.setSize(width, height, updateStyle);
              });
              $loc.__str__ = Sk.ffi.functionPy(function (self) {
                return Sk.ffi.stringToPy(METHOD_SET_SIZE);
              });
              $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                return Sk.ffi.stringToPy(METHOD_SET_SIZE);
              });
            }, METHOD_SET_SIZE, []));
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(WEBGL_RENDERER);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (self, name, valuePy) {
        var renderer = Sk.ffi.remapToJs(self);
        var value = Sk.ffi.remapToJs(valuePy);
        switch (name) {
        case PROP_AUTO_CLEAR: {
            if (isBoolean(value)) {
              renderer[PROP_AUTO_CLEAR] = value;
            } else {
              throw new Sk.builtin.TypeError('\'' + PROP_AUTO_CLEAR + '\' attribute must be a <type \'bool\'>.');
            }
          }
          break;
        case PROP_AUTO_CLEAR_COLOR: {
            Sk.ffi.checkArgType(PROP_AUTO_CLEAR_COLOR, Sk.ffi.PyType.BOOL, Sk.ffi.isBool(valuePy), valuePy);
            renderer[PROP_AUTO_CLEAR_COLOR] = Sk.ffi.remapToJs(valuePy);
          }
          break;
        case PROP_GAMMA_INPUT: {
            if (isBoolean(value)) {
              renderer[PROP_GAMMA_INPUT] = value;
            } else {
              throw new Sk.builtin.TypeError('\'' + PROP_GAMMA_INPUT + '\' attribute must be a <type \'bool\'>.');
            }
          }
          break;
        case PROP_GAMMA_OUTPUT: {
            if (isBoolean(value)) {
              renderer[PROP_GAMMA_OUTPUT] = value;
            } else {
              throw new Sk.builtin.TypeError('\'' + PROP_GAMMA_OUTPUT + '\' attribute must be a <type \'bool\'>.');
            }
          }
          break;
        case PROP_SORT_OBJECTS: {
            if (isBoolean(value)) {
              renderer[PROP_SORT_OBJECTS] = value;
            } else {
              throw new Sk.builtin.TypeError('\'' + PROP_SORT_OBJECTS + '\' attribute must be a <type \'bool\'>.');
            }
          }
          break;
        case 'size': {
            var width = Sk.builtin.asnum$(value[0]);
            var height = Sk.builtin.asnum$(value[1]);
            renderer.setSize(width, height);
          }
          break;
        default: {
            throw Sk.ffi.err.attribute(name).isNotSetableOnType(WEBGL_RENDERER);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (self) {
        var renderer = self.v;
        var args = {};
        args[PROP_AUTO_CLEAR] = renderer[PROP_AUTO_CLEAR];
        args[PROP_GAMMA_INPUT] = renderer[PROP_GAMMA_INPUT];
        args[PROP_GAMMA_OUTPUT] = renderer[PROP_GAMMA_OUTPUT];
        return Sk.ffi.stringToPy(WEBGL_RENDERER + '(' + JSON.stringify(args) + ')');
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (self) {
        var renderer = self.v;
        var autoClear = renderer[PROP_AUTO_CLEAR];
        var args = [{ 'autoClear': autoClear }];
        return Sk.ffi.stringToPy(WEBGL_RENDERER + '(' + args.map(function (x) {
          return JSON.stringify(x);
        }).join(', ') + ')');
      });
    }, WEBGL_RENDERER, []);
    mod[COLOR] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      var PROP_R = 'r';
      var PROP_G = 'g';
      var PROP_B = 'b';
      var PROP_VALUE = 'value';
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, valuePy) {
        var value = Sk.ffi.remapToJs(valuePy);
        if (Sk.ffi.isUndefined(valuePy)) {
          Sk.ffi.referenceToPy(new THREE.Color(), COLOR, undefined, selfPy);
        } else {
          if (Sk.ffi.isInt(valuePy) || Sk.ffi.isStr(valuePy)) {
            Sk.ffi.referenceToPy(new THREE.Color(value), COLOR, undefined, selfPy);
          } else if (Sk.ffi.isInstance(valuePy, COLOR)) {
            Sk.ffi.referenceToPy(value, COLOR, undefined, selfPy);
          } else {
            Sk.ffi.checkArgType(PROP_VALUE, [
              Sk.ffi.PyType.INT,
              Sk.ffi.PyType.STR,
              COLOR
            ], false, value);
          }
        }
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (colorPy, name) {
        var color = Sk.ffi.remapToJs(colorPy);
        switch (name) {
        case PROP_R: {
            return Sk.ffi.numberToIntPy(color[PROP_R]);
          }
        case PROP_G: {
            return Sk.ffi.numberToIntPy(color[PROP_G]);
          }
        case PROP_B: {
            return Sk.ffi.numberToIntPy(color[PROP_B]);
          }
        case METHOD_GET_HEX: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy) {
              return Sk.ffi.numberToIntPy(color[METHOD_GET_HEX]());
            });
          }
        case METHOD_GET_HEX_STRING: {
            return Sk.ffi.callableToPy(mod, METHOD_GET_HEX_STRING, function (methodPy) {
              return Sk.ffi.stringToPy(color[METHOD_GET_HEX_STRING]());
            });
          }
        case METHOD_SET_HEX: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy, hexPy) {
              Sk.ffi.checkMethodArgs(name, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_HEX, Sk.ffi.PyType.INT, Sk.ffi.isInt(hexPy), hexPy);
              color[METHOD_SET_HEX](Sk.ffi.remapToJs(hexPy));
              return colorPy;
            });
          }
        case METHOD_SET_RGB: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (self) {
                self.tp$name = METHOD_SET_RGB;
              });
              $loc.__call__ = Sk.ffi.functionPy(function (self, rPy, gPy, bPy) {
                var r = Sk.ffi.remapToJs(rPy);
                var g = Sk.ffi.remapToJs(gPy);
                var b = Sk.ffi.remapToJs(bPy);
                color[METHOD_SET_RGB](r, g, b);
                return colorPy;
              });
              $loc.__str__ = Sk.ffi.functionPy(function (self) {
                return Sk.ffi.stringToPy(METHOD_SET_RGB);
              });
              $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                return Sk.ffi.stringToPy(METHOD_SET_RGB);
              });
            }, METHOD_SET_RGB, []));
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(COLOR);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (colorPy, name, valuePy) {
        var color = Sk.ffi.remapToJs(colorPy);
        switch (name) {
        case PROP_R:
        case PROP_G:
        case PROP_B: {
            Sk.ffi.checkArgType(name, [
              Sk.ffi.PyType.FLOAT,
              Sk.ffi.PyType.INT
            ], Sk.ffi.isFloat(valuePy) || Sk.ffi.isInt(valuePy), valuePy);
            color[PROP_R] = Sk.ffi.remapToJs(valuePy);
          }
          break;
        default: {
            throw Sk.ffi.err.attribute(name).isNotSetableOnType(COLOR);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var color = Sk.ffi.remapToJs(selfPy);
        var args = {};
        args[PROP_R] = color[PROP_R];
        args[PROP_G] = color[PROP_G];
        args[PROP_B] = color[PROP_B];
        return Sk.ffi.stringToPy(COLOR + '(' + JSON.stringify(args) + ')');
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var color = Sk.ffi.remapToJs(selfPy);
        var r = color[PROP_R];
        var g = color[PROP_G];
        var b = color[PROP_B];
        var args = [
            r,
            g,
            b
          ];
        return Sk.ffi.stringToPy(COLOR + '(' + args.map(function (x) {
          return JSON.stringify(x);
        }).join(', ') + ')');
      });
    }, COLOR, []);
    function cameraGetAttr(cameraPy, name, className) {
      var camera = Sk.ffi.remapToJs(cameraPy);
      switch (name) {
      case PROP_ASPECT: {
          return Sk.ffi.numberToFloatPy(camera.aspect);
        }
      case PROP_POSITION: {
          return vectorToEuclidean3Py(camera[PROP_POSITION]);
        }
      case PROP_QUATERNION: {
          return Sk.ffi.callsim(mod[QUATERNION], Sk.ffi.referenceToPy(camera[PROP_QUATERNION], QUATERNION));
        }
      case PROP_ROTATION: {
          return vectorToEuclidean3Py(camera[PROP_ROTATION]);
        }
      case PROP_EULER_ORDER: {
          return Sk.ffi.stringToPy(camera[PROP_EULER_ORDER]);
        }
      case PROP_SCALE: {
          return vectorToEuclidean3Py(camera[PROP_SCALE]);
        }
      case PROP_UP: {
          return vectorToEuclidean3Py(camera[PROP_UP]);
        }
      case PROP_USE_QUATERNION: {
          return camera[PROP_USE_QUATERNION];
        }
      case METHOD_LOOK_AT: {
          return methodLookAt(cameraPy);
        }
      case UPDATE_PROJECTION_MATRIX: {
          return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = Sk.ffi.functionPy(function (self) {
              self.tp$name = UPDATE_PROJECTION_MATRIX;
            });
            $loc.__call__ = Sk.ffi.functionPy(function (self) {
              camera[name]();
            });
            $loc.__str__ = Sk.ffi.functionPy(function (self) {
              return Sk.ffi.stringToPy(UPDATE_PROJECTION_MATRIX);
            });
            $loc.__repr__ = Sk.ffi.functionPy(function (self) {
              return Sk.ffi.stringToPy(UPDATE_PROJECTION_MATRIX);
            });
          }, UPDATE_PROJECTION_MATRIX, []));
        }
      default: {
          throw Sk.ffi.err.attribute(name).isNotSetableOnType(className);
        }
      }
    }
    function cameraSetAttr(cameraPy, name, valuePy, className) {
      var camera = Sk.ffi.remapToJs(cameraPy);
      var value = Sk.ffi.remapToJs(valuePy);
      switch (name) {
      case PROP_POSITION:
      case PROP_ROTATION:
      case PROP_SCALE:
      case PROP_UP: {
          setVectorProperty(camera, name, valuePy);
        }
        break;
      case PROP_QUATERNION: {
          camera[PROP_QUATERNION] = value;
        }
        break;
      case PROP_EULER_ORDER: {
          if (isString(value)) {
            camera[PROP_EULER_ORDER] = value;
          } else {
            throw new Error(name + ' must be a string');
          }
        }
        break;
      case PROP_USE_QUATERNION: {
          camera[PROP_USE_QUATERNION] = value;
        }
        break;
      default: {
          throw Sk.ffi.err.attribute(name).isNotSetableOnType(className);
        }
      }
    }
    mod[PERSPECTIVE_CAMERA] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, fovPy, aspectPy, nearPy, farPy) {
        Sk.ffi.checkMethodArgs(PERSPECTIVE_CAMERA, arguments, 0, 4);
        if (Sk.ffi.isDefined(fovPy)) {
          Sk.ffi.checkArgType(ARG_FOV, Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(fovPy), fovPy);
        }
        if (Sk.ffi.isDefined(aspectPy)) {
          Sk.ffi.checkArgType(ARG_ASPECT, Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(aspectPy), aspectPy);
        }
        if (Sk.ffi.isDefined(nearPy)) {
          Sk.ffi.checkArgType(ARG_NEAR, Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(nearPy), nearPy);
        }
        if (Sk.ffi.isDefined(farPy)) {
          Sk.ffi.checkArgType(ARG_FAR, Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(farPy), farPy);
        }
        var fieldOfView = Sk.ffi.remapToJs(fovPy);
        var aspectRatio = Sk.ffi.remapToJs(aspectPy);
        var nearPlane = Sk.ffi.remapToJs(nearPy);
        var farPlane = Sk.ffi.remapToJs(farPy);
        Sk.ffi.referenceToPy(new THREE[PERSPECTIVE_CAMERA](fieldOfView, aspectRatio, nearPlane, farPlane), PERSPECTIVE_CAMERA, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (cameraPy, name) {
        var camera = Sk.ffi.remapToJs(cameraPy);
        switch (name) {
        case PROP_ASPECT: {
            return Sk.ffi.numberToFloatPy(camera.aspect);
          }
        case PROP_POSITION: {
            return vectorToEuclidean3Py(camera.position);
          }
        case PROP_QUATERNION: {
            return Sk.ffi.callsim(mod[QUATERNION], Sk.ffi.referenceToPy(camera[PROP_QUATERNION], QUATERNION));
          }
        case PROP_ROTATION: {
            return vectorToEuclidean3Py(camera[PROP_ROTATION]);
          }
        case PROP_EULER_ORDER: {
            return Sk.ffi.stringToPy(camera[PROP_EULER_ORDER]);
          }
        case PROP_SCALE: {
            return vectorToEuclidean3Py(camera[PROP_SCALE]);
          }
        case PROP_UP: {
            return vectorToEuclidean3Py(camera[PROP_UP]);
          }
        case PROP_USE_QUATERNION: {
            return camera[PROP_USE_QUATERNION];
          }
        case METHOD_LOOK_AT: {
            return methodLookAt(cameraPy);
          }
        case UPDATE_PROJECTION_MATRIX: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (self) {
                self.tp$name = UPDATE_PROJECTION_MATRIX;
              });
              $loc.__call__ = Sk.ffi.functionPy(function (self) {
                camera[name]();
              });
              $loc.__str__ = Sk.ffi.functionPy(function (self) {
                return Sk.ffi.stringToPy(UPDATE_PROJECTION_MATRIX);
              });
              $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                return Sk.ffi.stringToPy(UPDATE_PROJECTION_MATRIX);
              });
            }, UPDATE_PROJECTION_MATRIX, []));
          }
        default: {
            return cameraGetAttr(cameraPy, name, PERSPECTIVE_CAMERA);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (cameraPy, name, valuePy) {
        var camera = Sk.ffi.remapToJs(cameraPy);
        var value = Sk.ffi.remapToJs(valuePy);
        switch (name) {
        case 'aspect': {
            camera.aspect = value;
          }
          break;
        case PROP_POSITION:
        case PROP_ROTATION:
        case PROP_SCALE:
        case PROP_UP: {
            setVectorProperty(camera, name, valuePy);
          }
          break;
        case PROP_QUATERNION: {
            camera[PROP_QUATERNION] = value;
          }
          break;
        case PROP_EULER_ORDER: {
            if (isString(value)) {
              camera[PROP_EULER_ORDER] = value;
            } else {
              throw new Error(name + ' must be a string');
            }
          }
          break;
        case PROP_USE_QUATERNION: {
            camera[PROP_USE_QUATERNION] = value;
          }
          break;
        default: {
            return cameraSetAttr(cameraPy, name, valuePy, PERSPECTIVE_CAMERA);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var camera = Sk.ffi.remapToJs(selfPy);
        var args = {};
        args[PROP_FOV] = camera[PROP_FOV];
        args[PROP_ASPECT] = camera[PROP_ASPECT];
        args[PROP_NEAR] = camera[PROP_NEAR];
        args[PROP_FAR] = camera[PROP_FAR];
        return Sk.ffi.stringToPy(PERSPECTIVE_CAMERA + '(' + JSON.stringify(args) + ')');
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var camera = Sk.ffi.remapToJs(selfPy);
        var args = [
            camera[PROP_FOV],
            camera[PROP_ASPECT],
            camera[PROP_NEAR],
            camera[PROP_FAR]
          ];
        return Sk.ffi.stringToPy(PERSPECTIVE_CAMERA + '(' + args.map(function (x) {
          return JSON.stringify(x);
        }).join(', ') + ')');
      });
    }, PERSPECTIVE_CAMERA, []);
    mod[ORTHOGRAPHIC_CAMERA] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, leftPy, rightPy, topPy, bottomPy, nearPy, farPy) {
        Sk.ffi.checkMethodArgs(ORTHOGRAPHIC_CAMERA, arguments, 0, 6);
        if (Sk.ffi.isDefined(leftPy)) {
          Sk.ffi.checkArgType('left', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(leftPy), leftPy);
        }
        if (Sk.ffi.isDefined(rightPy)) {
          Sk.ffi.checkArgType('right', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(rightPy), rightPy);
        }
        if (Sk.ffi.isDefined(topPy)) {
          Sk.ffi.checkArgType('top', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(topPy), topPy);
        }
        if (Sk.ffi.isDefined(bottomPy)) {
          Sk.ffi.checkArgType('bottom', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(bottomPy), bottomPy);
        }
        if (Sk.ffi.isDefined(nearPy)) {
          Sk.ffi.checkArgType(ARG_NEAR, Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(nearPy), nearPy);
        }
        if (Sk.ffi.isDefined(farPy)) {
          Sk.ffi.checkArgType(ARG_FAR, Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(farPy), farPy);
        }
        var left = Sk.ffi.remapToJs(leftPy);
        var right = Sk.ffi.remapToJs(rightPy);
        var top = Sk.ffi.remapToJs(topPy);
        var bottom = Sk.ffi.remapToJs(bottomPy);
        var near = Sk.ffi.remapToJs(nearPy);
        var far = Sk.ffi.remapToJs(farPy);
        Sk.ffi.referenceToPy(new THREE[ORTHOGRAPHIC_CAMERA](left, right, top, bottom, near, far), ORTHOGRAPHIC_CAMERA, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (cameraPy, name) {
        var camera = Sk.ffi.remapToJs(cameraPy);
        var UPDATE_PROJECTION_MATRIX = 'updateProjectionMatrix';
        switch (name) {
        case 'aspect': {
            return Sk.ffi.numberToFloatPy(camera.aspect);
          }
        case PROP_POSITION: {
            return vectorToEuclidean3Py(camera[PROP_POSITION]);
          }
        case PROP_QUATERNION: {
            return Sk.ffi.callsim(mod[QUATERNION], Sk.ffi.referenceToPy(camera[PROP_QUATERNION], QUATERNION));
          }
        case PROP_ROTATION: {
            return vectorToEuclidean3Py(camera[PROP_ROTATION]);
          }
        case PROP_EULER_ORDER: {
            return Sk.ffi.stringToPy(camera[PROP_EULER_ORDER]);
          }
        case PROP_SCALE: {
            return vectorToEuclidean3Py(camera[PROP_SCALE]);
          }
        case PROP_UP: {
            return vectorToEuclidean3Py(camera[PROP_UP]);
          }
        case PROP_USE_QUATERNION: {
            return camera[PROP_USE_QUATERNION];
          }
        case METHOD_LOOK_AT: {
            return methodLookAt(cameraPy);
          }
        case UPDATE_PROJECTION_MATRIX: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (self) {
                self.tp$name = UPDATE_PROJECTION_MATRIX;
              });
              $loc.__call__ = Sk.ffi.functionPy(function (self) {
                camera[name]();
              });
              $loc.__str__ = Sk.ffi.functionPy(function (self) {
                return Sk.ffi.stringToPy(UPDATE_PROJECTION_MATRIX);
              });
              $loc.__repr__ = Sk.ffi.functionPy(function (self) {
                return Sk.ffi.stringToPy(UPDATE_PROJECTION_MATRIX);
              });
            }, UPDATE_PROJECTION_MATRIX, []));
          }
        default: {
            return cameraGetAttr(cameraPy, name, ORTHOGRAPHIC_CAMERA);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (cameraPy, name, valuePy) {
        var camera = Sk.ffi.remapToJs(cameraPy);
        var value = Sk.ffi.remapToJs(valuePy);
        switch (name) {
        case PROP_LEFT: {
            camera[PROP_LEFT] = value;
          }
          break;
        case PROP_RIGHT: {
            camera[PROP_RIGHT] = value;
          }
          break;
        case PROP_TOP: {
            camera[PROP_TOP] = value;
          }
          break;
        case PROP_BOTTOM: {
            camera[PROP_BOTTOM] = value;
          }
          break;
        case PROP_POSITION:
        case PROP_ROTATION:
        case PROP_SCALE:
        case PROP_UP: {
            setVectorProperty(camera, name, valuePy);
          }
          break;
        case PROP_QUATERNION: {
            camera[PROP_QUATERNION] = value;
          }
          break;
        case PROP_EULER_ORDER: {
            if (isString(value)) {
              camera[PROP_EULER_ORDER] = value;
            } else {
              throw new Error(name + ' must be a string');
            }
          }
          break;
        case PROP_USE_QUATERNION: {
            camera[PROP_USE_QUATERNION] = value;
          }
          break;
        default: {
            return cameraSetAttr(cameraPy, name, valuePy, ORTHOGRAPHIC_CAMERA);
          }
        }
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (cameraPy) {
        var camera = Sk.ffi.remapToJs(cameraPy);
        var args = [
            camera[PROP_LEFT],
            camera[PROP_RIGHT],
            camera[PROP_TOP],
            camera[PROP_BOTTOM],
            camera[PROP_NEAR],
            camera[PROP_FAR]
          ];
        return Sk.ffi.stringToPy(ORTHOGRAPHIC_CAMERA + '(' + args.map(function (x) {
          return JSON.stringify(x);
        }).join(', ') + ')');
      });
      $loc.__str__ = Sk.ffi.functionPy(function (self) {
        return Sk.ffi.stringToPy(ORTHOGRAPHIC_CAMERA);
      });
    }, ORTHOGRAPHIC_CAMERA, []);
    mod[Sk.three.ARROW_GEOMETRY] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, scalePy, attitudePy, segmentsPy, lengthPy, radiusShaft, radiusCone, lengthCone, axisPy) {
        Sk.ffi.checkMethodArgs(Sk.three.ARROW_GEOMETRY, arguments, 0, 8);
        var scale;
        var attitude;
        var length;
        var axis;
        if (Sk.ffi.isDefined(scalePy)) {
          if (Sk.ffi.isInstance(scalePy, Sk.three.ARROW_GEOMETRY)) {
            Sk.ffi.checkMethodArgs(Sk.three.ARROW_GEOMETRY, arguments, 1, 1);
            Sk.ffi.referenceToPy(Sk.ffi.remapToJs(scalePy), Sk.three.ARROW_GEOMETRY, undefined, selfPy);
            return;
          } else {
            Sk.ffi.checkArgType(PROP_SCALE, Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(scalePy), scalePy);
            scale = Sk.ffi.remapToJs(scalePy);
          }
        } else {
          scale = 1;
        }
        if (Sk.ffi.isDefined(attitudePy)) {
          Sk.ffi.checkArgType(PROP_ATTITUDE, EUCLIDEAN_3, Sk.ffi.isInstance(attitudePy, EUCLIDEAN_3), attitudePy);
          attitude = Sk.ffi.remapToJs(attitudePy).quaternion;
        } else {
          attitude = new THREE.Quaternion(0, 0, 0, 1);
        }
        if (Sk.ffi.isDefined(segmentsPy)) {
          Sk.ffi.checkArgType(PROP_SEGMENTS, INT, Sk.ffi.isInt(segmentsPy), segmentsPy);
        }
        if (Sk.ffi.isDefined(lengthPy)) {
          Sk.ffi.checkArgType(ARG_LENGTH, Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(lengthPy), lengthPy);
          length = Sk.ffi.remapToJs(lengthPy) * scale;
        } else {
          length = scale;
        }
        if (Sk.ffi.isDefined(axisPy)) {
          Sk.ffi.checkArgType(PROP_AXIS, EUCLIDEAN_3, Sk.ffi.isInstance(axisPy, EUCLIDEAN_3), axisPy);
          axis = Sk.ffi.remapToJs(axisPy).vector;
        } else {
          axis = new THREE.Vector3(0, 0, 1);
        }
        var segments = Sk.ffi.remapToJs(segmentsPy);
        radiusShaft = (Sk.ffi.remapToJs(radiusShaft) || 0.01) * scale;
        radiusCone = (Sk.ffi.remapToJs(radiusCone) || 0.08) * scale;
        lengthCone = (Sk.ffi.remapToJs(lengthCone) || 0.2) * scale;
        var lengthShaft = length - lengthCone;
        var halfLength = length / 2;
        var permutation = function (direction) {
          if (direction.x) {
            return 2;
          } else if (direction.y) {
            return 1;
          } else {
            return 0;
          }
        };
        var orientation = function (direction) {
          if (direction.x > 0) {
            return +1;
          } else if (direction.x < 0) {
            return -1;
          } else if (direction.y > 0) {
            return +1;
          } else if (direction.y < 0) {
            return -1;
          } else if (direction.z > 0) {
            return +1;
          } else if (direction.z < 0) {
            return -1;
          } else {
            return 0;
          }
        };
        var computeArrow = function (direction) {
          var cycle = permutation(direction);
          var sign = orientation(direction);
          var i = (cycle + 0) % 3;
          var j = (cycle + 1) % 3;
          var k = (cycle + 2) % 3;
          var shL = halfLength * sign;
          var data = [
              [
                0,
                0,
                halfLength * sign
              ],
              [
                radiusCone,
                0,
                (lengthShaft - halfLength) * sign
              ],
              [
                radiusShaft,
                0,
                (lengthShaft - halfLength) * sign
              ],
              [
                radiusShaft,
                0,
                -halfLength * sign
              ],
              [
                0,
                0,
                -halfLength * sign
              ]
            ];
          var points = data.map(function (point) {
              return new THREE.Vector3(point[i], point[j], point[k]);
            });
          var generator = new THREE.Quaternion(direction.x, direction.y, direction.z, 0);
          return {
            'points': points,
            'generator': generator
          };
        };
        var arrow = computeArrow(axis);
        Sk.ffi.referenceToPy(new Sk.stdlib.RevolutionGeometry(arrow.points, arrow.generator, segments, 0, 2 * Math.PI, attitude), Sk.three.ARROW_GEOMETRY, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        return geometryGetAttr(Sk.three.ARROW_GEOMETRY, selfPy, name);
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        return geometrySetAttr(Sk.three.ARROW_GEOMETRY, selfPy, name, valuePy);
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var names = [];
        var args = names.map(function (name) {
            return [
              name,
              Sk.ffi.remapToJs(Sk.ffh.str(Sk.ffi.gattr(selfPy, name)))
            ].join(EQUAL);
          });
        return Sk.ffi.stringToPy(Sk.three.ARROW_GEOMETRY + LPAREN + args.join(COMMA + SPACE) + RPAREN);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var args = [];
        return Sk.ffi.stringToPy(Sk.three.ARROW_GEOMETRY + '(' + args.map(function (x) {
          return JSON.stringify(x);
        }).join(', ') + ')');
      });
    }, Sk.three.ARROW_GEOMETRY, []);
    mod[CIRCLE_GEOMETRY] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, radiusPy, segmentsPy, thetaStartPy, thetaLengthPy) {
        Sk.ffi.checkMethodArgs(CIRCLE_GEOMETRY, arguments, 0, 4);
        if (Sk.ffi.isDefined(radiusPy)) {
          Sk.ffi.checkArgType(PROP_RADIUS, NUM, Sk.ffi.isNum(radiusPy), radiusPy);
        }
        if (Sk.ffi.isDefined(segmentsPy)) {
          Sk.ffi.checkArgType(PROP_SEGMENTS, INT, Sk.ffi.isInt(segmentsPy), segmentsPy);
        }
        if (Sk.ffi.isDefined(thetaStartPy)) {
          Sk.ffi.checkArgType(PROP_THETA_START, NUM, Sk.ffi.isNum(thetaStartPy), thetaStartPy);
        }
        if (Sk.ffi.isDefined(thetaLengthPy)) {
          Sk.ffi.checkArgType(PROP_THETA_LENGTH, NUM, Sk.ffi.isNum(thetaLengthPy), thetaLengthPy);
        }
        Sk.ffi.referenceToPy(new THREE[CIRCLE_GEOMETRY](Sk.ffi.remapToJs(radiusPy), Sk.ffi.remapToJs(segmentsPy), Sk.ffi.remapToJs(thetaStartPy), Sk.ffi.remapToJs(thetaLengthPy)), CIRCLE_GEOMETRY, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        return geometryGetAttr(CIRCLE_GEOMETRY, selfPy, name);
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        return geometrySetAttr(CIRCLE_GEOMETRY, selfPy, name, valuePy);
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var args = {};
        return Sk.ffi.stringToPy(CIRCLE_GEOMETRY + '(' + JSON.stringify(args) + ')');
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var args = [];
        return Sk.ffi.stringToPy(CIRCLE_GEOMETRY + '(' + args.map(function (x) {
          return JSON.stringify(x);
        }).join(', ') + ')');
      });
    }, CIRCLE_GEOMETRY, []);
    mod[CUBE_GEOMETRY] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, widthPy, heightPy, depthPy, widthSegmentsPy, heightSegmentsPy, depthSegmentsPy) {
        Sk.ffi.checkMethodArgs(CUBE_GEOMETRY, arguments, 3, 6);
        Sk.ffi.checkArgType(PROP_WIDTH, Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(widthPy), widthPy);
        Sk.ffi.checkArgType(PROP_HEIGHT, Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(heightPy), heightPy);
        Sk.ffi.checkArgType(PROP_DEPTH, Sk.ffi.PyType.FLOAT, Sk.ffi.isNum(depthPy), depthPy);
        if (Sk.ffi.isDefined(widthSegmentsPy)) {
          Sk.ffi.checkArgType(PROP_WIDTH_SEGMENTS, INT, Sk.ffi.isInt(widthSegmentsPy), widthSegmentsPy);
        }
        if (Sk.ffi.isDefined(heightSegmentsPy)) {
          Sk.ffi.checkArgType(PROP_HEIGHT_SEGMENTS, INT, Sk.ffi.isInt(heightSegmentsPy), heightSegmentsPy);
        }
        if (Sk.ffi.isDefined(depthSegmentsPy)) {
          Sk.ffi.checkArgType(PROP_DEPTH_SEGMENTS, INT, Sk.ffi.isInt(depthSegmentsPy), depthSegmentsPy);
        }
        var width = Sk.ffi.remapToJs(widthPy);
        var height = Sk.ffi.remapToJs(heightPy);
        var depth = Sk.ffi.remapToJs(depthPy);
        var widthSegments = Sk.ffi.remapToJs(widthSegmentsPy);
        var heightSegments = Sk.ffi.remapToJs(heightSegmentsPy);
        var depthSegments = Sk.ffi.remapToJs(depthSegmentsPy);
        Sk.ffi.referenceToPy(new THREE[CUBE_GEOMETRY](width, height, depth, widthSegments, heightSegments, depthSegments), CUBE_GEOMETRY, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var cube = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case PROP_WIDTH:
        case PROP_HEIGHT:
        case PROP_DEPTH: {
            return Sk.ffi.numberToFloatPy(cube[name]);
          }
        case PROP_WIDTH_SEGMENTS:
        case PROP_HEIGHT_SEGMENTS:
        case PROP_DEPTH_SEGMENTS: {
            return Sk.ffi.numberToIntPy(cube[name]);
          }
        default: {
            return geometryGetAttr(CUBE_GEOMETRY, selfPy, name);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        return geometrySetAttr(CUBE_GEOMETRY, selfPy, name, valuePy);
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var cube = Sk.ffi.remapToJs(selfPy);
        var args = {};
        args[PROP_WIDTH] = cube[PROP_WIDTH];
        args[PROP_HEIGHT] = cube[PROP_HEIGHT];
        args[PROP_DEPTH] = cube[PROP_DEPTH];
        return Sk.ffi.stringToPy(CUBE_GEOMETRY + '(' + JSON.stringify(args) + ')');
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var cube = Sk.ffi.remapToJs(selfPy);
        var width = cube[PROP_WIDTH];
        var height = cube[PROP_HEIGHT];
        var depth = cube[PROP_DEPTH];
        var widthSegments = cube[PROP_WIDTH_SEGMENTS];
        var heightSegments = cube[PROP_HEIGHT_SEGMENTS];
        var depthSegments = cube[PROP_DEPTH_SEGMENTS];
        var args = [
            width,
            height,
            depth,
            widthSegments,
            heightSegments,
            depthSegments
          ];
        return Sk.ffi.stringToPy(CUBE_GEOMETRY + '(' + args.map(function (x) {
          return JSON.stringify(x);
        }).join(', ') + ')');
      });
    }, CUBE_GEOMETRY, []);
    mod[CYLINDER_GEOMETRY] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, radiusTopPy, radiusBottomPy, heightPy, radialSegmentsPy, heightSegmentsPy, openEndedPy, axisPy) {
        if (Sk.ffi.isInstance(radiusTopPy, CYLINDER_GEOMETRY)) {
          Sk.ffi.referenceToPy(Sk.ffi.remapToJs(radiusTopPy), CYLINDER_GEOMETRY, undefined, selfPy);
        } else {
          Sk.ffi.checkMethodArgs(CYLINDER_GEOMETRY, arguments, 0, 7);
          Sk.ffi.checkArgType(PROP_RADIUS_TOP, NUM, Sk.ffi.isNum(radiusTopPy) || Sk.ffi.isUndefined(radiusTopPy), radiusTopPy);
          Sk.ffi.checkArgType(PROP_RADIUS_BOTTOM, NUM, Sk.ffi.isNum(radiusBottomPy) || Sk.ffi.isUndefined(radiusBottomPy), radiusBottomPy);
          Sk.ffi.checkArgType(PROP_HEIGHT, NUM, Sk.ffi.isNum(heightPy) || Sk.ffi.isUndefined(heightPy), heightPy);
          Sk.ffi.checkArgType(PROP_RADIAL_SEGMENTS, Sk.ffi.PyType.INT, Sk.ffi.isInt(radialSegmentsPy) || Sk.ffi.isUndefined(radialSegmentsPy), radialSegmentsPy);
          Sk.ffi.checkArgType(PROP_HEIGHT_SEGMENTS, Sk.ffi.PyType.INT, Sk.ffi.isInt(heightSegmentsPy) || Sk.ffi.isUndefined(heightSegmentsPy), heightSegmentsPy);
          Sk.ffi.checkArgType(PROP_OPEN_ENDED, Sk.ffi.PyType.BOOL, Sk.ffi.isBool(openEndedPy) || Sk.ffi.isUndefined(openEndedPy), openEndedPy);
          var radiusTop = Sk.ffi.remapToJs(radiusTopPy);
          var radiusBottom = Sk.ffi.remapToJs(radiusBottomPy);
          var height = Sk.ffi.remapToJs(heightPy);
          var radialSegments = Sk.ffi.remapToJs(radialSegmentsPy);
          var heightSegments = Sk.ffi.remapToJs(heightSegmentsPy);
          var openEnded = Sk.ffi.remapToJs(openEndedPy);
          var axis;
          if (Sk.ffi.isDefined(axisPy)) {
            Sk.ffi.checkArgType(PROP_AXIS, EUCLIDEAN_3, Sk.ffi.isInstance(axisPy, EUCLIDEAN_3), axisPy);
            axis = Sk.ffi.remapToJs(axisPy).vector;
          } else {
            axis = new THREE.Vector3(0, 0, 1);
          }
          Sk.ffi.referenceToPy(new Sk.stdlib.CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, axis), CYLINDER_GEOMETRY, undefined, selfPy);
        }
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var cylinder = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case PROP_RADIUS_TOP: {
            return Sk.ffi.numberToFloatPy(cylinder[PROP_RADIUS_TOP]);
          }
        case PROP_RADIUS_BOTTOM: {
            return Sk.ffi.numberToFloatPy(cylinder[PROP_RADIUS_BOTTOM]);
          }
        case PROP_HEIGHT: {
            return Sk.ffi.numberToFloatPy(cylinder[PROP_HEIGHT]);
          }
        case PROP_RADIAL_SEGMENTS: {
            return Sk.ffi.numberToIntPy(cylinder[PROP_RADIAL_SEGMENTS]);
          }
        case PROP_HEIGHT_SEGMENTS: {
            return Sk.ffi.numberToIntPy(cylinder[PROP_HEIGHT_SEGMENTS]);
          }
        case PROP_OPEN_ENDED: {
            return Sk.ffi.booleanToPy(cylinder[PROP_OPEN_ENDED]);
          }
        default: {
            return geometryGetAttr(CYLINDER_GEOMETRY, selfPy, name);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        return geometrySetAttr(CYLINDER_GEOMETRY, selfPy, name, valuePy);
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var cylinder = Sk.ffi.remapToJs(selfPy);
        var args = {};
        args[PROP_RADIUS_TOP] = cylinder[PROP_RADIUS_TOP];
        args[PROP_RADIUS_BOTTOM] = cylinder[PROP_RADIUS_BOTTOM];
        args[PROP_HEIGHT] = cylinder[PROP_HEIGHT];
        args[PROP_OPEN_ENDED] = cylinder[PROP_OPEN_ENDED];
        return Sk.ffi.stringToPy(CYLINDER_GEOMETRY + '(' + JSON.stringify(args) + ')');
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var cylinder = Sk.ffi.remapToJs(selfPy);
        var radiusTop = cylinder[PROP_RADIUS_TOP];
        var radiusBottom = cylinder[PROP_RADIUS_BOTTOM];
        var height = cylinder[PROP_HEIGHT];
        var radialSegments = cylinder[PROP_RADIAL_SEGMENTS];
        var heightSegments = cylinder[PROP_HEIGHT_SEGMENTS];
        var openEnded = cylinder[PROP_OPEN_ENDED];
        var args = [
            radiusTop,
            radiusBottom,
            height,
            radialSegments,
            heightSegments,
            openEnded
          ];
        return Sk.ffi.stringToPy(CYLINDER_GEOMETRY + '(' + args.map(function (x) {
          return JSON.stringify(x);
        }).join(', ') + ')');
      });
    }, CYLINDER_GEOMETRY, []);
    mod[LATHE_GEOMETRY] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, pointsPy, segmentsPy, phiStartPy, phiLengthPy) {
        Sk.ffi.checkMethodArgs(LATHE_GEOMETRY, arguments, 1, 4);
        var points = Sk.ffi.remapToJs(pointsPy).map(function (euclidean3) {
            return new THREE.Vector3(euclidean3.x, euclidean3.y, euclidean3.z);
          });
        var generator = new THREE.Quaternion(0, 0, 1, 0);
        Sk.ffi.referenceToPy(new Sk.stdlib.RevolutionGeometry(points, generator, Sk.ffi.remapToJs(segmentsPy), Sk.ffi.remapToJs(phiStartPy), Sk.ffi.remapToJs(phiLengthPy)), LATHE_GEOMETRY, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        return geometryGetAttr(LATHE_GEOMETRY, selfPy, name);
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        return geometrySetAttr(LATHE_GEOMETRY, selfPy, name, valuePy);
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var args = {};
        return Sk.ffi.stringToPy(LATHE_GEOMETRY + '(' + JSON.stringify(args) + ')');
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var args = [];
        return Sk.ffi.stringToPy(LATHE_GEOMETRY + '(' + args.map(function (x) {
          return JSON.stringify(x);
        }).join(', ') + ')');
      });
    }, LATHE_GEOMETRY, []);
    mod[ICOSAHEDRON_GEOMETRY] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, radiusPy, detailPy) {
        Sk.ffi.checkMethodArgs(ICOSAHEDRON_GEOMETRY, arguments, 0, 2);
        if (Sk.ffi.isDefined(radiusPy)) {
          Sk.ffi.checkArgType(PROP_RADIUS, NUM, Sk.ffi.isNum(radiusPy), radiusPy);
        }
        if (Sk.ffi.isDefined(detailPy)) {
          Sk.ffi.checkArgType(PROP_DETAIL, INT, Sk.ffi.isInt(detailPy), detailPy);
        }
        var radius = Sk.ffi.remapToJs(radiusPy);
        var detail = Sk.ffi.remapToJs(detailPy);
        Sk.ffi.referenceToPy(new THREE[ICOSAHEDRON_GEOMETRY](radius, detail), ICOSAHEDRON_GEOMETRY, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var self = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case PROP_RADIUS: {
            return Sk.ffi.numberToFloatPy(self[PROP_RADIUS]);
          }
        case PROP_DETAIL: {
            return Sk.ffi.numberToIntPy(self[PROP_DETAIL]);
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(ICOSAHEDRON_GEOMETRY);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        switch (name) {
        default: {
            throw Sk.ffi.err.attribute(name).isNotSetableOnType(ICOSAHEDRON_GEOMETRY);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var icosahedron = Sk.ffi.remapToJs(selfPy);
        var args = {};
        args[PROP_RADIUS] = icosahedron[PROP_RADIUS];
        args[PROP_DETAIL] = icosahedron[PROP_DETAIL];
        return Sk.ffi.stringToPy(ICOSAHEDRON_GEOMETRY + '(' + JSON.stringify(args) + ')');
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var icosahedron = Sk.ffi.remapToJs(selfPy);
        var radius = icosahedron[PROP_RADIUS];
        var detail = icosahedron[PROP_DETAIL];
        var args = [
            radius,
            detail
          ];
        return Sk.ffi.stringToPy(ICOSAHEDRON_GEOMETRY + '(' + args.map(function (x) {
          return JSON.stringify(x);
        }).join(', ') + ')');
      });
    }, ICOSAHEDRON_GEOMETRY, []);
    mod[OCTAHEDRON_GEOMETRY] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      var PROP_DETAIL = 'detail';
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, radiusPy, detailPy) {
        Sk.ffi.checkMethodArgs(OCTAHEDRON_GEOMETRY, arguments, 0, 2);
        if (Sk.ffi.isDefined(radiusPy)) {
          Sk.ffi.checkArgType(PROP_RADIUS, NUM, Sk.ffi.isNum(radiusPy), radiusPy);
        }
        if (Sk.ffi.isDefined(detailPy)) {
          Sk.ffi.checkArgType(PROP_DETAIL, INT, Sk.ffi.isInt(detailPy), detailPy);
        }
        var radius = Sk.ffi.remapToJs(radiusPy);
        var detail = Sk.ffi.remapToJs(detailPy);
        var octahedron = new THREE[OCTAHEDRON_GEOMETRY](radius, detail);
        octahedron.radius = radius;
        octahedron.detail = detail;
        Sk.ffi.referenceToPy(octahedron, OCTAHEDRON_GEOMETRY, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var self = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case PROP_RADIUS: {
            return Sk.ffi.numberToFloatPy(self[PROP_RADIUS]);
          }
        case PROP_DETAIL: {
            return Sk.ffi.numberToIntPy(self[PROP_DETAIL]);
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(OCTAHEDRON_GEOMETRY);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        switch (name) {
        default: {
            throw Sk.ffi.err.attribute(name).isNotSetableOnType(OCTAHEDRON_GEOMETRY);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var octahedron = Sk.ffi.remapToJs(selfPy);
        var args = {};
        args[PROP_RADIUS] = octahedron[PROP_RADIUS];
        args[PROP_DETAIL] = octahedron[PROP_DETAIL];
        return Sk.ffi.stringToPy(OCTAHEDRON_GEOMETRY + '(' + JSON.stringify(args) + ')');
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var octahedron = Sk.ffi.remapToJs(selfPy);
        var radius = octahedron[PROP_RADIUS];
        var detail = octahedron[PROP_DETAIL];
        var args = [
            radius,
            detail
          ];
        return Sk.ffi.stringToPy(OCTAHEDRON_GEOMETRY + '(' + args.map(function (x) {
          return JSON.stringify(x);
        }).join(', ') + ')');
      });
    }, OCTAHEDRON_GEOMETRY, []);
    mod[PLANE_GEOMETRY] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, widthPy, depthPy, widthSegmentsPy, heightSegmentsPy) {
        Sk.ffi.checkMethodArgs(PLANE_GEOMETRY, arguments, 2, 4);
        Sk.ffi.checkArgType(ARG_WIDTH, Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(widthPy), widthPy);
        Sk.ffi.checkArgType(ARG_DEPTH, Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(depthPy), depthPy);
        if (isDefined(widthSegmentsPy)) {
          Sk.ffi.checkArgType(PROP_WIDTH_SEGMENTS, Sk.ffi.PyType.INT, Sk.ffi.isInt(widthSegmentsPy), widthSegmentsPy);
        }
        if (isDefined(heightSegmentsPy)) {
          Sk.ffi.checkArgType(PROP_HEIGHT_SEGMENTS, Sk.ffi.PyType.INT, Sk.ffi.isInt(heightSegmentsPy), heightSegmentsPy);
        }
        var width = Sk.ffi.remapToJs(widthPy);
        var depth = Sk.ffi.remapToJs(depthPy);
        var widthSegments = Sk.ffi.remapToJs(widthSegmentsPy);
        var heightSegments = Sk.ffi.remapToJs(heightSegmentsPy);
        Sk.ffi.referenceToPy(new Sk.stdlib.PlaneGeometry(width, depth, widthSegments, heightSegments), PLANE_GEOMETRY, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        return geometryGetAttr(PLANE_GEOMETRY, selfPy, name);
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        return geometrySetAttr(PLANE_GEOMETRY, selfPy, name, valuePy);
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var names = [
            PROP_WIDTH,
            PROP_HEIGHT
          ];
        var args = names.map(function (name) {
            return [
              name,
              Sk.ffi.remapToJs(Sk.ffh.str(Sk.ffi.gattr(selfPy, name)))
            ].join(EQUAL);
          });
        return Sk.ffi.stringToPy(PLANE_GEOMETRY + LPAREN + args.join(COMMA + SPACE) + RPAREN);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var names = [
            PROP_WIDTH,
            PROP_HEIGHT
          ];
        var argsPy = names.map(function (name) {
            return Sk.ffi.gattr(selfPy, name);
          });
        var args = argsPy.map(function (valuePy) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(valuePy));
          });
        return Sk.ffi.stringToPy(PLANE_GEOMETRY + LPAREN + args.join(COMMA + SPACE) + RPAREN);
      });
    }, PLANE_GEOMETRY, []);
    mod[REVOLUTION_GEOMETRY] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, pointsPy, generatorPy, segmentsPy, phiStartPy, phiLengthPy, attitudePy) {
        Sk.ffi.checkMethodArgs(REVOLUTION_GEOMETRY, arguments, 2, 5);
        Sk.ffi.checkArgType(PROP_POINTS, Sk.ffi.PyType.LIST, Sk.ffi.isList(pointsPy), pointsPy);
        Sk.ffi.checkArgType(PROP_GENERATOR, EUCLIDEAN_3, Sk.ffi.isInstance(generatorPy, EUCLIDEAN_3), generatorPy);
        if (Sk.ffi.isDefined(segmentsPy)) {
          Sk.ffi.checkArgType(PROP_SEGMENTS, Sk.ffi.PyType.INT, Sk.ffi.isInt(segmentsPy), segmentsPy);
        }
        if (Sk.ffi.isDefined(phiStartPy)) {
          Sk.ffi.checkArgType(PROP_PHI_START, NUM, Sk.ffi.isNum(phiStartPy), phiStartPy);
        }
        if (Sk.ffi.isDefined(phiLengthPy)) {
          Sk.ffi.checkArgType(PROP_PHI_LENGTH, NUM, Sk.ffi.isNum(phiLengthPy), phiLengthPy);
        }
        if (Sk.ffi.isDefined(attitudePy)) {
          Sk.ffi.checkArgType(PROP_ATTITUDE, EUCLIDEAN_3, Sk.ffi.isInstance(attitudePy, EUCLIDEAN_3), attitudePy);
        }
        var points = Sk.ffi.remapToJs(pointsPy).map(function (euclidean3) {
            return new THREE.Vector3(euclidean3.x, euclidean3.y, euclidean3.z);
          });
        var attitude = Sk.ffi.remapToJs(attitudePy);
        var attitude = Sk.ffi.remapToJs(attitudePy) ? Sk.ffi.remapToJs(attitudePy).quaternion : undefined;
        Sk.ffi.referenceToPy(new Sk.stdlib.RevolutionGeometry(points, Sk.ffi.remapToJs(generatorPy).quaternion, Sk.ffi.remapToJs(segmentsPy), Sk.ffi.remapToJs(phiStartPy), Sk.ffi.remapToJs(phiLengthPy), attitude), REVOLUTION_GEOMETRY, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (geometryPy, name) {
        var geometry = Sk.ffi.remapToJs(geometryPy);
        switch (name) {
        default: {
            return geometryGetAttr(REVOLUTION_GEOMETRY, geometryPy, name);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (geometryPy, name, valuePy) {
        var geometry = Sk.ffi.remapToJs(geometryPy);
        var value = Sk.ffi.remapToJs(valuePy);
        switch (name) {
        default: {
            return geometrySetAttr(REVOLUTION_GEOMETRY, geometryPy, name, valuePy);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var args = {};
        return Sk.ffi.stringToPy(REVOLUTION_GEOMETRY + '(' + JSON.stringify(args) + ')');
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var args = [];
        return Sk.ffi.stringToPy(REVOLUTION_GEOMETRY + '(' + args.map(function (x) {
          return JSON.stringify(x);
        }).join(', ') + ')');
      });
    }, REVOLUTION_GEOMETRY, []);
    mod[SPHERE_GEOMETRY] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      var PROP_PHI_START = 'phiStart';
      var PROP_PHI_LENGTH = 'phiLength';
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, radiusPy, widthSegmentsPy, heightSegmentsPy, phiStart, phiLength, thetaStart, thetaLength) {
        if (Sk.ffi.isDefined(radiusPy)) {
          if (Sk.ffi.isInstance(radiusPy, SPHERE_GEOMETRY)) {
            Sk.ffi.checkMethodArgs(SPHERE_GEOMETRY, arguments, 1, 1);
            Sk.ffi.referenceToPy(Sk.ffi.remapToJs(radiusPy), SPHERE_GEOMETRY, undefined, selfPy);
            return;
          } else {
            Sk.ffi.checkArgType(PROP_RADIUS, Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(radiusPy), radiusPy);
          }
        }
        if (isDefined(widthSegmentsPy)) {
          Sk.ffi.checkArgType(PROP_WIDTH_SEGMENTS, Sk.ffi.PyType.INT, Sk.ffi.isInt(widthSegmentsPy), widthSegmentsPy);
        }
        if (isDefined(heightSegmentsPy)) {
          Sk.ffi.checkArgType(PROP_HEIGHT_SEGMENTS, Sk.ffi.PyType.INT, Sk.ffi.isInt(heightSegmentsPy), heightSegmentsPy);
        }
        var radius = Sk.ffi.remapToJs(radiusPy);
        var widthSegments = Sk.ffi.remapToJs(widthSegmentsPy);
        var heightSegments = Sk.ffi.remapToJs(heightSegmentsPy);
        phiStart = numberFromArg(phiStart, PROP_PHI_START, SPHERE_GEOMETRY);
        phiLength = numberFromArg(phiLength, PROP_PHI_LENGTH, SPHERE_GEOMETRY);
        thetaStart = numberFromArg(thetaStart, PROP_THETA_START, SPHERE_GEOMETRY);
        thetaLength = numberFromArg(thetaLength, PROP_THETA_LENGTH, SPHERE_GEOMETRY);
        Sk.ffi.referenceToPy(new THREE[SPHERE_GEOMETRY](radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength), SPHERE_GEOMETRY, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var geometry = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case PROP_RADIUS: {
            return Sk.ffi.numberToFloatPy(geometry[PROP_RADIUS]);
          }
        case PROP_WIDTH_SEGMENTS: {
            return Sk.ffi.numberToIntPy(geometry[PROP_WIDTH_SEGMENTS]);
          }
        case PROP_HEIGHT_SEGMENTS: {
            return Sk.ffi.numberToIntPy(geometry[PROP_HEIGHT_SEGMENTS]);
          }
        case PROP_PHI_START: {
            return Sk.ffi.numberToFloatPy(geometry[PROP_PHI_START]);
          }
        case PROP_PHI_LENGTH: {
            return Sk.ffi.numberToFloatPy(geometry[PROP_PHI_LENGTH]);
          }
        case PROP_THETA_START: {
            return Sk.ffi.numberToFloatPy(geometry[PROP_THETA_START]);
          }
        case PROP_THETA_LENGTH: {
            return Sk.ffi.numberToFloatPy(geometry[PROP_THETA_LENGTH]);
          }
        default: {
            return geometryGetAttr(SPHERE_GEOMETRY, selfPy, name);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        switch (name) {
        default: {
            return geometrySetAttr(SPHERE_GEOMETRY, selfPy, name, valuePy);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var names = [
            PROP_RADIUS,
            PROP_WIDTH_SEGMENTS,
            PROP_HEIGHT_SEGMENTS,
            PROP_PHI_START,
            PROP_PHI_LENGTH,
            PROP_THETA_START,
            PROP_THETA_LENGTH
          ];
        var args = names.map(function (name) {
            return [
              name,
              Sk.ffi.remapToJs(Sk.ffh.str(Sk.ffi.gattr(selfPy, name)))
            ].join(EQUAL);
          });
        return Sk.ffi.stringToPy(SPHERE_GEOMETRY + LPAREN + args.join(COMMA + SPACE) + RPAREN);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var sphere = Sk.ffi.remapToJs(selfPy);
        var radius = sphere[PROP_RADIUS];
        var widthSegments = sphere[PROP_WIDTH_SEGMENTS];
        var heightSegments = sphere[PROP_HEIGHT_SEGMENTS];
        var phiStart = sphere[PROP_PHI_START];
        var phiLength = sphere[PROP_PHI_LENGTH];
        var thetaStart = sphere[PROP_THETA_START];
        var thetaLength = sphere[PROP_THETA_LENGTH];
        var args = [
            radius,
            widthSegments,
            heightSegments,
            phiStart,
            phiLength,
            thetaStart,
            thetaLength
          ];
        return Sk.ffi.stringToPy(SPHERE_GEOMETRY + '(' + args.map(function (x) {
          return JSON.stringify(x);
        }).join(', ') + ')');
      });
    }, SPHERE_GEOMETRY, []);
    mod[TETRAHEDRON_GEOMETRY] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, radiusPy, detailPy) {
        Sk.ffi.checkMethodArgs(TETRAHEDRON_GEOMETRY, arguments, 2, 2);
        Sk.ffi.checkArgType(ARG_RADIUS, NUM, Sk.ffi.isNum(radiusPy), radiusPy);
        Sk.ffi.checkArgType(ARG_DETAIL, INT, Sk.ffi.isInt(detailPy), detailPy);
        var radius = Sk.ffi.remapToJs(radiusPy);
        var detail = Sk.ffi.remapToJs(detailPy);
        var tetra = new THREE[TETRAHEDRON_GEOMETRY](radius, detail);
        tetra.radius = radius;
        tetra.detail = detail;
        Sk.ffi.referenceToPy(tetra, TETRAHEDRON_GEOMETRY, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (tetraPy, name) {
        var tetra = Sk.ffi.remapToJs(tetraPy);
        switch (name) {
        case PROP_RADIUS: {
            return Sk.ffi.numberToFloatPy(tetra[PROP_RADIUS]);
          }
        case PROP_DETAIL: {
            return Sk.ffi.numberToIntPy(tetra[PROP_DETAIL]);
          }
        default: {
            return geometryGetAttr(TETRAHEDRON_GEOMETRY, tetraPy, name);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (tetraPy, name, valuePy) {
        return geometrySetAttr(TETRAHEDRON_GEOMETRY, tetraPy, name, valuePy);
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var tetrahedron = Sk.ffi.remapToJs(selfPy);
        var args = {};
        args[PROP_RADIUS] = tetrahedron[PROP_RADIUS];
        args[PROP_DETAIL] = tetrahedron[PROP_DETAIL];
        return Sk.ffi.stringToPy(TETRAHEDRON_GEOMETRY + '(' + JSON.stringify(args) + ')');
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var tetrahedron = Sk.ffi.remapToJs(selfPy);
        var radius = tetrahedron[PROP_RADIUS];
        var detail = tetrahedron[PROP_DETAIL];
        var args = [
            radius,
            detail
          ];
        return Sk.ffi.stringToPy(TETRAHEDRON_GEOMETRY + '(' + args.map(function (x) {
          return JSON.stringify(x);
        }).join(', ') + ')');
      });
    }, TETRAHEDRON_GEOMETRY, []);
    mod[TEXT_GEOMETRY] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (self, text, parameters) {
        text = Sk.ffi.remapToJs(text);
        parameters = Sk.ffi.remapToJs(parameters);
        self.v = new THREE[TEXT_GEOMETRY](text, parameters);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        return geometryGetAttr(TEXT_GEOMETRY, selfPy, name);
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        return geometrySetAttr(TEXT_GEOMETRY, selfPy, name, valuePy);
      });
      $loc.__str__ = Sk.ffi.functionPy(function (self) {
        var text = Sk.ffi.remapToJs(self);
        var args = {};
        return Sk.ffi.stringToPy(TEXT_GEOMETRY + '(' + JSON.stringify(args) + ')');
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (self) {
        var text = Sk.ffi.remapToJs(self);
        var args = [];
        return Sk.ffi.stringToPy(TEXT_GEOMETRY + '(' + args.map(function (x) {
          return JSON.stringify(x);
        }).join(', ') + ')');
      });
    }, TEXT_GEOMETRY, []);
    mod[TORUS_GEOMETRY] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      var PROP_TUBE = 'tube';
      var PROP_RADIAL_SEGMENTS = 'radialSegments';
      var PROP_TUBULAR_SEGMENTS = 'tubularSegments';
      var PROP_ARC = 'arc';
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, radiusPy, tubePy, radialSegmentsPy, tubularSegmentsPy, arcPy) {
        Sk.ffi.checkMethodArgs(TORUS_GEOMETRY, arguments, 0, 5);
        if (Sk.ffi.isDefined(radiusPy)) {
          Sk.ffi.checkArgType(ARG_RADIUS, NUM, Sk.ffi.isNum(radiusPy), radiusPy);
        }
        if (Sk.ffi.isDefined(tubePy)) {
          Sk.ffi.checkArgType(PROP_TUBE, NUM, Sk.ffi.isNum(tubePy), tubePy);
        }
        if (Sk.ffi.isDefined(radialSegmentsPy)) {
          Sk.ffi.checkArgType(PROP_RADIAL_SEGMENTS, INT, Sk.ffi.isInt(radialSegmentsPy), radialSegmentsPy);
        }
        if (Sk.ffi.isDefined(tubularSegmentsPy)) {
          Sk.ffi.checkArgType(PROP_TUBULAR_SEGMENTS, INT, Sk.ffi.isInt(tubularSegmentsPy), tubularSegmentsPy);
        }
        if (Sk.ffi.isDefined(arcPy)) {
          Sk.ffi.checkArgType(PROP_ARC, NUM, Sk.ffi.isNum(arcPy), arcPy);
        }
        var radius = Sk.ffi.remapToJs(radiusPy);
        var tube = Sk.ffi.remapToJs(tubePy);
        var radialSegments = Sk.ffi.remapToJs(radialSegmentsPy);
        var tubularSegments = Sk.ffi.remapToJs(tubularSegmentsPy);
        var arc = Sk.ffi.remapToJs(arcPy);
        var torus = new Sk.stdlib.TorusGeometry(radius, tube, radialSegments, tubularSegments, arc);
        Sk.ffi.referenceToPy(torus, TORUS_GEOMETRY, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (torusPy, name) {
        var torus = Sk.ffi.remapToJs(torusPy);
        switch (name) {
        case PROP_RADIUS: {
            return Sk.ffi.numberToFloatPy(torus[PROP_RADIUS]);
          }
        case PROP_TUBE: {
            return Sk.ffi.numberToFloatPy(torus[PROP_TUBE]);
          }
        case PROP_RADIAL_SEGMENTS: {
            return Sk.ffi.numberToIntPy(torus[PROP_RADIAL_SEGMENTS]);
          }
        case PROP_TUBULAR_SEGMENTS: {
            return Sk.ffi.numberToIntPy(torus[PROP_TUBULAR_SEGMENTS]);
          }
        case PROP_ARC: {
            return Sk.ffi.numberToFloatPy(torus[PROP_ARC]);
          }
        default: {
            return geometryGetAttr(TORUS_GEOMETRY, torusPy, name);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (torusPy, name, valuePy) {
        return geometrySetAttr(TORUS_GEOMETRY, torusPy, name, valuePy);
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var names = [
            PROP_RADIUS,
            PROP_TUBE,
            PROP_RADIAL_SEGMENTS,
            PROP_TUBULAR_SEGMENTS,
            PROP_ARC
          ];
        var args = names.map(function (name) {
            return [
              name,
              Sk.ffi.remapToJs(Sk.ffh.str(Sk.ffi.gattr(selfPy, name)))
            ].join(EQUAL);
          });
        return Sk.ffi.stringToPy(TORUS_GEOMETRY + LPAREN + args.join(COMMA + SPACE) + RPAREN);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var names = [
            PROP_RADIUS,
            PROP_TUBE,
            PROP_RADIAL_SEGMENTS,
            PROP_TUBULAR_SEGMENTS,
            PROP_ARC
          ];
        var argsPy = names.map(function (name) {
            return Sk.ffi.gattr(selfPy, name);
          });
        var args = argsPy.map(function (valuePy) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(valuePy));
          });
        return Sk.ffi.stringToPy(TORUS_GEOMETRY + LPAREN + args.join(COMMA + SPACE) + RPAREN);
      });
    }, TORUS_GEOMETRY, []);
    mod[Sk.three.VORTEX_GEOMETRY] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, radiusPy, radiusConePy, radiusShaftPy, lengthConePy, lengthShaftPy, arrowSegmentsPy, radialSegmentsPy) {
        Sk.ffi.checkMethodArgs(Sk.three.VORTEX_GEOMETRY, arguments, 7, 7);
        Sk.ffi.checkArgType(ARG_RADIUS, Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(radiusPy), radiusPy);
        Sk.ffi.checkArgType(ARG_RADIUS_CONE, NUM, Sk.ffi.isNum(radiusConePy), radiusConePy);
        Sk.ffi.checkArgType(ARG_RADIUS_SHAFT, NUM, Sk.ffi.isNum(radiusShaftPy), radiusShaftPy);
        var radius = Sk.ffi.remapToJs(radiusPy);
        var radiusCone = Sk.ffi.remapToJs(radiusConePy);
        var radiusShaft = Sk.ffi.remapToJs(radiusShaftPy);
        var lengthCone = Sk.ffi.remapToJs(lengthConePy);
        var lengthShaft = Sk.ffi.remapToJs(lengthShaftPy);
        if (isDefined(arrowSegmentsPy)) {
          Sk.ffi.checkArgType(PROP_WIDTH_SEGMENTS, Sk.ffi.PyType.INT, Sk.ffi.isInt(arrowSegmentsPy), arrowSegmentsPy);
        }
        if (isDefined(radialSegmentsPy)) {
          Sk.ffi.checkArgType(PROP_HEIGHT_SEGMENTS, Sk.ffi.PyType.INT, Sk.ffi.isInt(radialSegmentsPy), radialSegmentsPy);
        }
        var arrowSegments = Sk.ffi.remapToJs(arrowSegmentsPy);
        var radialSegments = Sk.ffi.remapToJs(radialSegmentsPy);
        var vortex = new Sk.stdlib.VortexGeometry(radius, radiusCone, radiusShaft, lengthCone, lengthShaft, arrowSegments, radialSegments);
        Sk.ffi.referenceToPy(vortex, Sk.three.VORTEX_GEOMETRY, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (vortexPy, name) {
        var vortex = Sk.ffi.remapToJs(vortexPy);
        switch (name) {
        case PROP_RADIUS: {
            return Sk.ffi.numberToFloatPy(vortex[PROP_RADIUS]);
          }
        case PROP_RADIUS_CONE: {
            return Sk.ffi.numberToFloatPy(vortex[PROP_RADIUS_CONE]);
          }
        case PROP_RADIUS_SHAFT: {
            return Sk.ffi.numberToFloatPy(vortex[PROP_RADIUS_SHAFT]);
          }
        case PROP_WIDTH_SEGMENTS: {
            return Sk.ffi.numberToIntPy(vortex[PROP_WIDTH_SEGMENTS]);
          }
        case PROP_DEPTH_SEGMENTS:
        case PROP_HEIGHT_SEGMENTS: {
            return Sk.ffi.numberToIntPy(vortex[PROP_HEIGHT_SEGMENTS]);
          }
        default: {
            return geometryGetAttr(Sk.three.VORTEX_GEOMETRY, vortexPy, name);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (vortexPy, name, valuePy) {
        return geometrySetAttr(Sk.three.VORTEX_GEOMETRY, vortexPy, name, valuePy);
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var names = [
            PROP_RADIUS,
            PROP_RADIUS_CONE,
            PROP_RADIUS_SHAFT
          ];
        var args = names.map(function (name) {
            return [
              name,
              Sk.ffi.remapToJs(Sk.ffh.str(Sk.ffi.gattr(selfPy, name)))
            ].join(EQUAL);
          });
        return Sk.ffi.stringToPy(Sk.three.VORTEX_GEOMETRY + LPAREN + args.join(COMMA + SPACE) + RPAREN);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var names = [
            PROP_RADIUS,
            PROP_RADIUS_CONE,
            PROP_RADIUS_SHAFT
          ];
        var argsPy = names.map(function (name) {
            return Sk.ffi.gattr(selfPy, name);
          });
        var args = argsPy.map(function (valuePy) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(valuePy));
          });
        return Sk.ffi.stringToPy(Sk.three.VORTEX_GEOMETRY + LPAREN + args.join(COMMA + SPACE) + RPAREN);
      });
    }, Sk.three.VORTEX_GEOMETRY, []);
    function geometryGetAttr(className, geometryPy, name) {
      var geometry = Sk.ffi.remapToJs(geometryPy);
      switch (name) {
      case PROP_ID: {
          return Sk.ffi.numberToIntPy(geometry.id);
        }
      case PROP_NAME: {
          return Sk.ffi.stringToPy(geometry.name);
        }
      case PROP_UUID: {
          return Sk.ffi.stringToPy(geometry.uuid);
        }
      case PROP_FACES: {
          return mutableFaceListPy(geometry.faces);
        }
      case PROP_COLORS: {
          return mutableColorListPy(geometry.colors);
        }
      case PROP_VERTICES: {
          return mutableVertexListPy(geometry.vertices);
        }
      case PROP_RADIUS: {
          return Sk.ffi.numberToFloatPy(geometry.radius);
        }
      case PROP_WIDTH: {
          return Sk.ffi.numberToFloatPy(geometry.width);
        }
      case PROP_DEPTH:
      case PROP_HEIGHT: {
          return Sk.ffi.numberToFloatPy(geometry.height);
        }
      case METHOD_APPLY_MATRIX: {
          return Sk.ffi.callableToPy(mod, name, function (methodPy, matrixPy) {
            Sk.ffi.checkMethodArgs(name, arguments, 1, 1);
            Sk.ffi.checkArgType('matrix', Sk.three.MATRIX_4, Sk.ffi.isInstance(matrixPy, Sk.three.MATRIX_4), matrixPy);
            geometry.applyMatrix(Sk.ffi.remapToJs(matrixPy));
          });
        }
      case METHOD_COMPUTE_CENTROIDS: {
          return Sk.ffi.callableToPy(mod, name, function (methodPy) {
            Sk.ffi.checkMethodArgs(name, arguments, 0, 0);
            geometry.computeCentroids();
          });
        }
      case METHOD_COMPUTE_FACE_NORMALS: {
          return Sk.ffi.callableToPy(mod, name, function (methodPy) {
            Sk.ffi.checkMethodArgs(name, arguments, 0, 0);
            geometry.computeFaceNormals();
          });
        }
      default: {
          throw Sk.ffi.err.attribute(name).isNotGetableOnType(className);
        }
      }
    }
    function geometrySetAttr(className, geometryPy, name, valuePy) {
      var g = Sk.ffi.remapToJs(geometryPy);
      var geometry = g;
      switch (name) {
      case PROP_NAME: {
          Sk.ffi.checkArgType(PROP_NAME, Sk.ffi.PyType.STR, Sk.ffi.isStr(valuePy), valuePy);
          geometry.name = Sk.ffi.remapToJs(valuePy);
        }
        break;
      default: {
          throw Sk.ffi.err.attribute(name).isNotSetableOnType(className);
        }
      }
    }
    mod[GEOMETRY] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, geometryPy) {
        if (isDefined(geometryPy)) {
          Sk.ffi.referenceToPy(Sk.ffi.remapToJs(geometryPy), GEOMETRY, undefined, selfPy);
        } else {
          Sk.ffi.referenceToPy(new THREE.Geometry(), GEOMETRY, undefined, selfPy);
        }
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        return geometryGetAttr(GEOMETRY, selfPy, name);
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        return geometrySetAttr(GEOMETRY, selfPy, name, valuePy);
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var geometry = Sk.ffi.remapToJs(selfPy);
        var args = {};
        return Sk.ffi.stringToPy(GEOMETRY + '(' + JSON.stringify(args) + ')');
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var geometry = Sk.ffi.remapToJs(selfPy);
        var args = [];
        return Sk.ffi.stringToPy(GEOMETRY + '(' + args.map(function (x) {
          return JSON.stringify(x);
        }).join(', ') + ')');
      });
    }, GEOMETRY, []);
    Sk.three.object3DGetAttr = function (className, selfPy, name) {
      var self = Sk.ffi.remapToJs(selfPy);
      switch (name) {
      case PROP_ID: {
          return Sk.ffi.numberToIntPy(self[name]);
        }
      case PROP_NAME:
      case PROP_UUID:
      case PROP_EULER_ORDER: {
          return Sk.ffi.stringToPy(self[name]);
        }
      case PROP_ATTITUDE: {
          return quaternionToEuclidean3Py(self[PROP_QUATERNION]);
        }
      case PROP_POSITION:
      case PROP_ROTATION:
      case PROP_SCALE:
      case PROP_UP: {
          return vectorToEuclidean3Py(self[name]);
        }
      case PROP_MATRIX_WORLD: {
          return Sk.ffi.callsim(mod[Sk.three.MATRIX_4], Sk.ffi.referenceToPy(self[name], Sk.three.MATRIX_4));
        }
      case PROP_QUATERNION: {
          return Sk.ffi.callsim(mod[QUATERNION], Sk.ffi.referenceToPy(self[PROP_QUATERNION], QUATERNION));
        }
      case PROP_USE_QUATERNION:
      case PROP_VISIBLE: {
          return Sk.ffi.booleanToPy(self[name]);
        }
      case PROP_CHARGE:
      case PROP_MASS:
      case PROP_MOMENTUM:
      case PROP_VELOCITY: {
          var valuePy = self[name];
          if (isEuclidean3Py(valuePy)) {
            return valuePy;
          } else {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(className);
          }
        }
      case PROP_GEOMETRY: {
          return Sk.ffi.callsim(mod[GEOMETRY], Sk.ffi.referenceToPy(self[PROP_GEOMETRY], GEOMETRY));
        }
      case PROP_MATERIAL: {
          return Sk.ffi.callsim(mod[Sk.three.MATERIAL], Sk.ffi.referenceToPy(self[PROP_MATERIAL], Sk.three.MATERIAL));
        }
      case METHOD_ADD: {
          return methodAdd(self);
        }
      case METHOD_REMOVE: {
          return methodRemove(self);
        }
      case METHOD_TRAVERSE: {
          return Sk.ffi.callableToPy(mod, name, function (methodPy, callbackPy) {
            Sk.ffi.checkMethodArgs(name, arguments, 1, 1);
            Sk.ffi.checkArgType(ARG_CALLBACK, Sk.ffi.PyType.FUNCTION, Sk.ffi.isFunction(callbackPy), callbackPy);
            var callbackJs = function (objJs) {
              var objPy = Sk.ffi.callsim(mod[Sk.three.OBJECT_3D], Sk.ffi.referenceToPy(objJs, Sk.three.OBJECT_3D));
              return Sk.ffi.remapToJs(Sk.ffi.callsim(callbackPy, objPy));
            };
            self[name](callbackJs);
            return selfPy;
          });
        }
      default: {
          throw Sk.ffi.err.attribute(name).isNotGetableOnType(className);
        }
      }
    };
    Sk.three.object3DSetAttr = function (className, selfPy, name, valuePy) {
      var self = Sk.ffi.remapToJs(selfPy);
      switch (name) {
      case PROP_ATTITUDE: {
          setQuaternionProperty(className, selfPy, PROP_QUATERNION, valuePy, name);
        }
        break;
      case PROP_POSITION:
      case PROP_ROTATION:
      case PROP_SCALE:
      case PROP_UP: {
          setVectorProperty(self, name, valuePy);
        }
        break;
      case PROP_QUATERNION: {
          Sk.ffi.checkArgType(name, QUATERNION, Sk.ffi.isInstance(valuePy, QUATERNION), valuePy);
          self[name] = Sk.ffi.remapToJs(valuePy);
        }
        break;
      case PROP_EULER_ORDER: {
          Sk.ffi.checkArgType(name, Sk.ffi.PyType.STR, Sk.ffi.isStr(valuePy), valuePy);
          self[name] = Sk.ffi.remapToJs(valuePy);
        }
        break;
      case PROP_USE_QUATERNION:
      case PROP_VISIBLE: {
          Sk.ffi.checkArgType(name, Sk.ffi.PyType.BOOL, Sk.ffi.isBool(valuePy), valuePy);
          self[name] = Sk.ffi.remapToJs(valuePy);
        }
        break;
      case PROP_CHARGE:
      case PROP_MASS:
      case PROP_MOMENTUM:
      case PROP_VELOCITY: {
          Sk.ffi.checkArgType(name, EUCLIDEAN_3, isEuclidean3Py(valuePy), valuePy);
          self[name] = valuePy;
        }
        break;
      default: {
          throw Sk.ffi.err.attribute(name).isNotSetableOnType(className);
        }
      }
    };
    mod[Sk.three.OBJECT_3D] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, objectPy) {
        var objectJs = isDefined(objectPy) ? Sk.ffi.remapToJs(objectPy) : new THREE[Sk.three.OBJECT_3D]();
        Sk.ffi.referenceToPy(objectJs, Sk.three.OBJECT_3D, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        return Sk.three.object3DGetAttr(Sk.three.OBJECT_3D, selfPy, name);
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        return Sk.three.object3DSetAttr(Sk.three.OBJECT_3D, selfPy, name, valuePy);
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var args = {};
        return Sk.ffi.stringToPy(Sk.three.OBJECT_3D + LPAREN + JSON.stringify(args) + RPAREN);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var args = [];
        return Sk.ffi.stringToPy(Sk.three.OBJECT_3D + LPAREN + args.map(function (x) {
          return JSON.stringify(x);
        }).join(', ') + RPAREN);
      });
    }, Sk.three.OBJECT_3D, []);
    function lightGetAttr(className, selfPy, name) {
      var light = Sk.ffi.remapToJs(selfPy);
      switch (name) {
      case PROP_COLOR: {
          return Sk.ffi.callsim(mod[COLOR], Sk.ffi.referenceToPy(light[PROP_COLOR], COLOR));
        }
      default: {
          return Sk.three.object3DGetAttr(className, selfPy, name);
        }
      }
    }
    function lightSetAttr(className, selfPy, name, valuePy) {
      var light = Sk.ffi.remapToJs(selfPy);
      var value = Sk.ffi.remapToJs(valuePy);
      switch (name) {
      case PROP_COLOR: {
          light[PROP_COLOR] = new THREE.Color(value);
        }
        break;
      default: {
          return Sk.three.object3DSetAttr(className, selfPy, name, valuePy);
        }
      }
    }
    mod[AMBIENT_LIGHT] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, colorPy) {
        var color = Sk.ffi.remapToJs(colorPy);
        Sk.ffi.referenceToPy(new THREE[AMBIENT_LIGHT](color), AMBIENT_LIGHT, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        return lightGetAttr(AMBIENT_LIGHT, selfPy, name);
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        return lightSetAttr(AMBIENT_LIGHT, selfPy, name, valuePy);
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var light = Sk.ffi.remapToJs(selfPy);
        var args = {};
        args[PROP_COLOR] = light[PROP_COLOR];
        return Sk.ffi.stringToPy(AMBIENT_LIGHT + '(' + JSON.stringify(args) + ')');
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var light = Sk.ffi.remapToJs(selfPy);
        var args = [light[PROP_COLOR]];
        return Sk.ffi.stringToPy(AMBIENT_LIGHT + '(' + args.map(function (x) {
          return JSON.stringify(x);
        }).join(', ') + ')');
      });
    }, AMBIENT_LIGHT, []);
    mod[DIRECTIONAL_LIGHT] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, colorPy, intensityPy) {
        Sk.ffi.checkMethodArgs(DIRECTIONAL_LIGHT, arguments, 1, 2);
        Sk.ffi.checkArgType(PROP_INTENSITY, NUM, Sk.ffi.isNum(intensityPy) || Sk.ffi.isUndefined(intensityPy), intensityPy);
        var color = Sk.ffi.remapToJs(colorPy);
        var intensity = Sk.ffi.remapToJs(intensityPy);
        Sk.ffi.referenceToPy(new THREE[DIRECTIONAL_LIGHT](color, intensity), DIRECTIONAL_LIGHT, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var light = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case PROP_INTENSITY: {
            return Sk.ffi.numberToFloatPy(light[PROP_INTENSITY]);
          }
        default: {
            return lightGetAttr(DIRECTIONAL_LIGHT, selfPy, name);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        var light = Sk.ffi.remapToJs(selfPy);
        var value = Sk.ffi.remapToJs(valuePy);
        switch (name) {
        case PROP_INTENSITY: {
            Sk.ffi.checkArgType(PROP_INTENSITY, NUM, Sk.ffi.isNum(valuePy), valuePy);
            light[PROP_INTENSITY] = value;
          }
          break;
        default: {
            return lightSetAttr(DIRECTIONAL_LIGHT, selfPy, name, valuePy);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var light = Sk.ffi.remapToJs(selfPy);
        var args = {};
        args[PROP_COLOR] = light[PROP_COLOR];
        args[PROP_INTENSITY] = light[PROP_INTENSITY];
        args[PROP_DISTANCE] = light[PROP_DISTANCE];
        return Sk.ffi.stringToPy(DIRECTIONAL_LIGHT + '(' + JSON.stringify(args) + ')');
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var light = Sk.ffi.remapToJs(selfPy);
        var args = [
            light[PROP_COLOR],
            light[PROP_INTENSITY],
            light[PROP_DISTANCE]
          ];
        return Sk.ffi.stringToPy(DIRECTIONAL_LIGHT + '(' + args.map(function (x) {
          return JSON.stringify(x);
        }).join(', ') + ')');
      });
    }, DIRECTIONAL_LIGHT, []);
    mod[POINT_LIGHT] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, colorPy, intensityPy, distancePy) {
        Sk.ffi.checkMethodArgs(POINT_LIGHT, arguments, 1, 3);
        Sk.ffi.checkArgType(ARG_COLOR, [
          COLOR,
          Sk.ffi.PyType.INT
        ], isColorPy(colorPy) || Sk.ffi.isInt(colorPy), colorPy);
        Sk.ffi.checkArgType(PROP_INTENSITY, NUM, Sk.ffi.isNum(intensityPy) || Sk.ffi.isUndefined(intensityPy), intensityPy);
        Sk.ffi.checkArgType(PROP_DISTANCE, NUM, Sk.ffi.isNum(distancePy) || Sk.ffi.isUndefined(distancePy), distancePy);
        var color = Sk.ffi.remapToJs(colorPy);
        var intensity = Sk.ffi.remapToJs(intensityPy);
        var distance = Sk.ffi.remapToJs(distancePy);
        Sk.ffi.referenceToPy(new THREE[POINT_LIGHT](color, intensity, distance), POINT_LIGHT, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        switch (name) {
        case PROP_DISTANCE: {
            return Sk.ffi.numberToFloatPy(Sk.ffi.remapToJs(selfPy)[PROP_DISTANCE]);
          }
        case PROP_INTENSITY: {
            return Sk.ffi.numberToFloatPy(Sk.ffi.remapToJs(selfPy)[PROP_INTENSITY]);
          }
        default: {
            return lightGetAttr(POINT_LIGHT, selfPy, name);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        switch (name) {
        case PROP_DISTANCE: {
            Sk.ffi.checkArgType(PROP_DISTANCE, NUM, Sk.ffi.isNum(valuePy), valuePy);
            Sk.ffi.remapToJs(selfPy)[PROP_DISTANCE] = Sk.ffi.remapToJs(valuePy);
          }
          break;
        case PROP_INTENSITY: {
            Sk.ffi.checkArgType(PROP_INTENSITY, NUM, Sk.ffi.isNum(valuePy), valuePy);
            Sk.ffi.remapToJs(selfPy)[PROP_INTENSITY] = Sk.ffi.remapToJs(valuePy);
          }
          break;
        default: {
            return lightSetAttr(POINT_LIGHT, selfPy, name, valuePy);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var light = Sk.ffi.remapToJs(selfPy);
        var args = {};
        args[PROP_COLOR] = light[PROP_COLOR];
        args[PROP_INTENSITY] = light[PROP_INTENSITY];
        args[PROP_DISTANCE] = light[PROP_DISTANCE];
        return Sk.ffi.stringToPy(POINT_LIGHT + '(' + JSON.stringify(args) + ')');
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var light = Sk.ffi.remapToJs(selfPy);
        var args = [
            light[PROP_COLOR],
            light[PROP_INTENSITY],
            light[PROP_DISTANCE]
          ];
        return Sk.ffi.stringToPy(POINT_LIGHT + '(' + args.map(function (x) {
          return JSON.stringify(x);
        }).join(', ') + ')');
      });
    }, POINT_LIGHT, []);
    mod[LINE] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (self, geometryPy, materialPy, typePy) {
        var geometry = Sk.ffi.remapToJs(geometryPy);
        var material = Sk.ffi.remapToJs(materialPy);
        var type = Sk.ffi.remapToJs(typePy);
        self.v = new THREE[LINE](geometry, material, type);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (linePy, name) {
        var line = Sk.ffi.remapToJs(linePy);
        switch (name) {
        case PROP_POSITION: {
            return vectorToEuclidean3Py(line[PROP_POSITION]);
          }
        case PROP_QUATERNION: {
            return Sk.ffi.callsim(mod[QUATERNION], Sk.ffi.referenceToPy(line[PROP_QUATERNION], QUATERNION));
          }
        case PROP_ROTATION: {
            return vectorToEuclidean3Py(line[PROP_ROTATION]);
          }
        case PROP_EULER_ORDER: {
            return Sk.ffi.stringToPy(line[PROP_EULER_ORDER]);
          }
        case PROP_SCALE: {
            return vectorToEuclidean3Py(line[PROP_SCALE]);
          }
        case PROP_UP: {
            return vectorToEuclidean3Py(line[PROP_UP]);
          }
        case PROP_USE_QUATERNION: {
            return line[PROP_USE_QUATERNION];
          }
        case METHOD_LOOK_AT: {
            return methodLookAt(linePy);
          }
        case PROP_TYPE: {
            return Sk.ffi.numberToIntPy(line[PROP_TYPE]);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (linePy, name, value) {
        var line = Sk.ffi.remapToJs(linePy);
        value = Sk.ffi.remapToJs(value);
        switch (name) {
        case PROP_TYPE: {
            if (isNumber(value)) {
              line[PROP_TYPE] = value;
            } else {
              throw new Error(PROP_TYPE + ' must be either LineStrip or LinePieces');
            }
          }
          break;
        default: {
            throw new Error(name + ' is not an attribute of ' + LINE);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (self) {
        return Sk.ffi.stringToPy(LINE);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (self) {
        return Sk.ffi.stringToPy(LINE);
      });
    }, LINE, []);
    mod[LINE_BASIC_MATERIAL] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (self, parameters) {
        self.tp$name = LINE_BASIC_MATERIAL;
        parameters = Sk.ffi.remapToJs(parameters);
        self.v = new THREE[LINE_BASIC_MATERIAL](parameters);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (material, name) {
        material = Sk.ffi.remapToJs(material);
        switch (name) {
        case PROP_COLOR: {
            return Sk.ffi.callsim(mod[COLOR], Sk.ffi.referenceToPy(material[PROP_COLOR], COLOR));
          }
        case PROP_OPACITY: {
            return Sk.ffi.numberToFloatPy(material[PROP_OPACITY]);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (material, name, value) {
        material = Sk.ffi.remapToJs(material);
        value = Sk.ffi.remapToJs(value);
        switch (name) {
        case PROP_COLOR: {
            if (isColor(value)) {
              material.color = value;
            } else {
              throw new Sk.builtin.TypeError('\'' + PROP_OPACITY + '\' attribute must be a <type \'' + COLOR + '\'>.');
            }
          }
          break;
        case PROP_OPACITY: {
            if (isNumber(value)) {
              material.opacity = value;
            } else {
              throw new Sk.builtin.TypeError('\'' + PROP_OPACITY + '\' attribute must be a <type \'float\'>.');
            }
          }
          break;
        default: {
            throw new Error(name + ' is not an attribute of ' + LINE_BASIC_MATERIAL);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (material) {
        material = Sk.ffi.remapToJs(material);
        var args = {};
        args[PROP_COLOR] = material[PROP_COLOR];
        args[PROP_OPACITY] = material[PROP_OPACITY];
        return Sk.ffi.stringToPy(LINE_BASIC_MATERIAL + '(' + JSON.stringify(args) + ')');
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (material) {
        material = Sk.ffi.remapToJs(material);
        var args = [{}];
        return Sk.ffi.stringToPy(LINE_BASIC_MATERIAL + '(' + args.map(function (x) {
          return JSON.stringify(x);
        }).join(', ') + ')');
      });
    }, LINE_BASIC_MATERIAL, []);
    Sk.three.meshGetAttr = function (className, meshPy, name) {
      var mesh = Sk.ffi.remapToJs(meshPy);
      switch (name) {
      case PROP_ATTITUDE: {
          return quaternionToEuclidean3Py(mesh[PROP_QUATERNION]);
        }
      case PROP_ID: {
          return Sk.ffi.numberToIntPy(mesh[PROP_ID]);
        }
      case PROP_GEOMETRY: {
          return Sk.ffi.callsim(mod[GEOMETRY], Sk.ffi.referenceToPy(mesh[PROP_GEOMETRY], GEOMETRY));
        }
      case PROP_MATERIAL: {
          return Sk.ffi.callsim(mod[Sk.three.MATERIAL], Sk.ffi.referenceToPy(mesh[PROP_MATERIAL], Sk.three.MATERIAL));
        }
      case PROP_MATRIX_AUTO_UPDATE: {
          return mesh[PROP_MATRIX_AUTO_UPDATE];
        }
      case PROP_NAME: {
          return Sk.ffi.stringToPy(mesh[PROP_NAME]);
        }
      case PROP_POSITION: {
          return vectorToEuclidean3Py(mesh[PROP_POSITION]);
        }
      case PROP_ROTATION: {
          return vectorToEuclidean3Py(mesh[PROP_ROTATION]);
        }
      case PROP_EULER_ORDER: {
          return Sk.ffi.stringToPy(mesh[PROP_EULER_ORDER]);
        }
      case PROP_SCALE: {
          return vectorToEuclidean3Py(mesh[PROP_SCALE]);
        }
      case PROP_UP: {
          return vectorToEuclidean3Py(mesh[PROP_UP]);
        }
      case METHOD_LOOK_AT: {
          return methodLookAt(meshPy);
        }
      case METHOD_ROTATE_ON_AXIS: {
          return Sk.ffi.callableToPy(mod, METHOD_ROTATE_ON_AXIS, function (methodPy, axisPy, anglePy) {
            Sk.ffi.checkMethodArgs(METHOD_ROTATE_ON_AXIS, arguments, 2, 2);
            Sk.ffi.checkArgType(ARG_AXIS, VECTOR_3, isVector3Py(axisPy), axisPy);
            Sk.ffi.checkArgType('angle', NUM, Sk.ffi.isNum(anglePy), anglePy);
            mesh[METHOD_ROTATE_ON_AXIS](Sk.ffi.remapToJs(axisPy), Sk.ffi.remapToJs(anglePy));
            return meshPy;
          });
        }
      case METHOD_ROTATE_X:
      case METHOD_ROTATE_Y:
      case METHOD_ROTATE_Z: {
          return Sk.ffi.callableToPy(mod, name, function (methodPy, axisPy) {
            Sk.ffi.checkMethodArgs(name, arguments, 1, 1);
            Sk.ffi.checkArgType(ARG_AXIS, NUM, Sk.ffi.isNum(axisPy), axisPy);
            mesh[name](Sk.ffi.remapToJs(axisPy));
            return meshPy;
          });
        }
      case METHOD_SET_GEOMETRY: {
          return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
            $loc.__init__ = Sk.ffi.functionPy(function (self) {
              self.tp$name = METHOD_SET_GEOMETRY;
            });
            $loc.__call__ = Sk.ffi.functionPy(function (self, geometryPy) {
              var geometry = Sk.ffi.remapToJs(geometryPy);
              mesh[METHOD_SET_GEOMETRY](geometry);
            });
            $loc.__str__ = Sk.ffi.functionPy(function (self) {
              return Sk.ffi.stringToPy(METHOD_SET_GEOMETRY);
            });
            $loc.__repr__ = Sk.ffi.functionPy(function (self) {
              return Sk.ffi.stringToPy(METHOD_SET_GEOMETRY);
            });
          }, METHOD_SET_GEOMETRY, []));
        }
      case METHOD_TRANSLATE_ON_AXIS: {
          return Sk.ffi.callableToPy(mod, METHOD_TRANSLATE_ON_AXIS, function (methodPy, axisPy, distancePy) {
            Sk.ffi.checkMethodArgs(METHOD_TRANSLATE_ON_AXIS, arguments, 2, 2);
            Sk.ffi.checkArgType(ARG_AXIS, VECTOR_3, isVector3Py(axisPy), axisPy);
            Sk.ffi.checkArgType(PROP_DISTANCE, NUM, Sk.ffi.isNum(distancePy), distancePy);
            mesh[METHOD_TRANSLATE_ON_AXIS](Sk.ffi.remapToJs(axisPy), Sk.ffi.remapToJs(distancePy));
            return meshPy;
          });
        }
      case METHOD_TRANSLATE_X:
      case METHOD_TRANSLATE_Y:
      case METHOD_TRANSLATE_Z: {
          return Sk.ffi.callableToPy(mod, name, function (methodPy, distancePy) {
            Sk.ffi.checkMethodArgs(name, arguments, 1, 1);
            Sk.ffi.checkArgType(PROP_DISTANCE, NUM, Sk.ffi.isNum(distancePy), distancePy);
            mesh[name](Sk.ffi.remapToJs(distancePy));
            return meshPy;
          });
        }
      case METHOD_UPDATE_MATRIX: {
          return Sk.ffi.callableToPy(mod, METHOD_UPDATE_MATRIX, function (methodPy) {
            Sk.ffi.checkMethodArgs(METHOD_UPDATE_MATRIX, arguments, 0, 0);
            mesh[METHOD_UPDATE_MATRIX]();
          });
        }
      default: {
          return Sk.three.object3DGetAttr(className, meshPy, name);
        }
      }
    };
    Sk.three.meshSetAttr = function (className, meshPy, name, valuePy) {
      var mesh = Sk.ffi.remapToJs(meshPy);
      var value = Sk.ffi.remapToJs(valuePy);
      switch (name) {
      case PROP_ATTITUDE: {
          setQuaternionProperty(Sk.three.MESH, meshPy, PROP_QUATERNION, valuePy, name);
        }
        break;
      case PROP_MATRIX_AUTO_UPDATE: {
          mesh[PROP_MATRIX_AUTO_UPDATE] = checkArgBool(PROP_MATRIX_AUTO_UPDATE, valuePy);
        }
        break;
      case PROP_NAME: {
          Sk.ffi.checkArgType(PROP_NAME, Sk.ffi.PyType.STR, Sk.ffi.isStr(valuePy), valuePy);
          mesh[PROP_NAME] = value;
        }
        break;
      case PROP_POSITION:
      case PROP_ROTATION:
      case PROP_SCALE:
      case PROP_UP: {
          setVectorProperty(mesh, name, valuePy);
        }
        break;
      case PROP_QUATERNION: {
          mesh[PROP_QUATERNION] = value;
        }
        break;
      case PROP_EULER_ORDER: {
          if (isString(value)) {
            mesh[PROP_EULER_ORDER] = value;
          } else {
            throw new Error(name + ' must be a string');
          }
        }
        break;
      case PROP_USE_QUATERNION: {
          mesh[PROP_USE_QUATERNION] = value;
        }
        break;
      default: {
          return Sk.three.object3DSetAttr(className, meshPy, name, valuePy);
        }
      }
    };
    mod[Sk.three.MESH] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, geometryPy, materialPy) {
        Sk.ffi.checkMethodArgs(Sk.three.MESH, arguments, 1, 2);
        Sk.ffi.checkArgType(PROP_GEOMETRY, GEOMETRY, Sk.ffi.isInstance(geometryPy), geometryPy);
        Sk.ffi.checkArgType(PROP_MATERIAL, Sk.three.MATERIAL, Sk.ffi.isInstance(materialPy), materialPy);
        Sk.ffi.referenceToPy(new THREE[Sk.three.MESH](Sk.ffi.remapToJs(geometryPy), Sk.ffi.remapToJs(materialPy)), Sk.three.MESH, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        return Sk.three.meshGetAttr(Sk.three.MESH, selfPy, name);
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        return Sk.three.meshSetAttr(Sk.three.MESH, selfPy, name, valuePy);
      });
      $loc.__str__ = Sk.ffi.functionPy(function (mesh) {
        mesh = Sk.ffi.remapToJs(mesh);
        var args = {};
        args[PROP_ID] = mesh[PROP_ID];
        args[PROP_NAME] = mesh[PROP_NAME];
        return Sk.ffi.stringToPy(Sk.three.MESH + '(' + JSON.stringify(args) + ')');
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (mesh) {
        mesh = Sk.ffi.remapToJs(mesh);
        var args = [];
        return Sk.ffi.stringToPy(Sk.three.MESH + '(' + args.map(function (x) {
          return JSON.stringify(x);
        }).join(', ') + ')');
      });
    }, Sk.three.MESH, []);
    function materialGetAttr(className, materialPy, name) {
      var material = Sk.ffi.remapToJs(materialPy);
      switch (name) {
      case PROP_EMISSIVE:
      case PROP_COLOR: {
          return Sk.ffi.callsim(mod[COLOR], Sk.ffi.referenceToPy(material[name], COLOR));
        }
      case PROP_ID: {
          return Sk.ffi.numberToIntPy(material[PROP_ID]);
        }
      case PROP_OPACITY:
      case PROP_OVERDRAW: {
          return Sk.ffi.numberToFloatPy(material[PROP_OPACITY]);
        }
      case PROP_NAME:
      case PROP_UUID: {
          return Sk.ffi.stringToPy(material[name]);
        }
      case PROP_NEEDS_UPDATE:
      case PROP_TRANSPARENT:
      case PROP_VISIBLE: {
          return Sk.ffi.booleanToPy(material[name]);
        }
      default: {
          throw Sk.ffi.err.attribute(name).isNotGetableOnType(className);
        }
      }
    }
    function materialSetAttr(className, materialPy, name, valuePy) {
      var material = Sk.ffi.remapToJs(materialPy);
      switch (name) {
      case PROP_NAME: {
          Sk.ffi.checkArgType(name, Sk.ffi.PyType.STR, Sk.ffi.isStr(valuePy), valuePy);
          material[name] = Sk.ffi.remapToJs(valuePy);
        }
        break;
      case PROP_OVERDRAW: {
          Sk.ffi.checkArgType(name, Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(valuePy), valuePy);
          material[name] = Sk.ffi.remapToJs(valuePy);
        }
        break;
      case PROP_NEEDS_UPDATE:
      case PROP_TRANSPARENT:
      case PROP_VISIBLE: {
          Sk.ffi.checkArgType(name, Sk.ffi.PyType.BOOL, Sk.ffi.isBool(valuePy), valuePy);
          material[name] = Sk.ffi.remapToJs(valuePy);
        }
        break;
      default: {
          throw Sk.ffi.err.attribute(name).isNotSetableOnType(className);
        }
      }
    }
    mod[Sk.three.MATERIAL] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, materialPy) {
        Sk.ffi.checkMethodArgs(Sk.three.MATERIAL, arguments, 0, 1);
        if (isDefined(materialPy)) {
          Sk.ffi.referenceToPy(Sk.ffi.remapToJs(materialPy), Sk.three.MATERIAL, undefined, selfPy);
        } else {
          Sk.ffi.referenceToPy(new THREE[Sk.three.MATERIAL](), Sk.three.MATERIAL, undefined, selfPy);
        }
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        switch (name) {
        default: {
            return materialGetAttr(Sk.three.MATERIAL, selfPy, name);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        switch (name) {
        default: {
            return materialSetAttr(Sk.three.MATERIAL, selfPy, name, valuePy);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffi.stringToPy(Sk.three.MATERIAL + LPAREN + RPAREN);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffi.stringToPy(Sk.three.MATERIAL + LPAREN + RPAREN);
      });
    }, Sk.three.MATERIAL, []);
    mod[MESH_BASIC_MATERIAL] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, parametersPy) {
        var parameters = Sk.ffi.remapToJs(parametersPy);
        Sk.ffi.referenceToPy(new THREE[MESH_BASIC_MATERIAL](parameters), MESH_BASIC_MATERIAL, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (materialPy, name) {
        var material = Sk.ffi.remapToJs(materialPy);
        switch (name) {
        case PROP_COLOR: {
            return Sk.ffi.callsim(mod[COLOR], Sk.ffi.referenceToPy(material[PROP_COLOR], COLOR));
          }
        case PROP_WIREFRAME: {
            return material[PROP_WIREFRAME];
          }
        case PROP_WIREFRAME_LINEWIDTH: {
            return Sk.ffi.numberToFloatPy(material[PROP_WIREFRAME_LINEWIDTH]);
          }
        default: {
            return materialGetAttr(MESH_BASIC_MATERIAL, materialPy, name);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (materialPy, name, valuePy) {
        var material = Sk.ffi.remapToJs(materialPy);
        var value = Sk.ffi.remapToJs(valuePy);
        switch (name) {
        case PROP_COLOR: {
            material[PROP_COLOR] = new THREE.Color(value);
          }
          break;
        case PROP_NAME: {
            if (isString(value)) {
              material[PROP_NAME] = value;
            } else {
              throw new Error(name + ' must be a string');
            }
          }
          break;
        case PROP_OPACITY: {
            if (isNumber(value)) {
              material.opacity = value;
            } else {
              throw new Sk.builtin.TypeError('\'' + PROP_OPACITY + '\' attribute must be a <type \'float\'>.');
            }
          }
          break;
        case PROP_WIREFRAME: {
            if (isBoolean(value)) {
              material[PROP_WIREFRAME] = value;
            } else {
              throw new Error(name + ' must be Boolean');
            }
          }
          break;
        case PROP_WIREFRAME_LINEWIDTH: {
            if (isNumber(value)) {
              material[PROP_WIREFRAME_LINEWIDTH] = value;
            } else {
              throw new Error(name + ' must be a number');
            }
          }
          break;
        default: {
            return materialSetAttr(MESH_BASIC_MATERIAL, materialPy, name, valuePy);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (materialPy) {
        var material = Sk.ffi.remapToJs(materialPy);
        var args = {};
        args[PROP_COLOR] = material[PROP_COLOR];
        args[PROP_WIREFRAME] = material[PROP_WIREFRAME];
        args[PROP_WIREFRAME_LINEWIDTH] = material[PROP_WIREFRAME_LINEWIDTH];
        return Sk.ffi.stringToPy(MESH_BASIC_MATERIAL + '(' + JSON.stringify(args) + ')');
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (material) {
        material = Sk.ffi.remapToJs(material);
        var parameters = {};
        parameters[PROP_COLOR] = material[PROP_COLOR];
        parameters[PROP_WIREFRAME] = material[PROP_WIREFRAME];
        parameters[PROP_WIREFRAME_LINEWIDTH] = material[PROP_WIREFRAME_LINEWIDTH];
        var args = [parameters];
        return Sk.ffi.stringToPy(MESH_BASIC_MATERIAL + '(' + args.map(function (x) {
          return JSON.stringify(x);
        }).join(', ') + ')');
      });
    }, MESH_BASIC_MATERIAL, []);
    mod[MESH_LAMBERT_MATERIAL] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, parametersPy) {
        Sk.ffi.checkMethodArgs(MESH_LAMBERT_MATERIAL, arguments, 0, 1);
        var parameters = Sk.ffi.remapToJs(parametersPy);
        Sk.ffi.referenceToPy(new THREE[MESH_LAMBERT_MATERIAL](parameters), MESH_LAMBERT_MATERIAL, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (materialPy, name) {
        var material = Sk.ffi.remapToJs(materialPy);
        switch (name) {
        case PROP_ID: {
            return Sk.ffi.numberToIntPy(material[PROP_ID]);
          }
        case PROP_COLOR: {
            return Sk.ffi.callsim(mod[COLOR], Sk.ffi.referenceToPy(material[PROP_COLOR], COLOR));
          }
        case PROP_NAME: {
            return Sk.ffi.stringToPy(material[PROP_NAME]);
          }
        case PROP_OPACITY: {
            return Sk.ffi.numberToFloatPy(material[PROP_OPACITY]);
          }
        default: {
            return materialGetAttr(MESH_LAMBERT_MATERIAL, materialPy, name);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (materialPy, name, valuePy) {
        var material = Sk.ffi.remapToJs(materialPy);
        var value = Sk.ffi.remapToJs(valuePy);
        switch (name) {
        case PROP_COLOR: {
            material[PROP_COLOR] = new THREE.Color(value);
          }
          break;
        case PROP_NAME: {
            if (isString(value)) {
              material[PROP_NAME] = value;
            } else {
              throw new Error(name + ' must be a string');
            }
          }
          break;
        case PROP_OPACITY: {
            if (isNumber(value)) {
              material.opacity = value;
            } else {
              throw new Sk.builtin.TypeError('\'' + PROP_OPACITY + '\' attribute must be a <type \'float\'>.');
            }
          }
          break;
        case PROP_WIREFRAME: {
            if (isBoolean(value)) {
              material[PROP_WIREFRAME] = value;
            } else {
              throw new Error(name + ' must be Boolean');
            }
          }
          break;
        case PROP_WIREFRAME_LINEWIDTH: {
            if (isNumber(value)) {
              material[PROP_WIREFRAME_LINEWIDTH] = value;
            } else {
              throw new Error(name + ' must be a number');
            }
          }
          break;
        default: {
            return materialSetAttr(MESH_LAMBERT_MATERIAL, materialPy, name, valuePy);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (material) {
        material = Sk.ffi.remapToJs(material);
        var args = {};
        return Sk.ffi.stringToPy(MESH_LAMBERT_MATERIAL + '(' + JSON.stringify(args) + ')');
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (material) {
        material = Sk.ffi.remapToJs(material);
        var parameters = {};
        parameters[PROP_COLOR] = material[PROP_COLOR];
        var args = [parameters];
        return Sk.ffi.stringToPy(MESH_LAMBERT_MATERIAL + '(' + args.map(function (x) {
          return JSON.stringify(x);
        }).join(', ') + ')');
      });
    }, MESH_LAMBERT_MATERIAL, []);
    mod[MESH_NORMAL_MATERIAL] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, parametersPy) {
        var parameters = Sk.ffi.remapToJs(parametersPy);
        Sk.ffi.referenceToPy(new THREE[MESH_NORMAL_MATERIAL](parameters), MESH_NORMAL_MATERIAL, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        return materialGetAttr(MESH_NORMAL_MATERIAL, selfPy, name);
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        return materialSetAttr(MESH_NORMAL_MATERIAL, selfPy, name, valuePy);
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var args = {};
        return Sk.ffi.stringToPy(MESH_NORMAL_MATERIAL + '(' + JSON.stringify(args) + ')');
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var args = [{}];
        return Sk.ffi.stringToPy(MESH_NORMAL_MATERIAL + '(' + args.map(function (x) {
          return JSON.stringify(x);
        }).join(', ') + ')');
      });
    }, MESH_NORMAL_MATERIAL, []);
    mod[MESH_PHONG_MATERIAL] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, parametersPy) {
        var parameters = Sk.ffi.remapToJs(parametersPy);
        Sk.ffi.referenceToPy(new THREE[MESH_PHONG_MATERIAL](parameters), MESH_PHONG_MATERIAL, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        return materialGetAttr(MESH_PHONG_MATERIAL, selfPy, name);
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        return materialSetAttr(MESH_PHONG_MATERIAL, selfPy, name, valuePy);
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var args = {};
        return Sk.ffi.stringToPy(MESH_PHONG_MATERIAL + '(' + JSON.stringify(args) + ')');
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var args = [{}];
        return Sk.ffi.stringToPy(MESH_PHONG_MATERIAL + '(' + args.map(function (x) {
          return JSON.stringify(x);
        }).join(', ') + ')');
      });
    }, MESH_PHONG_MATERIAL, []);
    mod[Sk.three.PARTICLE_SYSTEM] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, geometryPy, materialPy) {
        Sk.ffi.checkMethodArgs(Sk.three.PARTICLE_SYSTEM, arguments, 0, 2);
        Sk.ffi.checkArgType(PROP_GEOMETRY, GEOMETRY, Sk.ffi.isInstance(geometryPy), geometryPy);
        Sk.ffi.checkArgType(PROP_MATERIAL, Sk.three.MATERIAL, Sk.ffi.isInstance(materialPy), materialPy);
        Sk.ffi.referenceToPy(new THREE.ParticleSystem(Sk.ffi.remapToJs(geometryPy), Sk.ffi.remapToJs(materialPy)), Sk.three.PARTICLE_SYSTEM, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        switch (name) {
        default: {
            return Sk.three.object3DGetAttr(Sk.three.PARTICLE_SYSTEM, selfPy, name);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        switch (name) {
        default: {
            return Sk.three.object3DSetAttr(Sk.three.PARTICLE_SYSTEM, selfPy, name, valuePy);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var names = [];
        var argsPy = names.map(function (name) {
            return Sk.ffi.gattr(selfPy, name);
          });
        var args = argsPy.map(function (valuePy) {
            return Sk.ffi.remapToJs(Sk.ffh.str(valuePy));
          });
        return Sk.ffi.stringToPy(Sk.three.PARTICLE_SYSTEM + LPAREN + args.join(COMMA + SPACE) + RPAREN);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var names = [];
        var argsPy = names.map(function (name) {
            return Sk.ffi.gattr(selfPy, name);
          });
        var args = argsPy.map(function (valuePy) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(valuePy));
          });
        return Sk.ffi.stringToPy(Sk.three.PARTICLE_SYSTEM + LPAREN + args.join(COMMA + SPACE) + RPAREN);
      });
    }, Sk.three.PARTICLE_SYSTEM, []);
    mod[Sk.three.PARTICLE_SYSTEM_MATERIAL] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, parametersPy) {
        Sk.ffi.checkMethodArgs(Sk.three.PARTICLE_SYSTEM_MATERIAL, arguments, 0, 1);
        if (isDefined(parametersPy) && !isNull(parametersPy) && Sk.ffi.isInstance(parametersPy, Sk.three.PARTICLE_SYSTEM_MATERIAL)) {
          Sk.ffi.referenceToPy(Sk.ffi.remapToJs(parametersPy), Sk.three.PARTICLE_SYSTEM_MATERIAL, undefined, selfPy);
        } else {
          var parameters = Sk.ffi.remapToJs(parametersPy);
          Sk.ffi.referenceToPy(new THREE[Sk.three.PARTICLE_SYSTEM_MATERIAL](parameters), Sk.three.PARTICLE_SYSTEM_MATERIAL, undefined, selfPy);
        }
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var material = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case PROP_COLOR: {
            return colorToColorPy(material.color);
          }
        case PROP_SIZE: {
            return Sk.ffi.numberToFloatPy(material.size);
          }
        case PROP_SIZE_ATTENUATION: {
            return Sk.ffi.booleanToPy(material.sizeAttenuation);
          }
        case PROP_VERTEX_COLORS: {
            return Sk.ffi.booleanToPy(material.vertexColors);
          }
        case PROP_FOG: {
            return Sk.ffi.booleanToPy(material.fog);
          }
        default: {
            return materialGetAttr(Sk.three.PARTICLE_SYSTEM_MATERIAL, selfPy, name);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        var material = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case PROP_COLOR: {
            Sk.ffi.checkArgType(name, COLOR, Sk.ffi.isInstance(valuePy, COLOR), valuePy);
            material.color = Sk.ffi.remapToJs(valuePy);
          }
          break;
        case PROP_SIZE: {
            Sk.ffi.checkArgType(name, Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(valuePy), valuePy);
            material.size = Sk.ffi.remapToJs(valuePy);
          }
          break;
        case PROP_SIZE_ATTENUATION: {
            Sk.ffi.checkArgType(name, Sk.ffi.PyType.BOOL, Sk.ffi.isBool(valuePy), valuePy);
            material.sizeAttenuation = Sk.ffi.remapToJs(valuePy);
          }
          break;
        case PROP_VERTEX_COLORS: {
            Sk.ffi.checkArgType(name, Sk.ffi.PyType.BOOL, Sk.ffi.isBool(valuePy), valuePy);
            material.vertexColors = Sk.ffi.remapToJs(valuePy);
          }
          break;
        case PROP_FOG: {
            Sk.ffi.checkArgType(name, Sk.ffi.PyType.BOOL, Sk.ffi.isBool(valuePy), valuePy);
            material.fog = Sk.ffi.remapToJs(valuePy);
          }
          break;
        default: {
            return materialSetAttr(Sk.three.PARTICLE_SYSTEM_MATERIAL, selfPy, name, valuePy);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var names = [
            PROP_COLOR,
            PROP_SIZE,
            PROP_SIZE_ATTENUATION,
            PROP_VERTEX_COLORS,
            PROP_FOG
          ];
        var args = names.map(function (name) {
            return [
              name,
              Sk.ffi.remapToJs(Sk.ffh.str(Sk.ffi.gattr(selfPy, name)))
            ].join(EQUAL);
          });
        return Sk.ffi.stringToPy(Sk.three.PARTICLE_SYSTEM_MATERIAL + LPAREN + args.join(COMMA + SPACE) + RPAREN);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var names = [
            PROP_COLOR,
            PROP_SIZE,
            PROP_SIZE_ATTENUATION,
            PROP_VERTEX_COLORS,
            PROP_FOG
          ];
        var argsPy = names.map(function (name) {
            return Sk.ffi.gattr(selfPy, name);
          });
        var args = argsPy.map(function (valuePy) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(valuePy));
          });
        return Sk.ffi.stringToPy(Sk.three.PARTICLE_SYSTEM_MATERIAL + LPAREN + args.join(COMMA + SPACE) + RPAREN);
      });
    }, Sk.three.PARTICLE_SYSTEM_MATERIAL, []);
    mod[Sk.three.MATRIX_3] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, n11Py, n12Py, n13Py, n21Py, n22Py, n23Py, n31Py, n32Py, n33Py) {
        Sk.ffi.checkMethodArgs(Sk.three.MATRIX_3, arguments, 0, 9);
        if (isDefined(n11Py)) {
          if (Sk.ffi.isInstance(n11Py, Sk.three.MATRIX_3)) {
            Sk.ffi.referenceToPy(Sk.ffi.remapToJs(n11Py), Sk.three.MATRIX_3, undefined, selfPy);
          } else {
            Sk.ffi.checkMethodArgs(Sk.three.MATRIX_3, arguments, 9, 9);
            Sk.ffi.checkArgType('n11', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(n11Py), n11Py);
            Sk.ffi.checkArgType('n12', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(n12Py), n12Py);
            Sk.ffi.checkArgType('n13', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(n13Py), n13Py);
            Sk.ffi.checkArgType('n21', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(n21Py), n21Py);
            Sk.ffi.checkArgType('n22', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(n22Py), n22Py);
            Sk.ffi.checkArgType('n23', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(n23Py), n23Py);
            Sk.ffi.checkArgType('n31', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(n31Py), n31Py);
            Sk.ffi.checkArgType('n32', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(n32Py), n32Py);
            Sk.ffi.checkArgType('n33', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(n33Py), n33Py);
            var n11 = Sk.ffi.remapToJs(n11Py);
            var n12 = Sk.ffi.remapToJs(n12Py);
            var n13 = Sk.ffi.remapToJs(n13Py);
            var n21 = Sk.ffi.remapToJs(n21Py);
            var n22 = Sk.ffi.remapToJs(n22Py);
            var n23 = Sk.ffi.remapToJs(n23Py);
            var n31 = Sk.ffi.remapToJs(n31Py);
            var n32 = Sk.ffi.remapToJs(n32Py);
            var n33 = Sk.ffi.remapToJs(n33Py);
            Sk.ffi.referenceToPy(new THREE.Matrix3(n11, n12, n13, n21, n22, n23, n31, n32, n33), Sk.three.MATRIX_3, undefined, selfPy);
          }
        } else {
          Sk.ffi.referenceToPy(new THREE.Matrix3(), Sk.three.MATRIX_3, undefined, selfPy);
        }
      });
      $loc.__mul__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        switch (Sk.ffi.getType(otherPy)) {
        case Sk.ffi.PyType.INSTANCE: {
            if (Sk.ffi.isInstance(otherPy, Sk.three.MATRIX_3)) {
              var lhs = Sk.ffi.remapToJs(selfPy).elements;
              var a11 = lhs[0];
              var a12 = lhs[3];
              var a13 = lhs[6];
              var a21 = lhs[1];
              var a22 = lhs[4];
              var a23 = lhs[7];
              var a31 = lhs[2];
              var a32 = lhs[5];
              var a33 = lhs[8];
              var rhs = Sk.ffi.remapToJs(otherPy).elements;
              var b11 = rhs[0];
              var b12 = rhs[3];
              var b13 = rhs[6];
              var b21 = rhs[1];
              var b22 = rhs[4];
              var b23 = rhs[7];
              var b31 = rhs[2];
              var b32 = rhs[5];
              var b33 = rhs[8];
              var c11 = a11 * b11 + a12 * b21 + a13 * b31;
              var c12 = a11 * b12 + a12 * b22 + a13 * b32;
              var c13 = a11 * b13 + a12 * b23 + a13 * b33;
              var c21 = a21 * b11 + a22 * b21 + a23 * b31;
              var c22 = a21 * b12 + a22 * b22 + a23 * b32;
              var c23 = a21 * b13 + a22 * b23 + a23 * b33;
              var c31 = a31 * b11 + a32 * b21 + a33 * b31;
              var c32 = a31 * b12 + a32 * b22 + a33 * b32;
              var c33 = a31 * b13 + a32 * b23 + a33 * b33;
              var matrix = new THREE.Matrix3(c11, c12, c13, c21, c22, c23, c31, c32, c33);
              return Sk.ffi.callsim(mod[Sk.three.MATRIX_3], Sk.ffi.referenceToPy(matrix, Sk.three.MATRIX_3));
            } else {
              throw Sk.ffi.err.operand(ARG_OTHER).toOperation(OP_MUL).mustHaveType([
                Sk.ffi.PyType.FLOAT,
                Sk.three.MATRIX_3
              ]);
            }
          }
        case Sk.ffi.PyType.FLOAT: {
            var lhs = Sk.ffi.remapToJs(selfPy).elements;
            var n11 = lhs[0];
            var n12 = lhs[3];
            var n13 = lhs[6];
            var n21 = lhs[1];
            var n22 = lhs[4];
            var n23 = lhs[7];
            var n31 = lhs[2];
            var n32 = lhs[5];
            var n33 = lhs[8];
            var rhs = Sk.ffi.remapToJs(otherPy);
            var matrix = new THREE.Matrix3(n11 * rhs, n12 * rhs, n13 * rhs, n21 * rhs, n22 * rhs, n23 * rhs, n31 * rhs, n32 * rhs, n33 * rhs);
            return Sk.ffi.callsim(mod[Sk.three.MATRIX_3], Sk.ffi.referenceToPy(matrix, Sk.three.MATRIX_3));
          }
        default: {
            throw Sk.ffi.err.operand(ARG_OTHER).toOperation(OP_MUL).mustHaveType([
              Sk.ffi.PyType.FLOAT,
              Sk.three.MATRIX_3
            ]);
          }
        }
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var matrix = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case METHOD_CLONE: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy) {
              Sk.ffi.checkMethodArgs(name, arguments, 0, 0);
              return Sk.ffi.callsim(mod[Sk.three.MATRIX_3], Sk.ffi.referenceToPy(matrix.clone(), Sk.three.MATRIX_3));
            });
          }
        case METHOD_COPY: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy, mPy) {
              Sk.ffi.checkMethodArgs(name, arguments, 1, 1);
              Sk.ffi.checkArgType(ARG_MATRIX, Sk.three.MATRIX_3, Sk.ffi.isInstance(mPy, Sk.three.MATRIX_3), mPy);
              matrix.copy(Sk.ffi.remapToJs(mPy));
              return selfPy;
            });
          }
        case METHOD_DETERMINANT: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy) {
              Sk.ffi.checkMethodArgs(name, arguments, 0, 0);
              return Sk.ffi.numberToFloatPy(matrix.determinant());
            });
          }
        case METHOD_GET_NORMAL_MATRIX: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy, mPy) {
              Sk.ffi.checkMethodArgs(name, arguments, 1, 1);
              Sk.ffi.checkArgType('m', Sk.three.MATRIX_4, Sk.ffi.isInstance(mPy, Sk.three.MATRIX_4), mPy);
              matrix.getNormalMatrix(Sk.ffi.remapToJs(mPy));
              return selfPy;
            });
          }
        case METHOD_IDENTITY: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy) {
              Sk.ffi.checkMethodArgs(name, arguments, 0, 0);
              matrix.identity();
              return selfPy;
            });
          }
        case METHOD_SET: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy, n11Py, n12Py, n13Py, n21Py, n22Py, n23Py, n31Py, n32Py, n33Py) {
              Sk.ffi.checkMethodArgs(name, arguments, 9, 9);
              Sk.ffi.checkArgType('n11', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(n11Py), n11Py);
              Sk.ffi.checkArgType('n12', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(n12Py), n12Py);
              Sk.ffi.checkArgType('n13', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(n13Py), n13Py);
              Sk.ffi.checkArgType('n21', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(n21Py), n21Py);
              Sk.ffi.checkArgType('n22', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(n22Py), n22Py);
              Sk.ffi.checkArgType('n23', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(n23Py), n23Py);
              Sk.ffi.checkArgType('n31', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(n31Py), n31Py);
              Sk.ffi.checkArgType('n32', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(n32Py), n32Py);
              Sk.ffi.checkArgType('n33', Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(n33Py), n33Py);
              var n11 = Sk.ffi.remapToJs(n11Py);
              var n12 = Sk.ffi.remapToJs(n12Py);
              var n13 = Sk.ffi.remapToJs(n13Py);
              var n21 = Sk.ffi.remapToJs(n21Py);
              var n22 = Sk.ffi.remapToJs(n22Py);
              var n23 = Sk.ffi.remapToJs(n23Py);
              var n31 = Sk.ffi.remapToJs(n31Py);
              var n32 = Sk.ffi.remapToJs(n32Py);
              var n33 = Sk.ffi.remapToJs(n33Py);
              matrix.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
              return selfPy;
            });
          }
        case METHOD_TRANSPOSE: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy) {
              Sk.ffi.checkMethodArgs(name, arguments, 0, 0);
              matrix.transpose();
              return selfPy;
            });
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(Sk.three.MATRIX_3);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        switch (name) {
        default: {
            throw Sk.ffi.err.attribute(name).isNotSetableOnType(Sk.three.MATRIX_3);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var matrix = Sk.ffi.remapToJs(selfPy);
        var x = matrix.elements;
        var es = [
            [
              x[0],
              x[3],
              x[6]
            ],
            [
              x[1],
              x[4],
              x[7]
            ],
            [
              x[2],
              x[5],
              x[8]
            ]
          ].map(function (row) {
            return row.map(function (x) {
              return Sk.ffi.remapToJs(Sk.ffh.str(Sk.ffi.numberToFloatPy(x)));
            }).join(SPACE);
          }).join(NEWLINE);
        return Sk.ffi.stringToPy(es);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var matrix = Sk.ffi.remapToJs(selfPy);
        var x = matrix.elements;
        var args = [
            x[0],
            x[3],
            x[6],
            x[1],
            x[4],
            x[7],
            x[2],
            x[5],
            x[8]
          ].map(function (x) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(Sk.ffi.numberToFloatPy(x)));
          }).join(', ');
        return Sk.ffi.stringToPy(Sk.three.MATRIX_3 + LPAREN + args + RPAREN);
      });
    }, Sk.three.MATRIX_3, []);
    mod[Sk.three.MATRIX_4] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, n11Py) {
        Sk.ffi.checkMethodArgs(Sk.three.MATRIX_4, arguments, 0, 1);
        if (isDefined(n11Py) && Sk.ffi.isInstance(n11Py, Sk.three.MATRIX_4)) {
          Sk.ffi.referenceToPy(Sk.ffi.remapToJs(n11Py), Sk.three.MATRIX_4, undefined, selfPy);
        } else {
          Sk.ffi.referenceToPy(new THREE.Matrix4(), Sk.three.MATRIX_4, undefined, selfPy);
        }
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var matrix = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case METHOD_MAKE_ROTATION_X: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy, thetaPy) {
              Sk.ffi.checkMethodArgs(name, arguments, 1, 1);
              Sk.ffi.checkArgType(ARG_THETA, Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(thetaPy), thetaPy);
              var theta = Sk.ffi.remapToJs(thetaPy);
              return Sk.ffi.callsim(mod[Sk.three.MATRIX_4], Sk.ffi.referenceToPy(matrix.makeRotationX(theta), Sk.three.MATRIX_4));
            });
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(Sk.three.MATRIX_4);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        switch (name) {
        default: {
            throw Sk.ffi.err.attribute(name).isNotSetableOnType(Sk.three.MATRIX_4);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffi.stringToPy(Sk.three.MATRIX_4 + LPAREN + RPAREN);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffi.stringToPy(Sk.three.MATRIX_4 + LPAREN + RPAREN);
      });
    }, Sk.three.MATRIX_4, []);
    mod[Sk.three.FACE_3] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, aPy, bPy, cPy, normalPy, colorPy, materialIndexPy) {
        if (isDefined(aPy) && Sk.ffi.isInstance(aPy, Sk.three.FACE_3)) {
          Sk.ffi.checkMethodArgs(Sk.three.FACE_3, arguments, 1, 1);
          var face = Sk.ffi.remapToJs(aPy);
          Sk.ffi.checkArgType(PROP_A, '!?', isDefined(face), aPy);
          Sk.ffi.checkArgType(PROP_A, '?!', face instanceof THREE.Face3, aPy);
          Sk.ffi.referenceToPy(face, Sk.three.FACE_3, undefined, selfPy);
        } else {
          Sk.ffi.checkMethodArgs(Sk.three.FACE_3, arguments, 3, 6);
          Sk.ffi.checkArgType(PROP_A, INT, Sk.ffi.isInt(aPy), aPy);
          Sk.ffi.checkArgType(PROP_B, INT, Sk.ffi.isInt(bPy), bPy);
          Sk.ffi.checkArgType(PROP_C, INT, Sk.ffi.isInt(cPy), cPy);
          if (isDefined(normalPy)) {
            Sk.ffi.checkArgType(PROP_NORMAL, EUCLIDEAN_3, Sk.ffi.isInstance(normalPy, EUCLIDEAN_3), normalPy);
          }
          var a = Sk.ffi.remapToJs(aPy);
          var b = Sk.ffi.remapToJs(bPy);
          var c = Sk.ffi.remapToJs(cPy);
          var normal = remapToVector3(PROP_NORMAL, normalPy);
          var color = Sk.ffi.remapToJs(colorPy);
          var materialIndex = Sk.ffi.remapToJs(materialIndexPy);
          var face = new THREE.Face3(a, b, c, normal, color, materialIndex);
          Sk.ffi.referenceToPy(face, Sk.three.FACE_3, undefined, selfPy);
        }
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var face = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case PROP_A: {
            return Sk.ffi.numberToIntPy(face.a);
          }
        case PROP_B: {
            return Sk.ffi.numberToIntPy(face.b);
          }
        case PROP_C: {
            return Sk.ffi.numberToIntPy(face.c);
          }
        case PROP_COLOR: {
            return Sk.ffi.callsim(mod[COLOR], Sk.ffi.referenceToPy(face.color, COLOR));
          }
        case PROP_CENTROID: {
            return vectorToEuclidean3Py(face.centroid);
          }
        case PROP_NORMAL: {
            return vectorToEuclidean3Py(face.normal);
          }
        case PROP_VERTEX_NORMALS: {
            return Sk.ffi.listPy(face.vertexNormals.map(function (vectorJs) {
              return vectorToEuclidean3Py(vectorJs);
            }));
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(Sk.three.FACE_3);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        var face = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        default: {
            throw Sk.ffi.err.attribute(name).isNotSetableOnType(Sk.three.FACE_3);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var names = [
            PROP_A,
            PROP_B,
            PROP_C,
            PROP_NORMAL
          ];
        var argsPy = names.map(function (name) {
            return Sk.ffi.gattr(selfPy, name);
          });
        var args = argsPy.map(function (valuePy) {
            return Sk.ffi.remapToJs(Sk.ffh.str(valuePy));
          });
        return Sk.ffi.stringToPy(Sk.three.FACE_3 + LPAREN + args.join(COMMA + SPACE) + RPAREN);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var names = [
            PROP_A,
            PROP_B,
            PROP_C,
            PROP_NORMAL
          ];
        var argsPy = names.map(function (name) {
            return Sk.ffi.gattr(selfPy, name);
          });
        var args = argsPy.map(function (valuePy) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(valuePy));
          });
        return Sk.ffi.stringToPy(Sk.three.FACE_3 + LPAREN + args.join(COMMA + SPACE) + RPAREN);
      });
    }, Sk.three.FACE_3, []);
    mod[INTERSECTION] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, distancePy, pointPy, facePy) {
        switch (Sk.ffi.checkMethodArgs(INTERSECTION, arguments, 1, 3)) {
        case 1: {
            Sk.ffi.checkMethodArgs(INTERSECTION, arguments, 1, 1);
            Sk.ffi.referenceToPy(Sk.ffi.remapToJs(distancePy), INTERSECTION, undefined, selfPy);
          }
          break;
        default: {
            Sk.ffi.checkMethodArgs(INTERSECTION, arguments, 3, 3);
            Sk.ffi.checkArgType(PROP_DISTANCE, Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(distancePy), distancePy);
            Sk.ffi.checkArgType(PROP_POINT, EUCLIDEAN_3, Sk.ffi.isInstance(pointPy, EUCLIDEAN_3), pointPy);
            Sk.ffi.checkArgType(PROP_FACE, Sk.three.FACE_3, Sk.ffi.isInstance(facePy, Sk.three.FACE_3), facePy);
            var intersection = {};
            intersection[PROP_DISTANCE] = Sk.ffi.remapToJs(distancePy);
            intersection[PROP_POINT] = remapToVector3(PROP_POINT, pointPy);
            intersection[PROP_FACE] = Sk.ffi.remapToJs(facePy);
            Sk.ffi.referenceToPy(intersection, INTERSECTION, undefined, selfPy);
          }
        }
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var intersection = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case PROP_DISTANCE: {
            return Sk.ffi.numberToFloatPy(intersection[PROP_DISTANCE]);
          }
        case PROP_POINT: {
            return vectorToEuclidean3Py(intersection[PROP_POINT]);
          }
        case PROP_FACE: {
            var face = intersection[PROP_FACE];
            if (isDefined(face) && !isNull(face)) {
              return Sk.ffi.callsim(mod[Sk.three.FACE_3], Sk.ffi.referenceToPy(intersection[PROP_FACE], Sk.three.FACE_3));
            } else {
              return Sk.ffi.none.None;
            }
          }
        case PROP_OBJECT: {
            return Sk.ffi.callsim(mod[Sk.three.OBJECT_3D], Sk.ffi.referenceToPy(intersection[PROP_OBJECT], Sk.three.OBJECT_3D));
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(INTERSECTION);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        var intersection = Sk.ffi.remapToJs(selfPy);
        var value = Sk.ffi.remapToJs(valuePy);
        switch (name) {
        default: {
            throw Sk.ffi.err.attribute(name).isNotSetableOnType(INTERSECTION);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var names = [
            PROP_DISTANCE,
            PROP_POINT,
            PROP_FACE
          ];
        var argsPy = names.map(function (name) {
            return Sk.ffi.gattr(selfPy, name);
          });
        var args = argsPy.map(function (valuePy) {
            return Sk.ffi.remapToJs(Sk.ffh.str(valuePy));
          });
        return Sk.ffi.stringToPy(INTERSECTION + LPAREN + args.join(COMMA + SPACE) + RPAREN);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var names = [
            PROP_DISTANCE,
            PROP_POINT,
            PROP_FACE
          ];
        var argsPy = names.map(function (name) {
            return Sk.ffi.gattr(selfPy, name);
          });
        var args = argsPy.map(function (valuePy) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(valuePy));
          });
        return Sk.ffi.stringToPy(INTERSECTION + LPAREN + args.join(COMMA + SPACE) + RPAREN);
      });
    }, INTERSECTION, []);
    mod[PLANE] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, normalPy, offsetPy) {
        Sk.ffi.checkMethodArgs(PLANE, arguments, 0, 2);
        var normal = remapToVector3(PROP_NORMAL, normalPy);
        if (isDefined(offsetPy)) {
          Sk.ffi.checkArgType(PROP_OFFSET, Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(offsetPy), offsetPy);
        }
        var offset = Sk.ffi.remapToJs(offsetPy);
        Sk.ffi.referenceToPy(new THREE[PLANE](normal, offset), PLANE, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var plane = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case PROP_NORMAL: {
            return vectorToEuclidean3Py(plane[PROP_NORMAL]);
          }
        case PROP_OFFSET:
        case PROP_CONSTANT: {
            return Sk.ffi.numberToFloatPy(plane[PROP_CONSTANT]);
          }
        case METHOD_COPY: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy, planePy) {
              Sk.ffi.checkMethodArgs(name, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_PLANE, PLANE, Sk.ffi.isInstance(planePy, PLANE), planePy);
              plane[METHOD_COPY](Sk.ffi.remapToJs(planePy));
              return selfPy;
            });
          }
        case METHOD_DISTANCE_TO_POINT: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy, pointPy) {
              Sk.ffi.checkMethodArgs(name, arguments, 1, 1);
              return Sk.ffi.numberToFloatPy(plane[METHOD_DISTANCE_TO_POINT](remapToVector3(PROP_POINT, pointPy)));
            });
          }
        case METHOD_DISTANCE_TO_SPHERE: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy, spherePy) {
              Sk.ffi.checkMethodArgs(name, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_SPHERE, SPHERE, Sk.ffi.isInstance(spherePy, SPHERE), spherePy);
              return Sk.ffi.numberToFloatPy(plane[METHOD_DISTANCE_TO_SPHERE](Sk.ffi.remapToJs(spherePy)));
            });
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(PLANE);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        var plane = Sk.ffi.remapToJs(selfPy);
        var value = Sk.ffi.remapToJs(valuePy);
        switch (name) {
        default: {
            throw Sk.ffi.err.attribute(name).isNotSetableOnType(PLANE);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var plane = Sk.ffi.remapToJs(selfPy);
        var names = [
            PROP_NORMAL,
            PROP_OFFSET
          ];
        var argsPy = [
            vectorToEuclidean3Py(plane[PROP_NORMAL]),
            Sk.ffi.numberToFloatPy(plane[PROP_CONSTANT])
          ];
        var args = argsPy.map(function (valuePy) {
            return Sk.ffi.remapToJs(Sk.ffh.str(valuePy));
          });
        return Sk.ffi.stringToPy(PLANE + LPAREN + args.join(COMMA + SPACE) + RPAREN);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var plane = Sk.ffi.remapToJs(selfPy);
        var argsPy = [
            vectorToEuclidean3Py(plane[PROP_NORMAL]),
            Sk.ffi.numberToFloatPy(plane[PROP_CONSTANT])
          ];
        var args = argsPy.map(function (valuePy) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(valuePy));
          });
        return Sk.ffi.stringToPy(PLANE + LPAREN + args.join(COMMA + SPACE) + RPAREN);
      });
    }, PLANE, []);
    mod[PROJECTOR] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy) {
        Sk.ffi.checkMethodArgs(PROJECTOR, arguments, 0, 0);
        Sk.ffi.referenceToPy(new THREE[PROJECTOR](), PROJECTOR, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var projector = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case METHOD_PICKING_RAY: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy, vectorPy, cameraPy) {
              Sk.ffi.checkMethodArgs(name, arguments, 2, 2);
              var raycaster = projector[METHOD_PICKING_RAY](remapToVector3(PROP_VECTOR, vectorPy), Sk.ffi.remapToJs(cameraPy));
              return Sk.ffi.callsim(mod[RAYCASTER], Sk.ffi.referenceToPy(raycaster, RAYCASTER));
            });
          }
        case METHOD_PROJECT_VECTOR: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy, vectorPy, cameraPy) {
              Sk.ffi.checkMethodArgs(name, arguments, 2, 2);
              return vectorToEuclidean3Py(projector[METHOD_PROJECT_VECTOR](remapToVector3(PROP_VECTOR, vectorPy), Sk.ffi.remapToJs(cameraPy)));
            });
          }
        case METHOD_UNPROJECT_VECTOR: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy, vectorPy, cameraPy) {
              Sk.ffi.checkMethodArgs(name, arguments, 2, 2);
              return vectorToEuclidean3Py(projector[METHOD_UNPROJECT_VECTOR](remapToVector3(PROP_VECTOR, vectorPy), Sk.ffi.remapToJs(cameraPy)));
            });
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(PROJECTOR);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        var raycaster = Sk.ffi.remapToJs(selfPy);
        var value = Sk.ffi.remapToJs(valuePy);
        switch (name) {
        default: {
            throw Sk.ffi.err.attribute(name).isNotSetableOnType(PROJECTOR);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffi.stringToPy(PROJECTOR);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        return Sk.ffi.stringToPy(PROJECTOR + LPAREN + RPAREN);
      });
    }, PROJECTOR, []);
    mod[RAY] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, originPy, directionPy) {
        Sk.ffi.checkMethodArgs(RAY, arguments, 1, 2);
        if (Sk.ffi.isInstance(originPy, RAY)) {
          Sk.ffi.referenceToPy(Sk.ffi.remapToJs(originPy), RAY, undefined, selfPy);
        } else {
          Sk.ffi.checkMethodArgs(RAY, arguments, 2, 2);
          var origin = remapToVector3(PROP_ORIGIN, originPy);
          var direction = remapToVector3(PROP_DIRECTION, directionPy);
          Sk.ffi.referenceToPy(new THREE[RAY](origin, direction), RAY, undefined, selfPy);
        }
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var ray = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case PROP_ORIGIN:
        case PROP_DIRECTION: {
            return vectorToEuclidean3Py(ray[name]);
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(RAY);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        var ray = Sk.ffi.remapToJs(selfPy);
        var value = Sk.ffi.remapToJs(valuePy);
        switch (name) {
        default: {
            throw Sk.ffi.err.attribute(name).isNotSetableOnType(RAY);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var names = [
            PROP_ORIGIN,
            PROP_DIRECTION
          ];
        var argsPy = names.map(function (name) {
            return Sk.ffi.gattr(selfPy, name);
          });
        var args = argsPy.map(function (valuePy) {
            return Sk.ffi.remapToJs(Sk.ffh.str(valuePy));
          });
        return Sk.ffi.stringToPy(RAY + LPAREN + args.join(COMMA + SPACE) + RPAREN);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var names = [
            PROP_ORIGIN,
            PROP_DIRECTION
          ];
        var argsPy = names.map(function (name) {
            return Sk.ffi.gattr(selfPy, name);
          });
        var args = argsPy.map(function (valuePy) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(valuePy));
          });
        return Sk.ffi.stringToPy(RAY + LPAREN + args.join(COMMA + SPACE) + RPAREN);
      });
    }, RAY, []);
    mod[RAYCASTER] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, originPy, directionPy, nearPy, farPy) {
        Sk.ffi.checkMethodArgs(RAYCASTER, arguments, 0, 4);
        if (isDefined(originPy) && Sk.ffi.isInstance(originPy, RAYCASTER)) {
          Sk.ffi.referenceToPy(Sk.ffi.remapToJs(originPy), RAYCASTER, undefined, selfPy);
        } else {
          var origin = remapToVector3(PROP_ORIGIN, originPy);
          var direction = remapToVector3(PROP_DIRECTION, directionPy);
          if (isDefined(nearPy)) {
            Sk.ffi.checkArgType(PROP_NEAR, Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(nearPy), nearPy);
          }
          if (isDefined(farPy)) {
            Sk.ffi.checkArgType(PROP_FAR, Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(farPy), farPy);
          }
          var near = Sk.ffi.remapToJs(nearPy);
          var far = Sk.ffi.remapToJs(farPy);
          Sk.ffi.referenceToPy(new THREE[RAYCASTER](origin, direction, near), RAYCASTER, undefined, selfPy);
        }
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var raycaster = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case PROP_RAY: {
            return Sk.ffi.callsim(mod[RAY], Sk.ffi.referenceToPy(raycaster[PROP_RAY], RAY));
          }
        case PROP_NEAR:
        case PROP_FAR: {
            return Sk.ffi.numberToFloatPy(raycaster[name]);
          }
        case METHOD_INTERSECT_OBJECTS: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy, objectsPy, recursivePy) {
              Sk.ffi.checkMethodArgs(name, arguments, 1, 2);
              Sk.ffi.checkArgType(PROP_OBJECTS, Sk.ffi.PyType.LIST, Sk.ffi.isList(objectsPy), objectsPy);
              var intersects = raycaster[METHOD_INTERSECT_OBJECTS](Sk.ffi.remapToJs(objectsPy), Sk.ffi.remapToJs(recursivePy));
              return Sk.ffi.listPy(intersects.map(function (x) {
                return Sk.ffi.callsim(mod[INTERSECTION], Sk.ffi.referenceToPy(x, INTERSECTION));
              }));
            });
          }
        case METHOD_SET: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy, originPy, directionPy) {
              Sk.ffi.checkMethodArgs(name, arguments, 2, 2);
              raycaster[METHOD_SET](remapToVector3(PROP_ORIGIN, originPy), remapToVector3(PROP_DIRECTION, directionPy));
              return selfPy;
            });
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(RAYCASTER);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        var raycaster = Sk.ffi.remapToJs(selfPy);
        var value = Sk.ffi.remapToJs(valuePy);
        switch (name) {
        default: {
            throw Sk.ffi.err.attribute(name).isNotSetableOnType(RAYCASTER);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var names = [
            PROP_RAY,
            PROP_NEAR,
            PROP_FAR
          ];
        var argsPy = names.map(function (name) {
            return Sk.ffi.gattr(selfPy, name);
          });
        var args = argsPy.map(function (valuePy) {
            return Sk.ffi.remapToJs(Sk.ffh.str(valuePy));
          });
        return Sk.ffi.stringToPy(RAYCASTER + LPAREN + args.join(COMMA + SPACE) + RPAREN);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var self = Sk.ffi.remapToJs(selfPy);
        var names = [
            PROP_RAY,
            PROP_NEAR,
            PROP_FAR
          ];
        var argsPy = names.map(function (name) {
            return Sk.ffi.gattr(selfPy, name);
          });
        var args = argsPy.map(function (valuePy) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(valuePy));
          });
        return Sk.ffi.stringToPy(RAYCASTER + LPAREN + args.join(COMMA + SPACE) + RPAREN);
      });
    }, RAYCASTER, []);
    mod[SPHERE] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, centerPy, radiusPy) {
        Sk.ffi.checkMethodArgs(SPHERE, arguments, 0, 2);
        var center = remapToVector3(PROP_CENTER, centerPy);
        if (isDefined(radiusPy)) {
          Sk.ffi.checkArgType(PROP_RADIUS, Sk.ffi.PyType.FLOAT, Sk.ffi.isFloat(radiusPy), radiusPy);
        }
        var radius = Sk.ffi.remapToJs(radiusPy);
        Sk.ffi.referenceToPy(new THREE[SPHERE](center, radius), SPHERE, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var sphere = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case PROP_CENTER: {
            return vectorToEuclidean3Py(sphere[PROP_CENTER]);
          }
        case PROP_RADIUS: {
            return Sk.ffi.numberToFloatPy(sphere[PROP_RADIUS]);
          }
        case METHOD_COPY: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy, spherePy) {
              Sk.ffi.checkMethodArgs(name, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_SPHERE, SPHERE, Sk.ffi.isInstance(spherePy, SPHERE), spherePy);
              sphere[METHOD_COPY](Sk.ffi.remapToJs(spherePy));
              return selfPy;
            });
          }
        case METHOD_CONTAINS_POINT: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy, pointPy) {
              Sk.ffi.checkMethodArgs(name, arguments, 1, 1);
              return Sk.ffi.booleanToPy(sphere[METHOD_CONTAINS_POINT](remapToVector3(PROP_POINT, pointPy)));
            });
          }
        case METHOD_DISTANCE_TO_POINT: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy, pointPy) {
              Sk.ffi.checkMethodArgs(name, arguments, 1, 1);
              return Sk.ffi.numberToFloatPy(sphere[METHOD_DISTANCE_TO_POINT](remapToVector3(PROP_POINT, pointPy)));
            });
          }
        case METHOD_INTERSECTS_SPHERE: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy, spherePy) {
              Sk.ffi.checkMethodArgs(name, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_SPHERE, SPHERE, Sk.ffi.isInstance(spherePy, SPHERE), spherePy);
              return Sk.ffi.booleanToPy(sphere[METHOD_INTERSECTS_SPHERE](Sk.ffi.remapToJs(spherePy)));
            });
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(SPHERE);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        var sphere = Sk.ffi.remapToJs(selfPy);
        var value = Sk.ffi.remapToJs(valuePy);
        switch (name) {
        default: {
            throw Sk.ffi.err.attribute(name).isNotSetableOnType(SPHERE);
          }
        }
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var sphere = Sk.ffi.remapToJs(selfPy);
        var names = [
            PROP_CENTER,
            PROP_RADIUS
          ];
        var argsPy = [
            vectorToEuclidean3Py(sphere[PROP_CENTER]),
            Sk.ffi.numberToFloatPy(sphere[PROP_RADIUS])
          ];
        var args = argsPy.map(function (valuePy) {
            return Sk.ffi.remapToJs(Sk.ffh.str(valuePy));
          });
        return Sk.ffi.stringToPy(SPHERE + LPAREN + args.join(COMMA + SPACE) + RPAREN);
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var sphere = Sk.ffi.remapToJs(selfPy);
        var argsPy = [
            vectorToEuclidean3Py(sphere[PROP_CENTER]),
            Sk.ffi.numberToFloatPy(sphere[PROP_RADIUS])
          ];
        var args = argsPy.map(function (valuePy) {
            return Sk.ffi.remapToJs(Sk.ffh.repr(valuePy));
          });
        return Sk.ffi.stringToPy(SPHERE + LPAREN + args.join(COMMA + SPACE) + RPAREN);
      });
    }, SPHERE, []);
    if (isDefined(THREE)) {
      mod.LineStrip = Sk.ffi.numberToIntPy(THREE.LineStrip);
      mod.LinePieces = Sk.ffi.numberToIntPy(THREE.LinePieces);
      mod.FlatShading = Sk.ffi.numberToIntPy(THREE.FlatShading);
      mod.NoShading = Sk.ffi.numberToIntPy(THREE.NoShading);
      mod.SmoothShading = Sk.ffi.numberToIntPy(THREE.SmoothShading);
      mod.NoColors = Sk.ffi.numberToIntPy(THREE.NoColors);
      mod.FaceColors = Sk.ffi.numberToIntPy(THREE.FaceColors);
      mod.VertexColors = Sk.ffi.numberToIntPy(THREE.VertexColors);
      mod.FrontSide = Sk.ffi.numberToIntPy(THREE.FrontSide);
      mod.BackSide = Sk.ffi.numberToIntPy(THREE.BackSide);
      mod.DoubleSide = Sk.ffi.numberToIntPy(THREE.DoubleSide);
    }
  };
}.call(this));
(function () {
  var stringFromCoordinates = function (coordinates, labels) {
    var append, i, sb, str, _i, _ref;
    sb = [];
    append = function (number, label) {
      var n;
      if (number !== 0) {
        if (number >= 0) {
          if (sb.length > 0) {
            sb.push('+');
          }
        } else {
          sb.push('-');
        }
        n = Math.abs(number);
        if (n === 1) {
          return sb.push(label);
        } else {
          sb.push(n.toString());
          if (label !== '1') {
            sb.push('*');
            return sb.push(label);
          }
        }
      }
    };
    for (i = _i = 0, _ref = coordinates.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      append(coordinates[i], labels[i]);
    }
    if (sb.length > 0) {
      str = sb.join('');
    } else {
      str = '0';
    }
    return str;
  };
  var VECTOR_3 = 'Vector3';
  var PROP_X = 'x';
  var PROP_Y = 'y';
  var PROP_Z = 'z';
  var NUMBER = [
      Sk.ffi.PyType.FLOAT,
      Sk.ffi.PyType.INT,
      Sk.ffi.PyType.LONG
    ];
  var INT = Sk.ffi.PyType.INT;
  var QUATERNION = 'Quaternion';
  var METHOD_APPLY_QUATERNION = 'applyQuaternion';
  var METHOD_CLONE = 'clone';
  var METHOD_GET_COMPONENT = 'getComponent';
  var METHOD_MAGNITUDE = 'magnitude';
  var METHOD_NORMALIZE = 'normalize';
  var METHOD_SET = 'set';
  var METHOD_SET_COMPONENT = 'setComponent';
  var METHOD_SET_X = 'setX';
  var METHOD_SET_Y = 'setY';
  var METHOD_SET_Z = 'setZ';
  var OP_ADD = 'add';
  var OP_SUB = 'subtract';
  var OP_MUL = 'multiply';
  var OP_DIV = 'divide';
  var OP_EQ = 'equal';
  Sk.builtin.defineVector3 = function (mod, THREE) {
    Sk.ffi.checkFunctionArgs('defineVector3', arguments, 2, 2);
    var isQuaternionPy = function (valuePy) {
      return Sk.ffi.isInstance(valuePy, QUATERNION);
    };
    var isVector3Py = function (valuePy) {
      return Sk.ffi.isInstance(valuePy, VECTOR_3);
    };
    var xyzJsToVector3Py = function (x, y, z) {
      return Sk.ffi.callsim(mod[VECTOR_3], Sk.ffi.numberToFloatPy(x), Sk.ffi.numberToFloatPy(y), Sk.ffi.numberToFloatPy(z));
    };
    mod[VECTOR_3] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, x, y, z) {
        Sk.ffi.checkMethodArgs(VECTOR_3, arguments, 0, 4);
        if (Sk.ffi.isUndefined(x) && Sk.ffi.isUndefined(y) && Sk.ffi.isUndefined(z)) {
          Sk.ffi.referenceToPy(new THREE[VECTOR_3](), VECTOR_3, undefined, selfPy);
        } else {
          switch (Sk.ffi.getType(x)) {
          case Sk.ffi.PyType.INSTANCE: {
              Sk.ffi.checkMethodArgs(VECTOR_3, arguments, 1, 1);
              Sk.ffi.checkArgType(PROP_X, VECTOR_3, isVector3Py(x), x);
              Sk.ffi.referenceToPy(Sk.ffi.remapToJs(x), VECTOR_3, undefined, selfPy);
            }
            break;
          case Sk.ffi.PyType.FLOAT:
          case Sk.ffi.PyType.INT:
          case Sk.ffi.PyType.LONG: {
              Sk.ffi.checkMethodArgs(VECTOR_3, arguments, 3, 3);
              Sk.ffi.checkArgType(PROP_X, NUMBER, Sk.ffi.isNum(x), x);
              Sk.ffi.checkArgType(PROP_Y, NUMBER, Sk.ffi.isNum(y), y);
              Sk.ffi.checkArgType(PROP_Z, NUMBER, Sk.ffi.isNum(z), z);
              Sk.ffi.referenceToPy(new THREE[VECTOR_3](Sk.ffi.remapToJs(x), Sk.ffi.remapToJs(y), Sk.ffi.remapToJs(z)), VECTOR_3, undefined, selfPy);
            }
            break;
          default: {
              Sk.ffi.checkArgType(PROP_X, [
                NUMBER,
                VECTOR_3
              ], false, x);
            }
          }
        }
      });
      $loc.__add__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkLhsOperandType(OP_ADD, VECTOR_3, isVector3Py(selfPy), selfPy);
        Sk.ffi.checkRhsOperandType(OP_ADD, VECTOR_3, isVector3Py(otherPy), otherPy);
        var a = Sk.ffi.remapToJs(selfPy);
        var b = Sk.ffi.remapToJs(otherPy);
        var x = a.x + b.x;
        var y = a.y + b.y;
        var z = a.z + b.z;
        return xyzJsToVector3Py(x, y, z);
      });
      $loc.__iadd__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkLhsOperandType(OP_ADD, VECTOR_3, isVector3Py(selfPy), selfPy);
        Sk.ffi.checkRhsOperandType(OP_ADD, VECTOR_3, isVector3Py(otherPy), otherPy);
        var a = Sk.ffi.remapToJs(selfPy);
        var b = Sk.ffi.remapToJs(otherPy);
        a.x += b.x;
        a.y += b.y;
        a.z += b.z;
        return selfPy;
      });
      $loc.__sub__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkLhsOperandType(OP_SUB, VECTOR_3, isVector3Py(selfPy), selfPy);
        Sk.ffi.checkRhsOperandType(OP_SUB, VECTOR_3, isVector3Py(otherPy), otherPy);
        var a = Sk.ffi.remapToJs(selfPy);
        var b = Sk.ffi.remapToJs(otherPy);
        var x = a.x - b.x;
        var y = a.y - b.y;
        var z = a.z - b.z;
        return xyzJsToVector3Py(x, y, z);
      });
      $loc.__isub__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkLhsOperandType(OP_ADD, VECTOR_3, isVector3Py(selfPy), selfPy);
        Sk.ffi.checkRhsOperandType(OP_ADD, VECTOR_3, isVector3Py(otherPy), otherPy);
        var a = Sk.ffi.remapToJs(selfPy);
        var b = Sk.ffi.remapToJs(otherPy);
        a.x -= b.x;
        a.y -= b.y;
        a.z -= b.z;
        return selfPy;
      });
      $loc.__mul__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkLhsOperandType(OP_MUL, VECTOR_3, isVector3Py(selfPy), selfPy);
        Sk.ffi.checkRhsOperandType(OP_MUL, NUMBER, Sk.ffi.isNum(otherPy), otherPy);
        var a = Sk.ffi.remapToJs(selfPy);
        var b = Sk.ffi.remapToJs(otherPy);
        var x = a.x * b;
        var y = a.y * b;
        var z = a.z * b;
        return xyzJsToVector3Py(x, y, z);
      });
      $loc.__rmul__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkLhsOperandType(OP_MUL, NUMBER, Sk.ffi.isNum(otherPy), otherPy);
        Sk.ffi.checkRhsOperandType(OP_MUL, VECTOR_3, isVector3Py(selfPy), selfPy);
        var a = Sk.ffi.remapToJs(otherPy);
        var b = Sk.ffi.remapToJs(selfPy);
        var x = a * b.x;
        var y = a * b.y;
        var z = a * b.z;
        return xyzJsToVector3Py(x, y, z);
      });
      $loc.__div__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkLhsOperandType(OP_DIV, VECTOR_3, isVector3Py(selfPy), selfPy);
        Sk.ffi.checkRhsOperandType(OP_DIV, NUMBER, Sk.ffi.isNum(otherPy), otherPy);
        var a = Sk.ffi.remapToJs(selfPy);
        var b = Sk.ffi.remapToJs(otherPy);
        var x = a.x / b;
        var y = a.y / b;
        var z = a.z / b;
        return xyzJsToVector3Py(x, y, z);
      });
      $loc.__rdiv__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkLhsOperandType(OP_DIV, NUMBER, Sk.ffi.isNum(otherPy), otherPy);
        Sk.ffi.checkRhsOperandType(OP_DIV, VECTOR_3, isVector3Py(selfPy), selfPy);
        var a = Sk.ffi.remapToJs(otherPy);
        var b = Sk.ffi.remapToJs(selfPy);
        var x = b.x / a;
        var y = b.y / a;
        var z = b.z / a;
        return xyzJsToVector3Py(x, y, z);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (vectorPy, name) {
        var vector = Sk.ffi.remapToJs(vectorPy);
        switch (name) {
        case PROP_X:
        case PROP_Y:
        case PROP_Z: {
            return Sk.ffi.numberToFloatPy(vector[name]);
          }
        case METHOD_APPLY_QUATERNION: {
            return Sk.ffi.callableToPy(mod, METHOD_APPLY_QUATERNION, function (methodPy, qPy) {
              Sk.ffi.checkMethodArgs(METHOD_APPLY_QUATERNION, arguments, 1, 1);
              Sk.ffi.checkArgType('q', QUATERNION, isQuaternionPy(qPy), qPy);
              vector[METHOD_APPLY_QUATERNION](Sk.ffi.remapToJs(qPy));
              return vectorPy;
            });
          }
        case METHOD_CLONE: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (self) {
                self.tp$name = METHOD_CLONE;
              });
              $loc.__call__ = Sk.ffi.functionPy(function (self) {
                return xyzJsToVector3Py(vector.x, vector.y, vector.z);
              });
            }, METHOD_CLONE, []));
          }
        case METHOD_GET_COMPONENT: {
            return Sk.ffi.callableToPy(mod, METHOD_GET_COMPONENT, function (methodPy, indexPy) {
              Sk.ffi.checkMethodArgs(METHOD_GET_COMPONENT, arguments, 1, 1);
              Sk.ffi.checkArgType('index', INT, Sk.ffi.isNum(indexPy), indexPy);
              return Sk.ffi.numberToFloatPy(vector[METHOD_GET_COMPONENT](Sk.ffi.remapToJs(indexPy)));
            });
          }
        case METHOD_MAGNITUDE: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (self) {
                self.tp$name = METHOD_MAGNITUDE;
              });
              $loc.__call__ = Sk.ffi.functionPy(function (self) {
                return Sk.ffi.numberToFloatPy(vector.length());
              });
            }, METHOD_MAGNITUDE, []));
          }
        case METHOD_NORMALIZE: {
            return Sk.ffi.callsim(Sk.ffi.buildClass(mod, function ($gbl, $loc) {
              $loc.__init__ = Sk.ffi.functionPy(function (self) {
                self.tp$name = METHOD_NORMALIZE;
              });
              $loc.__call__ = Sk.ffi.functionPy(function (self) {
                Sk.ffi.checkMethodArgs(VECTOR_3, arguments, 0, 0);
                vector[METHOD_NORMALIZE]();
                return vectorPy;
              });
            }, METHOD_NORMALIZE, []));
          }
        case METHOD_SET: {
            return Sk.ffi.callableToPy(mod, METHOD_SET, function (methodPy, x, y, z) {
              Sk.ffi.checkMethodArgs(METHOD_SET, arguments, 3, 3);
              Sk.ffi.checkArgType(PROP_X, NUMBER, Sk.ffi.isNum(x), x);
              Sk.ffi.checkArgType(PROP_Y, NUMBER, Sk.ffi.isNum(y), y);
              Sk.ffi.checkArgType(PROP_Z, NUMBER, Sk.ffi.isNum(z), z);
              x = Sk.ffi.remapToJs(x);
              y = Sk.ffi.remapToJs(y);
              z = Sk.ffi.remapToJs(z);
              vector.set(x, y, z);
              return vectorPy;
            });
          }
        case METHOD_SET_COMPONENT: {
            return Sk.ffi.callableToPy(mod, METHOD_SET_COMPONENT, function (methodPy, indexPy, valuePy) {
              Sk.ffi.checkMethodArgs(METHOD_SET_COMPONENT, arguments, 2, 2);
              Sk.ffi.checkArgType('index', INT, Sk.ffi.isInt(indexPy), indexPy);
              Sk.ffi.checkArgType('value', NUMBER, Sk.ffi.isNum(valuePy), valuePy);
              var index = Sk.ffi.remapToJs(indexPy);
              var value = Sk.ffi.remapToJs(valuePy);
              vector[METHOD_SET_COMPONENT](index, value);
              return vectorPy;
            });
          }
        case METHOD_SET_X:
        case METHOD_SET_Y:
        case METHOD_SET_Z: {
            return Sk.ffi.callableToPy(mod, name, function (methodPy, valuePy) {
              Sk.ffi.checkMethodArgs(name, arguments, 1, 1);
              Sk.ffi.checkArgType('value', NUMBER, Sk.ffi.isNum(valuePy), valuePy);
              vector[name](Sk.ffi.remapToJs(valuePy));
              return vectorPy;
            });
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(VECTOR_3);
          }
        }
      });
      $loc.__setattr__ = Sk.ffi.functionPy(function (selfPy, name, valuePy) {
        switch (name) {
        case PROP_X:
        case PROP_Y:
        case PROP_Z: {
            Sk.ffi.checkArgType(name, NUMBER, Sk.ffi.isNum(valuePy), valuePy);
            var vector = Sk.ffi.remapToJs(selfPy);
            vector[name] = Sk.ffi.remapToJs(valuePy);
          }
          break;
        default: {
            throw Sk.ffi.err.attribute(name).isNotSetableOnType(VECTOR_3);
          }
        }
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (selfPy) {
        var vector = Sk.ffi.remapToJs(selfPy);
        var args = [
            vector.x,
            vector.y,
            vector.z
          ];
        return Sk.ffi.stringToPy(VECTOR_3 + '(' + args.join(', ') + ')');
      });
      $loc.__str__ = Sk.ffi.functionPy(function (selfPy) {
        var vector = Sk.ffi.remapToJs(selfPy);
        return Sk.ffi.stringToPy(stringFromCoordinates([
          vector.x,
          vector.y,
          vector.z
        ], [
          'i',
          'j',
          'k'
        ]));
      });
    }, VECTOR_3, []);
  };
}.call(this));
(function () {
  var NUMBER = 'Number';
  var PROP_NUMERATOR = 'numerator';
  var PROP_NUMER = 'numer';
  var PROP_DENOMINATOR = 'denominator';
  var PROP_DENOM = 'denom';
  var ARG_OTHER = 'other';
  var OP_ADD = 'add';
  var OP_SUB = 'subtract';
  var OP_MUL = 'multiply';
  var OP_DIV = 'divide';
  var OP_EQ = 'equal';
  var DENOMINATOR_ZERO = 'denominator must not be zero';
  Sk.builtin.defineFractions = function (mod, RATIONAL, factory) {
    Sk.ffi.checkFunctionArgs('defineFractions', arguments, 3, 3);
    var isRational = function (valuePy) {
      return Sk.ffi.isInstance(valuePy, RATIONAL);
    };
    var RATIONAL_OR_INT = [
        RATIONAL,
        Sk.ffi.PyType.INT
      ];
    var rationalToPy = function (numerator, denominator) {
      return Sk.ffi.callsim(mod[RATIONAL], Sk.ffi.numberToFloatPy(numerator), Sk.ffi.numberToFloatPy(denominator));
    };
    mod[RATIONAL] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, numerPy, denomPy) {
        if (!Sk.ffi.isUndefined(denomPy)) {
          Sk.ffi.checkMethodArgs(RATIONAL, arguments, 2, 2);
          Sk.ffi.checkArgType(PROP_NUMERATOR, Sk.ffi.PyType.INT, Sk.ffi.isInt(numerPy), numerPy);
          Sk.ffi.checkArgType(PROP_DENOMINATOR, Sk.ffi.PyType.INT, Sk.ffi.isInt(denomPy), denomPy);
          var numer = Sk.ffi.remapToJs(numerPy);
          var denom = Sk.ffi.remapToJs(denomPy);
          if (denom != 0) {
            Sk.ffi.referenceToPy(factory(numer, denom), RATIONAL, undefined, selfPy);
          } else {
            throw new Sk.builtin.ZeroDivisionError(DENOMINATOR_ZERO);
          }
        } else {
          if (Sk.ffi.isUndefined(numerPy)) {
            Sk.ffi.referenceToPy(factory(0, 1), RATIONAL, undefined, selfPy);
          } else {
            if (isRational(numerPy)) {
              Sk.ffi.checkMethodArgs(RATIONAL, arguments, 1, 1);
              Sk.ffi.referenceToPy(Sk.ffi.remapToJs(numerPy), RATIONAL, undefined, selfPy);
            } else if (Sk.ffi.isNum(numerPy)) {
              Sk.ffi.checkArgType(PROP_NUMERATOR, Sk.ffi.PyType.INT, Sk.ffi.isInt(numerPy), numerPy);
              var numer = Sk.ffi.remapToJs(numerPy);
              Sk.ffi.referenceToPy(factory(numer, 1), RATIONAL, undefined, selfPy);
            } else {
              Sk.ffi.checkMethodArgs(RATIONAL, arguments, 2, 2);
            }
          }
        }
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var rational = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case PROP_NUMER:
        case PROP_NUMERATOR: {
            return Sk.ffi.numberToIntPy(rational.numer);
          }
        case PROP_DENOM:
        case PROP_DENOMINATOR: {
            return Sk.ffi.numberToIntPy(rational.denom);
          }
        default: {
            throw Sk.ffi.err.attribute(name).isNotGetableOnType(RATIONAL);
          }
        }
      });
      $loc.__add__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkRhsOperandType(OP_ADD, RATIONAL_OR_INT, isRational(otherPy) || Sk.ffi.isInt(otherPy), otherPy);
        var a = Sk.ffi.remapToJs(selfPy);
        var b = Sk.ffi.remapToJs(otherPy);
        return Sk.ffi.callsim(mod[RATIONAL], Sk.ffi.referenceToPy(a.add(b), RATIONAL));
      });
      $loc.__radd__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkLhsOperandType(OP_ADD, RATIONAL_OR_INT, Sk.ffi.isInt(otherPy), otherPy);
        var self = Sk.ffi.remapToJs(selfPy);
        var other = factory(Sk.ffi.remapToJs(otherPy), 1);
        return Sk.ffi.callsim(mod[RATIONAL], Sk.ffi.referenceToPy(other.add(self), RATIONAL));
      });
      $loc.__sub__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkRhsOperandType(OP_SUB, RATIONAL_OR_INT, isRational(otherPy) || Sk.ffi.isInt(otherPy), otherPy);
        var a = Sk.ffi.remapToJs(selfPy);
        var b = Sk.ffi.remapToJs(otherPy);
        return Sk.ffi.callsim(mod[RATIONAL], Sk.ffi.referenceToPy(a.sub(b), RATIONAL));
      });
      $loc.__rsub__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkLhsOperandType(OP_SUB, RATIONAL_OR_INT, Sk.ffi.isInt(otherPy), otherPy);
        var self = Sk.ffi.remapToJs(selfPy);
        var other = factory(Sk.ffi.remapToJs(otherPy), 1);
        return Sk.ffi.callsim(mod[RATIONAL], Sk.ffi.referenceToPy(other.sub(self), RATIONAL));
      });
      $loc.__mul__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        switch (Sk.ffi.getType(otherPy)) {
        case Sk.ffi.PyType.INSTANCE: {
            switch (Sk.ffi.typeName(otherPy)) {
            case RATIONAL: {
                var a = Sk.ffi.remapToJs(selfPy);
                var b = Sk.ffi.remapToJs(otherPy);
                return Sk.ffi.callsim(mod[RATIONAL], Sk.ffi.referenceToPy(a.mul(b), RATIONAL));
              }
            default: {
                return undefined;
              }
            }
          }
        case Sk.ffi.PyType.INT: {
            var a = Sk.ffi.remapToJs(selfPy);
            var b = Sk.ffi.remapToJs(otherPy);
            return Sk.ffi.callsim(mod[RATIONAL], Sk.ffi.numberToIntPy(a.numer * b), Sk.ffi.numberToIntPy(a.denom));
          }
        default: {
            return undefined;
          }
        }
      });
      $loc.__rmul__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkLhsOperandType(OP_MUL, RATIONAL_OR_INT, Sk.ffi.isInt(otherPy), otherPy);
        var self = Sk.ffi.remapToJs(selfPy);
        var other = factory(Sk.ffi.remapToJs(otherPy), 1);
        return Sk.ffi.callsim(mod[RATIONAL], Sk.ffi.referenceToPy(other.mul(self), RATIONAL));
      });
      $loc.__div__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        var numer = Sk.ffi.remapToJs(selfPy);
        var denom = Sk.ffi.remapToJs(otherPy);
        if (Sk.ffi.isNum(otherPy)) {
          Sk.ffi.checkRhsOperandType(OP_DIV, RATIONAL_OR_INT, Sk.ffi.isInt(otherPy), otherPy);
          if (denom != 0) {
            return Sk.ffi.callsim(mod[RATIONAL], Sk.ffi.numberToIntPy(numer.numer), Sk.ffi.numberToIntPy(numer.denom * denom));
          } else {
            throw new Sk.builtin.ZeroDivisionError(DENOMINATOR_ZERO);
          }
        } else {
          Sk.ffi.checkRhsOperandType(OP_DIV, RATIONAL_OR_INT, isRational(otherPy), otherPy);
          if (denom.numer != 0) {
            return Sk.ffi.callsim(mod[RATIONAL], Sk.ffi.referenceToPy(numer.div(denom), RATIONAL));
          } else {
            throw new Sk.builtin.ZeroDivisionError(DENOMINATOR_ZERO);
          }
        }
      });
      $loc.__rdiv__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkLhsOperandType(OP_DIV, RATIONAL_OR_INT, Sk.ffi.isInt(otherPy), otherPy);
        var self = Sk.ffi.remapToJs(selfPy);
        var other = factory(Sk.ffi.remapToJs(otherPy), 1);
        if (self.numer != 0) {
          return Sk.ffi.callsim(mod[RATIONAL], Sk.ffi.referenceToPy(other.div(self), RATIONAL));
        } else {
          throw new Sk.builtin.ZeroDivisionError(DENOMINATOR_ZERO);
        }
      });
      $loc.__eq__ = Sk.ffi.functionPy(function (selfPy, otherPy) {
        Sk.ffi.checkFunctionArgs(OP_EQ, arguments, 2, 2);
        if (isRational(selfPy) && isRational(otherPy)) {
          var a = Sk.ffi.remapToJs(selfPy);
          var b = Sk.ffi.remapToJs(otherPy);
          return Sk.ffi.booleanToPy(a.equals(b));
        } else {
          return Sk.ffi.bool.False;
        }
      });
      $loc.__repr__ = Sk.ffi.functionPy(function (rationalPy) {
        var rational = Sk.ffi.remapToJs(rationalPy);
        return Sk.ffi.stringToPy(RATIONAL + '(' + rational.numer + ',' + rational.denom + ')');
      });
      $loc.__str__ = Sk.ffi.functionPy(function (rationalPy) {
        var rational = Sk.ffi.remapToJs(rationalPy);
        return Sk.ffi.stringToPy('' + rational);
      });
    }, RATIONAL, []);
  };
}.call(this));
(function () {
  Sk.builtin.defineWorkbench = function (mod) {
    Sk.ffi.checkFunctionArgs('defineWorkbench', arguments, 1, 1);
    var WORKBENCH_2D = 'Workbench2D';
    var WORKBENCH_3D = 'Workbench3D';
    var WORKBENCH = 'Workbench';
    var PROP_CANVAS = 'canvas';
    var METHOD_SET_UP = 'setUp';
    var METHOD_TEAR_DOWN = 'tearDown';
    var METHOD_UPDATE_PROJECTION_MATRIX = 'updateProjectionMatrix';
    var TAG_NAME_CANVAS = 'canvas';
    function removeElementsByTagName(tagName) {
      var elements = document.getElementsByTagName(tagName);
      for (var i = elements.length - 1; i >= 0; i--) {
        var e = elements[i];
        e.parentNode.removeChild(e);
      }
    }
    mod[WORKBENCH_2D] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, canvasPy) {
        Sk.ffi.checkMethodArgs(WORKBENCH_2D, arguments, 1, 1);
        Sk.ffi.checkArgType(PROP_CANVAS, [Sk.ffi.PyType.OBJECT], Sk.ffi.isObject(canvasPy) || Sk.ffi.isInstance(canvasPy), canvasPy);
        var canvas = Sk.ffi.remapToJs(canvasPy);
        function onWindowResize(event) {
          var width = window.innerWidth;
          var height = window.innerHeight;
          canvas.width = width;
          canvas.height = height;
        }
        Sk.ffi.referenceToPy({
          'canvas': canvas,
          'onWindowResize': onWindowResize
        }, WORKBENCH_2D, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var workbench = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case METHOD_SET_UP: {
            return Sk.ffi.callableToPy(mod, METHOD_SET_UP, function (methodPy) {
              Sk.ffi.checkMethodArgs(METHOD_SET_UP, arguments, 0, 0);
              document.body.insertBefore(workbench.canvas, document.body.firstChild);
              window.addEventListener('resize', workbench.onWindowResize, false);
              workbench.onWindowResize(null);
            });
          }
        case METHOD_TEAR_DOWN: {
            return Sk.ffi.callableToPy(mod, METHOD_TEAR_DOWN, function (methodPy) {
              window.removeEventListener('resize', workbench.onWindowResize, false);
              removeElementsByTagName(TAG_NAME_CANVAS);
            });
          }
        }
      });
    }, WORKBENCH_2D, []);
    mod[WORKBENCH_3D] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, canvasPy, rendererPy, cameraPy) {
        Sk.ffi.checkMethodArgs(WORKBENCH_3D, arguments, 3, 3);
        Sk.ffi.checkArgType(PROP_CANVAS, 'Element', Sk.ffi.isInstance(canvasPy), canvasPy);
        var canvas = Sk.ffi.remapToJs(canvasPy);
        var renderer = Sk.ffi.remapToJs(rendererPy);
        var camera = Sk.ffi.remapToJs(cameraPy);
        function onWindowResize(event) {
          var width = window.innerWidth;
          var height = window.innerHeight;
          renderer.setSize(width, height);
          camera.aspect = width / height;
          camera[METHOD_UPDATE_PROJECTION_MATRIX]();
        }
        Sk.ffi.referenceToPy({
          'canvas': canvas,
          'renderer': renderer,
          'camera': camera,
          'onWindowResize': onWindowResize
        }, WORKBENCH_3D, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var workbench = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case METHOD_SET_UP: {
            return Sk.ffi.callableToPy(mod, METHOD_SET_UP, function (methodPy) {
              document.body.insertBefore(workbench.canvas, document.body.firstChild);
              window.addEventListener('resize', workbench.onWindowResize, false);
              workbench.onWindowResize(null);
            });
          }
        case METHOD_TEAR_DOWN: {
            return Sk.ffi.callableToPy(mod, METHOD_TEAR_DOWN, function (methodPy) {
              window.removeEventListener('resize', workbench.onWindowResize, false);
              removeElementsByTagName(TAG_NAME_CANVAS);
            });
          }
        }
      });
    }, WORKBENCH_3D, []);
    mod[WORKBENCH] = Sk.ffi.buildClass(mod, function ($gbl, $loc) {
      $loc.__init__ = Sk.ffi.functionPy(function (selfPy, rendererPy, cameraPy) {
        Sk.ffi.checkMethodArgs(WORKBENCH, arguments, 2, 2);
        var renderer = Sk.ffi.remapToJs(rendererPy);
        var camera = Sk.ffi.remapToJs(cameraPy);
        function onWindowResize(event) {
          var width = window.innerWidth;
          var height = window.innerHeight;
          renderer.setSize(width, height);
          camera.aspect = width / height;
          camera[METHOD_UPDATE_PROJECTION_MATRIX]();
        }
        Sk.ffi.referenceToPy({
          'renderer': renderer,
          'camera': camera,
          'onWindowResize': onWindowResize
        }, WORKBENCH, undefined, selfPy);
      });
      $loc.__getattr__ = Sk.ffi.functionPy(function (selfPy, name) {
        var workbench = Sk.ffi.remapToJs(selfPy);
        switch (name) {
        case METHOD_SET_UP: {
            return Sk.ffi.callableToPy(mod, METHOD_SET_UP, function (methodPy) {
              document.body.insertBefore(workbench.renderer['domElement'], document.body.firstChild);
              window.addEventListener('resize', workbench.onWindowResize, false);
              workbench.onWindowResize(null);
            });
          }
        case METHOD_TEAR_DOWN: {
            return Sk.ffi.callableToPy(mod, METHOD_TEAR_DOWN, function (methodPy) {
              window.removeEventListener('resize', workbench.onWindowResize, false);
              removeElementsByTagName(TAG_NAME_CANVAS);
            });
          }
        }
      });
    }, WORKBENCH, []);
  };
}.call(this));
(function () {
  this.BLADE = this.BLADE || {};
}.call(this));
(function () {
  var BLADE, Dimensions, stringify;
  this.BLADE = this.BLADE || {};
  BLADE = this.BLADE;
  stringify = function (rational, label) {
    if (rational.numer === 0) {
      return null;
    } else if (rational.denom === 1) {
      if (rational.numer === 1) {
        return '' + label;
      } else {
        return '' + label + ' ** ' + rational.numer;
      }
    } else {
    }
    return '' + label + ' ** ' + rational;
  };
  Dimensions = function () {
    function Dimensions(mass, length, time, charge, temperature, amount, intensity) {
      if (typeof mass === 'number') {
        this.M = new BLADE.Rational(mass, 1);
      } else if (mass instanceof BLADE.Rational) {
        this.M = mass;
      } else {
        throw new Error('mass must be a Rational or number');
      }
      if (typeof length === 'number') {
        this.L = new BLADE.Rational(length, 1);
      } else {
        this.L = length;
      }
      if (typeof time === 'number') {
        this.T = new BLADE.Rational(time, 1);
      } else {
        this.T = time;
      }
      if (typeof charge === 'number') {
        this.Q = new BLADE.Rational(charge, 1);
      } else if (charge instanceof BLADE.Rational) {
        this.Q = charge;
      } else {
        throw {
          name: 'DimensionError',
          message: 'charge must be a Rational or number'
        };
      }
      if (typeof temperature === 'number') {
        this.temperature = new BLADE.Rational(temperature, 1);
      } else if (temperature instanceof BLADE.Rational) {
        this.temperature = temperature;
      } else {
        throw {
          name: 'DimensionError',
          message: '(thermodynamic) temperature must be a Rational or number'
        };
      }
      if (typeof amount === 'number') {
        this.amount = new BLADE.Rational(amount, 1);
      } else if (amount instanceof BLADE.Rational) {
        this.amount = amount;
      } else {
        throw {
          name: 'DimensionError',
          message: 'amount (of substance) must be a Rational or number'
        };
      }
      if (typeof intensity === 'number') {
        this.intensity = new BLADE.Rational(intensity, 1);
      } else if (intensity instanceof BLADE.Rational) {
        this.intensity = intensity;
      } else {
        throw {
          name: 'DimensionError',
          message: '(luminous) intensity must be a Rational or number'
        };
      }
    }
    Dimensions.prototype.compatible = function (rhs) {
      if (this.M.equals(rhs.M) && this.L.equals(rhs.L) && this.T.equals(rhs.T) && this.Q.equals(rhs.Q) && this.temperature.equals(rhs.temperature) && this.amount.equals(rhs.amount) && this.intensity.equals(rhs.intensity)) {
        return this;
      } else {
        throw {
          name: 'DimensionError',
          message: 'Dimensions must be equal (' + this + ', ' + rhs + ')'
        };
      }
    };
    Dimensions.prototype.mul = function (rhs) {
      return new BLADE.Dimensions(this.M.add(rhs.M), this.L.add(rhs.L), this.T.add(rhs.T), this.Q.add(rhs.Q), this.temperature.add(rhs.temperature), this.amount.add(rhs.amount), this.intensity.add(rhs.intensity));
    };
    Dimensions.prototype.div = function (rhs) {
      return new BLADE.Dimensions(this.M.sub(rhs.M), this.L.sub(rhs.L), this.T.sub(rhs.T), this.Q.sub(rhs.Q), this.temperature.sub(rhs.temperature), this.amount.sub(rhs.amount), this.intensity.sub(rhs.intensity));
    };
    Dimensions.prototype.pow = function (exponent) {
      return new BLADE.Dimensions(this.M.mul(exponent), this.L.mul(exponent), this.T.mul(exponent), this.Q.mul(exponent), this.temperature.mul(exponent), this.amount.mul(exponent), this.intensity.mul(exponent));
    };
    Dimensions.prototype.dimensionless = function () {
      return this.M.isZero() && this.L.isZero() && this.T.isZero() && this.Q.isZero() && this.temperature.isZero() && this.amount.isZero() && this.intensity.isZero();
    };
    Dimensions.prototype.toString = function () {
      return [
        stringify(this.M, 'mass'),
        stringify(this.L, 'length'),
        stringify(this.T, 'time'),
        stringify(this.Q, 'charge'),
        stringify(this.temperature, 'thermodynamic temperature'),
        stringify(this.amount, 'amount of substance'),
        stringify(this.intensity, 'luminous intensity')
      ].filter(function (x) {
        return typeof x === 'string';
      }).join(' * ');
    };
    return Dimensions;
  }();
  this.BLADE.Dimensions = Dimensions;
}.call(this));
(function () {
  var BLADE, Euclidean2, divide;
  this.BLADE = this.BLADE || {};
  BLADE = this.BLADE;
  divide = function (a00, a01, a10, a11, b00, b01, b10, b11, m) {
    var c00, c01, c10, c11, i00, i01, i10, i11, k00, m00, m01, m10, m11, r00, r01, r10, r11, s00, s01, s10, s11, x00, x01, x10, x11;
    r00 = +b00;
    r01 = +b01;
    r10 = +b10;
    r11 = -b11;
    m00 = b00 * r00 + b01 * r01 + b10 * r10 - b11 * r11;
    m01 = 0;
    m10 = 0;
    m11 = 0;
    c00 = +m00;
    c01 = -m01;
    c10 = -m10;
    c11 = -m11;
    s00 = r00 * c00 + r01 * c01 + r10 * c10 - r11 * c11;
    s01 = r00 * c01 + r01 * c00 - r10 * c11 + r11 * c10;
    s10 = r00 * c10 + r01 * c11 + r10 * c00 - r11 * c01;
    s11 = r00 * c11 + r01 * c10 - r10 * c01 + r11 * c00;
    k00 = b00 * s00 + b01 * s01 + b10 * s10 - b11 * s11;
    i00 = s00 / k00;
    i01 = s01 / k00;
    i10 = s10 / k00;
    i11 = s11 / k00;
    x00 = a00 * i00 + a01 * i01 + a10 * i10 - a11 * i11;
    x01 = a00 * i01 + a01 * i00 - a10 * i11 + a11 * i10;
    x10 = a00 * i10 + a01 * i11 + a10 * i00 - a11 * i01;
    x11 = a00 * i11 + a01 * i10 - a10 * i01 + a11 * i00;
    if (typeof m !== 'undefined') {
      m.w = x00;
      m.x = x01;
      m.y = x10;
      return m.xy = x11;
    } else {
      return new BLADE.Euclidean2(x00, x01, x10, x11);
    }
  };
  Euclidean2 = function () {
    function Euclidean2(w, x, y, xy) {
      this.w = w || 0;
      this.x = x;
      this.y = y;
      this.xy = xy;
    }
    Euclidean2.fromCartesian = function (w, x, y, xy) {
      return new BLADE.Euclidean2(w, x, y, xy);
    };
    Euclidean2.fromPolar = function (w, r, theta, s) {
      return new BLADE.Euclidean2(w, r * Math.cos(theta), r * Math.sin(theta), s);
    };
    Euclidean2.prototype.coordinates = function () {
      return [
        this.w,
        this.x,
        this.y,
        this.xy
      ];
    };
    Euclidean2.prototype.coordinate = function (index) {
      switch (index) {
      case 0:
        return this.w;
      case 1:
        return this.x;
      case 2:
        return this.y;
      case 3:
        return this.xy;
      default:
        throw new Error('index must be in the range [0..3]');
      }
    };
    Euclidean2.add = function (a, b) {
      var a00, a01, a10, a11, b00, b01, b10, b11, x00, x01, x10, x11;
      a00 = a[0];
      a01 = a[1];
      a10 = a[2];
      a11 = a[3];
      b00 = b[0];
      b01 = b[1];
      b10 = b[2];
      b11 = b[3];
      x00 = BLADE.e2gaASM.add00(a00, a01, a10, a11, b00, b01, b10, b11);
      x01 = BLADE.e2gaASM.add01(a00, a01, a10, a11, b00, b01, b10, b11);
      x10 = BLADE.e2gaASM.add10(a00, a01, a10, a11, b00, b01, b10, b11);
      x11 = BLADE.e2gaASM.add11(a00, a01, a10, a11, b00, b01, b10, b11);
      return [
        x00,
        x01,
        x10,
        x11
      ];
    };
    Euclidean2.prototype.add = function (rhs) {
      var xs;
      xs = Euclidean2.add(this.coordinates(), rhs.coordinates());
      return new BLADE.Euclidean2(xs[0], xs[1], xs[2], xs[3]);
    };
    Euclidean2.sub = function (a, b) {
      var a0, a1, a2, a3, b0, b1, b2, b3, x0, x1, x2, x3;
      a0 = a[0];
      a1 = a[1];
      a2 = a[2];
      a3 = a[3];
      b0 = b[0];
      b1 = b[1];
      b2 = b[2];
      b3 = b[3];
      x0 = BLADE.bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);
      x1 = BLADE.bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);
      x2 = BLADE.bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);
      x3 = BLADE.bladeASM.subE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);
      return [
        x0,
        x1,
        x2,
        x3
      ];
    };
    Euclidean2.prototype.sub = function (rhs) {
      var xs;
      xs = Euclidean2.sub(this.coordinates(), rhs.coordinates());
      return new BLADE.Euclidean2(xs[0], xs[1], xs[2], xs[3]);
    };
    Euclidean2.mul = function (a, b) {
      var a0, a1, a2, a3, b0, b1, b2, b3, x0, x1, x2, x3;
      a0 = a[0];
      a1 = a[1];
      a2 = a[2];
      a3 = a[3];
      b0 = b[0];
      b1 = b[1];
      b2 = b[2];
      b3 = b[3];
      x0 = BLADE.bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);
      x1 = BLADE.bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);
      x2 = BLADE.bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);
      x3 = BLADE.bladeASM.mulE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);
      return [
        x0,
        x1,
        x2,
        x3
      ];
    };
    Euclidean2.prototype.mul = function (rhs) {
      var xs;
      if (typeof rhs === 'number') {
        return new BLADE.Euclidean2(this.w * rhs, this.x * rhs, this.y * rhs, this.xy * rhs);
      } else {
        xs = Euclidean2.mul(this.coordinates(), rhs.coordinates());
        return new BLADE.Euclidean2(xs[0], xs[1], xs[2], xs[3]);
      }
    };
    Euclidean2.prototype.div = function (rhs) {
      if (typeof rhs === 'number') {
        return new BLADE.Euclidean2(this.w / rhs, this.x / rhs, this.y / rhs, this.xy / rhs);
      } else {
        return divide(this.w, this.x, this.y, this.xy, rhs.w, rhs.x, rhs.y, rhs.xy, void 0);
      }
    };
    Euclidean2.wedge = function (a, b) {
      var a0, a1, a2, a3, b0, b1, b2, b3, x0, x1, x2, x3;
      a0 = a[0];
      a1 = a[1];
      a2 = a[2];
      a3 = a[3];
      b0 = b[0];
      b1 = b[1];
      b2 = b[2];
      b3 = b[3];
      x0 = BLADE.bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);
      x1 = BLADE.bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);
      x2 = BLADE.bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);
      x3 = BLADE.bladeASM.extE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);
      return [
        x0,
        x1,
        x2,
        x3
      ];
    };
    Euclidean2.prototype.wedge = function (rhs) {
      var xs;
      xs = Euclidean2.wedge(this.coordinates(), rhs.coordinates());
      return new BLADE.Euclidean2(xs[0], xs[1], xs[2], xs[3]);
    };
    Euclidean2.lshift = function (a, b) {
      var a0, a1, a2, a3, b0, b1, b2, b3, x0, x1, x2, x3;
      a0 = a[0];
      a1 = a[1];
      a2 = a[2];
      a3 = a[3];
      b0 = b[0];
      b1 = b[1];
      b2 = b[2];
      b3 = b[3];
      x0 = BLADE.bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);
      x1 = BLADE.bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);
      x2 = BLADE.bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);
      x3 = BLADE.bladeASM.lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);
      return [
        x0,
        x1,
        x2,
        x3
      ];
    };
    Euclidean2.prototype.lshift = function (rhs) {
      var xs;
      xs = Euclidean2.lshift(this.coordinates(), rhs.coordinates());
      return new BLADE.Euclidean2(xs[0], xs[1], xs[2], xs[3]);
    };
    Euclidean2.rshift = function (a, b) {
      var a0, a1, a2, a3, b0, b1, b2, b3, x0, x1, x2, x3;
      a0 = a[0];
      a1 = a[1];
      a2 = a[2];
      a3 = a[3];
      b0 = b[0];
      b1 = b[1];
      b2 = b[2];
      b3 = b[3];
      x0 = BLADE.bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 0);
      x1 = BLADE.bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 1);
      x2 = BLADE.bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 2);
      x3 = BLADE.bladeASM.rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, 3);
      return [
        x0,
        x1,
        x2,
        x3
      ];
    };
    Euclidean2.prototype.rshift = function (rhs) {
      var xs;
      xs = Euclidean2.rshift(this.coordinates(), rhs.coordinates());
      return new BLADE.Euclidean2(xs[0], xs[1], xs[2], xs[3]);
    };
    Euclidean2.prototype.grade = function (index) {
      switch (index) {
      case 0:
        return new BLADE.Euclidean2(this.w, 0, 0, 0);
      case 1:
        return new BLADE.Euclidean2(0, this.x, this.y, 0);
      case 2:
        return new BLADE.Euclidean2(0, 0, 0, this.xy);
      default:
        return new BLADE.Euclidean2(0, 0, 0, 0);
      }
    };
    Euclidean2.prototype.quadrance = function () {
      var w, x, xy, y;
      w = this.w;
      x = this.x;
      y = this.y;
      xy = this.xy;
      return w * w + x * x + y * y + xy * xy;
    };
    Euclidean2.prototype.isNaN = function () {
      return isNaN(this.w) || isNaN(this.x) || isNaN(this.y) || isNaN(this.xy);
    };
    Euclidean2.prototype.toString = function () {
      return BLADE.bladeSTR.stringFromCoordinates([
        this.w,
        this.x,
        this.y,
        this.xy
      ], [
        '1',
        'e1',
        'e2',
        'e12'
      ]);
    };
    Euclidean2.prototype.toStringIJK = function () {
      return BLADE.bladeSTR.stringFromCoordinates(this.coordinates(), [
        '1',
        'i',
        'j',
        'I'
      ]);
    };
    Euclidean2.prototype.toStringLATEX = function () {
      return BLADE.bladeSTR.stringFromCoordinates(this.coordinates(), [
        '1',
        'e_{1}',
        'e_{2}',
        'e_{12}'
      ]);
    };
    return Euclidean2;
  }();
  this.BLADE.Euclidean2 = Euclidean2;
}.call(this));
(function () {
  var BLADE, Euclidean3, divide, mulE3;
  this.BLADE = this.BLADE || {};
  BLADE = this.BLADE;
  mulE3 = function (a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, index) {
    var x;
    a0 = +a0;
    a1 = +a1;
    a2 = +a2;
    a3 = +a3;
    a4 = +a4;
    a5 = +a5;
    a6 = +a6;
    a7 = +a7;
    b0 = +b0;
    b1 = +b1;
    b2 = +b2;
    b3 = +b3;
    b4 = +b4;
    b5 = +b5;
    b6 = +b6;
    b7 = +b7;
    index = index | 0;
    x = 0;
    switch (~~index) {
    case 0:
      x = +(a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3 - a4 * b4 - a5 * b5 - a6 * b6 - a7 * b7);
      break;
    case 1:
      x = +(a0 * b1 + a1 * b0 - a2 * b4 + a3 * b6 + a4 * b2 - a5 * b7 - a6 * b3 - a7 * b5);
      break;
    case 2:
      x = +(a0 * b2 + a1 * b4 + a2 * b0 - a3 * b5 - a4 * b1 + a5 * b3 - a6 * b7 - a7 * b6);
      break;
    case 3:
      x = +(a0 * b3 - a1 * b6 + a2 * b5 + a3 * b0 - a4 * b7 - a5 * b2 + a6 * b1 - a7 * b4);
      break;
    case 4:
      x = +(a0 * b4 + a1 * b2 - a2 * b1 + a3 * b7 + a4 * b0 - a5 * b6 + a6 * b5 + a7 * b3);
      break;
    case 5:
      x = +(a0 * b5 + a1 * b7 + a2 * b3 - a3 * b2 + a4 * b6 + a5 * b0 - a6 * b4 + a7 * b1);
      break;
    case 6:
      x = +(a0 * b6 - a1 * b3 + a2 * b7 + a3 * b1 - a4 * b5 + a5 * b4 + a6 * b0 + a7 * b2);
      break;
    case 7:
      x = +(a0 * b7 + a1 * b5 + a2 * b6 + a3 * b4 + a4 * b3 + a5 * b1 + a6 * b2 + a7 * b0);
    }
    return +x;
  };
  divide = function (a000, a001, a010, a011, a100, a101, a110, a111, b000, b001, b010, b011, b100, b101, b110, b111, dst) {
    var c000, c001, c010, c011, c100, c101, c110, c111, i000, i001, i010, i011, i100, i101, i110, i111, k000, m000, m001, m010, m011, m100, m101, m110, m111, r000, r001, r010, r011, r100, r101, r110, r111, s000, s001, s010, s011, s100, s101, s110, s111, w, x, x000, x001, x010, x011, x100, x101, x110, x111, xy, xyz, y, yz, z, zx;
    r000 = +b000;
    r001 = +b001;
    r010 = +b010;
    r011 = -b011;
    r100 = +b100;
    r101 = -b101;
    r110 = -b110;
    r111 = -b111;
    m000 = mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, r000, r001, r010, r100, r011, r110, -r101, r111, 0);
    m001 = mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, r000, r001, r010, r100, r011, r110, -r101, r111, 1);
    m010 = mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, r000, r001, r010, r100, r011, r110, -r101, r111, 2);
    m011 = 0;
    m100 = mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, r000, r001, r010, r100, r011, r110, -r101, r111, 3);
    m101 = 0;
    m110 = 0;
    m111 = 0;
    c000 = +m000;
    c001 = -m001;
    c010 = -m010;
    c011 = -m011;
    c100 = -m100;
    c101 = -m101;
    c110 = -m110;
    c111 = +m111;
    s000 = mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 0);
    s001 = mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 1);
    s010 = mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 2);
    s011 = mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 4);
    s100 = mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 3);
    s101 = -mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 6);
    s110 = mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 5);
    s111 = mulE3(r000, r001, r010, r100, r011, r110, -r101, r111, c000, c001, c010, c100, c011, c110, -c101, c111, 7);
    k000 = mulE3(b000, b001, b010, b100, b011, b110, -b101, b111, s000, s001, s010, s100, s011, s110, -s101, s111, 0);
    i000 = s000 / k000;
    i001 = s001 / k000;
    i010 = s010 / k000;
    i011 = s011 / k000;
    i100 = s100 / k000;
    i101 = s101 / k000;
    i110 = s110 / k000;
    i111 = s111 / k000;
    x000 = mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 0);
    x001 = mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 1);
    x010 = mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 2);
    x011 = mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 4);
    x100 = mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 3);
    x101 = -mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 6);
    x110 = mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 5);
    x111 = mulE3(a000, a001, a010, a100, a011, a110, -a101, a111, i000, i001, i010, i100, i011, i110, -i101, i111, 7);
    w = x000;
    x = x001;
    y = x010;
    z = x100;
    xy = x011;
    yz = x110;
    zx = -x101;
    xyz = x111;
    if (typeof dst !== 'undefined') {
      dst.w = w;
      dst.x = x;
      dst.y = y;
      dst.z = z;
      dst.xy = xy;
      dst.yz = yz;
      dst.zx = zx;
      return dst.xyz = xyz;
    } else {
      return new BLADE.Euclidean3(w, x, y, z, xy, yz, zx, xyz);
    }
  };
  Euclidean3 = function () {
    function Euclidean3(w, x, y, z, xy, yz, zx, xyz) {
      this.w = w || 0;
      this.x = x || 0;
      this.y = y || 0;
      this.z = z || 0;
      this.xy = xy || 0;
      this.yz = yz || 0;
      this.zx = zx || 0;
      this.xyz = xyz || 0;
    }
    Euclidean3.fromCartesian = function (w, x, y, z, xy, yz, zx, xyz) {
      return new BLADE.Euclidean3(w, x, y, z, xy, yz, zx, xyz);
    };
    Euclidean3.prototype.coordinates = function () {
      return [
        this.w,
        this.x,
        this.y,
        this.z,
        this.xy,
        this.yz,
        this.zx,
        this.xyz
      ];
    };
    Euclidean3.prototype.coordinate = function (index) {
      switch (index) {
      case 0:
        return this.w;
      case 1:
        return this.x;
      case 2:
        return this.y;
      case 3:
        return this.z;
      case 4:
        return this.xy;
      case 5:
        return this.yz;
      case 6:
        return this.zx;
      case 7:
        return this.xyz;
      default:
        throw new Error('index must be in the range [0..7]');
      }
    };
    Euclidean3.compute = function (f, a, b, coord, pack) {
      var a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, x0, x1, x2, x3, x4, x5, x6, x7;
      a0 = coord(a, 0);
      a1 = coord(a, 1);
      a2 = coord(a, 2);
      a3 = coord(a, 3);
      a4 = coord(a, 4);
      a5 = coord(a, 5);
      a6 = coord(a, 6);
      a7 = coord(a, 7);
      b0 = coord(b, 0);
      b1 = coord(b, 1);
      b2 = coord(b, 2);
      b3 = coord(b, 3);
      b4 = coord(b, 4);
      b5 = coord(b, 5);
      b6 = coord(b, 6);
      b7 = coord(b, 7);
      x0 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 0);
      x1 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 1);
      x2 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 2);
      x3 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 3);
      x4 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 4);
      x5 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 5);
      x6 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 6);
      x7 = f(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, 7);
      return pack(x0, x1, x2, x3, x4, x5, x6, x7);
    };
    Euclidean3.prototype.add = function (rhs) {
      var coord, pack;
      coord = function (x, n) {
        return x[n];
      };
      pack = function (w, x, y, z, xy, yz, zx, xyz) {
        return Euclidean3.fromCartesian(w, x, y, z, xy, yz, zx, xyz);
      };
      return Euclidean3.compute(BLADE.bladeASM.addE3, [
        this.w,
        this.x,
        this.y,
        this.z,
        this.xy,
        this.yz,
        this.zx,
        this.xyz
      ], [
        rhs.w,
        rhs.x,
        rhs.y,
        rhs.z,
        rhs.xy,
        rhs.yz,
        rhs.zx,
        rhs.xyz
      ], coord, pack);
    };
    Euclidean3.prototype.sub = function (rhs) {
      var coord, pack;
      coord = function (x, n) {
        return x[n];
      };
      pack = function (w, x, y, z, xy, yz, zx, xyz) {
        return Euclidean3.fromCartesian(w, x, y, z, xy, yz, zx, xyz);
      };
      return Euclidean3.compute(BLADE.bladeASM.subE3, [
        this.w,
        this.x,
        this.y,
        this.z,
        this.xy,
        this.yz,
        this.zx,
        this.xyz
      ], [
        rhs.w,
        rhs.x,
        rhs.y,
        rhs.z,
        rhs.xy,
        rhs.yz,
        rhs.zx,
        rhs.xyz
      ], coord, pack);
    };
    Euclidean3.prototype.mul = function (rhs) {
      var coord, pack;
      if (typeof rhs === 'number') {
        return new BLADE.Euclidean3(this.w * rhs, this.x * rhs, this.y * rhs, this.z * rhs, this.xy * rhs, this.yz * rhs, this.zx * rhs, this.xyz * rhs);
      } else {
        coord = function (x, n) {
          return x[n];
        };
        pack = function (w, x, y, z, xy, yz, zx, xyz) {
          return Euclidean3.fromCartesian(w, x, y, z, xy, yz, zx, xyz);
        };
        return Euclidean3.compute(BLADE.bladeASM.mulE3, [
          this.w,
          this.x,
          this.y,
          this.z,
          this.xy,
          this.yz,
          this.zx,
          this.xyz
        ], [
          rhs.w,
          rhs.x,
          rhs.y,
          rhs.z,
          rhs.xy,
          rhs.yz,
          rhs.zx,
          rhs.xyz
        ], coord, pack);
      }
    };
    Euclidean3.prototype.div = function (rhs) {
      if (typeof rhs === 'number') {
        return new BLADE.Euclidean3(this.w / rhs, this.x / rhs, this.y / rhs, this.z / rhs, this.xy / rhs, this.yz / rhs, this.zx / rhs, this.xyz / rhs);
      } else {
        return divide(this.w, this.x, this.y, this.xy, this.z, -this.zx, this.yz, this.xyz, rhs.w, rhs.x, rhs.y, rhs.xy, rhs.z, -rhs.zx, rhs.yz, rhs.xyz, void 0);
      }
    };
    Euclidean3.prototype.wedge = function (rhs) {
      var coord, pack;
      coord = function (x, n) {
        return x[n];
      };
      pack = function (w, x, y, z, xy, yz, zx, xyz) {
        return Euclidean3.fromCartesian(w, x, y, z, xy, yz, zx, xyz);
      };
      return Euclidean3.compute(BLADE.bladeASM.extE3, [
        this.w,
        this.x,
        this.y,
        this.z,
        this.xy,
        this.yz,
        this.zx,
        this.xyz
      ], [
        rhs.w,
        rhs.x,
        rhs.y,
        rhs.z,
        rhs.xy,
        rhs.yz,
        rhs.zx,
        rhs.xyz
      ], coord, pack);
    };
    Euclidean3.prototype.lshift = function (rhs) {
      var coord, pack;
      coord = function (x, n) {
        return x[n];
      };
      pack = function (w, x, y, z, xy, yz, zx, xyz) {
        return Euclidean3.fromCartesian(w, x, y, z, xy, yz, zx, xyz);
      };
      return Euclidean3.compute(BLADE.bladeASM.lcoE3, [
        this.w,
        this.x,
        this.y,
        this.z,
        this.xy,
        this.yz,
        this.zx,
        this.xyz
      ], [
        rhs.w,
        rhs.x,
        rhs.y,
        rhs.z,
        rhs.xy,
        rhs.yz,
        rhs.zx,
        rhs.xyz
      ], coord, pack);
    };
    Euclidean3.prototype.rshift = function (rhs) {
      var coord, pack;
      coord = function (x, n) {
        return x[n];
      };
      pack = function (w, x, y, z, xy, yz, zx, xyz) {
        return Euclidean3.fromCartesian(w, x, y, z, xy, yz, zx, xyz);
      };
      return Euclidean3.compute(BLADE.bladeASM.rcoE3, [
        this.w,
        this.x,
        this.y,
        this.z,
        this.xy,
        this.yz,
        this.zx,
        this.xyz
      ], [
        rhs.w,
        rhs.x,
        rhs.y,
        rhs.z,
        rhs.xy,
        rhs.yz,
        rhs.zx,
        rhs.xyz
      ], coord, pack);
    };
    Euclidean3.prototype.grade = function (index) {
      switch (index) {
      case 0:
        return Euclidean3.fromCartesian(this.w, 0, 0, 0, 0, 0, 0, 0);
      case 1:
        return Euclidean3.fromCartesian(0, this.x, this.y, this.z, 0, 0, 0, 0);
      case 2:
        return Euclidean3.fromCartesian(0, 0, 0, 0, this.xy, this.yz, this.zx, 0);
      case 3:
        return Euclidean3.fromCartesian(0, 0, 0, 0, 0, 0, 0, this.xyz);
      default:
        return Euclidean3.fromCartesian(0, 0, 0, 0, 0, 0, 0, 0);
      }
    };
    Euclidean3.prototype.dot = function (vector) {
      return this.x * vector.x + this.y * vector.y + this.z * vector.z;
    };
    Euclidean3.prototype.cross = function (vector) {
      var x, x1, x2, y, y1, y2, z, z1, z2;
      x1 = this.x;
      y1 = this.y;
      z1 = this.z;
      x2 = vector.x;
      y2 = vector.y;
      z2 = vector.z;
      x = y1 * z2 - z1 * y2;
      y = z1 * x2 - x1 * z2;
      z = x1 * y2 - y1 * x2;
      return new BLADE.Euclidean3(0, x, y, z, 0, 0, 0, 0);
    };
    Euclidean3.prototype.length = function () {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    };
    Euclidean3.prototype.toString = function () {
      return BLADE.bladeSTR.stringFromCoordinates([
        this.w,
        this.x,
        this.y,
        this.z,
        this.xy,
        this.yz,
        this.zx,
        this.xyz
      ], [
        '1',
        'e1',
        'e2',
        'e3',
        'e12',
        'e23',
        'e31',
        'e123'
      ]);
    };
    Euclidean3.prototype.toStringIJK = function () {
      return BLADE.bladeSTR.stringFromCoordinates([
        this.w,
        this.x,
        this.y,
        this.z,
        this.xy,
        this.yz,
        this.zx,
        this.xyz
      ], [
        '1',
        'i',
        'j',
        'k',
        'ij',
        'jk',
        'ki',
        'I'
      ]);
    };
    Euclidean3.prototype.toStringLATEX = function () {
      return BLADE.bladeSTR.stringFromCoordinates([
        this.w,
        this.x,
        this.y,
        this.z,
        this.xy,
        this.yz,
        this.zx,
        this.xyz
      ], [
        '1',
        'e_{1}',
        'e_{2}',
        'e_{3}',
        'e_{12}',
        'e_{23}',
        'e_{31}',
        'e_{123}'
      ]);
    };
    return Euclidean3;
  }();
  this.BLADE.Euclidean3 = Euclidean3;
}.call(this));
(function () {
  var BLADE, Line2;
  this.BLADE = this.BLADE || {};
  BLADE = this.BLADE;
  Line2 = function () {
    function Line2(a, b, c) {
      this.a = a;
      this.b = b;
      this.c = c;
    }
    Line2.prototype.meetWithLine = function (line) {
      var a1, a2, b1, b2, c1, c2, denom;
      a1 = this.a;
      b1 = this.b;
      c1 = this.c;
      a2 = line.a;
      b2 = line.b;
      c2 = line.c;
      denom = a1 * b2 - a2 * b1;
      return new BLADE.Point2((b1 * c2 - b2 * c1) / denom, (a2 * c1 - a1 * c2) / denom);
    };
    Line2.prototype.passesThroughPoint = function (point, epsilon) {
      return Math.abs(this.a * point.x + this.b * point.y + this.c) < epsilon;
    };
    Line2.prototype.reflectPoint = function (point) {
      var a, aSquared, b, bSquared, c, denom, sqsum, u, v, x, y;
      a = this.a;
      aSquared = a * a;
      b = this.b;
      bSquared = b * b;
      c = this.c;
      denom = aSquared - bSquared;
      sqsum = aSquared + bSquared;
      x = point.x;
      y = point.y;
      u = -(2 * a * (b * y + c) + x * sqsum) / denom;
      v = (2 * b * (a * x + c) + y * sqsum) / denom;
      return new BLADE.Point2(u, v);
    };
    return Line2;
  }();
  this.BLADE.Line2 = Line2;
}.call(this));
(function () {
  var BLADE, Measure;
  this.BLADE = this.BLADE || {};
  BLADE = this.BLADE;
  Measure = function () {
    function Measure(quantity, uom) {
      var scale;
      scale = uom.scale;
      if (scale === 1) {
        this.quantity = quantity;
        this.uom = uom;
      } else {
        this.quantity = quantity.mul(scale);
        this.uom = new BLADE.Unit(1, uom.dimensions, uom.labels);
      }
    }
    Measure.prototype.add = function (rhs) {
      if (rhs instanceof BLADE.Measure) {
        return new BLADE.Measure(this.quantity.add(rhs.quantity), this.uom.compatible(rhs.uom));
      } else {
        throw new Error('Measure.add(rhs): rhs must be a Measure.');
      }
    };
    Measure.prototype.sub = function (rhs) {
      if (rhs instanceof BLADE.Measure) {
        return new BLADE.Measure(this.quantity.sub(rhs.quantity), this.uom.compatible(rhs.uom));
      } else {
        throw new Error('Measure.sub(rhs): rhs must be a Measure.');
      }
    };
    Measure.prototype.mul = function (rhs) {
      if (rhs instanceof BLADE.Measure) {
        return new BLADE.Measure(this.quantity.mul(rhs.quantity), this.uom.mul(rhs.uom));
      } else if (rhs instanceof BLADE.Unit) {
        return new BLADE.Measure(this.quantity, this.uom.mul(rhs));
      } else if (typeof rhs === 'number') {
        return new BLADE.Measure(this.quantity.mul(rhs), this.uom);
      } else {
        throw new Error('Measure.mul(rhs): rhs must be a [Measure, Unit, number]');
      }
    };
    Measure.prototype.div = function (rhs) {
      if (rhs instanceof BLADE.Measure) {
        return new BLADE.Measure(this.quantity.div(rhs.quantity), this.uom.div(rhs.uom));
      } else if (rhs instanceof BLADE.Unit) {
        return new BLADE.Measure(this.quantity, this.uom.div(rhs));
      } else if (typeof rhs === 'number') {
        return new BLADE.Measure(this.quantity.div(rhs), this.uom);
      } else {
        throw new Error('Measure.div(rhs): rhs must be a [Measure, Unit, number]');
      }
    };
    Measure.prototype.wedge = function (rhs) {
      if (rhs instanceof BLADE.Measure) {
        return new BLADE.Measure(this.quantity.wedge(rhs.quantity), this.uom.mul(rhs.uom));
      } else {
        throw new Error('Measure.wedge(rhs): rhs must be a Measure');
      }
    };
    Measure.prototype.toString = function () {
      return '' + this.quantity + ' ' + this.uom;
    };
    return Measure;
  }();
  this.BLADE.Measure = Measure;
}.call(this));
(function () {
  var BLADE, Point2;
  this.BLADE = this.BLADE || {};
  BLADE = this.BLADE;
  Point2 = function () {
    function Point2(x, y) {
      this.x = x;
      this.y = y;
    }
    Point2.prototype.joinToPoint = function (point) {
      var x1, x2, y1, y2;
      x1 = this.x;
      y1 = this.y;
      x2 = point.x;
      y2 = point.y;
      return new BLADE.Line2(y1 - y2, x2 - x1, x1 * y2 - x2 * y1);
    };
    Point2.prototype.liesOnLine = function (line, epsilon) {
      return Math.abs(line.a * this.x + line.b * this.y + line.c) < epsilon;
    };
    Point2.prototype.quadrance = function (point) {
      var dx, dy, x1, x2, y1, y2;
      x1 = this.x;
      y1 = this.y;
      x2 = point.x;
      y2 = point.y;
      dx = x2 - x1;
      dy = y2 - y1;
      return dx * dx + dy * dy;
    };
    Point2.prototype.reflectAboutLine = function (line) {
      var a, aSquared, b, bSquared, c, denom, sqsum, u, v, x, y;
      a = line.a;
      aSquared = a * a;
      b = line.b;
      bSquared = b * b;
      c = line.c;
      denom = aSquared - bSquared;
      sqsum = aSquared + bSquared;
      x = this.x;
      y = this.y;
      u = -(2 * a * (b * y + c) + x * sqsum) / denom;
      v = (2 * b * (a * x + c) + y * sqsum) / denom;
      return new BLADE.Point2(u, v);
    };
    Point2.prototype.signedArea = function (pointA2, pointA3) {
      var v1, v2;
      v1 = this.vectorTo(pointA2);
      v2 = this.vectorTo(pointA3);
      return v1.wedge(v2).mul(new BLADE.Euclidean2(0.5, 0, 0, 0));
    };
    Point2.prototype.vectorTo = function (point) {
      return new BLADE.Euclidean2(0, point.x - this.x, point.y - this.y, 0);
    };
    return Point2;
  }();
  this.BLADE.Point2 = Point2;
}.call(this));
(function () {
  var BLADE, Rational, gcd;
  this.BLADE = this.BLADE || {};
  BLADE = this.BLADE;
  gcd = function (a, b) {
    var temp;
    if (a < 0) {
      a = -a;
    }
    if (b < 0) {
      b = -b;
    }
    if (b > a) {
      temp = a;
      a = b;
      b = temp;
    }
    while (true) {
      a %= b;
      if (a === 0) {
        return b;
      }
      b %= a;
      if (b === 0) {
        return a;
      }
    }
  };
  Rational = function () {
    function Rational(n, d) {
      var g;
      if (d === 0) {
        throw new Error('denominator must not be zero');
      }
      if (n === 0) {
        g = 1;
      } else {
        g = gcd(Math.abs(n), Math.abs(d));
      }
      if (d < 0) {
        n = -n;
        d = -d;
      }
      this.numer = n / g;
      this.denom = d / g;
    }
    Rational.prototype.add = function (rhs) {
      if (typeof rhs === 'number') {
        return new BLADE.Rational(this.numer + this.denom * rhs, this.denom);
      } else {
        return new BLADE.Rational(this.numer * rhs.denom + this.denom * rhs.numer, this.denom * rhs.denom);
      }
    };
    Rational.prototype.sub = function (rhs) {
      if (typeof rhs === 'number') {
        return new BLADE.Rational(this.numer - this.denom * rhs, this.denom);
      } else {
        return new BLADE.Rational(this.numer * rhs.denom - this.denom * rhs.numer, this.denom * rhs.denom);
      }
    };
    Rational.prototype.mul = function (rhs) {
      if (typeof rhs === 'number') {
        return new BLADE.Rational(this.numer * rhs, this.denom);
      } else {
        return new BLADE.Rational(this.numer * rhs.numer, this.denom * rhs.denom);
      }
    };
    Rational.prototype.div = function (rhs) {
      return new BLADE.Rational(this.numer * rhs.denom, this.denom * rhs.numer);
    };
    Rational.prototype.isZero = function () {
      return this.numer === 0;
    };
    Rational.prototype.equals = function (other) {
      if (other instanceof BLADE.Rational) {
        return this.numer * other.denom === this.denom * other.numer;
      } else {
        return false;
      }
    };
    Rational.prototype.toString = function () {
      return '' + this.numer + '/' + this.denom;
    };
    return Rational;
  }();
  this.BLADE.Rational = Rational;
}.call(this));
(function () {
  var BLADE, Unit, stringify;
  this.BLADE = this.BLADE || {};
  BLADE = this.BLADE;
  stringify = function (rational, label) {
    if (rational.numer === 0) {
      return null;
    } else if (rational.denom === 1) {
      if (rational.numer === 1) {
        return '' + label;
      } else {
        return '' + label + ' ** ' + rational.numer;
      }
    } else {
    }
    return '' + label + ' ** ' + rational;
  };
  Unit = function () {
    function Unit(scale, dimensions, labels) {
      if (labels.length !== 7) {
        throw new Error('Expecting 7 elements in the labels array.');
      }
      this.scale = scale;
      this.dimensions = dimensions;
      this.labels = labels;
    }
    Unit.prototype.compatible = function (rhs) {
      var dimensions;
      if (rhs instanceof Unit) {
        dimensions = this.dimensions.compatible(rhs.dimensions);
        return this;
      } else {
        throw new Error('Illegal Argument for Unit.compatible: ' + rhs);
      }
    };
    Unit.prototype.add = function (rhs) {
      if (rhs instanceof Unit) {
        return new BLADE.Unit(this.scale + rhs.scale, this.dimensions.compatible(rhs.dimensions), this.labels);
      } else {
        throw new Error('Illegal Argument for Unit.add: ' + rhs);
      }
    };
    Unit.prototype.sub = function (rhs) {
      if (rhs instanceof Unit) {
        return new BLADE.Unit(this.scale - rhs.scale, this.dimensions.compatible(rhs.dimensions), this.labels);
      } else {
        throw new Error('Illegal Argument for Unit.sub: ' + rhs);
      }
    };
    Unit.prototype.mul = function (rhs) {
      if (typeof rhs === 'number') {
        return new BLADE.Unit(this.scale * rhs, this.dimensions, this.labels);
      } else if (rhs instanceof Unit) {
        return new BLADE.Unit(this.scale * rhs.scale, this.dimensions.mul(rhs.dimensions), this.labels);
      } else {
        throw new Error('Illegal Argument for mul: ' + rhs);
      }
    };
    Unit.prototype.div = function (rhs) {
      if (typeof rhs === 'number') {
        return new BLADE.Unit(this.scale / rhs, this.dimensions, this.labels);
      } else if (rhs instanceof Unit) {
        return new BLADE.Unit(this.scale / rhs.scale, this.dimensions.div(rhs.dimensions), this.labels);
      } else {
        throw new Error('Illegal Argument for div: ' + rhs);
      }
    };
    Unit.prototype.pow = function (rhs) {
      if (typeof rhs === 'number') {
        return new BLADE.Unit(Math.pow(this.scale, rhs), this.dimensions.pow(rhs), this.labels);
      } else {
        throw new Error('Illegal Argument for div: ' + rhs);
      }
    };
    Unit.prototype.toString = function () {
      var operatorStr, scaleString, unitsString;
      operatorStr = this.scale === 1 || this.dimensions.dimensionless() ? '' : ' ';
      scaleString = this.scale === 1 ? '' : '' + this.scale;
      unitsString = [
        stringify(this.dimensions.M, this.labels[0]),
        stringify(this.dimensions.L, this.labels[1]),
        stringify(this.dimensions.T, this.labels[2]),
        stringify(this.dimensions.Q, this.labels[3]),
        stringify(this.dimensions.temperature, this.labels[4]),
        stringify(this.dimensions.amount, this.labels[5]),
        stringify(this.dimensions.intensity, this.labels[6])
      ].filter(function (x) {
        return typeof x === 'string';
      }).join(' ');
      return '' + scaleString + operatorStr + unitsString;
    };
    return Unit;
  }();
  this.BLADE.Unit = Unit;
  this.BLADE.UNIT_SYMBOLS = [
    'kg',
    'm',
    's',
    'C',
    'K',
    'mol',
    'cd'
  ];
  this.BLADE.UNIT_KILOGRAM = new Unit(1, new this.BLADE.Dimensions(1, 0, 0, 0, 0, 0, 0), this.BLADE.UNIT_SYMBOLS);
  this.BLADE.UNIT_METER = new Unit(1, new this.BLADE.Dimensions(0, 1, 0, 0, 0, 0, 0), this.BLADE.UNIT_SYMBOLS);
  this.BLADE.UNIT_SECOND = new Unit(1, new this.BLADE.Dimensions(0, 0, 1, 0, 0, 0, 0), this.BLADE.UNIT_SYMBOLS);
  this.BLADE.UNIT_AMPERE = new Unit(1, new this.BLADE.Dimensions(0, 0, -1, 1, 0, 0, 0), this.BLADE.UNIT_SYMBOLS);
  this.BLADE.UNIT_KELVIN = new Unit(1, new this.BLADE.Dimensions(0, 0, 0, 0, 1, 0, 0), this.BLADE.UNIT_SYMBOLS);
  this.BLADE.UNIT_MOLE = new Unit(1, new this.BLADE.Dimensions(0, 0, 0, 0, 0, 1, 0), this.BLADE.UNIT_SYMBOLS);
  this.BLADE.UNIT_CANDELA = new Unit(1, new this.BLADE.Dimensions(0, 0, 0, 0, 0, 0, 1), this.BLADE.UNIT_SYMBOLS);
  this.BLADE.UNIT_COULOMB = new Unit(1, new this.BLADE.Dimensions(0, 0, 0, 1, 0, 0, 0), this.BLADE.UNIT_SYMBOLS);
}.call(this));
(function () {
  this.BLADE = this.BLADE || {};
  this.BLADE.bladeASM = function (stdlib, foreign, heap) {
    function addE2(a0, a1, a2, a3, b0, b1, b2, b3, index) {
      a0 = +a0;
      a1 = +a1;
      a2 = +a2;
      a3 = +a3;
      b0 = +b0;
      b1 = +b1;
      b2 = +b2;
      b3 = +b3;
      index = index | 0;
      var x = 0;
      switch (~~index) {
      case 0: {
          x = +(a0 + b0);
        }
        break;
      case 1: {
          x = +(a1 + b1);
        }
        break;
      case 2: {
          x = +(a2 + b2);
        }
        break;
      case 3: {
          x = +(a3 + b3);
        }
        break;
      default: {
        }
      }
      return +x;
    }
    function subE2(a0, a1, a2, a3, b0, b1, b2, b3, index) {
      a0 = +a0;
      a1 = +a1;
      a2 = +a2;
      a3 = +a3;
      b0 = +b0;
      b1 = +b1;
      b2 = +b2;
      b3 = +b3;
      index = index | 0;
      var x = 0;
      switch (~~index) {
      case 0: {
          x = +(a0 - b0);
        }
        break;
      case 1: {
          x = +(a1 - b1);
        }
        break;
      case 2: {
          x = +(a2 - b2);
        }
        break;
      case 3: {
          x = +(a3 - b3);
        }
        break;
      default: {
        }
      }
      return +x;
    }
    function mulE2(a0, a1, a2, a3, b0, b1, b2, b3, index) {
      a0 = +a0;
      a1 = +a1;
      a2 = +a2;
      a3 = +a3;
      b0 = +b0;
      b1 = +b1;
      b2 = +b2;
      b3 = +b3;
      index = index | 0;
      var x = 0;
      switch (~~index) {
      case 0: {
          x = +(a0 * b0 + a1 * b1 + a2 * b2 - a3 * b3);
        }
        break;
      case 1: {
          x = +(a0 * b1 + a1 * b0 - a2 * b3 + a3 * b2);
        }
        break;
      case 2: {
          x = +(a0 * b2 + a1 * b3 + a2 * b0 - a3 * b1);
        }
        break;
      case 3: {
          x = +(a0 * b3 + a1 * b2 - a2 * b1 + a3 * b0);
        }
        break;
      default: {
        }
      }
      return +x;
    }
    function extE2(a0, a1, a2, a3, b0, b1, b2, b3, index) {
      a0 = +a0;
      a1 = +a1;
      a2 = +a2;
      a3 = +a3;
      b0 = +b0;
      b1 = +b1;
      b2 = +b2;
      b3 = +b3;
      index = index | 0;
      var x = 0;
      switch (~~index) {
      case 0: {
          x = +(a0 * b0);
        }
        break;
      case 1: {
          x = +(a0 * b1 + a1 * b0);
        }
        break;
      case 2: {
          x = +(a0 * b2 + a2 * b0);
        }
        break;
      case 3: {
          x = +(a0 * b3 + a1 * b2 - a2 * b1 + a3 * b0);
        }
        break;
      default: {
        }
      }
      return +x;
    }
    function lcoE2(a0, a1, a2, a3, b0, b1, b2, b3, index) {
      a0 = +a0;
      a1 = +a1;
      a2 = +a2;
      a3 = +a3;
      b0 = +b0;
      b1 = +b1;
      b2 = +b2;
      b3 = +b3;
      index = index | 0;
      var x = 0;
      switch (~~index) {
      case 0: {
          x = +(a0 * b0 + a1 * b1 + a2 * b2 - a3 * b3);
        }
        break;
      case 1: {
          x = +(a0 * b1 - a2 * b3);
        }
        break;
      case 2: {
          x = +(a0 * b2 + a1 * b3);
        }
        break;
      case 3: {
          x = +(a0 * b3);
        }
        break;
      default: {
        }
      }
      return +x;
    }
    function rcoE2(a0, a1, a2, a3, b0, b1, b2, b3, index) {
      a0 = +a0;
      a1 = +a1;
      a2 = +a2;
      a3 = +a3;
      b0 = +b0;
      b1 = +b1;
      b2 = +b2;
      b3 = +b3;
      index = index | 0;
      var x = 0;
      switch (~~index) {
      case 0: {
          x = +(a0 * b0 + a1 * b1 + a2 * b2 - a3 * b3);
        }
        break;
      case 1: {
          x = +(-a1 * b0 - a3 * b2);
        }
        break;
      case 2: {
          x = +(-a2 * b0 + a3 * b1);
        }
        break;
      case 3: {
          x = +(a3 * b0);
        }
        break;
      default: {
        }
      }
      return +x;
    }
    function addE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, index) {
      a0 = +a0;
      a1 = +a1;
      a2 = +a2;
      a3 = +a3;
      a4 = +a4;
      a5 = +a5;
      a6 = +a6;
      a7 = +a7;
      b0 = +b0;
      b1 = +b1;
      b2 = +b2;
      b3 = +b3;
      b4 = +b4;
      b5 = +b5;
      b6 = +b6;
      b7 = +b7;
      index = index | 0;
      var x = 0;
      switch (~~index) {
      case 0: {
          x = +(a0 + b0);
        }
        break;
      case 1: {
          x = +(a1 + b1);
        }
        break;
      case 2: {
          x = +(a2 + b2);
        }
        break;
      case 3: {
          x = +(a3 + b3);
        }
        break;
      case 4: {
          x = +(a4 + b4);
        }
        break;
      case 5: {
          x = +(a5 + b5);
        }
        break;
      case 6: {
          x = +(a6 + b6);
        }
        break;
      case 7: {
          x = +(a7 + b7);
        }
        break;
      default: {
        }
      }
      return +x;
    }
    function subE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, index) {
      a0 = +a0;
      a1 = +a1;
      a2 = +a2;
      a3 = +a3;
      a4 = +a4;
      a5 = +a5;
      a6 = +a6;
      a7 = +a7;
      b0 = +b0;
      b1 = +b1;
      b2 = +b2;
      b3 = +b3;
      b4 = +b4;
      b5 = +b5;
      b6 = +b6;
      b7 = +b7;
      index = index | 0;
      var x = 0;
      switch (~~index) {
      case 0: {
          x = +(a0 - b0);
        }
        break;
      case 1: {
          x = +(a1 - b1);
        }
        break;
      case 2: {
          x = +(a2 - b2);
        }
        break;
      case 3: {
          x = +(a3 - b3);
        }
        break;
      case 4: {
          x = +(a4 - b4);
        }
        break;
      case 5: {
          x = +(a5 - b5);
        }
        break;
      case 6: {
          x = +(a6 - b6);
        }
        break;
      case 7: {
          x = +(a7 - b7);
        }
        break;
      default: {
        }
      }
      return +x;
    }
    function mulE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, index) {
      a0 = +a0;
      a1 = +a1;
      a2 = +a2;
      a3 = +a3;
      a4 = +a4;
      a5 = +a5;
      a6 = +a6;
      a7 = +a7;
      b0 = +b0;
      b1 = +b1;
      b2 = +b2;
      b3 = +b3;
      b4 = +b4;
      b5 = +b5;
      b6 = +b6;
      b7 = +b7;
      index = index | 0;
      var x = 0;
      switch (~~index) {
      case 0: {
          x = +(a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3 - a4 * b4 - a5 * b5 - a6 * b6 - a7 * b7);
        }
        break;
      case 1: {
          x = +(a0 * b1 + a1 * b0 - a2 * b4 + a3 * b6 + a4 * b2 - a5 * b7 - a6 * b3 - a7 * b5);
        }
        break;
      case 2: {
          x = +(a0 * b2 + a1 * b4 + a2 * b0 - a3 * b5 - a4 * b1 + a5 * b3 - a6 * b7 - a7 * b6);
        }
        break;
      case 3: {
          x = +(a0 * b3 - a1 * b6 + a2 * b5 + a3 * b0 - a4 * b7 - a5 * b2 + a6 * b1 - a7 * b4);
        }
        break;
      case 4: {
          x = +(a0 * b4 + a1 * b2 - a2 * b1 + a3 * b7 + a4 * b0 - a5 * b6 + a6 * b5 + a7 * b3);
        }
        break;
      case 5: {
          x = +(a0 * b5 + a1 * b7 + a2 * b3 - a3 * b2 + a4 * b6 + a5 * b0 - a6 * b4 + a7 * b1);
        }
        break;
      case 6: {
          x = +(a0 * b6 - a1 * b3 + a2 * b7 + a3 * b1 - a4 * b5 + a5 * b4 + a6 * b0 + a7 * b2);
        }
        break;
      case 7: {
          x = +(a0 * b7 + a1 * b5 + a2 * b6 + a3 * b4 + a4 * b3 + a5 * b1 + a6 * b2 + a7 * b0);
        }
        break;
      default: {
        }
      }
      return +x;
    }
    function extE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, index) {
      a0 = +a0;
      a1 = +a1;
      a2 = +a2;
      a3 = +a3;
      a4 = +a4;
      a5 = +a5;
      a6 = +a6;
      a7 = +a7;
      b0 = +b0;
      b1 = +b1;
      b2 = +b2;
      b3 = +b3;
      b4 = +b4;
      b5 = +b5;
      b6 = +b6;
      b7 = +b7;
      index = index | 0;
      var x = 0;
      switch (~~index) {
      case 0: {
          x = +(a0 * b0);
        }
        break;
      case 1: {
          x = +(a0 * b1 + a1 * b0);
        }
        break;
      case 2: {
          x = +(a0 * b2 + a2 * b0);
        }
        break;
      case 3: {
          x = +(a0 * b3 + a3 * b0);
        }
        break;
      case 4: {
          x = +(a0 * b4 + a1 * b2 - a2 * b1 + a4 * b0);
        }
        break;
      case 5: {
          x = +(a0 * b5 + a2 * b3 - a3 * b2 + a5 * b0);
        }
        break;
      case 6: {
          x = +(a0 * b6 - a1 * b3 + a3 * b1 + a6 * b0);
        }
        break;
      case 7: {
          x = +(a0 * b7 + a1 * b5 + a2 * b6 + a3 * b4 + a4 * b3 + a5 * b1 + a6 * b2 + a7 * b0);
        }
        break;
      default: {
        }
      }
      return +x;
    }
    function lcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, index) {
      a0 = +a0;
      a1 = +a1;
      a2 = +a2;
      a3 = +a3;
      a4 = +a4;
      a5 = +a5;
      a6 = +a6;
      a7 = +a7;
      b0 = +b0;
      b1 = +b1;
      b2 = +b2;
      b3 = +b3;
      b4 = +b4;
      b5 = +b5;
      b6 = +b6;
      b7 = +b7;
      index = index | 0;
      var x = 0;
      switch (~~index) {
      case 0: {
          x = +(a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3 - a4 * b4 - a5 * b5 - a6 * b6 - a7 * b7);
        }
        break;
      case 1: {
          x = +(a0 * b1 - a2 * b4 + a3 * b6 - a5 * b7);
        }
        break;
      case 2: {
          x = +(a0 * b2 + a1 * b4 - a3 * b5 - a6 * b7);
        }
        break;
      case 3: {
          x = +(a0 * b3 - a1 * b6 + a2 * b5 - a4 * b7);
        }
        break;
      case 4: {
          x = +(a0 * b4 + a3 * b7);
        }
        break;
      case 5: {
          x = +(a0 * b5 + a1 * b7);
        }
        break;
      case 6: {
          x = +(a0 * b6 + a2 * b7);
        }
        break;
      case 7: {
          x = +(a0 * b7);
        }
        break;
      default: {
        }
      }
      return +x;
    }
    function rcoE3(a0, a1, a2, a3, a4, a5, a6, a7, b0, b1, b2, b3, b4, b5, b6, b7, index) {
      a0 = +a0;
      a1 = +a1;
      a2 = +a2;
      a3 = +a3;
      a4 = +a4;
      a5 = +a5;
      a6 = +a6;
      a7 = +a7;
      b0 = +b0;
      b1 = +b1;
      b2 = +b2;
      b3 = +b3;
      b4 = +b4;
      b5 = +b5;
      b6 = +b6;
      b7 = +b7;
      index = index | 0;
      var x = 0;
      switch (~~index) {
      case 0: {
          x = +(a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3 - a4 * b4 - a5 * b5 - a6 * b6 - a7 * b7);
        }
        break;
      case 1: {
          x = +(+a1 * b0 + a4 * b2 - a6 * b3 - a7 * b5);
        }
        break;
      case 2: {
          x = +(+a2 * b0 - a4 * b1 + a5 * b3 - a7 * b6);
        }
        break;
      case 3: {
          x = +(+a3 * b0 - a5 * b2 + a6 * b1 - a7 * b4);
        }
        break;
      case 4: {
          x = +(+a4 * b0 + a7 * b3);
        }
        break;
      case 5: {
          x = +(+a5 * b0 + a7 * b1);
        }
        break;
      case 6: {
          x = +(+a6 * b0 + a7 * b2);
        }
        break;
      case 7: {
          x = +(+a7 * b0);
        }
        break;
      default: {
        }
      }
      return +x;
    }
    return {
      addE2: addE2,
      subE2: subE2,
      mulE2: mulE2,
      extE2: extE2,
      lcoE2: lcoE2,
      rcoE2: rcoE2,
      addE3: addE3,
      subE3: subE3,
      mulE3: mulE3,
      extE3: extE3,
      lcoE3: lcoE3,
      rcoE3: rcoE3
    };
  }(typeof window === 'object' ? window : undefined, {}, new ArrayBuffer(4 * 1024));
}.call(this));
(function () {
  this.BLADE = this.BLADE || {};
  this.BLADE.bladeSTR = function () {
    'use strict';
    function stringFromCoordinates(coordinates, labels) {
      var append, i, sb, str, _i, _ref;
      sb = [];
      append = function (number, label) {
        var n;
        if (number !== 0) {
          if (number >= 0) {
            if (sb.length > 0) {
              sb.push('+');
            }
          } else {
            sb.push('-');
          }
          n = Math.abs(number);
          if (n === 1) {
            return sb.push(label);
          } else {
            sb.push(n.toString());
            if (label !== '1') {
              sb.push('*');
              return sb.push(label);
            }
          }
        }
      };
      for (i = _i = 0, _ref = coordinates.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        append(coordinates[i], labels[i]);
      }
      if (sb.length > 0) {
        str = sb.join('');
      } else {
        str = '0';
      }
      return str;
    }
    return { stringFromCoordinates: stringFromCoordinates };
  }();
}.call(this));
(function () {
  this.BLADE = this.BLADE || {};
  this.BLADE.e2gaASM = function (stdlib, foreign, heap) {
    function add00(a00, a01, a10, a11, b00, b01, b10, b11) {
      a00 = +a00;
      a01 = +a01;
      a10 = +a10;
      a11 = +a11;
      b00 = +b00;
      b01 = +b01;
      b10 = +b10;
      b11 = +b11;
      return +(a00 + b00);
    }
    function add01(a00, a01, a10, a11, b00, b01, b10, b11) {
      a00 = +a00;
      a01 = +a01;
      a10 = +a10;
      a11 = +a11;
      b00 = +b00;
      b01 = +b01;
      b10 = +b10;
      b11 = +b11;
      return +(a01 + b01);
    }
    function add10(a00, a01, a10, a11, b00, b01, b10, b11) {
      a00 = +a00;
      a01 = +a01;
      a10 = +a10;
      a11 = +a11;
      b00 = +b00;
      b01 = +b01;
      b10 = +b10;
      b11 = +b11;
      return +(a10 + b10);
    }
    function add11(a00, a01, a10, a11, b00, b01, b10, b11) {
      a00 = +a00;
      a01 = +a01;
      a10 = +a10;
      a11 = +a11;
      b00 = +b00;
      b01 = +b01;
      b10 = +b10;
      b11 = +b11;
      return +(a11 + b11);
    }
    return {
      add00: add00,
      add01: add01,
      add10: add10,
      add11: add11
    };
  }(typeof window === 'object' ? window : undefined, {}, new ArrayBuffer(4 * 1024));
}.call(this));
Sk.builtinFiles = {
  'files': {
    'src/lib/pythonds/trees/binheap.py': '# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n\n# this heap takes key value pairs, we will assume that the keys are integers\nclass BinHeap:\n    def __init__(self):\n        self.heapList = [0]\n        self.currentSize = 0\n\n\n    def buildHeap(self,alist):\n        i = len(alist) // 2\n        self.currentSize = len(alist)\n        self.heapList = [0] + alist[:]\n        print(len(self.heapList), i)\n        while (i > 0):\n            print(self.heapList, i)\n            self.percDown(i)\n            i = i - 1\n        print(self.heapList,i)\n                        \n    def percDown(self,i):\n        while (i * 2) <= self.currentSize:\n            mc = self.minChild(i)\n            if self.heapList[i] > self.heapList[mc]:\n                tmp = self.heapList[i]\n                self.heapList[i] = self.heapList[mc]\n                self.heapList[mc] = tmp\n            i = mc\n                \n    def minChild(self,i):\n        if i * 2 + 1 > self.currentSize:\n            return i * 2\n        else:\n            if self.heapList[i * 2] < self.heapList[i * 2 + 1]:\n                return i * 2\n            else:\n                return i * 2 + 1\n\n    def percUp(self,i):\n        while i // 2 > 0:\n            if self.heapList[i] < self.heapList[i//2]:\n               tmp = self.heapList[i // 2]\n               self.heapList[i // 2] = self.heapList[i]\n               self.heapList[i] = tmp\n            i = i // 2\n \n    def insert(self,k):\n        self.heapList.append(k)\n        self.currentSize = self.currentSize + 1\n        self.percUp(self.currentSize)\n\n    def delMin(self):\n        retval = self.heapList[1]\n        self.heapList[1] = self.heapList[self.currentSize]\n        self.currentSize = self.currentSize - 1\n        self.heapList.pop()\n        self.percDown(1)\n        return retval\n        \n    def isEmpty(self):\n        if currentSize == 0:\n            return True\n        else:\n            return False\n',
    'src/lib/fractions/__init__.js': '/**\n * fractions - Rational numbers\n *\n * David Holmes (david.geo.holmes@gmail.com)\n */\nvar $builtinmodule = function(name) {\n\n  var mod = {};\n\n  var FRACTION = "Fraction";\n\n  Sk.builtin.defineFractions(mod, FRACTION, function(n, d) {return new BLADE.Rational(n, d)});\n\n  return mod;\n};',
    'src/lib/pythonds/basic/stack.py': '# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n#stack.py\r\n\r\nclass Stack:\r\n    def __init__(self):\r\n        self.items = []\r\n\r\n    def isEmpty(self):\r\n        return self.items == []\r\n\r\n    def push(self, item):\r\n        self.items.append(item)\r\n\r\n    def pop(self):\r\n        return self.items.pop()\r\n\r\n    def peek(self):\r\n        return self.items[len(self.items)-1]\r\n\r\n    def size(self):\r\n        return len(self.items)\r\n\r\n',
    'src/lib/pythonds/trees/bst.py': '#!/bin/env python3.1\n# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005, 2010\n# \n\nclass BinarySearchTree:\n    \'\'\'\n    Author:  Brad Miller\n    Date:  1/15/2005\n    Description:  Imlement a binary search tree with the following interface\n                  functions:  \n                  __contains__(y) <==> y in x\n                  __getitem__(y) <==> x[y]\n                  __init__()\n                  __len__() <==> len(x)\n                  __setitem__(k,v) <==> x[k] = v\n                  clear()\n                  get(k)\n                  items() \n                  keys() \n                  values()\n                  put(k,v)\n                  in\n                  del <==> \n    \'\'\'\n\n    def __init__(self):\n        self.root = None\n        self.size = 0\n    \n    def put(self,key,val):\n        if self.root:\n            self._put(key,val,self.root)\n        else:\n            self.root = TreeNode(key,val)\n        self.size = self.size + 1\n\n    def _put(self,key,val,currentNode):\n        if key < currentNode.key:\n            if currentNode.hasLeftChild():\n                self._put(key,val,currentNode.leftChild)\n            else:\n                currentNode.leftChild = TreeNode(key,val,parent=currentNode)\n        else:\n            if currentNode.hasRightChild():\n                self._put(key,val,currentNode.rightChild)\n            else:\n                currentNode.rightChild = TreeNode(key,val,parent=currentNode)\n            \n    def __setitem__(self,k,v):\n        self.put(k,v)\n\n    def get(self,key):\n        if self.root:\n            res = self._get(key,self.root)\n            if res:\n                return res.payload\n            else:\n                return None\n        else:\n            return None\n        \n    def _get(self,key,currentNode):\n        if not currentNode:\n            return None\n        elif currentNode.key == key:\n            return currentNode\n        elif key < currentNode.key:\n            return self._get(key,currentNode.leftChild)\n        else:\n            return self._get(key,currentNode.rightChild)\n            \n        \n    def __getitem__(self,key):\n        res = self.get(key)\n        if res:\n            return res\n        else:\n            raise KeyError(\'Error, key not in tree\')\n            \n\n    def __contains__(self,key):\n        if self._get(key,self.root):\n            return True\n        else:\n            return False\n        \n    def length(self):\n        return self.size\n\n    def __len__(self):\n        return self.size\n\n    def __iter__(self):\n        return self.root.__iter__()\n    \n    def delete(self,key):\n        if self.size > 1:\n            nodeToRemove = self._get(key,self.root)\n            if nodeToRemove:\n                self.remove(nodeToRemove)\n                self.size = self.size-1\n            else:\n                raise KeyError(\'Error, key not in tree\')\n        elif self.size == 1 and self.root.key == key:\n            self.root = None\n            self.size = self.size - 1\n        else:\n            raise KeyError(\'Error, key not in tree\')\n\n    def __delitem__(self,key):\n        self.delete(key)\n    \n    def remove(self,currentNode):\n        if currentNode.isLeaf(): #leaf\n            if currentNode == currentNode.parent.leftChild:\n                currentNode.parent.leftChild = None\n            else:\n                currentNode.parent.rightChild = None\n        elif currentNode.hasBothChildren(): #interior\n            succ = currentNode.findSuccessor()\n            succ.spliceOut()\n            currentNode.key = succ.key\n            currentNode.payload = succ.payload\n        else: # this node has one child\n            if currentNode.hasLeftChild():\n                if currentNode.isLeftChild():\n                    currentNode.leftChild.parent = currentNode.parent\n                    currentNode.parent.leftChild = currentNode.leftChild\n                elif currentNode.isRightChild():\n                    currentNode.leftChild.parent = currentNode.parent\n                    currentNode.parent.rightChild = currentNode.leftChild\n                else:\n                    currentNode.replaceNodeData(currentNode.leftChild.key,\n                                       currentNode.leftChild.payload,\n                                       currentNode.leftChild.leftChild,\n                                       currentNode.leftChild.rightChild)\n            else:\n                if currentNode.isLeftChild():\n                    currentNode.rightChild.parent = currentNode.parent\n                    currentNode.parent.leftChild = currentNode.rightChild\n                elif currentNode.isRightChild():\n                    currentNode.rightChild.parent = currentNode.parent\n                    currentNode.parent.rightChild = currentNode.rightChild\n                else:\n                    currentNode.replaceNodeData(currentNode.rightChild.key,\n                                       currentNode.rightChild.payload,\n                                       currentNode.rightChild.leftChild,\n                                       currentNode.rightChild.rightChild)\n\n    def inorder(self):\n        self._inorder(self.root)\n\n    def _inorder(self,tree):\n        if tree != None:\n            self._inorder(tree.leftChild)\n            print(tree.key)\n            self._inorder(tree.rightChild)\n\n    def postorder(self):\n        self._postorder(self.root)\n\n    def _postorder(self, tree):\n        if tree:\n            self._postorder(tree.rightChild)\n            self._postorder(tree.leftChild)\n            print(tree.key)            \n\n    def preorder(self):\n        self._preorder(self,self.root)\n\n    def _preorder(self,tree):\n        if tree:\n            print(tree.key)            \n            self._preorder(tree.leftChild)\n            self._preorder(tree.rightChild)\n\n                \nclass TreeNode:\n    def __init__(self,key,val,left=None,right=None,parent=None):\n        self.key = key\n        self.payload = val\n        self.leftChild = left\n        self.rightChild = right\n        self.parent = parent\n        self.balanceFactor = 0\n        \n    def hasLeftChild(self):\n        return self.leftChild\n\n    def hasRightChild(self):\n        return self.rightChild\n    \n    def isLeftChild(self):\n        return self.parent and self.parent.leftChild == self\n\n    def isRightChild(self):\n        return self.parent and self.parent.rightChild == self\n\n    def isRoot(self):\n        return not self.parent\n\n    def isLeaf(self):\n        return not (self.rightChild or self.leftChild)\n\n    def hasAnyChildren(self):\n        return self.rightChild or self.leftChild\n\n    def hasBothChildren(self):\n        return self.rightChild and self.leftChild\n    \n    def replaceNodeData(self,key,value,lc,rc):\n        self.key = key\n        self.payload = value\n        self.leftChild = lc\n        self.rightChild = rc\n        if self.hasLeftChild():\n            self.leftChild.parent = self\n        if self.hasRightChild():\n            self.rightChild.parent = self\n        \n    def findSuccessor(self):\n        succ = None\n        if self.hasRightChild():\n            succ = self.rightChild.findMin()\n        else:\n            if self.parent:\n                if self.isLeftChild():\n                    succ = self.parent\n                else:\n                    self.parent.rightChild = None\n                    succ = self.parent.findSuccessor()\n                    self.parent.rightChild = self\n        return succ\n\n\n    def spliceOut(self):\n        if self.isLeaf():\n            if self.isLeftChild():\n                self.parent.leftChild = None\n            else:\n                self.parent.rightChild = None\n        elif self.hasAnyChildren():\n            if self.hasLeftChild():\n                if self.isLeftChild():\n                    self.parent.leftChild = self.leftChild\n                else:\n                    self.parent.rightChild = self.leftChild\n                self.leftChild.parent = self.parent\n            else:\n                if self.isLeftChild():\n                    self.parent.leftChild = self.rightChild\n                else:\n                    self.parent.rightChild = self.rightChild\n                self.rightChild.parent = self.parent\n\n    def findMin(self):\n        current = self\n        while current.hasLeftChild():\n            current = current.leftChild\n        return current\n\n    def __iter__(self):\n        """The standard inorder traversal of a binary tree."""\n        if self:\n            if self.hasLeftChild():\n                for elem in self.leftChild:\n                    yield elem\n            yield self.key\n            if self.hasRightChild():\n                for elem in self.rightChild:\n                    yield elem\n\n            \n',
    'src/lib/time/__init__.js': '\n/*\n\tBarebones implementation of the Python time package.\n\n\tFor now, only the time() function is implemented.\n*/\n \nvar $builtinmodule = function(name)\n{\n    var mod = {};\n\n    mod.time = new Sk.builtin.func(function() {\n\t  return Sk.builtin.assk$(new Date().getTime() / 1000, undefined);\n    });\n\n    return mod;\n}\n',
    'src/lib/image/__init__.js': 'var ImageMod; // the single identifier needed in the global scope\n\nif (! ImageMod) {\n    ImageMod = { };\n    ImageMod.canvasLib = [];\n}\n\n//  todo create an empty image by reading image data from a blank canvas of the appropriate size\n\nvar $builtinmodule = function(name) {\n    var mod = {};\n\n    var image = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self,imageId) {\n            self.image = document.getElementById(imageId.v);\n            if (self.image == null) {\n                throw "There is no image on this page named: " + imageId.v;\n            }\n            self.width = self.image.width;\n            self.height = self.image.height;\n            self.canvas = document.createElement("canvas");\n            self.canvas.height = self.height;\n            self.canvas.width = self.width;\n            self.ctx = self.canvas.getContext("2d");\n            self.ctx.drawImage(self.image,0,0)\n            self.imagedata = self.ctx.getImageData(0,0,self.width,self.height);\n        });\n\n        $loc.getPixel = new Sk.builtin.func(function(self,x,y) {\n\t\t\tx = Sk.builtin.asnum$(x);\n\t\t\ty = Sk.builtin.asnum$(y);\n            var index = (y*4)*self.width+(x*4);\n            var red = self.imagedata.data[index]\n            var green = self.imagedata.data[index+1]\n            var blue = self.imagedata.data[index+2]\n            return Sk.misceval.callsim(mod.Pixel,red,green,blue);\n        });\n\n        $loc.setPixel = new Sk.builtin.func(function(self, x, y, pix) {\n\t\t\tx = Sk.builtin.asnum$(x);\n\t\t\ty = Sk.builtin.asnum$(y);\n            var index = (y*4)*self.width+(x*4);\n            self.imagedata.data[index] = Sk.misceval.callsim(pix.getRed,pix);\n            self.imagedata.data[index+1] = Sk.misceval.callsim(pix.getGreen,pix);\n            self.imagedata.data[index+2] = Sk.misceval.callsim(pix.getBlue,pix);\n            self.imagedata.data[index+3] = 255;\n        });\n\n        $loc.getHeight = new Sk.builtin.func(function(self) {\n            return self.image.height;\n        });\n\n        $loc.getWidth = new Sk.builtin.func(function(self,titlestring) {\n            return self.image.width;\n        });\n\n        $loc.draw = new Sk.builtin.func(function(self,win,ulx,uly) {\n\t\t\twin = Sk.builtin.asnum$(win);\n\t\t\tulx = Sk.builtin.asnum$(ulx);\n\t\t\tuly = Sk.builtin.asnum$(uly);\n            var can = Sk.misceval.callsim(win.getWin,win);\n            var ctx = can.getContext("2d");\n            //ctx.putImageData(self.imagedata,0,0,0,0,self.imagedata.width,self.imagedata.height);\n            if (! ulx) {\n                ulx = 0;\n                uly = 0;\n            }\n            ctx.putImageData(self.imagedata,ulx,uly);\n        });\n\n        // toList\n\n    }\n\n    mod.Image = Sk.misceval.buildClass(mod, image, \'Image\', []);\n\n    var eImage = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self,width,height) {\n            self.width = Sk.builtin.asnum$(width);\n            self.height = Sk.builtin.asnum$(height);\n            self.canvas = document.createElement("canvas");\n            self.ctx = self.canvas.getContext(\'2d\');\n            self.canvas.height = self.height;\n            self.canvas.width = self.width;\n            self.imagedata = self.ctx.getImageData(0,0,self.width,self.height);\n        });\n\n    }\n\n    mod.EmptyImage = Sk.misceval.buildClass(mod, eImage, \'EmptyImage\', [mod.Image]);\n\n    // create a ListImage object\n\n    \n    var pixel = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self,r,g,b) {\n            self.red = Sk.builtin.asnum$(r);\n            self.green = Sk.builtin.asnum$(g);\n            self.blue = Sk.builtin.asnum$(b);\n        });\n\n        $loc.getRed = new Sk.builtin.func(function(self) {\n           return self.red;\n        });\n\n        $loc.getGreen = new Sk.builtin.func(function(self) {\n           return self.green;\n        });\n\n        $loc.getBlue = new Sk.builtin.func(function(self) {\n           return self.blue;\n        });\n\n        $loc.setRed = new Sk.builtin.func(function(self,r) {\n           self.red = Sk.builtin.asnum$(r);\n        });\n\n        $loc.setGreen = new Sk.builtin.func(function(self,g) {\n           self.green = Sk.builtin.asnum$(g);\n        });\n\n        $loc.setBlue = new Sk.builtin.func(function(self,b) {\n           self.blue = Sk.builtin.asnum$(b);\n        });\n\n        $loc.__getitem__ = new Sk.builtin.func(function(self,k) {\n\t\t   k = Sk.builtin.asnum$(k);\n           if(k == 0) {\n               return self.red;\n           } else if (k == 1) {\n               return self.green;\n           } else if (k == 2) {\n               return self.blue;\n           }\n        });\n\n        $loc.__str__ = new Sk.builtin.func(function(self) {\n            return "[" + self.red + "," + self.green + "," + self.blue + "]"\n        });\n        \n        //getColorTuple\n        $loc.getColorTuple = new Sk.builtin.func(function(self,x,y) {\n\n        });\n\n        //setRange -- change from 0..255 to 0.0 .. 1.0\n        $loc.setRange = new Sk.builtin.func(function(self,mx) {\n            self.max = Sk.builtin.asnum$(mx);\n        });\n\n    }\n    mod.Pixel = Sk.misceval.buildClass(mod, pixel, \'Pixel\', []);\n\n\n\n    var screen = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self,width,height) {\n            var currentCanvas = ImageMod.canvasLib[Sk.canvas];\n            if (currentCanvas === undefined) {\n                self.theScreen = document.getElementById(Sk.canvas);\n                if (width !== undefined) {\n                    self.theScreen.height = height;\n                    self.theScreen.width = width;\n                }\n\n                ImageMod.canvasLib[Sk.canvas] = self.theScreen;\n            } else {\n                self.theScreen = currentCanvas;\n                self.theScreen.height = self.theScreen.height;\n            }\n            self.theScreen.style.display = "block";\n        });\n\n        $loc.getWin = new Sk.builtin.func(function(self) {\n           return self.theScreen;\n        });\n\n        // exitonclick\n        $loc.exitonclick = new Sk.builtin.func(function(self) {\n            var canvas_id = self.theScreen.id;\n            self.theScreen.onclick = function() {\n                document.getElementById(canvas_id).style.display = \'none\';\n                document.getElementById(canvas_id).onclick = null;\n                delete ImageMod.canvasLib[canvas_id];\n            }\n\n        });\n        //getMouse\n    }\n\n    mod.ImageWin = Sk.misceval.buildClass(mod, screen, \'ImageWin\', []);\n\n    return mod\n}\n',
    'src/lib/browser/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n\n  var DOCUMENT_CLASS           = \'Document\';\n  var EVENT                    = \'Event\';\n  var NODE                     = \'Node\';\n  var WINDOW_CLASS             = \'Window\';\n  var WINDOW_ANIMATION_RUNNER  = \'WindowAnimationRunner\';\n  var WORKBENCH                = \'Workbench\';\n  var METHOD_START             = \'start\';\n\n  Sk.builtin.defineEvent(mod);\n\n  Sk.builtin.defineNode(mod);\n\n  mod[\'window\']   = new Sk.ffi.ObjectPy(window);\n  mod[\'document\'] = new Sk.ffi.ObjectPy(window.document);\n  // mod[\'window\'] = Sk.ffi.callsim(Sk.builtin.buildWindowClass(mod), Sk.ffi.referenceToPy(window, WINDOW_CLASS));\n  // mod[\'document\'] = Sk.ffi.callsim(Sk.builtin.buildDocumentClass(mod), Sk.ffi.referenceToPy(window.document, DOCUMENT_CLASS));\n\n  mod[WINDOW_ANIMATION_RUNNER] = Sk.ffi.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = Sk.ffi.functionPy(function(selfPy, tickPy, terminatePy, setUpPy, tearDownPy, windowPy) {\n      var prototype = WINDOW_ANIMATION_RUNNER + "(tick, terminate, setUp, tearDown[, window])";\n      Sk.ffi.checkMethodArgs(prototype, arguments, 4, 5);\n      Sk.ffi.checkArgType("tick",      Sk.ffi.PyType.FUNCTION, Sk.ffi.isFunction(tickPy));\n      Sk.ffi.checkArgType("terminate", Sk.ffi.PyType.FUNCTION, Sk.ffi.isFunction(terminatePy));\n      Sk.ffi.checkArgType("setUp",     Sk.ffi.PyType.FUNCTION, Sk.ffi.isFunction(setUpPy));\n      Sk.ffi.checkArgType("tearDown",  Sk.ffi.PyType.FUNCTION, Sk.ffi.isFunction(tearDownPy));\n      if (Sk.ffi.isDefined(windowPy)) {\n        Sk.ffi.checkArgType("window", [Sk.ffi.PyType.OBJECT,Sk.ffi.PyType.INSTANCE], Sk.ffi.isObject(windowPy) || Sk.ffi.isInstance(windowPy, WINDOW_CLASS), windowPy);\n      }\n      var onDocumentKeyDown = function(event) {\n        if (event.keyCode == 27) {\n          var war = Sk.ffi.remapToJs(selfPy);\n          war.escKeyPressed = true;\n          event.preventDefault();\n        }\n      };\n      var WindowAnimationRunner = function() {\n        this.window    = Sk.ffi.isDefined(windowPy) ? Sk.ffi.remapToJs(windowPy) : window;\n        this.startTime = null;\n        this.elapsed   = null;\n        this.requestID = null;\n        this.escKeyPressed = false;\n        this.exceptionPy = Sk.ffi.none.None;\n      };\n      WindowAnimationRunner.prototype = {\n        constructor: WindowAnimationRunner,\n        start: function() {\n          var war = this;\n          Sk.misceval.apply(setUpPy, undefined, undefined, undefined, []);\n          war.window.document.addEventListener(\'keydown\', onDocumentKeyDown, false);\n          var animate = function(timestamp) {\n            if (war.startTime) {\n              war.elapsed = timestamp - war.startTime;\n            }\n            else {\n              if (timestamp) {\n                war.startTime = timestamp;\n              }\n              else {\n                war.elapsed = 0;\n              }\n            }\n            function terminate() {\n                var timePy = Sk.ffi.numberToFloatPy(war.elapsed / 1000);\n                var responsePy = Sk.misceval.apply(terminatePy, undefined, undefined, undefined, [timePy]);\n                return Sk.ffi.remapToJs(responsePy);\n            }\n            if (war.escKeyPressed || terminate()) {\n              war.window.cancelAnimationFrame(war.requestID);\n              war.window.document.removeEventListener(\'keydown\', onDocumentKeyDown, false);\n              try {\n                Sk.misceval.apply(tearDownPy, undefined, undefined, undefined, [war.exceptionPy]);\n              }\n              catch(e) {\n                // For backwards compatibility, try again with zero arguments.\n                try {\n                  Sk.misceval.apply(tearDownPy, undefined, undefined, undefined, []);\n                }\n                catch(e) {\n                  // We\'re just going to have to eat this one or log it.\n                }\n              }\n            }\n            else {\n              war.requestID = war.window.requestAnimationFrame(animate);\n              try {\n                var timePy = Sk.ffi.numberToFloatPy(war.elapsed / 1000);\n                Sk.misceval.apply(tickPy, undefined, undefined, undefined, [timePy]);\n              }\n              catch(e) {\n                war.exceptionPy = e;\n                war.escKeyPressed = true;\n              }\n            }\n          };\n          animate(null);\n        },\n        toString: function() {\n          return WINDOW_ANIMATION_RUNNER;\n        }\n      };\n      Sk.ffi.referenceToPy(new WindowAnimationRunner(), WINDOW_ANIMATION_RUNNER, undefined, selfPy);\n    });\n    $loc.__getattr__ = Sk.ffi.functionPy(function(selfPy, name) {\n      var war = Sk.ffi.remapToJs(selfPy);\n      switch(name) {\n        case METHOD_START: {\n          return Sk.ffi.callableToPy(mod, METHOD_START, function(methodPy) {\n            Sk.ffi.checkMethodArgs(METHOD_START, arguments, 0, 0);\n            war.start();\n          });\n        }\n      }\n    });\n    $loc.__str__ = Sk.ffi.functionPy(function(selfPy) {\n      return Sk.ffi.stringToPy(WINDOW_ANIMATION_RUNNER);\n    });\n    $loc.__repr__ = Sk.ffi.functionPy(function(selfPy) {\n      return Sk.ffi.stringToPy(WINDOW_ANIMATION_RUNNER + "(" + ")");\n    });\n  }, WINDOW_ANIMATION_RUNNER, []);\n\n  return mod;\n}\n',
    'src/lib/units/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineUnits(mod, BLADE);\n  return mod;\n};',
    'src/lib/pythonds/basic/__init__.py': '\n#__all__ = ["stack"]\n\n\n#from .stack import Stack\n#from .queue import Queue\n\n\n\n',
    'src/lib/geometry/__init__.js': 'var $builtinmodule = function(moduleNamePy) {\n  var mod = {};\n  Sk.stdlib.defineThree(mod, BLADE);\n  Sk.builtin.defineGeometry(mod, THREE, Sk.ffi.remapToJs(moduleNamePy));\n  Sk.builtin.defineProbeE3(mod, THREE);\n  return mod;\n}\n',
    'src/lib/sprite/__init__.js': '//\n//\n// Sprite Graphics Module for DaVinci.\n//\n// Based on the turtle module by Brad Miller.\n//\n// Dependencies:\n//   jQuery\n//\n//\n\nvar SpriteGraphics; // the single identifier needed in the global scope\n\nif (! SpriteGraphics) {\n  SpriteGraphics = {};\n}\n\n\n(function () {\n\n  var Degree2Rad = Math.PI / 180.0; // conversion factor for degrees to radians.\n  var Rad2Degree = 180.0 / Math.PI; // conversion factor for radians to degrees.\n\n  function SpriteCanvas(options) {\n    this.canvasID = SpriteGraphics.defaults.canvasID;\n    if (options.canvasID) {\n      this.canvasID = options.canvasID;\n    }\n\n    this.canvas = document.getElementById(this.canvasID);\n    this.context = this.canvas.getContext(\'2d\');\n    $(this.canvas).fadeIn();\n\n    this.lineScale = 1.0;\n    this.xptscale = 1.0;\n    this.yptscale = 1.0;\n\n    this.llx = -this.canvas.width / 2;\n    this.lly = -this.canvas.height / 2;\n    this.urx = this.canvas.width / 2;\n    this.ury = this.canvas.height / 2;\n    this.setup(this.canvas.width,this.canvas.height);\n    SpriteGraphics.canvasInit = true;\n    this.tlist = []\n\n    this.timeFactor = 5;\n    if (SpriteGraphics.defaults.animate) {\n      this.delay = 5 * this.timeFactor;\n    }\n    else {\n      this.delay = 0;\n    }\n    this.segmentLength = 10;\n    this.renderCounter = 1;\n    this.clearPoint = 0;\n    SpriteGraphics.canvasLib[this.canvasID] = this;\n    //  This can be set to false AFTER the program completes to turn off the fade out on the canvas as a result of exitonclick\n    Sk.tg.fadeOnExit = true;\n  }\n\n  SpriteCanvas.prototype.setup = function(width, height) {\n    this.canvas.width = width;\n    this.canvas.height = height;\n    this.lineScale = 1.0;\n    this.xptscale = 1.0;\n    this.yptscale = 1.0;\n\n    this.llx = -this.canvas.width / 2;\n    this.lly = -this.canvas.height / 2;\n    this.urx = this.canvas.width / 2;\n    this.ury = this.canvas.height / 2;\n    this.renderCounter = 1;\n    this.clearPoint = 0;\n    this.timeFactor = 5;\n    if (SpriteGraphics.defaults.animate) {\n      this.delay = 5 * this.timeFactor;\n    }\n    else {\n      this.delay = 0;\n    }\n\n    if (SpriteGraphics.canvasInit == false) {\n      this.context.save();\n      this.context.translate(this.canvas.width / 2, this.canvas.height / 2); // move 0,0 to center.\n      this.context.scale(1, -1); // scaling like this flips the y axis the right way.\n      SpriteGraphics.canvasInit = true;\n      SpriteGraphics.eventCount = 0;\n      SpriteGraphics.renderClock = 0;\n      SpriteGraphics.renderTime = 0;\n    }\n    else {\n      this.context.restore();\n      this.context.translate(this.canvas.width / 2, this.canvas.height / 2); // move 0,0 to center.\n      this.context.scale(1, -1); // scaling like this flips the y axis the right way.\n      this.context.clearRect(-this.canvas.width / 2, -this.canvas.height / 2, this.canvas.width, this.canvas.height);\n    }\n  }\n\n  SpriteCanvas.prototype.addToCanvas = function(t) {\n    this.tlist.push(t);\n  }\n\n  SpriteCanvas.prototype.onCanvas = function(t) {\n    return (this.tlist.indexOf(t) >= 0);\n  }\n\n  SpriteCanvas.prototype.isAnimating = function() {\n    return (this.tlist.length > 0);\n  }\n\n  SpriteCanvas.prototype.startAnimating = function(t) {\n    if (! this.isAnimating()) {\n      this.intervalId = setTimeout(render, this.delay);\n    }\n    // Added in case startAnimating is called after it\'s already been added.\n    if (!this.onCanvas(t)) {\n      this.addToCanvas(t);\n    }\n    Sk.isSpriteProgram = true;\n  }\n\n  SpriteCanvas.prototype.doneAnimating = function(t) {\n    this.tlist.splice(0,this.tlist.length);\n    clearTimeout(this.intervalId);\n    $(Sk.runButton).removeAttr(\'disabled\');\n  }\n\n  SpriteCanvas.prototype.cancelAnimation = function() {\n    if (this.intervalId) {\n      clearTimeout(this.intervalId);\n    }\n\n    for (var t in this.tlist) {\n      this.tlist[t].aCount = this.tlist[t].drawingEvents.length - 1;\n    }\n    render();\n  }\n\n  SpriteCanvas.prototype.setSpeedDelay = function(s) {\n    var df = 10 - (s % 11) + 1;\n    this.delay = df * this.timeFactor;\n  }\n\n  SpriteCanvas.prototype.setDelay = function(d) {\n    this.delay = d;\n  }\n\n  SpriteCanvas.prototype.getDelay = function(s) {\n    return this.delay;\n  }\n\n  SpriteCanvas.prototype.setCounter = function(s) {\n    if (!s || s <= 0) {\n      s = 1;\n    }\n    this.renderCounter = s;\n  }\n\n  SpriteCanvas.prototype.getCounter = function() {\n    return this.renderCounter;\n  }\n\n  SpriteCanvas.prototype.setworldcoordinates = function(llx, lly, urx, ury) {\n    this.context.restore();\n    this.context.scale(this.canvas.width / (urx - llx), -this.canvas.height / (ury - lly));\n    if (lly == 0) {\n      this.context.translate(-llx, lly - (ury - lly));\n    }\n    else if (lly > 0) {\n      this.context.translate(-llx, -lly * 2);\n    }\n    else {\n      this.context.translate(-llx, -ury);\n    }\n\n    var xlinescale = (urx - llx) / this.canvas.width;\n    var ylinescale = (ury - lly) / this.canvas.height;\n    this.xptscale = xlinescale;\n    this.yptscale = ylinescale;\n    this.lineScale = Math.min(xlinescale,ylinescale);\n    this.context.save();\n\n    this.llx = llx;\n    this.lly = lly;\n    this.urx = urx;\n    this.ury = ury;\n\n  }\n\n  SpriteCanvas.prototype.window_width = function() {\n    return this.canvas.width;\n  }\n\n  SpriteCanvas.prototype.window_height = function() {\n    return this.canvas.height;\n  }\n\n  SpriteCanvas.prototype.bgcolor = function(c) {\n    this.background_color = c;\n    $(this.canvas).css("background-color",c.v);\n  }\n\n  SpriteCanvas.prototype.setSegmentLength = function(s) {\n    this.segmentLength = s;\n  }\n\n  SpriteCanvas.prototype.getSegmentLength = function() {\n    return this.segmentLength;\n  }\n\n  // todo: if animating, this should be deferred until the proper time\n  SpriteCanvas.prototype.exitonclick = function () {\n    var canvas_id = this.canvasID;\n    var theCanvas = this;\n    $(this.canvas).click(function() {\n      if (! theCanvas.isAnimating()) {\n        if (Sk.tg.fadeOnExit) {\n         $("#"+canvas_id).hide();\n       }\n       $("#"+canvas_id).unbind(\'click\');\n       Sk.tg.canvasInit = false;\n       delete Sk.tg.canvasLib[canvas_id];\n     }\n   });\n  }\n\n  SpriteCanvas.prototype.sprites = function() {\n    return SpriteGraphics.spriteList;\n  }\n\n /**\n  * New version NOT attached to a sprite (as per real sprite)\n  */\n  SpriteCanvas.prototype.tracer = function(t, d) {\n    this.setCounter(t);\n    if (t == 0) {\n      for (var i in this.spriteList) {\n        this.spriteList[i].animate = false;\n      }\n      this.cancelAnimation();\n    }\n    if (d !== undefined) {\n      this.setDelay(d);\n    }\n  }\n\n  // check if all sprites are done\n  allDone = function() {\n    var allDone = true;\n    for (var tix in SpriteGraphics.spriteList) {\n      var theT = SpriteGraphics.spriteList[tix];\n      allDone = allDone && (theT.aCount >= theT.drawingEvents.length);\n    }\n    return allDone;\n  }\n\n  //\n  //  This is the function that provides the animation\n  //\n  render = function () {\n    var context = document.getElementById(SpriteGraphics.defaults.canvasID).getContext(\'2d\');\n    with (context) {\n      with (SpriteGraphics.canvasLib[SpriteGraphics.defaults.canvasID]) {\n        clearRect(llx, lly, (urx - llx), (ury - lly));\n      }\n      var incr = SpriteGraphics.canvasLib[SpriteGraphics.defaults.canvasID].getCounter();\n      var lastCanvas = null;\n\n      SpriteGraphics.renderClock += incr;\n\n      for (var tix in SpriteGraphics.spriteList) {\n        var t = SpriteGraphics.spriteList[tix]\n        lastCanvas = t.spriteCanvas \n        if (t.aCount >= t.drawingEvents.length) {\n          t.aCount = t.drawingEvents.length - 1;\n        }\n        moveTo(0, 0);\n        var currentPos = new Vector(0,0,0);\n        var currentHead = new Vector(1,0,0);\n        lineWidth = t.get_pen_width();\n        lineCap = \'round\';\n        lineJoin = \'round\';\n        strokeStyle = \'black\';\n        var filling = false;\n        if (isNaN(t.spriteCanvas.delay)) {\n          t.spriteCanvas.delay = 0\n        }\n        for (var i = t.clearPoint; (i <= t.aCount || t.spriteCanvas.delay == 0) && i < t.drawingEvents.length; i++) {\n          if (i > t.aCount) {\n            // If se jump past aCount, jump it ahead\n            t.aCount = i\n          }\n          var oper = t.drawingEvents[i];\n          var ts = oper[oper.length-1];\n          if (ts <= SpriteGraphics.renderClock || t.spriteCanvas.delay == 0) {\n            if (ts > SpriteGraphics.renderClock) {\n              // If we go past the render clock, jump it ahead\n              SpriteGraphics.renderClock = ts\n            }\n            if (oper[0] == "LT") {  //  line to\n              if (! filling) {\n                beginPath();\n                moveTo(oper[1], oper[2]);\n              }\n              lineTo(oper[3], oper[4]);\n              strokeStyle = oper[5];\n              stroke();\n              currentPos = new Vector(oper[3],oper[4],0);\n              if (! filling)\n                closePath();\n            }\n            else if (oper[0] == "MT") {  // move to\n              moveTo(oper[3], oper[4]);\n              currentPos = new Vector(oper[3],oper[4],0);\n            }\n            else if (oper[0] == "BF") {  // begin fill\n              beginPath();\n              moveTo(oper[1], oper[2]);\n              filling = true;\n            }\n            else if (oper[0] == "EF") {  // end fill\n              fillStyle = oper[3];\n              stroke();\n              fill();\n              closePath();\n              filling = false;\n            }\n            else if (oper[0] == "FC") {  // fill color\n              fillStyle = oper[1];\n            }\n            else if (oper[0] == "TC") {  // sprite color\n              strokeStyle = oper[1];\n            }\n            else if (oper[0] == "PW") {  // Pen width\n              lineWidth = oper[1];\n            }\n            else if (oper[0] == "DT") {  // Dot\n              var col = fillStyle;\n              fillStyle = oper[2];\n              var size = oper[1];\n              fillRect(oper[3] - size / 2, oper[4] - size / 2, size, size);\n              fillStyle = col;\n            }\n            else if (oper[0] == "CI") {  // Circle\n              if (!filling)\n                beginPath();\n              arc(oper[1], oper[2], oper[3], oper[4], oper[5], oper[6]);\n              currentPos = new Vector(oper[1]+Sk.math.cos(oper[5])*oper[3],\n                oper[2]+Sk.math.sin(oper[5])*oper[3],0);\n              stroke();\n              if (! filling) {\n                closePath();\n              }\n            }\n            else if (oper[0] == "WT") { // write\n              if (font)\n                font = oper[2];\n              scale(1, -1);\n              fillText(oper[1], oper[3], -oper[4]);\n              scale(1, -1);\n            } else if (oper[0] == "ST") {  // stamp\n              t.drawSprite(oper[3], new Vector(oper[1], oper[2], 0));\n            } else if (oper[0] == "HT") { // hide sprite\n              t.visible = false;\n            } else if (oper[0] == "SH") { // show sprite\n              t.visible = true;\n            } else if (oper[0] == "TT") {\n              currentHead = oper[1];\n            } else if (oper[0] == "CL") { // RNL clear\n              clear_canvas(t.canvasID);\n              t.clearPoint = i; // Different from reset that calls clear because it leaves the sprites where they are\n            } else if (oper[0] == "DL") { // RNL delay\n              var df = oper[1];\n              t.spriteCanvas.delay = df\n            } else if (oper[0] == "SC") { // RNL speed change\n              var s = oper[1]\n              if (s < 0)\n                s = 0\n              if (s > 10)\n                s = 10\n              var df = (10 - (s % 11) + 1) * t.spriteCanvas.timeFactor  //  10\n              if (s == 0) {\n                df = 0\n              }\n              // t.spriteCanvas.intervalId = clearInterval(t.spriteCanvas.intervalId);\n              t.spriteCanvas.delay = df;\n              // t.spriteCanvas.intervalId = setInterval(render, t.spriteCanvas.delay)\n              if (oper[2]) {\n                t.spriteCanvas.setSegmentLength(oper[2]);\n              }\n            } else if (oper[0] == "NO") {\n              // RNL no op\n            } else {\n            } // end of oper[0] test\n          } // end of if ts < render clock\n        } // end of for\n        t.aCount += incr;\n        if (t.visible) {\n          // draw the sprite\n          t.drawSprite(currentHead.toAngle(), currentPos); // just use currentHead\n        }\n      }\n      // if (t.aCount >= t.drawingEvents.length) {\n      if (SpriteGraphics.renderClock > SpriteGraphics.eventCount ){ // && allDone() ){\n        // t.spriteCanvas.doneAnimating(t);\n        if (lastCanvas) lastCanvas.doneAnimating(t);\n      }\n      else {\n        // t.spriteCanvas.intervalId = setTimeout(render, t.spriteCanvas.delay)\n        if (lastCanvas) {\n          lastCanvas.intervalId = setTimeout(render, lastCanvas.delay)\n        }\n      }\n    }\n  }\n\n  // Constructor for Sprite objects\n  function Sprite() {\n    if (arguments.length >= 1) {\n      this.initialize(arguments[0]);\n    }\n    else {\n      this.initialize();\n    }\n    SpriteGraphics.spriteList.push(this);\n  }\n\n  Sprite.prototype.go_home = function () {\n    // Put sprite in initial state\n    // sprite is headed to the right\n    // with position 0,0,0 in the middle of the canvas.\n    // x grows to the right\n    // y grows towards the top of the canvas\n    with (this) {\n      position = home;\n      context.moveTo(home[0], home[1]);\n      heading = new Vector([1.0, 0.0, 0.0]); // to the right; in sprite space x+ direction\n      normal = new Vector([0.0, 0.0, -1.0]); // in z- direction\n    }\n  };\n\n  Sprite.prototype.initialize = function () {\n    // Initialize the sprite.\n    var options = { };\n\n    if (arguments.length >= 1) {\n      options = arguments[0];\n    }\n\n    this.canvasID = SpriteGraphics.defaults.canvasID;\n    if (options.canvasID) {\n      this.canvasID = options.canvasID;\n    }\n    this.context = document.getElementById(this.canvasID).getContext(\'2d\');\n\n    this.animate = SpriteGraphics.defaults.animate;\n\n    with (this.context) {\n      if (SpriteGraphics.canvasInit == false) {\n        save();\n        translate(canvas.width / 2, canvas.height / 2); // move 0,0 to center.\n        scale(1, -1); // scaling like this flips the y axis the right way.\n        if (! SpriteGraphics.canvasLib[this.canvasID]) {\n          SpriteGraphics.canvasLib[this.canvasID] = new SpriteCanvas(options);\n        }\n        SpriteGraphics.canvasInit = true;\n      }\n      else {\n        clear_canvas(this.canvasID);\n      }\n\n      this.spriteCanvas = SpriteGraphics.canvasLib[this.canvasID];\n      this.home = new Vector([0.0, 0.0, 0.0]);\n      this.visible = true;\n      this.shapeStore = {};\n      this.shapeStore[\'turtle\'] = turtleShapePoints();\n      this.shapeStore[\'arrow\'] = defaultShapePoints();\n      this.shapeStore[\'circle\'] = circleShapePoints();\n      this.shapeStore[\'classic\'] = classicShapePoints();\n      this.currentShape = \'classic\';\n      this.drawingEvents = [];\n\n      this.filling = false;\n      this.pen = true;\n      this.penStyle = \'black\';\n      this.penWidth = 2;\n      this.fillStyle = \'black\';\n      this.position = [ ];\n      this.heading = [ ];\n      this.normal = [ ];\n      this.go_home();\n      this.aCount = 0;\n      this.clearPoint = 0;\n    }\n  }\n\n  function turtleShapePoints() {\n    var pl = [\n    [0,16],\n    [-2,14],\n    [-1,10],\n    [-4,7],\n    [-7,9],\n    [-9,8],\n    [-6,5],\n    [-7,1],\n    [-5,-3],\n    [-8,-6],\n    [-6,-8],\n    [-4,-5],\n    [0,-7],\n    [4,-5],\n    [6,-8],\n    [8,-6],\n    [5,-3],\n    [7,1],\n    [6,5],\n    [9,8],\n    [7,9],\n    [4,7],\n    [1,10],\n    [2,14]\n    ];\n    res = [];\n    for (p in pl) {\n      res.push(new Vector(pl[p]));\n    }\n    return res;\n  }\n\n  function defaultShapePoints() {\n    var pl = [\n    [-10,0],\n    [10,0],\n    [0,10]\n    ];\n    res = [];\n    for (p in pl) {\n      res.push(new Vector(pl[p]));\n    }\n    return res;\n  }\n\n  function circleShapePoints() {\n    var pl = [\n    [10,0],\n    [9.51,3.09],\n    [8.09,5.88],\n    [5.88,8.09],\n    [3.09,9.51],\n    [0,10],\n    [-3.09,9.51],\n    [-5.88,8.09],\n    [-8.09,5.88],\n    [-9.51,3.09],\n    [-10,0],\n    [-9.51,-3.09],\n    [-8.09,-5.88],\n    [-5.88,-8.09],\n    [-3.09,-9.51],\n    [-0.00,-10.00],\n    [3.09,-9.51],\n    [5.88,-8.09],\n    [8.09,-5.88],\n    [9.51,-3.09]\n    ];\n    res = [];\n    for (p in pl) {\n      res.push(new Vector(pl[p]));\n    }\n    return res;\n  }\n\n  function classicShapePoints() {\n    var pl = [\n    [0,0],\n    [-5,-9],\n    [0,-7],\n    [5,-9]\n    ];\n    res = [];\n    for (p in pl) {\n      res.push(new Vector(pl[p]));\n    }\n    return res;\n  }\n\n  Sprite.prototype.clean = function () {\n    // Clean the canvas\n    // Optional second argument is color\n    with (this) {\n      if (arguments.length >= 1) {\n        clear_canvas(canvasID, arguments[0]);\n      }\n      else {\n        clear_canvas(canvasID);\n      }\n      initialize();\n    }\n  }\n\n  Sprite.prototype.addDrawingEvent = function(eventList) {\n    SpriteGraphics.eventCount += 1;\n    eventList.push(SpriteGraphics.eventCount);\n    this.drawingEvents.push(eventList);\n  }\n\n  //  \n  //  Drawing Functions\n  //\n\n    // break a line into segments\n    // sp:  Vector of starting position\n    // ep:  Vector of ending position\n    // sl:  int length of segments\n    segmentLine = function(sp, ep, sL, pen) {\n      var head = ep.sub(sp).normalize();\n      var numSegs = Math.floor(ep.sub(sp).len() / sL);\n      var res = [];\n      var oldp = sp;\n      var newp;\n      var op = ""\n      if (pen)\n        op = "LT"\n      else\n        op = "MT"\n      for (var i = 0; i < numSegs; i++) {\n        newp = oldp.linear(1, sL, head);\n        res.push([op,oldp[0],oldp[1],newp[0],newp[1]]);\n        oldp = newp;\n      }\n      if (! ((oldp[0] == ep[0]) && (oldp[1] == ep[1])))\n        res.push([op, oldp[0], oldp[1], ep[0], ep[1]]);\n      return res;\n    }\n\n    Sprite.prototype.draw_line = function(newposition) {\n      with (this) {\n        with (context) {\n          if (! animate) {\n            if (! filling) {\n              beginPath();\n              moveTo(position[0], position[1]);\n            }\n            lineCap = \'round\';\n            lineJoin = \'round\';\n            lineWidth = get_pen_width();\n            strokeStyle = penStyle;\n            lineTo(newposition[0], newposition[1]);\n            stroke();\n            if (! filling)\n              closePath();\n          } else {\n            var r = segmentLine(position, newposition, spriteCanvas.getSegmentLength(), pen);\n            for (var s in r) {\n              r[s].push(penStyle);\n              addDrawingEvent(r[s]);\n            }\n            if (! spriteCanvas.isAnimating()) {\n              spriteCanvas.startAnimating(this);\n            } else {\n              if (! spriteCanvas.onCanvas(this))\n                spriteCanvas.addToCanvas(this);\n            }\n          }\n        }\n      }\n    }\n\n    Sprite.prototype.forward = function (d) {\n      with (this) {\n        var newposition = position.linear(1, d, heading);\n        goto(newposition);\n      }\n    }\n\n    Sprite.prototype.backward = function(d) {\n      this.forward(-d);\n    }\n\n    // This is an internal function that sets the position without doing any drawing\n    Sprite.prototype.teleport_to = function(nx, ny) {\n      if (nx instanceof Vector)\n        var newposition = nx;\n      else\n        var newposition = new Vector([nx,ny,0]);\n      this.context.moveTo(newposition[0], newposition[1]);\n      this.position = newposition;\n    }\n\n    Sprite.prototype.goto = function(nx, ny) {\n      if (nx instanceof Vector)\n        var newposition = nx;\n      else\n        var newposition = new Vector([nx,ny,0]);\n      with (this) {\n        if (pen) {\n          draw_line(newposition);\n        } else {\n          if (! animate) {\n            context.moveTo(newposition[0], newposition[1]);\n          } else {\n            var r = segmentLine(position, newposition, spriteCanvas.getSegmentLength(), pen);\n            for (var s in r)\n              addDrawingEvent(r[s]);\n            if (! spriteCanvas.isAnimating()) {\n              spriteCanvas.startAnimating(this);\n            } else {\n              if (! spriteCanvas.onCanvas(this))\n                spriteCanvas.addToCanvas(this);\n            }\n          }\n        }\n        position = newposition;\n      }\n    }\n\n    Sprite.prototype.delay = function(d) {\n      if (d != null) {\n        if (d < 0) {\n          d = -d;\n        }\n        if (!this.animate) {\n          this.spriteCanvas.setDelay(d);\n        } \n        else {\n          this.spriteCanvas.setDelay(d);\n          this.addDrawingEvent(["DL", d]);\n          this.addDrawingEvent(["NO"]);\n        }\n      }\n      return this.spriteCanvas.getDelay();\n    }\n\n    Sprite.prototype.speed = function(s,t) {\n      if (s > 0 && !this.animate) {\n        this.animate = true;\n        this.spriteCanvas.setSpeedDelay(s);\n      }\n      else if (s == 0 && !this.animate) {\n        this.spriteCanvas.setSpeedDelay(s);\n      }\n      else {\n        // this.animate = false;\n        // this.spriteCanvas.cancelAnimation();\n        this.addDrawingEvent(["SC", s, t]);\n        this.addDrawingEvent(["NO"]);\n      }\n      if (t) {\n        this.spriteCanvas.setSegmentLength(t);\n        // set the number of units to divide a segment into\n      }\n      else {\n        this.spriteCanvas.setSegmentLength(10);\n      }\n    }\n\n    Sprite.prototype.tracer = function(t, d) {\n      this.spriteCanvas.setCounter(t);\n      if (t == 0) {\n       this.animate=false;\n       this.spriteCanvas.cancelAnimation();\n     }\n     if (d !== undefined)\n       this.spriteCanvas.setDelay(d);\n   }\n\n   Sprite.prototype.getRenderCounter = function() {\n    return this.spriteCanvas.getCounter();\n  }\n\n  Sprite.prototype.turn = function (phi) {\n    with (this) {\n      var alpha = phi * Degree2Rad;\n      var left = normal.cross(heading);\n      var newheading = heading.rotateNormal(left, normal, alpha);\n      heading = newheading;\n\n      if (animate) {\n        addDrawingEvent(["TT",heading]);\n      }\n    }\n  }\n\n  Sprite.prototype.right = Sprite.prototype.turn;\n\n  Sprite.prototype.left = function(phi) {\n    this.turn(-phi);\n  }\n\n  Sprite.prototype.get_heading = function () {\n    if (SpriteGraphics.defaults.degrees)\n      return this.heading.toAngle()\n    else\n      return this.heading\n  }\n\n  Sprite.prototype.get_position = function () {\n    return this.position;\n  }\n\n  Sprite.prototype.getx = function () {\n    return this.position[0];\n  }\n\n  Sprite.prototype.gety = function () {\n    return this.position[1];\n  }\n\n  Sprite.prototype.set_heading = function(newhead) {\n    if ((typeof(newhead)).toLowerCase() === \'number\') {\n      this.heading = Vector.angle2vec(newhead);\n    } else {\n      this.heading = newhead;\n    }\n  }\n\n  Sprite.prototype.towards = function(to, y) {\n    // set heading vector to point towards another point.\n    if ((typeof(to)).toLowerCase() === \'number\')\n      to = new Vector(to, y, 0);\n    else if (! (to instanceof Vector)) {\n      to = new Vector(to);\n    }\n    var res = to.sub(this.position);\n    res = res.normalize();\n    if (SpriteGraphics.defaults.degrees)\n      return res.toAngle();\n    else\n      return res;\n  }\n\n  Sprite.prototype.distance = function(to, y) {\n    if ((typeof(to)).toLowerCase() === \'number\')\n      to = new Vector(to, y, 0);\n    return this.position.sub(new Vector(to)).len();\n  }\n\n  Sprite.prototype.dot = function() {\n    var size = 2;\n    if (arguments.length >= 1) size = arguments[0];\n    size = size * this.spriteCanvas.lineScale;\n    with (this) {\n      with (context) {\n        var color = penStyle;\n        var nc = arguments[1] || color;\n        if (! animate) {\n          fillStyle = nc;\n          fillRect(position[0] - size / 2, position[1] - size / 2, size, size);\n          fillStyle = color;\n        } else {\n          addDrawingEvent(["DT", size, nc, position[0], position[1]]);\n        }\n      }\n    }\n  }\n\n  Sprite.prototype.circle = function(radius, extent) {\n    if (extent === undefined) {\n      extent = 360\n    }\n    if (this.animate) {\n     var arcLen = Math.abs(radius * Math.PI * 2.0  * extent / 360);\n     var segLen = this.spriteCanvas.getSegmentLength();\n     if (arcLen <= segLen)\n      this.arc(radius,extent);\n    else {\n        //  Break the arc into segments for animation\n        var extentPart = (segLen / arcLen) * extent;\n        var extentLeft = extent;\n        while (Math.abs(extentLeft) > Math.abs(extentPart)) {\n          this.arc(radius, extentPart);\n          extentLeft = extentLeft - extentPart;\n        }\n        if (Math.abs(extentLeft) > 0.01)\n          this.arc(radius, extentLeft);\n      }\n    } else {\n      this.arc(radius,extent);\n    }\n  }\n  \n  Sprite.prototype.arc = function(radius, extent) {\n    //  Figure out where the sprite is and which way it\'s facing\n    var spriteHeading = this.get_heading()\n    var tx = this.position[0]\n    var ty = this.position[1]\n\n    //  Figure out the circle center\n    var cx = tx + (radius * Sk.math.cos((spriteHeading + 90) * Degree2Rad));\n    var cy = ty + (radius * Sk.math.sin((spriteHeading + 90) * Degree2Rad));\n\n    //  Canvas arc angles go CLOCKWISE, not COUNTERCLOCKWISE like Sprite\n\n    //  Figure out our arc angles\n    var startAngleDeg;\n    if (radius >= 0)\n      startAngleDeg = spriteHeading - 90;\n    else\n      startAngleDeg = spriteHeading + 90;\n\n    var endAngleDeg;\n    if (extent) {\n      if (radius >= 0)\n        endAngleDeg = startAngleDeg + extent;\n      else\n        endAngleDeg = startAngleDeg - extent;\n    }\n    else {\n      if (radius >= 0)\n        endAngleDeg = startAngleDeg + 360;\n      else\n        endAngleDeg = startAngleDeg - 360;\n    }\n\n    //  Canvas angles are opposite\n    startAngleDeg = 360 - startAngleDeg\n    endAngleDeg   = 360 - endAngleDeg\n\n    //  Becuase the y axis has been flipped in HTML5 Canvas with a tanslation, we need to adjust the angles\n    startAngleDeg = -startAngleDeg\n    endAngleDeg   = -endAngleDeg\n\n    //  Convert to radians\n    var startAngle = startAngleDeg * Degree2Rad;\n    var endAngle   = endAngleDeg   * Degree2Rad;\n\n\n    //  Do the drawing\n    if (! this.animate) {\n      if (!this.filling)\n        this.context.beginPath();\n      this.context.arc(cx, cy, Math.abs(radius), startAngle, endAngle, (radius * extent <= 0));\n      this.context.stroke();\n      if (!this.filling)\n        this.context.closePath();\n    }\n    else {\n      this.addDrawingEvent(["CI", cx, cy, Math.abs(radius), startAngle, endAngle, (radius * extent <= 0)]);\n    }\n\n    //  Move the sprite only if we have to\n    if (extent && (extent % 360) != 0) {\n      var turtleArc;\n      if (radius >= 0)\n        turtleArc = extent;\n      else \n        turtleArc = -extent;\n      var newHeading = (spriteHeading + turtleArc) % 360;\n      if (newHeading < 0)\n        newHeading = newHeading + 360;\n\n      var nx = cx + (radius * Sk.math.cos((newHeading - 90) * Degree2Rad));\n      var ny = cy + (radius * Sk.math.sin((newHeading - 90) * Degree2Rad));  //  y coord is inverted in sprite\n\n      //  Move it internally\n      this.set_heading(newHeading);\n      this.teleport_to(nx,ny);\n\n      //  If we\'re animating the sprite, move it on the screen\n      if (this.animate) {\n        this.addDrawingEvent(["TT", this.heading]);\n      }\n    }\n  }\n\n  Sprite.prototype.write = function(theText, move, align, font) {\n    if (! this.animate) {\n      if (font)\n        this.context.font = font.v;\n      this.context.scale(1, -1);\n      this.context.fillText(theText, this.position[0], -this.position[1]);\n      this.context.scale(1, -1);\n    } else {\n      var fontspec;\n      if (font)\n        fontspec = font.v\n      this.addDrawingEvent(["WT", theText, fontspec, this.position[0], this.position[1]]);\n    }\n  }\n\n  Sprite.prototype.setworldcoordinates = function(llx, lly, urx, ury) {\n    this.spriteCanvas.setworldcoordinates(llx, lly, urx, ury);\n  }\n\n  //\n  // Pen and Style functions\n  //\n  Sprite.prototype.pen_down = function () {\n    this.pen = true;\n  }\n\n  Sprite.prototype.down = Sprite.prototype.pen_down;\n\n  Sprite.prototype.pen_up = function () {\n    this.pen = false;\n  }\n\n  Sprite.prototype.up = Sprite.prototype.pen_up;\n\n  Sprite.prototype.get_pen = function () {\n    return this.pen;\n  }\n\n  Sprite.prototype.set_pen_width = function (w) {\n    if (this.animate)\n      this.addDrawingEvent(["PW", w * this.spriteCanvas.lineScale]);\n    else\n      this.penWidth = w;\n  }\n\n  Sprite.prototype.get_pen_width = function() {\n    return this.penWidth * this.spriteCanvas.lineScale;\n  }\n\n  Sprite.prototype.set_pen_color = function (c, g, b) {\n    if (typeof(c) == "string") {\n      this.penStyle = c;\n    }\n    else {\n      var rs\n      var gs\n      var bs\n      if (typeof( c) == "object" && c.length == 3) {\n        var c0 = Sk.builtin.asnum$(c[0]);\n        var c1 = Sk.builtin.asnum$(c[1]);\n        var c2 = Sk.builtin.asnum$(c[2]);\n      }\n      else {\n        var c0 = Sk.builtin.asnum$(c);\n        var c1 = Sk.builtin.asnum$(g);\n        var c2 = Sk.builtin.asnum$(b);\n      }\n      rs = c0.toString(16);\n      gs = c1.toString(16);\n      bs = c2.toString(16);\n      while (rs.length < 2) rs = "0" + rs;\n      while (gs.length < 2) gs = "0" + gs;\n      while (bs.length < 2) bs = "0" + bs;\n      c = "#" + rs + gs + bs;\n      this.penStyle = c;\n    }\n\n    this.context.strokeStyle = c;\n    if (this.animate)\n      this.addDrawingEvent(["TC", c]);\n  }\n\n  Sprite.prototype.set_fill_color = function (c, g, b) {\n    if (typeof(c) == "string") {\n      this.fillStyle = c;\n    }\n    else {\n      var rs\n      var gs\n      var bs\n      if (typeof( c) == "object" && c.length == 3) {\n        var c0 = Sk.builtin.asnum$(c[0]);\n        var c1 = Sk.builtin.asnum$(c[1]);\n        var c2 = Sk.builtin.asnum$(c[2]);\n      } else {\n        var c0 = Sk.builtin.asnum$(c);\n        var c1 = Sk.builtin.asnum$(g);\n        var c2 = Sk.builtin.asnum$(b);\n      }\n      rs = c0.toString(16)\n      gs = c1.toString(16)\n      bs = c2.toString(16)\n      while (rs.length < 2) rs = "0" + rs;\n      while (gs.length < 2) gs = "0" + gs;\n      while (bs.length < 2) bs = "0" + bs;\n      c = "#" + rs + gs + bs;\n      this.fillStyle = c;\n    }\n\n    this.context.fillStyle = c;\n    if (this.animate)\n      this.addDrawingEvent(["FC", c]);\n  }\n\n  Sprite.prototype.begin_fill = function () {\n    if (! this.animate) {\n      this.filling = true;\n      this.context.beginPath();\n      this.context.moveTo(this.position[0], this.position[1]);\n    }\n    else {\n      this.addDrawingEvent(["BF", this.position[0], this.position[1]]);\n    }\n  }\n\n  Sprite.prototype.end_fill = function () {\n    if (! this.animate) {\n      this.context.stroke();\n      this.context.fill();\n      this.context.closePath();\n      this.filling = false;\n    } else\n    this.addDrawingEvent(["EF", this.position[0], this.position[1], this.fillStyle]);\n  }\n\n  Sprite.prototype.showturtle = function() {\n    if (this.animate) {\n      this.addDrawingEvent(["SH"]);\n    }\n    this.visible = true;\n  }\n\n  Sprite.prototype.hideturtle = function() {\n    if (this.animate) {\n      this.addDrawingEvent(["HT"]);\n    }\n    this.visible = false;\n  }\n\n  Sprite.prototype.isvisible = function() {\n    return this.visible;\n  }\n\n  // \n  // Appearance\n  //\n\n  Sprite.prototype.shape = function(s) {\n    if (this.shapeStore[s])\n      this.currentShape = s;\n    else {\n    }\n  }\n\n  Sprite.prototype.drawSprite = function(heading, position) {\n    var rtPoints = [];\n    var plist = this.shapeStore[this.currentShape];\n    var head;\n    if (! (heading === undefined))\n      head = heading - 90.0;\n    else\n      head = this.heading.toAngle() - 90.0;\n    if (! position)\n      position = this.position\n    for (p in plist) {\n      rtPoints.push(plist[p].scale(this.spriteCanvas.xptscale,this.spriteCanvas.yptscale).rotate(head).add(position));\n    }\n    this.context.beginPath();\n    this.context.moveTo(rtPoints[0][0], rtPoints[0][1]);\n    for (var i = 1; i < rtPoints.length; i++) {\n      this.context.lineTo(rtPoints[i][0], rtPoints[i][1]);\n    }\n    this.context.closePath();\n    this.context.stroke();\n    if (this.fillStyle) {\n      this.context.fill();\n    }\n  }\n\n  Sprite.prototype.stamp = function() {\n    // either call drawSprite or just add a DT with current position and heading to the drawingEvents list.\n    if (this.animate) {\n      this.addDrawingEvent(["ST",this.position[0],this.position[1],this.heading.toAngle()]);\n    } else\n    this.drawSprite();\n  }\n\n  Sprite.prototype.clear = function () {\n    if (this.animate) {\n      this.addDrawingEvent(["CL"])\n    }\n    else {\n      clear_canvas(this.canvasID);\n    }\n  }\n\n  function clear_canvas(canId) {\n    with (document.getElementById(canId).getContext(\'2d\')) {\n      if (arguments.length >= 2) {\n        // fillStyle = arguments[1];\n        // fillRect(0, 0, canvas.width, canvas.height);\n      }\n      clearRect(-canvas.width / 2, -canvas.height / 2, canvas.width, canvas.height);\n    }\n  }\n\n\n  // Create a 3d Vector class for manipulating sprite heading, and position.\n\n  function Vector(x, y, z) {\n    if ((typeof(x)).toLowerCase() === \'number\') {\n      Array.prototype.push.call(this, x);\n      Array.prototype.push.call(this, y);\n      Array.prototype.push.call(this, z);\n    }\n    else {\n      for (var i in x) {\n        Array.prototype.push.call(this, x[i]);\n      }\n    }\n  }\n\n\n  // Create a vector object given a direction as an angle.\n  Vector.angle2vec = function(phi) {\n    var res = new Vector([0.0,0.0,0.0]);\n    phi = phi * Degree2Rad;\n    res[0] = Sk.math.cos(phi);\n    res[1] = Sk.math.sin(phi);\n    return res.normalize();\n  }\n\n  // This trick allows you to access a Vector object like an array\n  // myVec[0] == x\n  // myVec[1] == y\n  // myVec[2] == z\n  // we really only need the z for the convenience of rotating!\n  // If we were using Geometric Algebra we wouldn\'t need it at all and could stay in the plane.\n  Vector.prototype.addItem = function(item) {\n    Array.prototype.push.call(this, item);\n  }\n\n  Vector.prototype.linear = function(a, b, v) {\n    var result = [ ];\n    for (var c = 0; c <= 2; ++c) {\n      result[c] = a * this[c] + b * v[c];\n    }\n    return new Vector(result);\n  }\n\n  Vector.prototype.cross = function(v) {\n    // Return cross product of this and v\n    var result = [ ];\n    for (var c = 0; c <= 2; ++c) {\n      result[c] = this[(c + 1) % 3] * v[(c + 2) % 3] - this[(c + 2) % 3] * v[(c + 1) % 3];\n    }\n    return new Vector(result);\n  }\n\n  Vector.prototype.rotate = function(angle) {\n    // Rotate this counter clockwise by angle.\n    var perp = new Vector(-this[1], this[0], 0);\n    angle = angle * Degree2Rad;\n    var c = Sk.math.cos(angle);\n    var s = Sk.math.sin(angle);\n    return new Vector(this[0] * c + perp[0] * s, this[1] * c + perp[1] * s, 0);\n  }\n\n  Vector.prototype.rotateNormal = function(v, w, alpha) {\n    // Return rotation of this in direction of v about w over alpha\n    // Requires: v, w are vectors; alpha is angle in radians\n    //   this, v, w are orthonormal\n    return this.linear(Sk.math.cos(alpha), Sk.math.sin(alpha), v);\n  }\n\n  Vector.prototype.normalize = function() {\n    var n = this.len();\n    var res = this.div(n);\n    return res;\n  }\n\n  Vector.prototype.toAngle = function() {\n    // workaround for values getting set to +/i xxx e -16 fooling the +/- checks below\n    if (Math.abs(this[1]) < 0.00001) this[1] = 0.0;\n    if (Math.abs(this[0]) < 0.00001) this[0] = 0.0;\n    var rads = Math.atan(Math.abs(this[1]) / Math.abs(this[0]));\n    var deg = rads * Rad2Degree;\n    if (this[0] < 0 && this[1] > 0) deg = 180 - deg;\n    else if (this[0] < 0 && this[1] <= 0) deg = 180.0 + deg;\n    else if (this[0] >= 0 && this[1] < 0) deg = 360 - deg;\n    return deg;\n  }\n\n  // divide all vector components by the same value\n  Vector.prototype.div = function(n) {\n    res = []\n    res[0] = this[0] / n;\n    res[1] = this[1] / n;\n    res[2] = this[2] / n;\n    return new Vector(res);\n  }\n\n  // subtract one vector from another\n  Vector.prototype.sub = function(v) {\n    res = new Vector(0, 0, 0);\n    res[0] = this[0] - v[0];\n    res[1] = this[1] - v[1];\n    res[2] = this[2] - v[2];\n    return res;\n  }\n\n  Vector.prototype.add = function(v) {\n    res = new Vector(0, 0, 0);\n    res[0] = this[0] + v[0];\n    res[1] = this[1] + v[1];\n    res[2] = this[2] + v[2];\n    return res;\n  }\n\n  Vector.prototype.smul = function(k) {  // scalar multiplication\n    res = new Vector(0, 0, 0);\n    res[0] = this[0] * k;\n    res[1] = this[1] * k;\n    res[2] = this[2] * k;\n    return res;\n  }\n\n  Vector.prototype.scale = function(xs,ys) {\n    res = new Vector(0,0,0);\n    res[0] =  this[0] * ys;\n    res[1] =  this[1] * xs;\n    res[2] = 1.0;\n    return res;\n  }\n\n  Vector.prototype.len = function() {\n    return Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);\n  }\n\n  SpriteGraphics.defaults = {canvasID: \'mycanvas\', degrees: true, animate: true};\n  SpriteGraphics.spriteList = [];\n  SpriteGraphics.Sprite = Sprite;\n  SpriteGraphics.SpriteCanvas = SpriteCanvas;\n  SpriteGraphics.canvasLib = {};\n  SpriteGraphics.clear_canvas = clear_canvas;\n  SpriteGraphics.Vector = Vector;\n  SpriteGraphics.canvasInit = false;\n  SpriteGraphics.eventCount = 0;\n  SpriteGraphics.renderClock = 0;\n  SpriteGraphics.renderTime  = 0;\n\n})();\n\nvar $builtinmodule = function(name) {\n\n  var mod = {};\n\n  Sk.builtin.defineEuclidean2(mod, BLADE);\n\n  // The exported name of the SPRITE class.\n  var SPRITE = "Sprite";\n\n  // First we create an object, this will end up being the class\n  Sk.tg = SpriteGraphics;\n\n  var checkArgs = function(expected, actual, func) {\n    if (actual != expected ) {\n      throw new Sk.builtin.TypeError(func + " takes exactly " + expected + " positional argument (" + actual + " given)");\n    }\n  }\n\n  var sprite = function($gbl, $loc) {\n\n    $loc.__init__ = new Sk.builtin.func(function(self, options) {\n      SpriteGraphics.defaults = {"canvasID": Sk.canvas, "animate": true, "degrees": true};\n      self.skType = SPRITE;\n      self.tp$name = SPRITE;\n      self.v = new SpriteGraphics.Sprite();\n      if (options instanceof Sk.builtin.dict) {\n        for (var iter = options.tp$iter(), k = iter.tp$iternext(); k !== undefined; k = iter.tp$iternext()) {\n          var v = options.mp$subscript(k);\n          if (v === undefined) {\n            v = null;\n          }\n          var kAsJs = Sk.ffi.remapToJs(k);\n          var vAsJs = Sk.ffi.remapToJs(v);\n          Sk.misceval.callsim(self[\'__setattr__\'], self, kAsJs, v);\n        }\n      }\n    });\n\n    $loc.__getattr__ = new Sk.builtin.func(function(self, key) {\n\n      var BACKWARD = "backward";\n      var BEGIN_FILL = "begin_fill";\n      // color is implemented as a callable attribute for compatibility.\n      var COLOR = "color";\n      var DOWN = "down";\n      var END_FILL = "end_fill";\n      // FILL_COLOR is implemented as a callable attribute for backwcompatibility.\n      var FILL_COLOR = "fillcolor";\n      var FORWARD = "forward";\n      var GOTO = "goto";\n      var LEFT = "left";\n      var POSITION = "position";\n      var RIGHT = "right";\n      // shape is implemented as a callable attribute for compatibility.\n      var SHAPE = "shape";\n      var STAMP = "stamp";\n      var UP = "up";\n      // Capture the target of the attribute operation.\n      var target = self.v;\n\n      switch(key) {\n        case BACKWARD: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = BACKWARD;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, distance) {\n              distance = Sk.builtin.asnum$(distance);\n              checkArgs(2, arguments.length, BACKWARD);\n              target.forward(-distance);\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(BACKWARD)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(BACKWARD)\n            })\n\n          }, BACKWARD, []));\n        }\n        case BEGIN_FILL: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = BEGIN_FILL;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              checkArgs(1, arguments.length, BEGIN_FILL);\n              target.begin_fill();\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(BEGIN_FILL)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(BEGIN_FILL)\n            })\n\n          }, BEGIN_FILL, []));\n        }\n        case COLOR: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = COLOR;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, color, green, blue) {\n              if(color) {\n                if (blue) {\n                  target.set_pen_color(color, green, blue);\n                  target.set_fill_color(color, green, blue);\n                }\n                else {\n                  color = color.v || target.context.fillStyle;\n                  target.set_pen_color(color);\n                  target.set_fill_color(color);\n                }\n              }\n              else {\n                return [target.penStyle, target.fillStyle];\n              }\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(COLOR)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(COLOR)\n            })\n\n          }, COLOR, []));\n        }\n        case DOWN: {\n          return Sk.ffi.callableToPy(mod, DOWN, function(methodPy) {\n            Sk.ffi.checkMethodArgs(DOWN, arguments, 0, 0);\n            target.pen_down();\n          });\n        }\n        case END_FILL: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = END_FILL;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              checkArgs(1, arguments.length, END_FILL);\n              target.end_fill();\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(END_FILL)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(END_FILL)\n            })\n\n          }, END_FILL, []));\n        }\n        case FILL_COLOR: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = FILL_COLOR;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, color, green, blue) {\n              if (color) {\n                if (blue) {\n                  target.set_fill_color(color, green, blue);\n                }\n                else {\n                  color = color.v || target.context.fillStyle;\n                  target.set_fill_color(color);\n                }\n              }\n              else {\n                return target.fillStyle;\n              }\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(FILL_COLOR)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(FILL_COLOR)\n            })\n\n          }, FILL_COLOR, []));\n        }\n        case FORWARD: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = FORWARD;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, distance) {\n              distance = Sk.builtin.asnum$(distance);\n              checkArgs(2, arguments.length, FORWARD);\n              target.forward(distance);\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(FORWARD)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(FORWARD)\n            })\n\n          }, FORWARD, []));\n        }\n        case GOTO: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = GOTO;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, nx, ny) {\n              nx = Sk.builtin.asnum$(nx);\n              ny = Sk.builtin.asnum$(ny);\n              checkArgs(3, arguments.length, GOTO);\n              target.goto(nx, ny);\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(GOTO)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(GOTO)\n            })\n\n          }, GOTO, []));\n        }\n        case LEFT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = LEFT;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, angle) {\n              angle = Sk.builtin.asnum$(angle);\n              checkArgs(2, arguments.length, LEFT);\n              target.turn(-angle);\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(LEFT)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(LEFT)\n            })\n\n          }, LEFT, []));\n        }\n        case POSITION: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = POSITION;\n              checkArgs(1, arguments.length, POSITION);\n            });\n\n            $loc.__getattr__ = new Sk.builtin.func(function(self, key) {\n              switch(key) {\n                case "x": {\n                  var position = target.get_position();\n                  return Sk.builtin.assk$(position[0], Sk.builtin.nmber.float$);\n                }\n                break;\n                case "y": {\n                  var position = target.get_position();\n                  return Sk.builtin.assk$(position[1], Sk.builtin.nmber.float$);\n                }\n                break;\n                default: {\n                  // do nothing.\n                }\n              }\n            });\n\n            $loc.__setattr__ = new Sk.builtin.func(function(self, key, value) {\n              switch(key) {\n                case "x": {\n                  var nx = Sk.builtin.asnum$(value);\n                  checkArgs(3, arguments.length, key);\n                  target.goto(nx, target.gety());\n                }\n                break;\n                case "y": {\n                  var ny = Sk.builtin.asnum$(value);\n                  checkArgs(3, arguments.length, key);\n                  target.goto(target.getx(), ny);\n                }\n                break;\n                default: {\n                  // do nothing.\n                }\n              }\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(POSITION)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(POSITION)\n            })\n\n          }, POSITION, []));\n        }\n        case RIGHT: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = RIGHT;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, angle) {\n              angle = Sk.builtin.asnum$(angle);\n              checkArgs(2, arguments.length, RIGHT);\n              target.turn(angle);\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(RIGHT)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(RIGHT)\n            })\n\n          }, RIGHT, []));\n        }\n        case SHAPE: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = SHAPE;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self, shape) {\n              checkArgs(2, arguments.length, SHAPE);\n              target.shape(shape.v);\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(SHAPE)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(SHAPE)\n            })\n\n          }, SHAPE, []));\n        }\n        case STAMP: {\n          return Sk.misceval.callsim(Sk.misceval.buildClass(mod, function($gbl, $loc) {\n\n            $loc.__init__ = new Sk.builtin.func(function(self) {\n              self.tp$name = STAMP;\n            });\n\n            $loc.__call__ = new Sk.builtin.func(function(self) {\n              checkArgs(1, arguments.length, STAMP);\n              target.stamp();\n            });\n\n            $loc.__str__ = new Sk.builtin.func(function(self) {\n              return new Sk.builtin.str(STAMP)\n            })\n\n            $loc.__repr__ = new Sk.builtin.func(function(self, arg) {\n              return new Sk.builtin.str(STAMP)\n            })\n\n          }, STAMP, []));\n        }\n        case UP: {\n          return Sk.ffi.callableToPy(mod, UP, function(methodPy) {\n            Sk.ffi.checkMethodArgs(UP, arguments, 0, 0);\n            target.pen_up();\n          });\n        }\n        default: {\n          // Do nothing\n        }\n      }\n    });\n\n    $loc.__setattr__ = new Sk.builtin.func(function(selfPy, name, valuePy) {\n\n      var COLOR = "color";\n      var FILL_COLOR = "fillcolor";\n      var POSITION = "position";\n      var SHAPE = "shape";\n      var EUCLIDEAN_2 = "Euclidean2";\n\n      switch(name) {\n        case COLOR: {\n          if(valuePy) {\n            var color = valuePy.v || selfPy.v.context.fillStyle;\n            selfPy.v.set_pen_color(color);\n            selfPy.v.set_fill_color(color);\n          }\n        }\n        break;\n        case FILL_COLOR: {\n          if (valuePy) {\n            selfPy.v.set_fill_color(valuePy.v || selfPy.v.context.fillStyle);\n          }\n        }\n        break;\n        case POSITION: {\n          Sk.ffi.checkArgType("value", EUCLIDEAN_2, Sk.ffi.isInstance(valuePy) && Sk.ffi.typeName(valuePy) === EUCLIDEAN_2);\n          var xPy = Sk.ffi.gattr(valuePy, "x");\n          var yPy = Sk.ffi.gattr(valuePy, "y");\n          selfPy.v.goto(Sk.ffi.remapToJs(xPy), Sk.ffi.remapToJs(yPy));\n        }\n        break;\n        case SHAPE: {\n          if (valuePy) {\n            checkArgs(3, arguments.length, SHAPE);\n            selfPy.v.shape(valuePy.v);\n          }\n        }\n        break;\n        default: {\n//          throw new Sk.builtin.AttributeError("\'" + SPRITE + "\' object has no attribute setter \'" + name + "\'.");\n        }\n      }\n    });\n\n    $loc.setposition = new Sk.builtin.func(function(self,nx,ny) {\n      nx = Sk.builtin.asnum$(nx);\n      ny = Sk.builtin.asnum$(ny);\n      checkArgs(3,arguments.length,"setposition()");\n      self.v.up();\n      self.v.goto(nx,ny);\n      self.v.down();\n    });\n\n    $loc.setpos = $loc.setposition;\n\n    $loc.setheading = new Sk.builtin.func(function(self, newhead) {\n      newhead = Sk.builtin.asnum$(newhead);\n      checkArgs(2,arguments.length,"setheading()");\n      return self.v.set_heading(newhead);\n    });\n\n    $loc.seth = $loc.setheading;\n\n    $loc.home = new Sk.builtin.func(function(self) {\n      self.v.go_home();\n    });\n\n    $loc.dot = new Sk.builtin.func(function(self, /*opt*/ size, color) {\n      size = Sk.builtin.asnum$(size);\n      size = size || 1;\n      if (color) {\n        color = color.v || self.v.penStyle;\n      }\n      self.v.dot(size, color);\n    });\n\n    $loc.circle = new Sk.builtin.func(function(self, radius, extent) {\n      radius = Sk.builtin.asnum$(radius);\n      extent = Sk.builtin.asnum$(extent);\n      self.v.circle(radius, extent);\n    });\n\n    $loc.delay = new Sk.builtin.func(function(self, d) {\n      d = Sk.builtin.asnum$(d);\n      return self.v.delay(d);\n    });\n\n    $loc.speed = new Sk.builtin.func(function(self, s, t) {\n      s = Sk.builtin.asnum$(s);\n      t = Sk.builtin.asnum$(t);\n      self.v.speed(s,t);\n    });\n\n    $loc.tracer = new Sk.builtin.func(function(self, t, d) {\n      t = Sk.builtin.asnum$(t);\n      d = Sk.builtin.asnum$(d);\n      self.v.tracer(t, d);\n    });\n\n    $loc.update = new Sk.builtin.func(function(self) {\n      //  Dummy function to emulate update... when not animating, we don\'t save the drawing operations, so this is pointless for us\n    });\n\n    $loc.heading = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,"heading()");\n      return self.v.get_heading();\n    });\n\n    $loc.xcor = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,"xcor()");\n      var res = self.v.getx();\n      return res;\n    });\n\n    $loc.ycor = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,"ycor()");\n      var res = self.v.gety();\n      return res;\n    });\n\n    $loc.towards = new Sk.builtin.func(function(self, tx, ty) {\n      tx = Sk.builtin.asnum$(tx);\n      ty = Sk.builtin.asnum$(ty);\n      if ((typeof(tx)).toLowerCase() === \'number\')\n        tx = [tx, ty, 0];\n      return self.v.towards(tx);\n    });\n\n    // tx can be either a number or a vector position.\n    // tx can not be a sprite at this time as multiple sprites have not been implemented yet.\n    $loc.distance = new Sk.builtin.func(function(self, tx, ty) {\n      tx = Sk.builtin.asnum$(tx);\n      ty = Sk.builtin.asnum$(ty);\n      if ((typeof(tx)).toLowerCase() === \'number\') {\n        tx = [tx, ty, 0];\n      }\n      else {\n        tx = [tx.v.getx(), tx.v.gety(), 0];\n      }\n      return self.v.distance(tx);\n    });\n\n    //\n    // Setting and Measurement\n    //\n\n    $loc.width = new Sk.builtin.func(function(self, w) {\n     w = Sk.builtin.asnum$(w);\n     checkArgs(2,arguments.length,"width()");\n     self.v.set_pen_width(w);\n   });\n\n    $loc.pensize = $loc.width;\n\n    $loc.isdown = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,"isdown()");\n      return self.v.get_pen();\n    });\n\n    $loc.pencolor = new Sk.builtin.func(function(self, color, green, blue) {\n      if (color) {\n        if (blue) {\n          color = Sk.builtin.asnum$(color);\n          green = Sk.builtin.asnum$(green);\n          blue = Sk.builtin.asnum$(blue);\n          self.v.set_pen_color(color, green, blue);\n        }\n        else {\n          color = color.v || self.v.context.fillStyle;\n          self.v.set_pen_color(color);\n        }\n      }\n      else {\n        return self.v.penStyle;\n      }\n    });\n\n    $loc.color = new Sk.builtin.func(function(self, color, green, blue) {\n      if(color) {\n        if (blue) {\n          self.v.set_pen_color(color, green, blue);\n          self.v.set_fill_color(color, green, blue);\n        }\n        else {\n          color = color.v || self.v.context.fillStyle;\n          self.v.set_pen_color(color);\n          self.v.set_fill_color(color);\n        }\n      }\n      else {\n        return [self.v.penStyle, self.v.fillStyle];\n      }\n    });\n\n    $loc.fill = new Sk.builtin.func(function(self, fillt) {\n      if (fillt === undefined)\n        return self.v.filling;\n      if (fillt)\n        self.v.begin_fill();\n      else\n        self.v.end_fill();\n    });\n\n    //\n    // More drawing control\n    //\n\n    $loc.reset = new Sk.builtin.func(function(self) {\n      self.v.clean();\n    });\n\n    $loc.showturtle = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,"showturtle()");\n      self.v.showturtle();\n    });\n\n    $loc.st = $loc.showturtle;\n\n    $loc.hideturtle = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,"hideturtle()");\n      self.v.hideturtle();\n    });\n\n    $loc.ht = $loc.hideturtle;\n\n    $loc.isvisible = new Sk.builtin.func(function(self) {\n      checkArgs(1,arguments.length,"isvisible()");\n      self.v.isvisible()\n    });\n\n    // todo the move, align, and font parameters should be kwargs...\n    $loc.write = new Sk.builtin.func(function(self, mystr, move, align, font) {\n      self.v.write(mystr.v, move, align, font);\n    });\n\n    // todo clean  -- again multiple sprites\n\n    $loc.setworldcoordinates = new Sk.builtin.func(function(self, llx, lly, urx, ury) {\n      llx = Sk.builtin.asnum$(llx);\n      lly = Sk.builtin.asnum$(lly);\n      urx = Sk.builtin.asnum$(urx);\n      ury = Sk.builtin.asnum$(ury);\n      self.v.setworldcoordinates(llx, lly, urx, ury);\n    });\n\n    $loc.clear = new Sk.builtin.func(function(self) {\n      self.v.clear()\n    });\n  }\n\n  mod[SPRITE] = Sk.misceval.buildClass(mod, sprite, SPRITE, []);\n\n  var screen = function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self) {\n      SpriteGraphics.defaults = {canvasID: Sk.canvas, animate: true, degrees: true};\n      var currentCanvas = SpriteGraphics.canvasLib[SpriteGraphics.defaults.canvasID];\n      if (currentCanvas === undefined) {\n        self.theScreen = new SpriteGraphics.SpriteCanvas(SpriteGraphics.defaults);\n      } else {\n        self.theScreen = currentCanvas;\n      }\n    });\n\n    $loc.bgcolor = new Sk.builtin.func(function(self, c) {\n      self.theScreen.bgcolor(c);\n    });\n\n    $loc.setworldcoordinates = new Sk.builtin.func(function(self, llx,lly,urx,ury) {\n     llx = Sk.builtin.asnum$(llx);\n     lly = Sk.builtin.asnum$(lly);\n     urx = Sk.builtin.asnum$(urx);\n     ury = Sk.builtin.asnum$(ury);\n     self.theScreen.setworldcoordinates(llx,lly,urx,ury);\n   });\n\n    $loc.exitonclick = new Sk.builtin.func(function(self) {\n      self.theScreen.exitonclick();\n    });\n\n    $loc.title = new Sk.builtin.func(function(self,titlestring) {\n      // no op....\n    });\n\n    $loc.window_width = new Sk.builtin.func(function(self) {\n      return self.theScreen.window_width();\n    });\n\n    $loc.window_height = new Sk.builtin.func(function(self) {\n      return self.theScreen.window_height();\n    });\n\n    $loc.sprites = new Sk.builtin.func(function(self) {\n      return self.theScreen.sprites();\n    });\n\n    $loc.colormode = new Sk.builtin.func(function(self) {\n      //  Empty function to emulate compatibility\n    });\n\n    var myfunc = function(self, width, height, startx, starty) {\n      width = Sk.builtin.asnum$(width);\n      height = Sk.builtin.asnum$(height);\n      self.theScreen.setup(width,height);\n    }\n    // this should allow for named parameters\n    myfunc.co_varnames = [\'self\',\'width\',\'height\',\'startx\',\'starty\'];\n    myfunc.$defaults = [null,500,500,0,0];\n    $loc.setup = new Sk.builtin.func(myfunc);\n  }\n\n  mod.Screen = Sk.misceval.buildClass(mod, screen, \'Screen\', []);\n\n  mod.tracer = new Sk.builtin.func(function(t, d) {\n    t = Sk.builtin.asnum$(t);\n    d = Sk.builtin.asnum$(d);\n    for (var i in Sk.tg.canvasLib) {\n      Sk.tg.canvasLib[i].tracer(t, d);\n    }\n  });\n\n  mod.update = new Sk.builtin.func(function(self) {\n    //  Dummy function to emulate update... when not animating, we don\'t save the drawing operations, so this is pointless for us\n  });\n\n  return mod\n}\n',
    'src/lib/unittestgui/__init__.py': '__author__ = \'bmiller\'\n\nimport document\n\n\nclass unittest:\n    def __init__(self):\n        self.numPassed = 0\n        self.numFailed = 0\n        self.divid = document.currentDiv()\n        self.mydiv = document.getElementById(self.divid)\n        res = document.getElementById(self.divid+\'_unit_results\')\n        if res:\n            self.resdiv = res\n            res.innerHTML = \'\'\n        else:\n            self.resdiv = document.createElement(\'div\')\n            self.resdiv.setAttribute(\'id\',self.divid+\'_unit_results\')\n            self.resdiv.setAttribute(\'class\',\'unittest-results\')\n        self.mydiv.appendChild(self.resdiv)\n\n        self.tlist = []\n        testNames = {}\n        for name in dir(self):\n            if name[:4] == \'test\' and name not in testNames:\n                self.tlist.append(getattr(self,name))\n                testNames[name]=True\n\n    def setup(self):\n        pass\n\n    def tearDown(self):\n        pass\n\n    def main(self):\n        l = document.createElement(\'ul\')\n        self.resdiv.appendChild(l)\n        self.resList = l\n\n        for func in self.tlist:\n            try:\n                self.setup()\n                func()\n                self.tearDown()\n            except:\n                self.appendResult(\'Error\')\n                self.numFailed += 1\n        self.showSummary()\n\n    def assertEqual(self, actual, expected, feedback=""):\n        res = actual==expected\n        self.appendResult(res,str(actual)+\' to be equal to \',expected, feedback)\n\n    def assertNotEqual(actual, expected, feedback=""):\n        res = actual != expected\n        self.appendResult(res,str(actual)+\' to not equal \',expected,feedback)\n\n    def assertTrue(self,x, feedback=""):\n        res = x\n        self.appendResult(res,str(x)+\' to be \',True,feedback)\n\n    def assertFalse(self,x, feedback=""):\n        res = not x\n        self.appendResult(res,str(x)+\' to be \',False,feedback)\n\n    def assertIs(self,a,b, feedback=""):\n        res = a is b\n        self.appendResult(res,str(a)+\' to be the same object as \',b,feedback)\n\n    def assertIsNot(self,a,b, feedback=""):\n        res = a is not b\n        self.appendResult(res,str(a)+\' to not be the same object as \',b,feedback)\n\n    def assertIsNone(self,x, feedback=""):\n        res = x is None\n        self.appendResult(res,x,None,feedback)\n\n    def assertIsNotNone(self,x, feedback=""):\n        res = x is not None\n        self.appendResult(res,str(x)+\' to not be \',None,feedback)\n\n    def assertIn(self,a,b, feedback=""):\n        res = a in b\n        self.appendResult(res,str(a)+\' to be in \',b,feedback)\n\n    def assertNotIn(self,a,b, feedback=""):\n        res = a not in b\n        self.appendResult(res,str(a)+\' to not be in \',b,feedback)\n\n    def assertIsInstance(self,a,b, feedback=""):\n        res = isinstance(a,b)\n        self.appendResult(res,str(a)+\' to be an instance of \',b,feedback)\n\n    def assertNotIsInstance(self,a,b, feedback=""):\n        res = not isinstance(a,b)\n        self.appendResult(res,str(a)+\' to not be an instance of \',b,feedback)\n\n    def assertAlmostEqual(self,a,b, feedback=""):\n        res = round(a-b,7) == 0\n        self.appendResult(res,str(a)+\' to equal \',b,feedback)\n\n    def assertNotAlmostEqual(self,a,b, feedback=""):\n        res = round(a-b,7) != 0\n        self.appendResult(res,str(a)+\' to not equal \',b,feedback)\n\n    def assertGreater(self,a,b, feedback=""):\n        res = a > b\n        self.appendResult(res,str(a)+\' to be greater than \',b,feedback)\n\n    def assertGreaterEqual(self,a,b, feedback=""):\n        res = a >= b\n        self.appendResult(res,str(a)+\' to be greater than or equal to \',b,feedback)\n\n    def assertLess(self,a,b, feedback=""):\n        res = a < b\n        self.appendResult(res,str(a)+\' to be less than \',b,feedback)\n\n    def assertLessEqual(self,a,b, feedback=""):\n        res = a <= b\n        self.appendResult(res,str(a)+\' to be less than or equal to \',b,feedback)\n\n    def appendResult(self,res,actual,expected,feedback):\n        if res == \'Error\':\n            msg = \'Error\'\n        elif res:\n            msg = \'Pass\'\n            self.numPassed += 1\n        else:\n            msg = \'Fail: expected %s  %s \' % (str(actual),str(expected)) + feedback\n            self.numFailed += 1\n\n        pTag = document.createElement(\'li\')\n        pTag.innerHTML = msg\n        self.resList.appendChild(pTag)\n\n    def showSummary(self):\n        pct = self.numPassed / (self.numPassed+self.numFailed) * 100\n        pTag = document.createElement(\'p\')\n        pTag.innerHTML = "You passed: " + str(pct) + "% of the tests"\n        self.resdiv.appendChild(pTag)\n        if pct < 90:\n            self.resdiv.setCSS(\'background-color\',\'#de8e96\')\n        else:\n            self.resdiv.setCSS(\'background-color\',\'#83d382\')\n\n\n\n',
    'src/lib/matrix/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineMatrix(mod);\n  return mod;\n};',
    'src/lib/webgl/matrix4.js': '// more from \'tdl\'\nvar $builtinmodule = function(name)\n{\n    var mod = {};\n\n    var temp0v3_ = new Float32Array(3);\n    var temp1v3_ = new Float32Array(3);\n    var temp2v3_ = new Float32Array(3);\n\n    var temp0v4_ = new Float32Array(4);\n    var temp1v4_ = new Float32Array(4);\n    var temp2v4_ = new Float32Array(4);\n\n    var temp0m4_ = new Float32Array(16);\n    var temp1m4_ = new Float32Array(16);\n    var temp2m4_ = new Float32Array(16);\n\n    var normalize = function(dst, a) {\n        var n = 0.0;\n        var aLength = a.length;\n        for (var i = 0; i < aLength; ++i)\n            n += a[i] * a[i];\n        n = Math.sqrt(n);\n        if (n > 0.00001) {\n            for (var i = 0; i < aLength; ++i)\n                dst[i] = a[i] / n;\n        } else {\n            for (var i = 0; i < aLength; ++i)\n                dst[i] = 0;\n        }\n        return dst;\n    };\n\n    var cross = function(dst, a, b) {\n        dst[0] = a[1] * b[2] - a[2] * b[1];\n        dst[1] = a[2] * b[0] - a[0] * b[2];\n        dst[2] = a[0] * b[1] - a[1] * b[0];\n        return dst;\n    };\n\n    var subVector = function(dst, a, b) {\n        var aLength = a.length;\n        for (var i = 0; i < aLength; ++i)\n            dst[i] = a[i] - b[i];\n        return dst;\n    };\n\n    var dot = function(a, b) {\n        return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]);\n    };\n\n    mod.lookAt = new Sk.builtin.func(function(view, eye, target, up)\n            {\n                var t0 = temp0v3_;\n                var t1 = temp1v3_;\n                var t2 = temp2v3_;\n\n                var vz = normalize(t0, subVector(t0, eye.v, target.v));\n                var vx = normalize(t1, cross(t1, up.v, vz));\n                var vy = cross(t2, vz, vx);\n\n                var dst = view.v;\n                dst[ 0] = vx[0];\n                dst[ 1] = vy[0];\n                dst[ 2] = vz[0];\n                dst[ 3] = 0;\n                dst[ 4] = vx[1];\n                dst[ 5] = vy[1];\n                dst[ 6] = vz[1];\n                dst[ 7] = 0;\n                dst[ 8] = vx[2];\n                dst[ 9] = vy[2];\n                dst[10] = vz[2];\n                dst[11] = 0;\n                dst[12] = -dot(vx, eye.v);\n                dst[13] = -dot(vy, eye.v);\n                dst[14] = -dot(vz, eye.v);\n                dst[15] = 1;\n\n                return view;\n            });\n\n    mod.perspective = new Sk.builtin.func(function(proj, angle, aspect, near, far)\n            {\n                var f = Math.tan(Math.PI * 0.5 - 0.5 * (angle * Math.PI / 180));\n                var rangeInv = 1.0 / (near - far);\n\n                var dst = proj.v;\n\n                dst[0]  = f / aspect;\n                dst[1]  = 0;\n                dst[2]  = 0;\n                dst[3]  = 0;\n\n                dst[4]  = 0;\n                dst[5]  = f;\n                dst[6]  = 0;\n                dst[7]  = 0;\n\n                dst[8]  = 0;\n                dst[9]  = 0;\n                dst[10] = (near + far) * rangeInv;\n                dst[11] = -1;\n\n                dst[12] = 0;\n                dst[13] = 0;\n                dst[14] = near * far * rangeInv * 2;\n                dst[15] = 0;\n\n                return proj;\n            });\n\n    // builds, not appending\n    mod.rotationY = new Sk.builtin.func(function(target, angle)\n            {\n                var dst = target.v;\n                var c = Sk.math.cos(angle * Math.PI / 180);\n                var s = Sk.math.sin(angle * Math.PI / 180);\n\n                dst[ 0] = c;\n                dst[ 1] = 0;\n                dst[ 2] = -s;\n                dst[ 3] = 0;\n                dst[ 4] = 0;\n                dst[ 5] = 1;\n                dst[ 6] = 0;\n                dst[ 7] = 0;\n                dst[ 8] = s;\n                dst[ 9] = 0;\n                dst[10] = c;\n                dst[11] = 0;\n                dst[12] = 0;\n                dst[13] = 0;\n                dst[14] = 0;\n                dst[15] = 1;\n\n                return target;\n            });\n\n    mod.identity = new Sk.builtin.func(function(target)\n            {\n                var dst = target.v;\n                dst[ 0] = 1;\n                dst[ 1] = 0;\n                dst[ 2] = 0;\n                dst[ 3] = 0;\n                dst[ 4] = 0;\n                dst[ 5] = 1;\n                dst[ 6] = 0;\n                dst[ 7] = 0;\n                dst[ 8] = 0;\n                dst[ 9] = 0;\n                dst[10] = 1;\n                dst[11] = 0;\n                dst[12] = 0;\n                dst[13] = 0;\n                dst[14] = 0;\n                dst[15] = 1;\n                return target;\n            });\n\n    // row major\n    mod.mul = new Sk.builtin.func(function(target, x, y)\n            {\n                var dst = target.v;\n                var a = x.v;\n                var b = y.v;\n                var a00 = a[0];\n                var a01 = a[1];\n                var a02 = a[2];\n                var a03 = a[3];\n                var a10 = a[ 4 + 0];\n                var a11 = a[ 4 + 1];\n                var a12 = a[ 4 + 2];\n                var a13 = a[ 4 + 3];\n                var a20 = a[ 8 + 0];\n                var a21 = a[ 8 + 1];\n                var a22 = a[ 8 + 2];\n                var a23 = a[ 8 + 3];\n                var a30 = a[12 + 0];\n                var a31 = a[12 + 1];\n                var a32 = a[12 + 2];\n                var a33 = a[12 + 3];\n                var b00 = b[0];\n                var b01 = b[1];\n                var b02 = b[2];\n                var b03 = b[3];\n                var b10 = b[ 4 + 0];\n                var b11 = b[ 4 + 1];\n                var b12 = b[ 4 + 2];\n                var b13 = b[ 4 + 3];\n                var b20 = b[ 8 + 0];\n                var b21 = b[ 8 + 1];\n                var b22 = b[ 8 + 2];\n                var b23 = b[ 8 + 3];\n                var b30 = b[12 + 0];\n                var b31 = b[12 + 1];\n                var b32 = b[12 + 2];\n                var b33 = b[12 + 3];\n                dst[ 0] = a00 * b00 + a01 * b10 + a02 * b20 + a03 * b30;\n                dst[ 1] = a00 * b01 + a01 * b11 + a02 * b21 + a03 * b31;\n                dst[ 2] = a00 * b02 + a01 * b12 + a02 * b22 + a03 * b32;\n                dst[ 3] = a00 * b03 + a01 * b13 + a02 * b23 + a03 * b33;\n                dst[ 4] = a10 * b00 + a11 * b10 + a12 * b20 + a13 * b30;\n                dst[ 5] = a10 * b01 + a11 * b11 + a12 * b21 + a13 * b31;\n                dst[ 6] = a10 * b02 + a11 * b12 + a12 * b22 + a13 * b32;\n                dst[ 7] = a10 * b03 + a11 * b13 + a12 * b23 + a13 * b33;\n                dst[ 8] = a20 * b00 + a21 * b10 + a22 * b20 + a23 * b30;\n                dst[ 9] = a20 * b01 + a21 * b11 + a22 * b21 + a23 * b31;\n                dst[10] = a20 * b02 + a21 * b12 + a22 * b22 + a23 * b32;\n                dst[11] = a20 * b03 + a21 * b13 + a22 * b23 + a23 * b33;\n                dst[12] = a30 * b00 + a31 * b10 + a32 * b20 + a33 * b30;\n                dst[13] = a30 * b01 + a31 * b11 + a32 * b21 + a33 * b31;\n                dst[14] = a30 * b02 + a31 * b12 + a32 * b22 + a33 * b32;\n                dst[15] = a30 * b03 + a31 * b13 + a32 * b23 + a33 * b33;\n                return target;\n            });\n\n    mod.invert = new Sk.builtin.func(function(target, mat)\n            {\n                var dst = target.v;\n                var m = mat.v;\n                var m00 = m[0 * 4 + 0];\n                var m01 = m[0 * 4 + 1];\n                var m02 = m[0 * 4 + 2];\n                var m03 = m[0 * 4 + 3];\n                var m10 = m[1 * 4 + 0];\n                var m11 = m[1 * 4 + 1];\n                var m12 = m[1 * 4 + 2];\n                var m13 = m[1 * 4 + 3];\n                var m20 = m[2 * 4 + 0];\n                var m21 = m[2 * 4 + 1];\n                var m22 = m[2 * 4 + 2];\n                var m23 = m[2 * 4 + 3];\n                var m30 = m[3 * 4 + 0];\n                var m31 = m[3 * 4 + 1];\n                var m32 = m[3 * 4 + 2];\n                var m33 = m[3 * 4 + 3];\n                var tmp_0  = m22 * m33;\n                var tmp_1  = m32 * m23;\n                var tmp_2  = m12 * m33;\n                var tmp_3  = m32 * m13;\n                var tmp_4  = m12 * m23;\n                var tmp_5  = m22 * m13;\n                var tmp_6  = m02 * m33;\n                var tmp_7  = m32 * m03;\n                var tmp_8  = m02 * m23;\n                var tmp_9  = m22 * m03;\n                var tmp_10 = m02 * m13;\n                var tmp_11 = m12 * m03;\n                var tmp_12 = m20 * m31;\n                var tmp_13 = m30 * m21;\n                var tmp_14 = m10 * m31;\n                var tmp_15 = m30 * m11;\n                var tmp_16 = m10 * m21;\n                var tmp_17 = m20 * m11;\n                var tmp_18 = m00 * m31;\n                var tmp_19 = m30 * m01;\n                var tmp_20 = m00 * m21;\n                var tmp_21 = m20 * m01;\n                var tmp_22 = m00 * m11;\n                var tmp_23 = m10 * m01;\n\n                var t0 = (tmp_0 * m11 + tmp_3 * m21 + tmp_4 * m31) -\n                    (tmp_1 * m11 + tmp_2 * m21 + tmp_5 * m31);\n                var t1 = (tmp_1 * m01 + tmp_6 * m21 + tmp_9 * m31) -\n                    (tmp_0 * m01 + tmp_7 * m21 + tmp_8 * m31);\n                var t2 = (tmp_2 * m01 + tmp_7 * m11 + tmp_10 * m31) -\n                    (tmp_3 * m01 + tmp_6 * m11 + tmp_11 * m31);\n                var t3 = (tmp_5 * m01 + tmp_8 * m11 + tmp_11 * m21) -\n                    (tmp_4 * m01 + tmp_9 * m11 + tmp_10 * m21);\n\n                var d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);\n\n                dst[ 0] = d * t0;\n                dst[ 1] = d * t1;\n                dst[ 2] = d * t2;\n                dst[ 3] = d * t3;\n                dst[ 4] = d * ((tmp_1 * m10 + tmp_2 * m20 + tmp_5 * m30) -\n                        (tmp_0 * m10 + tmp_3 * m20 + tmp_4 * m30));\n                dst[ 5] = d * ((tmp_0 * m00 + tmp_7 * m20 + tmp_8 * m30) -\n                        (tmp_1 * m00 + tmp_6 * m20 + tmp_9 * m30));\n                dst[ 6] = d * ((tmp_3 * m00 + tmp_6 * m10 + tmp_11 * m30) -\n                        (tmp_2 * m00 + tmp_7 * m10 + tmp_10 * m30));\n                dst[ 7] = d * ((tmp_4 * m00 + tmp_9 * m10 + tmp_10 * m20) -\n                        (tmp_5 * m00 + tmp_8 * m10 + tmp_11 * m20));\n                dst[ 8] = d * ((tmp_12 * m13 + tmp_15 * m23 + tmp_16 * m33) -\n                        (tmp_13 * m13 + tmp_14 * m23 + tmp_17 * m33));\n                dst[ 9] = d * ((tmp_13 * m03 + tmp_18 * m23 + tmp_21 * m33) -\n                        (tmp_12 * m03 + tmp_19 * m23 + tmp_20 * m33));\n                dst[10] = d * ((tmp_14 * m03 + tmp_19 * m13 + tmp_22 * m33) -\n                        (tmp_15 * m03 + tmp_18 * m13 + tmp_23 * m33));\n                dst[11] = d * ((tmp_17 * m03 + tmp_20 * m13 + tmp_23 * m23) -\n                        (tmp_16 * m03 + tmp_21 * m13 + tmp_22 * m23));\n                dst[12] = d * ((tmp_14 * m22 + tmp_17 * m32 + tmp_13 * m12) -\n                        (tmp_16 * m32 + tmp_12 * m12 + tmp_15 * m22));\n                dst[13] = d * ((tmp_20 * m32 + tmp_12 * m02 + tmp_19 * m22) -\n                        (tmp_18 * m22 + tmp_21 * m32 + tmp_13 * m02));\n                dst[14] = d * ((tmp_18 * m12 + tmp_23 * m32 + tmp_15 * m02) -\n                        (tmp_22 * m32 + tmp_14 * m02 + tmp_19 * m12));\n                dst[15] = d * ((tmp_22 * m22 + tmp_16 * m02 + tmp_21 * m12) -\n                        (tmp_20 * m12 + tmp_23 * m22 + tmp_17 * m02));\n                return target;\n            });\n\n    mod.transpose = new Sk.builtin.func(function(target, mat)\n            {\n                var dst = target.v;\n                var m = mat.v;\n                for (var j = 0; j < 4; ++j) {\n                    for (var i = 0; i < 4; ++i)\n                    dst[j * 4 + i] = m[i * 4 + j];\n                }\n                return dst;\n            });\n\n    return mod;\n};\n',
    'src/lib/webgl/__init__.js': 'var $builtinmodule = function(name)\n{\n  var mod = {};\n\n  var makeFailHTML = function(msg) {\n    return \'\' +\n      \'<table style="background-color: #8CE; width: 100%; height: 100%;"><tr>\' +\n      \'<td align="center">\' +\n      \'<div style="display: table-cell; vertical-align: middle;">\' +\n      \'<div style="">\' + msg + \'</div>\' +\n      \'</div>\' +\n      \'</td></tr></table>\';\n  };\n\n  var GET_A_WEBGL_BROWSER = \'\' +\n    \'This page requires a browser that supports WebGL.<br/>\' +\n    \'<a href="http://get.webgl.org">Click here to upgrade your browser.</a>\';\n\n  var NEED_HARDWARE = \'\' +\n    "It doesn\'t appear your computer can support WebGL.<br/>" +\n    \'<a href="http://get.webgl.org">Click here for more information.</a>\';\n  \n  var create3DContext = function(canvas) {\n    var names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];\n    var gl = null;\n    for (var ii = 0; ii < names.length; ++ii) {\n      try {\n        gl = canvas.getContext(names[ii]);\n      }\n      catch(e) {\n      }\n      if (gl) {\n          break;\n      }\n    }\n    if (gl) {\n      // Disallow selection by default. This keeps the cursor from changing to an\n      // I-beam when the user clicks and drags. It\'s easier on the eyes.\n      function returnFalse() {\n        return false;\n      }\n\n      canvas.onselectstart = returnFalse;\n      canvas.onmousedown = returnFalse;\n    }\n    return gl;\n  };\n\n  var setupWebGL = function(canvasContainerId, opt_canvas) {\n    var container = document.getElementById(canvasContainerId);\n    var context;\n    if (!opt_canvas) {\n      opt_canvas = container.getElementsByTagName("canvas")[0];\n    }\n    if (!opt_canvas) {\n        // this browser doesn\'t support the canvas tag at all. Not even 2d.\n      container.innerHTML = makeFailHTML(GET_A_WEBGL_BROWSER);\n      return;\n    }\n\n    var gl = create3DContext(opt_canvas);\n    if (!gl) {\n      // TODO(gman): fix to official way to detect that it\'s the user\'s machine, not the browser.\n      var browserStrings = navigator.userAgent.match(/(\\w+\\/.*? )/g);\n      var browsers = {};\n      try {\n        for (var b = 0; b < browserStrings.length; ++b) {\n          var parts = browserStrings[b].match(/(\\w+)/g);\n          var bb = [];\n          for (var ii = 1; ii < parts.length; ++ii) {\n            bb.push(parseInt(parts[ii]));\n          }\n          browsers[parts[0]] = bb;\n        }\n      }\n      catch (e) {\n      }\n      if (browsers.Chrome &&\n           (browsers.Chrome[0] > 7 ||\n                 (browsers.Chrome[0] == 7 && browsers.Chrome[1] > 0) ||\n                 (browsers.Chrome[0] == 7 && browsers.Chrome[1] == 0 && browsers.Chrome[2] >= 521))) {\n        container.innerHTML = makeFailHTML(NEED_HARDWARE);\n      }\n      else {\n        container.innerHTML = makeFailHTML(GET_A_WEBGL_BROWSER);\n      }\n    }\n    return gl;\n  };\n\n  /**\n   * The Context encapsulates the underlying WebGL native JavaScript API.\n   */\n  mod.Context = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(\n      function(self, canvasid) {\n        var canvas = document.getElementById(canvasid.v);\n        var gl = setupWebGL(canvasid.v, canvas)\n        if (!gl) {\n          throw new Error("Your browser does not appear to support WebGL.");\n        }\n\n        self.gl = gl;\n\n        // Copy symbolic constants and functions from native WebGL, encapsulating where necessary.       \n        for (var k in gl.__proto__) {\n          if (typeof gl.__proto__[k] === \'number\') {\n            Sk.abstr.objectSetItem(self[\'$d\'], new Sk.builtin.str(k), gl.__proto__[k]);\n          }\n          else if (typeof gl.__proto__[k] === "function") {\n            switch(k) {\n              case \'bufferData\': {\n              }\n              break;\n              case \'clearColor\': {\n              }\n              break;\n              case \'drawArrays\': {\n              }\n              break;\n              case \'getAttribLocation\': {\n              }\n              break;\n              case \'getUniformLocation\': {\n              }\n              break;\n              case \'shaderSource\': {\n              }\n              break;\n              case \'uniformMatrix4fv\': {\n              }\n              break;\n              case \'vertexAttribPointer\': {\n              }\n              break;\n              case \'viewport\': {\n              }\n              break;\n              default: {\n                (function(key) {\n                  Sk.abstr.objectSetItem(self[\'$d\'], new Sk.builtin.str(k), new Sk.builtin.func(function() {\n                    var f = gl.__proto__[key];\n                    return f.apply(gl, arguments);\n                  }));\n                 }(k));\n              }\n            }\n          }\n        }\n\n        gl.clearColor(100.0/255.0, 149.0/255.0, 237.0/255.0, 1.0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n      }\n    );\n\n    $loc.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;\n\n    $loc.bufferData = new Sk.builtin.func(\n      function(self, target, data, usage) {\n        self.gl.bufferData(target, data.v, usage);\n      }\n    );\n\n    $loc.clearColor = new Sk.builtin.func(\n      function(self, red, green, blue, alpha) {\n        self.gl.clearColor(Sk.builtin.asnum$(red), Sk.builtin.asnum$(green), Sk.builtin.asnum$(blue), Sk.builtin.asnum$(alpha));\n      }\n    );\n\n    $loc.getAttribLocation = new Sk.builtin.func(\n      function(self, program, name) {\n        return self.gl.getAttribLocation(program, name.v);\n      }\n    );\n\n    $loc.getUniformLocation = new Sk.builtin.func(\n      function(self, program, name) {\n        return self.gl.getUniformLocation(program, name.v);\n      }\n    );\n\n    $loc.shaderSource = new Sk.builtin.func(\n      function(self, shader, src) {\n        self.gl.shaderSource(shader, src.v);\n      }\n    );\n\n    $loc.drawArrays = new Sk.builtin.func(\n      function(self, mode, first, count) {\n        self.gl.drawArrays(Sk.builtin.asnum$(mode), Sk.builtin.asnum$(first), Sk.builtin.asnum$(count));\n      }\n    );\n\n    $loc.vertexAttribPointer = new Sk.builtin.func(\n      function(self, index, size, type, normalized, stride, dunno) {\n        self.gl.vertexAttribPointer(index, Sk.builtin.asnum$(size), Sk.builtin.asnum$(type), normalized, Sk.builtin.asnum$(stride), Sk.builtin.asnum$(dunno));\n      }\n    );\n\n    $loc.viewport = new Sk.builtin.func(\n      function(self, x, y, width, height) {\n        self.gl.viewport(Sk.builtin.asnum$(x), Sk.builtin.asnum$(y), Sk.builtin.asnum$(width), Sk.builtin.asnum$(height));\n      }\n    );\n\n    $loc.uniformMatrix4fv = new Sk.builtin.func(\n      function(self, location, transpose, values) {\n//        console.log("location  " + (typeof location));\n//        console.log("transpose " + (typeof transpose));\n//        console.log("values.v  " + (typeof values.v));\n        self.gl.uniformMatrix4fv(Sk.builtin.asnum$(location), transpose, values.v);\n      }\n    );\n\n    $loc.setDrawFunc = new Sk.builtin.func(function(self, func) {\n      var startTime = (new Date()).getTime();\n      var intervalId = setInterval(\n        function() {\n          Sk.misceval.callsim(func, self, (new Date()).getTime() - startTime);\n        }, 1000.0 / 60.0); // 60 fps\n    });\n\n  }, \'Context\', []);\n\n  mod.Float32Array = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, data) {\n      if (typeof data === "number") {\n        self.v = new Float32Array(data);\n      }\n      else {\n        self.v = new Float32Array(Sk.ffi.remapToJs(data));\n      }\n    });\n\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var copy = [];\n      for (var i = 0; i < self.v.length; ++i) {\n        copy.push(self.v[i]);\n      }\n      return new Sk.builtin.str("[" + copy.join(\', \') + "]");\n     });\n  }, \'Float32Array\', []);\n\n  /**\n   * A 4x4 (mutable) matrix suitable for OpenGL.\n   *\n   * Mutability is chosen for performance.\n   * The inderlying implementation is Float32Array.\n   * The indexing of the elements is\n   * 0 4  8 12\n   * 1 5  9 13\n   * 2 6 10 14\n   * 3 7 11 15\n   */\n  mod.Matrix4x4 = Sk.misceval.buildClass(mod, function($gbl, $loc) {\n    $loc.__init__ = new Sk.builtin.func(function(self, data) {\n      self.v = new Float32Array(Sk.ffi.remapToJs(data));\n    });\n\n    $loc.identity = new Sk.builtin.func(\n      function(self) {\n\n        var m = self.v;\n\n        m[0]  = 1;\n        m[1]  = 0;\n        m[2]  = 0;\n        m[3]  = 0;\n\n        m[4]  = 0;\n        m[5]  = 1;\n        m[6]  = 0;\n        m[7]  = 0;\n\n        m[8]  = 0;\n        m[9]  = 0;\n        m[10] = 1;\n        m[11] = 0;\n\n        m[12] = 0;\n        m[13] = 0;\n        m[14] = 0;\n        m[15] = 1;\n      }\n    );\n\n    $loc.perspective = new Sk.builtin.func(\n      function(self, fov, aspect, near, far) {\n        \n        var t = Math.tan(Math.PI * 0.5 - 0.5 * (Sk.builtin.asnum$(fov) * Math.PI / 180));\n        var a = Sk.builtin.asnum$(aspect)\n        var n = Sk.builtin.asnum$(near)\n        var f = Sk.builtin.asnum$(far)\n        var k = 1.0 / (n - f);\n\n        var m = self.v;\n\n        m[0]  = t / a;\n        m[1]  = 0;\n        m[2]  = 0;\n        m[3]  = 0;\n\n        m[4]  = 0;\n        m[5]  = t;\n        m[6]  = 0;\n        m[7]  = 0;\n\n        m[8]  = 0;\n        m[9]  = 0;\n        m[10] = (n + f) * k;\n        m[11] = -1;\n\n        m[12] = 0;\n        m[13] = 0;\n        m[14] = n * f * k * 2;\n        m[15] = 0;\n      }\n    );\n\n    $loc.translate = new Sk.builtin.func(\n      function(self, translation) {\n\n        var m = self.v;\n        var t = Sk.ffi.remapToJs(translation);\n\n        m[0]  = 1;\n        m[1]  = 0;\n        m[2]  = 0;\n        m[3]  = 0;\n\n        m[4]  = 0;\n        m[5]  = 1;\n        m[6]  = 0;\n        m[7]  = 0;\n\n        m[8]  = 0;\n        m[9]  = 0;\n        m[10] = 1;\n        m[11] = 0;\n\n        m[12] = t[0];\n        m[13] = t[1];\n        m[14] = t[2];\n        m[15] = 1;\n      }\n    );\n\n    $loc.__repr__ = new Sk.builtin.func(function(self) {\n      var copy = [];\n      for (var i = 0; i < self.v.length; ++i) {\n        copy.push(self.v[i]);\n      }\n      return new Sk.builtin.str("[" + copy.join(\', \') + "]");\n     });\n  }, \'Matrix4x4\', []);\n\n  return mod;\n};',
    'src/builtin/sys.js': 'var $builtinmodule = function(name)\n{\n    var sys = {};\n\n    var args = [];\n    var argv = Sk.getSysArgv();\n    for (var i = 0; i < argv.length; ++i)\n        args.push(new Sk.builtin.str(argv[i]));\n    sys.argv = new Sk.builtins[\'list\'](args);\n\n    sys.copyright = Sk.builtin[\'str\']("Copyright 2009-2010 Scott Graham.\\nAll Rights Reserved.\\n");\n\n    sys.modules = Sk.sysmodules;\n\n    sys.path = Sk.realsyspath;\n\n    sys.getExecutionLimit = new Sk.builtin.func(function() {\n        return Sk.execLimit\n    });\n\n    sys.setExecutionLimit = new Sk.builtin.func(function(t) {\n        if (t !==  undefined) {\n            Sk.execLimit = t\n        }\n    });\n\n    sys.resetTimeout = new Sk.builtin.func(function() {\n        Sk.execStart = new Date();\n    });\n\n    sys.debug = new Sk.builtin.func(function() {\n        debugger;\n    });\n\n    return sys;\n};\n',
    'src/lib/pythonds/trees/balance.py': '#!/bin/env python3.1\n# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005, 2010\n# \n\nfrom .bst import BinarySearchTree, TreeNode\n\nclass AVLTree(BinarySearchTree):\n    \'\'\'\n    Author:  Brad Miller\n    Date:  1/15/2005\n    Description:  Imlement a binary search tree with the following interface\n                  functions:  \n                  __contains__(y) <==> y in x\n                  __getitem__(y) <==> x[y]\n                  __init__()\n                  __len__() <==> len(x)\n                  __setitem__(k,v) <==> x[k] = v\n                  clear()\n                  get(k)\n                  has_key(k)\n                  items() \n                  keys() \n                  values()\n                  put(k,v)\n    \'\'\'\n\n\n    def _put(self,key,val,currentNode):\n        if key < currentNode.key:\n            if currentNode.hasLeftChild():\n                self._put(key,val,currentNode.leftChild)\n            else:\n                currentNode.leftChild = TreeNode(key,val,parent=currentNode)\n                self.updateBalance(currentNode.leftChild)\n        else:\n            if currentNode.hasRightChild():\n                self._put(key,val,currentNode.rightChild)\n            else:\n                currentNode.rightChild = TreeNode(key,val,parent=currentNode)\n                self.updateBalance(currentNode.rightChild)                \n\n    def updateBalance(self,node):\n        if node.balanceFactor > 1 or node.balanceFactor < -1:\n            self.rebalance(node)\n            return\n        if node.parent != None:\n            if node.isLeftChild():\n                node.parent.balanceFactor += 1\n            elif node.isRightChild():\n                node.parent.balanceFactor -= 1\n\n            if node.parent.balanceFactor != 0:\n                self.updateBalance(node.parent)\n\n    def rebalance(self,node):\n        if node.balanceFactor < 0:\n            if node.rightChild.balanceFactor > 0:\n                # Do an LR Rotation\n                self.rotateRight(node.rightChild)\n                self.rotateLeft(node)\n            else:\n                # single left\n                self.rotateLeft(node)\n        elif node.balanceFactor > 0:\n            if node.leftChild.balanceFactor < 0:\n                # Do an RL Rotation\n                self.rotateLeft(node.leftChild)\n                self.rotateRight(node)\n            else:\n                # single right\n                self.rotateRight(node)\n\n    def rotateLeft(self,rotRoot):\n        newRoot = rotRoot.rightChild\n        rotRoot.rightChild = newRoot.leftChild\n        if newRoot.leftChild != None:\n            newRoot.leftChild.parent = rotRoot\n        newRoot.parent = rotRoot.parent\n        if rotRoot.isRoot():\n            self.root = newRoot\n        else:\n            if rotRoot.isLeftChild():\n                rotRoot.parent.leftChild = newRoot\n            else:\n                rotRoot.parent.rightChild = newRoot\n        newRoot.leftChild = rotRoot\n        rotRoot.parent = newRoot\n        rotRoot.balanceFactor = rotRoot.balanceFactor + 1 - min(newRoot.balanceFactor, 0)\n        newRoot.balanceFactor = newRoot.balanceFactor + 1 + max(rotRoot.balanceFactor, 0)\n\n\n    def rotateRight(self,rotRoot):\n        newRoot = rotRoot.leftChild\n        rotRoot.leftChild = newRoot.rightChild\n        if newRoot.rightChild != None:\n            newRoot.rightChild.parent = rotRoot\n        newRoot.parent = rotRoot.parent\n        if rotRoot.isRoot():\n            self.root = newRoot\n        else:\n            if rotRoot.isRightChild():\n                rotRoot.parent.rightChild = newRoot\n            else:\n                rotRoot.parent.leftChild = newRoot\n        newRoot.rightChild = rotRoot\n        rotRoot.parent = newRoot\n        rotRoot.balanceFactor = rotRoot.balanceFactor - 1 - max(newRoot.balanceFactor, 0)\n        newRoot.balanceFactor = newRoot.balanceFactor - 1 + min(rotRoot.balanceFactor, 0)\n        \n',
    'src/lib/webgl/math.js': 'var $builtinmodule = function(name)\n{\n    var mod = {};\n\n    // todo; should probably put this in a math package\n    mod.Mat44 = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self)\n                    {\n                        Sk.misceval.callsim($loc.loadIdentity, self);\n                        self.stack = [];\n                    });\n\n                $loc.push = new Sk.builtin.func(function(self)\n                    {\n                        self.stack.push(self.elements.slice(0));\n                    });\n\n                $loc.pop = new Sk.builtin.func(function(self)\n                    {\n                        self.elements = self.stack.pop();\n                    });\n\n                $loc.loadIdentity = new Sk.builtin.func(function(self)\n                    {\n                        self.elements = [1.0, 0.0, 0.0, 0.0,\n                                         0.0, 1.0, 0.0, 0.0,\n                                         0.0, 0.0, 1.0, 0.0,\n                                         0.0, 0.0, 0.0, 1.0];\n                    });\n\n                $loc.transform3 = new Sk.builtin.func(function(self, v)\n                    {\n                        var e = self.elements;\n                        return Sk.misceval.callsim(mod.Vec3,\n                            e[0] * v.x + e[4] * v.y + e[8] * v.z,\n                            e[1] * v.x + e[5] * v.y + e[9] * v.z,\n                            e[2] * v.x + e[6] * v.y + e[10] * v.z);\n                    });\n\n                $loc.scale = new Sk.builtin.func(function(self, sx, sy, sz)\n                        {\n                            self.elements[0*4+0] *= sx;\n                            self.elements[0*4+1] *= sx;\n                            self.elements[0*4+2] *= sx;\n                            self.elements[0*4+3] *= sx;\n\n                            self.elements[1*4+0] *= sy;\n                            self.elements[1*4+1] *= sy;\n                            self.elements[1*4+2] *= sy;\n                            self.elements[1*4+3] *= sy;\n\n                            self.elements[2*4+0] *= sz;\n                            self.elements[2*4+1] *= sz;\n                            self.elements[2*4+2] *= sz;\n                            self.elements[2*4+3] *= sz;\n\n                            return self;\n                        });\n\n                $loc.translate = new Sk.builtin.func(function(self, tx, ty, tz)\n                        {\n                            self.elements[3*4+0] += self.elements[0*4+0] * tx + self.elements[1*4+0] * ty + self.elements[2*4+0] * tz;\n                            self.elements[3*4+1] += self.elements[0*4+1] * tx + self.elements[1*4+1] * ty + self.elements[2*4+1] * tz;\n                            self.elements[3*4+2] += self.elements[0*4+2] * tx + self.elements[1*4+2] * ty + self.elements[2*4+2] * tz;\n                            self.elements[3*4+3] += self.elements[0*4+3] * tx + self.elements[1*4+3] * ty + self.elements[2*4+3] * tz;\n                            return self;\n                        });\n\n                $loc.rotate = new Sk.builtin.func(function(self, angle, x, y, z)\n                        {\n                            var mag = Math.sqrt(x*x + y*y + z*z);\n                            var sinAngle = Sk.math.sin(angle * Math.PI / 180.0);\n                            var cosAngle = Sk.math.cos(angle * Math.PI / 180.0);\n\n                            if (mag > 0)\n                            {\n                                var xx, yy, zz, xy, yz, zx, xs, ys, zs;\n                                var oneMinusCos;\n                                var rotMat;\n\n                                x /= mag;\n                                y /= mag;\n                                z /= mag;\n\n                                xx = x * x;\n                                yy = y * y;\n                                zz = z * z;\n                                xy = x * y;\n                                yz = y * z;\n                                zx = z * x;\n                                xs = x * sinAngle;\n                                ys = y * sinAngle;\n                                zs = z * sinAngle;\n                                oneMinusCos = 1.0 - cosAngle;\n\n                                rotMat = Sk.misceval.callsim(mod.Mat44);\n\n                                rotMat.elements[0*4+0] = (oneMinusCos * xx) + cosAngle;\n                                rotMat.elements[0*4+1] = (oneMinusCos * xy) - zs;\n                                rotMat.elements[0*4+2] = (oneMinusCos * zx) + ys;\n                                rotMat.elements[0*4+3] = 0.0;\n\n                                rotMat.elements[1*4+0] = (oneMinusCos * xy) + zs;\n                                rotMat.elements[1*4+1] = (oneMinusCos * yy) + cosAngle;\n                                rotMat.elements[1*4+2] = (oneMinusCos * yz) - xs;\n                                rotMat.elements[1*4+3] = 0.0;\n\n                                rotMat.elements[2*4+0] = (oneMinusCos * zx) - ys;\n                                rotMat.elements[2*4+1] = (oneMinusCos * yz) + xs;\n                                rotMat.elements[2*4+2] = (oneMinusCos * zz) + cosAngle;\n                                rotMat.elements[2*4+3] = 0.0;\n\n                                rotMat.elements[3*4+0] = 0.0;\n                                rotMat.elements[3*4+1] = 0.0;\n                                rotMat.elements[3*4+2] = 0.0;\n                                rotMat.elements[3*4+3] = 1.0;\n\n                                rotMat = rotMat.multiply(self);\n                                self.elements = rotMat.elements;\n                            }\n                            return self;\n                        });\n\n                $loc.multiply = new Sk.builtin.func(function(self, right)\n                        {\n                            var tmp = Sk.misceval.callsim(mod.Mat44);\n\n                            for (var i = 0; i < 4; i++)\n                            {\n                                tmp.elements[i*4+0] =\n                                (self.elements[i*4+0] * right.elements[0*4+0]) +\n                                (self.elements[i*4+1] * right.elements[1*4+0]) +\n                                (self.elements[i*4+2] * right.elements[2*4+0]) +\n                                (self.elements[i*4+3] * right.elements[3*4+0]) ;\n\n                                tmp.elements[i*4+1] =\n                                (self.elements[i*4+0] * right.elements[0*4+1]) +\n                                (self.elements[i*4+1] * right.elements[1*4+1]) +\n                                (self.elements[i*4+2] * right.elements[2*4+1]) +\n                                (self.elements[i*4+3] * right.elements[3*4+1]) ;\n\n                                tmp.elements[i*4+2] =\n                                (self.elements[i*4+0] * right.elements[0*4+2]) +\n                                (self.elements[i*4+1] * right.elements[1*4+2]) +\n                                (self.elements[i*4+2] * right.elements[2*4+2]) +\n                                (self.elements[i*4+3] * right.elements[3*4+2]) ;\n\n                                tmp.elements[i*4+3] =\n                                (self.elements[i*4+0] * right.elements[0*4+3]) +\n                                (self.elements[i*4+1] * right.elements[1*4+3]) +\n                                (self.elements[i*4+2] * right.elements[2*4+3]) +\n                                (self.elements[i*4+3] * right.elements[3*4+3]) ;\n                            }\n\n                            self.elements = tmp.elements;\n                            return self;\n                        });\n\n                /* Following gluLookAt implementation is adapted from\n                 * the Mesa 3D Graphics library. http://www.mesa3d.org\n                 */\n                // todo; rewrite this with proper vec/mat ops\n                $loc.lookAt = new Sk.builtin.func(function(self, eyeX, eyeY, eyeZ,\n                                                                 centerX, centerY, centerZ,\n                                                                 upX, upY, upZ)\n                        {\n                            /* Z vector */\n                            var z = [\n                                eyeX - centerX,\n                                eyeY - centerY,\n                                eyeZ - centerZ\n                            ];\n                            var mag = Math.sqrt(z[0] * z[0] + z[1] * z[1] + z[2] * z[2]);\n                            if (mag)\n                            {\n                                z[0] /= mag;\n                                z[1] /= mag;\n                                z[2] /= mag;\n                            }\n\n                            /* Y vector */\n                            var y = [ upX, upY, upZ ];\n\n                            /* X vector = Y cross Z */\n                            var x = [];\n                            x[0] = y[1] * z[2] - y[2] * z[1];\n                            x[1] = -y[0] * z[2] + y[2] * z[0];\n                            x[2] = y[0] * z[1] - y[1] * z[0];\n\n                            /* Recompute Y = Z cross X */\n                            y[0] = z[1] * x[2] - z[2] * x[1];\n                            y[1] = -z[0] * x[2] + z[2] * x[0];\n                            y[2] = z[0] * x[1] - z[1] * x[0];\n\n                            /* mpichler, 19950515 */\n                            /* cross product gives area of parallelogram, which is < 1.0 for\n                            * non-perpendicular unit-length vectors; so normalize x, y here\n                            */\n\n                            mag = Math.sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);\n                            if (mag) {\n                                x[0] /= mag;\n                                x[1] /= mag;\n                                x[2] /= mag;\n                            }\n\n                            mag = Math.sqrt(y[0] * y[0] + y[1] * y[1] + y[2] * y[2]);\n                            if (mag) {\n                                y[0] /= mag;\n                                y[1] /= mag;\n                                y[2] /= mag;\n                            }\n\n                            var lookAt = Sk.misceval.callsim(mod.Mat44);\n                            lookAt.elements[0 * 4 + 0] = x[0];\n                            lookAt.elements[1 * 4 + 0] = x[1];\n                            lookAt.elements[2 * 4 + 0] = x[2];\n                            lookAt.elements[3 * 4 + 0] = 0.;\n                            lookAt.elements[0 * 4 + 1] = y[0];\n                            lookAt.elements[1 * 4 + 1] = y[1];\n                            lookAt.elements[2 * 4 + 1] = y[2];\n                            lookAt.elements[3 * 4 + 1] = 0.;\n                            lookAt.elements[0 * 4 + 2] = z[0];\n                            lookAt.elements[1 * 4 + 2] = z[1];\n                            lookAt.elements[2 * 4 + 2] = z[2];\n                            lookAt.elements[3 * 4 + 2] = 0.;\n                            lookAt.elements[0 * 4 + 3] = 0.;\n                            lookAt.elements[1 * 4 + 3] = 0.;\n                            lookAt.elements[2 * 4 + 3] = 0.;\n                            lookAt.elements[3 * 4 + 3] = 1.;\n\n                            // log(lookAt.elements);\n\n                            lookAt = lookAt.multiply(self);\n                            self.elements = lookAt.elements;\n                            self.translate(-eyeX, -eyeY, -eyeZ);\n\n                            // log(this.elements);\n\n                            return self;\n                        });\n            },\n            \'Mat44\', []);\n\n    // todo; should probably put this in a math package\n    mod.Mat33 = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self)\n                    {\n                        Sk.misceval.callsim($loc.loadIdentity, self);\n                    });\n\n                $loc.loadIdentity = new Sk.builtin.func(function(self)\n                    {\n                        self.elements = [1.0, 0.0, 0.0,\n                                         0.0, 1.0, 0.0,\n                                         0.0, 0.0, 1.0];\n                    });\n            },\n            \'Mat33\', []);\n\n    mod.Vec3 = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self, x, y, z)\n                    {\n                        self.x = x;\n                        self.y = y;\n                        self.z = z;\n                    });\n                $loc.__sub__ = new Sk.builtin.func(function(self, other)\n                    {\n                        return Sk.misceval.callsim(mod.Vec3, self.x - other.x, self.y - other.y, self.z - other.z);\n                    });\n            },\n            \'Vec3\', []);\n    \n    mod.cross = new Sk.builtin.func(function(v1, v2)\n            {\n                goog.asserts.assert(v1 instanceof mod.Vec3 && v2 instanceof mod.Vec3);\n                return Sk.misceval.callsim(mod.Vec3,\n                    v1.y * v2.z - v1.z * v2.y,\n                    v1.z * v2.x - v1.x * v2.z,\n                    v1.x * v2.y - v1.y * v2.x);\n            });\n\n    return mod;\n};\n',
    'src/lib/urllib/request/__init__.js': 'var $builtinmodule = function(name)\n{\n  var request = {};\n\n\n  //~ Classes .................................................................\n\n  // Response class\n  //\n  // Response objects are returned by the request, get, post, etc.\n  // methods, allowing the user to access the response text, status\n  // code, and other information.\n\n  // ------------------------------------------------------------\n  var response = function($gbl, $loc) {\n\n    // ------------------------------------------------------------\n    $loc.__init__ = new Sk.builtin.func(function(self, xhr) {\n      self.data$ = xhr.responseText;\n      self.lineList = self.data$.split("\\n");\n      self.lineList = self.lineList.slice(0,-1);\n      for(var i =0 ; i < self.lineList.length; i++) {\n        self.lineList[i] = self.lineList[i]+\'\\n\';\n      }\n      self.currentLine = 0;\n      self.pos$ = 0;\n    });\n\n\n    // ------------------------------------------------------------\n    $loc.__str__ = new Sk.builtin.func(function(self) {\n      return Sk.ffi.stringToPy(\'<Response>\');\n    });\n\n\n    // ------------------------------------------------------------\n    $loc.__iter__ = new Sk.builtin.func(function(self) {\n      var allLines = self.lineList;\n\n      return Sk.builtin.makeGenerator(function() {\n          if (this.$index >= this.$lines.length) return undefined;\n          return new Sk.builtin.str(this.$lines[this.$index++]);\n        }, {\n          $obj: self,\n          $index: 0,\n          $lines: allLines\n        });\n    });\n\n\n    // ------------------------------------------------------------\n    $loc.read = new Sk.builtin.func(function(self, size) {\n      if (self.closed) throw new Sk.builtin.ValueError("I/O operation on closed file");\n      var len = self.data$.length;\n      if (size === undefined) size = len;\n      var ret = new Sk.builtin.str(self.data$.substr(self.pos$, size));\n      self.pos$ += size;\n      if (self.pos$ >= len) self.pos$ = len;\n      return ret;\n    });\n\n\n    // ------------------------------------------------------------\n    $loc.readline = new Sk.builtin.func(function(self, size) {\n      var line = "";\n      if (self.currentLine < self.lineList.length) {\n        line = self.lineList[self.currentLine];\n        self.currentLine++;\n      }\n      return new Sk.builtin.str(line);\n    });\n\n\n    // ------------------------------------------------------------\n    $loc.readlines = new Sk.builtin.func(function(self, sizehint) {\n      var arr = [];\n      for(var i = self.currentLine; i < self.lineList.length; i++) {\n        arr.push(new Sk.builtin.str(self.lineList[i]));\n      }\n      return new Sk.builtin.list(arr);\n    });\n\n  };\n\n  request.Response =\n    Sk.misceval.buildClass(request, response, \'Response\', []);\n\n\n  //~ Module functions ........................................................\n\n  // ------------------------------------------------------------\n  /**\n   * Constructs and sends a Request. Returns Response object.\n   *\n   * http://docs.python-requests.org/en/latest/api/#requests.request\n   *\n   * For now, this implementation doesn\'t actually construct a Request\n   * object; it just makes the request through jQuery.ajax and then\n   * constructs a Response.\n   */\n  request.urlopen = new Sk.builtin.func(function(url, data, timeout) {\n    var xmlhttp = new XMLHttpRequest();\n    xmlhttp.open("GET",url.v,false);\n    xmlhttp.send(null);\n\n    return Sk.misceval.callsim(request.Response,xmlhttp)\n  });\n\n\n  return request;\n};\n',
    'src/lib/pythonds/basic/queue.py': '# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n#queue.py\r\n\r\nclass Queue:\r\n    def __init__(self):\r\n        self.items = []\r\n\r\n    def isEmpty(self):\r\n        return self.items == []\r\n\r\n    def enqueue(self, item):\r\n        self.items.insert(0,item)\r\n\r\n    def dequeue(self):\r\n        return self.items.pop()\r\n\r\n    def size(self):\r\n        return len(self.items)\r\n',
    'src/lib/three/__init__.js': 'var $builtinmodule = function(namePy) {\n  var mod = {};\n  Sk.stdlib.defineThree(mod, BLADE);\n  Sk.builtin.defineGeometry(mod, THREE, Sk.ffi.remapToJs(namePy));\n  return mod;\n}\n',
    'src/lib/numpy/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineNumPy(mod);\n  return mod;\n};\n',
    'src/lib/pythonds/graphs/adjGraph.py': '#\n#  adjGraph\n#\n#  Created by Brad Miller on 2005-02-24.\n#  Copyright (c) 2005 Brad Miller, David Ranum, Luther College. All rights reserved.\n#\n\nimport sys\nimport os\nimport unittest\n\nclass Graph:\n    def __init__(self):\n        self.vertices = {}\n        self.numVertices = 0\n        \n    def addVertex(self,key):\n        self.numVertices = self.numVertices + 1\n        newVertex = Vertex(key)\n        self.vertices[key] = newVertex\n        return newVertex\n    \n    def getVertex(self,n):\n        if n in self.vertices:\n            return self.vertices[n]\n        else:\n            return None\n\n    def __contains__(self,n):\n        return n in self.vertices\n    \n    def addEdge(self,f,t,cost=0):\n            if f not in self.vertices:\n                nv = self.addVertex(f)\n            if t not in self.vertices:\n                nv = self.addVertex(t)\n            self.vertices[f].addNeighbor(self.vertices[t],cost)\n    \n    def getVertices(self):\n        return list(self.vertices.keys())\n        \n    def __iter__(self):\n        return iter(self.vertices.values())\n                \nclass Vertex:\n    def __init__(self,num):\n        self.id = num\n        self.connectedTo = {}\n        self.color = \'white\'\n        self.dist = sys.maxsize\n        self.pred = None\n        self.disc = 0\n        self.fin = 0\n\n    # def __lt__(self,o):\n    #     return self.id < o.id\n    \n    def addNeighbor(self,nbr,weight=0):\n        self.connectedTo[nbr] = weight\n        \n    def setColor(self,color):\n        self.color = color\n        \n    def setDistance(self,d):\n        self.dist = d\n\n    def setPred(self,p):\n        self.pred = p\n\n    def setDiscovery(self,dtime):\n        self.disc = dtime\n        \n    def setFinish(self,ftime):\n        self.fin = ftime\n        \n    def getFinish(self):\n        return self.fin\n        \n    def getDiscovery(self):\n        return self.disc\n        \n    def getPred(self):\n        return self.pred\n        \n    def getDistance(self):\n        return self.dist\n        \n    def getColor(self):\n        return self.color\n    \n    def getConnections(self):\n        return self.connectedTo.keys()\n        \n    def getWeight(self,nbr):\n        return self.connectedTo[nbr]\n                \n    def __str__(self):\n        return str(self.id) + ":color " + self.color + ":disc " + str(self.disc) + ":fin " + str(self.fin) + ":dist " + str(self.dist) + ":pred \\n\\t[" + str(self.pred)+ "]\\n"\n    \n    def getId(self):\n        return self.id\n\nclass adjGraphTests(unittest.TestCase):\n    def setUp(self):\n        self.tGraph = Graph()\n        \n    def testMakeGraph(self):\n        gFile = open("test.dat")\n        for line in gFile:\n            fVertex, tVertex = line.split(\'|\')\n            fVertex = int(fVertex)\n            tVertex = int(tVertex)\n            self.tGraph.addEdge(fVertex,tVertex)\n        for i in self.tGraph:\n            adj = i.getAdj()\n            for k in adj:\n                print(i, k)\n\n        \nif __name__ == \'__main__\':\n    unittest.main()\n              \n',
    'src/lib/easel/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineEasel(mod, createjs, BLADE);\n  return mod;\n}\n',
    'src/lib/json/__init__.js': 'var $builtinmodule = function(name)\n{\n    var mod = {};\n\n    var FUNCTION_PARSE     = "parse";\n    var FUNCTION_STRINGIFY = "stringify";\n\n    mod[FUNCTION_PARSE] = Sk.ffi.functionPy(function(textPy, reviverPy) {\n        Sk.ffi.checkFunctionArgs(FUNCTION_PARSE, arguments, 1, 1);\n        Sk.ffi.checkArgType("text",    Sk.ffi.PyType.STR,   Sk.ffi.isStr(textPy));\n        Sk.ffi.checkArgType("reviver", Sk.ffi.PyType.FUNCTION, Sk.ffi.isUndefined(reviverPy) || isFunction(reviverPy));\n        var text = Sk.ffi.remapToJs(textPy);\n        var reviver = Sk.ffi.remapToJs(reviverPy);\n        return Sk.ffi.remapToPy(JSON.parse(text, reviver));\n    });\n\n    mod[FUNCTION_STRINGIFY] = Sk.ffi.functionPy(function(valuePy, replacerPy, spacePy) {\n        Sk.ffi.checkFunctionArgs(FUNCTION_STRINGIFY, arguments, 1, 3);\n        Sk.ffi.checkArgType("value", [Sk.ffi.PyType.OBJECT, Sk.ffi.PyType.DICT], Sk.ffi.isDict(valuePy));\n        Sk.ffi.checkArgType("replacer", [Sk.ffi.PyType.FUNCTION, Sk.ffi.PyType.NONE, Sk.ffi.PyType.UNDEFINED], Sk.ffi.isUndefined(replacerPy) || Sk.ffi.isNone(replacerPy) || Sk.ffi.isFunction(replacerPy));\n        Sk.ffi.checkArgType("space", [Sk.ffi.PyType.INT, Sk.ffi.PyType.UNDEFINED], Sk.ffi.isUndefined(spacePy) || Sk.ffi.isInt(spacePy));\n        var value = Sk.ffi.remapToJs(valuePy);\n        var replacer = Sk.ffi.remapToJs(replacerPy);\n        var space = Sk.ffi.remapToJs(spacePy);\n        return Sk.ffi.stringToPy(JSON.stringify(value, replacer, space));\n    });\n\n    return mod;\n}',
    'src/lib/turtle/__init__.js': '//\n//\n// Turtle Graphics Module for Skulpt\n//\n// Brad Miller\n//\n//\n//\n\n\nvar TurtleGraphics; // the single identifier needed in the global scope\n\nif (! TurtleGraphics) {\n    TurtleGraphics = { };\n}\n\n\n(function () {\n\n    // Define private constants\n\n    var Degree2Rad = Math.PI / 180.0; // conversion factor for degrees to radians\n    var Rad2Degree = 180.0 / Math.PI\n\n    //\n    // Define TurtleCanvas\n    // \n\n    function TurtleCanvas(options) {\n        this.canvasID = TurtleGraphics.defaults.canvasID;\n        if (options.canvasID) {\n            this.canvasID = options.canvasID;\n        }\n\n        this.canvas = document.getElementById(this.canvasID);\n        this.context = this.canvas.getContext(\'2d\');\n        //this.canvas.style.display = \'block\';\n        $(this.canvas).fadeIn();\n\n        this.lineScale = 1.0;\n        this.xptscale = 1.0;\n        this.yptscale = 1.0\n\n        this.llx = -this.canvas.width / 2;\n        this.lly = -this.canvas.height / 2;\n        this.urx = this.canvas.width / 2;\n        this.ury = this.canvas.height / 2;\n        this.setup(this.canvas.width,this.canvas.height);\n        TurtleGraphics.canvasInit = true;\n        this.tlist = []\n\n\t\tthis.timeFactor = 5;\n        if (TurtleGraphics.defaults.animate) {\n            this.delay = 5 * this.timeFactor;\n        } else {\n            this.delay = 0;\n        }\n        this.segmentLength = 10;\n        this.renderCounter = 1;\n        this.clearPoint = 0;\n        TurtleGraphics.canvasLib[this.canvasID] = this;\n\t\tSk.tg.fadeOnExit = true;\t//\tThis can be set to false AFTER the program completes to turn off the fade out on the canvas as a result of exitonclick\n    }\n\n    TurtleCanvas.prototype.setup = function(width, height) {\n        this.canvas.width = width;\n        this.canvas.height = height;\n        this.lineScale = 1.0;\n        this.xptscale = 1.0;\n        this.yptscale = 1.0;\n\n        this.llx = -this.canvas.width / 2;\n        this.lly = -this.canvas.height / 2;\n        this.urx = this.canvas.width / 2;\n        this.ury = this.canvas.height / 2;\n        this.renderCounter = 1;\n        this.clearPoint = 0;\n\t\tthis.timeFactor = 5;\n        if (TurtleGraphics.defaults.animate ) {\n            this.delay = 5 * this.timeFactor;\n        } else {\n            this.delay = 0;\n        }\n\n        if (TurtleGraphics.canvasInit == false) {\n            this.context.save();\n            this.context.translate(this.canvas.width / 2, this.canvas.height / 2); // move 0,0 to center.\n            this.context.scale(1, -1); // scaling like this flips the y axis the right way.\n            TurtleGraphics.canvasInit = true;\n            TurtleGraphics.eventCount = 0;\n            TurtleGraphics.renderClock = 0;\n            TurtleGraphics.renderTime = 0;\t// RNL\n        } else {\n            this.context.restore();\n            this.context.translate(this.canvas.width / 2, this.canvas.height / 2); // move 0,0 to center.\n            this.context.scale(1, -1); // scaling like this flips the y axis the right way.\n            this.context.clearRect(-this.canvas.width / 2, -this.canvas.height / 2,\n                                    this.canvas.width, this.canvas.height);\n        }\n    }\n    TurtleCanvas.prototype.addToCanvas = function(t) {\n\t        this.tlist.push(t);\n    }\n\n    TurtleCanvas.prototype.onCanvas = function(t) {\n        return (this.tlist.indexOf(t) >= 0);\n    }\n\n    TurtleCanvas.prototype.isAnimating = function() {\n        return (this.tlist.length > 0)\n    }\n\n    TurtleCanvas.prototype.startAnimating = function(t) {\n\t\tif (! this.isAnimating()) {\n        \tthis.intervalId = setTimeout(render, this.delay);\t//\tsetInterval(render, this.delay);\n\t\t}\n    \tif (!this.onCanvas(t))\t//\tAdded by RNL in case startAnimating is called after it\'s already been added\n       \t\tthis.addToCanvas(t);\n        Sk.isTurtleProgram = true;\n    }\n\n    TurtleCanvas.prototype.doneAnimating = function(t) {\n        this.tlist.splice(0,this.tlist.length)\n        clearTimeout(this.intervalId)   \n        $(Sk.runButton).removeAttr(\'disabled\');\n    }\n\n    TurtleCanvas.prototype.cancelAnimation = function() {\n        if (this.intervalId) {\n            clearTimeout(this.intervalId)\t//\tclearInterval(this.intervalId);\n        }\n\n        for (var t in this.tlist) {\n            this.tlist[t].aCount = this.tlist[t].drawingEvents.length - 1;\n        }\n        render();\n    }\n\n    TurtleCanvas.prototype.setSpeedDelay = function(s) {\t// RNL\n        var df = 10 - (s % 11) + 1;\n        this.delay = df * this.timeFactor;\t//\tRNL was 10;\n    }\n\n    TurtleCanvas.prototype.setDelay = function(d) {\n        this.delay = d;\n    }\n\n    TurtleCanvas.prototype.getDelay = function(s) { // RNL\n        return this.delay;\n    }\n\n    TurtleCanvas.prototype.setCounter = function(s) {\n\t\tif (!s || s <= 0)\t//\tDon\'t let this be less than 1\n\t\t\ts = 1;\n        this.renderCounter = s;\n    }\n\n    TurtleCanvas.prototype.getCounter = function() {\n        return this.renderCounter;\n    }\n\n    TurtleCanvas.prototype.setworldcoordinates = function(llx, lly, urx, ury) {\n        this.context.restore();\n        this.context.scale(this.canvas.width / (urx - llx), -this.canvas.height / (ury - lly));\n        if (lly == 0)\n            this.context.translate(-llx, lly - (ury - lly));\n        else if (lly > 0)\n            this.context.translate(-llx, -lly * 2);\n        else\n            this.context.translate(-llx, -ury);\n\n        var xlinescale = (urx - llx) / this.canvas.width;\n        var ylinescale = (ury - lly) / this.canvas.height;\n        this.xptscale = xlinescale;\n        this.yptscale = ylinescale;\n        this.lineScale = Math.min(xlinescale,ylinescale)\n        this.context.save();\n\n        this.llx = llx;\n        this.lly = lly;\n        this.urx = urx;\n        this.ury = ury;\n\n    }\n\n    TurtleCanvas.prototype.window_width = function() {\n        return this.canvas.width;\n    }\n\n    TurtleCanvas.prototype.window_height = function() {\n        return this.canvas.height;\n    }\n\n    TurtleCanvas.prototype.bgcolor = function(c) {\n        this.background_color = c;\n        //this.canvas.style.setProperty("background-color", c.v);\n        $(this.canvas).css("background-color",c.v);\n    }\n\n    TurtleCanvas.prototype.setSegmentLength = function(s) {\n        this.segmentLength = s;\n    }\n\n    TurtleCanvas.prototype.getSegmentLength = function() {\n        return this.segmentLength;\n    }\n    \n    // todo: if animating, this should be deferred until the proper time\n    TurtleCanvas.prototype.exitonclick = function () {\n        var canvas_id = this.canvasID;\n        var theCanvas = this;\n        $(this.canvas).click(function() {\n            if (! theCanvas.isAnimating()) {\n\t\t\t\tif (Sk.tg.fadeOnExit)\t//\tLet\'s this be configurable\n                \t$("#"+canvas_id).hide();\n                $("#"+canvas_id).unbind(\'click\');\n                Sk.tg.canvasInit = false;\n                delete Sk.tg.canvasLib[canvas_id];\n            }\n        });\n    }\n\n    TurtleCanvas.prototype.turtles = function() {\n        return TurtleGraphics.turtleList;\n    }\n\n\tTurtleCanvas.prototype.tracer = function(t, d) {\t//\tNew version NOT attached to a turtle (as per real turtle)\n        this.setCounter(t);\n\t\tif (t == 0) {\n\t\t\tfor (var i in this.turtleList)\n\t\t\t\tthis.turtleList[i].animate = false;\n\t\t\tthis.cancelAnimation();\n\t\t}\n\t\tif (d !== undefined)\n\t\t\tthis.setDelay(d);\n\t}\n\n    // check if all turtles are done\n    allDone = function() {\n        var allDone = true;\n        for (var tix in TurtleGraphics.turtleList) {\n            var theT = TurtleGraphics.turtleList[tix];\n            allDone = allDone && (theT.aCount >= theT.drawingEvents.length);\n        }\n        return allDone;\n    }\n    //\n    //  This is the function that provides the animation\n    //\n    render = function () {\n        var context = document.getElementById(TurtleGraphics.defaults.canvasID).getContext(\'2d\');\n        with (context) {\n            with (TurtleGraphics.canvasLib[TurtleGraphics.defaults.canvasID]) {\n                clearRect(llx, lly, (urx - llx), (ury - lly));\n                //canvas.style.setProperty("background-color",TurtleGraphics.turtleCanvas.bgcolor.v);\n            }\n            var incr = TurtleGraphics.canvasLib[TurtleGraphics.defaults.canvasID].getCounter();\n            var lastCanvas = null\n\n            TurtleGraphics.renderClock += incr;\n\n            for (var tix in TurtleGraphics.turtleList) {\n                var t = TurtleGraphics.turtleList[tix]\n                lastCanvas = t.turtleCanvas \n                if (t.aCount >= t.drawingEvents.length)\n                    t.aCount = t.drawingEvents.length - 1;\n                moveTo(0, 0);\n                var currentPos = new Vector(0,0,0);\n                var currentHead = new Vector(1,0,0);\n                lineWidth = t.get_pen_width();\n                lineCap = \'round\';\n                lineJoin = \'round\';\n                strokeStyle = \'black\';\n                var filling = false;\n                if (isNaN(t.turtleCanvas.delay))\n                \tt.turtleCanvas.delay = 0\n//\t\t\t\tconsole.log(tix + " : " + t.clearPoint + " to " + t.aCount)\n                for (var i = t.clearPoint; (i <= t.aCount || t.turtleCanvas.delay == 0) && i < t.drawingEvents.length; i++) {\n                \tif (i > t.aCount)\t//\tIf se jump past aCount, jump it ahead\n                \t\tt.aCount = i\n                    var oper = t.drawingEvents[i];\n                    var ts = oper[oper.length-1];\n//\t\t\t\t\tconsole.log(i + "/" + ts + oper [0] + "{" + oper [1] + "}" + t.turtleCanvas.delay)\n                    if (ts <= TurtleGraphics.renderClock || t.turtleCanvas.delay == 0) {\n                    \tif (ts > TurtleGraphics.renderClock)\t//\tIf we go past the render clock, jump it ahead\n                    \t\tTurtleGraphics.renderClock = ts\n//\t\t\t\t\t\tconsole.log("<==")\n                        if (oper[0] == "LT") {  //  line to\n                            if (! filling) {\n                                beginPath();\n                                moveTo(oper[1], oper[2]);\n                            }\n                            lineTo(oper[3], oper[4]);\n                            strokeStyle = oper[5];\n                            stroke();\n                            currentPos = new Vector(oper[3],oper[4],0);\n                            if (! filling)\n                                closePath();\n                        }\n                        else if (oper[0] == "MT") {  // move to\n                            moveTo(oper[3], oper[4]);\n                            currentPos = new Vector(oper[3],oper[4],0);\n                        }\n                        else if (oper[0] == "BF") {  // begin fill\n                            beginPath();\n                            moveTo(oper[1], oper[2]);\n                            filling = true;\n                        }\n                        else if (oper[0] == "EF") {  // end fill\n                            fillStyle = oper[3];\n                            stroke();\n                            fill();\n                            closePath();\n                            filling = false;\n                        }\n                        else if (oper[0] == "FC") {  // fill color\n                            fillStyle = oper[1];\n                        }\n                        else if (oper[0] == "TC") {  // turtle color\n                            strokeStyle = oper[1];\n                        }\n                        else if (oper[0] == "PW") {  // Pen width\n                            lineWidth = oper[1];\n                        }\n                        else if (oper[0] == "DT") {  // Dot\n                            var col = fillStyle;\n                            fillStyle = oper[2];\n                            var size = oper[1];\n                            fillRect(oper[3] - size / 2, oper[4] - size / 2, size, size);\n                            fillStyle = col;\n                        }\n                        else if (oper[0] == "CI") {  // Circle\n                            if (!filling)\n\t\t\t\t\t\t\t\tbeginPath();\n                            arc(oper[1], oper[2], oper[3], oper[4], oper[5], oper[6]);\n                            currentPos = new Vector(oper[1]+Sk.math.cos(oper[5])*oper[3],\n                                oper[2]+Sk.math.sin(oper[5])*oper[3],0);\n                            stroke();\n                            if (! filling) {\n                                closePath();\n                            }\n                        }\n                        else if (oper[0] == "WT") { // write\n                            if (font)\n                                font = oper[2];\n                            scale(1, -1);\n                            fillText(oper[1], oper[3], -oper[4]);\n                            scale(1, -1);\n                        } else if (oper[0] == "ST") {  // stamp\n                            t.drawturtle(oper[3], new Vector(oper[1], oper[2], 0));\n                        } else if (oper[0] == "HT") { // hide turtle\n                            t.visible = false;\n                        } else if (oper[0] == "SH") { // show turtle\n                            t.visible = true;\n                        } else if (oper[0] == "TT") {\n                            currentHead = oper[1];\n                        } else if (oper[0] == "CL") { // RNL clear\n                        \tclear_canvas(t.canvasID);\n                        \tt.clearPoint = i;\t// Different from reset that calls clear because it leaves the turtles where they are\n                        } else if (oper[0] == "DL") { // RNL delay\n                        \tvar df = oper[1]\n//                      \tconsole.log("animated delay set " + df)\n                        \tt.turtleCanvas.delay = df\n                        } else if (oper[0] == "SC") { // RNL speed change\n                        \tvar s = oper[1]\n                        \tif (s < 0)\n                        \t\ts = 0\n                        \tif (s > 10)\n                        \t\ts = 10\n       \t\t\t\t\t\tvar df = (10 - (s % 11) + 1) * t.turtleCanvas.timeFactor\t//\t10\n       \t\t\t\t\t\tif (s == 0) {\n       \t\t\t\t\t\t\tdf = 0\n       \t\t\t\t\t\t}\n\t                        //\tt.turtleCanvas.intervalId = clearInterval(t.turtleCanvas.intervalId);\n\t       \t\t\t\t\tt.turtleCanvas.delay = df;\n\t       \t\t\t\t\t//\tt.turtleCanvas.intervalId = setInterval(render, t.turtleCanvas.delay)\n       \t\t\t\t\t\tif (oper[2]) {\n       \t\t\t\t\t\t\tt.turtleCanvas.setSegmentLength(oper[2]);\n       \t\t\t\t\t\t}\n       \t\t\t\t\t} else if (oper[0] == "NO") { // RNL no op                \t\n                        } else {\n\t\t\t\t\t\t\tconsole.log("unknown op: " + oper[0]);\n                        } // end of oper[0] test\n                    } // end of if ts < render clock\n                } // end of for\n//\t\t\t\tconsole.log(TurtleGraphics.renderClock + " / " + t.aCount)\n//\t\t\t\tconsole.log("------------------------------")\n                t.aCount += incr;\n                if (t.visible) {\n                    // draw the turtle\n                    t.drawturtle(currentHead.toAngle(), currentPos); // just use currentHead\n                }\n            }\n            //if (t.aCount >= t.drawingEvents.length) {\n            if (TurtleGraphics.renderClock > TurtleGraphics.eventCount ){ // && allDone() ){\n//              t.turtleCanvas.doneAnimating(t);\n//\t\t\t\tconsole.log("done animating")\n                if (lastCanvas) lastCanvas.doneAnimating(t);\n            } else {\n//    \t\t\tt.turtleCanvas.intervalId = setTimeout(render, t.turtleCanvas.delay)\n    \t\t\tif (lastCanvas) {\n    \t\t\t\tlastCanvas.intervalId = setTimeout(render, lastCanvas.delay)\n    \t\t\t}\n            }\n        }\n    }\n\n\n\n    // Constructor for Turtle objects\n    function Turtle() {\n        if (arguments.length >= 1) {\n            this.initialize(arguments[0]);\n        }\n        else {\n            this.initialize();\n        }\n        TurtleGraphics.turtleList.push(this);\n    }\n\n\n    Turtle.prototype.go_home = function () {\n        // Put turtle in initial state\n        // turtle is headed to the right\n        // with location 0,0,0 in the middle of the canvas.\n        // x grows to the right\n        // y grows towards the top of the canvas\n        with (this) {\n            position = home;\n            context.moveTo(home[0], home[1]);\n            heading = new Vector([1.0, 0.0, 0.0]); // to the right; in turtle space x+ direction\n            normal = new Vector([0.0, 0.0, -1.0]); // in z- direction\n        }\n    };\n\n    Turtle.prototype.initialize = function () {\n        // Initialize the turtle.\n        var options = { };\n\n        if (arguments.length >= 1) {\n            options = arguments[0];\n        }\n\n        this.canvasID = TurtleGraphics.defaults.canvasID;\n        if (options.canvasID) {\n            this.canvasID = options.canvasID;\n        }\n        this.context = document.getElementById(this.canvasID).getContext(\'2d\');\n\n        this.animate = TurtleGraphics.defaults.animate;\n\n        with (this.context) {\n            if (TurtleGraphics.canvasInit == false) {   // This is a workaround until I understand skulpt re-running better\n                // the downside is that this limits us to a single turtle...\n                save();\n                translate(canvas.width / 2, canvas.height / 2); // move 0,0 to center.\n                scale(1, -1); // scaling like this flips the y axis the right way.\n                if (! TurtleGraphics.canvasLib[this.canvasID]) {\n                    TurtleGraphics.canvasLib[this.canvasID] = new TurtleCanvas(options);\n                }\n                TurtleGraphics.canvasInit = true;\n            } else {\n                clear_canvas(this.canvasID);\n            }\n\n            this.turtleCanvas = TurtleGraphics.canvasLib[this.canvasID];\n            this.home = new Vector([0.0, 0.0, 0.0]);\n            this.visible = true;\n            this.shapeStore = {};\n            this.shapeStore[\'turtle\'] = turtleShapePoints();\n            this.shapeStore[\'arrow\'] = defaultShapePoints();\n            this.shapeStore[\'circle\'] = circleShapePoints();\n            this.shapeStore[\'square\'] = squareShapePoints();\n            this.shapeStore[\'triangle\'] = triangleShapePoints();\n            this.shapeStore[\'blank\'] = [new Vector(0,0)];\n            this.shapeStore[\'classic\'] = classicShapePoints();\n            this.currentShape = \'classic\';\n            this.drawingEvents = [];\n\n            this.filling = false;\n            this.pen = true;\n            this.penStyle = \'black\';\n            this.penWidth = 2;\n            this.fillStyle = \'black\';\n            this.position = [ ];\n            this.heading = [ ];\n            this.normal = [ ];\n            this.go_home();\n            this.aCount = 0;\n            this.clearPoint = 0;\t// RNL for clear/clearScreen\n        }\n    }\n    function turtleShapePoints() {\n        var pl = [\n            [0,16],\n            [-2,14],\n            [-1,10],\n            [-4,7],\n            [-7,9],\n            [-9,8],\n            [-6,5],\n            [-7,1],\n            [-5,-3],\n            [-8,-6],\n            [-6,-8],\n            [-4,-5],\n            [0,-7],\n            [4,-5],\n            [6,-8],\n            [8,-6],\n            [5,-3],\n            [7,1],\n            [6,5],\n            [9,8],\n            [7,9],\n            [4,7],\n            [1,10],\n            [2,14]\n        ];\n        res = [];\n        for (p in pl) {\n            res.push(new Vector(pl[p]));\n        }\n        return res;\n    }\n\n    function defaultShapePoints() {\n        var pl = [\n            [-10,0],\n            [10,0],\n            [0,10]\n        ];\n        res = [];\n        for (p in pl) {\n            res.push(new Vector(pl[p]));\n        }\n        return res;\n    }\n\n    function circleShapePoints() {\n        var pl = [\n            [10,0],\n            [9.51,3.09],\n            [8.09,5.88],\n            [5.88,8.09],\n            [3.09,9.51],\n            [0,10],\n            [-3.09,9.51],\n            [-5.88,8.09],\n            [-8.09,5.88],\n            [-9.51,3.09],\n            [-10,0],\n            [-9.51,-3.09],\n            [-8.09,-5.88],\n            [-5.88,-8.09],\n            [-3.09,-9.51],\n            [-0.00,-10.00],\n            [3.09,-9.51],\n            [5.88,-8.09],\n            [8.09,-5.88],\n            [9.51,-3.09]\n        ];\n        res = [];\n        for (p in pl) {\n            res.push(new Vector(pl[p]));\n        }\n        return res;\n    }\n\n    function triangleShapePoints() {\n        var pl = [\n            [10,-5.77],\n            [0,11.55],\n            [-10,-5.77]\n        ];\n\n        res = [];\n        for (p in pl) {\n            res.push(new Vector(pl[p]));\n        }\n        return res;\n\n    }\n\n    function squareShapePoints() {\n        var pl = [\n            [10,-10],\n            [10,10],\n            [-10,10],\n            [-10,-10]\n        ];\n\n        res = [];\n        for (p in pl) {\n            res.push(new Vector(pl[p]));\n        }\n        return res;\n\n    }\n\n    function classicShapePoints() {\n        var pl = [\n            [0,0],\n            [-5,-9],\n            [0,-7],\n            [5,-9]\n        ];\n\n        res = [];\n        for (p in pl) {\n            res.push(new Vector(pl[p]));\n        }\n        return res;\n\n    }\n\n    Turtle.prototype.clean = function () {\n        // Clean the canvas\n        // Optional second argument is color\n        with (this) {\n            if (arguments.length >= 1) {\n                clear_canvas(canvasID, arguments[0]);\n            }\n            else {\n                clear_canvas(canvasID);\n            }\n            initialize();\n        }\n    }\n\n    Turtle.prototype.addDrawingEvent = function(eventList) {\n        TurtleGraphics.eventCount += 1;\n        eventList.push(TurtleGraphics.eventCount);\n        this.drawingEvents.push(eventList);\n    }\n//  \n//  Drawing Functions\n//\n\n    // break a line into segments\n    // sp:  Vector of starting position\n    // ep:  Vector of ending position\n    // sl:  int length of segments\n    segmentLine = function(sp, ep, sL, pen) {\n        var head = ep.sub(sp).normalize();\n        var numSegs = Math.floor(ep.sub(sp).len() / sL);\n        var res = [];\n        var oldp = sp;\n        var newp;\n        var op = ""\n        if (pen)\n            op = "LT"\n        else\n            op = "MT"\n        for (var i = 0; i < numSegs; i++) {\n            newp = oldp.linear(1, sL, head);\n            res.push([op,oldp[0],oldp[1],newp[0],newp[1]]);\n            oldp = newp;\n        }\n        if (! ((oldp[0] == ep[0]) && (oldp[1] == ep[1])))\n            res.push([op, oldp[0], oldp[1], ep[0], ep[1]]);\n        return res;\n    }\n\n    Turtle.prototype.draw_line = function(newposition) {\n        with (this) {\n            with (context) {\n                if (! animate) {\n                    if (! filling) {\n                        beginPath();\n                        moveTo(position[0], position[1]);\n                    }\n                    lineCap = \'round\';\n                    lineJoin = \'round\';\n                    lineWidth = get_pen_width();\n                    strokeStyle = penStyle;\n                    lineTo(newposition[0], newposition[1]);\n                    stroke();\n                    if (! filling)\n                        closePath();\n                } else {\n                    var r = segmentLine(position, newposition, turtleCanvas.getSegmentLength(), pen);\n                    for (var s in r) {\n                        r[s].push(penStyle);\n                        addDrawingEvent(r[s]);\n                    }\n                    if (! turtleCanvas.isAnimating()) {\n                        turtleCanvas.startAnimating(this);\n                    } else {\n                        if (! turtleCanvas.onCanvas(this))\n                            turtleCanvas.addToCanvas(this);\n                    }\n                }\n            }\n        }\n\n    }\n\n\n    Turtle.prototype.forward = function (d) {\n        with (this) {\n            var newposition = position.linear(1, d, heading);\n            goto(newposition);\n        }\n    }\n\n    Turtle.prototype.backward = function(d) {\n        this.forward(-d);\n    }\n\n//\tThis is an internal function that sets the position without doing any drawing\n    Turtle.prototype.teleport_to = function(nx, ny) {\n        if (nx instanceof Vector)\n            var newposition = nx;\n        else\n            var newposition = new Vector([nx,ny,0]);\n        this.context.moveTo(newposition[0], newposition[1]);\n\t\tthis.position = newposition;\n\t}\n\n    Turtle.prototype.goto = function(nx, ny) {\n        if (nx instanceof Vector)\n            var newposition = nx;\n        else\n            var newposition = new Vector([nx,ny,0]);\n        with (this) {\n            if (pen) {\n                draw_line(newposition);\n            } else {\n                if (! animate) {\n                    context.moveTo(newposition[0], newposition[1]);\n                } else {\n                    var r = segmentLine(position, newposition, turtleCanvas.getSegmentLength(), pen);\n                    for (var s in r)\n                        addDrawingEvent(r[s]);\n                    if (! turtleCanvas.isAnimating()) {\n                        turtleCanvas.startAnimating(this);\n                    } else {\n                        if (! turtleCanvas.onCanvas(this))\n                            turtleCanvas.addToCanvas(this);\n                    }\n                }\n            }\n            position = newposition;\n\n        }\n    }\n\n    Turtle.prototype.delay = function(d) {\t// RNL\n    \tif (d != null) {\n    \t\tif (d < 0)\n    \t\t\td = -d\n    \t\tif (!this.animate) \n    \t\t\tthis.turtleCanvas.setDelay(d)\n    \t\telse {\n    \t\t\tthis.turtleCanvas.setDelay(d)\n\t    \t\tthis.addDrawingEvent(["DL", d])\n\t    \t\tthis.addDrawingEvent(["NO"])\n    \t\t}\n    \t}\n        return this.turtleCanvas.getDelay();\n    }\n\n    Turtle.prototype.speed = function(s,t) {\n        if (s > 0 && !this.animate) {\n            this.animate = true;\n            this.turtleCanvas.setSpeedDelay(s)\n        } else if (s == 0 && !this.animate) {\n        \tthis.turtleCanvas.setSpeedDelay(s)\n        } else {\n//          this.animate = false;\n//          this.turtleCanvas.cancelAnimation();\n\t\t\tthis.addDrawingEvent(["SC", s, t])\n\t\t\tthis.addDrawingEvent(["NO"])\n        }\n        if (t) {\n            this.turtleCanvas.setSegmentLength(t);\n            // set the number of units to divide a segment into\n        } else {\n            this.turtleCanvas.setSegmentLength(10);\n        }\n    }\n\n    Turtle.prototype.tracer = function(t, d) {\n        this.turtleCanvas.setCounter(t);\n\t\tif (t == 0) {\n\t\t\tthis.animate=false;\n\t\t\tthis.turtleCanvas.cancelAnimation();\n\t\t}\n\t\tif (d !== undefined)\n\t\t\tthis.turtleCanvas.setDelay(d);\n    }\n\n    Turtle.prototype.getRenderCounter = function() {\n        return this.turtleCanvas.getCounter();\n    }\n\n    Turtle.prototype.turn = function (phi) {\n        with (this) {\n            var alpha = phi * Degree2Rad;\n            var left = normal.cross(heading);\n            var newheading = heading.rotateNormal(left, normal, alpha);\n            heading = newheading;\n\n            if (animate) {\n                addDrawingEvent(["TT",heading]);\n            }\n        }\n    }\n\n    Turtle.prototype.right = Turtle.prototype.turn;\n\n    Turtle.prototype.left = function(phi) {\n        this.turn(-phi);\n    }\n\n    Turtle.prototype.get_heading = function () {\n        if (TurtleGraphics.defaults.degrees)\n            return this.heading.toAngle()\n        else\n            return this.heading\n    }\n\n    Turtle.prototype.get_position = function () {\n        return this.position;\n    }\n\n    Turtle.prototype.getx = function () {\n        return this.position[0];\n    }\n\n    Turtle.prototype.gety = function () {\n        return this.position[1];\n    }\n\n    Turtle.prototype.set_heading = function(newhead) {\n        if ((typeof(newhead)).toLowerCase() === \'number\') {\n            this.heading = Vector.angle2vec(newhead);\n        } else {\n            this.heading = newhead;\n        }\n    }\n\n    Turtle.prototype.towards = function(to, y) {\n        // set heading vector to point towards another point.\n        if ((typeof(to)).toLowerCase() === \'number\')\n            to = new Vector(to, y, 0);\n        else if (! (to instanceof Vector)) {\n            to = new Vector(to);\n        }\n        var res = to.sub(this.position);\n        res = res.normalize();\n        if (TurtleGraphics.defaults.degrees) {\n            return res.toAngle();\n        }\n        else {\n            return res;\n        }\n    }\n\n    Turtle.prototype.distance = function(to, y) {\n        if ((typeof(to)).toLowerCase() === \'number\')\n            to = new Vector(to, y, 0);\n        return this.position.sub(new Vector(to)).len();\n    }\n\n    Turtle.prototype.dot = function() {\n        var size = 2;\n        if (arguments.length >= 1) size = arguments[0];\n        size = size * this.turtleCanvas.lineScale;\n        with (this) {\n            with (context) {\n                var color = penStyle;\n                var nc = arguments[1] || color;\n                if (! animate) {\n                    fillStyle = nc;\n                    fillRect(position[0] - size / 2, position[1] - size / 2, size, size);\n                    fillStyle = color;\n                } else {\n                    addDrawingEvent(["DT", size, nc, position[0], position[1]]);\n                }\n            }\n        }\n\n    }\n\n    Turtle.prototype.circle = function(radius, extent) {\n        if (extent === undefined) {\n            extent = 360\n        }\n\t\tif (this.animate) {\n\t\t\tvar arcLen = Math.abs(radius * Math.PI * 2.0  * extent / 360);\n\t\t\tvar segLen = this.turtleCanvas.getSegmentLength();\n\t\t\tif (arcLen <= segLen)\n\t\t\t\tthis.arc(radius,extent);\n\t\t\telse {\n\t\t\t\t//\tBreak the arc into segments for animation\n\t\t\t\tvar extentPart = (segLen / arcLen) * extent;\n\t\t\t\tvar extentLeft = extent;\n\t\t\t\twhile (Math.abs(extentLeft) > Math.abs(extentPart)) {\n\t\t\t\t\tthis.arc(radius, extentPart);\n\t\t\t\t\textentLeft = extentLeft - extentPart;\n\t\t\t\t}\n\t\t\t\tif (Math.abs(extentLeft) > 0.01)\n\t\t\t\t\tthis.arc(radius, extentLeft);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.arc(radius,extent);\n\t\t}\n\t}\n\t\n    Turtle.prototype.arc = function(radius, extent) {\n\t\t//\tFigure out where the turtle is and which way it\'s facing\n\t\tvar turtleHeading = this.get_heading()\n\t\tvar tx = this.position[0]\n\t\tvar ty = this.position[1]\n\n\t\t//\tFigure out the circle center\n\t\tvar cx = tx + (radius * Sk.math.cos((turtleHeading + 90) * Degree2Rad));\n\t\tvar cy = ty + (radius * Sk.math.sin((turtleHeading + 90) * Degree2Rad));\n\n\t\t//\tCanvas arc angles go CLOCKWISE, not COUNTERCLOCKWISE like Turtle\n\n\t\t//\tFigure out our arc angles\n\t\tvar startAngleDeg;\n\t\tif (radius >= 0)\n\t\t\tstartAngleDeg = turtleHeading - 90;\n\t\telse\n\t\t\tstartAngleDeg = turtleHeading + 90;\n\n\t\tvar endAngleDeg;\n        if (extent) {\n\t\t\tif (radius >= 0)\n\t            endAngleDeg = startAngleDeg + extent;\n\t\t\telse\n\t            endAngleDeg = startAngleDeg - extent;\n        } else {\n\t\t\tif (radius >= 0)\n\t            endAngleDeg = startAngleDeg + 360;\n\t\t\telse\n\t\t\t\tendAngleDeg = startAngleDeg - 360;\n\t\t}\n\n\t\t//\tCanvas angles are opposite\n\t\tstartAngleDeg = 360 - startAngleDeg\n\t\tendAngleDeg   = 360 - endAngleDeg\n\n\t\t//\tBecuase the y axis has been flipped in HTML5 Canvas with a tanslation, we need to adjust the angles\n\t\tstartAngleDeg = -startAngleDeg\n\t\tendAngleDeg   = -endAngleDeg\n\n\t\t//\tConvert to radians\n\t\tvar startAngle = startAngleDeg * Degree2Rad;\n\t\tvar endAngle   = endAngleDeg   * Degree2Rad;\n\n\n\t\t//\tDo the drawing\n        if (! this.animate) {\n\t\t\tif (!this.filling)\n\t\t\t\tthis.context.beginPath();\n            this.context.arc(cx, cy, Math.abs(radius), startAngle, endAngle, (radius * extent <= 0));\n            this.context.stroke();\n\t\t\tif (!this.filling)\n\t\t\t\tthis.context.closePath();\n        } else {\n            this.addDrawingEvent(["CI", cx, cy, Math.abs(radius), startAngle, endAngle, (radius * extent <= 0)]);\n        }\n\n\t\t//\tMove the turtle only if we have to\n\t\tif (extent && (extent % 360) != 0) {\n\t\t\tvar turtleArc;\n\t\t\tif (radius >= 0)\n\t\t\t\tturtleArc = extent;\n\t\t\telse \n\t\t\t\tturtleArc = -extent;\n\t\t\tvar newTurtleHeading = (turtleHeading + turtleArc) % 360;\n\t\t\tif (newTurtleHeading < 0)\n\t\t\t\tnewTurtleHeading = newTurtleHeading + 360;\n\n\t\t\tvar nx = cx + (radius * Sk.math.cos((newTurtleHeading - 90) * Degree2Rad));\n\t\t\tvar ny = cy + (radius * Sk.math.sin((newTurtleHeading - 90) * Degree2Rad));\t//\ty coord is inverted in turtle\n\n\t\t\t//\tMove it internally\n\t\t\tthis.set_heading(newTurtleHeading);\n\t\t\tthis.teleport_to(nx,ny);\n\n\t\t\t//\tIf we\'re animating the turtle, move it on the screen\n\t\t\tif (this.animate) {\n\t\t\t\tthis.addDrawingEvent(["TT", this.heading]);\n\t\t\t}\n\t\t}\n\n    }\n\n    Turtle.prototype.write = function(theText, move, align, font) {\n        if (! this.animate) {\n            if (font)\n                this.context.font = font.v;\n            this.context.scale(1, -1);\n            this.context.fillText(theText, this.position[0], -this.position[1]);\n            this.context.scale(1, -1);\n        } else {\n            var fontspec;\n            if (font)\n                fontspec = font.v\n            this.addDrawingEvent(["WT", theText, fontspec, this.position[0], this.position[1]]);\n        }\n    }\n\n    Turtle.prototype.setworldcoordinates = function(llx, lly, urx, ury) {\n        this.turtleCanvas.setworldcoordinates(llx, lly, urx, ury);\n    }\n\n//\n// Pen and Style functions\n//\n    Turtle.prototype.pen_down = function () {\n        this.pen = true;\n    }\n\n    Turtle.prototype.down = Turtle.prototype.pen_down;\n\n    Turtle.prototype.pen_up = function () {\n        this.pen = false;\n    }\n\n    Turtle.prototype.up = Turtle.prototype.pen_up;\n\n    Turtle.prototype.get_pen = function () {\n        return this.pen;\n    }\n\n    Turtle.prototype.set_pen_width = function (w) {\n        if (this.animate)\n            this.addDrawingEvent(["PW", w * this.turtleCanvas.lineScale]);\n        else\n            this.penWidth = w;\n    }\n\n    Turtle.prototype.get_pen_width = function() {\n        return this.penWidth * this.turtleCanvas.lineScale;\n    }\n\n    Turtle.prototype.set_pen_color = function (c, g, b) {\n        if (typeof(c) == "string") {\n            this.penStyle = c;\n        } else {\n        \tvar rs\n        \tvar gs\n        \tvar bs\n        \tif (typeof( c) == "object" && c.length == 3) {\n\t\t\t\tvar c0 = Sk.builtin.asnum$(c[0]);\n\t\t\t\tvar c1 = Sk.builtin.asnum$(c[1]);\n\t\t\t\tvar c2 = Sk.builtin.asnum$(c[2]);\n        \t} else {\n                var c0 = Sk.builtin.asnum$(c);\n                var c1 = Sk.builtin.asnum$(g);\n                var c2 = Sk.builtin.asnum$(b);\n        \t}\n            rs = c0.toString(16);\n            gs = c1.toString(16);\n            bs = c2.toString(16);\n            while (rs.length < 2) rs = "0" + rs;\n            while (gs.length < 2) gs = "0" + gs;\n            while (bs.length < 2) bs = "0" + bs;\n            c = "#" + rs + gs + bs;\n            this.penStyle = c;\n        }\n\n        this.context.strokeStyle = c;\n        if (this.animate)\n            this.addDrawingEvent(["TC", c]);\n    }\n\n    Turtle.prototype.set_fill_color = function (c, g, b) {\n        if (typeof(c) == "string") {\n            this.fillStyle = c;\n        } else {\n        \tvar rs\n        \tvar gs\n        \tvar bs\n        \tif (typeof( c) == "object" && c.length == 3) {\n\t\t\t\tvar c0 = Sk.builtin.asnum$(c[0]);\n\t\t\t\tvar c1 = Sk.builtin.asnum$(c[1]);\n\t\t\t\tvar c2 = Sk.builtin.asnum$(c[2]);\n        \t} else {\n                var c0 = Sk.builtin.asnum$(c);\n                var c1 = Sk.builtin.asnum$(g);\n                var c2 = Sk.builtin.asnum$(b);\n        \t}\n            rs = c0.toString(16)\n            gs = c1.toString(16)\n            bs = c2.toString(16)\n            while (rs.length < 2) rs = "0" + rs;\n            while (gs.length < 2) gs = "0" + gs;\n            while (bs.length < 2) bs = "0" + bs;\n            c = "#" + rs + gs + bs;\n            this.fillStyle = c;\n        }\n\n        this.context.fillStyle = c;\n        if (this.animate)\n            this.addDrawingEvent(["FC", c]);\n    }\n\n    Turtle.prototype.begin_fill = function () {\n        if (! this.animate) {\n            this.filling = true;\n            this.context.beginPath();\n            this.context.moveTo(this.position[0], this.position[1]);\n        } else\n            this.addDrawingEvent(["BF", this.position[0], this.position[1]]);\n\n    }\n\n    Turtle.prototype.end_fill = function () {\n        if (! this.animate) {\n            this.context.stroke();\n            this.context.fill();\n            this.context.closePath();\n            this.filling = false;\n        } else\n            this.addDrawingEvent(["EF", this.position[0], this.position[1], this.fillStyle]);\n    }\n\n\n    Turtle.prototype.showturtle = function() {\n        if (this.animate) {\n            this.addDrawingEvent(["SH"]);\n        }\n        this.visible = true;\n    }\n\n    Turtle.prototype.hideturtle = function() {\n        if (this.animate) {\n            this.addDrawingEvent(["HT"]);\n        }\n        this.visible = false;\n    }\n\n    Turtle.prototype.isvisible = function() {\n        return this.visible;\n    }\n\n    // \n    // Appearance\n    //\n\n    Turtle.prototype.shape = function(s) {\n        if (this.shapeStore[s])\n            this.currentShape = s;\n        else {\n        }\n    }\n\n    Turtle.prototype.drawturtle = function(heading, position) {\n        var rtPoints = [];\n        var plist = this.shapeStore[this.currentShape];\n        var head;\n        if (! (heading === undefined))\n            head = heading - 90.0;\n        else\n            head = this.heading.toAngle() - 90.0;\n        if (! position)\n            position = this.position\n        for (p in plist) {\n            rtPoints.push(plist[p].scale(this.turtleCanvas.xptscale,this.turtleCanvas.yptscale).rotate(head).add(position));\n        }\n        this.context.beginPath();\n        this.context.moveTo(rtPoints[0][0], rtPoints[0][1]);\n        for (var i = 1; i < rtPoints.length; i++) {\n            this.context.lineTo(rtPoints[i][0], rtPoints[i][1]);\n        }\n        this.context.closePath();\n        this.context.stroke();\n        if (this.fillStyle) {\n            this.context.fill();\n        }\n    }\n\n    Turtle.prototype.stamp = function() {\n        // either call drawTurtle or just add a DT with current position and heading to the drawingEvents list.\n        if (this.animate) {\n            this.addDrawingEvent(["ST",this.position[0],this.position[1],this.heading.toAngle()]);\n        } else\n            this.drawturtle();\n    }\n    \n    Turtle.prototype.clear = function () {\n    \tif (this.animate) {\n    \t\tthis.addDrawingEvent(["CL"])\n    \t} else {\n    \t\tclear_canvas(this.canvasID);\n    \t}\n    }\n\n    function clear_canvas(canId) {\n        with (document.getElementById(canId).getContext(\'2d\')) {\n            if (arguments.length >= 2) {\n//\t\tfillStyle = arguments[1];\n//\t\tfillRect(0, 0, canvas.width, canvas.height);\n            }\n            clearRect(-canvas.width / 2, -canvas.height / 2, canvas.width, canvas.height);\n        }\n    }\n\n\n    // Create a 3d Vector class for manipulating turtle heading, and position.\n\n    function Vector(x, y, z) {\n        if ((typeof(x)).toLowerCase() === \'number\') {\n            Array.prototype.push.call(this, x);\n            Array.prototype.push.call(this, y);\n            Array.prototype.push.call(this, z);\n        }\n        else {\n            for (var i in x) {\n                Array.prototype.push.call(this, x[i]);\n            }\n        }\n    }\n\n\n    // Create a vector object given a direction as an angle.\n    Vector.angle2vec = function(phi) {\n        var res = new Vector([0.0,0.0,0.0]);\n        phi = phi * Degree2Rad;\n        res[0] = Sk.math.cos(phi);\n        res[1] = Sk.math.sin(phi);\n        return res.normalize();\n    }\n\n    // This trick allows you to access a Vector object like an array\n    // myVec[0] == x\n    // myVec[1] == y\n    // myVec[2] == z\n    // we really only need the z for the convenience of rotating\n    Vector.prototype.addItem = function(item) {\n        Array.prototype.push.call(this, item);\n    }\n\n    Vector.prototype.linear = function(a, b, v) {\n        var result = [ ];\n        for (var c = 0; c <= 2; ++c) {\n            result[c] = a * this[c] + b * v[c];\n        }\n        return new Vector(result);\n    }\n\n    Vector.prototype.cross = function(v) {\n        // Return cross product of this and v\n        var result = [ ];\n        for (var c = 0; c <= 2; ++c) {\n            result[c] = this[(c + 1) % 3] * v[(c + 2) % 3] - this[(c + 2) % 3] * v[(c + 1) % 3];\n        }\n        return new Vector(result);\n    }\n\n    Vector.prototype.rotate = function(angle) {\n        // Rotate this counter clockwise by angle.\n        var perp = new Vector(-this[1], this[0], 0);\n        angle = angle * Degree2Rad;\n        var c = Sk.math.cos(angle);\n        var s = Sk.math.sin(angle);\n        return new Vector(this[0] * c + perp[0] * s, this[1] * c + perp[1] * s, 0);\n    }\n\n    Vector.prototype.rotateNormal = function(v, w, alpha) {\n        // Return rotation of this in direction of v about w over alpha\n        // Requires: v, w are vectors; alpha is angle in radians\n        //   this, v, w are orthonormal\n        return this.linear(Sk.math.cos(alpha), Sk.math.sin(alpha), v);\n    }\n\n    Vector.prototype.normalize = function() {\n        var n = this.len();\n        var res = this.div(n);\n        return res;\n    }\n\n    Vector.prototype.toAngle = function() {\n        // workaround for values getting set to +/i xxx e -16 fooling the +/- checks below\n        if (Math.abs(this[1]) < 0.00001) this[1] = 0.0;\n        if (Math.abs(this[0]) < 0.00001) this[0] = 0.0;\n        var rads = Math.atan(Math.abs(this[1]) / Math.abs(this[0]));\n        var deg = rads * Rad2Degree;\n        if (this[0] < 0 && this[1] > 0) deg = 180 - deg;\n        else if (this[0] < 0 && this[1] <= 0) deg = 180.0 + deg;\n        else if (this[0] >= 0 && this[1] < 0) deg = 360 - deg;\n        return deg;\n    }\n\n    // divide all vector components by the same value\n    Vector.prototype.div = function(n) {\n        res = []\n        res[0] = this[0] / n;\n        res[1] = this[1] / n;\n        res[2] = this[2] / n;\n        return new Vector(res);\n    }\n\n    // subtract one vector from another\n    Vector.prototype.sub = function(v) {\n        res = new Vector(0, 0, 0);\n        res[0] = this[0] - v[0];\n        res[1] = this[1] - v[1];\n        res[2] = this[2] - v[2];\n        return res;\n    }\n\n    Vector.prototype.add = function(v) {\n        res = new Vector(0, 0, 0);\n        res[0] = this[0] + v[0];\n        res[1] = this[1] + v[1];\n        res[2] = this[2] + v[2];\n        return res;\n    }\n\n    Vector.prototype.smul = function(k) {  // scalar multiplication\n        res = new Vector(0, 0, 0);\n        res[0] = this[0] * k;\n        res[1] = this[1] * k;\n        res[2] = this[2] * k;\n        return res;\n    }\n\n    Vector.prototype.scale = function(xs,ys) {\n        res = new Vector(0,0,0);\n        res[0] =  this[0] * ys;\n        res[1] =  this[1] * xs;\n        res[2] = 1.0;\n        return res;\n    }\n\n    Vector.prototype.len = function() {\n        return Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);\n    }\n\n\n    TurtleGraphics.defaults = { canvasID: \'mycanvas\', degrees: true, animate: true }\n    TurtleGraphics.turtleList = [];\n    TurtleGraphics.Turtle = Turtle;\n    TurtleGraphics.TurtleCanvas = TurtleCanvas;\n    TurtleGraphics.canvasLib = {}\n    TurtleGraphics.clear_canvas = clear_canvas;\n    TurtleGraphics.Vector = Vector;\n    TurtleGraphics.canvasInit = false;\n    TurtleGraphics.eventCount = 0;\n    TurtleGraphics.renderClock = 0;\n    TurtleGraphics.renderTime  = 0; // RNL\n\n})();\n\n\n//\n// Wrapper around the Turtle Module starts here.\n//\n//\nvar $builtinmodule = function(name) {\n    var mod = {};\n    // First we create an object, this will end up being the class\n    // class\n    Sk.tg = TurtleGraphics;\n\n    var checkArgs = function(expected, actual, func) {\n        if (actual != expected ) {\n            throw new Sk.builtin.TypeError(func + " takes exactly " + expected +\n                    " positional argument (" + actual + " given)")\n        }\n    }\n\n    var turtle = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self) {\n            TurtleGraphics.defaults = {canvasID: Sk.canvas, animate: true, degrees: true};\n            self.theTurtle = new TurtleGraphics.Turtle();\n        });\n\n//\n// Turtle Motion\n//\n        //\n        // Move and Draw\n        //\n        $loc.forward = new Sk.builtin.func(function(self, dist) {\n\t\t\tdist = Sk.builtin.asnum$(dist);\n            checkArgs(2,arguments.length,"forward()");\n            self.theTurtle.forward(dist);\n        });\n\n        $loc.fd = $loc.forward;\n\n        $loc.backward = new Sk.builtin.func(function(self, dist) {\n\t\t\tdist = Sk.builtin.asnum$(dist);\n            checkArgs(2,arguments.length,"backward()");\n            self.theTurtle.forward(-dist);\n        });\n\n        $loc.back = $loc.backward;\n        $loc.bk = $loc.backward;\n\n        $loc.right = new Sk.builtin.func(function(self, angle) {\n\t\t\tangle = Sk.builtin.asnum$(angle);\n            checkArgs(2,arguments.length,"right()");\n            self.theTurtle.turn(angle);\n        });\n\n        $loc.rt = $loc.right;\n\n        $loc.left = new Sk.builtin.func(function(self, angle) {\n\t\t\tangle = Sk.builtin.asnum$(angle);\n            checkArgs(2,arguments.length,"left()");\n            self.theTurtle.turn(-angle);\n        });\n\n        $loc.lt = $loc.left;\n\n        $loc.goto_$rw$ = new Sk.builtin.func(function(self, nx, ny) {\n\t\t\tnx = Sk.builtin.asnum$(nx);\n\t\t\tny = Sk.builtin.asnum$(ny);\n            checkArgs(3,arguments.length,"goto()");\n            self.theTurtle.goto(nx, ny);\n        });\n\n        $loc.setposition = new Sk.builtin.func(function(self,nx,ny) {\n\t\t\tnx = Sk.builtin.asnum$(nx);\n\t\t\tny = Sk.builtin.asnum$(ny);\n            checkArgs(3,arguments.length,"setposition()");\n            self.theTurtle.up();\n            self.theTurtle.goto(nx,ny);\n            self.theTurtle.down();\n        });\n        $loc.setpos = $loc.setposition;\n\n        $loc.setx = new Sk.builtin.func(function(self, nx) {\n\t\t\tnx = Sk.builtin.asnum$(nx);\n            checkArgs(2,arguments.length,"setx()");\n            self.theTurtle.goto(nx, self.theTurtle.GetY());\n        });\n\n        $loc.sety = new Sk.builtin.func(function(self, ny) {\n\t\t\tny = Sk.builtin.asnum$(ny);\n            checkArgs(2,arguments.length,"sety()");\n            self.theTurtle.goto(self.theTurtle.GetX(), ny);\n        });\n\n        $loc.setheading = new Sk.builtin.func(function(self, newhead) {\n\t\t\tnewhead = Sk.builtin.asnum$(newhead);\n            checkArgs(2,arguments.length,"setheading()");\n            return self.theTurtle.set_heading(newhead);\n        });\n\n        $loc.seth = $loc.setheading;\n\n        $loc.home = new Sk.builtin.func(function(self) {\n            self.theTurtle.go_home();\n        });\n\n        $loc.dot = new Sk.builtin.func(function(self, /*opt*/ size, color) {\n\t\t\tsize = Sk.builtin.asnum$(size);\n            size = size || 1;\n            if (color) {\n                color = color.v || self.theTurtle.penStyle;\n            }\n            self.theTurtle.dot(size, color);\n        });\n\n        $loc.circle = new Sk.builtin.func(function(self, radius, extent) {\n\t\t\tradius = Sk.builtin.asnum$(radius);\n\t\t\textent = Sk.builtin.asnum$(extent);\n            self.theTurtle.circle(radius, extent);\n        });\n\n        $loc.delay = new Sk.builtin.func(function(self, d) {\n\t\t\td = Sk.builtin.asnum$(d);\n            return self.theTurtle.delay(d);\n        });\n\n        $loc.speed = new Sk.builtin.func(function(self, s, t) {\n\t\t\ts = Sk.builtin.asnum$(s);\n\t\t\tt = Sk.builtin.asnum$(t);\n            self.theTurtle.speed(s,t);\n        });\n\n        $loc.tracer = new Sk.builtin.func(function(self, t, d) {\n\t\t\tt = Sk.builtin.asnum$(t);\n\t\t\td = Sk.builtin.asnum$(d);\n            self.theTurtle.tracer(t, d);\n        });\n\n\t\t$loc.update = new Sk.builtin.func(function(self) {\n\t\t\t//\tDummy function to emulate update... when not animating, we don\'t save the drawing operations, so this is pointless for us\n\t\t});\n\n        // todo:  stamp, clearstamp, clearstamps, undo, speed\n\n        //\n        // Tell Turtle\'s state\n        //\n        $loc.heading = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"heading()");\n            return Sk.builtin.assk$(self.theTurtle.get_heading(),Sk.builtin.nmber.float$);\n        });\n\n        $loc.position = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"position()");\n            var res = self.theTurtle.get_position();\n            var x = new Sk.builtin.tuple([Sk.builtin.assk$(res[0],Sk.builtin.nmber.float$),\n                                          Sk.builtin.assk$(res[1],Sk.builtin.nmber.float$) ]);\n            return x;\n        });\n\n        $loc.pos = $loc.position;\n\n        $loc.xcor = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"xcor()");\n            var res = self.theTurtle.getx();\n            return Sk.builtin.assk$(res,Sk.builtin.nmber.float$);\n        });\n\n        $loc.ycor = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"ycor()");\n            var res = self.theTurtle.gety();\n            return Sk.builtin.assk$(res,Sk.builtin.nmber.float$);\n        });\n\n        $loc.towards = new Sk.builtin.func(function(self, tx, ty) {\n\t\t\ttx = Sk.builtin.asnum$(tx);\n\t\t\tty = Sk.builtin.asnum$(ty);\n            if ((typeof(tx)).toLowerCase() === \'number\') {\n                tx = [tx, ty, 0];\n            } else {\n                tx = [Sk.builtin.asnum$(tx.theTurtle.getx()),Sk.builtin.asnum$(tx.theTurtle.gety()),Sk.builtin.asnum$(0)]\n            }\n            return Sk.builtin.assk$(self.theTurtle.towards(tx),Sk.builtin.nmber.float$);\n        });\n\n        // tx can be either a number or a vector position.\n        // tx can not be a turtle at this time as multiple turtles have not been implemented yet.\n        $loc.distance = new Sk.builtin.func(function(self, tx, ty) {\n\t\t\ttx = Sk.builtin.asnum$(tx);\n\t\t\tty = Sk.builtin.asnum$(ty);\n            if ((typeof(tx)).toLowerCase() === \'number\') {\n                tx = [tx, ty, 0];\n            } else {\n                tx = [tx.theTurtle.getx(), tx.theTurtle.gety(), 0];\n            }\n            return Sk.builtin.assk$(self.theTurtle.distance(tx),Sk.builtin.nmber.float$);\n        });\n\n        //\n        // Setting and Measurement\n        //\n\n        // todo:  degrees and radians...\n\n//\n// Pen Control\n//\n\n        //\n        // Drawing State\n        //\n\n        $loc.up = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"up()");\n            self.theTurtle.pen_up();\n        });\n\n        $loc.penup = $loc.up;\n        $loc.pu = $loc.up;\n\n        $loc.down = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"down()");\n            self.theTurtle.pen_down();\n        });\n\n        $loc.pendown = $loc.down;\n        $loc.pd = $loc.down;\n\n        $loc.width = new Sk.builtin.func(function(self, w) {\n\t\t\tw = Sk.builtin.asnum$(w);\n            checkArgs(2,arguments.length,"width()");\n            self.theTurtle.set_pen_width(w);\n        });\n\n        $loc.pensize = $loc.width;\n\n        $loc.isdown = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"isdown()");\n            return self.theTurtle.get_pen();\n        });\n\n        // todo:  pen  -- return a dictionary full of pen stuff\n\n        //\n        // Color Control\n        //\n\n        $loc.fillcolor = new Sk.builtin.func(function(self, color, green, blue) {\n            if (color) {\n                if (blue) {\n                    self.theTurtle.set_fill_color(color, green, blue);\n                } else {\n                    color = color.v || self.theTurtle.context.fillStyle;\n                    self.theTurtle.set_fill_color(color);\n                }\n            } else\n                return self.theTurtle.fillStyle;\n        });\n\n        $loc.pencolor = new Sk.builtin.func(function(self, color, green, blue) {\n            if (color) {\n                if (blue) {\n\t\t\t\t\tcolor = Sk.builtin.asnum$(color);\n\t\t\t\t\tgreen = Sk.builtin.asnum$(green);\n\t\t\t\t\tblue = Sk.builtin.asnum$(blue);\n                    self.theTurtle.set_pen_color(color, green, blue);\n                } else {\n                    color = color.v || self.theTurtle.context.fillStyle;\n                    self.theTurtle.set_pen_color(color);\n                }\n            } else\n                return self.theTurtle.penStyle;\n        });\n\n        $loc.color = new Sk.builtin.func(function(self, color, green, blue) {\n            if(color) {\n                if (blue) {\n                    self.theTurtle.set_pen_color(color, green, blue);\n                    self.theTurtle.set_fill_color(color, green, blue);\n                } else {\n                    color = color.v || self.theTurtle.context.fillStyle;\n                    self.theTurtle.set_pen_color(color);\n                    self.theTurtle.set_fill_color(color);\n                }\n            } else \n                return [self.theTurtle.penStyle, self.theTurtle.fillStyle];            \n        });\n\n        //\n        //  Filling\n        //\n\n        $loc.begin_fill = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"begin_fill()");\n            self.theTurtle.begin_fill();\n        });\n\n        $loc.end_fill = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"end_fill()");\n            self.theTurtle.end_fill();\n        });\n\n        $loc.fill = new Sk.builtin.func(function(self, fillt) {\n\t\t\tif (fillt === undefined)\n\t\t\t\treturn self.theTurtle.filling;\n            if (fillt)\n                self.theTurtle.begin_fill();\n            else\n                self.theTurtle.end_fill();\n        });\n\n        //\n        // More drawing control\n        //\n\n        $loc.reset = new Sk.builtin.func(function(self) {\n            self.theTurtle.clean();\n        });\n\n        $loc.showturtle = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"showturtle()");\n            self.theTurtle.showturtle();\n        });\n        $loc.st = $loc.showturtle;\n\n        $loc.hideturtle = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"hideturtle()");\n            self.theTurtle.hideturtle();\n        });\n        $loc.ht = $loc.hideturtle;\n\n        $loc.isvisible = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"isvisible()");\n            self.theTurtle.isvisible()\n        });\n\n        $loc.stamp = new Sk.builtin.func(function(self) {\n            checkArgs(1,arguments.length,"stamp()");\n            self.theTurtle.stamp();\n        });\n\n        $loc.shape = new Sk.builtin.func(function(self, s) {\n            checkArgs(2,arguments.length,"shape()");\n            self.theTurtle.shape(s.v);\n        });\n\n\n        // todo the move, align, and font parameters should be kwargs...\n        $loc.write = new Sk.builtin.func(function(self, mystr, move, align, font) {\n            self.theTurtle.write(mystr.v, move, align, font);\n        });\n\n        // todo clean  -- again multiple turtles\n\n        $loc.setworldcoordinates = new Sk.builtin.func(function(self, llx, lly, urx, ury) {\n\t\t\tllx = Sk.builtin.asnum$(llx);\n\t\t\tlly = Sk.builtin.asnum$(lly);\n\t\t\turx = Sk.builtin.asnum$(urx);\n\t\t\tury = Sk.builtin.asnum$(ury);\n            self.theTurtle.setworldcoordinates(llx, lly, urx, ury);\n        });\n\n\t\t//\tAdded by RNL\n\n\t\t$loc.clear = new Sk.builtin.func(function(self) {\n\t\t\tself.theTurtle.clear()\n\t\t});\n\n    }\n\n    mod.Turtle = Sk.misceval.buildClass(mod, turtle, \'Turtle\', []);\n\n    var screen = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self) {\n            TurtleGraphics.defaults = {canvasID: Sk.canvas, animate: true, degrees: true};\n            var currentCanvas = TurtleGraphics.canvasLib[TurtleGraphics.defaults.canvasID];\n            if (currentCanvas === undefined) {\n                self.theScreen = new TurtleGraphics.TurtleCanvas(TurtleGraphics.defaults);\n            } else {\n                self.theScreen = currentCanvas;\n            }\n        });\n\n        $loc.bgcolor = new Sk.builtin.func(function(self, c) {\n            self.theScreen.bgcolor(c);\n        });\n\n        $loc.setworldcoordinates = new Sk.builtin.func(function(self, llx,lly,urx,ury) {\n\t\t\tllx = Sk.builtin.asnum$(llx);\n\t\t\tlly = Sk.builtin.asnum$(lly);\n\t\t\turx = Sk.builtin.asnum$(urx);\n\t\t\tury = Sk.builtin.asnum$(ury);\n            self.theScreen.setworldcoordinates(llx,lly,urx,ury);\n        });\n\n        $loc.exitonclick = new Sk.builtin.func(function(self) {\n            self.theScreen.exitonclick();\n        });\n\n        $loc.title = new Sk.builtin.func(function(self,titlestring) {\n            // no op....\n        });\n\n        $loc.window_width = new Sk.builtin.func(function(self) {\n            return self.theScreen.window_width();\n        });\n\n        $loc.window_height = new Sk.builtin.func(function(self) {\n            return self.theScreen.window_height();\n        });\n\n        $loc.turtles = new Sk.builtin.func(function(self) {\n            return self.theScreen.turtles();\n        });\n\n\t\t$loc.colormode = new Sk.builtin.func(function(self) {\n\t\t\t//\tEmpty function to emulate compatibility\n\t\t});\n        \n//        $loc.clear = new Sk.builtin.func(function(self) {\n//        \t\n//        });\n\n        var myfunc = function(self, width, height, startx, starty) {\n\t\t\twidth = Sk.builtin.asnum$(width);\n\t\t\theight = Sk.builtin.asnum$(height);\n            self.theScreen.setup(width,height);\n        }\n        // this should allow for named parameters\n        myfunc.co_varnames = [\'self\',\'width\',\'height\',\'startx\',\'starty\'];\n        myfunc.$defaults = [null,500,500,0,0];\n        $loc.setup = new Sk.builtin.func(myfunc);\n    }\n\n    mod.Screen = Sk.misceval.buildClass(mod, screen, \'Screen\', []);\n\n    mod.tracer = new Sk.builtin.func(function(t, d) {\n\t\tt = Sk.builtin.asnum$(t);\n\t\td = Sk.builtin.asnum$(d);\n\t\tfor (var i in Sk.tg.canvasLib)\n\t\t\tSk.tg.canvasLib[i].tracer(t, d);\n    });\n\n\tmod.update = new Sk.builtin.func(function(self) {\n\t\t//\tDummy function to emulate update... when not animating, we don\'t save the drawing operations, so this is pointless for us\n\t});\n\n\n    return mod\n}\n',
    'src/lib/http/__init__.js': 'var $builtinmodule = function(name)\n{\n  var mod = {};\n  Sk.builtin.defineHttp(mod);\n  return mod;\n};\n',
    'src/builtin/unittest.py': '#!/usr/bin/env python\n\'\'\'\nPython unit testing framework, based on Erich Gamma\'s JUnit and Kent Beck\'s\nSmalltalk testing framework.\n\nThis module contains the core framework classes that form the basis of\nspecific test cases and suites (TestCase, TestSuite etc.), and also a\ntext-based utility class for running the tests and reporting the results\n (TextTestRunner).\n\nSimple usage:\n\n    import unittest\n\n    class IntegerArithmenticTestCase(unittest.TestCase):\n        def testAdd(self):  ## test method names begin \'test*\'\n            self.assertEquals((1 + 2), 3)\n            self.assertEquals(0 + 1, 1)\n        def testMultiply(self):\n            self.assertEquals((0 * 10), 0)\n            self.assertEquals((5 * 8), 40)\n\n    if __name__ == \'__main__\':\n        unittest.main()\n\nFurther information is available in the bundled documentation, and from\n\n  http://docs.python.org/lib/module-unittest.html\n\nCopyright (c) 1999-2003 Steve Purcell\nThis module is free software, and you may redistribute it and/or modify\nit under the same terms as Python itself, so long as this copyright message\nand disclaimer are retained in their original form.\n\nIN NO EVENT SHALL THE AUTHOR BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,\nSPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OF\nTHIS CODE, EVEN IF THE AUTHOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\nDAMAGE.\n\nTHE AUTHOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE.  THE CODE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS,\nAND THERE IS NO OBLIGATION WHATSOEVER TO PROVIDE MAINTENANCE,\nSUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n\'\'\'\n\n__author__ = "Steve Purcell"\n__email__ = "stephen_purcell at yahoo dot com"\n__version__ = "#Revision: 1.63 $"[11:-2]\n\nimport time\nimport sys\nimport traceback\nimport os\nimport types\n\n##############################################################################\n# Exported classes and functions\n##############################################################################\n__all__ = [\'TestResult\', \'TestCase\', \'TestSuite\', \'TextTestRunner\',\n           \'TestLoader\', \'FunctionTestCase\', \'main\', \'defaultTestLoader\']\n\n# Expose obsolete functions for backwards compatibility\n__all__.extend([\'getTestCaseNames\', \'makeSuite\', \'findTestCases\'])\n\n\n##############################################################################\n# Backward compatibility\n##############################################################################\nif sys.version_info[:2] < (2, 2):\n    def isinstance(obj, clsinfo):\n        import __builtin__\n        if type(clsinfo) in (tuple, list):\n            for cls in clsinfo:\n                if cls is type: cls = types.ClassType\n                if __builtin__.isinstance(obj, cls):\n                    return 1\n            return 0\n        else: return __builtin__.isinstance(obj, clsinfo)\n\ndef _CmpToKey(mycmp):\n    \'Convert a cmp= function into a key= function\'\n    class K(object):\n        def __init__(self, obj):\n            self.obj = obj\n        def __lt__(self, other):\n            return mycmp(self.obj, other.obj) == -1\n    return K\n\n##############################################################################\n# Test framework core\n##############################################################################\n\n# All classes defined herein are \'new-style\' classes, allowing use of \'super()\'\n__metaclass__ = type\n\ndef _strclass(cls):\n    return "%s.%s" % (cls.__module__, cls.__name__)\n\n__unittest = 1\n\nclass TestResult:\n    """Holder for test result information.\n\n    Test results are automatically managed by the TestCase and TestSuite\n    classes, and do not need to be explicitly manipulated by writers of tests.\n\n    Each instance holds the total number of tests run, and collections of\n    failures and errors that occurred among those test runs. The collections\n    contain tuples of (testcase, exceptioninfo), where exceptioninfo is the\n    formatted traceback of the error that occurred.\n    """\n    def __init__(self):\n        self.failures = []\n        self.errors = []\n        self.testsRun = 0\n        self.shouldStop = False\n\n    def startTest(self, test):\n        "Called when the given test is about to be run"\n        self.testsRun = self.testsRun + 1\n\n    def stopTest(self, test):\n        "Called when the given test has been run"\n        pass\n\n    def addError(self, test, err):\n        """Called when an error has occurred. \'err\' is a tuple of values as\n        returned by sys.exc_info().\n        """\n        self.errors.append((test, self._exc_info_to_string(err, test)))\n\n    def addFailure(self, test, err):\n        """Called when an error has occurred. \'err\' is a tuple of values as\n        returned by sys.exc_info()."""\n        self.failures.append((test, self._exc_info_to_string(err, test)))\n\n    def addSuccess(self, test):\n        "Called when a test has completed successfully"\n        pass\n\n    def wasSuccessful(self):\n        "Tells whether or not this result was a success"\n        return len(self.failures) == len(self.errors) == 0\n\n    def stop(self):\n        "Indicates that the tests should be aborted"\n        self.shouldStop = True\n\n    def _exc_info_to_string(self, err, test):\n        """Converts a sys.exc_info()-style tuple of values into a string."""\n        exctype, value, tb = err\n        # Skip test runner traceback levels\n        while tb and self._is_relevant_tb_level(tb):\n            tb = tb.tb_next\n        if exctype is test.failureException:\n            # Skip assert*() traceback levels\n            length = self._count_relevant_tb_levels(tb)\n            return \'\'.join(traceback.format_exception(exctype, value, tb, length))\n        return \'\'.join(traceback.format_exception(exctype, value, tb))\n\n    def _is_relevant_tb_level(self, tb):\n        return \'__unittest\' in tb.tb_frame.f_globals\n\n    def _count_relevant_tb_levels(self, tb):\n        length = 0\n        while tb and not self._is_relevant_tb_level(tb):\n            length += 1\n            tb = tb.tb_next\n        return length\n\n    def __repr__(self):\n        return "<%s run=%i errors=%i failures=%i>" % \\\n               (_strclass(self.__class__), self.testsRun, len(self.errors),\n                len(self.failures))\n\nclass TestCase:\n    """A class whose instances are single test cases.\n\n    By default, the test code itself should be placed in a method named\n    \'runTest\'.\n\n    If the fixture may be used for many test cases, create as\n    many test methods as are needed. When instantiating such a TestCase\n    subclass, specify in the constructor arguments the name of the test method\n    that the instance is to execute.\n\n    Test authors should subclass TestCase for their own tests. Construction\n    and deconstruction of the test\'s environment (\'fixture\') can be\n    implemented by overriding the \'setUp\' and \'tearDown\' methods respectively.\n\n    If it is necessary to override the __init__ method, the base class\n    __init__ method must always be called. It is important that subclasses\n    should not change the signature of their __init__ method, since instances\n    of the classes are instantiated automatically by parts of the framework\n    in order to be run.\n    """\n\n    # This attribute determines which exception will be raised when\n    # the instance\'s assertion methods fail; test methods raising this\n    # exception will be deemed to have \'failed\' rather than \'errored\'\n\n    failureException = AssertionError\n\n    def __init__(self, methodName=\'runTest\'):\n        """Create an instance of the class that will use the named test\n           method when executed. Raises a ValueError if the instance does\n           not have a method with the specified name.\n        """\n        try:\n            self._testMethodName = methodName\n            testMethod = getattr(self, methodName)\n            self._testMethodDoc = testMethod.__doc__\n        except AttributeError:\n            raise ValueError, "no such test method in %s: %s" % \\\n                  (self.__class__, methodName)\n\n    def setUp(self):\n        "Hook method for setting up the test fixture before exercising it."\n        pass\n\n    def tearDown(self):\n        "Hook method for deconstructing the test fixture after testing it."\n        pass\n\n    def countTestCases(self):\n        return 1\n\n    def defaultTestResult(self):\n        return TestResult()\n\n    def shortDescription(self):\n        """Returns a one-line description of the test, or None if no\n        description has been provided.\n\n        The default implementation of this method returns the first line of\n        the specified test method\'s docstring.\n        """\n        doc = self._testMethodDoc\n        return doc and doc.split("\\n")[0].strip() or None\n\n    def id(self):\n        return "%s.%s" % (_strclass(self.__class__), self._testMethodName)\n\n    def __eq__(self, other):\n        if type(self) is not type(other):\n            return False\n\n        return self._testMethodName == other._testMethodName\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __hash__(self):\n        return hash((type(self), self._testMethodName))\n\n    def __str__(self):\n        return "%s (%s)" % (self._testMethodName, _strclass(self.__class__))\n\n    def __repr__(self):\n        return "<%s testMethod=%s>" % \\\n               (_strclass(self.__class__), self._testMethodName)\n\n    def run(self, result=None):\n        if result is None: result = self.defaultTestResult()\n        result.startTest(self)\n        testMethod = getattr(self, self._testMethodName)\n        try:\n            try:\n                self.setUp()\n            except KeyboardInterrupt:\n                raise\n            except:\n                result.addError(self, self._exc_info())\n                return\n\n            ok = False\n            try:\n                testMethod()\n                ok = True\n            except self.failureException:\n                result.addFailure(self, self._exc_info())\n            except KeyboardInterrupt:\n                raise\n            except:\n                result.addError(self, self._exc_info())\n\n            try:\n                self.tearDown()\n            except KeyboardInterrupt:\n                raise\n            except:\n                result.addError(self, self._exc_info())\n                ok = False\n            if ok: result.addSuccess(self)\n        finally:\n            result.stopTest(self)\n\n    def __call__(self, *args, **kwds):\n        return self.run(*args, **kwds)\n\n    def debug(self):\n        """Run the test without collecting errors in a TestResult"""\n        self.setUp()\n        getattr(self, self._testMethodName)()\n        self.tearDown()\n\n    def _exc_info(self):\n        """Return a version of sys.exc_info() with the traceback frame\n           minimised; usually the top level of the traceback frame is not\n           needed.\n        """\n        return sys.exc_info()\n\n    def fail(self, msg=None):\n        """Fail immediately, with the given message."""\n        raise self.failureException, msg\n\n    def failIf(self, expr, msg=None):\n        "Fail the test if the expression is true."\n        if expr: raise self.failureException, msg\n\n    def failUnless(self, expr, msg=None):\n        """Fail the test unless the expression is true."""\n        if not expr: raise self.failureException, msg\n\n    def failUnlessRaises(self, excClass, callableObj, *args, **kwargs):\n        """Fail unless an exception of class excClass is thrown\n           by callableObj when invoked with arguments args and keyword\n           arguments kwargs. If a different type of exception is\n           thrown, it will not be caught, and the test case will be\n           deemed to have suffered an error, exactly as for an\n           unexpected exception.\n        """\n        try:\n            callableObj(*args, **kwargs)\n        except excClass:\n            return\n        else:\n            if hasattr(excClass,\'__name__\'): excName = excClass.__name__\n            else: excName = str(excClass)\n            raise self.failureException, "%s not raised" % excName\n\n    def failUnlessEqual(self, first, second, msg=None):\n        """Fail if the two objects are unequal as determined by the \'==\'\n           operator.\n        """\n        if not first == second:\n            raise self.failureException, \\\n                  (msg or \'%r != %r\' % (first, second))\n\n    def failIfEqual(self, first, second, msg=None):\n        """Fail if the two objects are equal as determined by the \'==\'\n           operator.\n        """\n        if first == second:\n            raise self.failureException, \\\n                  (msg or \'%r == %r\' % (first, second))\n\n    def failUnlessAlmostEqual(self, first, second, places=7, msg=None):\n        """Fail if the two objects are unequal as determined by their\n           difference rounded to the given number of decimal places\n           (default 7) and comparing to zero.\n\n           Note that decimal places (from zero) are usually not the same\n           as significant digits (measured from the most signficant digit).\n        """\n        if round(abs(second-first), places) != 0:\n            raise self.failureException, \\\n                  (msg or \'%r != %r within %r places\' % (first, second, places))\n\n    def failIfAlmostEqual(self, first, second, places=7, msg=None):\n        """Fail if the two objects are equal as determined by their\n           difference rounded to the given number of decimal places\n           (default 7) and comparing to zero.\n\n           Note that decimal places (from zero) are usually not the same\n           as significant digits (measured from the most signficant digit).\n        """\n        if round(abs(second-first), places) == 0:\n            raise self.failureException, \\\n                  (msg or \'%r == %r within %r places\' % (first, second, places))\n\n    # Synonyms for assertion methods\n\n    assertEqual = assertEquals = failUnlessEqual\n\n    assertNotEqual = assertNotEquals = failIfEqual\n\n    assertAlmostEqual = assertAlmostEquals = failUnlessAlmostEqual\n\n    assertNotAlmostEqual = assertNotAlmostEquals = failIfAlmostEqual\n\n    assertRaises = failUnlessRaises\n\n    assert_ = assertTrue = failUnless\n\n    assertFalse = failIf\n\n\n\nclass TestSuite:\n    """A test suite is a composite test consisting of a number of TestCases.\n\n    For use, create an instance of TestSuite, then add test case instances.\n    When all tests have been added, the suite can be passed to a test\n    runner, such as TextTestRunner. It will run the individual test cases\n    in the order in which they were added, aggregating the results. When\n    subclassing, do not forget to call the base class constructor.\n    """\n    def __init__(self, tests=()):\n        self._tests = []\n        self.addTests(tests)\n\n    def __repr__(self):\n        return "<%s tests=%s>" % (_strclass(self.__class__), self._tests)\n\n    __str__ = __repr__\n\n    def __eq__(self, other):\n        if type(self) is not type(other):\n            return False\n        return self._tests == other._tests\n\n    def __ne__(self, other):\n        return not self == other\n\n    # Can\'t guarantee hash invariant, so flag as unhashable\n    __hash__ = None\n\n    def __iter__(self):\n        return iter(self._tests)\n\n    def countTestCases(self):\n        cases = 0\n        for test in self._tests:\n            cases += test.countTestCases()\n        return cases\n\n    def addTest(self, test):\n        # sanity checks\n        if not hasattr(test, \'__call__\'):\n            raise TypeError("the test to add must be callable")\n        if (isinstance(test, (type, types.ClassType)) and\n            issubclass(test, (TestCase, TestSuite))):\n            raise TypeError("TestCases and TestSuites must be instantiated "\n                            "before passing them to addTest()")\n        self._tests.append(test)\n\n    def addTests(self, tests):\n        if isinstance(tests, basestring):\n            raise TypeError("tests must be an iterable of tests, not a string")\n        for test in tests:\n            self.addTest(test)\n\n    def run(self, result):\n        for test in self._tests:\n            if result.shouldStop:\n                break\n            test(result)\n        return result\n\n    def __call__(self, *args, **kwds):\n        return self.run(*args, **kwds)\n\n    def debug(self):\n        """Run the tests without collecting errors in a TestResult"""\n        for test in self._tests: test.debug()\n\n\nclass FunctionTestCase(TestCase):\n    """A test case that wraps a test function.\n\n    This is useful for slipping pre-existing test functions into the\n    unittest framework. Optionally, set-up and tidy-up functions can be\n    supplied. As with TestCase, the tidy-up (\'tearDown\') function will\n    always be called if the set-up (\'setUp\') function ran successfully.\n    """\n\n    def __init__(self, testFunc, setUp=None, tearDown=None,\n                 description=None):\n        TestCase.__init__(self)\n        self.__setUpFunc = setUp\n        self.__tearDownFunc = tearDown\n        self.__testFunc = testFunc\n        self.__description = description\n\n    def setUp(self):\n        if self.__setUpFunc is not None:\n            self.__setUpFunc()\n\n    def tearDown(self):\n        if self.__tearDownFunc is not None:\n            self.__tearDownFunc()\n\n    def runTest(self):\n        self.__testFunc()\n\n    def id(self):\n        return self.__testFunc.__name__\n\n    def __eq__(self, other):\n        if type(self) is not type(other):\n            return False\n\n        return self.__setUpFunc == other.__setUpFunc and \\\n               self.__tearDownFunc == other.__tearDownFunc and \\\n               self.__testFunc == other.__testFunc and \\\n               self.__description == other.__description\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __hash__(self):\n        return hash((type(self), self.__setUpFunc, self.__tearDownFunc,\n                                           self.__testFunc, self.__description))\n\n    def __str__(self):\n        return "%s (%s)" % (_strclass(self.__class__), self.__testFunc.__name__)\n\n    def __repr__(self):\n        return "<%s testFunc=%s>" % (_strclass(self.__class__), self.__testFunc)\n\n    def shortDescription(self):\n        if self.__description is not None: return self.__description\n        doc = self.__testFunc.__doc__\n        return doc and doc.split("\\n")[0].strip() or None\n\n\n\n##############################################################################\n# Locating and loading tests\n##############################################################################\n\nclass TestLoader:\n    """This class is responsible for loading tests according to various\n    criteria and returning them wrapped in a TestSuite\n    """\n    testMethodPrefix = \'test\'\n    sortTestMethodsUsing = cmp\n    suiteClass = TestSuite\n\n    def loadTestsFromTestCase(self, testCaseClass):\n        """Return a suite of all tests cases contained in testCaseClass"""\n        if issubclass(testCaseClass, TestSuite):\n            raise TypeError("Test cases should not be derived from TestSuite. Maybe you meant to derive from TestCase?")\n        testCaseNames = self.getTestCaseNames(testCaseClass)\n        if not testCaseNames and hasattr(testCaseClass, \'runTest\'):\n            testCaseNames = [\'runTest\']\n        return self.suiteClass(map(testCaseClass, testCaseNames))\n\n    def loadTestsFromModule(self, module):\n        """Return a suite of all tests cases contained in the given module"""\n        tests = []\n        for name in dir(module):\n            obj = getattr(module, name)\n            if (isinstance(obj, (type, types.ClassType)) and\n                issubclass(obj, TestCase)):\n                tests.append(self.loadTestsFromTestCase(obj))\n        return self.suiteClass(tests)\n\n    def loadTestsFromName(self, name, module=None):\n        """Return a suite of all tests cases given a string specifier.\n\n        The name may resolve either to a module, a test case class, a\n        test method within a test case class, or a callable object which\n        returns a TestCase or TestSuite instance.\n\n        The method optionally resolves the names relative to a given module.\n        """\n        parts = name.split(\'.\')\n        if module is None:\n            parts_copy = parts[:]\n            while parts_copy:\n                try:\n                    module = __import__(\'.\'.join(parts_copy))\n                    break\n                except ImportError:\n                    del parts_copy[-1]\n                    if not parts_copy: raise\n            parts = parts[1:]\n        obj = module\n        for part in parts:\n            parent, obj = obj, getattr(obj, part)\n\n        if type(obj) == types.ModuleType:\n            return self.loadTestsFromModule(obj)\n        elif (isinstance(obj, (type, types.ClassType)) and\n              issubclass(obj, TestCase)):\n            return self.loadTestsFromTestCase(obj)\n        elif (type(obj) == types.UnboundMethodType and\n              isinstance(parent, (type, types.ClassType)) and\n              issubclass(parent, TestCase)):\n            return TestSuite([parent(obj.__name__)])\n        elif isinstance(obj, TestSuite):\n            return obj\n        elif hasattr(obj, \'__call__\'):\n            test = obj()\n            if isinstance(test, TestSuite):\n                return test\n            elif isinstance(test, TestCase):\n                return TestSuite([test])\n            else:\n                raise TypeError("calling %s returned %s, not a test" %\n                                (obj, test))\n        else:\n            raise TypeError("don\'t know how to make test from: %s" % obj)\n\n    def loadTestsFromNames(self, names, module=None):\n        """Return a suite of all tests cases found using the given sequence\n        of string specifiers. See \'loadTestsFromName()\'.\n        """\n        suites = [self.loadTestsFromName(name, module) for name in names]\n        return self.suiteClass(suites)\n\n    def getTestCaseNames(self, testCaseClass):\n        """Return a sorted sequence of method names found within testCaseClass\n        """\n        def isTestMethod(attrname, testCaseClass=testCaseClass, prefix=self.testMethodPrefix):\n            return attrname.startswith(prefix) and hasattr(getattr(testCaseClass, attrname), \'__call__\')\n        testFnNames = filter(isTestMethod, dir(testCaseClass))\n        if self.sortTestMethodsUsing:\n            testFnNames.sort(key=_CmpToKey(self.sortTestMethodsUsing))\n        return testFnNames\n\n\n\ndefaultTestLoader = TestLoader()\n\n\n##############################################################################\n# Patches for old functions: these functions should be considered obsolete\n##############################################################################\n\ndef _makeLoader(prefix, sortUsing, suiteClass=None):\n    loader = TestLoader()\n    loader.sortTestMethodsUsing = sortUsing\n    loader.testMethodPrefix = prefix\n    if suiteClass: loader.suiteClass = suiteClass\n    return loader\n\ndef getTestCaseNames(testCaseClass, prefix, sortUsing=cmp):\n    return _makeLoader(prefix, sortUsing).getTestCaseNames(testCaseClass)\n\ndef makeSuite(testCaseClass, prefix=\'test\', sortUsing=cmp, suiteClass=TestSuite):\n    return _makeLoader(prefix, sortUsing, suiteClass).loadTestsFromTestCase(testCaseClass)\n\ndef findTestCases(module, prefix=\'test\', sortUsing=cmp, suiteClass=TestSuite):\n    return _makeLoader(prefix, sortUsing, suiteClass).loadTestsFromModule(module)\n\n\n##############################################################################\n# Text UI\n##############################################################################\n\nclass _WritelnDecorator:\n    """Used to decorate file-like objects with a handy \'writeln\' method"""\n    def __init__(self,stream):\n        self.stream = stream\n\n    def __getattr__(self, attr):\n        return getattr(self.stream,attr)\n\n    def writeln(self, arg=None):\n        if arg: self.write(arg)\n        self.write(\'\\n\') # text-mode streams translate to \\r\\n if needed\n\n\nclass _TextTestResult(TestResult):\n    """A test result class that can print formatted text results to a stream.\n\n    Used by TextTestRunner.\n    """\n    separator1 = \'=\' * 70\n    separator2 = \'-\' * 70\n\n    def __init__(self, stream, descriptions, verbosity):\n        TestResult.__init__(self)\n        self.stream = stream\n        self.showAll = verbosity > 1\n        self.dots = verbosity == 1\n        self.descriptions = descriptions\n\n    def getDescription(self, test):\n        if self.descriptions:\n            return test.shortDescription() or str(test)\n        else:\n            return str(test)\n\n    def startTest(self, test):\n        TestResult.startTest(self, test)\n        if self.showAll:\n            self.stream.write(self.getDescription(test))\n            self.stream.write(" ... ")\n            self.stream.flush()\n\n    def addSuccess(self, test):\n        TestResult.addSuccess(self, test)\n        if self.showAll:\n            self.stream.writeln("ok")\n        elif self.dots:\n            self.stream.write(\'.\')\n            self.stream.flush()\n\n    def addError(self, test, err):\n        TestResult.addError(self, test, err)\n        if self.showAll:\n            self.stream.writeln("ERROR")\n        elif self.dots:\n            self.stream.write(\'E\')\n            self.stream.flush()\n\n    def addFailure(self, test, err):\n        TestResult.addFailure(self, test, err)\n        if self.showAll:\n            self.stream.writeln("FAIL")\n        elif self.dots:\n            self.stream.write(\'F\')\n            self.stream.flush()\n\n    def printErrors(self):\n        if self.dots or self.showAll:\n            self.stream.writeln()\n        self.printErrorList(\'ERROR\', self.errors)\n        self.printErrorList(\'FAIL\', self.failures)\n\n    def printErrorList(self, flavour, errors):\n        for test, err in errors:\n            self.stream.writeln(self.separator1)\n            self.stream.writeln("%s: %s" % (flavour,self.getDescription(test)))\n            self.stream.writeln(self.separator2)\n            self.stream.writeln("%s" % err)\n\n\nclass TextTestRunner:\n    """A test runner class that displays results in textual form.\n\n    It prints out the names of tests as they are run, errors as they\n    occur, and a summary of the results at the end of the test run.\n    """\n    def __init__(self, stream=sys.stderr, descriptions=1, verbosity=1):\n        self.stream = _WritelnDecorator(stream)\n        self.descriptions = descriptions\n        self.verbosity = verbosity\n\n    def _makeResult(self):\n        return _TextTestResult(self.stream, self.descriptions, self.verbosity)\n\n    def run(self, test):\n        "Run the given test case or test suite."\n        result = self._makeResult()\n        startTime = time.time()\n        test(result)\n        stopTime = time.time()\n        timeTaken = stopTime - startTime\n        result.printErrors()\n        self.stream.writeln(result.separator2)\n        run = result.testsRun\n        self.stream.writeln("Ran %d test%s in %.3fs" %\n                            (run, run != 1 and "s" or "", timeTaken))\n        self.stream.writeln()\n        if not result.wasSuccessful():\n            self.stream.write("FAILED (")\n            failed, errored = map(len, (result.failures, result.errors))\n            if failed:\n                self.stream.write("failures=%d" % failed)\n            if errored:\n                if failed: self.stream.write(", ")\n                self.stream.write("errors=%d" % errored)\n            self.stream.writeln(")")\n        else:\n            self.stream.writeln("OK")\n        return result\n\n\n\n##############################################################################\n# Facilities for running tests from the command line\n##############################################################################\n\nclass TestProgram:\n    """A command-line program that runs a set of tests; this is primarily\n       for making test modules conveniently executable.\n    """\n    USAGE = """\\\nUsage: %(progName)s [options] [test] [...]\n\nOptions:\n  -h, --help       Show this message\n  -v, --verbose    Verbose output\n  -q, --quiet      Minimal output\n\nExamples:\n  %(progName)s                               - run default set of tests\n  %(progName)s MyTestSuite                   - run suite \'MyTestSuite\'\n  %(progName)s MyTestCase.testSomething      - run MyTestCase.testSomething\n  %(progName)s MyTestCase                    - run all \'test*\' test methods\n                                               in MyTestCase\n"""\n    def __init__(self, module=\'__main__\', defaultTest=None,\n                 argv=None, testRunner=None,\n                 testLoader=defaultTestLoader):\n        if type(module) == type(\'\'):\n            self.module = __import__(module)\n            for part in module.split(\'.\')[1:]:\n                self.module = getattr(self.module, part)\n        else:\n            self.module = module\n        if argv is None:\n            argv = sys.argv\n        self.verbosity = 1\n        self.defaultTest = defaultTest\n        self.testRunner = testRunner\n        self.testLoader = testLoader\n        self.progName = os.path.basename(argv[0])\n        self.parseArgs(argv)\n        self.runTests()\n\n    def usageExit(self, msg=None):\n        if msg: print msg\n        print self.USAGE % self.__dict__\n        sys.exit(2)\n\n    def parseArgs(self, argv):\n        import getopt\n        try:\n            options, args = getopt.getopt(argv[1:], \'hHvq\',\n                                          [\'help\',\'verbose\',\'quiet\'])\n            for opt, value in options:\n                if opt in (\'-h\',\'-H\',\'--help\'):\n                    self.usageExit()\n                if opt in (\'-q\',\'--quiet\'):\n                    self.verbosity = 0\n                if opt in (\'-v\',\'--verbose\'):\n                    self.verbosity = 2\n            if len(args) == 0 and self.defaultTest is None:\n                self.test = self.testLoader.loadTestsFromModule(self.module)\n                return\n            if len(args) > 0:\n                self.testNames = args\n            else:\n                self.testNames = (self.defaultTest,)\n            self.createTests()\n        except getopt.error, msg:\n            self.usageExit(msg)\n\n    def createTests(self):\n        self.test = self.testLoader.loadTestsFromNames(self.testNames,\n                                                       self.module)\n\n    def runTests(self):\n        if self.testRunner is None:\n            self.testRunner = TextTestRunner\n\n        if isinstance(self.testRunner, (type, types.ClassType)):\n            try:\n                testRunner = self.testRunner(verbosity=self.verbosity)\n            except TypeError:\n                # didn\'t accept the verbosity argument\n                testRunner = self.testRunner()\n        else:\n            # it is assumed to be a TestRunner instance\n            testRunner = self.testRunner\n        result = testRunner.run(self.test)\n        sys.exit(not result.wasSuccessful())\n\nmain = TestProgram\n\n\n##############################################################################\n# Executing this module from the command line\n##############################################################################\n\nif __name__ == "__main__":\n    main(module=None)\n',
    'src/lib/pythonds/graphs/__init__.py': '\n\nfrom .adjGraph import Graph\nfrom .adjGraph import Vertex\nfrom .priorityQueue import PriorityQueue\n',
    'src/lib/workbench/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineWorkbench(mod);\n  return mod;\n}\n',
    'src/lib/pythonds/graphs/priorityQueue.py': '# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \nimport unittest\n\n# this implementation of binary heap takes key value pairs,\n# we will assume that the keys are all comparable\n\nclass PriorityQueue:\n    def __init__(self):\n        self.heapArray = [(0,0)]\n        self.currentSize = 0\n\n    def buildHeap(self,alist):\n        self.currentSize = len(alist)\n        self.heapArray = [(0,0)]\n        for i in alist:\n            self.heapArray.append(i)\n        i = len(alist) // 2            \n        while (i > 0):\n            self.percDown(i)\n            i = i - 1\n                        \n    def percDown(self,i):\n        while (i * 2) <= self.currentSize:\n            mc = self.minChild(i)\n            if self.heapArray[i][0] > self.heapArray[mc][0]:\n                tmp = self.heapArray[i]\n                self.heapArray[i] = self.heapArray[mc]\n                self.heapArray[mc] = tmp\n            i = mc\n                \n    def minChild(self,i):\n        if i*2 > self.currentSize:\n            return -1\n        else:\n            if i*2 + 1 > self.currentSize:\n                return i*2\n            else:\n                if self.heapArray[i*2][0] < self.heapArray[i*2+1][0]:\n                    return i*2\n                else:\n                    return i*2+1\n\n    def percUp(self,i):\n        while i // 2 > 0:\n            if self.heapArray[i][0] < self.heapArray[i//2][0]:\n               tmp = self.heapArray[i//2]\n               self.heapArray[i//2] = self.heapArray[i]\n               self.heapArray[i] = tmp\n            i = i//2\n \n    def add(self,k):\n        self.heapArray.append(k)\n        self.currentSize = self.currentSize + 1\n        self.percUp(self.currentSize)\n\n    def delMin(self):\n        retval = self.heapArray[1][1]\n        self.heapArray[1] = self.heapArray[self.currentSize]\n        self.currentSize = self.currentSize - 1\n        self.heapArray.pop()\n        self.percDown(1)\n        return retval\n        \n    def isEmpty(self):\n        if self.currentSize == 0:\n            return True\n        else:\n            return False\n\n    def decreaseKey(self,val,amt):\n        # this is a little wierd, but we need to find the heap thing to decrease by\n        # looking at its value\n        done = False\n        i = 1\n        myKey = 0\n        while not done and i <= self.currentSize:\n            if self.heapArray[i][1] == val:\n                done = True\n                myKey = i\n            else:\n                i = i + 1\n        if myKey > 0:\n            self.heapArray[myKey] = (amt,self.heapArray[myKey][1])\n            self.percUp(myKey)\n            \n    def __contains__(self,vtx):\n        for pair in self.heapArray:\n            if pair[1] == vtx:\n                return True\n        return False\n        \nclass TestBinHeap(unittest.TestCase):\n    def setUp(self):\n        self.theHeap = PriorityQueue()\n        self.theHeap.add((2,\'x\'))\n        self.theHeap.add((3,\'y\'))\n        self.theHeap.add((5,\'z\'))\n        self.theHeap.add((6,\'a\'))\n        self.theHeap.add((4,\'d\'))\n\n\n    def testInsert(self):\n        assert self.theHeap.currentSize == 5\n\n    def testDelmin(self):\n        assert self.theHeap.delMin() == \'x\'\n        assert self.theHeap.delMin() == \'y\'\n    \n    def testDecKey(self):\n        self.theHeap.decreaseKey(\'d\',1)\n        assert self.theHeap.delMin() == \'d\'\n        \nif __name__ == \'__main__\':\n    unittest.main()\n',
    'src/lib/pythonds/__init__.py': '',
    'src/lib/cmath/__init__.js': 'var $builtinmodule = function(name)\n{\n  var mod = {};\n  Sk.builtin.defineComplex(mod, "complex");\n  return mod;\n};\n',
    'src/lib/pythonds/basic/deque.py': '# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n#deque.py\r\n\r\n\r\nclass Deque:\r\n    def __init__(self):\r\n        self.items = []\r\n\r\n    def isEmpty(self):\r\n        return self.items == []\r\n\r\n    def addFront(self, item):\r\n        self.items.append(item)\r\n\r\n    def addRear(self, item):\r\n        self.items.insert(0,item)\r\n\r\n    def removeFront(self):\r\n        return self.items.pop()\r\n\r\n    def removeRear(self):\r\n        return self.items.pop(0)\r\n\r\n    def size(self):\r\n        return len(self.items)\r\n',
    'src/lib/lorentz/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineLorentzian(mod, BLADE);\n  return mod;\n}\n',
    'src/lib/processing/__init__.js': 'var $builtinmodule = function(name)\n{\n    var mod = {};\n    var imList = [];\n    var looping = true;\n\n    // We need this to store a reference to the actual processing object which is not created\n    // until the run function is called.  Even then the processing object is passed by the\n    // processing-js sytem as a parameter to the sketchProc function.  Why not set it to None here\n    //\n\n    // See:  http://processingjs.org/reference/\n\n    mod.processing = null\n    mod.p = null\n\n    mod.CENTER = Sk.builtin.assk$(3, Sk.builtin.nmber.int$);\n    mod.RADIUS = Sk.builtin.assk$(2, Sk.builtin.nmber.int$);\n    mod.CORNERS = Sk.builtin.assk$(1, Sk.builtin.nmber.int$);\n    mod.CORNER = Sk.builtin.assk$(0, Sk.builtin.nmber.int$);\n    mod.RGB = Sk.builtin.assk$(1, Sk.builtin.nmber.int$);\n    mod.HSB = Sk.builtin.assk$(3, Sk.builtin.nmber.int$);\n    mod.CMYK = Sk.builtin.assk$(5, Sk.builtin.nmber.int$);\n    mod.MITER = new Sk.builtin.str(\'miter\');\n    mod.BEVEL = new Sk.builtin.str(\'bevel\');\n    mod.ROUND = new Sk.builtin.str(\'round\');\n    mod.SQUARE = new Sk.builtin.str(\'butt\');\n    mod.PROJECT = new Sk.builtin.str(\'square\');\n\n// 2D - Primitives\n    mod.line = new Sk.builtin.func(function(x1, y1, x2, y2) {\n        mod.processing.line(x1.v, y1.v, x2.v, y2.v);\n    });\n    \n    mod.ellipse = new Sk.builtin.func(function(x,y,r1,r2) {\n        mod.processing.ellipse(x.v,y.v,r1.v,r2.v)\n        \n    });\n\n    mod.point = new Sk.builtin.func(function(x1,y1) {\n        mod.processing.point(x1.v,y1.v)\n    });\n        \n    mod.arc = new Sk.builtin.func(function(x, y, width, height, start, stop) {\n        mod.processing.arc(x.v, y.v, width.v, height.v, start.v, stop.v)\n    });\n\n    mod.quad = new Sk.builtin.func(function(x1, y1, x2, y2, x3, y3, x4, y4) {\n        mod.processing.quad(x1.v, y1.v, x2.v, y2.v, x3.v, y3.v, x4.v, y4.v)\n    });\n            \n    mod.rect = new Sk.builtin.func(function(x, y, width, height, radius) {\n        if (typeof(radius) == \'undefined\') {\n            var rad = 0\n        } else {\n            var rad = radius.v\n        }\n        mod.processing.rect(x.v, y.v, width.v, height.v, rad)\n    });\n    \n    mod.triangle = new Sk.builtin.func(function(x1, y1, x2, y2, x3, y3) {\n            mod.processing.triangle(x1.v, y1.v, x2.v, y2.v, x3.v, y3.v)\n        });\n            \n\n    // 3D Primitives\n\n    // todo:  box, sphere, sphereDetail\n\n    // Color\n    mod.background = new Sk.builtin.func(function(r,g,b) {\n\n        if (typeof(g) !== \'undefined\')\n            g = g.v\n        if (typeof(b) !== \'undefined\')\n            b = b.v\n\n        mod.processing.background(r.v,g,b)\n        \n    });\n\n    mod.fill = new Sk.builtin.func(function(r,g,b) {\n        // r will be either:\n        //      a number in which case the fill will be grayscale\n        //      a color object\n        // g, and b may be undefined.  If they hold values it will\n        // be assumed that we have an r,g,b color tuple\n        if (typeof(g) !== \'undefined\')\n            g = g.v\n        if (typeof(b) !== \'undefined\')\n            b = b.v\n    \n        mod.processing.fill(r.v,g,b)\n        \n    });\n\n\n    mod.stroke = new Sk.builtin.func(function(r,g,b) {\n\n        if (typeof(g) !== \'undefined\')\n            g = g.v\n        if (typeof(b) !== \'undefined\')\n            b = b.v\n\n        mod.processing.stroke(r.v,g,b)\n        \n    });\n\n    mod.noStroke = new Sk.builtin.func(function() {\n        mod.processing.noStroke()\n    });\n    \n\n    mod.colorMode = new Sk.builtin.func(function(model, maxV) {\n        if (typeof(maxV) === \'undefined\')\n            maxV = 255\n        else\n            maxV = maxV.v\n        mod.processing.colorMode(model.v, maxV)\n    });\n\n    mod.noFill = new Sk.builtin.func(function() {\n            mod.processing.noFill()\n        });\n            \n\n    // Environment\n\n    mod.loop = new Sk.builtin.func(function() {\n            if (mod.processing === null) {\n                throw new Sk.builtin.Exception("Loop should be called in setup")\n            }\n            looping = true;\n            mod.processing.loop()\n        });\n            \n    mod.noLoop = new Sk.builtin.func(function() {\n        if (mod.processing === null) {\n            throw new Sk.builtin.Exception("noLoop should be called in setup")\n        }\n        looping = false;\n        mod.processing.noLoop()\n    });\n    \n    mod.frameRate = new Sk.builtin.func(function(fr) {\n        mod.processing.frameRate(fr.v)\n        \n    });\n\n    mod.size = new Sk.builtin.func(function(h,w) {\n        mod.processing.size(h.v,w.v)\n        \n    });\n\n    mod.exitp = new Sk.builtin.func(function(h,w) {\n        mod.processing.exit()\n    });\n\n\n    mod.mouseX = new Sk.builtin.func(function() {\n        return Sk.builtin.assk$(mod.processing.mouseX, Sk.builtin.nmber.int$);\n        \n    });\n\n    mod.mouseY = new Sk.builtin.func(function() {\n        return Sk.builtin.assk$(mod.processing.mouseY, Sk.builtin.nmber.int$);\n        \n    });\n\n    // Attributes\n    mod.rectMode = new Sk.builtin.func(function(mode) {\n        mod.processing.rectMode(mode.v)\n    });\n\n    mod.strokeWeight = new Sk.builtin.func(function(wt) {\n        mod.processing.strokeWeight(wt.v)\n        \n    });\n\n    mod.smooth = new Sk.builtin.func(function() {\n        mod.processing.smooth()\n    });\n\n    mod.noSmooth = new Sk.builtin.func(function() {\n        mod.processing.noSmooth()\n        });\n            \n    mod.ellipseMode = new Sk.builtin.func(function(mode) {\n        mod.processing.ellipseMode(mode.v)\n        });\n\n    mod.strokeCap = new Sk.builtin.func(function(mode) {\n        mod.processing.strokeCap(mode.v)\n        });\n\n    mod.strokeJoin = new Sk.builtin.func(function(mode) {\n        mod.processing.strokeJoin(mode.v)\n    });\n    \n\n\n    // Transforms\n\n    mod.rotate = new Sk.builtin.func(function(rads) {\n        // rotation in radians\n        mod.processing.rotate(rads.v)\n        \n    });\n\n    mod.scale = new Sk.builtin.func(function(sx, sy, sz) {\n        if (typeof(sy) == \'undefined\') {\n            sy = 1.0\n        } else \n            sy = sy.v\n        if (typeof(sz) == \'undefined\') {\n            sz = 1.0\n        } else\n            sz = sz.v\n        mod.processing.scale(sx.v, sy, sz)\n    });\n\n    mod.translate = new Sk.builtin.func(function(sx, sy, sz) {\n        if (typeof(sy) == \'undefined\') {\n            sy = 1.0\n        } else \n            sy = sy.v\n        if (typeof(sz) == \'undefined\') {\n            sz = 1.0\n        } else\n            sz = sz.v\n        mod.processing.translate(sx.v, sy, sz)\n    });\n\n    // todo:  applyMatrix, popMatrix, printMatrix??, pushMatrix, resetMatrix, rotate{X,Y,Z}\n    \n\n    //  //////////////////////////////////////////////////////////////////////\n    //  Run\n    // \n    //  Create the processing context and setup of calls to setup, draw etc.\n    //\n    //\n    //  //////////////////////////////////////////////////////////////////////    \n    mod.run = new Sk.builtin.func(function() {\n        function sketchProc(processing) {\n            mod.processing = processing\n\n            // processing.setup = function() {\n            //     if Sk.globals[\'setup\']\n            //         Sk.misceval.callsim(Sk.globals[\'setup\'])\n            // }\n\n            \n            processing.draw = function() {\n                // if there are pending image loads then just use the natural looping calls to \n                // retry until all the images are loaded.  If noLoop was called in setup then make\n                // sure to revert to that after all the images in hand.\n                var wait = false\n                for (var i in imList) {\n                    if (imList[i].width == 0) {\n                        wait = true\n                    }\n                }\n                if (wait == true) {\n                    if (looping == true) \n                        return\n                    else {\n                        processing.loop()\n                        return\n                    }\n\n                } else {\n                    if (looping == false)\n                        processing.noLoop()\n                }\n\n                mod.frameCount = processing.frameCount  \n                if (Sk.globals[\'draw\'])\n                    Sk.misceval.callsim(Sk.globals[\'draw\'])\n            }\n            \n            var callBacks = [\'setup\', \'mouseMoved\',\'mouseClicked\', \'mouseDragged\', \'mouseMoved\', \'mouseOut\',\n             \'mouseOver\', \'mousePressed\', \'mouseReleased\', \'keyPressed\', \'keyReleased\', \'keyTyped\'\n             ];\n\n             for(var cb in callBacks) {\n                if (Sk.globals[callBacks[cb]]) {\n                    console.log(\'defining \' + callBacks[cb])                    \n                    processing[callBacks[cb]] = new Function("Sk.misceval.callsim(Sk.globals[\'"+callBacks[cb]+"\']);")\n                }\n            }\n        }\n        \n        var canvas = document.getElementById(Sk.canvas)\n        $(canvas).show()\n        mod.p = new Processing(canvas, sketchProc)\n\n        \n    });\n\n    var mouseClass = function($gbl, $loc) {\n\n        $loc.__getattr__ = new Sk.builtin.func(function(self,key) {\n            if (key == \'x\') \n                return mod.processing.mouseX;\n            else if (key == \'y\') \n                return mod.processing.mouseY;\n            else if (key == \'px\')\n                return mod.processing.pmouseX;\n            else if (key == \'py\')\n                return mod.processing.pmouseY;\n            else if (key == \'pressed\')\n                return mod.processing.mousePressed;\n            else if (key == \'button\')\n                return mod.processing.mouseButton\n        });\n\n\n    }\n\n\n    mod.Mouse = Sk.misceval.buildClass(mod, mouseClass, \'Mouse\', []);\n\n    mod.mouse = Sk.misceval.callsim(mod.Mouse)\n\n    var keyboardClass = function($gbl, $loc) {\n\n        $loc.__getattr__ = new Sk.builtin.func(function(self,key) {\n            if (key == \'key\') {\n                console.log(mod.processing.key)\n                return new Sk.builtin.str(mod.processing.key.toString())\n            }\n            else if (key == \'keyCode\') \n                return mod.processing.keyCode\n            else if (key == \'keyPressed\')\n                return new Sk.builtin.str(mod.processing.keyPressed) // todo bool\n        });\n\n\n    }\n\n    mod.Keyboard = Sk.misceval.buildClass(mod,keyboardClass,\'Keyboard\', [])\n\n    mod.keyboard = Sk.misceval.callsim(mod.Keyboard)\n\n\n\n    var environmentClass = function($gbl, $loc) {\n\n        $loc.__getattr__ = new Sk.builtin.func(function(self,key) {\n            if (key == \'frameCount\') \n                return mod.processing.frameCount\n            else if (key == \'frameRate\') \n                return mod.processing.frameRate\n            else if (key == \'height\')\n                return mod.processing.height\n            else if (key == \'width\')\n                return mod.processing.width\n            else if (key == \'online\')\n                return mod.processing.online\n            else if (key == \'focused\')\n                return mod.processing.focused\n        });\n\n\n    }\n\n    mod.Environment = Sk.misceval.buildClass(mod,environmentClass,\'Environment\', [])\n\n    mod.environment = Sk.misceval.callsim(mod.Environment)\n\n    var screenClass = function($gbl, $loc) {\n\n        $loc.__init__ = new Sk.builtin.func(function(self) {\n            self.pixels = null;\n        });\n\n        $loc.__getattr__ = new Sk.builtin.func(function(self,key) {\n            if (key == \'height\')\n                return mod.processing.height\n            else if (key == \'width\')\n                return mod.processing.width\n            else if (key == \'pixels\')\n                if (self.pixels == null) {\n                    self.pixels = new Sk.builtin.list(mod.processing.pixels.toArray())\n                }\n                return self.pixels\n        });\n\n    }\n\n    mod.Screen = Sk.misceval.buildClass(mod,screenClass,\'Screen\', [])\n\n    mod.screen = Sk.misceval.callsim(mod.Screen)\n\n    mod.loadPixels = new Sk.builtin.func(function() {\n        mod.processing.loadPixels()\n        console.log(mod.processing.pixels)\n    });\n    \n\n    var colorClass = function($gbl, $loc) {\n        /* images are loaded async.. so its best to preload them */\n        $loc.__init__ = new Sk.builtin.func(function(self, val1, val2, val3, alpha) {\n            if (typeof(val2) !== \'undefined\')\n                val2 = val2.v\n            if (typeof(val3) !== \'undefined\')\n                val3 = val3.v\n            if (typeof(alpha) !== \'undefined\')\n                alpha = alpha.v\n            self.v = mod.processing.color(val1.v, val2, val3, alpha)\n        })\n    \n    }\n\n    mod.color = Sk.misceval.buildClass(mod,colorClass,\'color\', [])\n\n    mod.red = new Sk.builtin.func(function(clr) {\n        return Sk.builtin.assk$(mod.processing.red(clr.v), Sk.builtin.nmber.int$);\n    });\n    \n    mod.green = new Sk.builtin.func(function(clr) {\n        return Sk.builtin.assk$(mod.processing.green(clr.v), Sk.builtin.nmber.int$);\n    });\n\n    mod.blue = new Sk.builtin.func(function(clr) {\n        return Sk.builtin.assk$(mod.processing.blue(clr.v), Sk.builtin.nmber.int$);\n    });\n\n    // Image class and functions\n    //\n    var imageClass = function($gbl, $loc) {\n        /* images are loaded async.. so its best to preload them */\n        $loc.__init__ = new Sk.builtin.func(function(self,im) {\n            self.v = im\n            self.width = Sk.builtin.assk$(im.width, Sk.builtin.nmber.int$);\n            self.height = Sk.builtin.assk$(im.height, Sk.builtin.nmber.int$);\n        })\n\n        $loc.__getattr__ = new Sk.builtin.func(function(self,key) {\n            if (key == \'width\') return self.v.width;\n            if (key == \'height\') return self.v.height;\n        });\n    \n    }\n\n    mod.PImage = Sk.misceval.buildClass(mod,imageClass,\'PImage\', [])\n\n    mod.loadImage = new Sk.builtin.func(function(imfile) {\n        var i = mod.processing.loadImage(imfile.v);\n        imList.push(i);\n        return Sk.misceval.callsim(mod.PImage,i);\n    });\n    \n\n    mod.image = new Sk.builtin.func(function(im,x,y) {\n        if (im.v.width > 0)\n            mod.processing.image(im.v,x.v,y.v,im.v.width,im.v.height)\n    });\n\n    mod.get = new Sk.builtin.func(function(x,y) {\n        var clr = mod.processing.get(x.v,y.v)\n        return Sk.misceval.callsim(mod.color,\n            Sk.builtin.assk$(mod.processing.red(clr), Sk.builtin.nmber.int$),\n            Sk.builtin.assk$(mod.processing.green(clr), Sk.builtin.nmber.int$),\n            Sk.builtin.assk$(mod.processing.blue(clr), Sk.builtin.nmber.int$));\n    });\n\n    mod.set = new Sk.builtin.func(function(x, y, color) {\n        mod.processing.set(x.v, y.v, color.v)\n    });\n    \n// todo  -- add a color class for creating color objects.\n\n\n    return mod;\n}\n',
    'src/lib/webgl/models.js': '// most of this file is from/based on \'tdl\'\n\nvar $builtinmodule = function(name)\n{\n    var mod = {};\n\n    var Buffer = function(array, opt_target) {\n        var target = opt_target || gl.ARRAY_BUFFER;\n        var buf = gl.createBuffer();\n        this.target = target;\n        this.buf = buf;\n        this.set(array);\n        this.numComponents_ = array.numComponents;\n        this.numElements_ = array.numElements;\n        this.totalComponents_ = this.numComponents_ * this.numElements_;\n        if (array.buffer instanceof Float32Array) {\n            this.type_ = gl.FLOAT;\n        } else if (array.buffer instanceof Uint8Array) {\n            this.type_ = gl.UNSIGNED_BYTE;\n        } else if (array.buffer instanceof Int8Array) {\n            this.type_ = gl._BYTE;\n        } else if (array.buffer instanceof Uint16Array) {\n            this.type_ = gl.UNSIGNED_SHORT;\n        } else if (array.buffer instanceof Int16Array) {\n            this.type_ = gl.SHORT;\n        } else {\n            throw("unhandled type:" + (typeof array.buffer));\n        }\n    };\n\n    Buffer.prototype.set = function(array) {\n        gl.bindBuffer(this.target, this.buf);\n        gl.bufferData(this.target, array.buffer, gl.STATIC_DRAW);\n    }\n\n    Buffer.prototype.type = function() {\n        return this.type_;\n    };\n\n    Buffer.prototype.numComponents = function() {\n        return this.numComponents_;\n    };\n\n    Buffer.prototype.numElements = function() {\n        return this.numElements_;\n    };\n\n    Buffer.prototype.totalComponents = function() {\n        return this.totalComponents_;\n    };\n\n    Buffer.prototype.buffer = function() {\n        return this.buf;\n    };\n\n    Buffer.prototype.stride = function() {\n        return 0;\n    };\n\n    Buffer.prototype.offset = function() {\n        return 0;\n    };\n\n\n\n    mod.Model = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self, shader, arrays, textures)\n                    {\n                        self.buffers = {};\n                        var setBuffer = function(name, array)\n                        {\n                            var target = (name == \'indices\') ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;\n                            b = self.buffers[name];\n                            if (!b)\n                                b = new Buffer(array, target);\n                            else\n                                b.set(array);\n                            self.buffers[name] = b;\n                        };\n                        for (name in arrays)\n                            setBuffer(name, arrays[name]);\n\n                        var textureUnits = {};\n                        var unit = 0;\n                        for (var texture in textures)\n                        {\n                            textureUnits[texture] = unit++;\n                        }\n\n                        self.mode = gl.TRIANGLES;\n                        self.textures = textures.v;\n                        self.textureUnits = textureUnits;\n                        self.shader = shader;\n                    });\n\n                /**\n                * Sets up the shared parts of drawing this model. Uses the\n                * program, binds the buffers, sets the textures.\n                *\n                * @param {!Object.<string, *>} uniforms An object of names to\n                *     values to set on this models uniforms.\n                */\n                $loc.drawPrep = new Sk.builtin.func(function(self, uniforms)\n                    {\n                        var shader = self.shader;\n                        var buffers = self.buffers;\n                        var textures = self.textures;\n\n                        uniforms = Sk.ffi.remapToJs(uniforms);\n\n                        Sk.misceval.callsim(shader.use, shader);\n\n                        for (var buffer in buffers) {\n                            var b = buffers[buffer];\n                            if (buffer == \'indices\') {\n                                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, b.buffer());\n                            } else {\n                                var attrib = shader.attrib[buffer];\n                                if (attrib) {\n                                    attrib(b);\n                                }\n                            }\n                        }\n\n                        for (var texture in textures) {\n                            var unit = self.textureUnits[texture];\n                            shader.setUniform$impl(shader, textuer, unit);\n                            textures[texture].bindToUnit(unit);\n                        }\n\n                        for (var uniform in uniforms) {\n                            shader.setUniform$impl(shader, uniform, uniforms[uniform]);\n                        }\n                    });\n\n                /**\n                * Draws this model.\n                *\n                * After calling tdl.models.Model.drawPrep you can call this\n                * function multiple times to draw this model.\n                *\n                * @param {!Object.<string, *>} uniforms An object of names to\n                *     values to set on this models uniforms.\n                */\n                $loc.draw = new Sk.builtin.func(function(self, uniforms, opt_textures)\n                    {\n                        var shader = self.shader;\n                        uniforms = Sk.ffi.remapToJs(uniforms);\n                        for (uniform in uniforms) {\n                            shader.setUniform$impl(shader, uniform, uniforms[uniform]);\n                        }\n\n                        if (opt_textures) {\n                            for (var texture in opt_textures) {\n                                var unit = self.textureUnits[texture];\n                                shader.setUniform$impl(shader, texture, unit);\n                                opt_textures[texture].bindToUnit(unit);\n                            }\n                        }\n\n                        var buffers = self.buffers;\n                        gl.drawElements(self.mode, buffers.indices.totalComponents(), gl.UNSIGNED_SHORT, 0);\n                    });\n            },\n            \'Model\', []);\n\n    return mod;\n};\n',
    'src/lib/pythonds/trees/__init__.py': '\n# from .binaryTree import BinaryTree\n# from .balance import AVLTree\n# from .bst import BinarySearchTree\n# from .binheap import BinHeap\n\n\n',
    'src/lib/pythonds/trees/binaryTree.py': '# Bradley N. Miller, David L. Ranum\n# Introduction to Data Structures and Algorithms in Python\n# Copyright 2005\n# \n\nclass BinaryTree:\n    """\n    A recursive implementation of Binary Tree\n    Using links and Nodes approach.\n    """    \n    def __init__(self,rootObj):\n        self.key = rootObj\n        self.leftChild = None\n        self.rightChild = None\n\n    def insertLeft(self,newNode):\n        if self.leftChild == None:\n            self.leftChild = BinaryTree(newNode)\n        else:\n            t = BinaryTree(newNode)\n            t.left = self.leftChild\n            self.leftChild = t\n    \n    def insertRight(self,newNode):\n        if self.rightChild == None:\n            self.rightChild = BinaryTree(newNode)\n        else:\n            t = BinaryTree(newNode)\n            t.right = self.rightChild\n            self.rightChild = t\n\n    def isLeaf(self):\n        return ((not self.leftChild) and (not self.rightChild))\n\n    def getRightChild(self):\n        return self.rightChild\n\n    def getLeftChild(self):\n        return self.leftChild\n\n    def setRootVal(self,obj):\n        self.key = obj\n\n    def getRootVal(self,):\n        return self.key\n\n    def inorder(self):\n        if self.leftChild:\n            self.leftChild.inorder()\n        print(self.key)\n        if self.rightChild:\n            self.rightChild.inorder()\n\n    def postorder(self):\n        if self.leftChild:\n            self.leftChild.postorder()\n        if self.rightChild:\n            self.rightChild.postorder()\n        print(self.key)\n\n\n    def preorder(self):\n        print(self.key)\n        if self.leftChild:\n            self.leftChild.preorder()\n        if self.rightChild:\n            self.rightChild.preorder()\n\n    def printexp(self):\n        if self.leftChild:\n            print(\'(\')\n            self.leftChild.printexp()\n        print(self.key)\n        if self.rightChild:\n            self.rightChild.printexp()\n            print(\')\')\n\n    def postordereval(self):\n        opers = {\'+\':operator.add, \'-\':operator.sub, \'*\':operator.mul, \'/\':operator.truediv}\n        res1 = None\n        res2 = None\n        if self.leftChild:\n            res1 = self.leftChild.postordereval()  #// \\label{peleft}\n        if self.rightChild:\n            res2 = self.rightChild.postordereval() #// \\label{peright}\n        if res1 and res2:\n            return opers[self.key](res1,res2) #// \\label{peeval}\n        else:\n            return self.key\n\ndef inorder(tree):\n    if tree != None:\n        inorder(tree.getLeftChild())\n        print(tree.getRootVal())\n        inorder(tree.getRightChild())\n\ndef printexp(tree):\n    if tree.leftChild:\n        print(\'(\')\n        printexp(tree.getLeftChild())\n    print(tree.getRootVal())\n    if tree.rightChild:\n        printexp(tree.getRightChild())\n        print(\')\') \n\ndef printexp(tree):\n    sVal = ""\n    if tree:\n        sVal = \'(\' + printexp(tree.getLeftChild())\n        sVal = sVal + str(tree.getRootVal())\n        sVal = sVal + printexp(tree.getRightChild()) + \')\'\n    return sVal\n\ndef postordereval(tree):\n    opers = {\'+\':operator.add, \'-\':operator.sub, \'*\':operator.mul, \'/\':operator.truediv}\n    res1 = None\n    res2 = None\n    if tree:\n        res1 = postordereval(tree.getLeftChild())  #// \\label{peleft}\n        res2 = postordereval(tree.getRightChild()) #// \\label{peright}\n        if res1 and res2:\n            return opers[tree.getRootVal()](res1,res2) #// \\label{peeval}\n        else:\n            return tree.getRootVal()\n\ndef height(tree):\n    if tree == None:\n        return -1\n    else:\n        return 1 + max(height(tree.leftChild),height(tree.rightChild))\n\n# t = BinaryTree(7)\n# t.insertLeft(3)\n# t.insertRight(9)\n# inorder(t)\n# import operator\n# x = BinaryTree(\'*\')\n# x.insertLeft(\'+\')\n# l = x.getLeftChild()\n# l.insertLeft(4)\n# l.insertRight(5)\n# x.insertRight(7)\n# print(printexp(x))\n# print(postordereval(x))\n# print(height(x))\n',
    'src/lib/math/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineMath(mod);\n  return mod;\n};',
    'src/lib/e3ga/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineEuclidean3(mod, THREE, BLADE);\n  return mod;\n}\n',
    'src/lib/webgl/primitives.js': '// most of this file is from \'tdl\'\n\nvar $builtinmodule = function(name)\n{\n    var mod = {};\n\n\n\n    /**\n     * AttribBuffer manages a TypedArray as an array of vectors.\n     *\n     * @param {number} numComponents Number of components per\n     *     vector.\n     * @param {number|!Array.<number>} numElements Number of vectors or the data.\n     * @param {string} opt_type The type of the TypedArray to\n     *     create. Default = \'Float32Array\'.\n     * @param {!Array.<number>} opt_data The data for the array.\n     */\n    var AttribBuffer = function(\n            numComponents, numElements, opt_type) {\n        opt_type = opt_type || \'Float32Array\';\n        var type = window[opt_type];\n        if (numElements.length) {\n            this.buffer = new type(numElements);\n            numElements = this.buffer.length / numComponents;\n            this.cursor = numElements;\n        } else {\n            this.buffer = new type(numComponents * numElements);\n            this.cursor = 0;\n        }\n        this.numComponents = numComponents;\n        this.numElements = numElements;\n        this.type = opt_type;\n    };\n\n    AttribBuffer.prototype.stride = function() {\n        return 0;\n    };\n\n    AttribBuffer.prototype.offset = function() {\n        return 0;\n    };\n\n    AttribBuffer.prototype.getElement = function(index) {\n        var offset = index * this.numComponents;\n        var value = [];\n        for (var ii = 0; ii < this.numComponents; ++ii) {\n            value.push(this.buffer[offset + ii]);\n        }\n        return value;\n    };\n\n    AttribBuffer.prototype.setElement = function(index, value) {\n        var offset = index * this.numComponents;\n        for (var ii = 0; ii < this.numComponents; ++ii) {\n            this.buffer[offset + ii] = value[ii];\n        }\n    };\n\n    AttribBuffer.prototype.clone = function() {\n        var copy = new AttribBuffer(\n                this.numComponents, this.numElements, this.type);\n        copy.pushArray(this);\n        return copy;\n    }\n\n    AttribBuffer.prototype.push = function(value) {\n        this.setElement(this.cursor++, value);\n    };\n\n    AttribBuffer.prototype.pushArray = function(array) {\n        //  this.buffer.set(array, this.cursor * this.numComponents);\n        //  this.cursor += array.numElements;\n        for (var ii = 0; ii < array.numElements; ++ii) {\n            this.push(array.getElement(ii));\n        }\n    };\n\n    AttribBuffer.prototype.pushArrayWithOffset =\n    function(array, offset) {\n        for (var ii = 0; ii < array.numElements; ++ii) {\n            var elem = array.getElement(ii);\n            for (var jj = 0; jj < offset.length; ++jj) {\n                elem[jj] += offset[jj];\n            }\n            this.push(elem);\n        }\n    };\n\n    /**\n    * Computes the extents\n    * @param {!AttribBuffer} positions The positions\n    * @return {!{min: !tdl.math.Vector3, max:!tdl.math.Vector3}}\n    *     The min and max extents.\n    */\n    AttribBuffer.prototype.computeExtents = function() {\n        var numElements = this.numElements;\n        var numComponents = this.numComponents;\n        var minExtent = this.getElement(0);\n        var maxExtent = this.getElement(0);\n        for (var ii = 1; ii < numElements; ++ii) {\n            var element = this.getElement(ii);\n            for (var jj = 0; jj < numComponents; ++jj) {\n                minExtent[jj] = Math.min(minExtent[jj], element[jj]);\n                maxExtent[jj] = Math.max(maxExtent[jj], element[jj]);\n            }\n        }\n        return {min: minExtent, max: maxExtent};\n    };\n\n\n    /**\n     * Creates the vertices and indices for a cube. The\n     * cube will be created around the origin. (-size / 2, size / 2)\n     *\n     * @param {number} size Width, height and depth of the cube.\n     * @return {!Object.<string, !tdl.primitives.AttribBuffer>} The\n     *         created plane vertices.\n     */\n    mod.createCube = new Sk.builtin.func(function(size)\n            {\n                var CUBE_FACE_INDICES_ = [\n                    [3, 7, 5, 1],\n                    [0, 4, 6, 2],\n                    [6, 7, 3, 2],\n                    [0, 1, 5, 4],\n                    [5, 7, 6, 4],\n                    [2, 3, 1, 0]\n                ];\n\n                var k = size / 2;\n\n                var cornerVertices = [\n                        [-k, -k, -k],\n                        [+k, -k, -k],\n                        [-k, +k, -k],\n                        [+k, +k, -k],\n                        [-k, -k, +k],\n                        [+k, -k, +k],\n                        [-k, +k, +k],\n                        [+k, +k, +k]\n                    ];\n\n                var faceNormals = [\n                        [+1, +0, +0],\n                        [-1, +0, +0],\n                        [+0, +1, +0],\n                        [+0, -1, +0],\n                        [+0, +0, +1],\n                        [+0, +0, -1]\n                    ];\n\n                var uvCoords = [\n                        [0, 0],\n                        [1, 0],\n                        [1, 1],\n                        [0, 1]\n                    ];\n\n                var numVertices = 6 * 4;\n                var positions = new AttribBuffer(3, numVertices);\n                var normals = new AttribBuffer(3, numVertices);\n                var texCoords = new AttribBuffer(2, numVertices);\n                var indices = new AttribBuffer(3, 6 * 2, \'Uint16Array\');\n\n                for (var f = 0; f < 6; ++f) {\n                    var faceIndices = CUBE_FACE_INDICES_[f];\n                    for (var v = 0; v < 4; ++v) {\n                        var position = cornerVertices[faceIndices[v]];\n                        var normal = faceNormals[f];\n                        var uv = uvCoords[v];\n\n                        // Each face needs all four vertices because the normals and texture\n                        // coordinates are not all the same.\n                        positions.push(position);\n                        normals.push(normal);\n                        texCoords.push(uv);\n\n                    }\n                    // Two triangles make a square face.\n                    var offset = 4 * f;\n                    indices.push([offset + 0, offset + 1, offset + 2]);\n                    indices.push([offset + 0, offset + 2, offset + 3]);\n                }\n\n                return {\n                        position: positions,\n                        normal: normals,\n                        texCoord: texCoords,\n                        indices: indices\n                };\n            });\n\n    return mod;\n};\n',
    'src/lib/document/__init__.js': 'var $builtinmodule = function(name) {\n    var mod = {};\n\n    mod.getElementById = new Sk.builtin.func(function(id) {\n        var result = document.getElementById(id.v);\n        if (result) {\n            return Sk.misceval.callsim(mod.Element,result);\n        }\n        return Sk.builtin.none.none$;\n    });\n\n    mod.createElement = new Sk.builtin.func(function(eName) {\n            var r = document.createElement(eName.v);\n            if (r) {\n                return Sk.misceval.callsim(mod.Element,r);\n            }\n        });\n\n\n    mod.getElementsByTagName = new Sk.builtin.func(function(tag) {\n        var r = document.getElementsByTagName(tag.v)\n        var reslist = [];\n        for (var i = r.length - 1; i >= 0; i--) {\n            reslist.push(Sk.misceval.callsim(mod.Element,r[i]))\n        }\n        return new Sk.builtin.list(reslist)\n    });\n\n    mod.getElementsByClassName = new Sk.builtin.func(function(cname) {\n        var r = document.getElementsByClassName(cname.v);\n        var reslist = [];\n        for (var i = 0; i < r.length; i++) {\n            reslist.push(Sk.misceval.callsim(mod.Element,r[i]));\n        };\n        return new Sk.builtin.list(reslist);\n    });\n    \n    mod.getElementsByName = new Sk.builtin.func(function(cname) {\n        var r = document.getElementsByName(cname.v);\n        var reslist = [];\n        for (var i = 0; i < r.length; i++) {\n            reslist.push(Sk.misceval.callsim(mod.Element,r[i]));\n        };\n        return new Sk.builtin.list(reslist);\n    });\n        \n    mod.currentDiv = new Sk.builtin.func(function() {\n        if (Sk.divid !== undefined) {\n            return new Sk.builtin.str(Sk.divid)\n        }\n        else {\n            throw new Sk.builtin.AttributeError("There is no value set for divid");\n        }\n    })\n    var elementClass = function($gbl, $loc) {\n        /*\n            Notes:  self[\'$d\'] is the dictionary used by the GenericGetAttr mechanism for an object.\n                    for various reasons  if you create a class in Javascript and have self.xxxx instance\n                    variables, you cannot say instance.xxx and get the value of the instance variable unless \n                    it is stored in the self[\'$d\'] object.  This seems like a duplication of storage to me\n                    but that is how it works right now  (5/2013)\n\n                    Writing your own __getattr__ is also an option but this gets very tricky when an attr is \n                    a method...\n        */\n        $loc.__init__ = new Sk.builtin.func(function(self,elem) {\n            self.v = elem\n            self.innerHTML = elem.innerHTML\n            self.innerText = elem.innerText\n            if (elem.value !== undefined) {\n                self.value = elem.value\n                Sk.abstr.objectSetItem(self[\'$d\'], new Sk.builtin.str(\'value\'), new Sk.builtin.str(self.value))                \n            }\n\n            if (elem.checked !== undefined) {\n                self.checked = elem.checked\n                Sk.abstr.objectSetItem(self[\'$d\'], new Sk.builtin.str(\'checked\'), new Sk.builtin.str(self.checked))                \n            }\n\n            Sk.abstr.objectSetItem(self[\'$d\'], new Sk.builtin.str(\'innerHTML\'), new Sk.builtin.str(self.innerHTML))\n            Sk.abstr.objectSetItem(self[\'$d\'], new Sk.builtin.str(\'innerText\'), new Sk.builtin.str(self.innerText))            \n\n        })\n\n        $loc.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;\n\n        $loc.__setattr__ = new Sk.builtin.func(function(self,key,value) {\n            if (key === \'innerHTML\') {\n                self.innerHTML = value\n                self.v.innerHTML = value.v\n                Sk.abstr.objectSetItem(self[\'$d\'], new Sk.builtin.str(\'innerHTML\'), value)                \n            }\n            if (key === \'innerText\') {\n                self.innerText = value\n                self.v.innerText = value.v\n                Sk.abstr.objectSetItem(self[\'$d\'], new Sk.builtin.str(\'innerText\'), value)            \n            }\n        });\n\n\n        $loc.appendChild = new Sk.builtin.func(function(self,ch) {\n            self.v.appendChild(ch.v);\n        });\n\n        $loc.removeChild = new Sk.builtin.func(function(self,node) {\n            self.v.removeChild(node.v)\n        })\n\n        // getCSS\n                    \n        $loc.getCSS = new Sk.builtin.func(function(self,key) {\n            return new Sk.builtin.str(self.v.style[key.v]);\n        });\n    \n\n        $loc.setCSS = new Sk.builtin.func(function(self,attr,value) {\n            self.v.style[attr.v] = value.v\n\n        })\n\n        $loc.getAttribute = new Sk.builtin.func(function(self,key) {\n            var res = self.v.getAttribute(key.v)\n            if (res) {\n                return new Sk.builtin.str(res)\n            } else {\n                return Sk.builtin.none.none$;\n            }\n        });\n\n        $loc.setAttribute = new Sk.builtin.func(function(self,attr,value) {\n                self.v.setAttribute(attr.v,value.v)\n        });\n            \n\n        $loc.__str__ = new Sk.builtin.func(function(self) {\n            console.log(self.v.tagName);\n            return new Sk.builtin.str(self.v.tagName)\n        })\n\n        $loc.__repr__ = new Sk.builtin.func(function(self) {\n            return new Sk.builtin.str(\'[DOM Element]\')\n        })\n\n    \n    };\n\n    mod.Element = Sk.misceval.buildClass(mod,elementClass,\'Element\', []);\n\n    return mod;\n\n}   ',
    'src/lib/re/__init__.js': 'var $builtinmodule = function(name)\n{\n    var mod = {};\n\n    // Constants (mostly unsupported)\n    mod.I = 2;\n    mod.IGNORECASE = 2;\n    // mod.L = 4;\n    // mod.LOCALE = 4;\n    mod.M = 8;\n    mod.MULTILINE = 8;\n    // mod.S = 16;\n    // mod.DOTALL = 16;\n    // mod.U = 32;\n    // mod.UNICODE = 32;\n    // mod.X = 64;\n    // mod.VERBOSE = 64;\n\n    var validGroups = ["(?:", "(?=", "(?!"];\n\n    var convert = function(pattern) {\n        var newpattern;\n        var match;\n        var i;\n\n        // Look for disallowed constructs\n        match = pattern.match(/\\(\\?./g);\n        if (match) {\n            for (i=0; i<match.length; i++) {\n                if (validGroups.indexOf(match[i]) == -1) {\n                    throw new Sk.builtin.ValueError("Disallowed group in pattern: \'"\n                                                    + match[i] + "\'");\n                };\n            };\n        };\n\n        newpattern = pattern.replace(\'/\\\\/g\', \'\\\\\\\\\');\n        newpattern = pattern.replace(/([^\\\\]){,(?![^\\[]*\\])/g, \'$1{0,\');\n\n        return newpattern;\n    };\n\n    var getFlags = function(flags) {\n        var jsflags = "g";\n        if ((flags & mod.IGNORECASE) == mod.IGNORECASE) {\n            jsflags += "i";\n        };\n        if ((flags & mod.MULTILINE) == mod.MULTILINE) {\n            jsflags += "m";\n        }; \n        return jsflags;\n    };\n\n    mod.split = Sk.nativejs.func(function split(pattern, string, maxsplit, flags) {\n        Sk.builtin.pyCheckArgs("split", arguments, 2, 4);\n        if (!Sk.builtin.checkString(pattern)) {\n            throw new Sk.builtin.TypeError("pattern must be a string");\n        };\n        if (!Sk.builtin.checkString(string)) {\n            throw new Sk.builtin.TypeError("string must be a string");\n        };\n        if (maxsplit === undefined) {\n            maxsplit = 0;\n        };\n        if (!Sk.builtin.checkNumber(maxsplit)) {\n            throw new Sk.builtin.TypeError("maxsplit must be a number");\n        };\n        if (flags === undefined) {\n            flags = 0;\n        };\n        if (!Sk.builtin.checkNumber(flags)) {\n            throw new Sk.builtin.TypeError("flags must be a number");\n        };\n\n\tmaxsplit = Sk.builtin.asnum$(maxsplit);\n        var pat = Sk.ffi.unwrapo(pattern);\n        var str = Sk.ffi.unwrapo(string);\n        \n        // Convert pat from Python to Javascript regex syntax\n        pat = convert(pat);\n        //print("Pat: " + pat);\n        //print("Str: " + str);\n\n        var captured = !(pat.match(/^\\(.*\\)$/) === null);\n        //print("Captured: ", captured);\n\n        var jsflags = getFlags(flags);\n        //print("Flags: ", jsflags);\n\n        var regex = new RegExp(pat, jsflags);\n\n        var result = [];\n        var match;\n        var index = 0;\n        var splits = 0;\n        while ((match = regex.exec(str)) != null) {\n            //print("Matched \'" + match[0] + "\' at position " + match.index + \n            //      "; next search at " + regex.lastIndex);\n            if (match.index === regex.lastIndex) {\n                // empty match\n                break;\n            };\n            result.push(new Sk.builtin.str(str.substring(index, match.index)));\n            if (captured) {\n                // Add matching pattern, too\n                result.push(new Sk.builtin.str(match[0]));\n            };\n            index = regex.lastIndex;\n            splits += 1;\n            if (maxsplit && (splits >= maxsplit)) {\n                break;\n            };\n        };\n        result.push(new Sk.builtin.str(str.substring(index)));\n\n        return new Sk.builtin.list(result);\n    });\n\n    mod.findall = Sk.nativejs.func(function findall(pattern, string, flags) {\n        Sk.builtin.pyCheckArgs("findall", arguments, 2, 3);\n        if (!Sk.builtin.checkString(pattern)) {\n            throw new Sk.builtin.TypeError("pattern must be a string");\n        };\n        if (!Sk.builtin.checkString(string)) {\n            throw new Sk.builtin.TypeError("string must be a string");\n        };\n        if (flags === undefined) {\n            flags = 0;\n        };\n        if (!Sk.builtin.checkNumber(flags)) {\n            throw new Sk.builtin.TypeError("flags must be a number");\n        };\n\n        var pat = Sk.ffi.unwrapo(pattern);\n        var str = Sk.ffi.unwrapo(string);\n        \n        // Convert pat from Python to Javascript regex syntax\n        pat = convert(pat);\n        //print("Pat: " + pat);\n        //print("Str: " + str);\n\n        var jsflags = getFlags(flags);\n        //print("Flags: ", jsflags);\n\n        var regex = new RegExp(pat, jsflags);\n\n\tvar newline_at_end = new RegExp(/\\n$/);\n\tif (str.match(newline_at_end)) {\n\t    str = str.slice(0,-1);\n\t}\n\n        var result = [];\n        var match;\n        while ((match = regex.exec(str)) != null) {\n            //print("Matched \'" + match[0] + "\' at position " + match.index + \n            //      "; next search at " + regex.lastIndex);\n            // print("match: " + JSON.stringify(match));\n            if (match.length < 2) {\n                result.push(new Sk.builtin.str(match[0]));\n            } else if (match.length == 2) {\n                result.push(new Sk.builtin.str(match[1]));\n            } else {\n                var groups = [];\n                for (var i=1; i<match.length; i++) {\n                    groups.push(new Sk.builtin.str(match[i]));  \n                };\n                result.push(new Sk.builtin.tuple(groups));\n            };\n            if (match.index === regex.lastIndex) {\n                regex.lastIndex += 1;\n            };\n        };\n\n        return new Sk.builtin.list(result);\n    });\n\n\n    var matchobj = function($gbl, $loc) {\n        $loc.__init__ = new Sk.builtin.func(function(self,thematch, pattern, string) {\n            self.thematch = thematch;\n\t    self.re = pattern;\n\t    self.string = string;\n        });\n\n\t$loc.groups = new Sk.builtin.func(function(self) {\n\t    return new Sk.builtin.tuple(self.thematch.v.slice(1))\n\t});\n\n\t$loc.group = new Sk.builtin.func(function(self,grpnum) {\n\t    if (grpnum === undefined) {\n                grpnum = 0;\n            }\n            else {\n                grpnum = Sk.builtin.asnum$(grpnum);\n            }\n\t    if(grpnum >= self.thematch.v.length) {\n\t\tthrow new Sk.builtin.IndexError("Index out of range: " + grpnum);\n\t\t}\n\t    return self.thematch.v[grpnum]\n\t});\n\n    }\n\n    mod.MatchObject = Sk.misceval.buildClass(mod, matchobj, \'MatchObject\', []);\n\n    // Internal function to return a Python list of strings \n    // From a JS regular expression string\n    mod._findre = function(res, string) {\n\tres = res.replace(/([^\\\\]){,(?![^\\[]*\\])/g, \'$1{0,\');\n        var re = eval(res);\n\tvar patt = new RegExp(\'\\n$\');\n\tif (string.v.match(patt))\n\t    var matches = string.v.slice(0,-1).match(re);\n\telse\n            var matches = string.v.match(re);\n        retval = new Sk.builtin.list();\n        if ( matches == null ) return retval;\n        for (var i = 0; i < matches.length; ++i) {\n            var sitem = new Sk.builtin.str(matches[i]);\n            retval.v.push(sitem);\n        }\n        return retval;\n    }\n\n    mod.search = new Sk.builtin.func(function(pattern, string, flags) {\n\tSk.builtin.pyCheckArgs(\'search\', arguments, 2, 3);\n        if (!Sk.builtin.checkString(pattern)) {\n            throw new Sk.builtin.TypeError("pattern must be a string");\n        };\n        if (!Sk.builtin.checkString(string)) {\n            throw new Sk.builtin.TypeError("string must be a string");\n        };\n\tif (flags === undefined) {\n            flags = 0;\n        };\n        if (!Sk.builtin.checkNumber(flags)) {\n            throw new Sk.builtin.TypeError("flags must be a number");\n        };\n        var res = "/"+pattern.v.replace(/\\//g,"\\\\/")+"/";\n        lst = mod._findre(res,string);\n        if ( lst.v.length < 1 ) return Sk.builtin.none.none$;\n        var mob = Sk.misceval.callsim(mod.MatchObject, lst, pattern, string);\n        return mob;\n    });\n\n    mod.match = new Sk.builtin.func(function(pattern, string, flags) {\n\tSk.builtin.pyCheckArgs(\'match\', arguments, 2, 3);\n        if (!Sk.builtin.checkString(pattern)) {\n            throw new Sk.builtin.TypeError("pattern must be a string");\n        };\n        if (!Sk.builtin.checkString(string)) {\n            throw new Sk.builtin.TypeError("string must be a string");\n        };\n\tif (flags === undefined) {\n            flags = 0;\n        };\n        if (!Sk.builtin.checkNumber(flags)) {\n            throw new Sk.builtin.TypeError("flags must be a number");\n        };\n        var res = "/^"+pattern.v.replace(/\\//g,"\\\\/")+"/";\n        lst = mod._findre(res,string);\n        if ( lst.v.length < 1 ) return Sk.builtin.none.none$;\n        var mob = Sk.misceval.callsim(mod.MatchObject, lst, pattern, string);\n        return mob;\n    });\n\n    return mod;\n}\n',
    'src/lib/urllib/__init__.js': 'var $builtinmodule = function(name)\n{\n  var mod = {};\n  Sk.builtin.defineUrlLib(mod);\n  return mod;\n};\n',
    'src/lib/random/__init__.js': '\n/*\n  I\'ve wrapped Makoto Matsumoto and Takuji Nishimura\'s code in a namespace\n  so it\'s better encapsulated. Now you can have multiple random number generators\n  and they won\'t stomp all over eachother\'s state.\n  \n  If you want to use this as a substitute for Math.random(), use the random()\n  method like so:\n  \n  var m = new MersenneTwister();\n  var randomNumber = m.random();\n  \n  You can also call the other genrand_{foo}() methods on the instance.\n\n  If you want to use a specific seed in order to get a repeatable random\n  sequence, pass an integer into the constructor:\n\n  var m = new MersenneTwister(123);\n\n  and that will always produce the same random sequence.\n\n  Sean McCullough (banksean@gmail.com)\n*/\n\n/* \n   A C-program for MT19937, with initialization improved 2002/1/26.\n   Coded by Takuji Nishimura and Makoto Matsumoto.\n \n   Before using, initialize the state by using init_genrand(seed)  \n   or init_by_array(init_key, key_length).\n \n   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,\n   All rights reserved.                          \n \n   Redistribution and use in source and binary forms, with or without\n   modification, are permitted provided that the following conditions\n   are met:\n \n     1. Redistributions of source code must retain the above copyright\n        notice, this list of conditions and the following disclaimer.\n \n     2. Redistributions in binary form must reproduce the above copyright\n        notice, this list of conditions and the following disclaimer in the\n        documentation and/or other materials provided with the distribution.\n \n     3. The names of its contributors may not be used to endorse or promote \n        products derived from this software without specific prior written \n        permission.\n \n   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n \n \n   Any feedback is very welcome.\n   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html\n   email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)\n*/\n\nvar MersenneTwister = function(seed) {\n  if (seed == undefined) {\n    seed = new Date().getTime();\n  }\n  /* Period parameters */\n  this.N = 624;\n  this.M = 397;\n  this.MATRIX_A = 0x9908b0df;   /* constant vector a */\n  this.UPPER_MASK = 0x80000000; /* most significant w-r bits */\n  this.LOWER_MASK = 0x7fffffff; /* least significant r bits */\n \n  this.mt = new Array(this.N); /* the array for the state vector */\n  this.mti=this.N+1; /* mti==N+1 means mt[N] is not initialized */\n\n  this.init_genrand(seed);\n};\n \n/* initializes mt[N] with a seed */\nMersenneTwister.prototype.init_genrand = function(s) {\n  this.mt[0] = s >>> 0;\n  for (this.mti=1; this.mti<this.N; this.mti++) {\n      var s = this.mt[this.mti-1] ^ (this.mt[this.mti-1] >>> 30);\n   this.mt[this.mti] = (((((s & 0xffff0000) >>> 16) * 1812433253) << 16) + (s & 0x0000ffff) * 1812433253)\n  + this.mti;\n      /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */\n      /* In the previous versions, MSBs of the seed affect   */\n      /* only MSBs of the array mt[].                        */\n      /* 2002/01/09 modified by Makoto Matsumoto             */\n      this.mt[this.mti] >>>= 0;\n      /* for >32 bit machines */\n  }\n};\n\n/* initialize by an array with array-length */\n/* init_key is the array for initializing keys */\n/* key_length is its length */\n/* slight change for C++, 2004/2/26 */\nMersenneTwister.prototype.init_by_array = function(init_key, key_length) {\n  var i, j, k;\n  this.init_genrand(19650218);\n  i=1; j=0;\n  k = (this.N>key_length ? this.N : key_length);\n  for (; k; k--) {\n    var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30)\n    this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1664525) << 16) + ((s & 0x0000ffff) * 1664525)))\n      + init_key[j] + j; /* non linear */\n    this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */\n    i++; j++;\n    if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }\n    if (j>=key_length) j=0;\n  }\n  for (k=this.N-1; k; k--) {\n    var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30);\n    this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1566083941) << 16) + (s & 0x0000ffff) * 1566083941))\n      - i; /* non linear */\n    this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */\n    i++;\n    if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }\n  }\n\n  this.mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */ \n};\n\n/* generates a random number on [0,0xffffffff]-interval */\nMersenneTwister.prototype.genrand_int32 = function() {\n  var y;\n  var mag01 = new Array(0x0, this.MATRIX_A);\n  /* mag01[x] = x * MATRIX_A  for x=0,1 */\n\n  if (this.mti >= this.N) { /* generate N words at one time */\n    var kk;\n\n    if (this.mti == this.N+1)   /* if init_genrand() has not been called, */\n      this.init_genrand(5489); /* a default initial seed is used */\n\n    for (kk=0;kk<this.N-this.M;kk++) {\n      y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);\n      this.mt[kk] = this.mt[kk+this.M] ^ (y >>> 1) ^ mag01[y & 0x1];\n    }\n    for (;kk<this.N-1;kk++) {\n      y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);\n      this.mt[kk] = this.mt[kk+(this.M-this.N)] ^ (y >>> 1) ^ mag01[y & 0x1];\n    }\n    y = (this.mt[this.N-1]&this.UPPER_MASK)|(this.mt[0]&this.LOWER_MASK);\n    this.mt[this.N-1] = this.mt[this.M-1] ^ (y >>> 1) ^ mag01[y & 0x1];\n\n    this.mti = 0;\n  }\n\n  y = this.mt[this.mti++];\n\n  /* Tempering */\n  y ^= (y >>> 11);\n  y ^= (y << 7) & 0x9d2c5680;\n  y ^= (y << 15) & 0xefc60000;\n  y ^= (y >>> 18);\n\n  return y >>> 0;\n};\n\n/* generates a random number on [0,0x7fffffff]-interval */\nMersenneTwister.prototype.genrand_int31 = function() {\n  return (this.genrand_int32()>>>1);\n};\n\n/* generates a random number on [0,1]-real-interval */\nMersenneTwister.prototype.genrand_real1 = function() {\n  return this.genrand_int32()*(1.0/4294967295.0);\n  /* divided by 2^32-1 */\n};\n\n/* generates a random number on [0,1)-real-interval */\nMersenneTwister.prototype.random = function() {\n  return this.genrand_int32()*(1.0/4294967296.0); \n  /* divided by 2^32 */\n};\n\n/* generates a random number on (0,1)-real-interval */\nMersenneTwister.prototype.genrand_real3 = function() {\n  return (this.genrand_int32() + 0.5)*(1.0/4294967296.0);\n  /* divided by 2^32 */\n};\n\n/* generates a random number on [0,1) with 53-bit resolution*/\nMersenneTwister.prototype.genrand_res53 = function() {\n  var a=this.genrand_int32()>>>5, b=this.genrand_int32()>>>6;\n  return(a*67108864.0+b)*(1.0/9007199254740992.0);\n};\n\n/* These real versions are due to Isaku Wada, 2002/01/09 added */\n\nvar $builtinmodule = function(name) {\n\n  var mod = {};\n\n  var myGenerator = new MersenneTwister();\n\n  mod.seed = new Sk.builtin.func(function(x) {\n    Sk.builtin.pyCheckArgs("seed", arguments, 0, 1);\n    x = Sk.builtin.asnum$(x);\n\n    if (arguments.length > 0)\n      myGenerator = new MersenneTwister(x);\n    else\n      myGenerator = new MersenneTwister();\n    return Sk.builtin.none.none$;\n  });\n\n  mod.random = new Sk.builtin.func(function() {\n    Sk.builtin.pyCheckArgs("random", arguments, 0, 0);\n    return new Sk.builtin.nmber(myGenerator.genrand_res53(), Sk.builtin.nmber.float$);\n  });\n\n  var toInt = function(num) {\n    return num | 0;\n  };\n\n  var randrange = function(start, stop, step) {\n    // Ported from CPython 2.7\n    var width, n, ret;\n\n    if (!Sk.builtin.checkInt(start)) {\n      throw new Sk.builtin.ValueError("non-integer first argument for randrange()");\n    };\n\n    if (stop === undefined) {\n      // Random in [0, start)\n      return toInt(myGenerator.genrand_res53() * start);\n    };\n\n    if (!Sk.builtin.checkInt(stop)) {\n      throw new Sk.builtin.ValueError("non-integer stop for randrange()");\n    };\n\n    if (step === undefined) {\n      step = 1;\n    };\n\n    width = stop - start;\n\n    if ((step == 1) && (width > 0)) {\n      // Random in [start, stop), must use toInt on product for correct results with negative ranges\n      ret = start + toInt(myGenerator.genrand_res53() * width);\n      return new Sk.builtin.nmber(ret, Sk.builtin.nmber.int$);\n    };\n\n    if (step == 1) {\n      throw new Sk.builtin.ValueError("empty range for randrange() (" + start + ", " + stop + ", " + width + ")");\n    };\n\n    if (!Sk.builtin.checkInt(step)) {\n      throw new Sk.builtin.ValueError("non-integer step for randrange()");\n    };\n\n    if (step > 0) {\n      n = toInt((width + step - 1) / step);\n    } else if (step < 0) {\n      n = toInt((width + step + 1) / step);\n    } else {\n      throw new Sk.builtin.ValueError("zero step for randrange()");\n    };\n\n    if (n <= 0) {\n      throw new Sk.builtin.ValueError("empty range for randrange()");\n    };\n\n    // Random in range(start, stop, step)\n    ret = start + (step * toInt(myGenerator.genrand_res53() * n));\n    return new Sk.builtin.nmber(ret, Sk.builtin.nmber.int$);\n  };\n\n  mod.randint = new Sk.builtin.func(function(a, b) {\n    Sk.builtin.pyCheckArgs("randint", arguments, 2, 2);\n\n    a = Sk.builtin.asnum$(a);\n    b = Sk.builtin.asnum$(b);\n    return randrange(a, b+1);\n  });\n\n  mod.randrange = new Sk.builtin.func(function(start, stop, step) {\n    Sk.builtin.pyCheckArgs("randrange", arguments, 1, 3);\n\n    start = Sk.builtin.asnum$(start);\n    stop = Sk.builtin.asnum$(stop);\n    step = Sk.builtin.asnum$(step);\n    return randrange(start, stop, step);\n  });\n\n  mod.choice = new Sk.builtin.func(function(seq) {\n    Sk.builtin.pyCheckArgs("choice", arguments, 1, 1);\n    Sk.builtin.pyCheckType("seq", "sequence", Sk.builtin.checkSequence(seq));\n\n    if (seq.sq$length !== undefined) {\n      var r = toInt(myGenerator.genrand_res53() * seq.sq$length());\n      return seq.mp$subscript(r);\n    }\n    else {\n      throw new Sk.builtin.TypeError("object has no length");\n    }\n  });\n\n  mod.shuffle = new Sk.builtin.func(function(x) {\n    Sk.builtin.pyCheckArgs("shuffle", arguments, 1, 1);\n    Sk.builtin.pyCheckType("x", "sequence", Sk.builtin.checkSequence(x));\n\n    if (x.sq$length !== undefined) {\n      if (x.mp$ass_subscript !== undefined) {\n        for (var i = x.sq$length() - 1; i > 0; i -= 1) {\n            var r = toInt(myGenerator.genrand_res53() * (i + 1));\n            var tmp = x.mp$subscript(r);\n            x.mp$ass_subscript(r, x.mp$subscript(i));\n            x.mp$ass_subscript(i, tmp);\n        };\n      }\n      else {\n        throw new Sk.builtin.TypeError("object is immutable");\n      };\n    }\n    else {\n      throw new Sk.builtin.TypeError("object has no length");\n    }\n    return Sk.builtin.none.none$;\n  });\n\n  mod[\'uniform\'] = new Sk.builtin.func(function(minPy, maxPy) {\n    Sk.ffi.checkFunctionArgs("uniform", arguments, 2, 2);\n    Sk.ffi.checkArgType("min", [Sk.ffi.PyType.FLOAT], Sk.ffi.isNum(minPy), minPy);\n    Sk.ffi.checkArgType("max", [Sk.ffi.PyType.FLOAT], Sk.ffi.isNum(maxPy), maxPy);\n    var min = Sk.ffi.remapToJs(minPy);\n    var max = Sk.ffi.remapToJs(maxPy);\n    var x = myGenerator.genrand_res53();\n    var y = x * (max - min) + min;\n    return Sk.ffi.numberToFloatPy(y);\n  });\n\n  return mod;\n};',
    'src/lib/test/__init__.py': '__author__ = \'bmiller\'\n\ndef testEqual(actual, expected):\n    if type(expected) == type(1):\n        if actual == expected:\n            print(\'Pass\')\n            return True\n    elif type(expected) == type(1.11):\n        if abs(actual-expected) < 0.00001:\n            print(\'Pass\')\n            return True\n    else:\n        if actual == expected:\n            print(\'Pass\')\n            return True\n    print(\'Test Failed: expected \' + str(expected) + \' but got \' + str(actual))\n    return False\n\ndef testNotEqual(actual, expected):\n    pass\n\n',
    'src/lib/symbolic/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineSymbolic(mod, "symbolic");\n  return mod;\n};\n',
    'src/builtin/this.py': 's = """Gur Mra bs Clguba, ol Gvz Crgref\n\nOrnhgvshy vf orggre guna htyl.\nRkcyvpvg vf orggre guna vzcyvpvg.\nFvzcyr vf orggre guna pbzcyrk.\nPbzcyrk vf orggre guna pbzcyvpngrq.\nSyng vf orggre guna arfgrq.\nFcnefr vf orggre guna qrafr.\nErnqnovyvgl pbhagf.\nFcrpvny pnfrf nera\'g fcrpvny rabhtu gb oernx gur ehyrf.\nNygubhtu cenpgvpnyvgl orngf chevgl.\nReebef fubhyq arire cnff fvyragyl.\nHayrff rkcyvpvgyl fvyraprq.\nVa gur snpr bs nzovthvgl, ershfr gur grzcgngvba gb thrff.\nGurer fubhyq or bar-- naq cersrenoyl bayl bar --boivbhf jnl gb qb vg.\nNygubhtu gung jnl znl abg or boivbhf ng svefg hayrff lbh\'er Qhgpu.\nAbj vf orggre guna arire.\nNygubhtu arire vf bsgra orggre guna *evtug* abj.\nVs gur vzcyrzragngvba vf uneq gb rkcynva, vg\'f n onq vqrn.\nVs gur vzcyrzragngvba vf rnfl gb rkcynva, vg znl or n tbbq vqrn.\nAnzrfcnprf ner bar ubaxvat terng vqrn -- yrg\'f qb zber bs gubfr!"""\n\nd = {}\nfor c in (65, 97):\n    for i in range(26):\n        d[chr(i+c)] = chr((i+13) % 26 + c)\n\nprint "".join([d.get(c, c) for c in s])\n',
    'src/lib/e2ga/__init__.js': 'var $builtinmodule = function(name) {\n  var mod = {};\n  Sk.builtin.defineEuclidean2(mod, BLADE);\n  return mod;\n}\n'
  }
};
!function ($) {
  'use strict';
  var Carousel = function (element, options) {
    this.$element = $(element);
    this.$indicators = this.$element.find('.carousel-indicators');
    this.options = options;
    this.options.pause == 'hover' && this.$element.on('mouseenter', $.proxy(this.pause, this)).on('mouseleave', $.proxy(this.cycle, this));
  };
  Carousel.prototype = {
    cycle: function (e) {
      if (!e)
        this.paused = false;
      if (this.interval)
        clearInterval(this.interval);
      this.options.interval && !this.paused && (this.interval = setInterval($.proxy(this.next, this), this.options.interval));
      return this;
    },
    getActiveIndex: function () {
      this.$active = this.$element.find('.item.active');
      this.$items = this.$active.parent().children();
      return this.$items.index(this.$active);
    },
    to: function (pos) {
      var activeIndex = this.getActiveIndex(), that = this;
      if (pos > this.$items.length - 1 || pos < 0)
        return;
      if (this.sliding) {
        return this.$element.one('slid', function () {
          that.to(pos);
        });
      }
      if (activeIndex == pos) {
        return this.pause().cycle();
      }
      return this.slide(pos > activeIndex ? 'next' : 'prev', $(this.$items[pos]));
    },
    pause: function (e) {
      if (!e)
        this.paused = true;
      if (this.$element.find('.next, .prev').length && $.support.transition.end) {
        this.$element.trigger($.support.transition.end);
        this.cycle(true);
      }
      clearInterval(this.interval);
      this.interval = null;
      return this;
    },
    next: function () {
      if (this.sliding)
        return;
      return this.slide('next');
    },
    prev: function () {
      if (this.sliding)
        return;
      return this.slide('prev');
    },
    slide: function (type, next) {
      var $active = this.$element.find('.item.active'), $next = next || $active[type](), isCycling = this.interval, direction = type == 'next' ? 'left' : 'right', fallback = type == 'next' ? 'first' : 'last', that = this, e;
      this.sliding = true;
      isCycling && this.pause();
      $next = $next.length ? $next : this.$element.find('.item')[fallback]();
      e = $.Event('slide', {
        relatedTarget: $next[0],
        direction: direction
      });
      if ($next.hasClass('active'))
        return;
      if (this.$indicators.length) {
        this.$indicators.find('.active').removeClass('active');
        this.$element.one('slid', function () {
          var $nextIndicator = $(that.$indicators.children()[that.getActiveIndex()]);
          $nextIndicator && $nextIndicator.addClass('active');
        });
      }
      if ($.support.transition && this.$element.hasClass('slide')) {
        this.$element.trigger(e);
        if (e.isDefaultPrevented())
          return;
        $next.addClass(type);
        $next[0].offsetWidth;
        $active.addClass(direction);
        $next.addClass(direction);
        this.$element.one($.support.transition.end, function () {
          $next.removeClass([
            type,
            direction
          ].join(' ')).addClass('active');
          $active.removeClass([
            'active',
            direction
          ].join(' '));
          that.sliding = false;
          setTimeout(function () {
            that.$element.trigger('slid');
          }, 0);
        });
      } else {
        this.$element.trigger(e);
        if (e.isDefaultPrevented())
          return;
        $active.removeClass('active');
        $next.addClass('active');
        this.sliding = false;
        this.$element.trigger('slid');
      }
      isCycling && this.cycle();
      return this;
    }
  };
  var old = $.fn.carousel;
  $.fn.carousel = function (option) {
    return this.each(function () {
      var $this = $(this), data = $this.data('carousel'), options = $.extend({}, $.fn.carousel.defaults, typeof option == 'object' && option), action = typeof option == 'string' ? option : options.slide;
      if (!data)
        $this.data('carousel', data = new Carousel(this, options));
      if (typeof option == 'number')
        data.to(option);
      else if (action)
        data[action]();
      else if (options.interval)
        data.pause().cycle();
    });
  };
  $.fn.carousel.defaults = {
    interval: 5000,
    pause: 'hover'
  };
  $.fn.carousel.Constructor = Carousel;
  $.fn.carousel.noConflict = function () {
    $.fn.carousel = old;
    return this;
  };
  $(document).on('click.carousel.data-api', '[data-slide], [data-slide-to]', function (e) {
    var $this = $(this), href, $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')), options = $.extend({}, $target.data(), $this.data()), slideIndex;
    $target.carousel(options);
    if (slideIndex = $this.attr('data-slide-to')) {
      $target.data('carousel').pause().to(slideIndex).cycle();
    }
    e.preventDefault();
  });
}(window.jQuery);
!function ($) {
  'use strict';
  var Collapse = function (element, options) {
    this.$element = $(element);
    this.options = $.extend({}, $.fn.collapse.defaults, options);
    if (this.options.parent) {
      this.$parent = $(this.options.parent);
    }
    this.options.toggle && this.toggle();
  };
  Collapse.prototype = {
    constructor: Collapse,
    dimension: function () {
      var hasWidth = this.$element.hasClass('width');
      return hasWidth ? 'width' : 'height';
    },
    show: function () {
      var dimension, scroll, actives, hasData;
      if (this.transitioning || this.$element.hasClass('in'))
        return;
      dimension = this.dimension();
      scroll = $.camelCase([
        'scroll',
        dimension
      ].join('-'));
      actives = this.$parent && this.$parent.find('> .accordion-group > .in');
      if (actives && actives.length) {
        hasData = actives.data('collapse');
        if (hasData && hasData.transitioning)
          return;
        actives.collapse('hide');
        hasData || actives.data('collapse', null);
      }
      this.$element[dimension](0);
      this.transition('addClass', $.Event('show'), 'shown');
      $.support.transition && this.$element[dimension](this.$element[0][scroll]);
    },
    hide: function () {
      var dimension;
      if (this.transitioning || !this.$element.hasClass('in'))
        return;
      dimension = this.dimension();
      this.reset(this.$element[dimension]());
      this.transition('removeClass', $.Event('hide'), 'hidden');
      this.$element[dimension](0);
    },
    reset: function (size) {
      var dimension = this.dimension();
      this.$element.removeClass('collapse')[dimension](size || 'auto')[0].offsetWidth;
      this.$element[size !== null ? 'addClass' : 'removeClass']('collapse');
      return this;
    },
    transition: function (method, startEvent, completeEvent) {
      var that = this, complete = function () {
          if (startEvent.type == 'show')
            that.reset();
          that.transitioning = 0;
          that.$element.trigger(completeEvent);
        };
      this.$element.trigger(startEvent);
      if (startEvent.isDefaultPrevented())
        return;
      this.transitioning = 1;
      this.$element[method]('in');
      $.support.transition && this.$element.hasClass('collapse') ? this.$element.one($.support.transition.end, complete) : complete();
    },
    toggle: function () {
      this[this.$element.hasClass('in') ? 'hide' : 'show']();
    }
  };
  var old = $.fn.collapse;
  $.fn.collapse = function (option) {
    return this.each(function () {
      var $this = $(this), data = $this.data('collapse'), options = $.extend({}, $.fn.collapse.defaults, $this.data(), typeof option == 'object' && option);
      if (!data)
        $this.data('collapse', data = new Collapse(this, options));
      if (typeof option == 'string')
        data[option]();
    });
  };
  $.fn.collapse.defaults = { toggle: true };
  $.fn.collapse.Constructor = Collapse;
  $.fn.collapse.noConflict = function () {
    $.fn.collapse = old;
    return this;
  };
  $(document).on('click.collapse.data-api', '[data-toggle=collapse]', function (e) {
    var $this = $(this), href, target = $this.attr('data-target') || e.preventDefault() || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, ''), option = $(target).data('collapse') ? 'toggle' : $this.data();
    $this[$(target).hasClass('in') ? 'addClass' : 'removeClass']('collapsed');
    $(target).collapse(option);
  });
}(window.jQuery);
!function ($) {
  'use strict';
  var toggle = '[data-toggle=dropdown]', Dropdown = function (element) {
      var $el = $(element).on('click.dropdown.data-api', this.toggle);
      $('html').on('click.dropdown.data-api', function () {
        $el.parent().removeClass('open');
      });
    };
  Dropdown.prototype = {
    constructor: Dropdown,
    toggle: function (e) {
      var $this = $(this), $parent, isActive;
      if ($this.is('.disabled, :disabled'))
        return;
      $parent = getParent($this);
      isActive = $parent.hasClass('open');
      clearMenus();
      if (!isActive) {
        if ('ontouchstart' in document.documentElement) {
          $('<div class="dropdown-backdrop"/>').insertBefore($(this)).on('click', clearMenus);
        }
        $parent.toggleClass('open');
      }
      $this.focus();
      return false;
    },
    keydown: function (e) {
      var $this, $items, $active, $parent, isActive, index;
      if (!/(38|40|27)/.test(e.keyCode))
        return;
      $this = $(this);
      e.preventDefault();
      e.stopPropagation();
      if ($this.is('.disabled, :disabled'))
        return;
      $parent = getParent($this);
      isActive = $parent.hasClass('open');
      if (!isActive || isActive && e.keyCode == 27) {
        if (e.which == 27)
          $parent.find(toggle).focus();
        return $this.click();
      }
      $items = $('[role=menu] li:not(.divider):visible a', $parent);
      if (!$items.length)
        return;
      index = $items.index($items.filter(':focus'));
      if (e.keyCode == 38 && index > 0)
        index--;
      if (e.keyCode == 40 && index < $items.length - 1)
        index++;
      if (!~index)
        index = 0;
      $items.eq(index).focus();
    }
  };
  function clearMenus() {
    $('.dropdown-backdrop').remove();
    $(toggle).each(function () {
      getParent($(this)).removeClass('open');
    });
  }
  function getParent($this) {
    var selector = $this.attr('data-target'), $parent;
    if (!selector) {
      selector = $this.attr('href');
      selector = selector && /#/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '');
    }
    $parent = selector && $(selector);
    if (!$parent || !$parent.length)
      $parent = $this.parent();
    return $parent;
  }
  var old = $.fn.dropdown;
  $.fn.dropdown = function (option) {
    return this.each(function () {
      var $this = $(this), data = $this.data('dropdown');
      if (!data)
        $this.data('dropdown', data = new Dropdown(this));
      if (typeof option == 'string')
        data[option].call($this);
    });
  };
  $.fn.dropdown.Constructor = Dropdown;
  $.fn.dropdown.noConflict = function () {
    $.fn.dropdown = old;
    return this;
  };
  $(document).on('click.dropdown.data-api', clearMenus).on('click.dropdown.data-api', '.dropdown form', function (e) {
    e.stopPropagation();
  }).on('click.dropdown.data-api', toggle, Dropdown.prototype.toggle).on('keydown.dropdown.data-api', toggle + ', [role=menu]', Dropdown.prototype.keydown);
}(window.jQuery);
!function ($) {
  'use strict';
  var Modal = function (element, options) {
    this.options = options;
    this.$element = $(element).delegate('[data-dismiss="modal"]', 'click.dismiss.modal', $.proxy(this.hide, this));
    this.options.remote && this.$element.find('.modal-body').load(this.options.remote);
  };
  Modal.prototype = {
    constructor: Modal,
    toggle: function () {
      return this[!this.isShown ? 'show' : 'hide']();
    },
    show: function () {
      var that = this, e = $.Event('show');
      this.$element.trigger(e);
      if (this.isShown || e.isDefaultPrevented())
        return;
      this.isShown = true;
      this.escape();
      this.backdrop(function () {
        var transition = $.support.transition && that.$element.hasClass('fade');
        if (!that.$element.parent().length) {
          that.$element.appendTo(document.body);
        }
        that.$element.show();
        if (transition) {
          that.$element[0].offsetWidth;
        }
        that.$element.addClass('in').attr('aria-hidden', false);
        that.enforceFocus();
        transition ? that.$element.one($.support.transition.end, function () {
          that.$element.focus().trigger('shown');
        }) : that.$element.focus().trigger('shown');
      });
    },
    hide: function (e) {
      e && e.preventDefault();
      var that = this;
      e = $.Event('hide');
      this.$element.trigger(e);
      if (!this.isShown || e.isDefaultPrevented())
        return;
      this.isShown = false;
      this.escape();
      $(document).off('focusin.modal');
      this.$element.removeClass('in').attr('aria-hidden', true);
      $.support.transition && this.$element.hasClass('fade') ? this.hideWithTransition() : this.hideModal();
    },
    enforceFocus: function () {
      var that = this;
      $(document).on('focusin.modal', function (e) {
        if (that.$element[0] !== e.target && !that.$element.has(e.target).length) {
          that.$element.focus();
        }
      });
    },
    escape: function () {
      var that = this;
      if (this.isShown && this.options.keyboard) {
        this.$element.on('keyup.dismiss.modal', function (e) {
          e.which == 27 && that.hide();
        });
      } else if (!this.isShown) {
        this.$element.off('keyup.dismiss.modal');
      }
    },
    hideWithTransition: function () {
      var that = this, timeout = setTimeout(function () {
          that.$element.off($.support.transition.end);
          that.hideModal();
        }, 500);
      this.$element.one($.support.transition.end, function () {
        clearTimeout(timeout);
        that.hideModal();
      });
    },
    hideModal: function () {
      var that = this;
      this.$element.hide();
      this.backdrop(function () {
        that.removeBackdrop();
        that.$element.trigger('hidden');
      });
    },
    removeBackdrop: function () {
      this.$backdrop && this.$backdrop.remove();
      this.$backdrop = null;
    },
    backdrop: function (callback) {
      var that = this, animate = this.$element.hasClass('fade') ? 'fade' : '';
      if (this.isShown && this.options.backdrop) {
        var doAnimate = $.support.transition && animate;
        this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />').appendTo(document.body);
        this.$backdrop.click(this.options.backdrop == 'static' ? $.proxy(this.$element[0].focus, this.$element[0]) : $.proxy(this.hide, this));
        if (doAnimate)
          this.$backdrop[0].offsetWidth;
        this.$backdrop.addClass('in');
        if (!callback)
          return;
        doAnimate ? this.$backdrop.one($.support.transition.end, callback) : callback();
      } else if (!this.isShown && this.$backdrop) {
        this.$backdrop.removeClass('in');
        $.support.transition && this.$element.hasClass('fade') ? this.$backdrop.one($.support.transition.end, callback) : callback();
      } else if (callback) {
        callback();
      }
    }
  };
  var old = $.fn.modal;
  $.fn.modal = function (option) {
    return this.each(function () {
      var $this = $(this), data = $this.data('modal'), options = $.extend({}, $.fn.modal.defaults, $this.data(), typeof option == 'object' && option);
      if (!data)
        $this.data('modal', data = new Modal(this, options));
      if (typeof option == 'string')
        data[option]();
      else if (options.show)
        data.show();
    });
  };
  $.fn.modal.defaults = {
    backdrop: true,
    keyboard: true,
    show: true
  };
  $.fn.modal.Constructor = Modal;
  $.fn.modal.noConflict = function () {
    $.fn.modal = old;
    return this;
  };
  $(document).on('click.modal.data-api', '[data-toggle="modal"]', function (e) {
    var $this = $(this), href = $this.attr('href'), $target = $($this.attr('data-target') || href && href.replace(/.*(?=#[^\s]+$)/, '')), option = $target.data('modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data());
    e.preventDefault();
    $target.modal(option).one('hide', function () {
      $this.focus();
    });
  });
}(window.jQuery);
!function ($) {
  'use strict';
  var Tab = function (element) {
    this.element = $(element);
  };
  Tab.prototype = {
    constructor: Tab,
    show: function () {
      var $this = this.element, $ul = $this.closest('ul:not(.dropdown-menu)'), selector = $this.attr('data-target'), previous, $target, e;
      if (!selector) {
        selector = $this.attr('href');
        selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '');
      }
      if ($this.parent('li').hasClass('active'))
        return;
      previous = $ul.find('.active:last a')[0];
      e = $.Event('show', { relatedTarget: previous });
      $this.trigger(e);
      if (e.isDefaultPrevented())
        return;
      $target = $(selector);
      this.activate($this.parent('li'), $ul);
      this.activate($target, $target.parent(), function () {
        $this.trigger({
          type: 'shown',
          relatedTarget: previous
        });
      });
    },
    activate: function (element, container, callback) {
      var $active = container.find('> .active'), transition = callback && $.support.transition && $active.hasClass('fade');
      function next() {
        $active.removeClass('active').find('> .dropdown-menu > .active').removeClass('active');
        element.addClass('active');
        if (transition) {
          element[0].offsetWidth;
          element.addClass('in');
        } else {
          element.removeClass('fade');
        }
        if (element.parent('.dropdown-menu')) {
          element.closest('li.dropdown').addClass('active');
        }
        callback && callback();
      }
      transition ? $active.one($.support.transition.end, next) : next();
      $active.removeClass('in');
    }
  };
  var old = $.fn.tab;
  $.fn.tab = function (option) {
    return this.each(function () {
      var $this = $(this), data = $this.data('tab');
      if (!data)
        $this.data('tab', data = new Tab(this));
      if (typeof option == 'string')
        data[option]();
    });
  };
  $.fn.tab.Constructor = Tab;
  $.fn.tab.noConflict = function () {
    $.fn.tab = old;
    return this;
  };
  $(document).on('click.tab.data-api', '[data-toggle="tab"], [data-toggle="pill"]', function (e) {
    e.preventDefault();
    $(this).tab('show');
  });
}(window.jQuery);
!function ($) {
  'use strict';
  $(function () {
    $.support.transition = function () {
      var transitionEnd = function () {
          var el = document.createElement('bootstrap'), transEndEventNames = {
              'WebkitTransition': 'webkitTransitionEnd',
              'MozTransition': 'transitionend',
              'OTransition': 'oTransitionEnd otransitionend',
              'transition': 'transitionend'
            }, name;
          for (name in transEndEventNames) {
            if (el.style[name] !== undefined) {
              return transEndEventNames[name];
            }
          }
        }();
      return transitionEnd && { end: transitionEnd };
    }();
  });
}(window.jQuery);
(function (window, document, undefined) {
  'use strict';
  var lowercase = function (string) {
    return isString(string) ? string.toLowerCase() : string;
  };
  var uppercase = function (string) {
    return isString(string) ? string.toUpperCase() : string;
  };
  var manualLowercase = function (s) {
    return isString(s) ? s.replace(/[A-Z]/g, function (ch) {
      return String.fromCharCode(ch.charCodeAt(0) | 32);
    }) : s;
  };
  var manualUppercase = function (s) {
    return isString(s) ? s.replace(/[a-z]/g, function (ch) {
      return String.fromCharCode(ch.charCodeAt(0) & ~32);
    }) : s;
  };
  if ('i' !== 'I'.toLowerCase()) {
    lowercase = manualLowercase;
    uppercase = manualUppercase;
  }
  var msie = int((/msie (\d+)/.exec(lowercase(navigator.userAgent)) || [])[1]), jqLite, jQuery, slice = [].slice, push = [].push, toString = Object.prototype.toString, angular = window.angular || (window.angular = {}), angularModule, nodeName_, uid = [
      '0',
      '0',
      '0'
    ];
  function isArrayLike(obj) {
    if (!obj || typeof obj.length !== 'number')
      return false;
    if (typeof obj.hasOwnProperty != 'function' && typeof obj.constructor != 'function') {
      return true;
    } else {
      return obj instanceof JQLite || jQuery && obj instanceof jQuery || toString.call(obj) !== '[object Object]' || typeof obj.callee === 'function';
    }
  }
  function forEach(obj, iterator, context) {
    var key;
    if (obj) {
      if (isFunction(obj)) {
        for (key in obj) {
          if (key != 'prototype' && key != 'length' && key != 'name' && obj.hasOwnProperty(key)) {
            iterator.call(context, obj[key], key);
          }
        }
      } else if (obj.forEach && obj.forEach !== forEach) {
        obj.forEach(iterator, context);
      } else if (isArrayLike(obj)) {
        for (key = 0; key < obj.length; key++)
          iterator.call(context, obj[key], key);
      } else {
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            iterator.call(context, obj[key], key);
          }
        }
      }
    }
    return obj;
  }
  function sortedKeys(obj) {
    var keys = [];
    for (var key in obj) {
      if (obj.hasOwnProperty(key)) {
        keys.push(key);
      }
    }
    return keys.sort();
  }
  function forEachSorted(obj, iterator, context) {
    var keys = sortedKeys(obj);
    for (var i = 0; i < keys.length; i++) {
      iterator.call(context, obj[keys[i]], keys[i]);
    }
    return keys;
  }
  function reverseParams(iteratorFn) {
    return function (value, key) {
      iteratorFn(key, value);
    };
  }
  function nextUid() {
    var index = uid.length;
    var digit;
    while (index) {
      index--;
      digit = uid[index].charCodeAt(0);
      if (digit == 57) {
        uid[index] = 'A';
        return uid.join('');
      }
      if (digit == 90) {
        uid[index] = '0';
      } else {
        uid[index] = String.fromCharCode(digit + 1);
        return uid.join('');
      }
    }
    uid.unshift('0');
    return uid.join('');
  }
  function setHashKey(obj, h) {
    if (h) {
      obj.$$hashKey = h;
    } else {
      delete obj.$$hashKey;
    }
  }
  function extend(dst) {
    var h = dst.$$hashKey;
    forEach(arguments, function (obj) {
      if (obj !== dst) {
        forEach(obj, function (value, key) {
          dst[key] = value;
        });
      }
    });
    setHashKey(dst, h);
    return dst;
  }
  function int(str) {
    return parseInt(str, 10);
  }
  function inherit(parent, extra) {
    return extend(new (extend(function () {
    }, { prototype: parent }))(), extra);
  }
  function noop() {
  }
  noop.$inject = [];
  function identity($) {
    return $;
  }
  identity.$inject = [];
  function valueFn(value) {
    return function () {
      return value;
    };
  }
  function isUndefined(value) {
    return typeof value == 'undefined';
  }
  function isDefined(value) {
    return typeof value != 'undefined';
  }
  function isObject(value) {
    return value != null && typeof value == 'object';
  }
  function isString(value) {
    return typeof value == 'string';
  }
  function isNumber(value) {
    return typeof value == 'number';
  }
  function isDate(value) {
    return toString.apply(value) == '[object Date]';
  }
  function isArray(value) {
    return toString.apply(value) == '[object Array]';
  }
  function isFunction(value) {
    return typeof value == 'function';
  }
  function isWindow(obj) {
    return obj && obj.document && obj.location && obj.alert && obj.setInterval;
  }
  function isScope(obj) {
    return obj && obj.$evalAsync && obj.$watch;
  }
  function isFile(obj) {
    return toString.apply(obj) === '[object File]';
  }
  function isBoolean(value) {
    return typeof value == 'boolean';
  }
  function trim(value) {
    return isString(value) ? value.replace(/^\s*/, '').replace(/\s*$/, '') : value;
  }
  function isElement(node) {
    return node && (node.nodeName || node.bind && node.find);
  }
  function makeMap(str) {
    var obj = {}, items = str.split(','), i;
    for (i = 0; i < items.length; i++)
      obj[items[i]] = true;
    return obj;
  }
  if (msie < 9) {
    nodeName_ = function (element) {
      element = element.nodeName ? element : element[0];
      return element.scopeName && element.scopeName != 'HTML' ? uppercase(element.scopeName + ':' + element.nodeName) : element.nodeName;
    };
  } else {
    nodeName_ = function (element) {
      return element.nodeName ? element.nodeName : element[0].nodeName;
    };
  }
  function map(obj, iterator, context) {
    var results = [];
    forEach(obj, function (value, index, list) {
      results.push(iterator.call(context, value, index, list));
    });
    return results;
  }
  function size(obj, ownPropsOnly) {
    var size = 0, key;
    if (isArray(obj) || isString(obj)) {
      return obj.length;
    } else if (isObject(obj)) {
      for (key in obj)
        if (!ownPropsOnly || obj.hasOwnProperty(key))
          size++;
    }
    return size;
  }
  function includes(array, obj) {
    return indexOf(array, obj) != -1;
  }
  function indexOf(array, obj) {
    if (array.indexOf)
      return array.indexOf(obj);
    for (var i = 0; i < array.length; i++) {
      if (obj === array[i])
        return i;
    }
    return -1;
  }
  function arrayRemove(array, value) {
    var index = indexOf(array, value);
    if (index >= 0)
      array.splice(index, 1);
    return value;
  }
  function isLeafNode(node) {
    if (node) {
      switch (node.nodeName) {
      case 'OPTION':
      case 'PRE':
      case 'TITLE':
        return true;
      }
    }
    return false;
  }
  function copy(source, destination) {
    if (isWindow(source) || isScope(source))
      throw Error('Can\'t copy Window or Scope');
    if (!destination) {
      destination = source;
      if (source) {
        if (isArray(source)) {
          destination = copy(source, []);
        } else if (isDate(source)) {
          destination = new Date(source.getTime());
        } else if (isObject(source)) {
          destination = copy(source, {});
        }
      }
    } else {
      if (source === destination)
        throw Error('Can\'t copy equivalent objects or arrays');
      if (isArray(source)) {
        destination.length = 0;
        for (var i = 0; i < source.length; i++) {
          destination.push(copy(source[i]));
        }
      } else {
        var h = destination.$$hashKey;
        forEach(destination, function (value, key) {
          delete destination[key];
        });
        for (var key in source) {
          destination[key] = copy(source[key]);
        }
        setHashKey(destination, h);
      }
    }
    return destination;
  }
  function shallowCopy(src, dst) {
    dst = dst || {};
    for (var key in src) {
      if (src.hasOwnProperty(key) && key.substr(0, 2) !== '$$') {
        dst[key] = src[key];
      }
    }
    return dst;
  }
  function equals(o1, o2) {
    if (o1 === o2)
      return true;
    if (o1 === null || o2 === null)
      return false;
    if (o1 !== o1 && o2 !== o2)
      return true;
    var t1 = typeof o1, t2 = typeof o2, length, key, keySet;
    if (t1 == t2) {
      if (t1 == 'object') {
        if (isArray(o1)) {
          if ((length = o1.length) == o2.length) {
            for (key = 0; key < length; key++) {
              if (!equals(o1[key], o2[key]))
                return false;
            }
            return true;
          }
        } else if (isDate(o1)) {
          return isDate(o2) && o1.getTime() == o2.getTime();
        } else {
          if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2))
            return false;
          keySet = {};
          for (key in o1) {
            if (key.charAt(0) === '$' || isFunction(o1[key]))
              continue;
            if (!equals(o1[key], o2[key]))
              return false;
            keySet[key] = true;
          }
          for (key in o2) {
            if (!keySet[key] && key.charAt(0) !== '$' && o2[key] !== undefined && !isFunction(o2[key]))
              return false;
          }
          return true;
        }
      }
    }
    return false;
  }
  function concat(array1, array2, index) {
    return array1.concat(slice.call(array2, index));
  }
  function sliceArgs(args, startIndex) {
    return slice.call(args, startIndex || 0);
  }
  function bind(self, fn) {
    var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
    if (isFunction(fn) && !(fn instanceof RegExp)) {
      return curryArgs.length ? function () {
        return arguments.length ? fn.apply(self, curryArgs.concat(slice.call(arguments, 0))) : fn.apply(self, curryArgs);
      } : function () {
        return arguments.length ? fn.apply(self, arguments) : fn.call(self);
      };
    } else {
      return fn;
    }
  }
  function toJsonReplacer(key, value) {
    var val = value;
    if (/^\$+/.test(key)) {
      val = undefined;
    } else if (isWindow(value)) {
      val = '$WINDOW';
    } else if (value && document === value) {
      val = '$DOCUMENT';
    } else if (isScope(value)) {
      val = '$SCOPE';
    }
    return val;
  }
  function toJson(obj, pretty) {
    return JSON.stringify(obj, toJsonReplacer, pretty ? '  ' : null);
  }
  function fromJson(json) {
    return isString(json) ? JSON.parse(json) : json;
  }
  function toBoolean(value) {
    if (value && value.length !== 0) {
      var v = lowercase('' + value);
      value = !(v == 'f' || v == '0' || v == 'false' || v == 'no' || v == 'n' || v == '[]');
    } else {
      value = false;
    }
    return value;
  }
  function startingTag(element) {
    element = jqLite(element).clone();
    try {
      element.html('');
    } catch (e) {
    }
    var TEXT_NODE = 3;
    var elemHtml = jqLite('<div>').append(element).html();
    try {
      return element[0].nodeType === TEXT_NODE ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function (match, nodeName) {
        return '<' + lowercase(nodeName);
      });
    } catch (e) {
      return lowercase(elemHtml);
    }
  }
  function parseKeyValue(keyValue) {
    var obj = {}, key_value, key;
    forEach((keyValue || '').split('&'), function (keyValue) {
      if (keyValue) {
        key_value = keyValue.split('=');
        key = decodeURIComponent(key_value[0]);
        obj[key] = isDefined(key_value[1]) ? decodeURIComponent(key_value[1]) : true;
      }
    });
    return obj;
  }
  function toKeyValue(obj) {
    var parts = [];
    forEach(obj, function (value, key) {
      parts.push(encodeUriQuery(key, true) + (value === true ? '' : '=' + encodeUriQuery(value, true)));
    });
    return parts.length ? parts.join('&') : '';
  }
  function encodeUriSegment(val) {
    return encodeUriQuery(val, true).replace(/%26/gi, '&').replace(/%3D/gi, '=').replace(/%2B/gi, '+');
  }
  function encodeUriQuery(val, pctEncodeSpaces) {
    return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, pctEncodeSpaces ? '%20' : '+');
  }
  function angularInit(element, bootstrap) {
    var elements = [element], appElement, module, names = [
        'ng:app',
        'ng-app',
        'x-ng-app',
        'data-ng-app'
      ], NG_APP_CLASS_REGEXP = /\sng[:\-]app(:\s*([\w\d_]+);?)?\s/;
    function append(element) {
      element && elements.push(element);
    }
    forEach(names, function (name) {
      names[name] = true;
      append(document.getElementById(name));
      name = name.replace(':', '\\:');
      if (element.querySelectorAll) {
        forEach(element.querySelectorAll('.' + name), append);
        forEach(element.querySelectorAll('.' + name + '\\:'), append);
        forEach(element.querySelectorAll('[' + name + ']'), append);
      }
    });
    forEach(elements, function (element) {
      if (!appElement) {
        var className = ' ' + element.className + ' ';
        var match = NG_APP_CLASS_REGEXP.exec(className);
        if (match) {
          appElement = element;
          module = (match[2] || '').replace(/\s+/g, ',');
        } else {
          forEach(element.attributes, function (attr) {
            if (!appElement && names[attr.name]) {
              appElement = element;
              module = attr.value;
            }
          });
        }
      }
    });
    if (appElement) {
      bootstrap(appElement, module ? [module] : []);
    }
  }
  function bootstrap(element, modules) {
    var resumeBootstrapInternal = function () {
      element = jqLite(element);
      modules = modules || [];
      modules.unshift([
        '$provide',
        function ($provide) {
          $provide.value('$rootElement', element);
        }
      ]);
      modules.unshift('ng');
      var injector = createInjector(modules);
      injector.invoke([
        '$rootScope',
        '$rootElement',
        '$compile',
        '$injector',
        function (scope, element, compile, injector) {
          scope.$apply(function () {
            element.data('$injector', injector);
            compile(element)(scope);
          });
        }
      ]);
      return injector;
    };
    var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
    if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
      return resumeBootstrapInternal();
    }
    window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');
    angular.resumeBootstrap = function (extraModules) {
      forEach(extraModules, function (module) {
        modules.push(module);
      });
      resumeBootstrapInternal();
    };
  }
  var SNAKE_CASE_REGEXP = /[A-Z]/g;
  function snake_case(name, separator) {
    separator = separator || '_';
    return name.replace(SNAKE_CASE_REGEXP, function (letter, pos) {
      return (pos ? separator : '') + letter.toLowerCase();
    });
  }
  function bindJQuery() {
    jQuery = window.jQuery;
    if (jQuery) {
      jqLite = jQuery;
      extend(jQuery.fn, {
        scope: JQLitePrototype.scope,
        controller: JQLitePrototype.controller,
        injector: JQLitePrototype.injector,
        inheritedData: JQLitePrototype.inheritedData
      });
      JQLitePatchJQueryRemove('remove', true);
      JQLitePatchJQueryRemove('empty');
      JQLitePatchJQueryRemove('html');
    } else {
      jqLite = JQLite;
    }
    angular.element = jqLite;
  }
  function assertArg(arg, name, reason) {
    if (!arg) {
      throw new Error('Argument \'' + (name || '?') + '\' is ' + (reason || 'required'));
    }
    return arg;
  }
  function assertArgFn(arg, name, acceptArrayAnnotation) {
    if (acceptArrayAnnotation && isArray(arg)) {
      arg = arg[arg.length - 1];
    }
    assertArg(isFunction(arg), name, 'not a function, got ' + (arg && typeof arg == 'object' ? arg.constructor.name || 'Object' : typeof arg));
    return arg;
  }
  function setupModuleLoader(window) {
    function ensure(obj, name, factory) {
      return obj[name] || (obj[name] = factory());
    }
    return ensure(ensure(window, 'angular', Object), 'module', function () {
      var modules = {};
      return function module(name, requires, configFn) {
        if (requires && modules.hasOwnProperty(name)) {
          modules[name] = null;
        }
        return ensure(modules, name, function () {
          if (!requires) {
            throw Error('No module: ' + name);
          }
          var invokeQueue = [];
          var runBlocks = [];
          var config = invokeLater('$injector', 'invoke');
          var moduleInstance = {
              _invokeQueue: invokeQueue,
              _runBlocks: runBlocks,
              requires: requires,
              name: name,
              provider: invokeLater('$provide', 'provider'),
              factory: invokeLater('$provide', 'factory'),
              service: invokeLater('$provide', 'service'),
              value: invokeLater('$provide', 'value'),
              constant: invokeLater('$provide', 'constant', 'unshift'),
              filter: invokeLater('$filterProvider', 'register'),
              controller: invokeLater('$controllerProvider', 'register'),
              directive: invokeLater('$compileProvider', 'directive'),
              config: config,
              run: function (block) {
                runBlocks.push(block);
                return this;
              }
            };
          if (configFn) {
            config(configFn);
          }
          return moduleInstance;
          function invokeLater(provider, method, insertMethod) {
            return function () {
              invokeQueue[insertMethod || 'push']([
                provider,
                method,
                arguments
              ]);
              return moduleInstance;
            };
          }
        });
      };
    });
  }
  var version = {
      full: '1.0.7',
      major: 1,
      minor: 0,
      dot: 7,
      codeName: 'monochromatic-rainbow'
    };
  function publishExternalAPI(angular) {
    extend(angular, {
      'bootstrap': bootstrap,
      'copy': copy,
      'extend': extend,
      'equals': equals,
      'element': jqLite,
      'forEach': forEach,
      'injector': createInjector,
      'noop': noop,
      'bind': bind,
      'toJson': toJson,
      'fromJson': fromJson,
      'identity': identity,
      'isUndefined': isUndefined,
      'isDefined': isDefined,
      'isString': isString,
      'isFunction': isFunction,
      'isObject': isObject,
      'isNumber': isNumber,
      'isElement': isElement,
      'isArray': isArray,
      'version': version,
      'isDate': isDate,
      'lowercase': lowercase,
      'uppercase': uppercase,
      'callbacks': { counter: 0 }
    });
    angularModule = setupModuleLoader(window);
    try {
      angularModule('ngLocale');
    } catch (e) {
      angularModule('ngLocale', []).provider('$locale', $LocaleProvider);
    }
    angularModule('ng', ['ngLocale'], [
      '$provide',
      function ngModule($provide) {
        $provide.provider('$compile', $CompileProvider).directive({
          a: htmlAnchorDirective,
          input: inputDirective,
          textarea: inputDirective,
          form: formDirective,
          script: scriptDirective,
          select: selectDirective,
          style: styleDirective,
          option: optionDirective,
          ngBind: ngBindDirective,
          ngBindHtmlUnsafe: ngBindHtmlUnsafeDirective,
          ngBindTemplate: ngBindTemplateDirective,
          ngClass: ngClassDirective,
          ngClassEven: ngClassEvenDirective,
          ngClassOdd: ngClassOddDirective,
          ngCsp: ngCspDirective,
          ngCloak: ngCloakDirective,
          ngController: ngControllerDirective,
          ngForm: ngFormDirective,
          ngHide: ngHideDirective,
          ngInclude: ngIncludeDirective,
          ngInit: ngInitDirective,
          ngNonBindable: ngNonBindableDirective,
          ngPluralize: ngPluralizeDirective,
          ngRepeat: ngRepeatDirective,
          ngShow: ngShowDirective,
          ngSubmit: ngSubmitDirective,
          ngStyle: ngStyleDirective,
          ngSwitch: ngSwitchDirective,
          ngSwitchWhen: ngSwitchWhenDirective,
          ngSwitchDefault: ngSwitchDefaultDirective,
          ngOptions: ngOptionsDirective,
          ngView: ngViewDirective,
          ngTransclude: ngTranscludeDirective,
          ngModel: ngModelDirective,
          ngList: ngListDirective,
          ngChange: ngChangeDirective,
          required: requiredDirective,
          ngRequired: requiredDirective,
          ngValue: ngValueDirective
        }).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
        $provide.provider({
          $anchorScroll: $AnchorScrollProvider,
          $browser: $BrowserProvider,
          $cacheFactory: $CacheFactoryProvider,
          $controller: $ControllerProvider,
          $document: $DocumentProvider,
          $exceptionHandler: $ExceptionHandlerProvider,
          $filter: $FilterProvider,
          $interpolate: $InterpolateProvider,
          $http: $HttpProvider,
          $httpBackend: $HttpBackendProvider,
          $location: $LocationProvider,
          $log: $LogProvider,
          $parse: $ParseProvider,
          $route: $RouteProvider,
          $routeParams: $RouteParamsProvider,
          $rootScope: $RootScopeProvider,
          $q: $QProvider,
          $sniffer: $SnifferProvider,
          $templateCache: $TemplateCacheProvider,
          $timeout: $TimeoutProvider,
          $window: $WindowProvider
        });
      }
    ]);
  }
  var jqCache = JQLite.cache = {}, jqName = JQLite.expando = 'ng-' + new Date().getTime(), jqId = 1, addEventListenerFn = window.document.addEventListener ? function (element, type, fn) {
      element.addEventListener(type, fn, false);
    } : function (element, type, fn) {
      element.attachEvent('on' + type, fn);
    }, removeEventListenerFn = window.document.removeEventListener ? function (element, type, fn) {
      element.removeEventListener(type, fn, false);
    } : function (element, type, fn) {
      element.detachEvent('on' + type, fn);
    };
  function jqNextId() {
    return ++jqId;
  }
  var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
  var MOZ_HACK_REGEXP = /^moz([A-Z])/;
  function camelCase(name) {
    return name.replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {
      return offset ? letter.toUpperCase() : letter;
    }).replace(MOZ_HACK_REGEXP, 'Moz$1');
  }
  function JQLitePatchJQueryRemove(name, dispatchThis) {
    var originalJqFn = jQuery.fn[name];
    originalJqFn = originalJqFn.$original || originalJqFn;
    removePatch.$original = originalJqFn;
    jQuery.fn[name] = removePatch;
    function removePatch() {
      var list = [this], fireEvent = dispatchThis, set, setIndex, setLength, element, childIndex, childLength, children, fns, events;
      while (list.length) {
        set = list.shift();
        for (setIndex = 0, setLength = set.length; setIndex < setLength; setIndex++) {
          element = jqLite(set[setIndex]);
          if (fireEvent) {
            element.triggerHandler('$destroy');
          } else {
            fireEvent = !fireEvent;
          }
          for (childIndex = 0, childLength = (children = element.children()).length; childIndex < childLength; childIndex++) {
            list.push(jQuery(children[childIndex]));
          }
        }
      }
      return originalJqFn.apply(this, arguments);
    }
  }
  function JQLite(element) {
    if (element instanceof JQLite) {
      return element;
    }
    if (!(this instanceof JQLite)) {
      if (isString(element) && element.charAt(0) != '<') {
        throw Error('selectors not implemented');
      }
      return new JQLite(element);
    }
    if (isString(element)) {
      var div = document.createElement('div');
      div.innerHTML = '<div>&#160;</div>' + element;
      div.removeChild(div.firstChild);
      JQLiteAddNodes(this, div.childNodes);
      this.remove();
    } else {
      JQLiteAddNodes(this, element);
    }
  }
  function JQLiteClone(element) {
    return element.cloneNode(true);
  }
  function JQLiteDealoc(element) {
    JQLiteRemoveData(element);
    for (var i = 0, children = element.childNodes || []; i < children.length; i++) {
      JQLiteDealoc(children[i]);
    }
  }
  function JQLiteUnbind(element, type, fn) {
    var events = JQLiteExpandoStore(element, 'events'), handle = JQLiteExpandoStore(element, 'handle');
    if (!handle)
      return;
    if (isUndefined(type)) {
      forEach(events, function (eventHandler, type) {
        removeEventListenerFn(element, type, eventHandler);
        delete events[type];
      });
    } else {
      if (isUndefined(fn)) {
        removeEventListenerFn(element, type, events[type]);
        delete events[type];
      } else {
        arrayRemove(events[type], fn);
      }
    }
  }
  function JQLiteRemoveData(element) {
    var expandoId = element[jqName], expandoStore = jqCache[expandoId];
    if (expandoStore) {
      if (expandoStore.handle) {
        expandoStore.events.$destroy && expandoStore.handle({}, '$destroy');
        JQLiteUnbind(element);
      }
      delete jqCache[expandoId];
      element[jqName] = undefined;
    }
  }
  function JQLiteExpandoStore(element, key, value) {
    var expandoId = element[jqName], expandoStore = jqCache[expandoId || -1];
    if (isDefined(value)) {
      if (!expandoStore) {
        element[jqName] = expandoId = jqNextId();
        expandoStore = jqCache[expandoId] = {};
      }
      expandoStore[key] = value;
    } else {
      return expandoStore && expandoStore[key];
    }
  }
  function JQLiteData(element, key, value) {
    var data = JQLiteExpandoStore(element, 'data'), isSetter = isDefined(value), keyDefined = !isSetter && isDefined(key), isSimpleGetter = keyDefined && !isObject(key);
    if (!data && !isSimpleGetter) {
      JQLiteExpandoStore(element, 'data', data = {});
    }
    if (isSetter) {
      data[key] = value;
    } else {
      if (keyDefined) {
        if (isSimpleGetter) {
          return data && data[key];
        } else {
          extend(data, key);
        }
      } else {
        return data;
      }
    }
  }
  function JQLiteHasClass(element, selector) {
    return (' ' + element.className + ' ').replace(/[\n\t]/g, ' ').indexOf(' ' + selector + ' ') > -1;
  }
  function JQLiteRemoveClass(element, cssClasses) {
    if (cssClasses) {
      forEach(cssClasses.split(' '), function (cssClass) {
        element.className = trim((' ' + element.className + ' ').replace(/[\n\t]/g, ' ').replace(' ' + trim(cssClass) + ' ', ' '));
      });
    }
  }
  function JQLiteAddClass(element, cssClasses) {
    if (cssClasses) {
      forEach(cssClasses.split(' '), function (cssClass) {
        if (!JQLiteHasClass(element, cssClass)) {
          element.className = trim(element.className + ' ' + trim(cssClass));
        }
      });
    }
  }
  function JQLiteAddNodes(root, elements) {
    if (elements) {
      elements = !elements.nodeName && isDefined(elements.length) && !isWindow(elements) ? elements : [elements];
      for (var i = 0; i < elements.length; i++) {
        root.push(elements[i]);
      }
    }
  }
  function JQLiteController(element, name) {
    return JQLiteInheritedData(element, '$' + (name || 'ngController') + 'Controller');
  }
  function JQLiteInheritedData(element, name, value) {
    element = jqLite(element);
    if (element[0].nodeType == 9) {
      element = element.find('html');
    }
    while (element.length) {
      if (value = element.data(name))
        return value;
      element = element.parent();
    }
  }
  var JQLitePrototype = JQLite.prototype = {
      ready: function (fn) {
        var fired = false;
        function trigger() {
          if (fired)
            return;
          fired = true;
          fn();
        }
        this.bind('DOMContentLoaded', trigger);
        JQLite(window).bind('load', trigger);
      },
      toString: function () {
        var value = [];
        forEach(this, function (e) {
          value.push('' + e);
        });
        return '[' + value.join(', ') + ']';
      },
      eq: function (index) {
        return index >= 0 ? jqLite(this[index]) : jqLite(this[this.length + index]);
      },
      length: 0,
      push: push,
      sort: [].sort,
      splice: [].splice
    };
  var BOOLEAN_ATTR = {};
  forEach('multiple,selected,checked,disabled,readOnly,required'.split(','), function (value) {
    BOOLEAN_ATTR[lowercase(value)] = value;
  });
  var BOOLEAN_ELEMENTS = {};
  forEach('input,select,option,textarea,button,form'.split(','), function (value) {
    BOOLEAN_ELEMENTS[uppercase(value)] = true;
  });
  function getBooleanAttrName(element, name) {
    var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
    return booleanAttr && BOOLEAN_ELEMENTS[element.nodeName] && booleanAttr;
  }
  forEach({
    data: JQLiteData,
    inheritedData: JQLiteInheritedData,
    scope: function (element) {
      return JQLiteInheritedData(element, '$scope');
    },
    controller: JQLiteController,
    injector: function (element) {
      return JQLiteInheritedData(element, '$injector');
    },
    removeAttr: function (element, name) {
      element.removeAttribute(name);
    },
    hasClass: JQLiteHasClass,
    css: function (element, name, value) {
      name = camelCase(name);
      if (isDefined(value)) {
        element.style[name] = value;
      } else {
        var val;
        if (msie <= 8) {
          val = element.currentStyle && element.currentStyle[name];
          if (val === '')
            val = 'auto';
        }
        val = val || element.style[name];
        if (msie <= 8) {
          val = val === '' ? undefined : val;
        }
        return val;
      }
    },
    attr: function (element, name, value) {
      var lowercasedName = lowercase(name);
      if (BOOLEAN_ATTR[lowercasedName]) {
        if (isDefined(value)) {
          if (!!value) {
            element[name] = true;
            element.setAttribute(name, lowercasedName);
          } else {
            element[name] = false;
            element.removeAttribute(lowercasedName);
          }
        } else {
          return element[name] || (element.attributes.getNamedItem(name) || noop).specified ? lowercasedName : undefined;
        }
      } else if (isDefined(value)) {
        element.setAttribute(name, value);
      } else if (element.getAttribute) {
        var ret = element.getAttribute(name, 2);
        return ret === null ? undefined : ret;
      }
    },
    prop: function (element, name, value) {
      if (isDefined(value)) {
        element[name] = value;
      } else {
        return element[name];
      }
    },
    text: extend(msie < 9 ? function (element, value) {
      if (element.nodeType == 1) {
        if (isUndefined(value))
          return element.innerText;
        element.innerText = value;
      } else {
        if (isUndefined(value))
          return element.nodeValue;
        element.nodeValue = value;
      }
    } : function (element, value) {
      if (isUndefined(value)) {
        return element.textContent;
      }
      element.textContent = value;
    }, { $dv: '' }),
    val: function (element, value) {
      if (isUndefined(value)) {
        return element.value;
      }
      element.value = value;
    },
    html: function (element, value) {
      if (isUndefined(value)) {
        return element.innerHTML;
      }
      for (var i = 0, childNodes = element.childNodes; i < childNodes.length; i++) {
        JQLiteDealoc(childNodes[i]);
      }
      element.innerHTML = value;
    }
  }, function (fn, name) {
    JQLite.prototype[name] = function (arg1, arg2) {
      var i, key;
      if ((fn.length == 2 && (fn !== JQLiteHasClass && fn !== JQLiteController) ? arg1 : arg2) === undefined) {
        if (isObject(arg1)) {
          for (i = 0; i < this.length; i++) {
            if (fn === JQLiteData) {
              fn(this[i], arg1);
            } else {
              for (key in arg1) {
                fn(this[i], key, arg1[key]);
              }
            }
          }
          return this;
        } else {
          if (this.length)
            return fn(this[0], arg1, arg2);
        }
      } else {
        for (i = 0; i < this.length; i++) {
          fn(this[i], arg1, arg2);
        }
        return this;
      }
      return fn.$dv;
    };
  });
  function createEventHandler(element, events) {
    var eventHandler = function (event, type) {
      if (!event.preventDefault) {
        event.preventDefault = function () {
          event.returnValue = false;
        };
      }
      if (!event.stopPropagation) {
        event.stopPropagation = function () {
          event.cancelBubble = true;
        };
      }
      if (!event.target) {
        event.target = event.srcElement || document;
      }
      if (isUndefined(event.defaultPrevented)) {
        var prevent = event.preventDefault;
        event.preventDefault = function () {
          event.defaultPrevented = true;
          prevent.call(event);
        };
        event.defaultPrevented = false;
      }
      event.isDefaultPrevented = function () {
        return event.defaultPrevented;
      };
      forEach(events[type || event.type], function (fn) {
        fn.call(element, event);
      });
      if (msie <= 8) {
        event.preventDefault = null;
        event.stopPropagation = null;
        event.isDefaultPrevented = null;
      } else {
        delete event.preventDefault;
        delete event.stopPropagation;
        delete event.isDefaultPrevented;
      }
    };
    eventHandler.elem = element;
    return eventHandler;
  }
  forEach({
    removeData: JQLiteRemoveData,
    dealoc: JQLiteDealoc,
    bind: function bindFn(element, type, fn) {
      var events = JQLiteExpandoStore(element, 'events'), handle = JQLiteExpandoStore(element, 'handle');
      if (!events)
        JQLiteExpandoStore(element, 'events', events = {});
      if (!handle)
        JQLiteExpandoStore(element, 'handle', handle = createEventHandler(element, events));
      forEach(type.split(' '), function (type) {
        var eventFns = events[type];
        if (!eventFns) {
          if (type == 'mouseenter' || type == 'mouseleave') {
            var contains = document.body.contains || document.body.compareDocumentPosition ? function (a, b) {
                var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
                return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
              } : function (a, b) {
                if (b) {
                  while (b = b.parentNode) {
                    if (b === a) {
                      return true;
                    }
                  }
                }
                return false;
              };
            events[type] = [];
            var eventmap = {
                mouseleave: 'mouseout',
                mouseenter: 'mouseover'
              };
            bindFn(element, eventmap[type], function (event) {
              var ret, target = this, related = event.relatedTarget;
              if (!related || related !== target && !contains(target, related)) {
                handle(event, type);
              }
            });
          } else {
            addEventListenerFn(element, type, handle);
            events[type] = [];
          }
          eventFns = events[type];
        }
        eventFns.push(fn);
      });
    },
    unbind: JQLiteUnbind,
    replaceWith: function (element, replaceNode) {
      var index, parent = element.parentNode;
      JQLiteDealoc(element);
      forEach(new JQLite(replaceNode), function (node) {
        if (index) {
          parent.insertBefore(node, index.nextSibling);
        } else {
          parent.replaceChild(node, element);
        }
        index = node;
      });
    },
    children: function (element) {
      var children = [];
      forEach(element.childNodes, function (element) {
        if (element.nodeType === 1)
          children.push(element);
      });
      return children;
    },
    contents: function (element) {
      return element.childNodes || [];
    },
    append: function (element, node) {
      forEach(new JQLite(node), function (child) {
        if (element.nodeType === 1)
          element.appendChild(child);
      });
    },
    prepend: function (element, node) {
      if (element.nodeType === 1) {
        var index = element.firstChild;
        forEach(new JQLite(node), function (child) {
          if (index) {
            element.insertBefore(child, index);
          } else {
            element.appendChild(child);
            index = child;
          }
        });
      }
    },
    wrap: function (element, wrapNode) {
      wrapNode = jqLite(wrapNode)[0];
      var parent = element.parentNode;
      if (parent) {
        parent.replaceChild(wrapNode, element);
      }
      wrapNode.appendChild(element);
    },
    remove: function (element) {
      JQLiteDealoc(element);
      var parent = element.parentNode;
      if (parent)
        parent.removeChild(element);
    },
    after: function (element, newElement) {
      var index = element, parent = element.parentNode;
      forEach(new JQLite(newElement), function (node) {
        parent.insertBefore(node, index.nextSibling);
        index = node;
      });
    },
    addClass: JQLiteAddClass,
    removeClass: JQLiteRemoveClass,
    toggleClass: function (element, selector, condition) {
      if (isUndefined(condition)) {
        condition = !JQLiteHasClass(element, selector);
      }
      (condition ? JQLiteAddClass : JQLiteRemoveClass)(element, selector);
    },
    parent: function (element) {
      var parent = element.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    next: function (element) {
      if (element.nextElementSibling) {
        return element.nextElementSibling;
      }
      var elm = element.nextSibling;
      while (elm != null && elm.nodeType !== 1) {
        elm = elm.nextSibling;
      }
      return elm;
    },
    find: function (element, selector) {
      return element.getElementsByTagName(selector);
    },
    clone: JQLiteClone,
    triggerHandler: function (element, eventName) {
      var eventFns = (JQLiteExpandoStore(element, 'events') || {})[eventName];
      forEach(eventFns, function (fn) {
        fn.call(element, null);
      });
    }
  }, function (fn, name) {
    JQLite.prototype[name] = function (arg1, arg2) {
      var value;
      for (var i = 0; i < this.length; i++) {
        if (value == undefined) {
          value = fn(this[i], arg1, arg2);
          if (value !== undefined) {
            value = jqLite(value);
          }
        } else {
          JQLiteAddNodes(value, fn(this[i], arg1, arg2));
        }
      }
      return value == undefined ? this : value;
    };
  });
  function hashKey(obj) {
    var objType = typeof obj, key;
    if (objType == 'object' && obj !== null) {
      if (typeof (key = obj.$$hashKey) == 'function') {
        key = obj.$$hashKey();
      } else if (key === undefined) {
        key = obj.$$hashKey = nextUid();
      }
    } else {
      key = obj;
    }
    return objType + ':' + key;
  }
  function HashMap(array) {
    forEach(array, this.put, this);
  }
  HashMap.prototype = {
    put: function (key, value) {
      this[hashKey(key)] = value;
    },
    get: function (key) {
      return this[hashKey(key)];
    },
    remove: function (key) {
      var value = this[key = hashKey(key)];
      delete this[key];
      return value;
    }
  };
  function HashQueueMap() {
  }
  HashQueueMap.prototype = {
    push: function (key, value) {
      var array = this[key = hashKey(key)];
      if (!array) {
        this[key] = [value];
      } else {
        array.push(value);
      }
    },
    shift: function (key) {
      var array = this[key = hashKey(key)];
      if (array) {
        if (array.length == 1) {
          delete this[key];
          return array[0];
        } else {
          return array.shift();
        }
      }
    },
    peek: function (key) {
      var array = this[hashKey(key)];
      if (array) {
        return array[0];
      }
    }
  };
  var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;
  var FN_ARG_SPLIT = /,/;
  var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
  var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
  function annotate(fn) {
    var $inject, fnText, argDecl, last;
    if (typeof fn == 'function') {
      if (!($inject = fn.$inject)) {
        $inject = [];
        fnText = fn.toString().replace(STRIP_COMMENTS, '');
        argDecl = fnText.match(FN_ARGS);
        forEach(argDecl[1].split(FN_ARG_SPLIT), function (arg) {
          arg.replace(FN_ARG, function (all, underscore, name) {
            $inject.push(name);
          });
        });
        fn.$inject = $inject;
      }
    } else if (isArray(fn)) {
      last = fn.length - 1;
      assertArgFn(fn[last], 'fn');
      $inject = fn.slice(0, last);
    } else {
      assertArgFn(fn, 'fn', true);
    }
    return $inject;
  }
  function createInjector(modulesToLoad) {
    var INSTANTIATING = {}, providerSuffix = 'Provider', path = [], loadedModules = new HashMap(), providerCache = {
        $provide: {
          provider: supportObject(provider),
          factory: supportObject(factory),
          service: supportObject(service),
          value: supportObject(value),
          constant: supportObject(constant),
          decorator: decorator
        }
      }, providerInjector = createInternalInjector(providerCache, function () {
        throw Error('Unknown provider: ' + path.join(' <- '));
      }), instanceCache = {}, instanceInjector = instanceCache.$injector = createInternalInjector(instanceCache, function (servicename) {
        var provider = providerInjector.get(servicename + providerSuffix);
        return instanceInjector.invoke(provider.$get, provider);
      });
    forEach(loadModules(modulesToLoad), function (fn) {
      instanceInjector.invoke(fn || noop);
    });
    return instanceInjector;
    function supportObject(delegate) {
      return function (key, value) {
        if (isObject(key)) {
          forEach(key, reverseParams(delegate));
        } else {
          return delegate(key, value);
        }
      };
    }
    function provider(name, provider_) {
      if (isFunction(provider_) || isArray(provider_)) {
        provider_ = providerInjector.instantiate(provider_);
      }
      if (!provider_.$get) {
        throw Error('Provider ' + name + ' must define $get factory method.');
      }
      return providerCache[name + providerSuffix] = provider_;
    }
    function factory(name, factoryFn) {
      return provider(name, { $get: factoryFn });
    }
    function service(name, constructor) {
      return factory(name, [
        '$injector',
        function ($injector) {
          return $injector.instantiate(constructor);
        }
      ]);
    }
    function value(name, value) {
      return factory(name, valueFn(value));
    }
    function constant(name, value) {
      providerCache[name] = value;
      instanceCache[name] = value;
    }
    function decorator(serviceName, decorFn) {
      var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get;
      origProvider.$get = function () {
        var origInstance = instanceInjector.invoke(orig$get, origProvider);
        return instanceInjector.invoke(decorFn, null, { $delegate: origInstance });
      };
    }
    function loadModules(modulesToLoad) {
      var runBlocks = [];
      forEach(modulesToLoad, function (module) {
        if (loadedModules.get(module))
          return;
        loadedModules.put(module, true);
        if (isString(module)) {
          var moduleFn = angularModule(module);
          runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
          try {
            for (var invokeQueue = moduleFn._invokeQueue, i = 0, ii = invokeQueue.length; i < ii; i++) {
              var invokeArgs = invokeQueue[i], provider = invokeArgs[0] == '$injector' ? providerInjector : providerInjector.get(invokeArgs[0]);
              provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
            }
          } catch (e) {
            if (e.message)
              e.message += ' from ' + module;
            throw e;
          }
        } else if (isFunction(module)) {
          try {
            runBlocks.push(providerInjector.invoke(module));
          } catch (e) {
            if (e.message)
              e.message += ' from ' + module;
            throw e;
          }
        } else if (isArray(module)) {
          try {
            runBlocks.push(providerInjector.invoke(module));
          } catch (e) {
            if (e.message)
              e.message += ' from ' + String(module[module.length - 1]);
            throw e;
          }
        } else {
          assertArgFn(module, 'module');
        }
      });
      return runBlocks;
    }
    function createInternalInjector(cache, factory) {
      function getService(serviceName) {
        if (typeof serviceName !== 'string') {
          throw Error('Service name expected');
        }
        if (cache.hasOwnProperty(serviceName)) {
          if (cache[serviceName] === INSTANTIATING) {
            throw Error('Circular dependency: ' + path.join(' <- '));
          }
          return cache[serviceName];
        } else {
          try {
            path.unshift(serviceName);
            cache[serviceName] = INSTANTIATING;
            return cache[serviceName] = factory(serviceName);
          } finally {
            path.shift();
          }
        }
      }
      function invoke(fn, self, locals) {
        var args = [], $inject = annotate(fn), length, i, key;
        for (i = 0, length = $inject.length; i < length; i++) {
          key = $inject[i];
          args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key));
        }
        if (!fn.$inject) {
          fn = fn[length];
        }
        switch (self ? -1 : args.length) {
        case 0:
          return fn();
        case 1:
          return fn(args[0]);
        case 2:
          return fn(args[0], args[1]);
        case 3:
          return fn(args[0], args[1], args[2]);
        case 4:
          return fn(args[0], args[1], args[2], args[3]);
        case 5:
          return fn(args[0], args[1], args[2], args[3], args[4]);
        case 6:
          return fn(args[0], args[1], args[2], args[3], args[4], args[5]);
        case 7:
          return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        case 8:
          return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);
        case 9:
          return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]);
        case 10:
          return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]);
        default:
          return fn.apply(self, args);
        }
      }
      function instantiate(Type, locals) {
        var Constructor = function () {
          }, instance, returnedValue;
        Constructor.prototype = (isArray(Type) ? Type[Type.length - 1] : Type).prototype;
        instance = new Constructor();
        returnedValue = invoke(Type, instance, locals);
        return isObject(returnedValue) ? returnedValue : instance;
      }
      return {
        invoke: invoke,
        instantiate: instantiate,
        get: getService,
        annotate: annotate
      };
    }
  }
  function $AnchorScrollProvider() {
    var autoScrollingEnabled = true;
    this.disableAutoScrolling = function () {
      autoScrollingEnabled = false;
    };
    this.$get = [
      '$window',
      '$location',
      '$rootScope',
      function ($window, $location, $rootScope) {
        var document = $window.document;
        function getFirstAnchor(list) {
          var result = null;
          forEach(list, function (element) {
            if (!result && lowercase(element.nodeName) === 'a')
              result = element;
          });
          return result;
        }
        function scroll() {
          var hash = $location.hash(), elm;
          if (!hash)
            $window.scrollTo(0, 0);
          else if (elm = document.getElementById(hash))
            elm.scrollIntoView();
          else if (elm = getFirstAnchor(document.getElementsByName(hash)))
            elm.scrollIntoView();
          else if (hash === 'top')
            $window.scrollTo(0, 0);
        }
        if (autoScrollingEnabled) {
          $rootScope.$watch(function autoScrollWatch() {
            return $location.hash();
          }, function autoScrollWatchAction() {
            $rootScope.$evalAsync(scroll);
          });
        }
        return scroll;
      }
    ];
  }
  function Browser(window, document, $log, $sniffer) {
    var self = this, rawDocument = document[0], location = window.location, history = window.history, setTimeout = window.setTimeout, clearTimeout = window.clearTimeout, pendingDeferIds = {};
    self.isMock = false;
    var outstandingRequestCount = 0;
    var outstandingRequestCallbacks = [];
    self.$$completeOutstandingRequest = completeOutstandingRequest;
    self.$$incOutstandingRequestCount = function () {
      outstandingRequestCount++;
    };
    function completeOutstandingRequest(fn) {
      try {
        fn.apply(null, sliceArgs(arguments, 1));
      } finally {
        outstandingRequestCount--;
        if (outstandingRequestCount === 0) {
          while (outstandingRequestCallbacks.length) {
            try {
              outstandingRequestCallbacks.pop()();
            } catch (e) {
              $log.error(e);
            }
          }
        }
      }
    }
    self.notifyWhenNoOutstandingRequests = function (callback) {
      forEach(pollFns, function (pollFn) {
        pollFn();
      });
      if (outstandingRequestCount === 0) {
        callback();
      } else {
        outstandingRequestCallbacks.push(callback);
      }
    };
    var pollFns = [], pollTimeout;
    self.addPollFn = function (fn) {
      if (isUndefined(pollTimeout))
        startPoller(100, setTimeout);
      pollFns.push(fn);
      return fn;
    };
    function startPoller(interval, setTimeout) {
      (function check() {
        forEach(pollFns, function (pollFn) {
          pollFn();
        });
        pollTimeout = setTimeout(check, interval);
      }());
    }
    var lastBrowserUrl = location.href, baseElement = document.find('base');
    self.url = function (url, replace) {
      if (url) {
        if (lastBrowserUrl == url)
          return;
        lastBrowserUrl = url;
        if ($sniffer.history) {
          if (replace)
            history.replaceState(null, '', url);
          else {
            history.pushState(null, '', url);
            baseElement.attr('href', baseElement.attr('href'));
          }
        } else {
          if (replace)
            location.replace(url);
          else
            location.href = url;
        }
        return self;
      } else {
        return location.href.replace(/%27/g, '\'');
      }
    };
    var urlChangeListeners = [], urlChangeInit = false;
    function fireUrlChange() {
      if (lastBrowserUrl == self.url())
        return;
      lastBrowserUrl = self.url();
      forEach(urlChangeListeners, function (listener) {
        listener(self.url());
      });
    }
    self.onUrlChange = function (callback) {
      if (!urlChangeInit) {
        if ($sniffer.history)
          jqLite(window).bind('popstate', fireUrlChange);
        if ($sniffer.hashchange)
          jqLite(window).bind('hashchange', fireUrlChange);
        else
          self.addPollFn(fireUrlChange);
        urlChangeInit = true;
      }
      urlChangeListeners.push(callback);
      return callback;
    };
    self.baseHref = function () {
      var href = baseElement.attr('href');
      return href ? href.replace(/^https?\:\/\/[^\/]*/, '') : '';
    };
    var lastCookies = {};
    var lastCookieString = '';
    var cookiePath = self.baseHref();
    self.cookies = function (name, value) {
      var cookieLength, cookieArray, cookie, i, index;
      if (name) {
        if (value === undefined) {
          rawDocument.cookie = escape(name) + '=;path=' + cookiePath + ';expires=Thu, 01 Jan 1970 00:00:00 GMT';
        } else {
          if (isString(value)) {
            cookieLength = (rawDocument.cookie = escape(name) + '=' + escape(value) + ';path=' + cookiePath).length + 1;
            if (cookieLength > 4096) {
              $log.warn('Cookie \'' + name + '\' possibly not set or overflowed because it was too large (' + cookieLength + ' > 4096 bytes)!');
            }
          }
        }
      } else {
        if (rawDocument.cookie !== lastCookieString) {
          lastCookieString = rawDocument.cookie;
          cookieArray = lastCookieString.split('; ');
          lastCookies = {};
          for (i = 0; i < cookieArray.length; i++) {
            cookie = cookieArray[i];
            index = cookie.indexOf('=');
            if (index > 0) {
              var name = unescape(cookie.substring(0, index));
              if (lastCookies[name] === undefined) {
                lastCookies[name] = unescape(cookie.substring(index + 1));
              }
            }
          }
        }
        return lastCookies;
      }
    };
    self.defer = function (fn, delay) {
      var timeoutId;
      outstandingRequestCount++;
      timeoutId = setTimeout(function () {
        delete pendingDeferIds[timeoutId];
        completeOutstandingRequest(fn);
      }, delay || 0);
      pendingDeferIds[timeoutId] = true;
      return timeoutId;
    };
    self.defer.cancel = function (deferId) {
      if (pendingDeferIds[deferId]) {
        delete pendingDeferIds[deferId];
        clearTimeout(deferId);
        completeOutstandingRequest(noop);
        return true;
      }
      return false;
    };
  }
  function $BrowserProvider() {
    this.$get = [
      '$window',
      '$log',
      '$sniffer',
      '$document',
      function ($window, $log, $sniffer, $document) {
        return new Browser($window, $document, $log, $sniffer);
      }
    ];
  }
  function $CacheFactoryProvider() {
    this.$get = function () {
      var caches = {};
      function cacheFactory(cacheId, options) {
        if (cacheId in caches) {
          throw Error('cacheId ' + cacheId + ' taken');
        }
        var size = 0, stats = extend({}, options, { id: cacheId }), data = {}, capacity = options && options.capacity || Number.MAX_VALUE, lruHash = {}, freshEnd = null, staleEnd = null;
        return caches[cacheId] = {
          put: function (key, value) {
            var lruEntry = lruHash[key] || (lruHash[key] = { key: key });
            refresh(lruEntry);
            if (isUndefined(value))
              return;
            if (!(key in data))
              size++;
            data[key] = value;
            if (size > capacity) {
              this.remove(staleEnd.key);
            }
          },
          get: function (key) {
            var lruEntry = lruHash[key];
            if (!lruEntry)
              return;
            refresh(lruEntry);
            return data[key];
          },
          remove: function (key) {
            var lruEntry = lruHash[key];
            if (!lruEntry)
              return;
            if (lruEntry == freshEnd)
              freshEnd = lruEntry.p;
            if (lruEntry == staleEnd)
              staleEnd = lruEntry.n;
            link(lruEntry.n, lruEntry.p);
            delete lruHash[key];
            delete data[key];
            size--;
          },
          removeAll: function () {
            data = {};
            size = 0;
            lruHash = {};
            freshEnd = staleEnd = null;
          },
          destroy: function () {
            data = null;
            stats = null;
            lruHash = null;
            delete caches[cacheId];
          },
          info: function () {
            return extend({}, stats, { size: size });
          }
        };
        function refresh(entry) {
          if (entry != freshEnd) {
            if (!staleEnd) {
              staleEnd = entry;
            } else if (staleEnd == entry) {
              staleEnd = entry.n;
            }
            link(entry.n, entry.p);
            link(entry, freshEnd);
            freshEnd = entry;
            freshEnd.n = null;
          }
        }
        function link(nextEntry, prevEntry) {
          if (nextEntry != prevEntry) {
            if (nextEntry)
              nextEntry.p = prevEntry;
            if (prevEntry)
              prevEntry.n = nextEntry;
          }
        }
      }
      cacheFactory.info = function () {
        var info = {};
        forEach(caches, function (cache, cacheId) {
          info[cacheId] = cache.info();
        });
        return info;
      };
      cacheFactory.get = function (cacheId) {
        return caches[cacheId];
      };
      return cacheFactory;
    };
  }
  function $TemplateCacheProvider() {
    this.$get = [
      '$cacheFactory',
      function ($cacheFactory) {
        return $cacheFactory('templates');
      }
    ];
  }
  var NON_ASSIGNABLE_MODEL_EXPRESSION = 'Non-assignable model expression: ';
  $CompileProvider.$inject = ['$provide'];
  function $CompileProvider($provide) {
    var hasDirectives = {}, Suffix = 'Directive', COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\d\w\-_]+)\s+(.*)$/, CLASS_DIRECTIVE_REGEXP = /(([\d\w\-_]+)(?:\:([^;]+))?;?)/, MULTI_ROOT_TEMPLATE_ERROR = 'Template must have exactly one root element. was: ', urlSanitizationWhitelist = /^\s*(https?|ftp|mailto|file):/;
    this.directive = function registerDirective(name, directiveFactory) {
      if (isString(name)) {
        assertArg(directiveFactory, 'directive');
        if (!hasDirectives.hasOwnProperty(name)) {
          hasDirectives[name] = [];
          $provide.factory(name + Suffix, [
            '$injector',
            '$exceptionHandler',
            function ($injector, $exceptionHandler) {
              var directives = [];
              forEach(hasDirectives[name], function (directiveFactory) {
                try {
                  var directive = $injector.invoke(directiveFactory);
                  if (isFunction(directive)) {
                    directive = { compile: valueFn(directive) };
                  } else if (!directive.compile && directive.link) {
                    directive.compile = valueFn(directive.link);
                  }
                  directive.priority = directive.priority || 0;
                  directive.name = directive.name || name;
                  directive.require = directive.require || directive.controller && directive.name;
                  directive.restrict = directive.restrict || 'A';
                  directives.push(directive);
                } catch (e) {
                  $exceptionHandler(e);
                }
              });
              return directives;
            }
          ]);
        }
        hasDirectives[name].push(directiveFactory);
      } else {
        forEach(name, reverseParams(registerDirective));
      }
      return this;
    };
    this.urlSanitizationWhitelist = function (regexp) {
      if (isDefined(regexp)) {
        urlSanitizationWhitelist = regexp;
        return this;
      }
      return urlSanitizationWhitelist;
    };
    this.$get = [
      '$injector',
      '$interpolate',
      '$exceptionHandler',
      '$http',
      '$templateCache',
      '$parse',
      '$controller',
      '$rootScope',
      '$document',
      function ($injector, $interpolate, $exceptionHandler, $http, $templateCache, $parse, $controller, $rootScope, $document) {
        var Attributes = function (element, attr) {
          this.$$element = element;
          this.$attr = attr || {};
        };
        Attributes.prototype = {
          $normalize: directiveNormalize,
          $set: function (key, value, writeAttr, attrName) {
            var booleanKey = getBooleanAttrName(this.$$element[0], key), $$observers = this.$$observers, normalizedVal;
            if (booleanKey) {
              this.$$element.prop(key, value);
              attrName = booleanKey;
            }
            this[key] = value;
            if (attrName) {
              this.$attr[key] = attrName;
            } else {
              attrName = this.$attr[key];
              if (!attrName) {
                this.$attr[key] = attrName = snake_case(key, '-');
              }
            }
            if (nodeName_(this.$$element[0]) === 'A' && key === 'href') {
              urlSanitizationNode.setAttribute('href', value);
              normalizedVal = urlSanitizationNode.href;
              if (!normalizedVal.match(urlSanitizationWhitelist)) {
                this[key] = value = 'unsafe:' + normalizedVal;
              }
            }
            if (writeAttr !== false) {
              if (value === null || value === undefined) {
                this.$$element.removeAttr(attrName);
              } else {
                this.$$element.attr(attrName, value);
              }
            }
            $$observers && forEach($$observers[key], function (fn) {
              try {
                fn(value);
              } catch (e) {
                $exceptionHandler(e);
              }
            });
          },
          $observe: function (key, fn) {
            var attrs = this, $$observers = attrs.$$observers || (attrs.$$observers = {}), listeners = $$observers[key] || ($$observers[key] = []);
            listeners.push(fn);
            $rootScope.$evalAsync(function () {
              if (!listeners.$$inter) {
                fn(attrs[key]);
              }
            });
            return fn;
          }
        };
        var urlSanitizationNode = $document[0].createElement('a'), startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), denormalizeTemplate = startSymbol == '{{' || endSymbol == '}}' ? identity : function denormalizeTemplate(template) {
            return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
          };
        return compile;
        function compile($compileNodes, transcludeFn, maxPriority) {
          if (!($compileNodes instanceof jqLite)) {
            $compileNodes = jqLite($compileNodes);
          }
          forEach($compileNodes, function (node, index) {
            if (node.nodeType == 3 && node.nodeValue.match(/\S+/)) {
              $compileNodes[index] = jqLite(node).wrap('<span></span>').parent()[0];
            }
          });
          var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority);
          return function publicLinkFn(scope, cloneConnectFn) {
            assertArg(scope, 'scope');
            var $linkNode = cloneConnectFn ? JQLitePrototype.clone.call($compileNodes) : $compileNodes;
            for (var i = 0, ii = $linkNode.length; i < ii; i++) {
              var node = $linkNode[i];
              if (node.nodeType == 1 || node.nodeType == 9) {
                $linkNode.eq(i).data('$scope', scope);
              }
            }
            safeAddClass($linkNode, 'ng-scope');
            if (cloneConnectFn)
              cloneConnectFn($linkNode, scope);
            if (compositeLinkFn)
              compositeLinkFn(scope, $linkNode, $linkNode);
            return $linkNode;
          };
        }
        function wrongMode(localName, mode) {
          throw Error('Unsupported \'' + mode + '\' for \'' + localName + '\'.');
        }
        function safeAddClass($element, className) {
          try {
            $element.addClass(className);
          } catch (e) {
          }
        }
        function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority) {
          var linkFns = [], nodeLinkFn, childLinkFn, directives, attrs, linkFnFound;
          for (var i = 0; i < nodeList.length; i++) {
            attrs = new Attributes();
            directives = collectDirectives(nodeList[i], [], attrs, maxPriority);
            nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement) : null;
            childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !nodeList[i].childNodes || !nodeList[i].childNodes.length ? null : compileNodes(nodeList[i].childNodes, nodeLinkFn ? nodeLinkFn.transclude : transcludeFn);
            linkFns.push(nodeLinkFn);
            linkFns.push(childLinkFn);
            linkFnFound = linkFnFound || nodeLinkFn || childLinkFn;
          }
          return linkFnFound ? compositeLinkFn : null;
          function compositeLinkFn(scope, nodeList, $rootElement, boundTranscludeFn) {
            var nodeLinkFn, childLinkFn, node, childScope, childTranscludeFn, i, ii, n;
            var stableNodeList = [];
            for (i = 0, ii = nodeList.length; i < ii; i++) {
              stableNodeList.push(nodeList[i]);
            }
            for (i = 0, n = 0, ii = linkFns.length; i < ii; n++) {
              node = stableNodeList[n];
              nodeLinkFn = linkFns[i++];
              childLinkFn = linkFns[i++];
              if (nodeLinkFn) {
                if (nodeLinkFn.scope) {
                  childScope = scope.$new(isObject(nodeLinkFn.scope));
                  jqLite(node).data('$scope', childScope);
                } else {
                  childScope = scope;
                }
                childTranscludeFn = nodeLinkFn.transclude;
                if (childTranscludeFn || !boundTranscludeFn && transcludeFn) {
                  nodeLinkFn(childLinkFn, childScope, node, $rootElement, function (transcludeFn) {
                    return function (cloneFn) {
                      var transcludeScope = scope.$new();
                      transcludeScope.$$transcluded = true;
                      return transcludeFn(transcludeScope, cloneFn).bind('$destroy', bind(transcludeScope, transcludeScope.$destroy));
                    };
                  }(childTranscludeFn || transcludeFn));
                } else {
                  nodeLinkFn(childLinkFn, childScope, node, undefined, boundTranscludeFn);
                }
              } else if (childLinkFn) {
                childLinkFn(scope, node.childNodes, undefined, boundTranscludeFn);
              }
            }
          }
        }
        function collectDirectives(node, directives, attrs, maxPriority) {
          var nodeType = node.nodeType, attrsMap = attrs.$attr, match, className;
          switch (nodeType) {
          case 1:
            addDirective(directives, directiveNormalize(nodeName_(node).toLowerCase()), 'E', maxPriority);
            for (var attr, name, nName, value, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
              attr = nAttrs[j];
              if (attr.specified) {
                name = attr.name;
                nName = directiveNormalize(name.toLowerCase());
                attrsMap[nName] = name;
                attrs[nName] = value = trim(msie && name == 'href' ? decodeURIComponent(node.getAttribute(name, 2)) : attr.value);
                if (getBooleanAttrName(node, nName)) {
                  attrs[nName] = true;
                }
                addAttrInterpolateDirective(node, directives, value, nName);
                addDirective(directives, nName, 'A', maxPriority);
              }
            }
            className = node.className;
            if (isString(className) && className !== '') {
              while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                nName = directiveNormalize(match[2]);
                if (addDirective(directives, nName, 'C', maxPriority)) {
                  attrs[nName] = trim(match[3]);
                }
                className = className.substr(match.index + match[0].length);
              }
            }
            break;
          case 3:
            addTextInterpolateDirective(directives, node.nodeValue);
            break;
          case 8:
            try {
              match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
              if (match) {
                nName = directiveNormalize(match[1]);
                if (addDirective(directives, nName, 'M', maxPriority)) {
                  attrs[nName] = trim(match[2]);
                }
              }
            } catch (e) {
            }
            break;
          }
          directives.sort(byPriority);
          return directives;
        }
        function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection) {
          var terminalPriority = -Number.MAX_VALUE, preLinkFns = [], postLinkFns = [], newScopeDirective = null, newIsolateScopeDirective = null, templateDirective = null, $compileNode = templateAttrs.$$element = jqLite(compileNode), directive, directiveName, $template, transcludeDirective, childTranscludeFn = transcludeFn, controllerDirectives, linkFn, directiveValue;
          for (var i = 0, ii = directives.length; i < ii; i++) {
            directive = directives[i];
            $template = undefined;
            if (terminalPriority > directive.priority) {
              break;
            }
            if (directiveValue = directive.scope) {
              assertNoDuplicate('isolated scope', newIsolateScopeDirective, directive, $compileNode);
              if (isObject(directiveValue)) {
                safeAddClass($compileNode, 'ng-isolate-scope');
                newIsolateScopeDirective = directive;
              }
              safeAddClass($compileNode, 'ng-scope');
              newScopeDirective = newScopeDirective || directive;
            }
            directiveName = directive.name;
            if (directiveValue = directive.controller) {
              controllerDirectives = controllerDirectives || {};
              assertNoDuplicate('\'' + directiveName + '\' controller', controllerDirectives[directiveName], directive, $compileNode);
              controllerDirectives[directiveName] = directive;
            }
            if (directiveValue = directive.transclude) {
              assertNoDuplicate('transclusion', transcludeDirective, directive, $compileNode);
              transcludeDirective = directive;
              terminalPriority = directive.priority;
              if (directiveValue == 'element') {
                $template = jqLite(compileNode);
                $compileNode = templateAttrs.$$element = jqLite(document.createComment(' ' + directiveName + ': ' + templateAttrs[directiveName] + ' '));
                compileNode = $compileNode[0];
                replaceWith(jqCollection, jqLite($template[0]), compileNode);
                childTranscludeFn = compile($template, transcludeFn, terminalPriority);
              } else {
                $template = jqLite(JQLiteClone(compileNode)).contents();
                $compileNode.html('');
                childTranscludeFn = compile($template, transcludeFn);
              }
            }
            if (directiveValue = directive.template) {
              assertNoDuplicate('template', templateDirective, directive, $compileNode);
              templateDirective = directive;
              directiveValue = denormalizeTemplate(directiveValue);
              if (directive.replace) {
                $template = jqLite('<div>' + trim(directiveValue) + '</div>').contents();
                compileNode = $template[0];
                if ($template.length != 1 || compileNode.nodeType !== 1) {
                  throw new Error(MULTI_ROOT_TEMPLATE_ERROR + directiveValue);
                }
                replaceWith(jqCollection, $compileNode, compileNode);
                var newTemplateAttrs = { $attr: {} };
                directives = directives.concat(collectDirectives(compileNode, directives.splice(i + 1, directives.length - (i + 1)), newTemplateAttrs));
                mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                ii = directives.length;
              } else {
                $compileNode.html(directiveValue);
              }
            }
            if (directive.templateUrl) {
              assertNoDuplicate('template', templateDirective, directive, $compileNode);
              templateDirective = directive;
              nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), nodeLinkFn, $compileNode, templateAttrs, jqCollection, directive.replace, childTranscludeFn);
              ii = directives.length;
            } else if (directive.compile) {
              try {
                linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                if (isFunction(linkFn)) {
                  addLinkFns(null, linkFn);
                } else if (linkFn) {
                  addLinkFns(linkFn.pre, linkFn.post);
                }
              } catch (e) {
                $exceptionHandler(e, startingTag($compileNode));
              }
            }
            if (directive.terminal) {
              nodeLinkFn.terminal = true;
              terminalPriority = Math.max(terminalPriority, directive.priority);
            }
          }
          nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope;
          nodeLinkFn.transclude = transcludeDirective && childTranscludeFn;
          return nodeLinkFn;
          function addLinkFns(pre, post) {
            if (pre) {
              pre.require = directive.require;
              preLinkFns.push(pre);
            }
            if (post) {
              post.require = directive.require;
              postLinkFns.push(post);
            }
          }
          function getControllers(require, $element) {
            var value, retrievalMethod = 'data', optional = false;
            if (isString(require)) {
              while ((value = require.charAt(0)) == '^' || value == '?') {
                require = require.substr(1);
                if (value == '^') {
                  retrievalMethod = 'inheritedData';
                }
                optional = optional || value == '?';
              }
              value = $element[retrievalMethod]('$' + require + 'Controller');
              if (!value && !optional) {
                throw Error('No controller: ' + require);
              }
              return value;
            } else if (isArray(require)) {
              value = [];
              forEach(require, function (require) {
                value.push(getControllers(require, $element));
              });
            }
            return value;
          }
          function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
            var attrs, $element, i, ii, linkFn, controller;
            if (compileNode === linkNode) {
              attrs = templateAttrs;
            } else {
              attrs = shallowCopy(templateAttrs, new Attributes(jqLite(linkNode), templateAttrs.$attr));
            }
            $element = attrs.$$element;
            if (newIsolateScopeDirective) {
              var LOCAL_REGEXP = /^\s*([@=&])\s*(\w*)\s*$/;
              var parentScope = scope.$parent || scope;
              forEach(newIsolateScopeDirective.scope, function (definiton, scopeName) {
                var match = definiton.match(LOCAL_REGEXP) || [], attrName = match[2] || scopeName, mode = match[1], lastValue, parentGet, parentSet;
                scope.$$isolateBindings[scopeName] = mode + attrName;
                switch (mode) {
                case '@': {
                    attrs.$observe(attrName, function (value) {
                      scope[scopeName] = value;
                    });
                    attrs.$$observers[attrName].$$scope = parentScope;
                    break;
                  }
                case '=': {
                    parentGet = $parse(attrs[attrName]);
                    parentSet = parentGet.assign || function () {
                      lastValue = scope[scopeName] = parentGet(parentScope);
                      throw Error(NON_ASSIGNABLE_MODEL_EXPRESSION + attrs[attrName] + ' (directive: ' + newIsolateScopeDirective.name + ')');
                    };
                    lastValue = scope[scopeName] = parentGet(parentScope);
                    scope.$watch(function parentValueWatch() {
                      var parentValue = parentGet(parentScope);
                      if (parentValue !== scope[scopeName]) {
                        if (parentValue !== lastValue) {
                          lastValue = scope[scopeName] = parentValue;
                        } else {
                          parentSet(parentScope, parentValue = lastValue = scope[scopeName]);
                        }
                      }
                      return parentValue;
                    });
                    break;
                  }
                case '&': {
                    parentGet = $parse(attrs[attrName]);
                    scope[scopeName] = function (locals) {
                      return parentGet(parentScope, locals);
                    };
                    break;
                  }
                default: {
                    throw Error('Invalid isolate scope definition for directive ' + newIsolateScopeDirective.name + ': ' + definiton);
                  }
                }
              });
            }
            if (controllerDirectives) {
              forEach(controllerDirectives, function (directive) {
                var locals = {
                    $scope: scope,
                    $element: $element,
                    $attrs: attrs,
                    $transclude: boundTranscludeFn
                  };
                controller = directive.controller;
                if (controller == '@') {
                  controller = attrs[directive.name];
                }
                $element.data('$' + directive.name + 'Controller', $controller(controller, locals));
              });
            }
            for (i = 0, ii = preLinkFns.length; i < ii; i++) {
              try {
                linkFn = preLinkFns[i];
                linkFn(scope, $element, attrs, linkFn.require && getControllers(linkFn.require, $element));
              } catch (e) {
                $exceptionHandler(e, startingTag($element));
              }
            }
            childLinkFn && childLinkFn(scope, linkNode.childNodes, undefined, boundTranscludeFn);
            for (i = 0, ii = postLinkFns.length; i < ii; i++) {
              try {
                linkFn = postLinkFns[i];
                linkFn(scope, $element, attrs, linkFn.require && getControllers(linkFn.require, $element));
              } catch (e) {
                $exceptionHandler(e, startingTag($element));
              }
            }
          }
        }
        function addDirective(tDirectives, name, location, maxPriority) {
          var match = false;
          if (hasDirectives.hasOwnProperty(name)) {
            for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {
              try {
                directive = directives[i];
                if ((maxPriority === undefined || maxPriority > directive.priority) && directive.restrict.indexOf(location) != -1) {
                  tDirectives.push(directive);
                  match = true;
                }
              } catch (e) {
                $exceptionHandler(e);
              }
            }
          }
          return match;
        }
        function mergeTemplateAttributes(dst, src) {
          var srcAttr = src.$attr, dstAttr = dst.$attr, $element = dst.$$element;
          forEach(dst, function (value, key) {
            if (key.charAt(0) != '$') {
              if (src[key]) {
                value += (key === 'style' ? ';' : ' ') + src[key];
              }
              dst.$set(key, value, true, srcAttr[key]);
            }
          });
          forEach(src, function (value, key) {
            if (key == 'class') {
              safeAddClass($element, value);
              dst['class'] = (dst['class'] ? dst['class'] + ' ' : '') + value;
            } else if (key == 'style') {
              $element.attr('style', $element.attr('style') + ';' + value);
            } else if (key.charAt(0) != '$' && !dst.hasOwnProperty(key)) {
              dst[key] = value;
              dstAttr[key] = srcAttr[key];
            }
          });
        }
        function compileTemplateUrl(directives, beforeTemplateNodeLinkFn, $compileNode, tAttrs, $rootElement, replace, childTranscludeFn) {
          var linkQueue = [], afterTemplateNodeLinkFn, afterTemplateChildLinkFn, beforeTemplateCompileNode = $compileNode[0], origAsyncDirective = directives.shift(), derivedSyncDirective = extend({}, origAsyncDirective, {
              controller: null,
              templateUrl: null,
              transclude: null,
              scope: null
            });
          $compileNode.html('');
          $http.get(origAsyncDirective.templateUrl, { cache: $templateCache }).success(function (content) {
            var compileNode, tempTemplateAttrs, $template;
            content = denormalizeTemplate(content);
            if (replace) {
              $template = jqLite('<div>' + trim(content) + '</div>').contents();
              compileNode = $template[0];
              if ($template.length != 1 || compileNode.nodeType !== 1) {
                throw new Error(MULTI_ROOT_TEMPLATE_ERROR + content);
              }
              tempTemplateAttrs = { $attr: {} };
              replaceWith($rootElement, $compileNode, compileNode);
              collectDirectives(compileNode, directives, tempTemplateAttrs);
              mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
            } else {
              compileNode = beforeTemplateCompileNode;
              $compileNode.html(content);
            }
            directives.unshift(derivedSyncDirective);
            afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn);
            afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
            while (linkQueue.length) {
              var controller = linkQueue.pop(), linkRootElement = linkQueue.pop(), beforeTemplateLinkNode = linkQueue.pop(), scope = linkQueue.pop(), linkNode = compileNode;
              if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                linkNode = JQLiteClone(compileNode);
                replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
              }
              afterTemplateNodeLinkFn(function () {
                beforeTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, controller);
              }, scope, linkNode, $rootElement, controller);
            }
            linkQueue = null;
          }).error(function (response, code, headers, config) {
            throw Error('Failed to load template: ' + config.url);
          });
          return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, controller) {
            if (linkQueue) {
              linkQueue.push(scope);
              linkQueue.push(node);
              linkQueue.push(rootElement);
              linkQueue.push(controller);
            } else {
              afterTemplateNodeLinkFn(function () {
                beforeTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, controller);
              }, scope, node, rootElement, controller);
            }
          };
        }
        function byPriority(a, b) {
          return b.priority - a.priority;
        }
        function assertNoDuplicate(what, previousDirective, directive, element) {
          if (previousDirective) {
            throw Error('Multiple directives [' + previousDirective.name + ', ' + directive.name + '] asking for ' + what + ' on: ' + startingTag(element));
          }
        }
        function addTextInterpolateDirective(directives, text) {
          var interpolateFn = $interpolate(text, true);
          if (interpolateFn) {
            directives.push({
              priority: 0,
              compile: valueFn(function textInterpolateLinkFn(scope, node) {
                var parent = node.parent(), bindings = parent.data('$binding') || [];
                bindings.push(interpolateFn);
                safeAddClass(parent.data('$binding', bindings), 'ng-binding');
                scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                  node[0].nodeValue = value;
                });
              })
            });
          }
        }
        function addAttrInterpolateDirective(node, directives, value, name) {
          var interpolateFn = $interpolate(value, true);
          if (!interpolateFn)
            return;
          directives.push({
            priority: 100,
            compile: valueFn(function attrInterpolateLinkFn(scope, element, attr) {
              var $$observers = attr.$$observers || (attr.$$observers = {});
              if (name === 'class') {
                interpolateFn = $interpolate(attr[name], true);
              }
              attr[name] = undefined;
              ($$observers[name] || ($$observers[name] = [])).$$inter = true;
              (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function interpolateFnWatchAction(value) {
                attr.$set(name, value);
              });
            })
          });
        }
        function replaceWith($rootElement, $element, newNode) {
          var oldNode = $element[0], parent = oldNode.parentNode, i, ii;
          if ($rootElement) {
            for (i = 0, ii = $rootElement.length; i < ii; i++) {
              if ($rootElement[i] == oldNode) {
                $rootElement[i] = newNode;
                break;
              }
            }
          }
          if (parent) {
            parent.replaceChild(newNode, oldNode);
          }
          newNode[jqLite.expando] = oldNode[jqLite.expando];
          $element[0] = newNode;
        }
      }
    ];
  }
  var PREFIX_REGEXP = /^(x[\:\-_]|data[\:\-_])/i;
  function directiveNormalize(name) {
    return camelCase(name.replace(PREFIX_REGEXP, ''));
  }
  function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {
  }
  function directiveLinkingFn(nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn) {
  }
  function $ControllerProvider() {
    var controllers = {};
    this.register = function (name, constructor) {
      if (isObject(name)) {
        extend(controllers, name);
      } else {
        controllers[name] = constructor;
      }
    };
    this.$get = [
      '$injector',
      '$window',
      function ($injector, $window) {
        return function (constructor, locals) {
          if (isString(constructor)) {
            var name = constructor;
            constructor = controllers.hasOwnProperty(name) ? controllers[name] : getter(locals.$scope, name, true) || getter($window, name, true);
            assertArgFn(constructor, name, true);
          }
          return $injector.instantiate(constructor, locals);
        };
      }
    ];
  }
  function $DocumentProvider() {
    this.$get = [
      '$window',
      function (window) {
        return jqLite(window.document);
      }
    ];
  }
  function $ExceptionHandlerProvider() {
    this.$get = [
      '$log',
      function ($log) {
        return function (exception, cause) {
          $log.error.apply($log, arguments);
        };
      }
    ];
  }
  function $InterpolateProvider() {
    var startSymbol = '{{';
    var endSymbol = '}}';
    this.startSymbol = function (value) {
      if (value) {
        startSymbol = value;
        return this;
      } else {
        return startSymbol;
      }
    };
    this.endSymbol = function (value) {
      if (value) {
        endSymbol = value;
        return this;
      } else {
        return endSymbol;
      }
    };
    this.$get = [
      '$parse',
      function ($parse) {
        var startSymbolLength = startSymbol.length, endSymbolLength = endSymbol.length;
        function $interpolate(text, mustHaveExpression) {
          var startIndex, endIndex, index = 0, parts = [], length = text.length, hasInterpolation = false, fn, exp, concat = [];
          while (index < length) {
            if ((startIndex = text.indexOf(startSymbol, index)) != -1 && (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1) {
              index != startIndex && parts.push(text.substring(index, startIndex));
              parts.push(fn = $parse(exp = text.substring(startIndex + startSymbolLength, endIndex)));
              fn.exp = exp;
              index = endIndex + endSymbolLength;
              hasInterpolation = true;
            } else {
              index != length && parts.push(text.substring(index));
              index = length;
            }
          }
          if (!(length = parts.length)) {
            parts.push('');
            length = 1;
          }
          if (!mustHaveExpression || hasInterpolation) {
            concat.length = length;
            fn = function (context) {
              for (var i = 0, ii = length, part; i < ii; i++) {
                if (typeof (part = parts[i]) == 'function') {
                  part = part(context);
                  if (part == null || part == undefined) {
                    part = '';
                  } else if (typeof part != 'string') {
                    part = toJson(part);
                  }
                }
                concat[i] = part;
              }
              return concat.join('');
            };
            fn.exp = text;
            fn.parts = parts;
            return fn;
          }
        }
        $interpolate.startSymbol = function () {
          return startSymbol;
        };
        $interpolate.endSymbol = function () {
          return endSymbol;
        };
        return $interpolate;
      }
    ];
  }
  var URL_MATCH = /^([^:]+):\/\/(\w+:{0,1}\w*@)?(\{?[\w\.-]*\}?)(:([0-9]+))?(\/[^\?#]*)?(\?([^#]*))?(#(.*))?$/, PATH_MATCH = /^([^\?#]*)?(\?([^#]*))?(#(.*))?$/, HASH_MATCH = PATH_MATCH, DEFAULT_PORTS = {
      'http': 80,
      'https': 443,
      'ftp': 21
    };
  function encodePath(path) {
    var segments = path.split('/'), i = segments.length;
    while (i--) {
      segments[i] = encodeUriSegment(segments[i]);
    }
    return segments.join('/');
  }
  function stripHash(url) {
    return url.split('#')[0];
  }
  function matchUrl(url, obj) {
    var match = URL_MATCH.exec(url);
    match = {
      protocol: match[1],
      host: match[3],
      port: int(match[5]) || DEFAULT_PORTS[match[1]] || null,
      path: match[6] || '/',
      search: match[8],
      hash: match[10]
    };
    if (obj) {
      obj.$$protocol = match.protocol;
      obj.$$host = match.host;
      obj.$$port = match.port;
    }
    return match;
  }
  function composeProtocolHostPort(protocol, host, port) {
    return protocol + '://' + host + (port == DEFAULT_PORTS[protocol] ? '' : ':' + port);
  }
  function pathPrefixFromBase(basePath) {
    return basePath.substr(0, basePath.lastIndexOf('/'));
  }
  function convertToHtml5Url(url, basePath, hashPrefix) {
    var match = matchUrl(url);
    if (decodeURIComponent(match.path) != basePath || isUndefined(match.hash) || match.hash.indexOf(hashPrefix) !== 0) {
      return url;
    } else {
      return composeProtocolHostPort(match.protocol, match.host, match.port) + pathPrefixFromBase(basePath) + match.hash.substr(hashPrefix.length);
    }
  }
  function convertToHashbangUrl(url, basePath, hashPrefix) {
    var match = matchUrl(url);
    if (decodeURIComponent(match.path) == basePath && !isUndefined(match.hash) && match.hash.indexOf(hashPrefix) === 0) {
      return url;
    } else {
      var search = match.search && '?' + match.search || '', hash = match.hash && '#' + match.hash || '', pathPrefix = pathPrefixFromBase(basePath), path = match.path.substr(pathPrefix.length);
      if (match.path.indexOf(pathPrefix) !== 0) {
        throw Error('Invalid url "' + url + '", missing path prefix "' + pathPrefix + '" !');
      }
      return composeProtocolHostPort(match.protocol, match.host, match.port) + basePath + '#' + hashPrefix + path + search + hash;
    }
  }
  function LocationUrl(url, pathPrefix, appBaseUrl) {
    pathPrefix = pathPrefix || '';
    this.$$parse = function (newAbsoluteUrl) {
      var match = matchUrl(newAbsoluteUrl, this);
      if (match.path.indexOf(pathPrefix) !== 0) {
        throw Error('Invalid url "' + newAbsoluteUrl + '", missing path prefix "' + pathPrefix + '" !');
      }
      this.$$path = decodeURIComponent(match.path.substr(pathPrefix.length));
      this.$$search = parseKeyValue(match.search);
      this.$$hash = match.hash && decodeURIComponent(match.hash) || '';
      this.$$compose();
    };
    this.$$compose = function () {
      var search = toKeyValue(this.$$search), hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
      this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
      this.$$absUrl = composeProtocolHostPort(this.$$protocol, this.$$host, this.$$port) + pathPrefix + this.$$url;
    };
    this.$$rewriteAppUrl = function (absoluteLinkUrl) {
      if (absoluteLinkUrl.indexOf(appBaseUrl) == 0) {
        return absoluteLinkUrl;
      }
    };
    this.$$parse(url);
  }
  function LocationHashbangUrl(url, hashPrefix, appBaseUrl) {
    var basePath;
    this.$$parse = function (url) {
      var match = matchUrl(url, this);
      if (match.hash && match.hash.indexOf(hashPrefix) !== 0) {
        throw Error('Invalid url "' + url + '", missing hash prefix "' + hashPrefix + '" !');
      }
      basePath = match.path + (match.search ? '?' + match.search : '');
      match = HASH_MATCH.exec((match.hash || '').substr(hashPrefix.length));
      if (match[1]) {
        this.$$path = (match[1].charAt(0) == '/' ? '' : '/') + decodeURIComponent(match[1]);
      } else {
        this.$$path = '';
      }
      this.$$search = parseKeyValue(match[3]);
      this.$$hash = match[5] && decodeURIComponent(match[5]) || '';
      this.$$compose();
    };
    this.$$compose = function () {
      var search = toKeyValue(this.$$search), hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
      this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
      this.$$absUrl = composeProtocolHostPort(this.$$protocol, this.$$host, this.$$port) + basePath + (this.$$url ? '#' + hashPrefix + this.$$url : '');
    };
    this.$$rewriteAppUrl = function (absoluteLinkUrl) {
      if (absoluteLinkUrl.indexOf(appBaseUrl) == 0) {
        return absoluteLinkUrl;
      }
    };
    this.$$parse(url);
  }
  LocationUrl.prototype = {
    $$replace: false,
    absUrl: locationGetter('$$absUrl'),
    url: function (url, replace) {
      if (isUndefined(url))
        return this.$$url;
      var match = PATH_MATCH.exec(url);
      if (match[1])
        this.path(decodeURIComponent(match[1]));
      if (match[2] || match[1])
        this.search(match[3] || '');
      this.hash(match[5] || '', replace);
      return this;
    },
    protocol: locationGetter('$$protocol'),
    host: locationGetter('$$host'),
    port: locationGetter('$$port'),
    path: locationGetterSetter('$$path', function (path) {
      return path.charAt(0) == '/' ? path : '/' + path;
    }),
    search: function (search, paramValue) {
      if (isUndefined(search))
        return this.$$search;
      if (isDefined(paramValue)) {
        if (paramValue === null) {
          delete this.$$search[search];
        } else {
          this.$$search[search] = paramValue;
        }
      } else {
        this.$$search = isString(search) ? parseKeyValue(search) : search;
      }
      this.$$compose();
      return this;
    },
    hash: locationGetterSetter('$$hash', identity),
    replace: function () {
      this.$$replace = true;
      return this;
    }
  };
  LocationHashbangUrl.prototype = inherit(LocationUrl.prototype);
  function LocationHashbangInHtml5Url(url, hashPrefix, appBaseUrl, baseExtra) {
    LocationHashbangUrl.apply(this, arguments);
    this.$$rewriteAppUrl = function (absoluteLinkUrl) {
      if (absoluteLinkUrl.indexOf(appBaseUrl) == 0) {
        return appBaseUrl + baseExtra + '#' + hashPrefix + absoluteLinkUrl.substr(appBaseUrl.length);
      }
    };
  }
  LocationHashbangInHtml5Url.prototype = inherit(LocationHashbangUrl.prototype);
  function locationGetter(property) {
    return function () {
      return this[property];
    };
  }
  function locationGetterSetter(property, preprocess) {
    return function (value) {
      if (isUndefined(value))
        return this[property];
      this[property] = preprocess(value);
      this.$$compose();
      return this;
    };
  }
  function $LocationProvider() {
    var hashPrefix = '', html5Mode = false;
    this.hashPrefix = function (prefix) {
      if (isDefined(prefix)) {
        hashPrefix = prefix;
        return this;
      } else {
        return hashPrefix;
      }
    };
    this.html5Mode = function (mode) {
      if (isDefined(mode)) {
        html5Mode = mode;
        return this;
      } else {
        return html5Mode;
      }
    };
    this.$get = [
      '$rootScope',
      '$browser',
      '$sniffer',
      '$rootElement',
      function ($rootScope, $browser, $sniffer, $rootElement) {
        var $location, basePath, pathPrefix, initUrl = $browser.url(), initUrlParts = matchUrl(initUrl), appBaseUrl;
        if (html5Mode) {
          basePath = $browser.baseHref() || '/';
          pathPrefix = pathPrefixFromBase(basePath);
          appBaseUrl = composeProtocolHostPort(initUrlParts.protocol, initUrlParts.host, initUrlParts.port) + pathPrefix + '/';
          if ($sniffer.history) {
            $location = new LocationUrl(convertToHtml5Url(initUrl, basePath, hashPrefix), pathPrefix, appBaseUrl);
          } else {
            $location = new LocationHashbangInHtml5Url(convertToHashbangUrl(initUrl, basePath, hashPrefix), hashPrefix, appBaseUrl, basePath.substr(pathPrefix.length + 1));
          }
        } else {
          appBaseUrl = composeProtocolHostPort(initUrlParts.protocol, initUrlParts.host, initUrlParts.port) + (initUrlParts.path || '') + (initUrlParts.search ? '?' + initUrlParts.search : '') + '#' + hashPrefix + '/';
          $location = new LocationHashbangUrl(initUrl, hashPrefix, appBaseUrl);
        }
        $rootElement.bind('click', function (event) {
          if (event.ctrlKey || event.metaKey || event.which == 2)
            return;
          var elm = jqLite(event.target);
          while (lowercase(elm[0].nodeName) !== 'a') {
            if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0])
              return;
          }
          var absHref = elm.prop('href'), rewrittenUrl = $location.$$rewriteAppUrl(absHref);
          if (absHref && !elm.attr('target') && rewrittenUrl) {
            $location.$$parse(rewrittenUrl);
            $rootScope.$apply();
            event.preventDefault();
            window.angular['ff-684208-preventDefault'] = true;
          }
        });
        if ($location.absUrl() != initUrl) {
          $browser.url($location.absUrl(), true);
        }
        $browser.onUrlChange(function (newUrl) {
          if ($location.absUrl() != newUrl) {
            if ($rootScope.$broadcast('$locationChangeStart', newUrl, $location.absUrl()).defaultPrevented) {
              $browser.url($location.absUrl());
              return;
            }
            $rootScope.$evalAsync(function () {
              var oldUrl = $location.absUrl();
              $location.$$parse(newUrl);
              afterLocationChange(oldUrl);
            });
            if (!$rootScope.$$phase)
              $rootScope.$digest();
          }
        });
        var changeCounter = 0;
        $rootScope.$watch(function $locationWatch() {
          var oldUrl = $browser.url();
          var currentReplace = $location.$$replace;
          if (!changeCounter || oldUrl != $location.absUrl()) {
            changeCounter++;
            $rootScope.$evalAsync(function () {
              if ($rootScope.$broadcast('$locationChangeStart', $location.absUrl(), oldUrl).defaultPrevented) {
                $location.$$parse(oldUrl);
              } else {
                $browser.url($location.absUrl(), currentReplace);
                afterLocationChange(oldUrl);
              }
            });
          }
          $location.$$replace = false;
          return changeCounter;
        });
        return $location;
        function afterLocationChange(oldUrl) {
          $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl);
        }
      }
    ];
  }
  function $LogProvider() {
    this.$get = [
      '$window',
      function ($window) {
        return {
          log: consoleLog('log'),
          warn: consoleLog('warn'),
          info: consoleLog('info'),
          error: consoleLog('error')
        };
        function formatError(arg) {
          if (arg instanceof Error) {
            if (arg.stack) {
              arg = arg.message && arg.stack.indexOf(arg.message) === -1 ? 'Error: ' + arg.message + '\n' + arg.stack : arg.stack;
            } else if (arg.sourceURL) {
              arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;
            }
          }
          return arg;
        }
        function consoleLog(type) {
          var console = $window.console || {}, logFn = console[type] || console.log || noop;
          if (logFn.apply) {
            return function () {
              var args = [];
              forEach(arguments, function (arg) {
                args.push(formatError(arg));
              });
              return logFn.apply(console, args);
            };
          }
          return function (arg1, arg2) {
            logFn(arg1, arg2);
          };
        }
      }
    ];
  }
  var OPERATORS = {
      'null': function () {
        return null;
      },
      'true': function () {
        return true;
      },
      'false': function () {
        return false;
      },
      undefined: noop,
      '+': function (self, locals, a, b) {
        a = a(self, locals);
        b = b(self, locals);
        if (isDefined(a)) {
          if (isDefined(b)) {
            return a + b;
          }
          return a;
        }
        return isDefined(b) ? b : undefined;
      },
      '-': function (self, locals, a, b) {
        a = a(self, locals);
        b = b(self, locals);
        return (isDefined(a) ? a : 0) - (isDefined(b) ? b : 0);
      },
      '*': function (self, locals, a, b) {
        return a(self, locals) * b(self, locals);
      },
      '/': function (self, locals, a, b) {
        return a(self, locals) / b(self, locals);
      },
      '%': function (self, locals, a, b) {
        return a(self, locals) % b(self, locals);
      },
      '^': function (self, locals, a, b) {
        return a(self, locals) ^ b(self, locals);
      },
      '=': noop,
      '==': function (self, locals, a, b) {
        return a(self, locals) == b(self, locals);
      },
      '!=': function (self, locals, a, b) {
        return a(self, locals) != b(self, locals);
      },
      '<': function (self, locals, a, b) {
        return a(self, locals) < b(self, locals);
      },
      '>': function (self, locals, a, b) {
        return a(self, locals) > b(self, locals);
      },
      '<=': function (self, locals, a, b) {
        return a(self, locals) <= b(self, locals);
      },
      '>=': function (self, locals, a, b) {
        return a(self, locals) >= b(self, locals);
      },
      '&&': function (self, locals, a, b) {
        return a(self, locals) && b(self, locals);
      },
      '||': function (self, locals, a, b) {
        return a(self, locals) || b(self, locals);
      },
      '&': function (self, locals, a, b) {
        return a(self, locals) & b(self, locals);
      },
      '|': function (self, locals, a, b) {
        return b(self, locals)(self, locals, a(self, locals));
      },
      '!': function (self, locals, a) {
        return !a(self, locals);
      }
    };
  var ESCAPE = {
      'n': '\n',
      'f': '\f',
      'r': '\r',
      't': '\t',
      'v': '\x0B',
      '\'': '\'',
      '"': '"'
    };
  function lex(text, csp) {
    var tokens = [], token, index = 0, json = [], ch, lastCh = ':';
    while (index < text.length) {
      ch = text.charAt(index);
      if (is('"\'')) {
        readString(ch);
      } else if (isNumber(ch) || is('.') && isNumber(peek())) {
        readNumber();
      } else if (isIdent(ch)) {
        readIdent();
        if (was('{,') && json[0] == '{' && (token = tokens[tokens.length - 1])) {
          token.json = token.text.indexOf('.') == -1;
        }
      } else if (is('(){}[].,;:')) {
        tokens.push({
          index: index,
          text: ch,
          json: was(':[,') && is('{[') || is('}]:,')
        });
        if (is('{['))
          json.unshift(ch);
        if (is('}]'))
          json.shift();
        index++;
      } else if (isWhitespace(ch)) {
        index++;
        continue;
      } else {
        var ch2 = ch + peek(), fn = OPERATORS[ch], fn2 = OPERATORS[ch2];
        if (fn2) {
          tokens.push({
            index: index,
            text: ch2,
            fn: fn2
          });
          index += 2;
        } else if (fn) {
          tokens.push({
            index: index,
            text: ch,
            fn: fn,
            json: was('[,:') && is('+-')
          });
          index += 1;
        } else {
          throwError('Unexpected next character ', index, index + 1);
        }
      }
      lastCh = ch;
    }
    return tokens;
    function is(chars) {
      return chars.indexOf(ch) != -1;
    }
    function was(chars) {
      return chars.indexOf(lastCh) != -1;
    }
    function peek() {
      return index + 1 < text.length ? text.charAt(index + 1) : false;
    }
    function isNumber(ch) {
      return '0' <= ch && ch <= '9';
    }
    function isWhitespace(ch) {
      return ch == ' ' || ch == '\r' || ch == '\t' || ch == '\n' || ch == '\x0B' || ch == '\xa0';
    }
    function isIdent(ch) {
      return 'a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || '_' == ch || ch == '$';
    }
    function isExpOperator(ch) {
      return ch == '-' || ch == '+' || isNumber(ch);
    }
    function throwError(error, start, end) {
      end = end || index;
      throw Error('Lexer Error: ' + error + ' at column' + (isDefined(start) ? 's ' + start + '-' + index + ' [' + text.substring(start, end) + ']' : ' ' + end) + ' in expression [' + text + '].');
    }
    function readNumber() {
      var number = '';
      var start = index;
      while (index < text.length) {
        var ch = lowercase(text.charAt(index));
        if (ch == '.' || isNumber(ch)) {
          number += ch;
        } else {
          var peekCh = peek();
          if (ch == 'e' && isExpOperator(peekCh)) {
            number += ch;
          } else if (isExpOperator(ch) && peekCh && isNumber(peekCh) && number.charAt(number.length - 1) == 'e') {
            number += ch;
          } else if (isExpOperator(ch) && (!peekCh || !isNumber(peekCh)) && number.charAt(number.length - 1) == 'e') {
            throwError('Invalid exponent');
          } else {
            break;
          }
        }
        index++;
      }
      number = 1 * number;
      tokens.push({
        index: start,
        text: number,
        json: true,
        fn: function () {
          return number;
        }
      });
    }
    function readIdent() {
      var ident = '', start = index, lastDot, peekIndex, methodName, ch;
      while (index < text.length) {
        ch = text.charAt(index);
        if (ch == '.' || isIdent(ch) || isNumber(ch)) {
          if (ch == '.')
            lastDot = index;
          ident += ch;
        } else {
          break;
        }
        index++;
      }
      if (lastDot) {
        peekIndex = index;
        while (peekIndex < text.length) {
          ch = text.charAt(peekIndex);
          if (ch == '(') {
            methodName = ident.substr(lastDot - start + 1);
            ident = ident.substr(0, lastDot - start);
            index = peekIndex;
            break;
          }
          if (isWhitespace(ch)) {
            peekIndex++;
          } else {
            break;
          }
        }
      }
      var token = {
          index: start,
          text: ident
        };
      if (OPERATORS.hasOwnProperty(ident)) {
        token.fn = token.json = OPERATORS[ident];
      } else {
        var getter = getterFn(ident, csp);
        token.fn = extend(function (self, locals) {
          return getter(self, locals);
        }, {
          assign: function (self, value) {
            return setter(self, ident, value);
          }
        });
      }
      tokens.push(token);
      if (methodName) {
        tokens.push({
          index: lastDot,
          text: '.',
          json: false
        });
        tokens.push({
          index: lastDot + 1,
          text: methodName,
          json: false
        });
      }
    }
    function readString(quote) {
      var start = index;
      index++;
      var string = '';
      var rawString = quote;
      var escape = false;
      while (index < text.length) {
        var ch = text.charAt(index);
        rawString += ch;
        if (escape) {
          if (ch == 'u') {
            var hex = text.substring(index + 1, index + 5);
            if (!hex.match(/[\da-f]{4}/i))
              throwError('Invalid unicode escape [\\u' + hex + ']');
            index += 4;
            string += String.fromCharCode(parseInt(hex, 16));
          } else {
            var rep = ESCAPE[ch];
            if (rep) {
              string += rep;
            } else {
              string += ch;
            }
          }
          escape = false;
        } else if (ch == '\\') {
          escape = true;
        } else if (ch == quote) {
          index++;
          tokens.push({
            index: start,
            text: rawString,
            string: string,
            json: true,
            fn: function () {
              return string;
            }
          });
          return;
        } else {
          string += ch;
        }
        index++;
      }
      throwError('Unterminated quote', start);
    }
  }
  function parser(text, json, $filter, csp) {
    var ZERO = valueFn(0), value, tokens = lex(text, csp), assignment = _assignment, functionCall = _functionCall, fieldAccess = _fieldAccess, objectIndex = _objectIndex, filterChain = _filterChain;
    if (json) {
      assignment = logicalOR;
      functionCall = fieldAccess = objectIndex = filterChain = function () {
        throwError('is not valid json', {
          text: text,
          index: 0
        });
      };
      value = primary();
    } else {
      value = statements();
    }
    if (tokens.length !== 0) {
      throwError('is an unexpected token', tokens[0]);
    }
    return value;
    function throwError(msg, token) {
      throw Error('Syntax Error: Token \'' + token.text + '\' ' + msg + ' at column ' + (token.index + 1) + ' of the expression [' + text + '] starting at [' + text.substring(token.index) + '].');
    }
    function peekToken() {
      if (tokens.length === 0)
        throw Error('Unexpected end of expression: ' + text);
      return tokens[0];
    }
    function peek(e1, e2, e3, e4) {
      if (tokens.length > 0) {
        var token = tokens[0];
        var t = token.text;
        if (t == e1 || t == e2 || t == e3 || t == e4 || !e1 && !e2 && !e3 && !e4) {
          return token;
        }
      }
      return false;
    }
    function expect(e1, e2, e3, e4) {
      var token = peek(e1, e2, e3, e4);
      if (token) {
        if (json && !token.json) {
          throwError('is not valid json', token);
        }
        tokens.shift();
        return token;
      }
      return false;
    }
    function consume(e1) {
      if (!expect(e1)) {
        throwError('is unexpected, expecting [' + e1 + ']', peek());
      }
    }
    function unaryFn(fn, right) {
      return function (self, locals) {
        return fn(self, locals, right);
      };
    }
    function binaryFn(left, fn, right) {
      return function (self, locals) {
        return fn(self, locals, left, right);
      };
    }
    function statements() {
      var statements = [];
      while (true) {
        if (tokens.length > 0 && !peek('}', ')', ';', ']'))
          statements.push(filterChain());
        if (!expect(';')) {
          return statements.length == 1 ? statements[0] : function (self, locals) {
            var value;
            for (var i = 0; i < statements.length; i++) {
              var statement = statements[i];
              if (statement)
                value = statement(self, locals);
            }
            return value;
          };
        }
      }
    }
    function _filterChain() {
      var left = expression();
      var token;
      while (true) {
        if (token = expect('|')) {
          left = binaryFn(left, token.fn, filter());
        } else {
          return left;
        }
      }
    }
    function filter() {
      var token = expect();
      var fn = $filter(token.text);
      var argsFn = [];
      while (true) {
        if (token = expect(':')) {
          argsFn.push(expression());
        } else {
          var fnInvoke = function (self, locals, input) {
            var args = [input];
            for (var i = 0; i < argsFn.length; i++) {
              args.push(argsFn[i](self, locals));
            }
            return fn.apply(self, args);
          };
          return function () {
            return fnInvoke;
          };
        }
      }
    }
    function expression() {
      return assignment();
    }
    function _assignment() {
      var left = logicalOR();
      var right;
      var token;
      if (token = expect('=')) {
        if (!left.assign) {
          throwError('implies assignment but [' + text.substring(0, token.index) + '] can not be assigned to', token);
        }
        right = logicalOR();
        return function (scope, locals) {
          return left.assign(scope, right(scope, locals), locals);
        };
      } else {
        return left;
      }
    }
    function logicalOR() {
      var left = logicalAND();
      var token;
      while (true) {
        if (token = expect('||')) {
          left = binaryFn(left, token.fn, logicalAND());
        } else {
          return left;
        }
      }
    }
    function logicalAND() {
      var left = equality();
      var token;
      if (token = expect('&&')) {
        left = binaryFn(left, token.fn, logicalAND());
      }
      return left;
    }
    function equality() {
      var left = relational();
      var token;
      if (token = expect('==', '!=')) {
        left = binaryFn(left, token.fn, equality());
      }
      return left;
    }
    function relational() {
      var left = additive();
      var token;
      if (token = expect('<', '>', '<=', '>=')) {
        left = binaryFn(left, token.fn, relational());
      }
      return left;
    }
    function additive() {
      var left = multiplicative();
      var token;
      while (token = expect('+', '-')) {
        left = binaryFn(left, token.fn, multiplicative());
      }
      return left;
    }
    function multiplicative() {
      var left = unary();
      var token;
      while (token = expect('*', '/', '%')) {
        left = binaryFn(left, token.fn, unary());
      }
      return left;
    }
    function unary() {
      var token;
      if (expect('+')) {
        return primary();
      } else if (token = expect('-')) {
        return binaryFn(ZERO, token.fn, unary());
      } else if (token = expect('!')) {
        return unaryFn(token.fn, unary());
      } else {
        return primary();
      }
    }
    function primary() {
      var primary;
      if (expect('(')) {
        primary = filterChain();
        consume(')');
      } else if (expect('[')) {
        primary = arrayDeclaration();
      } else if (expect('{')) {
        primary = object();
      } else {
        var token = expect();
        primary = token.fn;
        if (!primary) {
          throwError('not a primary expression', token);
        }
      }
      var next, context;
      while (next = expect('(', '[', '.')) {
        if (next.text === '(') {
          primary = functionCall(primary, context);
          context = null;
        } else if (next.text === '[') {
          context = primary;
          primary = objectIndex(primary);
        } else if (next.text === '.') {
          context = primary;
          primary = fieldAccess(primary);
        } else {
          throwError('IMPOSSIBLE');
        }
      }
      return primary;
    }
    function _fieldAccess(object) {
      var field = expect().text;
      var getter = getterFn(field, csp);
      return extend(function (scope, locals, self) {
        return getter(self || object(scope, locals), locals);
      }, {
        assign: function (scope, value, locals) {
          return setter(object(scope, locals), field, value);
        }
      });
    }
    function _objectIndex(obj) {
      var indexFn = expression();
      consume(']');
      return extend(function (self, locals) {
        var o = obj(self, locals), i = indexFn(self, locals), v, p;
        if (!o)
          return undefined;
        v = o[i];
        if (v && v.then) {
          p = v;
          if (!('$$v' in v)) {
            p.$$v = undefined;
            p.then(function (val) {
              p.$$v = val;
            });
          }
          v = v.$$v;
        }
        return v;
      }, {
        assign: function (self, value, locals) {
          return obj(self, locals)[indexFn(self, locals)] = value;
        }
      });
    }
    function _functionCall(fn, contextGetter) {
      var argsFn = [];
      if (peekToken().text != ')') {
        do {
          argsFn.push(expression());
        } while (expect(','));
      }
      consume(')');
      return function (scope, locals) {
        var args = [], context = contextGetter ? contextGetter(scope, locals) : scope;
        for (var i = 0; i < argsFn.length; i++) {
          args.push(argsFn[i](scope, locals));
        }
        var fnPtr = fn(scope, locals, context) || noop;
        return fnPtr.apply ? fnPtr.apply(context, args) : fnPtr(args[0], args[1], args[2], args[3], args[4]);
      };
    }
    function arrayDeclaration() {
      var elementFns = [];
      if (peekToken().text != ']') {
        do {
          elementFns.push(expression());
        } while (expect(','));
      }
      consume(']');
      return function (self, locals) {
        var array = [];
        for (var i = 0; i < elementFns.length; i++) {
          array.push(elementFns[i](self, locals));
        }
        return array;
      };
    }
    function object() {
      var keyValues = [];
      if (peekToken().text != '}') {
        do {
          var token = expect(), key = token.string || token.text;
          consume(':');
          var value = expression();
          keyValues.push({
            key: key,
            value: value
          });
        } while (expect(','));
      }
      consume('}');
      return function (self, locals) {
        var object = {};
        for (var i = 0; i < keyValues.length; i++) {
          var keyValue = keyValues[i];
          object[keyValue.key] = keyValue.value(self, locals);
        }
        return object;
      };
    }
  }
  function setter(obj, path, setValue) {
    var element = path.split('.');
    for (var i = 0; element.length > 1; i++) {
      var key = element.shift();
      var propertyObj = obj[key];
      if (!propertyObj) {
        propertyObj = {};
        obj[key] = propertyObj;
      }
      obj = propertyObj;
    }
    obj[element.shift()] = setValue;
    return setValue;
  }
  function getter(obj, path, bindFnToScope) {
    if (!path)
      return obj;
    var keys = path.split('.');
    var key;
    var lastInstance = obj;
    var len = keys.length;
    for (var i = 0; i < len; i++) {
      key = keys[i];
      if (obj) {
        obj = (lastInstance = obj)[key];
      }
    }
    if (!bindFnToScope && isFunction(obj)) {
      return bind(lastInstance, obj);
    }
    return obj;
  }
  var getterFnCache = {};
  function cspSafeGetterFn(key0, key1, key2, key3, key4) {
    return function (scope, locals) {
      var pathVal = locals && locals.hasOwnProperty(key0) ? locals : scope, promise;
      if (pathVal === null || pathVal === undefined)
        return pathVal;
      pathVal = pathVal[key0];
      if (pathVal && pathVal.then) {
        if (!('$$v' in pathVal)) {
          promise = pathVal;
          promise.$$v = undefined;
          promise.then(function (val) {
            promise.$$v = val;
          });
        }
        pathVal = pathVal.$$v;
      }
      if (!key1 || pathVal === null || pathVal === undefined)
        return pathVal;
      pathVal = pathVal[key1];
      if (pathVal && pathVal.then) {
        if (!('$$v' in pathVal)) {
          promise = pathVal;
          promise.$$v = undefined;
          promise.then(function (val) {
            promise.$$v = val;
          });
        }
        pathVal = pathVal.$$v;
      }
      if (!key2 || pathVal === null || pathVal === undefined)
        return pathVal;
      pathVal = pathVal[key2];
      if (pathVal && pathVal.then) {
        if (!('$$v' in pathVal)) {
          promise = pathVal;
          promise.$$v = undefined;
          promise.then(function (val) {
            promise.$$v = val;
          });
        }
        pathVal = pathVal.$$v;
      }
      if (!key3 || pathVal === null || pathVal === undefined)
        return pathVal;
      pathVal = pathVal[key3];
      if (pathVal && pathVal.then) {
        if (!('$$v' in pathVal)) {
          promise = pathVal;
          promise.$$v = undefined;
          promise.then(function (val) {
            promise.$$v = val;
          });
        }
        pathVal = pathVal.$$v;
      }
      if (!key4 || pathVal === null || pathVal === undefined)
        return pathVal;
      pathVal = pathVal[key4];
      if (pathVal && pathVal.then) {
        if (!('$$v' in pathVal)) {
          promise = pathVal;
          promise.$$v = undefined;
          promise.then(function (val) {
            promise.$$v = val;
          });
        }
        pathVal = pathVal.$$v;
      }
      return pathVal;
    };
  }
  function getterFn(path, csp) {
    if (getterFnCache.hasOwnProperty(path)) {
      return getterFnCache[path];
    }
    var pathKeys = path.split('.'), pathKeysLength = pathKeys.length, fn;
    if (csp) {
      fn = pathKeysLength < 6 ? cspSafeGetterFn(pathKeys[0], pathKeys[1], pathKeys[2], pathKeys[3], pathKeys[4]) : function (scope, locals) {
        var i = 0, val;
        do {
          val = cspSafeGetterFn(pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++])(scope, locals);
          locals = undefined;
          scope = val;
        } while (i < pathKeysLength);
        return val;
      };
    } else {
      var code = 'var l, fn, p;\n';
      forEach(pathKeys, function (key, index) {
        code += 'if(s === null || s === undefined) return s;\n' + 'l=s;\n' + 's=' + (index ? 's' : '((k&&k.hasOwnProperty("' + key + '"))?k:s)') + '["' + key + '"]' + ';\n' + 'if (s && s.then) {\n' + ' if (!("$$v" in s)) {\n' + ' p=s;\n' + ' p.$$v = undefined;\n' + ' p.then(function(v) {p.$$v=v;});\n' + '}\n' + ' s=s.$$v\n' + '}\n';
      });
      code += 'return s;';
      fn = Function('s', 'k', code);
      fn.toString = function () {
        return code;
      };
    }
    return getterFnCache[path] = fn;
  }
  function $ParseProvider() {
    var cache = {};
    this.$get = [
      '$filter',
      '$sniffer',
      function ($filter, $sniffer) {
        return function (exp) {
          switch (typeof exp) {
          case 'string':
            return cache.hasOwnProperty(exp) ? cache[exp] : cache[exp] = parser(exp, false, $filter, $sniffer.csp);
          case 'function':
            return exp;
          default:
            return noop;
          }
        };
      }
    ];
  }
  function $QProvider() {
    this.$get = [
      '$rootScope',
      '$exceptionHandler',
      function ($rootScope, $exceptionHandler) {
        return qFactory(function (callback) {
          $rootScope.$evalAsync(callback);
        }, $exceptionHandler);
      }
    ];
  }
  function qFactory(nextTick, exceptionHandler) {
    var defer = function () {
      var pending = [], value, deferred;
      deferred = {
        resolve: function (val) {
          if (pending) {
            var callbacks = pending;
            pending = undefined;
            value = ref(val);
            if (callbacks.length) {
              nextTick(function () {
                var callback;
                for (var i = 0, ii = callbacks.length; i < ii; i++) {
                  callback = callbacks[i];
                  value.then(callback[0], callback[1]);
                }
              });
            }
          }
        },
        reject: function (reason) {
          deferred.resolve(reject(reason));
        },
        promise: {
          then: function (callback, errback) {
            var result = defer();
            var wrappedCallback = function (value) {
              try {
                result.resolve((callback || defaultCallback)(value));
              } catch (e) {
                exceptionHandler(e);
                result.reject(e);
              }
            };
            var wrappedErrback = function (reason) {
              try {
                result.resolve((errback || defaultErrback)(reason));
              } catch (e) {
                exceptionHandler(e);
                result.reject(e);
              }
            };
            if (pending) {
              pending.push([
                wrappedCallback,
                wrappedErrback
              ]);
            } else {
              value.then(wrappedCallback, wrappedErrback);
            }
            return result.promise;
          }
        }
      };
      return deferred;
    };
    var ref = function (value) {
      if (value && value.then)
        return value;
      return {
        then: function (callback) {
          var result = defer();
          nextTick(function () {
            result.resolve(callback(value));
          });
          return result.promise;
        }
      };
    };
    var reject = function (reason) {
      return {
        then: function (callback, errback) {
          var result = defer();
          nextTick(function () {
            result.resolve((errback || defaultErrback)(reason));
          });
          return result.promise;
        }
      };
    };
    var when = function (value, callback, errback) {
      var result = defer(), done;
      var wrappedCallback = function (value) {
        try {
          return (callback || defaultCallback)(value);
        } catch (e) {
          exceptionHandler(e);
          return reject(e);
        }
      };
      var wrappedErrback = function (reason) {
        try {
          return (errback || defaultErrback)(reason);
        } catch (e) {
          exceptionHandler(e);
          return reject(e);
        }
      };
      nextTick(function () {
        ref(value).then(function (value) {
          if (done)
            return;
          done = true;
          result.resolve(ref(value).then(wrappedCallback, wrappedErrback));
        }, function (reason) {
          if (done)
            return;
          done = true;
          result.resolve(wrappedErrback(reason));
        });
      });
      return result.promise;
    };
    function defaultCallback(value) {
      return value;
    }
    function defaultErrback(reason) {
      return reject(reason);
    }
    function all(promises) {
      var deferred = defer(), counter = promises.length, results = [];
      if (counter) {
        forEach(promises, function (promise, index) {
          ref(promise).then(function (value) {
            if (index in results)
              return;
            results[index] = value;
            if (!--counter)
              deferred.resolve(results);
          }, function (reason) {
            if (index in results)
              return;
            deferred.reject(reason);
          });
        });
      } else {
        deferred.resolve(results);
      }
      return deferred.promise;
    }
    return {
      defer: defer,
      reject: reject,
      when: when,
      all: all
    };
  }
  function $RouteProvider() {
    var routes = {};
    this.when = function (path, route) {
      routes[path] = extend({ reloadOnSearch: true }, route);
      if (path) {
        var redirectPath = path[path.length - 1] == '/' ? path.substr(0, path.length - 1) : path + '/';
        routes[redirectPath] = { redirectTo: path };
      }
      return this;
    };
    this.otherwise = function (params) {
      this.when(null, params);
      return this;
    };
    this.$get = [
      '$rootScope',
      '$location',
      '$routeParams',
      '$q',
      '$injector',
      '$http',
      '$templateCache',
      function ($rootScope, $location, $routeParams, $q, $injector, $http, $templateCache) {
        var forceReload = false, $route = {
            routes: routes,
            reload: function () {
              forceReload = true;
              $rootScope.$evalAsync(updateRoute);
            }
          };
        $rootScope.$on('$locationChangeSuccess', updateRoute);
        return $route;
        function switchRouteMatcher(on, when) {
          when = '^' + when.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') + '$';
          var regex = '', params = [], dst = {};
          var re = /:(\w+)/g, paramMatch, lastMatchedIndex = 0;
          while ((paramMatch = re.exec(when)) !== null) {
            regex += when.slice(lastMatchedIndex, paramMatch.index);
            regex += '([^\\/]*)';
            params.push(paramMatch[1]);
            lastMatchedIndex = re.lastIndex;
          }
          regex += when.substr(lastMatchedIndex);
          var match = on.match(new RegExp(regex));
          if (match) {
            forEach(params, function (name, index) {
              dst[name] = match[index + 1];
            });
          }
          return match ? dst : null;
        }
        function updateRoute() {
          var next = parseRoute(), last = $route.current;
          if (next && last && next.$$route === last.$$route && equals(next.pathParams, last.pathParams) && !next.reloadOnSearch && !forceReload) {
            last.params = next.params;
            copy(last.params, $routeParams);
            $rootScope.$broadcast('$routeUpdate', last);
          } else if (next || last) {
            forceReload = false;
            $rootScope.$broadcast('$routeChangeStart', next, last);
            $route.current = next;
            if (next) {
              if (next.redirectTo) {
                if (isString(next.redirectTo)) {
                  $location.path(interpolate(next.redirectTo, next.params)).search(next.params).replace();
                } else {
                  $location.url(next.redirectTo(next.pathParams, $location.path(), $location.search())).replace();
                }
              }
            }
            $q.when(next).then(function () {
              if (next) {
                var keys = [], values = [], template;
                forEach(next.resolve || {}, function (value, key) {
                  keys.push(key);
                  values.push(isString(value) ? $injector.get(value) : $injector.invoke(value));
                });
                if (isDefined(template = next.template)) {
                } else if (isDefined(template = next.templateUrl)) {
                  template = $http.get(template, { cache: $templateCache }).then(function (response) {
                    return response.data;
                  });
                }
                if (isDefined(template)) {
                  keys.push('$template');
                  values.push(template);
                }
                return $q.all(values).then(function (values) {
                  var locals = {};
                  forEach(values, function (value, index) {
                    locals[keys[index]] = value;
                  });
                  return locals;
                });
              }
            }).then(function (locals) {
              if (next == $route.current) {
                if (next) {
                  next.locals = locals;
                  copy(next.params, $routeParams);
                }
                $rootScope.$broadcast('$routeChangeSuccess', next, last);
              }
            }, function (error) {
              if (next == $route.current) {
                $rootScope.$broadcast('$routeChangeError', next, last, error);
              }
            });
          }
        }
        function parseRoute() {
          var params, match;
          forEach(routes, function (route, path) {
            if (!match && (params = switchRouteMatcher($location.path(), path))) {
              match = inherit(route, {
                params: extend({}, $location.search(), params),
                pathParams: params
              });
              match.$$route = route;
            }
          });
          return match || routes[null] && inherit(routes[null], {
            params: {},
            pathParams: {}
          });
        }
        function interpolate(string, params) {
          var result = [];
          forEach((string || '').split(':'), function (segment, i) {
            if (i == 0) {
              result.push(segment);
            } else {
              var segmentMatch = segment.match(/(\w+)(.*)/);
              var key = segmentMatch[1];
              result.push(params[key]);
              result.push(segmentMatch[2] || '');
              delete params[key];
            }
          });
          return result.join('');
        }
      }
    ];
  }
  function $RouteParamsProvider() {
    this.$get = valueFn({});
  }
  function $RootScopeProvider() {
    var TTL = 10;
    this.digestTtl = function (value) {
      if (arguments.length) {
        TTL = value;
      }
      return TTL;
    };
    this.$get = [
      '$injector',
      '$exceptionHandler',
      '$parse',
      function ($injector, $exceptionHandler, $parse) {
        function Scope() {
          this.$id = nextUid();
          this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
          this['this'] = this.$root = this;
          this.$$destroyed = false;
          this.$$asyncQueue = [];
          this.$$listeners = {};
          this.$$isolateBindings = {};
        }
        Scope.prototype = {
          $new: function (isolate) {
            var Child, child;
            if (isFunction(isolate)) {
              throw Error('API-CHANGE: Use $controller to instantiate controllers.');
            }
            if (isolate) {
              child = new Scope();
              child.$root = this.$root;
            } else {
              Child = function () {
              };
              Child.prototype = this;
              child = new Child();
              child.$id = nextUid();
            }
            child['this'] = child;
            child.$$listeners = {};
            child.$parent = this;
            child.$$asyncQueue = [];
            child.$$watchers = child.$$nextSibling = child.$$childHead = child.$$childTail = null;
            child.$$prevSibling = this.$$childTail;
            if (this.$$childHead) {
              this.$$childTail.$$nextSibling = child;
              this.$$childTail = child;
            } else {
              this.$$childHead = this.$$childTail = child;
            }
            return child;
          },
          $watch: function (watchExp, listener, objectEquality) {
            var scope = this, get = compileToFn(watchExp, 'watch'), array = scope.$$watchers, watcher = {
                fn: listener,
                last: initWatchVal,
                get: get,
                exp: watchExp,
                eq: !!objectEquality
              };
            if (!isFunction(listener)) {
              var listenFn = compileToFn(listener || noop, 'listener');
              watcher.fn = function (newVal, oldVal, scope) {
                listenFn(scope);
              };
            }
            if (!array) {
              array = scope.$$watchers = [];
            }
            array.unshift(watcher);
            return function () {
              arrayRemove(array, watcher);
            };
          },
          $digest: function () {
            var watch, value, last, watchers, asyncQueue, length, dirty, ttl = TTL, next, current, target = this, watchLog = [], logIdx, logMsg;
            beginPhase('$digest');
            do {
              dirty = false;
              current = target;
              do {
                asyncQueue = current.$$asyncQueue;
                while (asyncQueue.length) {
                  try {
                    current.$eval(asyncQueue.shift());
                  } catch (e) {
                    $exceptionHandler(e);
                  }
                }
                if (watchers = current.$$watchers) {
                  length = watchers.length;
                  while (length--) {
                    try {
                      watch = watchers[length];
                      if ((value = watch.get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : typeof value == 'number' && typeof last == 'number' && isNaN(value) && isNaN(last))) {
                        dirty = true;
                        watch.last = watch.eq ? copy(value) : value;
                        watch.fn(value, last === initWatchVal ? value : last, current);
                        if (ttl < 5) {
                          logIdx = 4 - ttl;
                          if (!watchLog[logIdx])
                            watchLog[logIdx] = [];
                          logMsg = isFunction(watch.exp) ? 'fn: ' + (watch.exp.name || watch.exp.toString()) : watch.exp;
                          logMsg += '; newVal: ' + toJson(value) + '; oldVal: ' + toJson(last);
                          watchLog[logIdx].push(logMsg);
                        }
                      }
                    } catch (e) {
                      $exceptionHandler(e);
                    }
                  }
                }
                if (!(next = current.$$childHead || current !== target && current.$$nextSibling)) {
                  while (current !== target && !(next = current.$$nextSibling)) {
                    current = current.$parent;
                  }
                }
              } while (current = next);
              if (dirty && !ttl--) {
                clearPhase();
                throw Error(TTL + ' $digest() iterations reached. Aborting!\n' + 'Watchers fired in the last 5 iterations: ' + toJson(watchLog));
              }
            } while (dirty || asyncQueue.length);
            clearPhase();
          },
          $destroy: function () {
            if ($rootScope == this || this.$$destroyed)
              return;
            var parent = this.$parent;
            this.$broadcast('$destroy');
            this.$$destroyed = true;
            if (parent.$$childHead == this)
              parent.$$childHead = this.$$nextSibling;
            if (parent.$$childTail == this)
              parent.$$childTail = this.$$prevSibling;
            if (this.$$prevSibling)
              this.$$prevSibling.$$nextSibling = this.$$nextSibling;
            if (this.$$nextSibling)
              this.$$nextSibling.$$prevSibling = this.$$prevSibling;
            this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
          },
          $eval: function (expr, locals) {
            return $parse(expr)(this, locals);
          },
          $evalAsync: function (expr) {
            this.$$asyncQueue.push(expr);
          },
          $apply: function (expr) {
            try {
              beginPhase('$apply');
              return this.$eval(expr);
            } catch (e) {
              $exceptionHandler(e);
            } finally {
              clearPhase();
              try {
                $rootScope.$digest();
              } catch (e) {
                $exceptionHandler(e);
                throw e;
              }
            }
          },
          $on: function (name, listener) {
            var namedListeners = this.$$listeners[name];
            if (!namedListeners) {
              this.$$listeners[name] = namedListeners = [];
            }
            namedListeners.push(listener);
            return function () {
              namedListeners[indexOf(namedListeners, listener)] = null;
            };
          },
          $emit: function (name, args) {
            var empty = [], namedListeners, scope = this, stopPropagation = false, event = {
                name: name,
                targetScope: scope,
                stopPropagation: function () {
                  stopPropagation = true;
                },
                preventDefault: function () {
                  event.defaultPrevented = true;
                },
                defaultPrevented: false
              }, listenerArgs = concat([event], arguments, 1), i, length;
            do {
              namedListeners = scope.$$listeners[name] || empty;
              event.currentScope = scope;
              for (i = 0, length = namedListeners.length; i < length; i++) {
                if (!namedListeners[i]) {
                  namedListeners.splice(i, 1);
                  i--;
                  length--;
                  continue;
                }
                try {
                  namedListeners[i].apply(null, listenerArgs);
                  if (stopPropagation)
                    return event;
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
              scope = scope.$parent;
            } while (scope);
            return event;
          },
          $broadcast: function (name, args) {
            var target = this, current = target, next = target, event = {
                name: name,
                targetScope: target,
                preventDefault: function () {
                  event.defaultPrevented = true;
                },
                defaultPrevented: false
              }, listenerArgs = concat([event], arguments, 1), listeners, i, length;
            do {
              current = next;
              event.currentScope = current;
              listeners = current.$$listeners[name] || [];
              for (i = 0, length = listeners.length; i < length; i++) {
                if (!listeners[i]) {
                  listeners.splice(i, 1);
                  i--;
                  length--;
                  continue;
                }
                try {
                  listeners[i].apply(null, listenerArgs);
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
              if (!(next = current.$$childHead || current !== target && current.$$nextSibling)) {
                while (current !== target && !(next = current.$$nextSibling)) {
                  current = current.$parent;
                }
              }
            } while (current = next);
            return event;
          }
        };
        var $rootScope = new Scope();
        return $rootScope;
        function beginPhase(phase) {
          if ($rootScope.$$phase) {
            throw Error($rootScope.$$phase + ' already in progress');
          }
          $rootScope.$$phase = phase;
        }
        function clearPhase() {
          $rootScope.$$phase = null;
        }
        function compileToFn(exp, name) {
          var fn = $parse(exp);
          assertArgFn(fn, name);
          return fn;
        }
        function initWatchVal() {
        }
      }
    ];
  }
  function $SnifferProvider() {
    this.$get = [
      '$window',
      function ($window) {
        var eventSupport = {}, android = int((/android (\d+)/.exec(lowercase($window.navigator.userAgent)) || [])[1]);
        return {
          history: !!($window.history && $window.history.pushState && !(android < 4)),
          hashchange: 'onhashchange' in $window && (!$window.document.documentMode || $window.document.documentMode > 7),
          hasEvent: function (event) {
            if (event == 'input' && msie == 9)
              return false;
            if (isUndefined(eventSupport[event])) {
              var divElm = $window.document.createElement('div');
              eventSupport[event] = 'on' + event in divElm;
            }
            return eventSupport[event];
          },
          csp: false
        };
      }
    ];
  }
  function $WindowProvider() {
    this.$get = valueFn(window);
  }
  function parseHeaders(headers) {
    var parsed = {}, key, val, i;
    if (!headers)
      return parsed;
    forEach(headers.split('\n'), function (line) {
      i = line.indexOf(':');
      key = lowercase(trim(line.substr(0, i)));
      val = trim(line.substr(i + 1));
      if (key) {
        if (parsed[key]) {
          parsed[key] += ', ' + val;
        } else {
          parsed[key] = val;
        }
      }
    });
    return parsed;
  }
  function headersGetter(headers) {
    var headersObj = isObject(headers) ? headers : undefined;
    return function (name) {
      if (!headersObj)
        headersObj = parseHeaders(headers);
      if (name) {
        return headersObj[lowercase(name)] || null;
      }
      return headersObj;
    };
  }
  function transformData(data, headers, fns) {
    if (isFunction(fns))
      return fns(data, headers);
    forEach(fns, function (fn) {
      data = fn(data, headers);
    });
    return data;
  }
  function isSuccess(status) {
    return 200 <= status && status < 300;
  }
  function $HttpProvider() {
    var JSON_START = /^\s*(\[|\{[^\{])/, JSON_END = /[\}\]]\s*$/, PROTECTION_PREFIX = /^\)\]\}',?\n/;
    var $config = this.defaults = {
        transformResponse: [function (data) {
            if (isString(data)) {
              data = data.replace(PROTECTION_PREFIX, '');
              if (JSON_START.test(data) && JSON_END.test(data))
                data = fromJson(data, true);
            }
            return data;
          }],
        transformRequest: [function (d) {
            return isObject(d) && !isFile(d) ? toJson(d) : d;
          }],
        headers: {
          common: {
            'Accept': 'application/json, text/plain, */*',
            'X-Requested-With': 'XMLHttpRequest'
          },
          post: { 'Content-Type': 'application/json;charset=utf-8' },
          put: { 'Content-Type': 'application/json;charset=utf-8' }
        }
      };
    var providerResponseInterceptors = this.responseInterceptors = [];
    this.$get = [
      '$httpBackend',
      '$browser',
      '$cacheFactory',
      '$rootScope',
      '$q',
      '$injector',
      function ($httpBackend, $browser, $cacheFactory, $rootScope, $q, $injector) {
        var defaultCache = $cacheFactory('$http'), responseInterceptors = [];
        forEach(providerResponseInterceptors, function (interceptor) {
          responseInterceptors.push(isString(interceptor) ? $injector.get(interceptor) : $injector.invoke(interceptor));
        });
        function $http(config) {
          config.method = uppercase(config.method);
          var reqTransformFn = config.transformRequest || $config.transformRequest, respTransformFn = config.transformResponse || $config.transformResponse, defHeaders = $config.headers, reqHeaders = extend({ 'X-XSRF-TOKEN': $browser.cookies()['XSRF-TOKEN'] }, defHeaders.common, defHeaders[lowercase(config.method)], config.headers), reqData = transformData(config.data, headersGetter(reqHeaders), reqTransformFn), promise;
          if (isUndefined(config.data)) {
            delete reqHeaders['Content-Type'];
          }
          promise = sendReq(config, reqData, reqHeaders);
          promise = promise.then(transformResponse, transformResponse);
          forEach(responseInterceptors, function (interceptor) {
            promise = interceptor(promise);
          });
          promise.success = function (fn) {
            promise.then(function (response) {
              fn(response.data, response.status, response.headers, config);
            });
            return promise;
          };
          promise.error = function (fn) {
            promise.then(null, function (response) {
              fn(response.data, response.status, response.headers, config);
            });
            return promise;
          };
          return promise;
          function transformResponse(response) {
            var resp = extend({}, response, { data: transformData(response.data, response.headers, respTransformFn) });
            return isSuccess(response.status) ? resp : $q.reject(resp);
          }
        }
        $http.pendingRequests = [];
        createShortMethods('get', 'delete', 'head', 'jsonp');
        createShortMethodsWithData('post', 'put');
        $http.defaults = $config;
        return $http;
        function createShortMethods(names) {
          forEach(arguments, function (name) {
            $http[name] = function (url, config) {
              return $http(extend(config || {}, {
                method: name,
                url: url
              }));
            };
          });
        }
        function createShortMethodsWithData(name) {
          forEach(arguments, function (name) {
            $http[name] = function (url, data, config) {
              return $http(extend(config || {}, {
                method: name,
                url: url,
                data: data
              }));
            };
          });
        }
        function sendReq(config, reqData, reqHeaders) {
          var deferred = $q.defer(), promise = deferred.promise, cache, cachedResp, url = buildUrl(config.url, config.params);
          $http.pendingRequests.push(config);
          promise.then(removePendingReq, removePendingReq);
          if (config.cache && config.method == 'GET') {
            cache = isObject(config.cache) ? config.cache : defaultCache;
          }
          if (cache) {
            cachedResp = cache.get(url);
            if (cachedResp) {
              if (cachedResp.then) {
                cachedResp.then(removePendingReq, removePendingReq);
                return cachedResp;
              } else {
                if (isArray(cachedResp)) {
                  resolvePromise(cachedResp[1], cachedResp[0], copy(cachedResp[2]));
                } else {
                  resolvePromise(cachedResp, 200, {});
                }
              }
            } else {
              cache.put(url, promise);
            }
          }
          if (!cachedResp) {
            $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials);
          }
          return promise;
          function done(status, response, headersString) {
            if (cache) {
              if (isSuccess(status)) {
                cache.put(url, [
                  status,
                  response,
                  parseHeaders(headersString)
                ]);
              } else {
                cache.remove(url);
              }
            }
            resolvePromise(response, status, headersString);
            $rootScope.$apply();
          }
          function resolvePromise(response, status, headers) {
            status = Math.max(status, 0);
            (isSuccess(status) ? deferred.resolve : deferred.reject)({
              data: response,
              status: status,
              headers: headersGetter(headers),
              config: config
            });
          }
          function removePendingReq() {
            var idx = indexOf($http.pendingRequests, config);
            if (idx !== -1)
              $http.pendingRequests.splice(idx, 1);
          }
        }
        function buildUrl(url, params) {
          if (!params)
            return url;
          var parts = [];
          forEachSorted(params, function (value, key) {
            if (value == null || value == undefined)
              return;
            if (isObject(value)) {
              value = toJson(value);
            }
            parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
          });
          return url + (url.indexOf('?') == -1 ? '?' : '&') + parts.join('&');
        }
      }
    ];
  }
  var XHR = window.XMLHttpRequest || function () {
      try {
        return new ActiveXObject('Msxml2.XMLHTTP.6.0');
      } catch (e1) {
      }
      try {
        return new ActiveXObject('Msxml2.XMLHTTP.3.0');
      } catch (e2) {
      }
      try {
        return new ActiveXObject('Msxml2.XMLHTTP');
      } catch (e3) {
      }
      throw new Error('This browser does not support XMLHttpRequest.');
    };
  function $HttpBackendProvider() {
    this.$get = [
      '$browser',
      '$window',
      '$document',
      function ($browser, $window, $document) {
        return createHttpBackend($browser, XHR, $browser.defer, $window.angular.callbacks, $document[0], $window.location.protocol.replace(':', ''));
      }
    ];
  }
  function createHttpBackend($browser, XHR, $browserDefer, callbacks, rawDocument, locationProtocol) {
    return function (method, url, post, callback, headers, timeout, withCredentials) {
      $browser.$$incOutstandingRequestCount();
      url = url || $browser.url();
      if (lowercase(method) == 'jsonp') {
        var callbackId = '_' + (callbacks.counter++).toString(36);
        callbacks[callbackId] = function (data) {
          callbacks[callbackId].data = data;
        };
        jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId), function () {
          if (callbacks[callbackId].data) {
            completeRequest(callback, 200, callbacks[callbackId].data);
          } else {
            completeRequest(callback, -2);
          }
          delete callbacks[callbackId];
        });
      } else {
        var xhr = new XHR();
        xhr.open(method, url, true);
        forEach(headers, function (value, key) {
          if (value)
            xhr.setRequestHeader(key, value);
        });
        var status;
        xhr.onreadystatechange = function () {
          if (xhr.readyState == 4) {
            var responseHeaders = xhr.getAllResponseHeaders();
            var value, simpleHeaders = [
                'Cache-Control',
                'Content-Language',
                'Content-Type',
                'Expires',
                'Last-Modified',
                'Pragma'
              ];
            if (!responseHeaders) {
              responseHeaders = '';
              forEach(simpleHeaders, function (header) {
                var value = xhr.getResponseHeader(header);
                if (value) {
                  responseHeaders += header + ': ' + value + '\n';
                }
              });
            }
            completeRequest(callback, status || xhr.status, xhr.responseText, responseHeaders);
          }
        };
        if (withCredentials) {
          xhr.withCredentials = true;
        }
        xhr.send(post || '');
        if (timeout > 0) {
          $browserDefer(function () {
            status = -1;
            xhr.abort();
          }, timeout);
        }
      }
      function completeRequest(callback, status, response, headersString) {
        var protocol = (url.match(URL_MATCH) || [
            '',
            locationProtocol
          ])[1];
        status = protocol == 'file' ? response ? 200 : 404 : status;
        status = status == 1223 ? 204 : status;
        callback(status, response, headersString);
        $browser.$$completeOutstandingRequest(noop);
      }
    };
    function jsonpReq(url, done) {
      var script = rawDocument.createElement('script'), doneWrapper = function () {
          rawDocument.body.removeChild(script);
          if (done)
            done();
        };
      script.type = 'text/javascript';
      script.src = url;
      if (msie) {
        script.onreadystatechange = function () {
          if (/loaded|complete/.test(script.readyState))
            doneWrapper();
        };
      } else {
        script.onload = script.onerror = doneWrapper;
      }
      rawDocument.body.appendChild(script);
    }
  }
  function $LocaleProvider() {
    this.$get = function () {
      return {
        id: 'en-us',
        NUMBER_FORMATS: {
          DECIMAL_SEP: '.',
          GROUP_SEP: ',',
          PATTERNS: [
            {
              minInt: 1,
              minFrac: 0,
              maxFrac: 3,
              posPre: '',
              posSuf: '',
              negPre: '-',
              negSuf: '',
              gSize: 3,
              lgSize: 3
            },
            {
              minInt: 1,
              minFrac: 2,
              maxFrac: 2,
              posPre: '\xa4',
              posSuf: '',
              negPre: '(\xa4',
              negSuf: ')',
              gSize: 3,
              lgSize: 3
            }
          ],
          CURRENCY_SYM: '$'
        },
        DATETIME_FORMATS: {
          MONTH: 'January,February,March,April,May,June,July,August,September,October,November,December'.split(','),
          SHORTMONTH: 'Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec'.split(','),
          DAY: 'Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday'.split(','),
          SHORTDAY: 'Sun,Mon,Tue,Wed,Thu,Fri,Sat'.split(','),
          AMPMS: [
            'AM',
            'PM'
          ],
          medium: 'MMM d, y h:mm:ss a',
          short: 'M/d/yy h:mm a',
          fullDate: 'EEEE, MMMM d, y',
          longDate: 'MMMM d, y',
          mediumDate: 'MMM d, y',
          shortDate: 'M/d/yy',
          mediumTime: 'h:mm:ss a',
          shortTime: 'h:mm a'
        },
        pluralCat: function (num) {
          if (num === 1) {
            return 'one';
          }
          return 'other';
        }
      };
    };
  }
  function $TimeoutProvider() {
    this.$get = [
      '$rootScope',
      '$browser',
      '$q',
      '$exceptionHandler',
      function ($rootScope, $browser, $q, $exceptionHandler) {
        var deferreds = {};
        function timeout(fn, delay, invokeApply) {
          var deferred = $q.defer(), promise = deferred.promise, skipApply = isDefined(invokeApply) && !invokeApply, timeoutId, cleanup;
          timeoutId = $browser.defer(function () {
            try {
              deferred.resolve(fn());
            } catch (e) {
              deferred.reject(e);
              $exceptionHandler(e);
            }
            if (!skipApply)
              $rootScope.$apply();
          }, delay);
          cleanup = function () {
            delete deferreds[promise.$$timeoutId];
          };
          promise.$$timeoutId = timeoutId;
          deferreds[timeoutId] = deferred;
          promise.then(cleanup, cleanup);
          return promise;
        }
        timeout.cancel = function (promise) {
          if (promise && promise.$$timeoutId in deferreds) {
            deferreds[promise.$$timeoutId].reject('canceled');
            return $browser.defer.cancel(promise.$$timeoutId);
          }
          return false;
        };
        return timeout;
      }
    ];
  }
  $FilterProvider.$inject = ['$provide'];
  function $FilterProvider($provide) {
    var suffix = 'Filter';
    function register(name, factory) {
      return $provide.factory(name + suffix, factory);
    }
    this.register = register;
    this.$get = [
      '$injector',
      function ($injector) {
        return function (name) {
          return $injector.get(name + suffix);
        };
      }
    ];
    register('currency', currencyFilter);
    register('date', dateFilter);
    register('filter', filterFilter);
    register('json', jsonFilter);
    register('limitTo', limitToFilter);
    register('lowercase', lowercaseFilter);
    register('number', numberFilter);
    register('orderBy', orderByFilter);
    register('uppercase', uppercaseFilter);
  }
  function filterFilter() {
    return function (array, expression) {
      if (!isArray(array))
        return array;
      var predicates = [];
      predicates.check = function (value) {
        for (var j = 0; j < predicates.length; j++) {
          if (!predicates[j](value)) {
            return false;
          }
        }
        return true;
      };
      var search = function (obj, text) {
        if (text.charAt(0) === '!') {
          return !search(obj, text.substr(1));
        }
        switch (typeof obj) {
        case 'boolean':
        case 'number':
        case 'string':
          return ('' + obj).toLowerCase().indexOf(text) > -1;
        case 'object':
          for (var objKey in obj) {
            if (objKey.charAt(0) !== '$' && search(obj[objKey], text)) {
              return true;
            }
          }
          return false;
        case 'array':
          for (var i = 0; i < obj.length; i++) {
            if (search(obj[i], text)) {
              return true;
            }
          }
          return false;
        default:
          return false;
        }
      };
      switch (typeof expression) {
      case 'boolean':
      case 'number':
      case 'string':
        expression = { $: expression };
      case 'object':
        for (var key in expression) {
          if (key == '$') {
            (function () {
              var text = ('' + expression[key]).toLowerCase();
              if (!text)
                return;
              predicates.push(function (value) {
                return search(value, text);
              });
            }());
          } else {
            (function () {
              var path = key;
              var text = ('' + expression[key]).toLowerCase();
              if (!text)
                return;
              predicates.push(function (value) {
                return search(getter(value, path), text);
              });
            }());
          }
        }
        break;
      case 'function':
        predicates.push(expression);
        break;
      default:
        return array;
      }
      var filtered = [];
      for (var j = 0; j < array.length; j++) {
        var value = array[j];
        if (predicates.check(value)) {
          filtered.push(value);
        }
      }
      return filtered;
    };
  }
  currencyFilter.$inject = ['$locale'];
  function currencyFilter($locale) {
    var formats = $locale.NUMBER_FORMATS;
    return function (amount, currencySymbol) {
      if (isUndefined(currencySymbol))
        currencySymbol = formats.CURRENCY_SYM;
      return formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, 2).replace(/\u00A4/g, currencySymbol);
    };
  }
  numberFilter.$inject = ['$locale'];
  function numberFilter($locale) {
    var formats = $locale.NUMBER_FORMATS;
    return function (number, fractionSize) {
      return formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
    };
  }
  var DECIMAL_SEP = '.';
  function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
    if (isNaN(number) || !isFinite(number))
      return '';
    var isNegative = number < 0;
    number = Math.abs(number);
    var numStr = number + '', formatedText = '', parts = [];
    var hasExponent = false;
    if (numStr.indexOf('e') !== -1) {
      var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
      if (match && match[2] == '-' && match[3] > fractionSize + 1) {
        numStr = '0';
      } else {
        formatedText = numStr;
        hasExponent = true;
      }
    }
    if (!hasExponent) {
      var fractionLen = (numStr.split(DECIMAL_SEP)[1] || '').length;
      if (isUndefined(fractionSize)) {
        fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);
      }
      var pow = Math.pow(10, fractionSize);
      number = Math.round(number * pow) / pow;
      var fraction = ('' + number).split(DECIMAL_SEP);
      var whole = fraction[0];
      fraction = fraction[1] || '';
      var pos = 0, lgroup = pattern.lgSize, group = pattern.gSize;
      if (whole.length >= lgroup + group) {
        pos = whole.length - lgroup;
        for (var i = 0; i < pos; i++) {
          if ((pos - i) % group === 0 && i !== 0) {
            formatedText += groupSep;
          }
          formatedText += whole.charAt(i);
        }
      }
      for (i = pos; i < whole.length; i++) {
        if ((whole.length - i) % lgroup === 0 && i !== 0) {
          formatedText += groupSep;
        }
        formatedText += whole.charAt(i);
      }
      while (fraction.length < fractionSize) {
        fraction += '0';
      }
      if (fractionSize && fractionSize !== '0')
        formatedText += decimalSep + fraction.substr(0, fractionSize);
    }
    parts.push(isNegative ? pattern.negPre : pattern.posPre);
    parts.push(formatedText);
    parts.push(isNegative ? pattern.negSuf : pattern.posSuf);
    return parts.join('');
  }
  function padNumber(num, digits, trim) {
    var neg = '';
    if (num < 0) {
      neg = '-';
      num = -num;
    }
    num = '' + num;
    while (num.length < digits)
      num = '0' + num;
    if (trim)
      num = num.substr(num.length - digits);
    return neg + num;
  }
  function dateGetter(name, size, offset, trim) {
    offset = offset || 0;
    return function (date) {
      var value = date['get' + name]();
      if (offset > 0 || value > -offset)
        value += offset;
      if (value === 0 && offset == -12)
        value = 12;
      return padNumber(value, size, trim);
    };
  }
  function dateStrGetter(name, shortForm) {
    return function (date, formats) {
      var value = date['get' + name]();
      var get = uppercase(shortForm ? 'SHORT' + name : name);
      return formats[get][value];
    };
  }
  function timeZoneGetter(date) {
    var zone = -1 * date.getTimezoneOffset();
    var paddedZone = zone >= 0 ? '+' : '';
    paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
    return paddedZone;
  }
  function ampmGetter(date, formats) {
    return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
  }
  var DATE_FORMATS = {
      yyyy: dateGetter('FullYear', 4),
      yy: dateGetter('FullYear', 2, 0, true),
      y: dateGetter('FullYear', 1),
      MMMM: dateStrGetter('Month'),
      MMM: dateStrGetter('Month', true),
      MM: dateGetter('Month', 2, 1),
      M: dateGetter('Month', 1, 1),
      dd: dateGetter('Date', 2),
      d: dateGetter('Date', 1),
      HH: dateGetter('Hours', 2),
      H: dateGetter('Hours', 1),
      hh: dateGetter('Hours', 2, -12),
      h: dateGetter('Hours', 1, -12),
      mm: dateGetter('Minutes', 2),
      m: dateGetter('Minutes', 1),
      ss: dateGetter('Seconds', 2),
      s: dateGetter('Seconds', 1),
      EEEE: dateStrGetter('Day'),
      EEE: dateStrGetter('Day', true),
      a: ampmGetter,
      Z: timeZoneGetter
    };
  var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZE']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z))(.*)/, NUMBER_STRING = /^\d+$/;
  dateFilter.$inject = ['$locale'];
  function dateFilter($locale) {
    var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
    function jsonStringToDate(string) {
      var match;
      if (match = string.match(R_ISO8601_STR)) {
        var date = new Date(0), tzHour = 0, tzMin = 0;
        if (match[9]) {
          tzHour = int(match[9] + match[10]);
          tzMin = int(match[9] + match[11]);
        }
        date.setUTCFullYear(int(match[1]), int(match[2]) - 1, int(match[3]));
        date.setUTCHours(int(match[4] || 0) - tzHour, int(match[5] || 0) - tzMin, int(match[6] || 0), int(match[7] || 0));
        return date;
      }
      return string;
    }
    return function (date, format) {
      var text = '', parts = [], fn, match;
      format = format || 'mediumDate';
      format = $locale.DATETIME_FORMATS[format] || format;
      if (isString(date)) {
        if (NUMBER_STRING.test(date)) {
          date = int(date);
        } else {
          date = jsonStringToDate(date);
        }
      }
      if (isNumber(date)) {
        date = new Date(date);
      }
      if (!isDate(date)) {
        return date;
      }
      while (format) {
        match = DATE_FORMATS_SPLIT.exec(format);
        if (match) {
          parts = concat(parts, match, 1);
          format = parts.pop();
        } else {
          parts.push(format);
          format = null;
        }
      }
      forEach(parts, function (value) {
        fn = DATE_FORMATS[value];
        text += fn ? fn(date, $locale.DATETIME_FORMATS) : value.replace(/(^'|'$)/g, '').replace(/''/g, '\'');
      });
      return text;
    };
  }
  function jsonFilter() {
    return function (object) {
      return toJson(object, true);
    };
  }
  var lowercaseFilter = valueFn(lowercase);
  var uppercaseFilter = valueFn(uppercase);
  function limitToFilter() {
    return function (array, limit) {
      if (!(array instanceof Array))
        return array;
      limit = int(limit);
      var out = [], i, n;
      if (!array || !(array instanceof Array))
        return out;
      if (limit > array.length)
        limit = array.length;
      else if (limit < -array.length)
        limit = -array.length;
      if (limit > 0) {
        i = 0;
        n = limit;
      } else {
        i = array.length + limit;
        n = array.length;
      }
      for (; i < n; i++) {
        out.push(array[i]);
      }
      return out;
    };
  }
  orderByFilter.$inject = ['$parse'];
  function orderByFilter($parse) {
    return function (array, sortPredicate, reverseOrder) {
      if (!isArray(array))
        return array;
      if (!sortPredicate)
        return array;
      sortPredicate = isArray(sortPredicate) ? sortPredicate : [sortPredicate];
      sortPredicate = map(sortPredicate, function (predicate) {
        var descending = false, get = predicate || identity;
        if (isString(predicate)) {
          if (predicate.charAt(0) == '+' || predicate.charAt(0) == '-') {
            descending = predicate.charAt(0) == '-';
            predicate = predicate.substring(1);
          }
          get = $parse(predicate);
        }
        return reverseComparator(function (a, b) {
          return compare(get(a), get(b));
        }, descending);
      });
      var arrayCopy = [];
      for (var i = 0; i < array.length; i++) {
        arrayCopy.push(array[i]);
      }
      return arrayCopy.sort(reverseComparator(comparator, reverseOrder));
      function comparator(o1, o2) {
        for (var i = 0; i < sortPredicate.length; i++) {
          var comp = sortPredicate[i](o1, o2);
          if (comp !== 0)
            return comp;
        }
        return 0;
      }
      function reverseComparator(comp, descending) {
        return toBoolean(descending) ? function (a, b) {
          return comp(b, a);
        } : comp;
      }
      function compare(v1, v2) {
        var t1 = typeof v1;
        var t2 = typeof v2;
        if (t1 == t2) {
          if (t1 == 'string')
            v1 = v1.toLowerCase();
          if (t1 == 'string')
            v2 = v2.toLowerCase();
          if (v1 === v2)
            return 0;
          return v1 < v2 ? -1 : 1;
        } else {
          return t1 < t2 ? -1 : 1;
        }
      }
    };
  }
  function ngDirective(directive) {
    if (isFunction(directive)) {
      directive = { link: directive };
    }
    directive.restrict = directive.restrict || 'AC';
    return valueFn(directive);
  }
  var htmlAnchorDirective = valueFn({
      restrict: 'E',
      compile: function (element, attr) {
        if (msie <= 8) {
          if (!attr.href && !attr.name) {
            attr.$set('href', '');
          }
          element.append(document.createComment('IE fix'));
        }
        return function (scope, element) {
          element.bind('click', function (event) {
            if (!element.attr('href')) {
              event.preventDefault();
            }
          });
        };
      }
    });
  var ngAttributeAliasDirectives = {};
  forEach(BOOLEAN_ATTR, function (propName, attrName) {
    var normalized = directiveNormalize('ng-' + attrName);
    ngAttributeAliasDirectives[normalized] = function () {
      return {
        priority: 100,
        compile: function () {
          return function (scope, element, attr) {
            scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
              attr.$set(attrName, !!value);
            });
          };
        }
      };
    };
  });
  forEach([
    'src',
    'href'
  ], function (attrName) {
    var normalized = directiveNormalize('ng-' + attrName);
    ngAttributeAliasDirectives[normalized] = function () {
      return {
        priority: 99,
        link: function (scope, element, attr) {
          attr.$observe(normalized, function (value) {
            if (!value)
              return;
            attr.$set(attrName, value);
            if (msie)
              element.prop(attrName, attr[attrName]);
          });
        }
      };
    };
  });
  var nullFormCtrl = {
      $addControl: noop,
      $removeControl: noop,
      $setValidity: noop,
      $setDirty: noop
    };
  FormController.$inject = [
    '$element',
    '$attrs',
    '$scope'
  ];
  function FormController(element, attrs) {
    var form = this, parentForm = element.parent().controller('form') || nullFormCtrl, invalidCount = 0, errors = form.$error = {};
    form.$name = attrs.name;
    form.$dirty = false;
    form.$pristine = true;
    form.$valid = true;
    form.$invalid = false;
    parentForm.$addControl(form);
    element.addClass(PRISTINE_CLASS);
    toggleValidCss(true);
    function toggleValidCss(isValid, validationErrorKey) {
      validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
      element.removeClass((isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey).addClass((isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);
    }
    form.$addControl = function (control) {
      if (control.$name && !form.hasOwnProperty(control.$name)) {
        form[control.$name] = control;
      }
    };
    form.$removeControl = function (control) {
      if (control.$name && form[control.$name] === control) {
        delete form[control.$name];
      }
      forEach(errors, function (queue, validationToken) {
        form.$setValidity(validationToken, true, control);
      });
    };
    form.$setValidity = function (validationToken, isValid, control) {
      var queue = errors[validationToken];
      if (isValid) {
        if (queue) {
          arrayRemove(queue, control);
          if (!queue.length) {
            invalidCount--;
            if (!invalidCount) {
              toggleValidCss(isValid);
              form.$valid = true;
              form.$invalid = false;
            }
            errors[validationToken] = false;
            toggleValidCss(true, validationToken);
            parentForm.$setValidity(validationToken, true, form);
          }
        }
      } else {
        if (!invalidCount) {
          toggleValidCss(isValid);
        }
        if (queue) {
          if (includes(queue, control))
            return;
        } else {
          errors[validationToken] = queue = [];
          invalidCount++;
          toggleValidCss(false, validationToken);
          parentForm.$setValidity(validationToken, false, form);
        }
        queue.push(control);
        form.$valid = false;
        form.$invalid = true;
      }
    };
    form.$setDirty = function () {
      element.removeClass(PRISTINE_CLASS).addClass(DIRTY_CLASS);
      form.$dirty = true;
      form.$pristine = false;
      parentForm.$setDirty();
    };
  }
  var formDirectiveFactory = function (isNgForm) {
    return [
      '$timeout',
      function ($timeout) {
        var formDirective = {
            name: 'form',
            restrict: 'E',
            controller: FormController,
            compile: function () {
              return {
                pre: function (scope, formElement, attr, controller) {
                  if (!attr.action) {
                    var preventDefaultListener = function (event) {
                      event.preventDefault ? event.preventDefault() : event.returnValue = false;
                    };
                    addEventListenerFn(formElement[0], 'submit', preventDefaultListener);
                    formElement.bind('$destroy', function () {
                      $timeout(function () {
                        removeEventListenerFn(formElement[0], 'submit', preventDefaultListener);
                      }, 0, false);
                    });
                  }
                  var parentFormCtrl = formElement.parent().controller('form'), alias = attr.name || attr.ngForm;
                  if (alias) {
                    scope[alias] = controller;
                  }
                  if (parentFormCtrl) {
                    formElement.bind('$destroy', function () {
                      parentFormCtrl.$removeControl(controller);
                      if (alias) {
                        scope[alias] = undefined;
                      }
                      extend(controller, nullFormCtrl);
                    });
                  }
                }
              };
            }
          };
        return isNgForm ? extend(copy(formDirective), { restrict: 'EAC' }) : formDirective;
      }
    ];
  };
  var formDirective = formDirectiveFactory();
  var ngFormDirective = formDirectiveFactory(true);
  var URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/;
  var EMAIL_REGEXP = /^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,4}$/;
  var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/;
  var inputType = {
      'text': textInputType,
      'number': numberInputType,
      'url': urlInputType,
      'email': emailInputType,
      'radio': radioInputType,
      'checkbox': checkboxInputType,
      'hidden': noop,
      'button': noop,
      'submit': noop,
      'reset': noop
    };
  function isEmpty(value) {
    return isUndefined(value) || value === '' || value === null || value !== value;
  }
  function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    var listener = function () {
      var value = trim(element.val());
      if (ctrl.$viewValue !== value) {
        scope.$apply(function () {
          ctrl.$setViewValue(value);
        });
      }
    };
    if ($sniffer.hasEvent('input')) {
      element.bind('input', listener);
    } else {
      var timeout;
      var deferListener = function () {
        if (!timeout) {
          timeout = $browser.defer(function () {
            listener();
            timeout = null;
          });
        }
      };
      element.bind('keydown', function (event) {
        var key = event.keyCode;
        if (key === 91 || 15 < key && key < 19 || 37 <= key && key <= 40)
          return;
        deferListener();
      });
      element.bind('change', listener);
      if ($sniffer.hasEvent('paste')) {
        element.bind('paste cut', deferListener);
      }
    }
    ctrl.$render = function () {
      element.val(isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue);
    };
    var pattern = attr.ngPattern, patternValidator;
    var validate = function (regexp, value) {
      if (isEmpty(value) || regexp.test(value)) {
        ctrl.$setValidity('pattern', true);
        return value;
      } else {
        ctrl.$setValidity('pattern', false);
        return undefined;
      }
    };
    if (pattern) {
      if (pattern.match(/^\/(.*)\/$/)) {
        pattern = new RegExp(pattern.substr(1, pattern.length - 2));
        patternValidator = function (value) {
          return validate(pattern, value);
        };
      } else {
        patternValidator = function (value) {
          var patternObj = scope.$eval(pattern);
          if (!patternObj || !patternObj.test) {
            throw new Error('Expected ' + pattern + ' to be a RegExp but was ' + patternObj);
          }
          return validate(patternObj, value);
        };
      }
      ctrl.$formatters.push(patternValidator);
      ctrl.$parsers.push(patternValidator);
    }
    if (attr.ngMinlength) {
      var minlength = int(attr.ngMinlength);
      var minLengthValidator = function (value) {
        if (!isEmpty(value) && value.length < minlength) {
          ctrl.$setValidity('minlength', false);
          return undefined;
        } else {
          ctrl.$setValidity('minlength', true);
          return value;
        }
      };
      ctrl.$parsers.push(minLengthValidator);
      ctrl.$formatters.push(minLengthValidator);
    }
    if (attr.ngMaxlength) {
      var maxlength = int(attr.ngMaxlength);
      var maxLengthValidator = function (value) {
        if (!isEmpty(value) && value.length > maxlength) {
          ctrl.$setValidity('maxlength', false);
          return undefined;
        } else {
          ctrl.$setValidity('maxlength', true);
          return value;
        }
      };
      ctrl.$parsers.push(maxLengthValidator);
      ctrl.$formatters.push(maxLengthValidator);
    }
  }
  function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    textInputType(scope, element, attr, ctrl, $sniffer, $browser);
    ctrl.$parsers.push(function (value) {
      var empty = isEmpty(value);
      if (empty || NUMBER_REGEXP.test(value)) {
        ctrl.$setValidity('number', true);
        return value === '' ? null : empty ? value : parseFloat(value);
      } else {
        ctrl.$setValidity('number', false);
        return undefined;
      }
    });
    ctrl.$formatters.push(function (value) {
      return isEmpty(value) ? '' : '' + value;
    });
    if (attr.min) {
      var min = parseFloat(attr.min);
      var minValidator = function (value) {
        if (!isEmpty(value) && value < min) {
          ctrl.$setValidity('min', false);
          return undefined;
        } else {
          ctrl.$setValidity('min', true);
          return value;
        }
      };
      ctrl.$parsers.push(minValidator);
      ctrl.$formatters.push(minValidator);
    }
    if (attr.max) {
      var max = parseFloat(attr.max);
      var maxValidator = function (value) {
        if (!isEmpty(value) && value > max) {
          ctrl.$setValidity('max', false);
          return undefined;
        } else {
          ctrl.$setValidity('max', true);
          return value;
        }
      };
      ctrl.$parsers.push(maxValidator);
      ctrl.$formatters.push(maxValidator);
    }
    ctrl.$formatters.push(function (value) {
      if (isEmpty(value) || isNumber(value)) {
        ctrl.$setValidity('number', true);
        return value;
      } else {
        ctrl.$setValidity('number', false);
        return undefined;
      }
    });
  }
  function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    textInputType(scope, element, attr, ctrl, $sniffer, $browser);
    var urlValidator = function (value) {
      if (isEmpty(value) || URL_REGEXP.test(value)) {
        ctrl.$setValidity('url', true);
        return value;
      } else {
        ctrl.$setValidity('url', false);
        return undefined;
      }
    };
    ctrl.$formatters.push(urlValidator);
    ctrl.$parsers.push(urlValidator);
  }
  function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
    textInputType(scope, element, attr, ctrl, $sniffer, $browser);
    var emailValidator = function (value) {
      if (isEmpty(value) || EMAIL_REGEXP.test(value)) {
        ctrl.$setValidity('email', true);
        return value;
      } else {
        ctrl.$setValidity('email', false);
        return undefined;
      }
    };
    ctrl.$formatters.push(emailValidator);
    ctrl.$parsers.push(emailValidator);
  }
  function radioInputType(scope, element, attr, ctrl) {
    if (isUndefined(attr.name)) {
      element.attr('name', nextUid());
    }
    element.bind('click', function () {
      if (element[0].checked) {
        scope.$apply(function () {
          ctrl.$setViewValue(attr.value);
        });
      }
    });
    ctrl.$render = function () {
      var value = attr.value;
      element[0].checked = value == ctrl.$viewValue;
    };
    attr.$observe('value', ctrl.$render);
  }
  function checkboxInputType(scope, element, attr, ctrl) {
    var trueValue = attr.ngTrueValue, falseValue = attr.ngFalseValue;
    if (!isString(trueValue))
      trueValue = true;
    if (!isString(falseValue))
      falseValue = false;
    element.bind('click', function () {
      scope.$apply(function () {
        ctrl.$setViewValue(element[0].checked);
      });
    });
    ctrl.$render = function () {
      element[0].checked = ctrl.$viewValue;
    };
    ctrl.$formatters.push(function (value) {
      return value === trueValue;
    });
    ctrl.$parsers.push(function (value) {
      return value ? trueValue : falseValue;
    });
  }
  var inputDirective = [
      '$browser',
      '$sniffer',
      function ($browser, $sniffer) {
        return {
          restrict: 'E',
          require: '?ngModel',
          link: function (scope, element, attr, ctrl) {
            if (ctrl) {
              (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrl, $sniffer, $browser);
            }
          }
        };
      }
    ];
  var VALID_CLASS = 'ng-valid', INVALID_CLASS = 'ng-invalid', PRISTINE_CLASS = 'ng-pristine', DIRTY_CLASS = 'ng-dirty';
  var NgModelController = [
      '$scope',
      '$exceptionHandler',
      '$attrs',
      '$element',
      '$parse',
      function ($scope, $exceptionHandler, $attr, $element, $parse) {
        this.$viewValue = Number.NaN;
        this.$modelValue = Number.NaN;
        this.$parsers = [];
        this.$formatters = [];
        this.$viewChangeListeners = [];
        this.$pristine = true;
        this.$dirty = false;
        this.$valid = true;
        this.$invalid = false;
        this.$name = $attr.name;
        var ngModelGet = $parse($attr.ngModel), ngModelSet = ngModelGet.assign;
        if (!ngModelSet) {
          throw Error(NON_ASSIGNABLE_MODEL_EXPRESSION + $attr.ngModel + ' (' + startingTag($element) + ')');
        }
        this.$render = noop;
        var parentForm = $element.inheritedData('$formController') || nullFormCtrl, invalidCount = 0, $error = this.$error = {};
        $element.addClass(PRISTINE_CLASS);
        toggleValidCss(true);
        function toggleValidCss(isValid, validationErrorKey) {
          validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
          $element.removeClass((isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey).addClass((isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);
        }
        this.$setValidity = function (validationErrorKey, isValid) {
          if ($error[validationErrorKey] === !isValid)
            return;
          if (isValid) {
            if ($error[validationErrorKey])
              invalidCount--;
            if (!invalidCount) {
              toggleValidCss(true);
              this.$valid = true;
              this.$invalid = false;
            }
          } else {
            toggleValidCss(false);
            this.$invalid = true;
            this.$valid = false;
            invalidCount++;
          }
          $error[validationErrorKey] = !isValid;
          toggleValidCss(isValid, validationErrorKey);
          parentForm.$setValidity(validationErrorKey, isValid, this);
        };
        this.$setViewValue = function (value) {
          this.$viewValue = value;
          if (this.$pristine) {
            this.$dirty = true;
            this.$pristine = false;
            $element.removeClass(PRISTINE_CLASS).addClass(DIRTY_CLASS);
            parentForm.$setDirty();
          }
          forEach(this.$parsers, function (fn) {
            value = fn(value);
          });
          if (this.$modelValue !== value) {
            this.$modelValue = value;
            ngModelSet($scope, value);
            forEach(this.$viewChangeListeners, function (listener) {
              try {
                listener();
              } catch (e) {
                $exceptionHandler(e);
              }
            });
          }
        };
        var ctrl = this;
        $scope.$watch(function ngModelWatch() {
          var value = ngModelGet($scope);
          if (ctrl.$modelValue !== value) {
            var formatters = ctrl.$formatters, idx = formatters.length;
            ctrl.$modelValue = value;
            while (idx--) {
              value = formatters[idx](value);
            }
            if (ctrl.$viewValue !== value) {
              ctrl.$viewValue = value;
              ctrl.$render();
            }
          }
        });
      }
    ];
  var ngModelDirective = function () {
    return {
      require: [
        'ngModel',
        '^?form'
      ],
      controller: NgModelController,
      link: function (scope, element, attr, ctrls) {
        var modelCtrl = ctrls[0], formCtrl = ctrls[1] || nullFormCtrl;
        formCtrl.$addControl(modelCtrl);
        element.bind('$destroy', function () {
          formCtrl.$removeControl(modelCtrl);
        });
      }
    };
  };
  var ngChangeDirective = valueFn({
      require: 'ngModel',
      link: function (scope, element, attr, ctrl) {
        ctrl.$viewChangeListeners.push(function () {
          scope.$eval(attr.ngChange);
        });
      }
    });
  var requiredDirective = function () {
    return {
      require: '?ngModel',
      link: function (scope, elm, attr, ctrl) {
        if (!ctrl)
          return;
        attr.required = true;
        var validator = function (value) {
          if (attr.required && (isEmpty(value) || value === false)) {
            ctrl.$setValidity('required', false);
            return;
          } else {
            ctrl.$setValidity('required', true);
            return value;
          }
        };
        ctrl.$formatters.push(validator);
        ctrl.$parsers.unshift(validator);
        attr.$observe('required', function () {
          validator(ctrl.$viewValue);
        });
      }
    };
  };
  var ngListDirective = function () {
    return {
      require: 'ngModel',
      link: function (scope, element, attr, ctrl) {
        var match = /\/(.*)\//.exec(attr.ngList), separator = match && new RegExp(match[1]) || attr.ngList || ',';
        var parse = function (viewValue) {
          var list = [];
          if (viewValue) {
            forEach(viewValue.split(separator), function (value) {
              if (value)
                list.push(trim(value));
            });
          }
          return list;
        };
        ctrl.$parsers.push(parse);
        ctrl.$formatters.push(function (value) {
          if (isArray(value)) {
            return value.join(', ');
          }
          return undefined;
        });
      }
    };
  };
  var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
  var ngValueDirective = function () {
    return {
      priority: 100,
      compile: function (tpl, tplAttr) {
        if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
          return function (scope, elm, attr) {
            attr.$set('value', scope.$eval(attr.ngValue));
          };
        } else {
          return function (scope, elm, attr) {
            scope.$watch(attr.ngValue, function valueWatchAction(value) {
              attr.$set('value', value, false);
            });
          };
        }
      }
    };
  };
  var ngBindDirective = ngDirective(function (scope, element, attr) {
      element.addClass('ng-binding').data('$binding', attr.ngBind);
      scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
        element.text(value == undefined ? '' : value);
      });
    });
  var ngBindTemplateDirective = [
      '$interpolate',
      function ($interpolate) {
        return function (scope, element, attr) {
          var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
          element.addClass('ng-binding').data('$binding', interpolateFn);
          attr.$observe('ngBindTemplate', function (value) {
            element.text(value);
          });
        };
      }
    ];
  var ngBindHtmlUnsafeDirective = [function () {
        return function (scope, element, attr) {
          element.addClass('ng-binding').data('$binding', attr.ngBindHtmlUnsafe);
          scope.$watch(attr.ngBindHtmlUnsafe, function ngBindHtmlUnsafeWatchAction(value) {
            element.html(value || '');
          });
        };
      }];
  function classDirective(name, selector) {
    name = 'ngClass' + name;
    return ngDirective(function (scope, element, attr) {
      var oldVal = undefined;
      scope.$watch(attr[name], ngClassWatchAction, true);
      attr.$observe('class', function (value) {
        var ngClass = scope.$eval(attr[name]);
        ngClassWatchAction(ngClass, ngClass);
      });
      if (name !== 'ngClass') {
        scope.$watch('$index', function ($index, old$index) {
          var mod = $index & 1;
          if (mod !== old$index & 1) {
            if (mod === selector) {
              addClass(scope.$eval(attr[name]));
            } else {
              removeClass(scope.$eval(attr[name]));
            }
          }
        });
      }
      function ngClassWatchAction(newVal) {
        if (selector === true || scope.$index % 2 === selector) {
          if (oldVal && !equals(newVal, oldVal)) {
            removeClass(oldVal);
          }
          addClass(newVal);
        }
        oldVal = copy(newVal);
      }
      function removeClass(classVal) {
        if (isObject(classVal) && !isArray(classVal)) {
          classVal = map(classVal, function (v, k) {
            if (v)
              return k;
          });
        }
        element.removeClass(isArray(classVal) ? classVal.join(' ') : classVal);
      }
      function addClass(classVal) {
        if (isObject(classVal) && !isArray(classVal)) {
          classVal = map(classVal, function (v, k) {
            if (v)
              return k;
          });
        }
        if (classVal) {
          element.addClass(isArray(classVal) ? classVal.join(' ') : classVal);
        }
      }
    });
  }
  var ngClassDirective = classDirective('', true);
  var ngClassOddDirective = classDirective('Odd', 0);
  var ngClassEvenDirective = classDirective('Even', 1);
  var ngCloakDirective = ngDirective({
      compile: function (element, attr) {
        attr.$set('ngCloak', undefined);
        element.removeClass('ng-cloak');
      }
    });
  var ngControllerDirective = [function () {
        return {
          scope: true,
          controller: '@'
        };
      }];
  var ngCspDirective = [
      '$sniffer',
      function ($sniffer) {
        return {
          priority: 1000,
          compile: function () {
            $sniffer.csp = true;
          }
        };
      }
    ];
  var ngEventDirectives = {};
  forEach('click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave'.split(' '), function (name) {
    var directiveName = directiveNormalize('ng-' + name);
    ngEventDirectives[directiveName] = [
      '$parse',
      function ($parse) {
        return function (scope, element, attr) {
          var fn = $parse(attr[directiveName]);
          element.bind(lowercase(name), function (event) {
            scope.$apply(function () {
              fn(scope, { $event: event });
            });
          });
        };
      }
    ];
  });
  var ngSubmitDirective = ngDirective(function (scope, element, attrs) {
      element.bind('submit', function () {
        scope.$apply(attrs.ngSubmit);
      });
    });
  var ngIncludeDirective = [
      '$http',
      '$templateCache',
      '$anchorScroll',
      '$compile',
      function ($http, $templateCache, $anchorScroll, $compile) {
        return {
          restrict: 'ECA',
          terminal: true,
          compile: function (element, attr) {
            var srcExp = attr.ngInclude || attr.src, onloadExp = attr.onload || '', autoScrollExp = attr.autoscroll;
            return function (scope, element) {
              var changeCounter = 0, childScope;
              var clearContent = function () {
                if (childScope) {
                  childScope.$destroy();
                  childScope = null;
                }
                element.html('');
              };
              scope.$watch(srcExp, function ngIncludeWatchAction(src) {
                var thisChangeId = ++changeCounter;
                if (src) {
                  $http.get(src, { cache: $templateCache }).success(function (response) {
                    if (thisChangeId !== changeCounter)
                      return;
                    if (childScope)
                      childScope.$destroy();
                    childScope = scope.$new();
                    element.html(response);
                    $compile(element.contents())(childScope);
                    if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                      $anchorScroll();
                    }
                    childScope.$emit('$includeContentLoaded');
                    scope.$eval(onloadExp);
                  }).error(function () {
                    if (thisChangeId === changeCounter)
                      clearContent();
                  });
                } else
                  clearContent();
              });
            };
          }
        };
      }
    ];
  var ngInitDirective = ngDirective({
      compile: function () {
        return {
          pre: function (scope, element, attrs) {
            scope.$eval(attrs.ngInit);
          }
        };
      }
    });
  var ngNonBindableDirective = ngDirective({
      terminal: true,
      priority: 1000
    });
  var ngPluralizeDirective = [
      '$locale',
      '$interpolate',
      function ($locale, $interpolate) {
        var BRACE = /{}/g;
        return {
          restrict: 'EA',
          link: function (scope, element, attr) {
            var numberExp = attr.count, whenExp = element.attr(attr.$attr.when), offset = attr.offset || 0, whens = scope.$eval(whenExp), whensExpFns = {}, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol();
            forEach(whens, function (expression, key) {
              whensExpFns[key] = $interpolate(expression.replace(BRACE, startSymbol + numberExp + '-' + offset + endSymbol));
            });
            scope.$watch(function ngPluralizeWatch() {
              var value = parseFloat(scope.$eval(numberExp));
              if (!isNaN(value)) {
                if (!(value in whens))
                  value = $locale.pluralCat(value - offset);
                return whensExpFns[value](scope, element, true);
              } else {
                return '';
              }
            }, function ngPluralizeWatchAction(newVal) {
              element.text(newVal);
            });
          }
        };
      }
    ];
  var ngRepeatDirective = ngDirective({
      transclude: 'element',
      priority: 1000,
      terminal: true,
      compile: function (element, attr, linker) {
        return function (scope, iterStartElement, attr) {
          var expression = attr.ngRepeat;
          var match = expression.match(/^\s*(.+)\s+in\s+(.*)\s*$/), lhs, rhs, valueIdent, keyIdent;
          if (!match) {
            throw Error('Expected ngRepeat in form of \'_item_ in _collection_\' but got \'' + expression + '\'.');
          }
          lhs = match[1];
          rhs = match[2];
          match = lhs.match(/^(?:([\$\w]+)|\(([\$\w]+)\s*,\s*([\$\w]+)\))$/);
          if (!match) {
            throw Error('\'item\' in \'item in collection\' should be identifier or (key, value) but got \'' + lhs + '\'.');
          }
          valueIdent = match[3] || match[1];
          keyIdent = match[2];
          var lastOrder = new HashQueueMap();
          scope.$watch(function ngRepeatWatch(scope) {
            var index, length, collection = scope.$eval(rhs), cursor = iterStartElement, nextOrder = new HashQueueMap(), arrayBound, childScope, key, value, array, last;
            if (!isArray(collection)) {
              array = [];
              for (key in collection) {
                if (collection.hasOwnProperty(key) && key.charAt(0) != '$') {
                  array.push(key);
                }
              }
              array.sort();
            } else {
              array = collection || [];
            }
            arrayBound = array.length - 1;
            for (index = 0, length = array.length; index < length; index++) {
              key = collection === array ? index : array[index];
              value = collection[key];
              last = lastOrder.shift(value);
              if (last) {
                childScope = last.scope;
                nextOrder.push(value, last);
                if (index === last.index) {
                  cursor = last.element;
                } else {
                  last.index = index;
                  cursor.after(last.element);
                  cursor = last.element;
                }
              } else {
                childScope = scope.$new();
              }
              childScope[valueIdent] = value;
              if (keyIdent)
                childScope[keyIdent] = key;
              childScope.$index = index;
              childScope.$first = index === 0;
              childScope.$last = index === arrayBound;
              childScope.$middle = !(childScope.$first || childScope.$last);
              if (!last) {
                linker(childScope, function (clone) {
                  cursor.after(clone);
                  last = {
                    scope: childScope,
                    element: cursor = clone,
                    index: index
                  };
                  nextOrder.push(value, last);
                });
              }
            }
            for (key in lastOrder) {
              if (lastOrder.hasOwnProperty(key)) {
                array = lastOrder[key];
                while (array.length) {
                  value = array.pop();
                  value.element.remove();
                  value.scope.$destroy();
                }
              }
            }
            lastOrder = nextOrder;
          });
        };
      }
    });
  var ngShowDirective = ngDirective(function (scope, element, attr) {
      scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
        element.css('display', toBoolean(value) ? '' : 'none');
      });
    });
  var ngHideDirective = ngDirective(function (scope, element, attr) {
      scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
        element.css('display', toBoolean(value) ? 'none' : '');
      });
    });
  var ngStyleDirective = ngDirective(function (scope, element, attr) {
      scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
        if (oldStyles && newStyles !== oldStyles) {
          forEach(oldStyles, function (val, style) {
            element.css(style, '');
          });
        }
        if (newStyles)
          element.css(newStyles);
      }, true);
    });
  var NG_SWITCH = 'ng-switch';
  var ngSwitchDirective = valueFn({
      restrict: 'EA',
      require: 'ngSwitch',
      controller: [
        '$scope',
        function ngSwitchController() {
          this.cases = {};
        }
      ],
      link: function (scope, element, attr, ctrl) {
        var watchExpr = attr.ngSwitch || attr.on, selectedTransclude, selectedElement, selectedScope;
        scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
          if (selectedElement) {
            selectedScope.$destroy();
            selectedElement.remove();
            selectedElement = selectedScope = null;
          }
          if (selectedTransclude = ctrl.cases['!' + value] || ctrl.cases['?']) {
            scope.$eval(attr.change);
            selectedScope = scope.$new();
            selectedTransclude(selectedScope, function (caseElement) {
              selectedElement = caseElement;
              element.append(caseElement);
            });
          }
        });
      }
    });
  var ngSwitchWhenDirective = ngDirective({
      transclude: 'element',
      priority: 500,
      require: '^ngSwitch',
      compile: function (element, attrs, transclude) {
        return function (scope, element, attr, ctrl) {
          ctrl.cases['!' + attrs.ngSwitchWhen] = transclude;
        };
      }
    });
  var ngSwitchDefaultDirective = ngDirective({
      transclude: 'element',
      priority: 500,
      require: '^ngSwitch',
      compile: function (element, attrs, transclude) {
        return function (scope, element, attr, ctrl) {
          ctrl.cases['?'] = transclude;
        };
      }
    });
  var ngTranscludeDirective = ngDirective({
      controller: [
        '$transclude',
        '$element',
        function ($transclude, $element) {
          $transclude(function (clone) {
            $element.append(clone);
          });
        }
      ]
    });
  var ngViewDirective = [
      '$http',
      '$templateCache',
      '$route',
      '$anchorScroll',
      '$compile',
      '$controller',
      function ($http, $templateCache, $route, $anchorScroll, $compile, $controller) {
        return {
          restrict: 'ECA',
          terminal: true,
          link: function (scope, element, attr) {
            var lastScope, onloadExp = attr.onload || '';
            scope.$on('$routeChangeSuccess', update);
            update();
            function destroyLastScope() {
              if (lastScope) {
                lastScope.$destroy();
                lastScope = null;
              }
            }
            function clearContent() {
              element.html('');
              destroyLastScope();
            }
            function update() {
              var locals = $route.current && $route.current.locals, template = locals && locals.$template;
              if (template) {
                element.html(template);
                destroyLastScope();
                var link = $compile(element.contents()), current = $route.current, controller;
                lastScope = current.scope = scope.$new();
                if (current.controller) {
                  locals.$scope = lastScope;
                  controller = $controller(current.controller, locals);
                  element.children().data('$ngControllerController', controller);
                }
                link(lastScope);
                lastScope.$emit('$viewContentLoaded');
                lastScope.$eval(onloadExp);
                $anchorScroll();
              } else {
                clearContent();
              }
            }
          }
        };
      }
    ];
  var scriptDirective = [
      '$templateCache',
      function ($templateCache) {
        return {
          restrict: 'E',
          terminal: true,
          compile: function (element, attr) {
            if (attr.type == 'text/ng-template') {
              var templateUrl = attr.id, text = element[0].text;
              $templateCache.put(templateUrl, text);
            }
          }
        };
      }
    ];
  var ngOptionsDirective = valueFn({ terminal: true });
  var selectDirective = [
      '$compile',
      '$parse',
      function ($compile, $parse) {
        var NG_OPTIONS_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?(?:\s+group\s+by\s+(.*))?\s+for\s+(?:([\$\w][\$\w\d]*)|(?:\(\s*([\$\w][\$\w\d]*)\s*,\s*([\$\w][\$\w\d]*)\s*\)))\s+in\s+(.*)$/, nullModelCtrl = { $setViewValue: noop };
        return {
          restrict: 'E',
          require: [
            'select',
            '?ngModel'
          ],
          controller: [
            '$element',
            '$scope',
            '$attrs',
            function ($element, $scope, $attrs) {
              var self = this, optionsMap = {}, ngModelCtrl = nullModelCtrl, nullOption, unknownOption;
              self.databound = $attrs.ngModel;
              self.init = function (ngModelCtrl_, nullOption_, unknownOption_) {
                ngModelCtrl = ngModelCtrl_;
                nullOption = nullOption_;
                unknownOption = unknownOption_;
              };
              self.addOption = function (value) {
                optionsMap[value] = true;
                if (ngModelCtrl.$viewValue == value) {
                  $element.val(value);
                  if (unknownOption.parent())
                    unknownOption.remove();
                }
              };
              self.removeOption = function (value) {
                if (this.hasOption(value)) {
                  delete optionsMap[value];
                  if (ngModelCtrl.$viewValue == value) {
                    this.renderUnknownOption(value);
                  }
                }
              };
              self.renderUnknownOption = function (val) {
                var unknownVal = '? ' + hashKey(val) + ' ?';
                unknownOption.val(unknownVal);
                $element.prepend(unknownOption);
                $element.val(unknownVal);
                unknownOption.prop('selected', true);
              };
              self.hasOption = function (value) {
                return optionsMap.hasOwnProperty(value);
              };
              $scope.$on('$destroy', function () {
                self.renderUnknownOption = noop;
              });
            }
          ],
          link: function (scope, element, attr, ctrls) {
            if (!ctrls[1])
              return;
            var selectCtrl = ctrls[0], ngModelCtrl = ctrls[1], multiple = attr.multiple, optionsExp = attr.ngOptions, nullOption = false, emptyOption, optionTemplate = jqLite(document.createElement('option')), optGroupTemplate = jqLite(document.createElement('optgroup')), unknownOption = optionTemplate.clone();
            for (var i = 0, children = element.children(), ii = children.length; i < ii; i++) {
              if (children[i].value == '') {
                emptyOption = nullOption = children.eq(i);
                break;
              }
            }
            selectCtrl.init(ngModelCtrl, nullOption, unknownOption);
            if (multiple && (attr.required || attr.ngRequired)) {
              var requiredValidator = function (value) {
                ngModelCtrl.$setValidity('required', !attr.required || value && value.length);
                return value;
              };
              ngModelCtrl.$parsers.push(requiredValidator);
              ngModelCtrl.$formatters.unshift(requiredValidator);
              attr.$observe('required', function () {
                requiredValidator(ngModelCtrl.$viewValue);
              });
            }
            if (optionsExp)
              Options(scope, element, ngModelCtrl);
            else if (multiple)
              Multiple(scope, element, ngModelCtrl);
            else
              Single(scope, element, ngModelCtrl, selectCtrl);
            function Single(scope, selectElement, ngModelCtrl, selectCtrl) {
              ngModelCtrl.$render = function () {
                var viewValue = ngModelCtrl.$viewValue;
                if (selectCtrl.hasOption(viewValue)) {
                  if (unknownOption.parent())
                    unknownOption.remove();
                  selectElement.val(viewValue);
                  if (viewValue === '')
                    emptyOption.prop('selected', true);
                } else {
                  if (isUndefined(viewValue) && emptyOption) {
                    selectElement.val('');
                  } else {
                    selectCtrl.renderUnknownOption(viewValue);
                  }
                }
              };
              selectElement.bind('change', function () {
                scope.$apply(function () {
                  if (unknownOption.parent())
                    unknownOption.remove();
                  ngModelCtrl.$setViewValue(selectElement.val());
                });
              });
            }
            function Multiple(scope, selectElement, ctrl) {
              var lastView;
              ctrl.$render = function () {
                var items = new HashMap(ctrl.$viewValue);
                forEach(selectElement.find('option'), function (option) {
                  option.selected = isDefined(items.get(option.value));
                });
              };
              scope.$watch(function selectMultipleWatch() {
                if (!equals(lastView, ctrl.$viewValue)) {
                  lastView = copy(ctrl.$viewValue);
                  ctrl.$render();
                }
              });
              selectElement.bind('change', function () {
                scope.$apply(function () {
                  var array = [];
                  forEach(selectElement.find('option'), function (option) {
                    if (option.selected) {
                      array.push(option.value);
                    }
                  });
                  ctrl.$setViewValue(array);
                });
              });
            }
            function Options(scope, selectElement, ctrl) {
              var match;
              if (!(match = optionsExp.match(NG_OPTIONS_REGEXP))) {
                throw Error('Expected ngOptions in form of \'_select_ (as _label_)? for (_key_,)?_value_ in _collection_\'' + ' but got \'' + optionsExp + '\'.');
              }
              var displayFn = $parse(match[2] || match[1]), valueName = match[4] || match[6], keyName = match[5], groupByFn = $parse(match[3] || ''), valueFn = $parse(match[2] ? match[1] : valueName), valuesFn = $parse(match[7]), optionGroupsCache = [[{
                      element: selectElement,
                      label: ''
                    }]];
              if (nullOption) {
                $compile(nullOption)(scope);
                nullOption.removeClass('ng-scope');
                nullOption.remove();
              }
              selectElement.html('');
              selectElement.bind('change', function () {
                scope.$apply(function () {
                  var optionGroup, collection = valuesFn(scope) || [], locals = {}, key, value, optionElement, index, groupIndex, length, groupLength;
                  if (multiple) {
                    value = [];
                    for (groupIndex = 0, groupLength = optionGroupsCache.length; groupIndex < groupLength; groupIndex++) {
                      optionGroup = optionGroupsCache[groupIndex];
                      for (index = 1, length = optionGroup.length; index < length; index++) {
                        if ((optionElement = optionGroup[index].element)[0].selected) {
                          key = optionElement.val();
                          if (keyName)
                            locals[keyName] = key;
                          locals[valueName] = collection[key];
                          value.push(valueFn(scope, locals));
                        }
                      }
                    }
                  } else {
                    key = selectElement.val();
                    if (key == '?') {
                      value = undefined;
                    } else if (key == '') {
                      value = null;
                    } else {
                      locals[valueName] = collection[key];
                      if (keyName)
                        locals[keyName] = key;
                      value = valueFn(scope, locals);
                    }
                  }
                  ctrl.$setViewValue(value);
                });
              });
              ctrl.$render = render;
              scope.$watch(render);
              function render() {
                var optionGroups = { '': [] }, optionGroupNames = [''], optionGroupName, optionGroup, option, existingParent, existingOptions, existingOption, modelValue = ctrl.$modelValue, values = valuesFn(scope) || [], keys = keyName ? sortedKeys(values) : values, groupLength, length, groupIndex, index, locals = {}, selected, selectedSet = false, lastElement, element, label;
                if (multiple) {
                  selectedSet = new HashMap(modelValue);
                }
                for (index = 0; length = keys.length, index < length; index++) {
                  locals[valueName] = values[keyName ? locals[keyName] = keys[index] : index];
                  optionGroupName = groupByFn(scope, locals) || '';
                  if (!(optionGroup = optionGroups[optionGroupName])) {
                    optionGroup = optionGroups[optionGroupName] = [];
                    optionGroupNames.push(optionGroupName);
                  }
                  if (multiple) {
                    selected = selectedSet.remove(valueFn(scope, locals)) != undefined;
                  } else {
                    selected = modelValue === valueFn(scope, locals);
                    selectedSet = selectedSet || selected;
                  }
                  label = displayFn(scope, locals);
                  label = label === undefined ? '' : label;
                  optionGroup.push({
                    id: keyName ? keys[index] : index,
                    label: label,
                    selected: selected
                  });
                }
                if (!multiple) {
                  if (nullOption || modelValue === null) {
                    optionGroups[''].unshift({
                      id: '',
                      label: '',
                      selected: !selectedSet
                    });
                  } else if (!selectedSet) {
                    optionGroups[''].unshift({
                      id: '?',
                      label: '',
                      selected: true
                    });
                  }
                }
                for (groupIndex = 0, groupLength = optionGroupNames.length; groupIndex < groupLength; groupIndex++) {
                  optionGroupName = optionGroupNames[groupIndex];
                  optionGroup = optionGroups[optionGroupName];
                  if (optionGroupsCache.length <= groupIndex) {
                    existingParent = {
                      element: optGroupTemplate.clone().attr('label', optionGroupName),
                      label: optionGroup.label
                    };
                    existingOptions = [existingParent];
                    optionGroupsCache.push(existingOptions);
                    selectElement.append(existingParent.element);
                  } else {
                    existingOptions = optionGroupsCache[groupIndex];
                    existingParent = existingOptions[0];
                    if (existingParent.label != optionGroupName) {
                      existingParent.element.attr('label', existingParent.label = optionGroupName);
                    }
                  }
                  lastElement = null;
                  for (index = 0, length = optionGroup.length; index < length; index++) {
                    option = optionGroup[index];
                    if (existingOption = existingOptions[index + 1]) {
                      lastElement = existingOption.element;
                      if (existingOption.label !== option.label) {
                        lastElement.text(existingOption.label = option.label);
                      }
                      if (existingOption.id !== option.id) {
                        lastElement.val(existingOption.id = option.id);
                      }
                      if (lastElement[0].selected !== option.selected) {
                        lastElement.prop('selected', existingOption.selected = option.selected);
                      }
                    } else {
                      if (option.id === '' && nullOption) {
                        element = nullOption;
                      } else {
                        (element = optionTemplate.clone()).val(option.id).attr('selected', option.selected).text(option.label);
                      }
                      existingOptions.push(existingOption = {
                        element: element,
                        label: option.label,
                        id: option.id,
                        selected: option.selected
                      });
                      if (lastElement) {
                        lastElement.after(element);
                      } else {
                        existingParent.element.append(element);
                      }
                      lastElement = element;
                    }
                  }
                  index++;
                  while (existingOptions.length > index) {
                    existingOptions.pop().element.remove();
                  }
                }
                while (optionGroupsCache.length > groupIndex) {
                  optionGroupsCache.pop()[0].element.remove();
                }
              }
            }
          }
        };
      }
    ];
  var optionDirective = [
      '$interpolate',
      function ($interpolate) {
        var nullSelectCtrl = {
            addOption: noop,
            removeOption: noop
          };
        return {
          restrict: 'E',
          priority: 100,
          compile: function (element, attr) {
            if (isUndefined(attr.value)) {
              var interpolateFn = $interpolate(element.text(), true);
              if (!interpolateFn) {
                attr.$set('value', element.text());
              }
            }
            return function (scope, element, attr) {
              var selectCtrlName = '$selectController', parent = element.parent(), selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
              if (selectCtrl && selectCtrl.databound) {
                element.prop('selected', false);
              } else {
                selectCtrl = nullSelectCtrl;
              }
              if (interpolateFn) {
                scope.$watch(interpolateFn, function interpolateWatchAction(newVal, oldVal) {
                  attr.$set('value', newVal);
                  if (newVal !== oldVal)
                    selectCtrl.removeOption(oldVal);
                  selectCtrl.addOption(newVal);
                });
              } else {
                selectCtrl.addOption(attr.value);
              }
              element.bind('$destroy', function () {
                selectCtrl.removeOption(attr.value);
              });
            };
          }
        };
      }
    ];
  var styleDirective = valueFn({
      restrict: 'E',
      terminal: true
    });
  bindJQuery();
  publishExternalAPI(angular);
  jqLite(document).ready(function () {
    angularInit(document, bootstrap);
  });
}(window, document));
angular.element(document).find('head').append('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak{display:none;}ng\\:form{display:block;}</style>');
(function () {
  var root = this;
  var previousUnderscore = root._;
  var breaker = {};
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;
  var push = ArrayProto.push, slice = ArrayProto.slice, concat = ArrayProto.concat, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty;
  var nativeForEach = ArrayProto.forEach, nativeMap = ArrayProto.map, nativeReduce = ArrayProto.reduce, nativeReduceRight = ArrayProto.reduceRight, nativeFilter = ArrayProto.filter, nativeEvery = ArrayProto.every, nativeSome = ArrayProto.some, nativeIndexOf = ArrayProto.indexOf, nativeLastIndexOf = ArrayProto.lastIndexOf, nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeBind = FuncProto.bind;
  var _ = function (obj) {
    if (obj instanceof _)
      return obj;
    if (!(this instanceof _))
      return new _(obj);
    this._wrapped = obj;
  };
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }
  _.VERSION = '1.6.0';
  var each = _.each = _.forEach = function (obj, iterator, context) {
      if (obj == null)
        return obj;
      if (nativeForEach && obj.forEach === nativeForEach) {
        obj.forEach(iterator, context);
      } else if (obj.length === +obj.length) {
        for (var i = 0, length = obj.length; i < length; i++) {
          if (iterator.call(context, obj[i], i, obj) === breaker)
            return;
        }
      } else {
        var keys = _.keys(obj);
        for (var i = 0, length = keys.length; i < length; i++) {
          if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker)
            return;
        }
      }
      return obj;
    };
  _.map = _.collect = function (obj, iterator, context) {
    var results = [];
    if (obj == null)
      return results;
    if (nativeMap && obj.map === nativeMap)
      return obj.map(iterator, context);
    each(obj, function (value, index, list) {
      results.push(iterator.call(context, value, index, list));
    });
    return results;
  };
  var reduceError = 'Reduce of empty array with no initial value';
  _.reduce = _.foldl = _.inject = function (obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null)
      obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context)
        iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function (value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial)
      throw new TypeError(reduceError);
    return memo;
  };
  _.reduceRight = _.foldr = function (obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null)
      obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context)
        iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function (value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial)
      throw new TypeError(reduceError);
    return memo;
  };
  _.find = _.detect = function (obj, predicate, context) {
    var result;
    any(obj, function (value, index, list) {
      if (predicate.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };
  _.filter = _.select = function (obj, predicate, context) {
    var results = [];
    if (obj == null)
      return results;
    if (nativeFilter && obj.filter === nativeFilter)
      return obj.filter(predicate, context);
    each(obj, function (value, index, list) {
      if (predicate.call(context, value, index, list))
        results.push(value);
    });
    return results;
  };
  _.reject = function (obj, predicate, context) {
    return _.filter(obj, function (value, index, list) {
      return !predicate.call(context, value, index, list);
    }, context);
  };
  _.every = _.all = function (obj, predicate, context) {
    predicate || (predicate = _.identity);
    var result = true;
    if (obj == null)
      return result;
    if (nativeEvery && obj.every === nativeEvery)
      return obj.every(predicate, context);
    each(obj, function (value, index, list) {
      if (!(result = result && predicate.call(context, value, index, list)))
        return breaker;
    });
    return !!result;
  };
  var any = _.some = _.any = function (obj, predicate, context) {
      predicate || (predicate = _.identity);
      var result = false;
      if (obj == null)
        return result;
      if (nativeSome && obj.some === nativeSome)
        return obj.some(predicate, context);
      each(obj, function (value, index, list) {
        if (result || (result = predicate.call(context, value, index, list)))
          return breaker;
      });
      return !!result;
    };
  _.contains = _.include = function (obj, target) {
    if (obj == null)
      return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf)
      return obj.indexOf(target) != -1;
    return any(obj, function (value) {
      return value === target;
    });
  };
  _.invoke = function (obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function (value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };
  _.pluck = function (obj, key) {
    return _.map(obj, _.property(key));
  };
  _.where = function (obj, attrs) {
    return _.filter(obj, _.matches(attrs));
  };
  _.findWhere = function (obj, attrs) {
    return _.find(obj, _.matches(attrs));
  };
  _.max = function (obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    var result = -Infinity, lastComputed = -Infinity;
    each(obj, function (value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      if (computed > lastComputed) {
        result = value;
        lastComputed = computed;
      }
    });
    return result;
  };
  _.min = function (obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    var result = Infinity, lastComputed = Infinity;
    each(obj, function (value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      if (computed < lastComputed) {
        result = value;
        lastComputed = computed;
      }
    });
    return result;
  };
  _.shuffle = function (obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function (value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };
  _.sample = function (obj, n, guard) {
    if (n == null || guard) {
      if (obj.length !== +obj.length)
        obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };
  var lookupIterator = function (value) {
    if (value == null)
      return _.identity;
    if (_.isFunction(value))
      return value;
    return _.property(value);
  };
  _.sortBy = function (obj, iterator, context) {
    iterator = lookupIterator(iterator);
    return _.pluck(_.map(obj, function (value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iterator.call(context, value, index, list)
      };
    }).sort(function (left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0)
          return 1;
        if (a < b || b === void 0)
          return -1;
      }
      return left.index - right.index;
    }), 'value');
  };
  var group = function (behavior) {
    return function (obj, iterator, context) {
      var result = {};
      iterator = lookupIterator(iterator);
      each(obj, function (value, index) {
        var key = iterator.call(context, value, index, obj);
        behavior(result, key, value);
      });
      return result;
    };
  };
  _.groupBy = group(function (result, key, value) {
    _.has(result, key) ? result[key].push(value) : result[key] = [value];
  });
  _.indexBy = group(function (result, key, value) {
    result[key] = value;
  });
  _.countBy = group(function (result, key) {
    _.has(result, key) ? result[key]++ : result[key] = 1;
  });
  _.sortedIndex = function (array, obj, iterator, context) {
    iterator = lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = low + high >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };
  _.toArray = function (obj) {
    if (!obj)
      return [];
    if (_.isArray(obj))
      return slice.call(obj);
    if (obj.length === +obj.length)
      return _.map(obj, _.identity);
    return _.values(obj);
  };
  _.size = function (obj) {
    if (obj == null)
      return 0;
    return obj.length === +obj.length ? obj.length : _.keys(obj).length;
  };
  _.first = _.head = _.take = function (array, n, guard) {
    if (array == null)
      return void 0;
    if (n == null || guard)
      return array[0];
    if (n < 0)
      return [];
    return slice.call(array, 0, n);
  };
  _.initial = function (array, n, guard) {
    return slice.call(array, 0, array.length - (n == null || guard ? 1 : n));
  };
  _.last = function (array, n, guard) {
    if (array == null)
      return void 0;
    if (n == null || guard)
      return array[array.length - 1];
    return slice.call(array, Math.max(array.length - n, 0));
  };
  _.rest = _.tail = _.drop = function (array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };
  _.compact = function (array) {
    return _.filter(array, _.identity);
  };
  var flatten = function (input, shallow, output) {
    if (shallow && _.every(input, _.isArray)) {
      return concat.apply(output, input);
    }
    each(input, function (value) {
      if (_.isArray(value) || _.isArguments(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };
  _.flatten = function (array, shallow) {
    return flatten(array, shallow, []);
  };
  _.without = function (array) {
    return _.difference(array, slice.call(arguments, 1));
  };
  _.partition = function (array, predicate) {
    var pass = [], fail = [];
    each(array, function (elem) {
      (predicate(elem) ? pass : fail).push(elem);
    });
    return [
      pass,
      fail
    ];
  };
  _.uniq = _.unique = function (array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function (value, index) {
      if (isSorted ? !index || seen[seen.length - 1] !== value : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };
  _.union = function () {
    return _.uniq(_.flatten(arguments, true));
  };
  _.intersection = function (array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function (item) {
      return _.every(rest, function (other) {
        return _.contains(other, item);
      });
    });
  };
  _.difference = function (array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function (value) {
      return !_.contains(rest, value);
    });
  };
  _.zip = function () {
    var length = _.max(_.pluck(arguments, 'length').concat(0));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(arguments, '' + i);
    }
    return results;
  };
  _.object = function (list, values) {
    if (list == null)
      return {};
    var result = {};
    for (var i = 0, length = list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };
  _.indexOf = function (array, item, isSorted) {
    if (array == null)
      return -1;
    var i = 0, length = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf)
      return array.indexOf(item, isSorted);
    for (; i < length; i++)
      if (array[i] === item)
        return i;
    return -1;
  };
  _.lastIndexOf = function (array, item, from) {
    if (array == null)
      return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = hasIndex ? from : array.length;
    while (i--)
      if (array[i] === item)
        return i;
    return -1;
  };
  _.range = function (start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;
    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(length);
    while (idx < length) {
      range[idx++] = start;
      start += step;
    }
    return range;
  };
  var ctor = function () {
  };
  _.bind = function (func, context) {
    var args, bound;
    if (nativeBind && func.bind === nativeBind)
      return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func))
      throw new TypeError();
    args = slice.call(arguments, 2);
    return bound = function () {
      if (!(this instanceof bound))
        return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor();
      ctor.prototype = null;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result)
        return result;
      return self;
    };
  };
  _.partial = function (func) {
    var boundArgs = slice.call(arguments, 1);
    return function () {
      var position = 0;
      var args = boundArgs.slice();
      for (var i = 0, length = args.length; i < length; i++) {
        if (args[i] === _)
          args[i] = arguments[position++];
      }
      while (position < arguments.length)
        args.push(arguments[position++]);
      return func.apply(this, args);
    };
  };
  _.bindAll = function (obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0)
      throw new Error('bindAll must be passed function names');
    each(funcs, function (f) {
      obj[f] = _.bind(obj[f], obj);
    });
    return obj;
  };
  _.memoize = function (func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function () {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : memo[key] = func.apply(this, arguments);
    };
  };
  _.delay = function (func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function () {
      return func.apply(null, args);
    }, wait);
  };
  _.defer = function (func) {
    return _.delay.apply(_, [
      func,
      1
    ].concat(slice.call(arguments, 1)));
  };
  _.throttle = function (func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    options || (options = {});
    var later = function () {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      context = args = null;
    };
    return function () {
      var now = _.now();
      if (!previous && options.leading === false)
        previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
        context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };
  _.debounce = function (func, wait, immediate) {
    var timeout, args, context, timestamp, result;
    var later = function () {
      var last = _.now() - timestamp;
      if (last < wait) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          context = args = null;
        }
      }
    };
    return function () {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) {
        timeout = setTimeout(later, wait);
      }
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }
      return result;
    };
  };
  _.once = function (func) {
    var ran = false, memo;
    return function () {
      if (ran)
        return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };
  _.wrap = function (func, wrapper) {
    return _.partial(wrapper, func);
  };
  _.compose = function () {
    var funcs = arguments;
    return function () {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };
  _.after = function (times, func) {
    return function () {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };
  _.keys = function (obj) {
    if (!_.isObject(obj))
      return [];
    if (nativeKeys)
      return nativeKeys(obj);
    var keys = [];
    for (var key in obj)
      if (_.has(obj, key))
        keys.push(key);
    return keys;
  };
  _.values = function (obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = new Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };
  _.pairs = function (obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = new Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [
        keys[i],
        obj[keys[i]]
      ];
    }
    return pairs;
  };
  _.invert = function (obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };
  _.functions = _.methods = function (obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key]))
        names.push(key);
    }
    return names.sort();
  };
  _.extend = function (obj) {
    each(slice.call(arguments, 1), function (source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };
  _.pick = function (obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function (key) {
      if (key in obj)
        copy[key] = obj[key];
    });
    return copy;
  };
  _.omit = function (obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key))
        copy[key] = obj[key];
    }
    return copy;
  };
  _.defaults = function (obj) {
    each(slice.call(arguments, 1), function (source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] === void 0)
            obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };
  _.clone = function (obj) {
    if (!_.isObject(obj))
      return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };
  _.tap = function (obj, interceptor) {
    interceptor(obj);
    return obj;
  };
  var eq = function (a, b, aStack, bStack) {
    if (a === b)
      return a !== 0 || 1 / a == 1 / b;
    if (a == null || b == null)
      return a === b;
    if (a instanceof _)
      a = a._wrapped;
    if (b instanceof _)
      b = b._wrapped;
    var className = toString.call(a);
    if (className != toString.call(b))
      return false;
    switch (className) {
    case '[object String]':
      return a == String(b);
    case '[object Number]':
      return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;
    case '[object Date]':
    case '[object Boolean]':
      return +a == +b;
    case '[object RegExp]':
      return a.source == b.source && a.global == b.global && a.multiline == b.multiline && a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object')
      return false;
    var length = aStack.length;
    while (length--) {
      if (aStack[length] == a)
        return bStack[length] == b;
    }
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor) && ('constructor' in a && 'constructor' in b)) {
      return false;
    }
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    if (className == '[object Array]') {
      size = a.length;
      result = size == b.length;
      if (result) {
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack)))
            break;
        }
      }
    } else {
      for (var key in a) {
        if (_.has(a, key)) {
          size++;
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack)))
            break;
        }
      }
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !size--)
            break;
        }
        result = !size;
      }
    }
    aStack.pop();
    bStack.pop();
    return result;
  };
  _.isEqual = function (a, b) {
    return eq(a, b, [], []);
  };
  _.isEmpty = function (obj) {
    if (obj == null)
      return true;
    if (_.isArray(obj) || _.isString(obj))
      return obj.length === 0;
    for (var key in obj)
      if (_.has(obj, key))
        return false;
    return true;
  };
  _.isElement = function (obj) {
    return !!(obj && obj.nodeType === 1);
  };
  _.isArray = nativeIsArray || function (obj) {
    return toString.call(obj) == '[object Array]';
  };
  _.isObject = function (obj) {
    return obj === Object(obj);
  };
  each([
    'Arguments',
    'Function',
    'String',
    'Number',
    'Date',
    'RegExp'
  ], function (name) {
    _['is' + name] = function (obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });
  if (!_.isArguments(arguments)) {
    _.isArguments = function (obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }
  if (typeof /./ !== 'function') {
    _.isFunction = function (obj) {
      return typeof obj === 'function';
    };
  }
  _.isFinite = function (obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };
  _.isNaN = function (obj) {
    return _.isNumber(obj) && obj != +obj;
  };
  _.isBoolean = function (obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };
  _.isNull = function (obj) {
    return obj === null;
  };
  _.isUndefined = function (obj) {
    return obj === void 0;
  };
  _.has = function (obj, key) {
    return hasOwnProperty.call(obj, key);
  };
  _.noConflict = function () {
    root._ = previousUnderscore;
    return this;
  };
  _.identity = function (value) {
    return value;
  };
  _.constant = function (value) {
    return function () {
      return value;
    };
  };
  _.property = function (key) {
    return function (obj) {
      return obj[key];
    };
  };
  _.matches = function (attrs) {
    return function (obj) {
      if (obj === attrs)
        return true;
      for (var key in attrs) {
        if (attrs[key] !== obj[key])
          return false;
      }
      return true;
    };
  };
  _.times = function (n, iterator, context) {
    var accum = Array(Math.max(0, n));
    for (var i = 0; i < n; i++)
      accum[i] = iterator.call(context, i);
    return accum;
  };
  _.random = function (min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };
  _.now = Date.now || function () {
    return new Date().getTime();
  };
  var entityMap = {
      escape: {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        '\'': '&#x27;'
      }
    };
  entityMap.unescape = _.invert(entityMap.escape);
  var entityRegexes = {
      escape: new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
      unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
    };
  _.each([
    'escape',
    'unescape'
  ], function (method) {
    _[method] = function (string) {
      if (string == null)
        return '';
      return ('' + string).replace(entityRegexes[method], function (match) {
        return entityMap[method][match];
      });
    };
  });
  _.result = function (object, property) {
    if (object == null)
      return void 0;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };
  _.mixin = function (obj) {
    each(_.functions(obj), function (name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function () {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };
  var idCounter = 0;
  _.uniqueId = function (prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };
  _.templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g
  };
  var noMatch = /(.)^/;
  var escapes = {
      '\'': '\'',
      '\\': '\\',
      '\r': 'r',
      '\n': 'n',
      '\t': 't',
      '\u2028': 'u2028',
      '\u2029': 'u2029'
    };
  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;
  _.template = function (text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);
    var matcher = new RegExp([
        (settings.escape || noMatch).source,
        (settings.interpolate || noMatch).source,
        (settings.evaluate || noMatch).source
      ].join('|') + '|$', 'g');
    var index = 0;
    var source = '__p+=\'';
    text.replace(matcher, function (match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, function (match) {
        return '\\' + escapes[match];
      });
      if (escape) {
        source += '\'+\n((__t=(' + escape + '))==null?\'\':_.escape(__t))+\n\'';
      }
      if (interpolate) {
        source += '\'+\n((__t=(' + interpolate + '))==null?\'\':__t)+\n\'';
      }
      if (evaluate) {
        source += '\';\n' + evaluate + '\n__p+=\'';
      }
      index = offset + match.length;
      return match;
    });
    source += '\';\n';
    if (!settings.variable)
      source = 'with(obj||{}){\n' + source + '}\n';
    source = 'var __t,__p=\'\',__j=Array.prototype.join,' + 'print=function(){__p+=__j.call(arguments,\'\');};\n' + source + 'return __p;\n';
    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }
    if (data)
      return render(data, _);
    var template = function (data) {
      return render.call(this, data, _);
    };
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';
    return template;
  };
  _.chain = function (obj) {
    return _(obj).chain();
  };
  var result = function (obj) {
    return this._chain ? _(obj).chain() : obj;
  };
  _.mixin(_);
  each([
    'pop',
    'push',
    'reverse',
    'shift',
    'sort',
    'splice',
    'unshift'
  ], function (name) {
    var method = ArrayProto[name];
    _.prototype[name] = function () {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0)
        delete obj[0];
      return result.call(this, obj);
    };
  });
  each([
    'concat',
    'join',
    'slice'
  ], function (name) {
    var method = ArrayProto[name];
    _.prototype[name] = function () {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });
  _.extend(_.prototype, {
    chain: function () {
      this._chain = true;
      return this;
    },
    value: function () {
      return this._wrapped;
    }
  });
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function () {
      return _;
    });
  }
}.call(this));
(function (root, undef) {
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, slice = ArrayProto.slice, hasOwnProp = ObjProto.hasOwnProperty, nativeForEach = ArrayProto.forEach, breaker = {};
  var _ = {
      forEach: function (obj, iterator, context) {
        var i, l, key;
        if (obj === null) {
          return;
        }
        if (nativeForEach && obj.forEach === nativeForEach) {
          obj.forEach(iterator, context);
        } else if (obj.length === +obj.length) {
          for (i = 0, l = obj.length; i < l; i++) {
            if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) {
              return;
            }
          }
        } else {
          for (key in obj) {
            if (hasOwnProp.call(obj, key)) {
              if (iterator.call(context, obj[key], key, obj) === breaker) {
                return;
              }
            }
          }
        }
      },
      extend: function (obj) {
        this.forEach(slice.call(arguments, 1), function (source) {
          for (var prop in source) {
            obj[prop] = source[prop];
          }
        });
        return obj;
      }
    };
  var Jed = function (options) {
    this.defaults = {
      'locale_data': {
        'messages': {
          '': {
            'domain': 'messages',
            'lang': 'en',
            'plural_forms': 'nplurals=2; plural=(n != 1);'
          }
        }
      },
      'domain': 'messages'
    };
    this.options = _.extend({}, this.defaults, options);
    this.textdomain(this.options.domain);
    if (options.domain && !this.options.locale_data[this.options.domain]) {
      throw new Error('Text domain set to non-existent domain: `' + options.domain + '`');
    }
  };
  Jed.context_delimiter = String.fromCharCode(4);
  function getPluralFormFunc(plural_form_string) {
    return Jed.PF.compile(plural_form_string || 'nplurals=2; plural=(n != 1);');
  }
  function Chain(key, i18n) {
    this._key = key;
    this._i18n = i18n;
  }
  _.extend(Chain.prototype, {
    onDomain: function (domain) {
      this._domain = domain;
      return this;
    },
    withContext: function (context) {
      this._context = context;
      return this;
    },
    ifPlural: function (num, pkey) {
      this._val = num;
      this._pkey = pkey;
      return this;
    },
    fetch: function (sArr) {
      if ({}.toString.call(sArr) != '[object Array]') {
        sArr = [].slice.call(arguments);
      }
      return (sArr && sArr.length ? Jed.sprintf : function (x) {
        return x;
      })(this._i18n.dcnpgettext(this._domain, this._context, this._key, this._pkey, this._val), sArr);
    }
  });
  _.extend(Jed.prototype, {
    translate: function (key) {
      return new Chain(key, this);
    },
    textdomain: function (domain) {
      if (!domain) {
        return this._textdomain;
      }
      this._textdomain = domain;
    },
    gettext: function (key) {
      return this.dcnpgettext.call(this, undef, undef, key);
    },
    dgettext: function (domain, key) {
      return this.dcnpgettext.call(this, domain, undef, key);
    },
    dcgettext: function (domain, key) {
      return this.dcnpgettext.call(this, domain, undef, key);
    },
    ngettext: function (skey, pkey, val) {
      return this.dcnpgettext.call(this, undef, undef, skey, pkey, val);
    },
    dngettext: function (domain, skey, pkey, val) {
      return this.dcnpgettext.call(this, domain, undef, skey, pkey, val);
    },
    dcngettext: function (domain, skey, pkey, val) {
      return this.dcnpgettext.call(this, domain, undef, skey, pkey, val);
    },
    pgettext: function (context, key) {
      return this.dcnpgettext.call(this, undef, context, key);
    },
    dpgettext: function (domain, context, key) {
      return this.dcnpgettext.call(this, domain, context, key);
    },
    dcpgettext: function (domain, context, key) {
      return this.dcnpgettext.call(this, domain, context, key);
    },
    npgettext: function (context, skey, pkey, val) {
      return this.dcnpgettext.call(this, undef, context, skey, pkey, val);
    },
    dnpgettext: function (domain, context, skey, pkey, val) {
      return this.dcnpgettext.call(this, domain, context, skey, pkey, val);
    },
    dcnpgettext: function (domain, context, singular_key, plural_key, val) {
      plural_key = plural_key || singular_key;
      domain = domain || this._textdomain;
      val = typeof val == 'undefined' ? 1 : val;
      var fallback;
      if (!this.options) {
        fallback = new Jed();
        return fallback.dcnpgettext.call(fallback, undefined, undefined, singular_key, plural_key, val);
      }
      if (!this.options.locale_data) {
        throw new Error('No locale data provided.');
      }
      if (!this.options.locale_data[domain]) {
        throw new Error('Domain `' + domain + '` was not found.');
      }
      if (!this.options.locale_data[domain]['']) {
        throw new Error('No locale meta information provided.');
      }
      if (!singular_key) {
        throw new Error('No translation key found.');
      }
      if (typeof val != 'number') {
        val = parseInt(val, 10);
        if (isNaN(val)) {
          throw new Error('The number that was passed in is not a number.');
        }
      }
      var key = context ? context + Jed.context_delimiter + singular_key : singular_key, locale_data = this.options.locale_data, dict = locale_data[domain], pluralForms = dict[''].plural_forms || (locale_data.messages || this.defaults.locale_data.messages)[''].plural_forms, val_idx = getPluralFormFunc(pluralForms)(val) + 1, val_list, res;
      if (!dict) {
        throw new Error('No domain named `' + domain + '` could be found.');
      }
      val_list = dict[key];
      if (!val_list || val_idx >= val_list.length) {
        if (this.options.missing_key_callback) {
          this.options.missing_key_callback(key);
        }
        res = [
          null,
          singular_key,
          plural_key
        ];
        return res[getPluralFormFunc(pluralForms)(val) + 1];
      }
      res = val_list[val_idx];
      if (!res) {
        res = [
          null,
          singular_key,
          plural_key
        ];
        return res[getPluralFormFunc(pluralForms)(val) + 1];
      }
      return res;
    }
  });
  var sprintf = function () {
      function get_type(variable) {
        return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
      }
      function str_repeat(input, multiplier) {
        for (var output = []; multiplier > 0; output[--multiplier] = input) {
        }
        return output.join('');
      }
      var str_format = function () {
        if (!str_format.cache.hasOwnProperty(arguments[0])) {
          str_format.cache[arguments[0]] = str_format.parse(arguments[0]);
        }
        return str_format.format.call(null, str_format.cache[arguments[0]], arguments);
      };
      str_format.format = function (parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;
        for (i = 0; i < tree_length; i++) {
          node_type = get_type(parse_tree[i]);
          if (node_type === 'string') {
            output.push(parse_tree[i]);
          } else if (node_type === 'array') {
            match = parse_tree[i];
            if (match[2]) {
              arg = argv[cursor];
              for (k = 0; k < match[2].length; k++) {
                if (!arg.hasOwnProperty(match[2][k])) {
                  throw sprintf('[sprintf] property "%s" does not exist', match[2][k]);
                }
                arg = arg[match[2][k]];
              }
            } else if (match[1]) {
              arg = argv[match[1]];
            } else {
              arg = argv[cursor++];
            }
            if (/[^s]/.test(match[8]) && get_type(arg) != 'number') {
              throw sprintf('[sprintf] expecting number but found %s', get_type(arg));
            }
            if (typeof arg == 'undefined' || arg === null) {
              arg = '';
            }
            switch (match[8]) {
            case 'b':
              arg = arg.toString(2);
              break;
            case 'c':
              arg = String.fromCharCode(arg);
              break;
            case 'd':
              arg = parseInt(arg, 10);
              break;
            case 'e':
              arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential();
              break;
            case 'f':
              arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg);
              break;
            case 'o':
              arg = arg.toString(8);
              break;
            case 's':
              arg = (arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg;
              break;
            case 'u':
              arg = Math.abs(arg);
              break;
            case 'x':
              arg = arg.toString(16);
              break;
            case 'X':
              arg = arg.toString(16).toUpperCase();
              break;
            }
            arg = /[def]/.test(match[8]) && match[3] && arg >= 0 ? '+' + arg : arg;
            pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';
            pad_length = match[6] - String(arg).length;
            pad = match[6] ? str_repeat(pad_character, pad_length) : '';
            output.push(match[5] ? arg + pad : pad + arg);
          }
        }
        return output.join('');
      };
      str_format.cache = {};
      str_format.parse = function (fmt) {
        var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
        while (_fmt) {
          if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
            parse_tree.push(match[0]);
          } else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
            parse_tree.push('%');
          } else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
            if (match[2]) {
              arg_names |= 1;
              var field_list = [], replacement_field = match[2], field_match = [];
              if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                field_list.push(field_match[1]);
                while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                  if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else {
                    throw '[sprintf] huh?';
                  }
                }
              } else {
                throw '[sprintf] huh?';
              }
              match[2] = field_list;
            } else {
              arg_names |= 2;
            }
            if (arg_names === 3) {
              throw '[sprintf] mixing positional and named placeholders is not (yet) supported';
            }
            parse_tree.push(match);
          } else {
            throw '[sprintf] huh?';
          }
          _fmt = _fmt.substring(match[0].length);
        }
        return parse_tree;
      };
      return str_format;
    }();
  var vsprintf = function (fmt, argv) {
    argv.unshift(fmt);
    return sprintf.apply(null, argv);
  };
  Jed.parse_plural = function (plural_forms, n) {
    plural_forms = plural_forms.replace(/n/g, n);
    return Jed.parse_expression(plural_forms);
  };
  Jed.sprintf = function (fmt, args) {
    if ({}.toString.call(args) == '[object Array]') {
      return vsprintf(fmt, [].slice.call(args));
    }
    return sprintf.apply(this, [].slice.call(arguments));
  };
  Jed.prototype.sprintf = function () {
    return Jed.sprintf.apply(this, arguments);
  };
  Jed.PF = {};
  Jed.PF.parse = function (p) {
    var plural_str = Jed.PF.extractPluralExpr(p);
    return Jed.PF.parser.parse.call(Jed.PF.parser, plural_str);
  };
  Jed.PF.compile = function (p) {
    function imply(val) {
      return val === true ? 1 : val ? val : 0;
    }
    var ast = Jed.PF.parse(p);
    return function (n) {
      return imply(Jed.PF.interpreter(ast)(n));
    };
  };
  Jed.PF.interpreter = function (ast) {
    return function (n) {
      var res;
      switch (ast.type) {
      case 'GROUP':
        return Jed.PF.interpreter(ast.expr)(n);
      case 'TERNARY':
        if (Jed.PF.interpreter(ast.expr)(n)) {
          return Jed.PF.interpreter(ast.truthy)(n);
        }
        return Jed.PF.interpreter(ast.falsey)(n);
      case 'OR':
        return Jed.PF.interpreter(ast.left)(n) || Jed.PF.interpreter(ast.right)(n);
      case 'AND':
        return Jed.PF.interpreter(ast.left)(n) && Jed.PF.interpreter(ast.right)(n);
      case 'LT':
        return Jed.PF.interpreter(ast.left)(n) < Jed.PF.interpreter(ast.right)(n);
      case 'GT':
        return Jed.PF.interpreter(ast.left)(n) > Jed.PF.interpreter(ast.right)(n);
      case 'LTE':
        return Jed.PF.interpreter(ast.left)(n) <= Jed.PF.interpreter(ast.right)(n);
      case 'GTE':
        return Jed.PF.interpreter(ast.left)(n) >= Jed.PF.interpreter(ast.right)(n);
      case 'EQ':
        return Jed.PF.interpreter(ast.left)(n) == Jed.PF.interpreter(ast.right)(n);
      case 'NEQ':
        return Jed.PF.interpreter(ast.left)(n) != Jed.PF.interpreter(ast.right)(n);
      case 'MOD':
        return Jed.PF.interpreter(ast.left)(n) % Jed.PF.interpreter(ast.right)(n);
      case 'VAR':
        return n;
      case 'NUM':
        return ast.val;
      default:
        throw new Error('Invalid Token found.');
      }
    };
  };
  Jed.PF.extractPluralExpr = function (p) {
    p = p.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    if (!/;\s*$/.test(p)) {
      p = p.concat(';');
    }
    var nplurals_re = /nplurals\=(\d+);/, plural_re = /plural\=(.*);/, nplurals_matches = p.match(nplurals_re), res = {}, plural_matches;
    if (nplurals_matches.length > 1) {
      res.nplurals = nplurals_matches[1];
    } else {
      throw new Error('nplurals not found in plural_forms string: ' + p);
    }
    p = p.replace(nplurals_re, '');
    plural_matches = p.match(plural_re);
    if (!(plural_matches && plural_matches.length > 1)) {
      throw new Error('`plural` expression not found: ' + p);
    }
    return plural_matches[1];
  };
  Jed.PF.parser = function () {
    var parser = {
        trace: function trace() {
        },
        yy: {},
        symbols_: {
          'error': 2,
          'expressions': 3,
          'e': 4,
          'EOF': 5,
          '?': 6,
          ':': 7,
          '||': 8,
          '&&': 9,
          '<': 10,
          '<=': 11,
          '>': 12,
          '>=': 13,
          '!=': 14,
          '==': 15,
          '%': 16,
          '(': 17,
          ')': 18,
          'n': 19,
          'NUMBER': 20,
          '$accept': 0,
          '$end': 1
        },
        terminals_: {
          2: 'error',
          5: 'EOF',
          6: '?',
          7: ':',
          8: '||',
          9: '&&',
          10: '<',
          11: '<=',
          12: '>',
          13: '>=',
          14: '!=',
          15: '==',
          16: '%',
          17: '(',
          18: ')',
          19: 'n',
          20: 'NUMBER'
        },
        productions_: [
          0,
          [
            3,
            2
          ],
          [
            4,
            5
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            3
          ],
          [
            4,
            1
          ],
          [
            4,
            1
          ]
        ],
        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
          var $0 = $$.length - 1;
          switch (yystate) {
          case 1:
            return {
              type: 'GROUP',
              expr: $$[$0 - 1]
            };
            break;
          case 2:
            this.$ = {
              type: 'TERNARY',
              expr: $$[$0 - 4],
              truthy: $$[$0 - 2],
              falsey: $$[$0]
            };
            break;
          case 3:
            this.$ = {
              type: 'OR',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 4:
            this.$ = {
              type: 'AND',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 5:
            this.$ = {
              type: 'LT',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 6:
            this.$ = {
              type: 'LTE',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 7:
            this.$ = {
              type: 'GT',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 8:
            this.$ = {
              type: 'GTE',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 9:
            this.$ = {
              type: 'NEQ',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 10:
            this.$ = {
              type: 'EQ',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 11:
            this.$ = {
              type: 'MOD',
              left: $$[$0 - 2],
              right: $$[$0]
            };
            break;
          case 12:
            this.$ = {
              type: 'GROUP',
              expr: $$[$0 - 1]
            };
            break;
          case 13:
            this.$ = { type: 'VAR' };
            break;
          case 14:
            this.$ = {
              type: 'NUM',
              val: Number(yytext)
            };
            break;
          }
        },
        table: [
          {
            3: 1,
            4: 2,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          { 1: [3] },
          {
            5: [
              1,
              6
            ],
            6: [
              1,
              7
            ],
            8: [
              1,
              8
            ],
            9: [
              1,
              9
            ],
            10: [
              1,
              10
            ],
            11: [
              1,
              11
            ],
            12: [
              1,
              12
            ],
            13: [
              1,
              13
            ],
            14: [
              1,
              14
            ],
            15: [
              1,
              15
            ],
            16: [
              1,
              16
            ]
          },
          {
            4: 17,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            5: [
              2,
              13
            ],
            6: [
              2,
              13
            ],
            7: [
              2,
              13
            ],
            8: [
              2,
              13
            ],
            9: [
              2,
              13
            ],
            10: [
              2,
              13
            ],
            11: [
              2,
              13
            ],
            12: [
              2,
              13
            ],
            13: [
              2,
              13
            ],
            14: [
              2,
              13
            ],
            15: [
              2,
              13
            ],
            16: [
              2,
              13
            ],
            18: [
              2,
              13
            ]
          },
          {
            5: [
              2,
              14
            ],
            6: [
              2,
              14
            ],
            7: [
              2,
              14
            ],
            8: [
              2,
              14
            ],
            9: [
              2,
              14
            ],
            10: [
              2,
              14
            ],
            11: [
              2,
              14
            ],
            12: [
              2,
              14
            ],
            13: [
              2,
              14
            ],
            14: [
              2,
              14
            ],
            15: [
              2,
              14
            ],
            16: [
              2,
              14
            ],
            18: [
              2,
              14
            ]
          },
          {
            1: [
              2,
              1
            ]
          },
          {
            4: 18,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 19,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 20,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 21,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 22,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 23,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 24,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 25,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 26,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            4: 27,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            6: [
              1,
              7
            ],
            8: [
              1,
              8
            ],
            9: [
              1,
              9
            ],
            10: [
              1,
              10
            ],
            11: [
              1,
              11
            ],
            12: [
              1,
              12
            ],
            13: [
              1,
              13
            ],
            14: [
              1,
              14
            ],
            15: [
              1,
              15
            ],
            16: [
              1,
              16
            ],
            18: [
              1,
              28
            ]
          },
          {
            6: [
              1,
              7
            ],
            7: [
              1,
              29
            ],
            8: [
              1,
              8
            ],
            9: [
              1,
              9
            ],
            10: [
              1,
              10
            ],
            11: [
              1,
              11
            ],
            12: [
              1,
              12
            ],
            13: [
              1,
              13
            ],
            14: [
              1,
              14
            ],
            15: [
              1,
              15
            ],
            16: [
              1,
              16
            ]
          },
          {
            5: [
              2,
              3
            ],
            6: [
              2,
              3
            ],
            7: [
              2,
              3
            ],
            8: [
              2,
              3
            ],
            9: [
              1,
              9
            ],
            10: [
              1,
              10
            ],
            11: [
              1,
              11
            ],
            12: [
              1,
              12
            ],
            13: [
              1,
              13
            ],
            14: [
              1,
              14
            ],
            15: [
              1,
              15
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              3
            ]
          },
          {
            5: [
              2,
              4
            ],
            6: [
              2,
              4
            ],
            7: [
              2,
              4
            ],
            8: [
              2,
              4
            ],
            9: [
              2,
              4
            ],
            10: [
              1,
              10
            ],
            11: [
              1,
              11
            ],
            12: [
              1,
              12
            ],
            13: [
              1,
              13
            ],
            14: [
              1,
              14
            ],
            15: [
              1,
              15
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              4
            ]
          },
          {
            5: [
              2,
              5
            ],
            6: [
              2,
              5
            ],
            7: [
              2,
              5
            ],
            8: [
              2,
              5
            ],
            9: [
              2,
              5
            ],
            10: [
              2,
              5
            ],
            11: [
              2,
              5
            ],
            12: [
              2,
              5
            ],
            13: [
              2,
              5
            ],
            14: [
              2,
              5
            ],
            15: [
              2,
              5
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              5
            ]
          },
          {
            5: [
              2,
              6
            ],
            6: [
              2,
              6
            ],
            7: [
              2,
              6
            ],
            8: [
              2,
              6
            ],
            9: [
              2,
              6
            ],
            10: [
              2,
              6
            ],
            11: [
              2,
              6
            ],
            12: [
              2,
              6
            ],
            13: [
              2,
              6
            ],
            14: [
              2,
              6
            ],
            15: [
              2,
              6
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              6
            ]
          },
          {
            5: [
              2,
              7
            ],
            6: [
              2,
              7
            ],
            7: [
              2,
              7
            ],
            8: [
              2,
              7
            ],
            9: [
              2,
              7
            ],
            10: [
              2,
              7
            ],
            11: [
              2,
              7
            ],
            12: [
              2,
              7
            ],
            13: [
              2,
              7
            ],
            14: [
              2,
              7
            ],
            15: [
              2,
              7
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              7
            ]
          },
          {
            5: [
              2,
              8
            ],
            6: [
              2,
              8
            ],
            7: [
              2,
              8
            ],
            8: [
              2,
              8
            ],
            9: [
              2,
              8
            ],
            10: [
              2,
              8
            ],
            11: [
              2,
              8
            ],
            12: [
              2,
              8
            ],
            13: [
              2,
              8
            ],
            14: [
              2,
              8
            ],
            15: [
              2,
              8
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              8
            ]
          },
          {
            5: [
              2,
              9
            ],
            6: [
              2,
              9
            ],
            7: [
              2,
              9
            ],
            8: [
              2,
              9
            ],
            9: [
              2,
              9
            ],
            10: [
              2,
              9
            ],
            11: [
              2,
              9
            ],
            12: [
              2,
              9
            ],
            13: [
              2,
              9
            ],
            14: [
              2,
              9
            ],
            15: [
              2,
              9
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              9
            ]
          },
          {
            5: [
              2,
              10
            ],
            6: [
              2,
              10
            ],
            7: [
              2,
              10
            ],
            8: [
              2,
              10
            ],
            9: [
              2,
              10
            ],
            10: [
              2,
              10
            ],
            11: [
              2,
              10
            ],
            12: [
              2,
              10
            ],
            13: [
              2,
              10
            ],
            14: [
              2,
              10
            ],
            15: [
              2,
              10
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              10
            ]
          },
          {
            5: [
              2,
              11
            ],
            6: [
              2,
              11
            ],
            7: [
              2,
              11
            ],
            8: [
              2,
              11
            ],
            9: [
              2,
              11
            ],
            10: [
              2,
              11
            ],
            11: [
              2,
              11
            ],
            12: [
              2,
              11
            ],
            13: [
              2,
              11
            ],
            14: [
              2,
              11
            ],
            15: [
              2,
              11
            ],
            16: [
              2,
              11
            ],
            18: [
              2,
              11
            ]
          },
          {
            5: [
              2,
              12
            ],
            6: [
              2,
              12
            ],
            7: [
              2,
              12
            ],
            8: [
              2,
              12
            ],
            9: [
              2,
              12
            ],
            10: [
              2,
              12
            ],
            11: [
              2,
              12
            ],
            12: [
              2,
              12
            ],
            13: [
              2,
              12
            ],
            14: [
              2,
              12
            ],
            15: [
              2,
              12
            ],
            16: [
              2,
              12
            ],
            18: [
              2,
              12
            ]
          },
          {
            4: 30,
            17: [
              1,
              3
            ],
            19: [
              1,
              4
            ],
            20: [
              1,
              5
            ]
          },
          {
            5: [
              2,
              2
            ],
            6: [
              1,
              7
            ],
            7: [
              2,
              2
            ],
            8: [
              1,
              8
            ],
            9: [
              1,
              9
            ],
            10: [
              1,
              10
            ],
            11: [
              1,
              11
            ],
            12: [
              1,
              12
            ],
            13: [
              1,
              13
            ],
            14: [
              1,
              14
            ],
            15: [
              1,
              15
            ],
            16: [
              1,
              16
            ],
            18: [
              2,
              2
            ]
          }
        ],
        defaultActions: {
          6: [
            2,
            1
          ]
        },
        parseError: function parseError(str, hash) {
          throw new Error(str);
        },
        parse: function parse(input) {
          var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
          this.lexer.setInput(input);
          this.lexer.yy = this.yy;
          this.yy.lexer = this.lexer;
          if (typeof this.lexer.yylloc == 'undefined')
            this.lexer.yylloc = {};
          var yyloc = this.lexer.yylloc;
          lstack.push(yyloc);
          if (typeof this.yy.parseError === 'function')
            this.parseError = this.yy.parseError;
          function popStack(n) {
            stack.length = stack.length - 2 * n;
            vstack.length = vstack.length - n;
            lstack.length = lstack.length - n;
          }
          function lex() {
            var token;
            token = self.lexer.lex() || 1;
            if (typeof token !== 'number') {
              token = self.symbols_[token] || token;
            }
            return token;
          }
          var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
          while (true) {
            state = stack[stack.length - 1];
            if (this.defaultActions[state]) {
              action = this.defaultActions[state];
            } else {
              if (symbol == null)
                symbol = lex();
              action = table[state] && table[state][symbol];
            }
            _handle_error:
              if (typeof action === 'undefined' || !action.length || !action[0]) {
                if (!recovering) {
                  expected = [];
                  for (p in table[state])
                    if (this.terminals_[p] && p > 2) {
                      expected.push('\'' + this.terminals_[p] + '\'');
                    }
                  var errStr = '';
                  if (this.lexer.showPosition) {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + this.lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + this.terminals_[symbol] + '\'';
                  } else {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == 1 ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                  }
                  this.parseError(errStr, {
                    text: this.lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: this.lexer.yylineno,
                    loc: yyloc,
                    expected: expected
                  });
                }
                if (recovering == 3) {
                  if (symbol == EOF) {
                    throw new Error(errStr || 'Parsing halted.');
                  }
                  yyleng = this.lexer.yyleng;
                  yytext = this.lexer.yytext;
                  yylineno = this.lexer.yylineno;
                  yyloc = this.lexer.yylloc;
                  symbol = lex();
                }
                while (1) {
                  if (TERROR.toString() in table[state]) {
                    break;
                  }
                  if (state == 0) {
                    throw new Error(errStr || 'Parsing halted.');
                  }
                  popStack(1);
                  state = stack[stack.length - 1];
                }
                preErrorSymbol = symbol;
                symbol = TERROR;
                state = stack[stack.length - 1];
                action = table[state] && table[state][TERROR];
                recovering = 3;
              }
            if (action[0] instanceof Array && action.length > 1) {
              throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
            }
            switch (action[0]) {
            case 1:
              stack.push(symbol);
              vstack.push(this.lexer.yytext);
              lstack.push(this.lexer.yylloc);
              stack.push(action[1]);
              symbol = null;
              if (!preErrorSymbol) {
                yyleng = this.lexer.yyleng;
                yytext = this.lexer.yytext;
                yylineno = this.lexer.yylineno;
                yyloc = this.lexer.yylloc;
                if (recovering > 0)
                  recovering--;
              } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
              }
              break;
            case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
              };
              r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
              if (typeof r !== 'undefined') {
                return r;
              }
              if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
              }
              stack.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
              stack.push(newState);
              break;
            case 3:
              return true;
            }
          }
          return true;
        }
      };
    var lexer = function () {
        var lexer = {
            EOF: 1,
            parseError: function parseError(str, hash) {
              if (this.yy.parseError) {
                this.yy.parseError(str, hash);
              } else {
                throw new Error(str);
              }
            },
            setInput: function (input) {
              this._input = input;
              this._more = this._less = this.done = false;
              this.yylineno = this.yyleng = 0;
              this.yytext = this.matched = this.match = '';
              this.conditionStack = ['INITIAL'];
              this.yylloc = {
                first_line: 1,
                first_column: 0,
                last_line: 1,
                last_column: 0
              };
              return this;
            },
            input: function () {
              var ch = this._input[0];
              this.yytext += ch;
              this.yyleng++;
              this.match += ch;
              this.matched += ch;
              var lines = ch.match(/\n/);
              if (lines)
                this.yylineno++;
              this._input = this._input.slice(1);
              return ch;
            },
            unput: function (ch) {
              this._input = ch + this._input;
              return this;
            },
            more: function () {
              this._more = true;
              return this;
            },
            pastInput: function () {
              var past = this.matched.substr(0, this.matched.length - this.match.length);
              return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, '');
            },
            upcomingInput: function () {
              var next = this.match;
              if (next.length < 20) {
                next += this._input.substr(0, 20 - next.length);
              }
              return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, '');
            },
            showPosition: function () {
              var pre = this.pastInput();
              var c = new Array(pre.length + 1).join('-');
              return pre + this.upcomingInput() + '\n' + c + '^';
            },
            next: function () {
              if (this.done) {
                return this.EOF;
              }
              if (!this._input)
                this.done = true;
              var token, match, col, lines;
              if (!this._more) {
                this.yytext = '';
                this.match = '';
              }
              var rules = this._currentRules();
              for (var i = 0; i < rules.length; i++) {
                match = this._input.match(this.rules[rules[i]]);
                if (match) {
                  lines = match[0].match(/\n.*/g);
                  if (lines)
                    this.yylineno += lines.length;
                  this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: lines ? lines[lines.length - 1].length - 1 : this.yylloc.last_column + match[0].length
                  };
                  this.yytext += match[0];
                  this.match += match[0];
                  this.matches = match;
                  this.yyleng = this.yytext.length;
                  this._more = false;
                  this._input = this._input.slice(match[0].length);
                  this.matched += match[0];
                  token = this.performAction.call(this, this.yy, this, rules[i], this.conditionStack[this.conditionStack.length - 1]);
                  if (token)
                    return token;
                  else
                    return;
                }
              }
              if (this._input === '') {
                return this.EOF;
              } else {
                this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                  text: '',
                  token: null,
                  line: this.yylineno
                });
              }
            },
            lex: function lex() {
              var r = this.next();
              if (typeof r !== 'undefined') {
                return r;
              } else {
                return this.lex();
              }
            },
            begin: function begin(condition) {
              this.conditionStack.push(condition);
            },
            popState: function popState() {
              return this.conditionStack.pop();
            },
            _currentRules: function _currentRules() {
              return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
            },
            topState: function () {
              return this.conditionStack[this.conditionStack.length - 2];
            },
            pushState: function begin(condition) {
              this.begin(condition);
            }
          };
        lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
          var YYSTATE = YY_START;
          switch ($avoiding_name_collisions) {
          case 0:
            break;
          case 1:
            return 20;
            break;
          case 2:
            return 19;
            break;
          case 3:
            return 8;
            break;
          case 4:
            return 9;
            break;
          case 5:
            return 6;
            break;
          case 6:
            return 7;
            break;
          case 7:
            return 11;
            break;
          case 8:
            return 13;
            break;
          case 9:
            return 10;
            break;
          case 10:
            return 12;
            break;
          case 11:
            return 14;
            break;
          case 12:
            return 15;
            break;
          case 13:
            return 16;
            break;
          case 14:
            return 17;
            break;
          case 15:
            return 18;
            break;
          case 16:
            return 5;
            break;
          case 17:
            return 'INVALID';
            break;
          }
        };
        lexer.rules = [
          /^\s+/,
          /^[0-9]+(\.[0-9]+)?\b/,
          /^n\b/,
          /^\|\|/,
          /^&&/,
          /^\?/,
          /^:/,
          /^<=/,
          /^>=/,
          /^</,
          /^>/,
          /^!=/,
          /^==/,
          /^%/,
          /^\(/,
          /^\)/,
          /^$/,
          /^./
        ];
        lexer.conditions = {
          'INITIAL': {
            'rules': [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              14,
              15,
              16,
              17
            ],
            'inclusive': true
          }
        };
        return lexer;
      }();
    parser.lexer = lexer;
    return parser;
  }();
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = Jed;
    }
    exports.Jed = Jed;
  } else {
    if (typeof define === 'function' && define.amd) {
      define('jed', function () {
        return Jed;
      });
    }
    root['Jed'] = Jed;
  }
}(this));
window.CodeMirror = function () {
  'use strict';
  var gecko = /gecko\/\d/i.test(navigator.userAgent);
  var ie = /MSIE \d/.test(navigator.userAgent);
  var ie_lt8 = ie && (document.documentMode == null || document.documentMode < 8);
  var ie_lt9 = ie && (document.documentMode == null || document.documentMode < 9);
  var webkit = /WebKit\//.test(navigator.userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(navigator.userAgent);
  var chrome = /Chrome\//.test(navigator.userAgent);
  var opera = /Opera\//.test(navigator.userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var khtml = /KHTML\//.test(navigator.userAgent);
  var mac_geLion = /Mac OS X 1\d\D([7-9]|\d\d)\D/.test(navigator.userAgent);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(navigator.userAgent);
  var phantom = /PhantomJS/.test(navigator.userAgent);
  var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent);
  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);
  var mac = ios || /Mac/.test(navigator.platform);
  var windows = /windows/i.test(navigator.platform);
  var opera_version = opera && navigator.userAgent.match(/Version\/(\d*\.\d*)/);
  if (opera_version)
    opera_version = Number(opera_version[1]);
  var flipCtrlCmd = mac && (qtwebkit || opera && (opera_version == null || opera_version < 12.11));
  var captureMiddleClick = gecko || ie && !ie_lt9;
  var sawReadOnlySpans = false, sawCollapsedSpans = false;
  function CodeMirror(place, options) {
    if (!(this instanceof CodeMirror))
      return new CodeMirror(place, options);
    this.options = options = options || {};
    for (var opt in defaults)
      if (!options.hasOwnProperty(opt) && defaults.hasOwnProperty(opt))
        options[opt] = defaults[opt];
    setGuttersForLineNumbers(options);
    var docStart = typeof options.value == 'string' ? 0 : options.value.first;
    var display = this.display = makeDisplay(place, docStart);
    display.wrapper.CodeMirror = this;
    updateGutters(this);
    if (options.autofocus && !mobile)
      focusInput(this);
    this.state = {
      keyMaps: [],
      overlays: [],
      modeGen: 0,
      overwrite: false,
      focused: false,
      suppressEdits: false,
      pasteIncoming: false,
      draggingText: false,
      highlight: new Delayed()
    };
    themeChanged(this);
    if (options.lineWrapping)
      this.display.wrapper.className += ' CodeMirror-wrap';
    var doc = options.value;
    if (typeof doc == 'string')
      doc = new Doc(options.value, options.mode);
    operation(this, attachDoc)(this, doc);
    if (ie)
      setTimeout(bind(resetInput, this, true), 20);
    registerEventHandlers(this);
    var hasFocus;
    try {
      hasFocus = document.activeElement == display.input;
    } catch (e) {
    }
    if (hasFocus || options.autofocus && !mobile)
      setTimeout(bind(onFocus, this), 20);
    else
      onBlur(this);
    operation(this, function () {
      for (var opt in optionHandlers)
        if (optionHandlers.propertyIsEnumerable(opt))
          optionHandlers[opt](this, options[opt], Init);
      for (var i = 0; i < initHooks.length; ++i)
        initHooks[i](this);
    })();
  }
  function makeDisplay(place, docStart) {
    var d = {};
    var input = d.input = elt('textarea', null, null, 'position: absolute; padding: 0; width: 1px; height: 1em; outline: none; font-size: 4px;');
    if (webkit)
      input.style.width = '1000px';
    else
      input.setAttribute('wrap', 'off');
    if (ios)
      input.style.border = '1px solid black';
    input.setAttribute('autocorrect', 'off');
    input.setAttribute('autocapitalize', 'off');
    d.inputDiv = elt('div', [input], null, 'overflow: hidden; position: relative; width: 3px; height: 0px;');
    d.scrollbarH = elt('div', [elt('div', null, null, 'height: 1px')], 'CodeMirror-hscrollbar');
    d.scrollbarV = elt('div', [elt('div', null, null, 'width: 1px')], 'CodeMirror-vscrollbar');
    d.scrollbarFiller = elt('div', null, 'CodeMirror-scrollbar-filler');
    d.lineDiv = elt('div');
    d.selectionDiv = elt('div', null, null, 'position: relative; z-index: 1');
    d.cursor = elt('div', '\xa0', 'CodeMirror-cursor');
    d.otherCursor = elt('div', '\xa0', 'CodeMirror-cursor CodeMirror-secondarycursor');
    d.measure = elt('div', null, 'CodeMirror-measure');
    d.lineSpace = elt('div', [
      d.measure,
      d.selectionDiv,
      d.lineDiv,
      d.cursor,
      d.otherCursor
    ], null, 'position: relative; outline: none');
    d.mover = elt('div', [elt('div', [d.lineSpace], 'CodeMirror-lines')], null, 'position: relative');
    d.sizer = elt('div', [d.mover], 'CodeMirror-sizer');
    d.heightForcer = elt('div', null, null, 'position: absolute; height: ' + scrollerCutOff + 'px; width: 1px;');
    d.gutters = elt('div', null, 'CodeMirror-gutters');
    d.lineGutter = null;
    var scrollerInner = elt('div', [
        d.sizer,
        d.heightForcer,
        d.gutters
      ], null, 'position: relative; min-height: 100%');
    d.scroller = elt('div', [scrollerInner], 'CodeMirror-scroll');
    d.scroller.setAttribute('tabIndex', '-1');
    d.wrapper = elt('div', [
      d.inputDiv,
      d.scrollbarH,
      d.scrollbarV,
      d.scrollbarFiller,
      d.scroller
    ], 'CodeMirror');
    if (ie_lt8) {
      d.gutters.style.zIndex = -1;
      d.scroller.style.paddingRight = 0;
    }
    if (place.appendChild)
      place.appendChild(d.wrapper);
    else
      place(d.wrapper);
    if (ios)
      input.style.width = '0px';
    if (!webkit)
      d.scroller.draggable = true;
    if (khtml) {
      d.inputDiv.style.height = '1px';
      d.inputDiv.style.position = 'absolute';
    } else if (ie_lt8)
      d.scrollbarH.style.minWidth = d.scrollbarV.style.minWidth = '18px';
    d.viewOffset = d.lastSizeC = 0;
    d.showingFrom = d.showingTo = docStart;
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    d.prevInput = '';
    d.alignWidgets = false;
    d.pollingFast = false;
    d.poll = new Delayed();
    d.cachedCharWidth = d.cachedTextHeight = null;
    d.measureLineCache = [];
    d.measureLineCachePos = 0;
    d.inaccurateSelection = false;
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;
    return d;
  }
  function loadMode(cm) {
    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);
    cm.doc.iter(function (line) {
      if (line.stateAfter)
        line.stateAfter = null;
      if (line.styles)
        line.styles = null;
    });
    cm.doc.frontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp)
      regChange(cm);
  }
  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      cm.display.wrapper.className += ' CodeMirror-wrap';
      cm.display.sizer.style.minWidth = '';
    } else {
      cm.display.wrapper.className = cm.display.wrapper.className.replace(' CodeMirror-wrap', '');
      computeMaxLength(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function () {
      updateScrollbars(cm.display, cm.doc.height);
    }, 100);
  }
  function estimateHeight(cm) {
    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function (line) {
      if (lineIsHidden(cm.doc, line))
        return 0;
      else if (wrapping)
        return (Math.ceil(line.text.length / perLine) || 1) * th;
      else
        return th;
    };
  }
  function estimateLineHeights(cm) {
    var doc = cm.doc, est = estimateHeight(cm);
    doc.iter(function (line) {
      var estHeight = est(line);
      if (estHeight != line.height)
        updateLineHeight(line, estHeight);
    });
  }
  function keyMapChanged(cm) {
    var style = keyMap[cm.options.keyMap].style;
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-keymap-\S+/g, '') + (style ? ' cm-keymap-' + style : '');
  }
  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, '') + cm.options.theme.replace(/(^|\s)\s*/g, ' cm-s-');
    clearCaches(cm);
  }
  function guttersChanged(cm) {
    updateGutters(cm);
    regChange(cm);
  }
  function updateGutters(cm) {
    var gutters = cm.display.gutters, specs = cm.options.gutters;
    removeChildren(gutters);
    for (var i = 0; i < specs.length; ++i) {
      var gutterClass = specs[i];
      var gElt = gutters.appendChild(elt('div', null, 'CodeMirror-gutter ' + gutterClass));
      if (gutterClass == 'CodeMirror-linenumbers') {
        cm.display.lineGutter = gElt;
        gElt.style.width = (cm.display.lineNumWidth || 1) + 'px';
      }
    }
    gutters.style.display = i ? '' : 'none';
  }
  function lineLength(doc, line) {
    if (line.height == 0)
      return 0;
    var len = line.text.length, merged, cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find();
      cur = getLine(doc, found.from.line);
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found = merged.find();
      len -= cur.text.length - found.from.ch;
      cur = getLine(doc, found.to.line);
      len += cur.text.length - found.to.ch;
    }
    return len;
  }
  function computeMaxLength(cm) {
    var d = cm.display, doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(doc, d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function (line) {
      var len = lineLength(doc, line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }
  function setGuttersForLineNumbers(options) {
    var found = false;
    for (var i = 0; i < options.gutters.length; ++i) {
      if (options.gutters[i] == 'CodeMirror-linenumbers') {
        if (options.lineNumbers)
          found = true;
        else
          options.gutters.splice(i--, 1);
      }
    }
    if (!found && options.lineNumbers)
      options.gutters.push('CodeMirror-linenumbers');
  }
  function updateScrollbars(d, docHeight) {
    var totalHeight = docHeight + paddingVert(d);
    d.sizer.style.minHeight = d.heightForcer.style.top = totalHeight + 'px';
    var scrollHeight = Math.max(totalHeight, d.scroller.scrollHeight);
    var needsH = d.scroller.scrollWidth > d.scroller.clientWidth;
    var needsV = scrollHeight > d.scroller.clientHeight;
    if (needsV) {
      d.scrollbarV.style.display = 'block';
      d.scrollbarV.style.bottom = needsH ? scrollbarWidth(d.measure) + 'px' : '0';
      d.scrollbarV.firstChild.style.height = scrollHeight - d.scroller.clientHeight + d.scrollbarV.clientHeight + 'px';
    } else
      d.scrollbarV.style.display = '';
    if (needsH) {
      d.scrollbarH.style.display = 'block';
      d.scrollbarH.style.right = needsV ? scrollbarWidth(d.measure) + 'px' : '0';
      d.scrollbarH.firstChild.style.width = d.scroller.scrollWidth - d.scroller.clientWidth + d.scrollbarH.clientWidth + 'px';
    } else
      d.scrollbarH.style.display = '';
    if (needsH && needsV) {
      d.scrollbarFiller.style.display = 'block';
      d.scrollbarFiller.style.height = d.scrollbarFiller.style.width = scrollbarWidth(d.measure) + 'px';
    } else
      d.scrollbarFiller.style.display = '';
    if (mac_geLion && scrollbarWidth(d.measure) === 0)
      d.scrollbarV.style.minWidth = d.scrollbarH.style.minHeight = mac_geMountainLion ? '18px' : '12px';
  }
  function visibleLines(display, doc, viewPort) {
    var top = display.scroller.scrollTop, height = display.wrapper.clientHeight;
    if (typeof viewPort == 'number')
      top = viewPort;
    else if (viewPort) {
      top = viewPort.top;
      height = viewPort.bottom - viewPort.top;
    }
    top = Math.floor(top - paddingTop(display));
    var bottom = Math.ceil(top + height);
    return {
      from: lineAtHeight(doc, top),
      to: lineAtHeight(doc, bottom)
    };
  }
  function alignHorizontally(cm) {
    var display = cm.display;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter))
      return;
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth, l = comp + 'px';
    for (var n = display.lineDiv.firstChild; n; n = n.nextSibling)
      if (n.alignable) {
        for (var i = 0, a = n.alignable; i < a.length; ++i)
          a[i].style.left = l;
      }
    if (cm.options.fixedGutter)
      display.gutters.style.left = comp + gutterW + 'px';
  }
  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers)
      return false;
    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt('div', [elt('div', last)], 'CodeMirror-linenumber CodeMirror-gutter-elt'));
      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = '';
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding);
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + 'px';
      return true;
    }
    return false;
  }
  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber));
  }
  function compensateForHScroll(display) {
    return getRect(display.scroller).left - getRect(display.sizer).left;
  }
  function updateDisplay(cm, changes, viewPort) {
    var oldFrom = cm.display.showingFrom, oldTo = cm.display.showingTo, updated;
    var visible = visibleLines(cm.display, cm.doc, viewPort);
    for (;;) {
      if (updateDisplayInner(cm, changes, visible)) {
        updated = true;
        signalLater(cm, 'update', cm);
        if (cm.display.showingFrom != oldFrom || cm.display.showingTo != oldTo)
          signalLater(cm, 'viewportChange', cm, cm.display.showingFrom, cm.display.showingTo);
      } else
        break;
      updateSelection(cm);
      updateScrollbars(cm.display, cm.doc.height);
      if (viewPort)
        viewPort = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, typeof viewPort == 'number' ? viewPort : viewPort.top);
      visible = visibleLines(cm.display, cm.doc, viewPort);
      if (visible.from >= cm.display.showingFrom && visible.to <= cm.display.showingTo)
        break;
      changes = [];
    }
    return updated;
  }
  function updateDisplayInner(cm, changes, visible) {
    var display = cm.display, doc = cm.doc;
    if (!display.wrapper.clientWidth) {
      display.showingFrom = display.showingTo = doc.first;
      display.viewOffset = 0;
      return;
    }
    if (changes.length == 0 && visible.from > display.showingFrom && visible.to < display.showingTo)
      return;
    if (maybeUpdateLineNumberWidth(cm))
      changes = [{
          from: doc.first,
          to: doc.first + doc.size
        }];
    var gutterW = display.sizer.style.marginLeft = display.gutters.offsetWidth + 'px';
    display.scrollbarH.style.left = cm.options.fixedGutter ? gutterW : '0';
    var positionsChangedFrom = Infinity;
    if (cm.options.lineNumbers)
      for (var i = 0; i < changes.length; ++i)
        if (changes[i].diff) {
          positionsChangedFrom = changes[i].from;
          break;
        }
    var end = doc.first + doc.size;
    var from = Math.max(visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, visible.to + cm.options.viewportMargin);
    if (display.showingFrom < from && from - display.showingFrom < 20)
      from = Math.max(doc.first, display.showingFrom);
    if (display.showingTo > to && display.showingTo - to < 20)
      to = Math.min(end, display.showingTo);
    if (sawCollapsedSpans) {
      from = lineNo(visualLine(doc, getLine(doc, from)));
      while (to < end && lineIsHidden(doc, getLine(doc, to)))
        ++to;
    }
    var intact = [{
          from: Math.max(display.showingFrom, doc.first),
          to: Math.min(display.showingTo, end)
        }];
    if (intact[0].from >= intact[0].to)
      intact = [];
    else
      intact = computeIntact(intact, changes);
    if (sawCollapsedSpans)
      for (var i = 0; i < intact.length; ++i) {
        var range = intact[i], merged;
        while (merged = collapsedSpanAtEnd(getLine(doc, range.to - 1))) {
          var newTo = merged.find().from.line;
          if (newTo > range.from)
            range.to = newTo;
          else {
            intact.splice(i--, 1);
            break;
          }
        }
      }
    var intactLines = 0;
    for (var i = 0; i < intact.length; ++i) {
      var range = intact[i];
      if (range.from < from)
        range.from = from;
      if (range.to > to)
        range.to = to;
      if (range.from >= range.to)
        intact.splice(i--, 1);
      else
        intactLines += range.to - range.from;
    }
    if (intactLines == to - from && from == display.showingFrom && to == display.showingTo) {
      updateViewOffset(cm);
      return;
    }
    intact.sort(function (a, b) {
      return a.from - b.from;
    });
    try {
      var focused = document.activeElement;
    } catch (e) {
    }
    if (intactLines < (to - from) * 0.7)
      display.lineDiv.style.display = 'none';
    patchDisplay(cm, from, to, intact, positionsChangedFrom);
    display.lineDiv.style.display = '';
    if (focused && document.activeElement != focused && focused.offsetHeight)
      focused.focus();
    var different = from != display.showingFrom || to != display.showingTo || display.lastSizeC != display.wrapper.clientHeight;
    if (different)
      display.lastSizeC = display.wrapper.clientHeight;
    display.showingFrom = from;
    display.showingTo = to;
    startWorker(cm, 100);
    var prevBottom = display.lineDiv.offsetTop;
    for (var node = display.lineDiv.firstChild, height; node; node = node.nextSibling)
      if (node.lineObj) {
        if (ie_lt8) {
          var bot = node.offsetTop + node.offsetHeight;
          height = bot - prevBottom;
          prevBottom = bot;
        } else {
          var box = getRect(node);
          height = box.bottom - box.top;
        }
        var diff = node.lineObj.height - height;
        if (height < 2)
          height = textHeight(display);
        if (diff > 0.001 || diff < -0.001) {
          updateLineHeight(node.lineObj, height);
          var widgets = node.lineObj.widgets;
          if (widgets)
            for (var i = 0; i < widgets.length; ++i)
              widgets[i].height = widgets[i].node.offsetHeight;
        }
      }
    updateViewOffset(cm);
    return true;
  }
  function updateViewOffset(cm) {
    var off = cm.display.viewOffset = heightAtLine(cm, getLine(cm.doc, cm.display.showingFrom));
    cm.display.mover.style.top = off + 'px';
  }
  function computeIntact(intact, changes) {
    for (var i = 0, l = changes.length || 0; i < l; ++i) {
      var change = changes[i], intact2 = [], diff = change.diff || 0;
      for (var j = 0, l2 = intact.length; j < l2; ++j) {
        var range = intact[j];
        if (change.to <= range.from && change.diff) {
          intact2.push({
            from: range.from + diff,
            to: range.to + diff
          });
        } else if (change.to <= range.from || change.from >= range.to) {
          intact2.push(range);
        } else {
          if (change.from > range.from)
            intact2.push({
              from: range.from,
              to: change.from
            });
          if (change.to < range.to)
            intact2.push({
              from: change.to + diff,
              to: range.to + diff
            });
        }
      }
      intact = intact2;
    }
    return intact;
  }
  function getDimensions(cm) {
    var d = cm.display, left = {}, width = {};
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      left[cm.options.gutters[i]] = n.offsetLeft;
      width[cm.options.gutters[i]] = n.offsetWidth;
    }
    return {
      fixedPos: compensateForHScroll(d),
      gutterTotalWidth: d.gutters.offsetWidth,
      gutterLeft: left,
      gutterWidth: width,
      wrapperWidth: d.wrapper.clientWidth
    };
  }
  function patchDisplay(cm, from, to, intact, updateNumbersFrom) {
    var dims = getDimensions(cm);
    var display = cm.display, lineNumbers = cm.options.lineNumbers;
    if (!intact.length && (!webkit || !cm.display.currentWheelTarget))
      removeChildren(display.lineDiv);
    var container = display.lineDiv, cur = container.firstChild;
    function rm(node) {
      var next = node.nextSibling;
      if (webkit && mac && cm.display.currentWheelTarget == node) {
        node.style.display = 'none';
        node.lineObj = null;
      } else {
        node.parentNode.removeChild(node);
      }
      return next;
    }
    var nextIntact = intact.shift(), lineN = from;
    cm.doc.iter(from, to, function (line) {
      if (nextIntact && nextIntact.to == lineN)
        nextIntact = intact.shift();
      if (lineIsHidden(cm.doc, line)) {
        if (line.height != 0)
          updateLineHeight(line, 0);
        if (line.widgets && cur.previousSibling)
          for (var i = 0; i < line.widgets.length; ++i)
            if (line.widgets[i].showIfHidden) {
              var prev = cur.previousSibling;
              if (/pre/i.test(prev.nodeName)) {
                var wrap = elt('div', null, null, 'position: relative');
                prev.parentNode.replaceChild(wrap, prev);
                wrap.appendChild(prev);
                prev = wrap;
              }
              var wnode = prev.appendChild(elt('div', [line.widgets[i].node], 'CodeMirror-linewidget'));
              positionLineWidget(line.widgets[i], wnode, prev, dims);
            }
      } else if (nextIntact && nextIntact.from <= lineN && nextIntact.to > lineN) {
        while (cur.lineObj != line)
          cur = rm(cur);
        if (lineNumbers && updateNumbersFrom <= lineN && cur.lineNumber)
          setTextContent(cur.lineNumber, lineNumberFor(cm.options, lineN));
        cur = cur.nextSibling;
      } else {
        if (line.widgets)
          for (var j = 0, search = cur, reuse; search && j < 20; ++j, search = search.nextSibling)
            if (search.lineObj == line && /div/i.test(search.nodeName)) {
              reuse = search;
              break;
            }
        var lineNode = buildLineElement(cm, line, lineN, dims, reuse);
        if (lineNode != reuse) {
          container.insertBefore(lineNode, cur);
        } else {
          while (cur != reuse)
            cur = rm(cur);
          cur = cur.nextSibling;
        }
        lineNode.lineObj = line;
      }
      ++lineN;
    });
    while (cur)
      cur = rm(cur);
  }
  function buildLineElement(cm, line, lineNo, dims, reuse) {
    var lineElement = lineContent(cm, line);
    var markers = line.gutterMarkers, display = cm.display, wrap;
    if (!cm.options.lineNumbers && !markers && !line.bgClass && !line.wrapClass && !line.widgets)
      return lineElement;
    if (reuse) {
      reuse.alignable = null;
      var isOk = true, widgetsSeen = 0;
      for (var n = reuse.firstChild, next; n; n = next) {
        next = n.nextSibling;
        if (!/\bCodeMirror-linewidget\b/.test(n.className)) {
          reuse.removeChild(n);
        } else {
          for (var i = 0, first = true; i < line.widgets.length; ++i) {
            var widget = line.widgets[i], isFirst = false;
            if (!widget.above) {
              isFirst = first;
              first = false;
            }
            if (widget.node == n.firstChild) {
              positionLineWidget(widget, n, reuse, dims);
              ++widgetsSeen;
              if (isFirst)
                reuse.insertBefore(lineElement, n);
              break;
            }
          }
          if (i == line.widgets.length) {
            isOk = false;
            break;
          }
        }
      }
      if (isOk && widgetsSeen == line.widgets.length) {
        wrap = reuse;
        reuse.className = line.wrapClass || '';
      }
    }
    if (!wrap) {
      wrap = elt('div', null, line.wrapClass, 'position: relative');
      wrap.appendChild(lineElement);
    }
    if (line.bgClass)
      wrap.insertBefore(elt('div', null, line.bgClass + ' CodeMirror-linebackground'), wrap.firstChild);
    if (cm.options.lineNumbers || markers) {
      var gutterWrap = wrap.insertBefore(elt('div', null, null, 'position: absolute; left: ' + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + 'px'), wrap.firstChild);
      if (cm.options.fixedGutter)
        (wrap.alignable || (wrap.alignable = [])).push(gutterWrap);
      if (cm.options.lineNumbers && (!markers || !markers['CodeMirror-linenumbers']))
        wrap.lineNumber = gutterWrap.appendChild(elt('div', lineNumberFor(cm.options, lineNo), 'CodeMirror-linenumber CodeMirror-gutter-elt', 'left: ' + dims.gutterLeft['CodeMirror-linenumbers'] + 'px; width: ' + display.lineNumInnerWidth + 'px'));
      if (markers)
        for (var k = 0; k < cm.options.gutters.length; ++k) {
          var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
          if (found)
            gutterWrap.appendChild(elt('div', [found], 'CodeMirror-gutter-elt', 'left: ' + dims.gutterLeft[id] + 'px; width: ' + dims.gutterWidth[id] + 'px'));
        }
    }
    if (ie_lt8)
      wrap.style.zIndex = 2;
    if (line.widgets && wrap != reuse)
      for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
        var widget = ws[i], node = elt('div', [widget.node], 'CodeMirror-linewidget');
        positionLineWidget(widget, node, wrap, dims);
        if (widget.above)
          wrap.insertBefore(node, cm.options.lineNumbers && line.height != 0 ? gutterWrap : lineElement);
        else
          wrap.appendChild(node);
        signalLater(widget, 'redraw');
      }
    return wrap;
  }
  function positionLineWidget(widget, node, wrap, dims) {
    if (widget.noHScroll) {
      (wrap.alignable || (wrap.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + 'px';
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + 'px';
      }
      node.style.width = width + 'px';
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = 'relative';
      if (!widget.noHScroll)
        node.style.marginLeft = -dims.gutterTotalWidth + 'px';
    }
  }
  function updateSelection(cm) {
    var display = cm.display;
    var collapsed = posEq(cm.doc.sel.from, cm.doc.sel.to);
    if (collapsed || cm.options.showCursorWhenSelecting)
      updateSelectionCursor(cm);
    else
      display.cursor.style.display = display.otherCursor.style.display = 'none';
    if (!collapsed)
      updateSelectionRange(cm);
    else
      display.selectionDiv.style.display = 'none';
    if (cm.options.moveInputWithCursor) {
      var headPos = cursorCoords(cm, cm.doc.sel.head, 'div');
      var wrapOff = getRect(display.wrapper), lineOff = getRect(display.lineDiv);
      display.inputDiv.style.top = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top)) + 'px';
      display.inputDiv.style.left = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left)) + 'px';
    }
  }
  function updateSelectionCursor(cm) {
    var display = cm.display, pos = cursorCoords(cm, cm.doc.sel.head, 'div');
    display.cursor.style.left = pos.left + 'px';
    display.cursor.style.top = pos.top + 'px';
    display.cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + 'px';
    display.cursor.style.display = '';
    if (pos.other) {
      display.otherCursor.style.display = '';
      display.otherCursor.style.left = pos.other.left + 'px';
      display.otherCursor.style.top = pos.other.top + 'px';
      display.otherCursor.style.height = (pos.other.bottom - pos.other.top) * 0.85 + 'px';
    } else {
      display.otherCursor.style.display = 'none';
    }
  }
  function updateSelectionRange(cm) {
    var display = cm.display, doc = cm.doc, sel = cm.doc.sel;
    var fragment = document.createDocumentFragment();
    var clientWidth = display.lineSpace.offsetWidth, pl = paddingLeft(cm.display);
    function add(left, top, width, bottom) {
      if (top < 0)
        top = 0;
      fragment.appendChild(elt('div', null, 'CodeMirror-selected', 'position: absolute; left: ' + left + 'px; top: ' + top + 'px; width: ' + (width == null ? clientWidth - left : width) + 'px; height: ' + (bottom - top) + 'px'));
    }
    function drawForLine(line, fromArg, toArg, retTop) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length, rVal = retTop ? Infinity : -Infinity;
      function coords(ch) {
        return charCoords(cm, Pos(line, ch), 'div', lineObj);
      }
      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir) {
        var leftPos = coords(from), rightPos, left, right;
        if (from == to) {
          rightPos = leftPos;
          left = right = leftPos.left;
        } else {
          rightPos = coords(to - 1);
          if (dir == 'rtl') {
            var tmp = leftPos;
            leftPos = rightPos;
            rightPos = tmp;
          }
          left = leftPos.left;
          right = rightPos.right;
        }
        if (rightPos.top - leftPos.top > 3) {
          add(left, leftPos.top, null, leftPos.bottom);
          left = pl;
          if (leftPos.bottom < rightPos.top)
            add(left, leftPos.bottom, null, rightPos.top);
        }
        if (toArg == null && to == lineLen)
          right = clientWidth;
        if (fromArg == null && from == 0)
          left = pl;
        rVal = retTop ? Math.min(rightPos.top, rVal) : Math.max(rightPos.bottom, rVal);
        if (left < pl + 1)
          left = pl;
        add(left, rightPos.top, right - left, rightPos.bottom);
      });
      return rVal;
    }
    if (sel.from.line == sel.to.line) {
      drawForLine(sel.from.line, sel.from.ch, sel.to.ch);
    } else {
      var fromObj = getLine(doc, sel.from.line);
      var cur = fromObj, merged, path = [
          sel.from.line,
          sel.from.ch
        ], singleLine;
      while (merged = collapsedSpanAtEnd(cur)) {
        var found = merged.find();
        path.push(found.from.ch, found.to.line, found.to.ch);
        if (found.to.line == sel.to.line) {
          path.push(sel.to.ch);
          singleLine = true;
          break;
        }
        cur = getLine(doc, found.to.line);
      }
      if (singleLine) {
        for (var i = 0; i < path.length; i += 3)
          drawForLine(path[i], path[i + 1], path[i + 2]);
      } else {
        var middleTop, middleBot, toObj = getLine(doc, sel.to.line);
        if (sel.from.ch)
          middleTop = drawForLine(sel.from.line, sel.from.ch, null, false);
        else
          middleTop = heightAtLine(cm, fromObj) - display.viewOffset;
        if (!sel.to.ch)
          middleBot = heightAtLine(cm, toObj) - display.viewOffset;
        else
          middleBot = drawForLine(sel.to.line, collapsedSpanAtStart(toObj) ? null : 0, sel.to.ch, true);
        if (middleTop < middleBot)
          add(pl, middleTop, null, middleBot);
      }
    }
    removeChildrenAndAdd(display.selectionDiv, fragment);
    display.selectionDiv.style.display = '';
  }
  function restartBlink(cm) {
    if (!cm.state.focused)
      return;
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursor.style.visibility = display.otherCursor.style.visibility = '';
    display.blinker = setInterval(function () {
      display.cursor.style.visibility = display.otherCursor.style.visibility = (on = !on) ? '' : 'hidden';
    }, cm.options.cursorBlinkRate);
  }
  function startWorker(cm, time) {
    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.showingTo)
      cm.state.highlight.set(time, bind(highlightWorker, cm));
  }
  function highlightWorker(cm) {
    var doc = cm.doc;
    if (doc.frontier < doc.first)
      doc.frontier = doc.first;
    if (doc.frontier >= cm.display.showingTo)
      return;
    var end = +new Date() + cm.options.workTime;
    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));
    var changed = [], prevChange;
    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.showingTo + 500), function (line) {
      if (doc.frontier >= cm.display.showingFrom) {
        var oldStyles = line.styles;
        line.styles = highlightLine(cm, line, state);
        var ischange = !oldStyles || oldStyles.length != line.styles.length;
        for (var i = 0; !ischange && i < oldStyles.length; ++i)
          ischange = oldStyles[i] != line.styles[i];
        if (ischange) {
          if (prevChange && prevChange.end == doc.frontier)
            prevChange.end++;
          else
            changed.push(prevChange = {
              start: doc.frontier,
              end: doc.frontier + 1
            });
        }
        line.stateAfter = copyState(doc.mode, state);
      } else {
        processLine(cm, line, state);
        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
      }
      ++doc.frontier;
      if (+new Date() > end) {
        startWorker(cm, cm.options.workDelay);
        return true;
      }
    });
    if (changed.length)
      operation(cm, function () {
        for (var i = 0; i < changed.length; ++i)
          regChange(this, changed[i].start, changed[i].end);
      })();
  }
  function findStartLine(cm, n) {
    var minindent, minline, doc = cm.doc;
    for (var search = n, lim = n - 100; search > lim; --search) {
      if (search <= doc.first)
        return doc.first;
      var line = getLine(doc, search - 1);
      if (line.stateAfter)
        return search;
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline;
  }
  function getStateBefore(cm, n) {
    var doc = cm.doc, display = cm.display;
    if (!doc.mode.startState)
      return true;
    var pos = findStartLine(cm, n), state = pos > doc.first && getLine(doc, pos - 1).stateAfter;
    if (!state)
      state = startState(doc.mode);
    else
      state = copyState(doc.mode, state);
    doc.iter(pos, n, function (line) {
      processLine(cm, line, state);
      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.showingFrom && pos < display.showingTo;
      line.stateAfter = save ? copyState(doc.mode, state) : null;
      ++pos;
    });
    return state;
  }
  function paddingTop(display) {
    return display.lineSpace.offsetTop;
  }
  function paddingVert(display) {
    return display.mover.offsetHeight - display.lineSpace.offsetHeight;
  }
  function paddingLeft(display) {
    var e = removeChildrenAndAdd(display.measure, elt('pre', null, null, 'text-align: left')).appendChild(elt('span', 'x'));
    return e.offsetLeft;
  }
  function measureChar(cm, line, ch, data) {
    var dir = -1;
    data = data || measureLine(cm, line);
    for (var pos = ch;; pos += dir) {
      var r = data[pos];
      if (r)
        break;
      if (dir < 0 && pos == 0)
        dir = 1;
    }
    return {
      left: pos < ch ? r.right : r.left,
      right: pos > ch ? r.left : r.right,
      top: r.top,
      bottom: r.bottom
    };
  }
  function findCachedMeasurement(cm, line) {
    var cache = cm.display.measureLineCache;
    for (var i = 0; i < cache.length; ++i) {
      var memo = cache[i];
      if (memo.text == line.text && memo.markedSpans == line.markedSpans && cm.display.scroller.clientWidth == memo.width && memo.classes == line.textClass + '|' + line.bgClass + '|' + line.wrapClass)
        return memo.measure;
    }
  }
  function measureLine(cm, line) {
    var measure = findCachedMeasurement(cm, line);
    if (!measure) {
      measure = measureLineInner(cm, line);
      var cache = cm.display.measureLineCache;
      var memo = {
          text: line.text,
          width: cm.display.scroller.clientWidth,
          markedSpans: line.markedSpans,
          measure: measure,
          classes: line.textClass + '|' + line.bgClass + '|' + line.wrapClass
        };
      if (cache.length == 16)
        cache[++cm.display.measureLineCachePos % 16] = memo;
      else
        cache.push(memo);
    }
    return measure;
  }
  function measureLineInner(cm, line) {
    var display = cm.display, measure = emptyArray(line.text.length);
    var pre = lineContent(cm, line, measure);
    if (ie && !ie_lt8 && !cm.options.lineWrapping && pre.childNodes.length > 100) {
      var fragment = document.createDocumentFragment();
      var chunk = 10, n = pre.childNodes.length;
      for (var i = 0, chunks = Math.ceil(n / chunk); i < chunks; ++i) {
        var wrap = elt('div', null, null, 'display: inline-block');
        for (var j = 0; j < chunk && n; ++j) {
          wrap.appendChild(pre.firstChild);
          --n;
        }
        fragment.appendChild(wrap);
      }
      pre.appendChild(fragment);
    }
    removeChildrenAndAdd(display.measure, pre);
    var outer = getRect(display.lineDiv);
    var vranges = [], data = emptyArray(line.text.length), maxBot = pre.offsetHeight;
    if (ie_lt9 && display.measure.first != pre)
      removeChildrenAndAdd(display.measure, pre);
    for (var i = 0, cur; i < measure.length; ++i)
      if (cur = measure[i]) {
        var size = getRect(cur);
        var top = Math.max(0, size.top - outer.top), bot = Math.min(size.bottom - outer.top, maxBot);
        for (var j = 0; j < vranges.length; j += 2) {
          var rtop = vranges[j], rbot = vranges[j + 1];
          if (rtop > bot || rbot < top)
            continue;
          if (rtop <= top && rbot >= bot || top <= rtop && bot >= rbot || Math.min(bot, rbot) - Math.max(top, rtop) >= bot - top >> 1) {
            vranges[j] = Math.min(top, rtop);
            vranges[j + 1] = Math.max(bot, rbot);
            break;
          }
        }
        if (j == vranges.length)
          vranges.push(top, bot);
        var right = size.right;
        if (cur.measureRight)
          right = getRect(cur.measureRight).left;
        data[i] = {
          left: size.left - outer.left,
          right: right - outer.left,
          top: j
        };
      }
    for (var i = 0, cur; i < data.length; ++i)
      if (cur = data[i]) {
        var vr = cur.top;
        cur.top = vranges[vr];
        cur.bottom = vranges[vr + 1];
      }
    return data;
  }
  function measureLineWidth(cm, line) {
    var hasBadSpan = false;
    if (line.markedSpans)
      for (var i = 0; i < line.markedSpans; ++i) {
        var sp = line.markedSpans[i];
        if (sp.collapsed && (sp.to == null || sp.to == line.text.length))
          hasBadSpan = true;
      }
    var cached = !hasBadSpan && findCachedMeasurement(cm, line);
    if (cached)
      return measureChar(cm, line, line.text.length, cached).right;
    var pre = lineContent(cm, line);
    var end = pre.appendChild(zeroWidthElement(cm.display.measure));
    removeChildrenAndAdd(cm.display.measure, pre);
    return getRect(end).right - getRect(cm.display.lineDiv).left;
  }
  function clearCaches(cm) {
    cm.display.measureLineCache.length = cm.display.measureLineCachePos = 0;
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = null;
    if (!cm.options.lineWrapping)
      cm.display.maxLineChanged = true;
    cm.display.lineNumChars = null;
  }
  function intoCoordSystem(cm, lineObj, rect, context) {
    if (lineObj.widgets)
      for (var i = 0; i < lineObj.widgets.length; ++i)
        if (lineObj.widgets[i].above) {
          var size = widgetHeight(lineObj.widgets[i]);
          rect.top += size;
          rect.bottom += size;
        }
    if (context == 'line')
      return rect;
    if (!context)
      context = 'local';
    var yOff = heightAtLine(cm, lineObj);
    if (context != 'local')
      yOff -= cm.display.viewOffset;
    if (context == 'page') {
      var lOff = getRect(cm.display.lineSpace);
      yOff += lOff.top + (window.pageYOffset || (document.documentElement || document.body).scrollTop);
      var xOff = lOff.left + (window.pageXOffset || (document.documentElement || document.body).scrollLeft);
      rect.left += xOff;
      rect.right += xOff;
    }
    rect.top += yOff;
    rect.bottom += yOff;
    return rect;
  }
  function fromCoordSystem(cm, coords, context) {
    if (context == 'div')
      return coords;
    var left = coords.left, top = coords.top;
    if (context == 'page') {
      left -= window.pageXOffset || (document.documentElement || document.body).scrollLeft;
      top -= window.pageYOffset || (document.documentElement || document.body).scrollTop;
    }
    var lineSpaceBox = getRect(cm.display.lineSpace);
    left -= lineSpaceBox.left;
    top -= lineSpaceBox.top;
    if (context == 'local' || !context) {
      var editorBox = getRect(cm.display.wrapper);
      left += editorBox.left;
      top += editorBox.top;
    }
    return {
      left: left,
      top: top
    };
  }
  function charCoords(cm, pos, context, lineObj) {
    if (!lineObj)
      lineObj = getLine(cm.doc, pos.line);
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch), context);
  }
  function cursorCoords(cm, pos, context, lineObj, measurement) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!measurement)
      measurement = measureLine(cm, lineObj);
    function get(ch, right) {
      var m = measureChar(cm, lineObj, ch, measurement);
      if (right)
        m.left = m.right;
      else
        m.right = m.left;
      return intoCoordSystem(cm, lineObj, m, context);
    }
    var order = getOrder(lineObj), ch = pos.ch;
    if (!order)
      return get(ch);
    var main, other, linedir = order[0].level;
    for (var i = 0; i < order.length; ++i) {
      var part = order[i], rtl = part.level % 2, nb, here;
      if (part.from < ch && part.to > ch)
        return get(ch, rtl);
      var left = rtl ? part.to : part.from, right = rtl ? part.from : part.to;
      if (left == ch) {
        if (i && part.level < (nb = order[i - 1]).level)
          here = get(nb.level % 2 ? nb.from : nb.to - 1, true);
        else
          here = get(rtl && part.from != part.to ? ch - 1 : ch);
        if (rtl == linedir)
          main = here;
        else
          other = here;
      } else if (right == ch) {
        var nb = i < order.length - 1 && order[i + 1];
        if (!rtl && nb && nb.from == nb.to)
          continue;
        if (nb && part.level < nb.level)
          here = get(nb.level % 2 ? nb.to - 1 : nb.from);
        else
          here = get(rtl ? ch : ch - 1, true);
        if (rtl == linedir)
          main = here;
        else
          other = here;
      }
    }
    if (linedir && !ch)
      other = get(order[0].to - 1);
    if (!main)
      return other;
    if (other)
      main.other = other;
    return main;
  }
  function PosMaybeOutside(line, ch, outside) {
    var pos = new Pos(line, ch);
    if (outside)
      pos.outside = true;
    return pos;
  }
  function coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0)
      return PosMaybeOutside(doc.first, 0, true);
    var lineNo = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
    if (lineNo > last)
      return PosMaybeOutside(doc.first + doc.size - 1, getLine(doc, last).text.length, true);
    if (x < 0)
      x = 0;
    for (;;) {
      var lineObj = getLine(doc, lineNo);
      var found = coordsCharInner(cm, lineObj, lineNo, x, y);
      var merged = collapsedSpanAtEnd(lineObj);
      var mergedPos = merged && merged.find();
      if (merged && found.ch >= mergedPos.from.ch)
        lineNo = mergedPos.to.line;
      else
        return found;
    }
  }
  function coordsCharInner(cm, lineObj, lineNo, x, y) {
    var innerOff = y - heightAtLine(cm, lineObj);
    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;
    var measurement = measureLine(cm, lineObj);
    function getX(ch) {
      var sp = cursorCoords(cm, Pos(lineNo, ch), 'line', lineObj, measurement);
      wrongLine = true;
      if (innerOff > sp.bottom)
        return sp.left - adjust;
      else if (innerOff < sp.top)
        return sp.left + adjust;
      else
        wrongLine = false;
      return sp.left;
    }
    var bidi = getOrder(lineObj), dist = lineObj.text.length;
    var from = lineLeft(lineObj), to = lineRight(lineObj);
    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;
    if (x > toX)
      return PosMaybeOutside(lineNo, to, toOutside);
    for (;;) {
      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
        var after = x - fromX < toX - x, ch = after ? from : to;
        while (isExtendingChar.test(lineObj.text.charAt(ch)))
          ++ch;
        var pos = PosMaybeOutside(lineNo, ch, after ? fromOutside : toOutside);
        pos.after = after;
        return pos;
      }
      var step = Math.ceil(dist / 2), middle = from + step;
      if (bidi) {
        middle = from;
        for (var i = 0; i < step; ++i)
          middle = moveVisually(lineObj, middle, 1);
      }
      var middleX = getX(middle);
      if (middleX > x) {
        to = middle;
        toX = middleX;
        if (toOutside = wrongLine)
          toX += 1000;
        dist = step;
      } else {
        from = middle;
        fromX = middleX;
        fromOutside = wrongLine;
        dist -= step;
      }
    }
  }
  var measureText;
  function textHeight(display) {
    if (display.cachedTextHeight != null)
      return display.cachedTextHeight;
    if (measureText == null) {
      measureText = elt('pre');
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode('x'));
        measureText.appendChild(elt('br'));
      }
      measureText.appendChild(document.createTextNode('x'));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3)
      display.cachedTextHeight = height;
    removeChildren(display.measure);
    return height || 1;
  }
  function charWidth(display) {
    if (display.cachedCharWidth != null)
      return display.cachedCharWidth;
    var anchor = elt('span', 'x');
    var pre = elt('pre', [anchor]);
    removeChildrenAndAdd(display.measure, pre);
    var width = anchor.offsetWidth;
    if (width > 2)
      display.cachedCharWidth = width;
    return width || 10;
  }
  var nextOpId = 0;
  function startOperation(cm) {
    cm.curOp = {
      changes: [],
      updateInput: null,
      userSelChange: null,
      textChanged: null,
      selectionChanged: false,
      cursorActivity: false,
      updateMaxLine: false,
      updateScrollPos: false,
      id: ++nextOpId
    };
    if (!delayedCallbackDepth++)
      delayedCallbacks = [];
  }
  function endOperation(cm) {
    var op = cm.curOp, doc = cm.doc, display = cm.display;
    cm.curOp = null;
    if (op.updateMaxLine)
      computeMaxLength(cm);
    if (display.maxLineChanged && !cm.options.lineWrapping && display.maxLine) {
      var width = measureLineWidth(cm, display.maxLine);
      display.sizer.style.minWidth = Math.max(0, width + 3 + scrollerCutOff) + 'px';
      display.maxLineChanged = false;
      var maxScrollLeft = Math.max(0, display.sizer.offsetLeft + display.sizer.offsetWidth - display.scroller.clientWidth);
      if (maxScrollLeft < doc.scrollLeft && !op.updateScrollPos)
        setScrollLeft(cm, Math.min(display.scroller.scrollLeft, maxScrollLeft), true);
    }
    var newScrollPos, updated;
    if (op.updateScrollPos) {
      newScrollPos = op.updateScrollPos;
    } else if (op.selectionChanged && display.scroller.clientHeight) {
      var coords = cursorCoords(cm, doc.sel.head);
      newScrollPos = calculateScrollPos(cm, coords.left, coords.top, coords.left, coords.bottom);
    }
    if (op.changes.length || newScrollPos && newScrollPos.scrollTop != null) {
      updated = updateDisplay(cm, op.changes, newScrollPos && newScrollPos.scrollTop);
      if (cm.display.scroller.offsetHeight)
        cm.doc.scrollTop = cm.display.scroller.scrollTop;
    }
    if (!updated && op.selectionChanged)
      updateSelection(cm);
    if (op.updateScrollPos) {
      display.scroller.scrollTop = display.scrollbarV.scrollTop = doc.scrollTop = newScrollPos.scrollTop;
      display.scroller.scrollLeft = display.scrollbarH.scrollLeft = doc.scrollLeft = newScrollPos.scrollLeft;
      alignHorizontally(cm);
      if (op.scrollToPos)
        scrollPosIntoView(cm, clipPos(cm.doc, op.scrollToPos), op.scrollToPosMargin);
    } else if (newScrollPos) {
      scrollCursorIntoView(cm);
    }
    if (op.selectionChanged)
      restartBlink(cm);
    if (cm.state.focused && op.updateInput)
      resetInput(cm, op.userSelChange);
    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
    if (hidden)
      for (var i = 0; i < hidden.length; ++i)
        if (!hidden[i].lines.length)
          signal(hidden[i], 'hide');
    if (unhidden)
      for (var i = 0; i < unhidden.length; ++i)
        if (unhidden[i].lines.length)
          signal(unhidden[i], 'unhide');
    var delayed;
    if (!--delayedCallbackDepth) {
      delayed = delayedCallbacks;
      delayedCallbacks = null;
    }
    if (op.textChanged)
      signal(cm, 'change', cm, op.textChanged);
    if (op.cursorActivity)
      signal(cm, 'cursorActivity', cm);
    if (delayed)
      for (var i = 0; i < delayed.length; ++i)
        delayed[i]();
  }
  function operation(cm1, f) {
    return function () {
      var cm = cm1 || this, withOp = !cm.curOp;
      if (withOp)
        startOperation(cm);
      try {
        var result = f.apply(cm, arguments);
      } finally {
        if (withOp)
          endOperation(cm);
      }
      return result;
    };
  }
  function docOperation(f) {
    return function () {
      var withOp = this.cm && !this.cm.curOp, result;
      if (withOp)
        startOperation(this.cm);
      try {
        result = f.apply(this, arguments);
      } finally {
        if (withOp)
          endOperation(this.cm);
      }
      return result;
    };
  }
  function runInOp(cm, f) {
    var withOp = !cm.curOp, result;
    if (withOp)
      startOperation(cm);
    try {
      result = f();
    } finally {
      if (withOp)
        endOperation(cm);
    }
    return result;
  }
  function regChange(cm, from, to, lendiff) {
    if (from == null)
      from = cm.doc.first;
    if (to == null)
      to = cm.doc.first + cm.doc.size;
    cm.curOp.changes.push({
      from: from,
      to: to,
      diff: lendiff
    });
  }
  function slowPoll(cm) {
    if (cm.display.pollingFast)
      return;
    cm.display.poll.set(cm.options.pollInterval, function () {
      readInput(cm);
      if (cm.state.focused)
        slowPoll(cm);
    });
  }
  function fastPoll(cm) {
    var missed = false;
    cm.display.pollingFast = true;
    function p() {
      var changed = readInput(cm);
      if (!changed && !missed) {
        missed = true;
        cm.display.poll.set(60, p);
      } else {
        cm.display.pollingFast = false;
        slowPoll(cm);
      }
    }
    cm.display.poll.set(20, p);
  }
  function readInput(cm) {
    var input = cm.display.input, prevInput = cm.display.prevInput, doc = cm.doc, sel = doc.sel;
    if (!cm.state.focused || hasSelection(input) || isReadOnly(cm))
      return false;
    var text = input.value;
    if (text == prevInput && posEq(sel.from, sel.to))
      return false;
    if (ie && !ie_lt9 && cm.display.inputHasSelection === text) {
      resetInput(cm, true);
      return false;
    }
    var withOp = !cm.curOp;
    if (withOp)
      startOperation(cm);
    sel.shift = false;
    var same = 0, l = Math.min(prevInput.length, text.length);
    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same))
      ++same;
    var from = sel.from, to = sel.to;
    if (same < prevInput.length)
      from = Pos(from.line, from.ch - (prevInput.length - same));
    else if (cm.state.overwrite && posEq(from, to) && !cm.state.pasteIncoming)
      to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + (text.length - same)));
    var updateInput = cm.curOp.updateInput;
    makeChange(cm.doc, {
      from: from,
      to: to,
      text: splitLines(text.slice(same)),
      origin: cm.state.pasteIncoming ? 'paste' : '+input'
    }, 'end');
    cm.curOp.updateInput = updateInput;
    if (text.length > 1000 || text.indexOf('\n') > -1)
      input.value = cm.display.prevInput = '';
    else
      cm.display.prevInput = text;
    if (withOp)
      endOperation(cm);
    cm.state.pasteIncoming = false;
    return true;
  }
  function resetInput(cm, user) {
    var minimal, selected, doc = cm.doc;
    if (!posEq(doc.sel.from, doc.sel.to)) {
      cm.display.prevInput = '';
      minimal = hasCopyEvent && (doc.sel.to.line - doc.sel.from.line > 100 || (selected = cm.getSelection()).length > 1000);
      var content = minimal ? '-' : selected || cm.getSelection();
      cm.display.input.value = content;
      if (cm.state.focused)
        selectInput(cm.display.input);
      if (ie && !ie_lt9)
        cm.display.inputHasSelection = content;
    } else if (user) {
      cm.display.prevInput = cm.display.input.value = '';
      if (ie && !ie_lt9)
        cm.display.inputHasSelection = null;
    }
    cm.display.inaccurateSelection = minimal;
  }
  function focusInput(cm) {
    if (cm.options.readOnly != 'nocursor' && (!mobile || document.activeElement != cm.display.input))
      cm.display.input.focus();
  }
  function isReadOnly(cm) {
    return cm.options.readOnly || cm.doc.cantEdit;
  }
  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, 'mousedown', operation(cm, onMouseDown));
    if (ie)
      on(d.scroller, 'dblclick', operation(cm, function (e) {
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e))
          return;
        e_preventDefault(e);
        var word = findWordAt(getLine(cm.doc, pos.line).text, pos);
        extendSelection(cm.doc, word.from, word.to);
      }));
    else
      on(d.scroller, 'dblclick', e_preventDefault);
    on(d.lineSpace, 'selectstart', function (e) {
      if (!eventInWidget(d, e))
        e_preventDefault(e);
    });
    if (!captureMiddleClick)
      on(d.scroller, 'contextmenu', function (e) {
        onContextMenu(cm, e);
      });
    on(d.scroller, 'scroll', function () {
      if (d.scroller.clientHeight) {
        setScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, 'scroll', cm);
      }
    });
    on(d.scrollbarV, 'scroll', function () {
      if (d.scroller.clientHeight)
        setScrollTop(cm, d.scrollbarV.scrollTop);
    });
    on(d.scrollbarH, 'scroll', function () {
      if (d.scroller.clientHeight)
        setScrollLeft(cm, d.scrollbarH.scrollLeft);
    });
    on(d.scroller, 'mousewheel', function (e) {
      onScrollWheel(cm, e);
    });
    on(d.scroller, 'DOMMouseScroll', function (e) {
      onScrollWheel(cm, e);
    });
    function reFocus() {
      if (cm.state.focused)
        setTimeout(bind(focusInput, cm), 0);
    }
    on(d.scrollbarH, 'mousedown', reFocus);
    on(d.scrollbarV, 'mousedown', reFocus);
    on(d.wrapper, 'scroll', function () {
      d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
    });
    function onResize() {
      d.cachedCharWidth = d.cachedTextHeight = null;
      clearCaches(cm);
      runInOp(cm, bind(regChange, cm));
    }
    on(window, 'resize', onResize);
    function unregister() {
      for (var p = d.wrapper.parentNode; p && p != document.body; p = p.parentNode) {
      }
      if (p)
        setTimeout(unregister, 5000);
      else
        off(window, 'resize', onResize);
    }
    setTimeout(unregister, 5000);
    on(d.input, 'keyup', operation(cm, function (e) {
      if (cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e)))
        return;
      if (e.keyCode == 16)
        cm.doc.sel.shift = false;
    }));
    on(d.input, 'input', bind(fastPoll, cm));
    on(d.input, 'keydown', operation(cm, onKeyDown));
    on(d.input, 'keypress', operation(cm, onKeyPress));
    on(d.input, 'focus', bind(onFocus, cm));
    on(d.input, 'blur', bind(onBlur, cm));
    function drag_(e) {
      if (cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e)))
        return;
      e_stop(e);
    }
    if (cm.options.dragDrop) {
      on(d.scroller, 'dragstart', function (e) {
        onDragStart(cm, e);
      });
      on(d.scroller, 'dragenter', drag_);
      on(d.scroller, 'dragover', drag_);
      on(d.scroller, 'drop', operation(cm, onDrop));
    }
    on(d.scroller, 'paste', function (e) {
      if (eventInWidget(d, e))
        return;
      focusInput(cm);
      fastPoll(cm);
    });
    on(d.input, 'paste', function () {
      cm.state.pasteIncoming = true;
      fastPoll(cm);
    });
    function prepareCopy() {
      if (d.inaccurateSelection) {
        d.prevInput = '';
        d.inaccurateSelection = false;
        d.input.value = cm.getSelection();
        selectInput(d.input);
      }
    }
    on(d.input, 'cut', prepareCopy);
    on(d.input, 'copy', prepareCopy);
    if (khtml)
      on(d.sizer, 'mouseup', function () {
        if (document.activeElement == d.input)
          d.input.blur();
        focusInput(cm);
      });
  }
  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n)
        return true;
      if (/\bCodeMirror-(?:line)?widget\b/.test(n.className) || n.parentNode == display.sizer && n != display.mover)
        return true;
    }
  }
  function posFromMouse(cm, e, liberal) {
    var display = cm.display;
    if (!liberal) {
      var target = e_target(e);
      if (target == display.scrollbarH || target == display.scrollbarH.firstChild || target == display.scrollbarV || target == display.scrollbarV.firstChild || target == display.scrollbarFiller)
        return null;
    }
    var x, y, space = getRect(display.lineSpace);
    try {
      x = e.clientX;
      y = e.clientY;
    } catch (e) {
      return null;
    }
    return coordsChar(cm, x - space.left, y - space.top);
  }
  var lastClick, lastDoubleClick;
  function onMouseDown(e) {
    var cm = this, display = cm.display, doc = cm.doc, sel = doc.sel;
    sel.shift = e.shiftKey;
    if (eventInWidget(display, e)) {
      if (!webkit) {
        display.scroller.draggable = false;
        setTimeout(function () {
          display.scroller.draggable = true;
        }, 100);
      }
      return;
    }
    if (clickInGutter(cm, e))
      return;
    var start = posFromMouse(cm, e);
    switch (e_button(e)) {
    case 3:
      if (captureMiddleClick)
        onContextMenu.call(cm, cm, e);
      return;
    case 2:
      if (start)
        extendSelection(cm.doc, start);
      setTimeout(bind(focusInput, cm), 20);
      e_preventDefault(e);
      return;
    }
    if (!start) {
      if (e_target(e) == display.scroller)
        e_preventDefault(e);
      return;
    }
    if (!cm.state.focused)
      onFocus(cm);
    var now = +new Date(), type = 'single';
    if (lastDoubleClick && lastDoubleClick.time > now - 400 && posEq(lastDoubleClick.pos, start)) {
      type = 'triple';
      e_preventDefault(e);
      setTimeout(bind(focusInput, cm), 20);
      selectLine(cm, start.line);
    } else if (lastClick && lastClick.time > now - 400 && posEq(lastClick.pos, start)) {
      type = 'double';
      lastDoubleClick = {
        time: now,
        pos: start
      };
      e_preventDefault(e);
      var word = findWordAt(getLine(doc, start.line).text, start);
      extendSelection(cm.doc, word.from, word.to);
    } else {
      lastClick = {
        time: now,
        pos: start
      };
    }
    var last = start;
    if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) && !posEq(sel.from, sel.to) && !posLess(start, sel.from) && !posLess(sel.to, start) && type == 'single') {
      var dragEnd = operation(cm, function (e2) {
          if (webkit)
            display.scroller.draggable = false;
          cm.state.draggingText = false;
          off(document, 'mouseup', dragEnd);
          off(display.scroller, 'drop', dragEnd);
          if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
            e_preventDefault(e2);
            extendSelection(cm.doc, start);
            focusInput(cm);
          }
        });
      if (webkit)
        display.scroller.draggable = true;
      cm.state.draggingText = dragEnd;
      if (display.scroller.dragDrop)
        display.scroller.dragDrop();
      on(document, 'mouseup', dragEnd);
      on(display.scroller, 'drop', dragEnd);
      return;
    }
    e_preventDefault(e);
    if (type == 'single')
      extendSelection(cm.doc, clipPos(doc, start));
    var startstart = sel.from, startend = sel.to, lastPos = start;
    function doSelect(cur) {
      if (posEq(lastPos, cur))
        return;
      lastPos = cur;
      if (type == 'single') {
        extendSelection(cm.doc, clipPos(doc, start), cur);
        return;
      }
      startstart = clipPos(doc, startstart);
      startend = clipPos(doc, startend);
      if (type == 'double') {
        var word = findWordAt(getLine(doc, cur.line).text, cur);
        if (posLess(cur, startstart))
          extendSelection(cm.doc, word.from, startend);
        else
          extendSelection(cm.doc, startstart, word.to);
      } else if (type == 'triple') {
        if (posLess(cur, startstart))
          extendSelection(cm.doc, startend, clipPos(doc, Pos(cur.line, 0)));
        else
          extendSelection(cm.doc, startstart, clipPos(doc, Pos(cur.line + 1, 0)));
      }
    }
    var editorSize = getRect(display.wrapper);
    var counter = 0;
    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true);
      if (!cur)
        return;
      if (!posEq(cur, last)) {
        if (!cm.state.focused)
          onFocus(cm);
        last = cur;
        doSelect(cur);
        var visible = visibleLines(display, doc);
        if (cur.line >= visible.to || cur.line < visible.from)
          setTimeout(operation(cm, function () {
            if (counter == curCount)
              extend(e);
          }), 150);
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside)
          setTimeout(operation(cm, function () {
            if (counter != curCount)
              return;
            display.scroller.scrollTop += outside;
            extend(e);
          }), 50);
      }
    }
    function done(e) {
      counter = Infinity;
      var cur = posFromMouse(cm, e);
      if (cur)
        doSelect(cur);
      e_preventDefault(e);
      focusInput(cm);
      off(document, 'mousemove', move);
      off(document, 'mouseup', up);
    }
    var move = operation(cm, function (e) {
        if (!ie && !e_button(e))
          done(e);
        else
          extend(e);
      });
    var up = operation(cm, done);
    on(document, 'mousemove', move);
    on(document, 'mouseup', up);
  }
  function onDrop(e) {
    var cm = this;
    if (eventInWidget(cm.display, e) || cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e)))
      return;
    e_preventDefault(e);
    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
    if (!pos || isReadOnly(cm))
      return;
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length, text = Array(n), read = 0;
      var loadFile = function (file, i) {
        var reader = new FileReader();
        reader.onload = function () {
          text[i] = reader.result;
          if (++read == n) {
            pos = clipPos(cm.doc, pos);
            makeChange(cm.doc, {
              from: pos,
              to: pos,
              text: splitLines(text.join('\n')),
              origin: 'paste'
            }, 'around');
          }
        };
        reader.readAsText(file);
      };
      for (var i = 0; i < n; ++i)
        loadFile(files[i], i);
    } else {
      if (cm.state.draggingText && !(posLess(pos, cm.doc.sel.from) || posLess(cm.doc.sel.to, pos))) {
        cm.state.draggingText(e);
        setTimeout(bind(focusInput, cm), 20);
        return;
      }
      try {
        var text = e.dataTransfer.getData('Text');
        if (text) {
          var curFrom = cm.doc.sel.from, curTo = cm.doc.sel.to;
          setSelection(cm.doc, pos, pos);
          if (cm.state.draggingText)
            replaceRange(cm.doc, '', curFrom, curTo, 'paste');
          cm.replaceSelection(text, null, 'paste');
          focusInput(cm);
          onFocus(cm);
        }
      } catch (e) {
      }
    }
  }
  function clickInGutter(cm, e) {
    var display = cm.display;
    try {
      var mX = e.clientX, mY = e.clientY;
    } catch (e) {
      return false;
    }
    if (mX >= Math.floor(getRect(display.gutters).right))
      return false;
    e_preventDefault(e);
    if (!hasHandler(cm, 'gutterClick'))
      return true;
    var lineBox = getRect(display.lineDiv);
    if (mY > lineBox.bottom)
      return true;
    mY -= lineBox.top - display.viewOffset;
    for (var i = 0; i < cm.options.gutters.length; ++i) {
      var g = display.gutters.childNodes[i];
      if (g && getRect(g).right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.options.gutters[i];
        signalLater(cm, 'gutterClick', cm, line, gutter, e);
        break;
      }
    }
    return true;
  }
  function onDragStart(cm, e) {
    if (ie && !cm.state.draggingText) {
      e_stop(e);
      return;
    }
    if (eventInWidget(cm.display, e))
      return;
    var txt = cm.getSelection();
    e.dataTransfer.setData('Text', txt);
    if (e.dataTransfer.setDragImage) {
      var img = elt('img', null, null, 'position: fixed; left: 0; top: 0;');
      if (opera) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        img._top = img.offsetTop;
      }
      if (safari) {
        if (cm.display.dragImg) {
          img = cm.display.dragImg;
        } else {
          cm.display.dragImg = img;
          img.src = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';
          cm.display.wrapper.appendChild(img);
        }
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (opera)
        img.parentNode.removeChild(img);
    }
  }
  function setScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2)
      return;
    cm.doc.scrollTop = val;
    if (!gecko)
      updateDisplay(cm, [], val);
    if (cm.display.scroller.scrollTop != val)
      cm.display.scroller.scrollTop = val;
    if (cm.display.scrollbarV.scrollTop != val)
      cm.display.scrollbarV.scrollTop = val;
    if (gecko)
      updateDisplay(cm, []);
  }
  function setScrollLeft(cm, val, isScroller) {
    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2)
      return;
    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val)
      cm.display.scroller.scrollLeft = val;
    if (cm.display.scrollbarH.scrollLeft != val)
      cm.display.scrollbarH.scrollLeft = val;
  }
  var wheelSamples = 0, wheelPixelsPerUnit = null;
  if (ie)
    wheelPixelsPerUnit = -0.53;
  else if (gecko)
    wheelPixelsPerUnit = 15;
  else if (chrome)
    wheelPixelsPerUnit = -0.7;
  else if (safari)
    wheelPixelsPerUnit = -1 / 3;
  function onScrollWheel(cm, e) {
    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS)
      dx = e.detail;
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS)
      dy = e.detail;
    else if (dy == null)
      dy = e.wheelDelta;
    var display = cm.display, scroll = display.scroller;
    if (!(dx && scroll.scrollWidth > scroll.clientWidth || dy && scroll.scrollHeight > scroll.clientHeight))
      return;
    if (dy && mac && webkit) {
      for (var cur = e.target; cur != scroll; cur = cur.parentNode) {
        if (cur.lineObj) {
          cm.display.currentWheelTarget = cur;
          break;
        }
      }
    }
    if (dx && !gecko && !opera && wheelPixelsPerUnit != null) {
      if (dy)
        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
      e_preventDefault(e);
      display.wheelStartX = null;
      return;
    }
    if (dy && wheelPixelsPerUnit != null) {
      var pixels = dy * wheelPixelsPerUnit;
      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
      if (pixels < 0)
        top = Math.max(0, top + pixels - 50);
      else
        bot = Math.min(cm.doc.height, bot + pixels + 50);
      updateDisplay(cm, [], {
        top: top,
        bottom: bot
      });
    }
    if (wheelSamples < 20) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft;
        display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx;
        display.wheelDY = dy;
        setTimeout(function () {
          if (display.wheelStartX == null)
            return;
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
          display.wheelStartX = display.wheelStartY = null;
          if (!sample)
            return;
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx;
        display.wheelDY += dy;
      }
    }
  }
  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == 'string') {
      bound = commands[bound];
      if (!bound)
        return false;
    }
    if (cm.display.pollingFast && readInput(cm))
      cm.display.pollingFast = false;
    var doc = cm.doc, prevShift = doc.sel.shift, done = false;
    try {
      if (isReadOnly(cm))
        cm.state.suppressEdits = true;
      if (dropShift)
        doc.sel.shift = false;
      done = bound(cm) != Pass;
    } finally {
      doc.sel.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done;
  }
  function allKeyMaps(cm) {
    var maps = cm.state.keyMaps.slice(0);
    if (cm.options.extraKeys)
      maps.push(cm.options.extraKeys);
    maps.push(cm.options.keyMap);
    return maps;
  }
  var maybeTransition;
  function handleKeyBinding(cm, e) {
    var startMap = getKeyMap(cm.options.keyMap), next = startMap.auto;
    clearTimeout(maybeTransition);
    if (next && !isModifierKey(e))
      maybeTransition = setTimeout(function () {
        if (getKeyMap(cm.options.keyMap) == startMap)
          cm.options.keyMap = next.call ? next.call(null, cm) : next;
      }, 50);
    var name = keyName(e, true), handled = false;
    if (!name)
      return false;
    var keymaps = allKeyMaps(cm);
    if (e.shiftKey) {
      handled = lookupKey('Shift-' + name, keymaps, function (b) {
        return doHandleBinding(cm, b, true);
      }) || lookupKey(name, keymaps, function (b) {
        if (typeof b == 'string' && /^go[A-Z]/.test(b))
          return doHandleBinding(cm, b);
      });
    } else {
      handled = lookupKey(name, keymaps, function (b) {
        return doHandleBinding(cm, b);
      });
    }
    if (handled == 'stop')
      handled = false;
    if (handled) {
      e_preventDefault(e);
      restartBlink(cm);
      if (ie_lt9) {
        e.oldKeyCode = e.keyCode;
        e.keyCode = 0;
      }
    }
    return handled;
  }
  function handleCharBinding(cm, e, ch) {
    var handled = lookupKey('\'' + ch + '\'', allKeyMaps(cm), function (b) {
        return doHandleBinding(cm, b, true);
      });
    if (handled) {
      e_preventDefault(e);
      restartBlink(cm);
    }
    return handled;
  }
  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    if (!cm.state.focused)
      onFocus(cm);
    if (ie && e.keyCode == 27) {
      e.returnValue = false;
    }
    if (cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e)))
      return;
    var code = e.keyCode;
    cm.doc.sel.shift = code == 16 || e.shiftKey;
    var handled = handleKeyBinding(cm, e);
    if (opera) {
      lastStoppedKey = handled ? code : null;
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
        cm.replaceSelection('');
    }
  }
  function onKeyPress(e) {
    var cm = this;
    if (cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e)))
      return;
    var keyCode = e.keyCode, charCode = e.charCode;
    if (opera && keyCode == lastStoppedKey) {
      lastStoppedKey = null;
      e_preventDefault(e);
      return;
    }
    if ((opera && (!e.which || e.which < 10) || khtml) && handleKeyBinding(cm, e))
      return;
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    if (this.options.electricChars && this.doc.mode.electricChars && this.options.smartIndent && !isReadOnly(this) && this.doc.mode.electricChars.indexOf(ch) > -1)
      setTimeout(operation(cm, function () {
        indentLine(cm, cm.doc.sel.to.line, 'smart');
      }), 75);
    if (handleCharBinding(cm, e, ch))
      return;
    if (ie && !ie_lt9)
      cm.display.inputHasSelection = null;
    fastPoll(cm);
  }
  function onFocus(cm) {
    if (cm.options.readOnly == 'nocursor')
      return;
    if (!cm.state.focused) {
      signal(cm, 'focus', cm);
      cm.state.focused = true;
      if (cm.display.wrapper.className.search(/\bCodeMirror-focused\b/) == -1)
        cm.display.wrapper.className += ' CodeMirror-focused';
      resetInput(cm, true);
    }
    slowPoll(cm);
    restartBlink(cm);
  }
  function onBlur(cm) {
    if (cm.state.focused) {
      signal(cm, 'blur', cm);
      cm.state.focused = false;
      cm.display.wrapper.className = cm.display.wrapper.className.replace(' CodeMirror-focused', '');
    }
    clearInterval(cm.display.blinker);
    setTimeout(function () {
      if (!cm.state.focused)
        cm.doc.sel.shift = false;
    }, 150);
  }
  var detectingSelectAll;
  function onContextMenu(cm, e) {
    var display = cm.display, sel = cm.doc.sel;
    if (eventInWidget(display, e))
      return;
    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
    if (!pos || opera)
      return;
    if (posEq(sel.from, sel.to) || posLess(pos, sel.from) || !posLess(pos, sel.to))
      operation(cm, setSelection)(cm.doc, pos, pos);
    var oldCSS = display.input.style.cssText;
    display.inputDiv.style.position = 'absolute';
    display.input.style.cssText = 'position: fixed; width: 30px; height: 30px; top: ' + (e.clientY - 5) + 'px; left: ' + (e.clientX - 5) + 'px; z-index: 1000; background: white; outline: none;' + 'border-width: 0; outline: none; overflow: hidden; opacity: .05; -ms-opacity: .05; filter: alpha(opacity=5);';
    focusInput(cm);
    resetInput(cm, true);
    if (posEq(sel.from, sel.to))
      display.input.value = display.prevInput = ' ';
    function rehide() {
      display.inputDiv.style.position = 'relative';
      display.input.style.cssText = oldCSS;
      if (ie_lt9)
        display.scrollbarV.scrollTop = display.scroller.scrollTop = scrollPos;
      slowPoll(cm);
      if (display.input.selectionStart != null && (!ie || ie_lt9)) {
        clearTimeout(detectingSelectAll);
        var extval = display.input.value = ' ' + (posEq(sel.from, sel.to) ? '' : display.input.value), i = 0;
        display.prevInput = ' ';
        display.input.selectionStart = 1;
        display.input.selectionEnd = extval.length;
        var poll = function () {
          if (display.prevInput == ' ' && display.input.selectionStart == 0)
            operation(cm, commands.selectAll)(cm);
          else if (i++ < 10)
            detectingSelectAll = setTimeout(poll, 500);
          else
            resetInput(cm);
        };
        detectingSelectAll = setTimeout(poll, 200);
      }
    }
    if (captureMiddleClick) {
      e_stop(e);
      var mouseup = function () {
        off(window, 'mouseup', mouseup);
        setTimeout(rehide, 20);
      };
      on(window, 'mouseup', mouseup);
    } else {
      setTimeout(rehide, 50);
    }
  }
  function changeEnd(change) {
    if (!change.text)
      return change.to;
    return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
  }
  function clipPostChange(doc, change, pos) {
    if (!posLess(change.from, pos))
      return clipPos(doc, pos);
    var diff = change.text.length - 1 - (change.to.line - change.from.line);
    if (pos.line > change.to.line + diff) {
      var preLine = pos.line - diff, lastLine = doc.first + doc.size - 1;
      if (preLine > lastLine)
        return Pos(lastLine, getLine(doc, lastLine).text.length);
      return clipToLen(pos, getLine(doc, preLine).text.length);
    }
    if (pos.line == change.to.line + diff)
      return clipToLen(pos, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0) + getLine(doc, change.to.line).text.length - change.to.ch);
    var inside = pos.line - change.from.line;
    return clipToLen(pos, change.text[inside].length + (inside ? 0 : change.from.ch));
  }
  function computeSelAfterChange(doc, change, hint) {
    if (hint && typeof hint == 'object')
      return {
        anchor: clipPostChange(doc, change, hint.anchor),
        head: clipPostChange(doc, change, hint.head)
      };
    if (hint == 'start')
      return {
        anchor: change.from,
        head: change.from
      };
    var end = changeEnd(change);
    if (hint == 'around')
      return {
        anchor: change.from,
        head: end
      };
    if (hint == 'end')
      return {
        anchor: end,
        head: end
      };
    var adjustPos = function (pos) {
      if (posLess(pos, change.from))
        return pos;
      if (!posLess(change.to, pos))
        return end;
      var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
      if (pos.line == change.to.line)
        ch += end.ch - change.to.ch;
      return Pos(line, ch);
    };
    return {
      anchor: adjustPos(doc.sel.anchor),
      head: adjustPos(doc.sel.head)
    };
  }
  function filterChange(doc, change) {
    var obj = {
        canceled: false,
        from: change.from,
        to: change.to,
        text: change.text,
        origin: change.origin,
        update: function (from, to, text, origin) {
          if (from)
            this.from = clipPos(doc, from);
          if (to)
            this.to = clipPos(doc, to);
          if (text)
            this.text = text;
          if (origin !== undefined)
            this.origin = origin;
        },
        cancel: function () {
          this.canceled = true;
        }
      };
    signal(doc, 'beforeChange', doc, obj);
    if (doc.cm)
      signal(doc.cm, 'beforeChange', doc.cm, obj);
    if (obj.canceled)
      return null;
    return {
      from: obj.from,
      to: obj.to,
      text: obj.text,
      origin: obj.origin
    };
  }
  function makeChange(doc, change, selUpdate, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp)
        return operation(doc.cm, makeChange)(doc, change, selUpdate, ignoreReadOnly);
      if (doc.cm.state.suppressEdits)
        return;
    }
    if (hasHandler(doc, 'beforeChange') || doc.cm && hasHandler(doc.cm, 'beforeChange')) {
      change = filterChange(doc, change);
      if (!change)
        return;
    }
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 1; --i)
        makeChangeNoReadonly(doc, {
          from: split[i].from,
          to: split[i].to,
          text: ['']
        });
      if (split.length)
        makeChangeNoReadonly(doc, {
          from: split[0].from,
          to: split[0].to,
          text: change.text
        }, selUpdate);
    } else {
      makeChangeNoReadonly(doc, change, selUpdate);
    }
  }
  function makeChangeNoReadonly(doc, change, selUpdate) {
    var selAfter = computeSelAfterChange(doc, change, selUpdate);
    addToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);
    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];
    linkedDocs(doc, function (doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }
  function makeChangeFromHistory(doc, type) {
    if (doc.cm && doc.cm.state.suppressEdits)
      return;
    var hist = doc.history;
    var event = (type == 'undo' ? hist.done : hist.undone).pop();
    if (!event)
      return;
    hist.dirtyCounter += type == 'undo' ? -1 : 1;
    var anti = {
        changes: [],
        anchorBefore: event.anchorAfter,
        headBefore: event.headAfter,
        anchorAfter: event.anchorBefore,
        headAfter: event.headBefore
      };
    (type == 'undo' ? hist.undone : hist.done).push(anti);
    for (var i = event.changes.length - 1; i >= 0; --i) {
      var change = event.changes[i];
      change.origin = type;
      anti.changes.push(historyChangeFromChange(doc, change));
      var after = i ? computeSelAfterChange(doc, change, null) : {
          anchor: event.anchorBefore,
          head: event.headBefore
        };
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      var rebased = [];
      linkedDocs(doc, function (doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    }
  }
  function shiftDoc(doc, distance) {
    function shiftPos(pos) {
      return Pos(pos.line + distance, pos.ch);
    }
    doc.first += distance;
    if (doc.cm)
      regChange(doc.cm, doc.first, doc.first, distance);
    doc.sel.head = shiftPos(doc.sel.head);
    doc.sel.anchor = shiftPos(doc.sel.anchor);
    doc.sel.from = shiftPos(doc.sel.from);
    doc.sel.to = shiftPos(doc.sel.to);
  }
  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp)
      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return;
    }
    if (change.from.line > doc.lastLine())
      return;
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {
        from: Pos(doc.first, 0),
        to: Pos(change.to.line + shift, change.to.ch),
        text: [lst(change.text)],
        origin: change.origin
      };
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = {
        from: change.from,
        to: Pos(last, getLine(doc, last).text.length),
        text: [change.text[0]],
        origin: change.origin
      };
    }
    change.removed = getBetween(doc, change.from, change.to);
    if (!selAfter)
      selAfter = computeSelAfterChange(doc, change, null);
    if (doc.cm)
      makeChangeSingleDocInEditor(doc.cm, change, spans, selAfter);
    else
      updateDoc(doc, change, spans, selAfter);
  }
  function makeChangeSingleDocInEditor(cm, change, spans, selAfter) {
    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;
    var recomputeMaxLength = false, checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(doc, getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function (line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true;
        }
      });
    }
    if (!posLess(doc.sel.head, change.from) && !posLess(change.to, doc.sel.head))
      cm.curOp.cursorActivity = true;
    updateDoc(doc, change, spans, selAfter, estimateHeight(cm));
    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
        var len = lineLength(doc, line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength)
        cm.curOp.updateMaxLine = true;
    }
    doc.frontier = Math.min(doc.frontier, from.line);
    startWorker(cm, 400);
    var lendiff = change.text.length - (to.line - from.line) - 1;
    regChange(cm, from.line, to.line + 1, lendiff);
    if (hasHandler(cm, 'change')) {
      var changeObj = {
          from: from,
          to: to,
          text: change.text,
          removed: change.removed,
          origin: change.origin
        };
      if (cm.curOp.textChanged) {
        for (var cur = cm.curOp.textChanged; cur.next; cur = cur.next) {
        }
        cur.next = changeObj;
      } else
        cm.curOp.textChanged = changeObj;
    }
  }
  function replaceRange(doc, code, from, to, origin) {
    if (!to)
      to = from;
    if (posLess(to, from)) {
      var tmp = to;
      to = from;
      from = tmp;
    }
    if (typeof code == 'string')
      code = splitLines(code);
    makeChange(doc, {
      from: from,
      to: to,
      text: code,
      origin: origin
    }, null);
  }
  function Pos(line, ch) {
    if (!(this instanceof Pos))
      return new Pos(line, ch);
    this.line = line;
    this.ch = ch;
  }
  CodeMirror.Pos = Pos;
  function posEq(a, b) {
    return a.line == b.line && a.ch == b.ch;
  }
  function posLess(a, b) {
    return a.line < b.line || a.line == b.line && a.ch < b.ch;
  }
  function copyPos(x) {
    return Pos(x.line, x.ch);
  }
  function clipLine(doc, n) {
    return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));
  }
  function clipPos(doc, pos) {
    if (pos.line < doc.first)
      return Pos(doc.first, 0);
    var last = doc.first + doc.size - 1;
    if (pos.line > last)
      return Pos(last, getLine(doc, last).text.length);
    return clipToLen(pos, getLine(doc, pos.line).text.length);
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen)
      return Pos(pos.line, linelen);
    else if (ch < 0)
      return Pos(pos.line, 0);
    else
      return pos;
  }
  function isLine(doc, l) {
    return l >= doc.first && l < doc.first + doc.size;
  }
  function extendSelection(doc, pos, other, bias) {
    if (doc.sel.shift || doc.sel.extend) {
      var anchor = doc.sel.anchor;
      if (other) {
        var posBefore = posLess(pos, anchor);
        if (posBefore != posLess(other, anchor)) {
          anchor = pos;
          pos = other;
        } else if (posBefore != posLess(pos, other)) {
          pos = other;
        }
      }
      setSelection(doc, anchor, pos, bias);
    } else {
      setSelection(doc, pos, other || pos, bias);
    }
    if (doc.cm)
      doc.cm.curOp.userSelChange = true;
  }
  function filterSelectionChange(doc, anchor, head) {
    var obj = {
        anchor: anchor,
        head: head
      };
    signal(doc, 'beforeSelectionChange', doc, obj);
    if (doc.cm)
      signal(doc.cm, 'beforeSelectionChange', doc.cm, obj);
    obj.anchor = clipPos(doc, obj.anchor);
    obj.head = clipPos(doc, obj.head);
    return obj;
  }
  function setSelection(doc, anchor, head, bias, checkAtomic) {
    if (!checkAtomic && hasHandler(doc, 'beforeSelectionChange') || doc.cm && hasHandler(doc.cm, 'beforeSelectionChange')) {
      var filtered = filterSelectionChange(doc, anchor, head);
      head = filtered.head;
      anchor = filtered.anchor;
    }
    var sel = doc.sel;
    sel.goalColumn = null;
    if (checkAtomic || !posEq(anchor, sel.anchor))
      anchor = skipAtomic(doc, anchor, bias, checkAtomic != 'push');
    if (checkAtomic || !posEq(head, sel.head))
      head = skipAtomic(doc, head, bias, checkAtomic != 'push');
    if (posEq(sel.anchor, anchor) && posEq(sel.head, head))
      return;
    sel.anchor = anchor;
    sel.head = head;
    var inv = posLess(head, anchor);
    sel.from = inv ? head : anchor;
    sel.to = inv ? anchor : head;
    if (doc.cm)
      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = doc.cm.curOp.cursorActivity = true;
    signalLater(doc, 'cursorActivity', doc);
  }
  function reCheckSelection(cm) {
    setSelection(cm.doc, cm.doc.sel.from, cm.doc.sel.to, null, 'push');
  }
  function skipAtomic(doc, pos, bias, mayClear) {
    var flipped = false, curPos = pos;
    var dir = bias || 1;
    doc.cantEdit = false;
    search:
      for (;;) {
        var line = getLine(doc, curPos.line);
        if (line.markedSpans) {
          for (var i = 0; i < line.markedSpans.length; ++i) {
            var sp = line.markedSpans[i], m = sp.marker;
            if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) && (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {
              if (mayClear) {
                signal(m, 'beforeCursorEnter');
                if (m.explicitlyCleared) {
                  if (!line.markedSpans)
                    break;
                  else {
                    --i;
                    continue;
                  }
                }
              }
              if (!m.atomic)
                continue;
              var newPos = m.find()[dir < 0 ? 'from' : 'to'];
              if (posEq(newPos, curPos)) {
                newPos.ch += dir;
                if (newPos.ch < 0) {
                  if (newPos.line > doc.first)
                    newPos = clipPos(doc, Pos(newPos.line - 1));
                  else
                    newPos = null;
                } else if (newPos.ch > line.text.length) {
                  if (newPos.line < doc.first + doc.size - 1)
                    newPos = Pos(newPos.line + 1, 0);
                  else
                    newPos = null;
                }
                if (!newPos) {
                  if (flipped) {
                    if (!mayClear)
                      return skipAtomic(doc, pos, bias, true);
                    doc.cantEdit = true;
                    return Pos(doc.first, 0);
                  }
                  flipped = true;
                  newPos = pos;
                  dir = -dir;
                }
              }
              curPos = newPos;
              continue search;
            }
          }
        }
        return curPos;
      }
  }
  function scrollCursorIntoView(cm) {
    var coords = scrollPosIntoView(cm, cm.doc.sel.head);
    if (!cm.state.focused)
      return;
    var display = cm.display, box = getRect(display.sizer), doScroll = null, pTop = paddingTop(cm.display);
    if (coords.top + pTop + box.top < 0)
      doScroll = true;
    else if (coords.bottom + pTop + box.top > (window.innerHeight || document.documentElement.clientHeight))
      doScroll = false;
    if (doScroll != null && !phantom) {
      var hidden = display.cursor.style.display == 'none';
      if (hidden) {
        display.cursor.style.display = '';
        display.cursor.style.left = coords.left + 'px';
        display.cursor.style.top = coords.top - display.viewOffset + 'px';
      }
      display.cursor.scrollIntoView(doScroll);
      if (hidden)
        display.cursor.style.display = 'none';
    }
  }
  function scrollPosIntoView(cm, pos, margin) {
    if (margin == null)
      margin = 0;
    for (;;) {
      var changed = false, coords = cursorCoords(cm, pos);
      var scrollPos = calculateScrollPos(cm, coords.left, coords.top - margin, coords.left, coords.bottom + margin);
      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        setScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1)
          changed = true;
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1)
          changed = true;
      }
      if (!changed)
        return coords;
    }
  }
  function scrollIntoView(cm, x1, y1, x2, y2) {
    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
    if (scrollPos.scrollTop != null)
      setScrollTop(cm, scrollPos.scrollTop);
    if (scrollPos.scrollLeft != null)
      setScrollLeft(cm, scrollPos.scrollLeft);
  }
  function calculateScrollPos(cm, x1, y1, x2, y2) {
    var display = cm.display, pt = paddingTop(display);
    y1 += pt;
    y2 += pt;
    if (y1 < 0)
      y1 = 0;
    var screen = display.scroller.clientHeight - scrollerCutOff, screentop = display.scroller.scrollTop, result = {};
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = y1 < pt + 10, atBottom = y2 + pt > docBottom - 10;
    if (y1 < screentop) {
      result.scrollTop = atTop ? 0 : y1;
    } else if (y2 > screentop + screen) {
      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
      if (newTop != screentop)
        result.scrollTop = newTop;
    }
    var screenw = display.scroller.clientWidth - scrollerCutOff, screenleft = display.scroller.scrollLeft;
    x1 += display.gutters.offsetWidth;
    x2 += display.gutters.offsetWidth;
    var gutterw = display.gutters.offsetWidth;
    var atLeft = x1 < gutterw + 10;
    if (x1 < screenleft + gutterw || atLeft) {
      if (atLeft)
        x1 = 0;
      result.scrollLeft = Math.max(0, x1 - 10 - gutterw);
    } else if (x2 > screenw + screenleft - 3) {
      result.scrollLeft = x2 + 10 - screenw;
    }
    return result;
  }
  function updateScrollPos(cm, left, top) {
    cm.curOp.updateScrollPos = {
      scrollLeft: left == null ? cm.doc.scrollLeft : left,
      scrollTop: top == null ? cm.doc.scrollTop : top
    };
  }
  function addToScrollPos(cm, left, top) {
    var pos = cm.curOp.updateScrollPos || (cm.curOp.updateScrollPos = {
        scrollLeft: cm.doc.scrollLeft,
        scrollTop: cm.doc.scrollTop
      });
    var scroll = cm.display.scroller;
    pos.scrollTop = Math.max(0, Math.min(scroll.scrollHeight - scroll.clientHeight, pos.scrollTop + top));
    pos.scrollLeft = Math.max(0, Math.min(scroll.scrollWidth - scroll.clientWidth, pos.scrollLeft + left));
  }
  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc;
    if (!how)
      how = 'add';
    if (how == 'smart') {
      if (!cm.doc.mode.indent)
        how = 'prev';
      else
        var state = getStateBefore(cm, n);
    }
    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
    if (how == 'smart') {
      indentation = cm.doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass) {
        if (!aggressive)
          return;
        how = 'prev';
      }
    }
    if (how == 'prev') {
      if (n > doc.first)
        indentation = countColumn(getLine(doc, n - 1).text, null, tabSize);
      else
        indentation = 0;
    } else if (how == 'add') {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == 'subtract') {
      indentation = curSpace - cm.options.indentUnit;
    }
    indentation = Math.max(0, indentation);
    var indentString = '', pos = 0;
    if (cm.options.indentWithTabs)
      for (var i = Math.floor(indentation / tabSize); i; --i) {
        pos += tabSize;
        indentString += '\t';
      }
    if (pos < indentation)
      indentString += spaceStr(indentation - pos);
    if (indentString != curSpaceString)
      replaceRange(cm.doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), '+input');
    line.stateAfter = null;
  }
  function changeLine(cm, handle, op) {
    var no = handle, line = handle, doc = cm.doc;
    if (typeof handle == 'number')
      line = getLine(doc, clipLine(doc, handle));
    else
      no = lineNo(handle);
    if (no == null)
      return null;
    if (op(line, no))
      regChange(cm, no, no + 1);
    else
      return null;
    return line;
  }
  function findPosH(doc, pos, dir, unit, visually) {
    var line = pos.line, ch = pos.ch;
    var lineObj = getLine(doc, line);
    var possible = true;
    function findNextLine() {
      var l = line + dir;
      if (l < doc.first || l >= doc.first + doc.size)
        return possible = false;
      line = l;
      return lineObj = getLine(doc, l);
    }
    function moveOnce(boundToLine) {
      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);
      if (next == null) {
        if (!boundToLine && findNextLine()) {
          if (visually)
            ch = (dir < 0 ? lineRight : lineLeft)(lineObj);
          else
            ch = dir < 0 ? lineObj.text.length : 0;
        } else
          return possible = false;
      } else
        ch = next;
      return true;
    }
    if (unit == 'char')
      moveOnce();
    else if (unit == 'column')
      moveOnce(true);
    else if (unit == 'word' || unit == 'group') {
      var sawType = null, group = unit == 'group';
      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first))
          break;
        var cur = lineObj.text.charAt(ch) || '\n';
        var type = isWordChar(cur) ? 'w' : !group ? null : /\s/.test(cur) ? null : 'p';
        if (sawType && sawType != type) {
          if (dir < 0) {
            dir = 1;
            moveOnce();
          }
          break;
        }
        if (type)
          sawType = type;
        if (dir > 0 && !moveOnce(!first))
          break;
      }
    }
    var result = skipAtomic(doc, Pos(line, ch), dir, true);
    if (!possible)
      result.hitSide = true;
    return result;
  }
  function findPosV(cm, pos, dir, unit) {
    var doc = cm.doc, x = pos.left, y;
    if (unit == 'page') {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : 0.5) * textHeight(cm.display));
    } else if (unit == 'line') {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    for (;;) {
      var target = coordsChar(cm, x, y);
      if (!target.outside)
        break;
      if (dir < 0 ? y <= 0 : y >= doc.height) {
        target.hitSide = true;
        break;
      }
      y += dir * 5;
    }
    return target;
  }
  function findWordAt(line, pos) {
    var start = pos.ch, end = pos.ch;
    if (line) {
      if (pos.after === false || end == line.length)
        --start;
      else
        ++end;
      var startChar = line.charAt(start);
      var check = isWordChar(startChar) ? isWordChar : /\s/.test(startChar) ? function (ch) {
          return /\s/.test(ch);
        } : function (ch) {
          return !/\s/.test(ch) && !isWordChar(ch);
        };
      while (start > 0 && check(line.charAt(start - 1)))
        --start;
      while (end < line.length && check(line.charAt(end)))
        ++end;
    }
    return {
      from: Pos(pos.line, start),
      to: Pos(pos.line, end)
    };
  }
  function selectLine(cm, line) {
    extendSelection(cm.doc, Pos(line, 0), clipPos(cm.doc, Pos(line + 1, 0)));
  }
  CodeMirror.prototype = {
    focus: function () {
      window.focus();
      focusInput(this);
      onFocus(this);
      fastPoll(this);
    },
    setOption: function (option, value) {
      var options = this.options, old = options[option];
      if (options[option] == value && option != 'mode')
        return;
      options[option] = value;
      if (optionHandlers.hasOwnProperty(option))
        operation(this, optionHandlers[option])(this, value, old);
    },
    getOption: function (option) {
      return this.options[option];
    },
    getDoc: function () {
      return this.doc;
    },
    addKeyMap: function (map, bottom) {
      this.state.keyMaps[bottom ? 'push' : 'unshift'](map);
    },
    removeKeyMap: function (map) {
      var maps = this.state.keyMaps;
      for (var i = 0; i < maps.length; ++i)
        if ((typeof map == 'string' ? maps[i].name : maps[i]) == map) {
          maps.splice(i, 1);
          return true;
        }
    },
    addOverlay: operation(null, function (spec, options) {
      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
      if (mode.startState)
        throw new Error('Overlays may not be stateful.');
      this.state.overlays.push({
        mode: mode,
        modeSpec: spec,
        opaque: options && options.opaque
      });
      this.state.modeGen++;
      regChange(this);
    }),
    removeOverlay: operation(null, function (spec) {
      var overlays = this.state.overlays;
      for (var i = 0; i < overlays.length; ++i) {
        if (overlays[i].modeSpec == spec) {
          overlays.splice(i, 1);
          this.state.modeGen++;
          regChange(this);
          return;
        }
      }
    }),
    indentLine: operation(null, function (n, dir, aggressive) {
      if (typeof dir != 'string') {
        if (dir == null)
          dir = this.options.smartIndent ? 'smart' : 'prev';
        else
          dir = dir ? 'add' : 'subtract';
      }
      if (isLine(this.doc, n))
        indentLine(this, n, dir, aggressive);
    }),
    indentSelection: operation(null, function (how) {
      var sel = this.doc.sel;
      if (posEq(sel.from, sel.to))
        return indentLine(this, sel.from.line, how);
      var e = sel.to.line - (sel.to.ch ? 0 : 1);
      for (var i = sel.from.line; i <= e; ++i)
        indentLine(this, i, how);
    }),
    getTokenAt: function (pos) {
      var doc = this.doc;
      pos = clipPos(doc, pos);
      var state = getStateBefore(this, pos.line), mode = this.doc.mode;
      var line = getLine(doc, pos.line);
      var stream = new StringStream(line.text, this.options.tabSize);
      while (stream.pos < pos.ch && !stream.eol()) {
        stream.start = stream.pos;
        var style = mode.token(stream, state);
      }
      return {
        start: stream.start,
        end: stream.pos,
        string: stream.current(),
        className: style || null,
        type: style || null,
        state: state
      };
    },
    getStateAfter: function (line) {
      var doc = this.doc;
      line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);
      return getStateBefore(this, line + 1);
    },
    cursorCoords: function (start, mode) {
      var pos, sel = this.doc.sel;
      if (start == null)
        pos = sel.head;
      else if (typeof start == 'object')
        pos = clipPos(this.doc, start);
      else
        pos = start ? sel.from : sel.to;
      return cursorCoords(this, pos, mode || 'page');
    },
    charCoords: function (pos, mode) {
      return charCoords(this, clipPos(this.doc, pos), mode || 'page');
    },
    coordsChar: function (coords, mode) {
      coords = fromCoordSystem(this, coords, mode || 'page');
      return coordsChar(this, coords.left, coords.top);
    },
    defaultTextHeight: function () {
      return textHeight(this.display);
    },
    defaultCharWidth: function () {
      return charWidth(this.display);
    },
    setGutterMarker: operation(null, function (line, gutterID, value) {
      return changeLine(this, line, function (line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers))
          line.gutterMarkers = null;
        return true;
      });
    }),
    clearGutter: operation(null, function (gutterID) {
      var cm = this, doc = cm.doc, i = doc.first;
      doc.iter(function (line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          line.gutterMarkers[gutterID] = null;
          regChange(cm, i, i + 1);
          if (isEmpty(line.gutterMarkers))
            line.gutterMarkers = null;
        }
        ++i;
      });
    }),
    addLineClass: operation(null, function (handle, where, cls) {
      return changeLine(this, handle, function (line) {
        var prop = where == 'text' ? 'textClass' : where == 'background' ? 'bgClass' : 'wrapClass';
        if (!line[prop])
          line[prop] = cls;
        else if (new RegExp('\\b' + cls + '\\b').test(line[prop]))
          return false;
        else
          line[prop] += ' ' + cls;
        return true;
      });
    }),
    removeLineClass: operation(null, function (handle, where, cls) {
      return changeLine(this, handle, function (line) {
        var prop = where == 'text' ? 'textClass' : where == 'background' ? 'bgClass' : 'wrapClass';
        var cur = line[prop];
        if (!cur)
          return false;
        else if (cls == null)
          line[prop] = null;
        else {
          var upd = cur.replace(new RegExp('^' + cls + '\\b\\s*|\\s*\\b' + cls + '\\b'), '');
          if (upd == cur)
            return false;
          line[prop] = upd || null;
        }
        return true;
      });
    }),
    addLineWidget: operation(null, function (handle, node, options) {
      return addLineWidget(this, handle, node, options);
    }),
    removeLineWidget: function (widget) {
      widget.clear();
    },
    lineInfo: function (line) {
      if (typeof line == 'number') {
        if (!isLine(this.doc, line))
          return null;
        var n = line;
        line = getLine(this.doc, line);
        if (!line)
          return null;
      } else {
        var n = lineNo(line);
        if (n == null)
          return null;
      }
      return {
        line: n,
        handle: line,
        text: line.text,
        gutterMarkers: line.gutterMarkers,
        textClass: line.textClass,
        bgClass: line.bgClass,
        wrapClass: line.wrapClass,
        widgets: line.widgets
      };
    },
    getViewport: function () {
      return {
        from: this.display.showingFrom,
        to: this.display.showingTo
      };
    },
    addWidget: function (pos, node, scroll, vert, horiz) {
      var display = this.display;
      pos = cursorCoords(this, clipPos(this.doc, pos));
      var top = pos.bottom, left = pos.left;
      node.style.position = 'absolute';
      display.sizer.appendChild(node);
      if (vert == 'over') {
        top = pos.top;
      } else if (vert == 'above' || vert == 'near') {
        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
          top = pos.top - node.offsetHeight;
        else if (pos.bottom + node.offsetHeight <= vspace)
          top = pos.bottom;
        if (left + node.offsetWidth > hspace)
          left = hspace - node.offsetWidth;
      }
      node.style.top = top + paddingTop(display) + 'px';
      node.style.left = node.style.right = '';
      if (horiz == 'right') {
        left = display.sizer.clientWidth - node.offsetWidth;
        node.style.right = '0px';
      } else {
        if (horiz == 'left')
          left = 0;
        else if (horiz == 'middle')
          left = (display.sizer.clientWidth - node.offsetWidth) / 2;
        node.style.left = left + 'px';
      }
      if (scroll)
        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
    },
    triggerOnKeyDown: operation(null, onKeyDown),
    execCommand: function (cmd) {
      return commands[cmd](this);
    },
    findPosH: function (from, amount, unit, visually) {
      var dir = 1;
      if (amount < 0) {
        dir = -1;
        amount = -amount;
      }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        cur = findPosH(this.doc, cur, dir, unit, visually);
        if (cur.hitSide)
          break;
      }
      return cur;
    },
    moveH: operation(null, function (dir, unit) {
      var sel = this.doc.sel, pos;
      if (sel.shift || sel.extend || posEq(sel.from, sel.to))
        pos = findPosH(this.doc, sel.head, dir, unit, this.options.rtlMoveVisually);
      else
        pos = dir < 0 ? sel.from : sel.to;
      extendSelection(this.doc, pos, pos, dir);
    }),
    deleteH: operation(null, function (dir, unit) {
      var sel = this.doc.sel;
      if (!posEq(sel.from, sel.to))
        replaceRange(this.doc, '', sel.from, sel.to, '+delete');
      else
        replaceRange(this.doc, '', sel.from, findPosH(this.doc, sel.head, dir, unit, false), '+delete');
      this.curOp.userSelChange = true;
    }),
    findPosV: function (from, amount, unit, goalColumn) {
      var dir = 1, x = goalColumn;
      if (amount < 0) {
        dir = -1;
        amount = -amount;
      }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        var coords = cursorCoords(this, cur, 'div');
        if (x == null)
          x = coords.left;
        else
          coords.left = x;
        cur = findPosV(this, coords, dir, unit);
        if (cur.hitSide)
          break;
      }
      return cur;
    },
    moveV: operation(null, function (dir, unit) {
      var sel = this.doc.sel;
      var pos = cursorCoords(this, sel.head, 'div');
      if (sel.goalColumn != null)
        pos.left = sel.goalColumn;
      var target = findPosV(this, pos, dir, unit);
      if (unit == 'page')
        addToScrollPos(this, 0, charCoords(this, target, 'div').top - pos.top);
      extendSelection(this.doc, target, target, dir);
      sel.goalColumn = pos.left;
    }),
    toggleOverwrite: function () {
      if (this.state.overwrite = !this.state.overwrite)
        this.display.cursor.className += ' CodeMirror-overwrite';
      else
        this.display.cursor.className = this.display.cursor.className.replace(' CodeMirror-overwrite', '');
    },
    hasFocus: function () {
      return this.state.focused;
    },
    scrollTo: operation(null, function (x, y) {
      updateScrollPos(this, x, y);
    }),
    getScrollInfo: function () {
      var scroller = this.display.scroller, co = scrollerCutOff;
      return {
        left: scroller.scrollLeft,
        top: scroller.scrollTop,
        height: scroller.scrollHeight - co,
        width: scroller.scrollWidth - co,
        clientHeight: scroller.clientHeight - co,
        clientWidth: scroller.clientWidth - co
      };
    },
    scrollIntoView: operation(null, function (pos, margin) {
      if (typeof pos == 'number')
        pos = Pos(pos, 0);
      if (!margin)
        margin = 0;
      var coords = pos;
      if (!pos || pos.line != null) {
        this.curOp.scrollToPos = pos ? clipPos(this.doc, pos) : this.doc.sel.head;
        this.curOp.scrollToPosMargin = margin;
        coords = cursorCoords(this, this.curOp.scrollToPos);
      }
      var sPos = calculateScrollPos(this, coords.left, coords.top - margin, coords.right, coords.bottom + margin);
      updateScrollPos(this, sPos.scrollLeft, sPos.scrollTop);
    }),
    setSize: function (width, height) {
      function interpret(val) {
        return typeof val == 'number' || /^\d+$/.test(String(val)) ? val + 'px' : val;
      }
      if (width != null)
        this.display.wrapper.style.width = interpret(width);
      if (height != null)
        this.display.wrapper.style.height = interpret(height);
      this.refresh();
    },
    on: function (type, f) {
      on(this, type, f);
    },
    off: function (type, f) {
      off(this, type, f);
    },
    operation: function (f) {
      return runInOp(this, f);
    },
    refresh: operation(null, function () {
      clearCaches(this);
      updateScrollPos(this, this.doc.scrollLeft, this.doc.scrollTop);
      regChange(this);
    }),
    swapDoc: operation(null, function (doc) {
      var old = this.doc;
      old.cm = null;
      attachDoc(this, doc);
      clearCaches(this);
      resetInput(this, true);
      updateScrollPos(this, doc.scrollLeft, doc.scrollTop);
      return old;
    }),
    getInputField: function () {
      return this.display.input;
    },
    getWrapperElement: function () {
      return this.display.wrapper;
    },
    getScrollerElement: function () {
      return this.display.scroller;
    },
    getGutterElement: function () {
      return this.display.gutters;
    }
  };
  var optionHandlers = CodeMirror.optionHandlers = {};
  var defaults = CodeMirror.defaults = {};
  function option(name, deflt, handle, notOnInit) {
    CodeMirror.defaults[name] = deflt;
    if (handle)
      optionHandlers[name] = notOnInit ? function (cm, val, old) {
        if (old != Init)
          handle(cm, val, old);
      } : handle;
  }
  var Init = CodeMirror.Init = {
      toString: function () {
        return 'CodeMirror.Init';
      }
    };
  option('value', '', function (cm, val) {
    cm.setValue(val);
  }, true);
  option('mode', null, function (cm, val) {
    cm.doc.modeOption = val;
    loadMode(cm);
  }, true);
  option('indentUnit', 2, loadMode, true);
  option('indentWithTabs', false);
  option('smartIndent', true);
  option('tabSize', 4, function (cm) {
    loadMode(cm);
    clearCaches(cm);
    regChange(cm);
  }, true);
  option('electricChars', true);
  option('rtlMoveVisually', !windows);
  option('theme', 'default', function (cm) {
    themeChanged(cm);
    guttersChanged(cm);
  }, true);
  option('keyMap', 'default', keyMapChanged);
  option('extraKeys', null);
  option('onKeyEvent', null);
  option('onDragEvent', null);
  option('lineWrapping', false, wrappingChanged, true);
  option('gutters', [], function (cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option('fixedGutter', true, function (cm, val) {
    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + 'px' : '0';
    cm.refresh();
  }, true);
  option('lineNumbers', false, function (cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option('firstLineNumber', 1, guttersChanged, true);
  option('lineNumberFormatter', function (integer) {
    return integer;
  }, guttersChanged, true);
  option('showCursorWhenSelecting', false, updateSelection, true);
  option('readOnly', false, function (cm, val) {
    if (val == 'nocursor') {
      onBlur(cm);
      cm.display.input.blur();
    } else if (!val)
      resetInput(cm, true);
  });
  option('dragDrop', true);
  option('cursorBlinkRate', 530);
  option('cursorHeight', 1);
  option('workTime', 100);
  option('workDelay', 100);
  option('flattenSpans', true);
  option('pollInterval', 100);
  option('undoDepth', 40, function (cm, val) {
    cm.doc.history.undoDepth = val;
  });
  option('historyEventDelay', 500);
  option('viewportMargin', 10, function (cm) {
    cm.refresh();
  }, true);
  option('maxHighlightLength', 10000, function (cm) {
    loadMode(cm);
    cm.refresh();
  }, true);
  option('moveInputWithCursor', true, function (cm, val) {
    if (!val)
      cm.display.inputDiv.style.top = cm.display.inputDiv.style.left = 0;
  });
  option('tabindex', null, function (cm, val) {
    cm.display.input.tabIndex = val || '';
  });
  option('autofocus', null);
  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};
  CodeMirror.defineMode = function (name, mode) {
    if (!CodeMirror.defaults.mode && name != 'null')
      CodeMirror.defaults.mode = name;
    if (arguments.length > 2) {
      mode.dependencies = [];
      for (var i = 2; i < arguments.length; ++i)
        mode.dependencies.push(arguments[i]);
    }
    modes[name] = mode;
  };
  CodeMirror.defineMIME = function (mime, spec) {
    mimeModes[mime] = spec;
  };
  CodeMirror.resolveMode = function (spec) {
    if (typeof spec == 'string' && mimeModes.hasOwnProperty(spec))
      spec = mimeModes[spec];
    else if (typeof spec == 'string' && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec))
      return CodeMirror.resolveMode('application/xml');
    if (typeof spec == 'string')
      return { name: spec };
    else
      return spec || { name: 'null' };
  };
  CodeMirror.getMode = function (options, spec) {
    spec = CodeMirror.resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory)
      return CodeMirror.getMode(options, 'text/plain');
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop))
          continue;
        if (modeObj.hasOwnProperty(prop))
          modeObj['_' + prop] = modeObj[prop];
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;
    return modeObj;
  };
  CodeMirror.defineMode('null', function () {
    return {
      token: function (stream) {
        stream.skipToEnd();
      }
    };
  });
  CodeMirror.defineMIME('text/plain', 'null');
  var modeExtensions = CodeMirror.modeExtensions = {};
  CodeMirror.extendMode = function (mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
    copyObj(properties, exts);
  };
  CodeMirror.defineExtension = function (name, func) {
    CodeMirror.prototype[name] = func;
  };
  CodeMirror.defineDocExtension = function (name, func) {
    Doc.prototype[name] = func;
  };
  CodeMirror.defineOption = option;
  var initHooks = [];
  CodeMirror.defineInitHook = function (f) {
    initHooks.push(f);
  };
  function copyState(mode, state) {
    if (state === true)
      return state;
    if (mode.copyState)
      return mode.copyState(state);
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array)
        val = val.concat([]);
      nstate[n] = val;
    }
    return nstate;
  }
  CodeMirror.copyState = copyState;
  function startState(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true;
  }
  CodeMirror.startState = startState;
  CodeMirror.innerMode = function (mode, state) {
    while (mode.innerMode) {
      var info = mode.innerMode(state);
      state = info.state;
      mode = info.mode;
    }
    return info || {
      mode: mode,
      state: state
    };
  };
  var commands = CodeMirror.commands = {
      selectAll: function (cm) {
        cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()));
      },
      killLine: function (cm) {
        var from = cm.getCursor(true), to = cm.getCursor(false), sel = !posEq(from, to);
        if (!sel && cm.getLine(from.line).length == from.ch)
          cm.replaceRange('', from, Pos(from.line + 1, 0), '+delete');
        else
          cm.replaceRange('', from, sel ? to : Pos(from.line), '+delete');
      },
      deleteLine: function (cm) {
        var l = cm.getCursor().line;
        cm.replaceRange('', Pos(l, 0), Pos(l), '+delete');
      },
      undo: function (cm) {
        cm.undo();
      },
      redo: function (cm) {
        cm.redo();
      },
      goDocStart: function (cm) {
        cm.extendSelection(Pos(cm.firstLine(), 0));
      },
      goDocEnd: function (cm) {
        cm.extendSelection(Pos(cm.lastLine()));
      },
      goLineStart: function (cm) {
        cm.extendSelection(lineStart(cm, cm.getCursor().line));
      },
      goLineStartSmart: function (cm) {
        var cur = cm.getCursor(), start = lineStart(cm, cur.line);
        var line = cm.getLineHandle(start.line);
        var order = getOrder(line);
        if (!order || order[0].level == 0) {
          var firstNonWS = Math.max(0, line.text.search(/\S/));
          var inWS = cur.line == start.line && cur.ch <= firstNonWS && cur.ch;
          cm.extendSelection(Pos(start.line, inWS ? 0 : firstNonWS));
        } else
          cm.extendSelection(start);
      },
      goLineEnd: function (cm) {
        cm.extendSelection(lineEnd(cm, cm.getCursor().line));
      },
      goLineRight: function (cm) {
        var top = cm.charCoords(cm.getCursor(), 'div').top + 5;
        cm.extendSelection(cm.coordsChar({
          left: cm.display.lineDiv.offsetWidth + 100,
          top: top
        }, 'div'));
      },
      goLineLeft: function (cm) {
        var top = cm.charCoords(cm.getCursor(), 'div').top + 5;
        cm.extendSelection(cm.coordsChar({
          left: 0,
          top: top
        }, 'div'));
      },
      goLineUp: function (cm) {
        cm.moveV(-1, 'line');
      },
      goLineDown: function (cm) {
        cm.moveV(1, 'line');
      },
      goPageUp: function (cm) {
        cm.moveV(-1, 'page');
      },
      goPageDown: function (cm) {
        cm.moveV(1, 'page');
      },
      goCharLeft: function (cm) {
        cm.moveH(-1, 'char');
      },
      goCharRight: function (cm) {
        cm.moveH(1, 'char');
      },
      goColumnLeft: function (cm) {
        cm.moveH(-1, 'column');
      },
      goColumnRight: function (cm) {
        cm.moveH(1, 'column');
      },
      goWordLeft: function (cm) {
        cm.moveH(-1, 'word');
      },
      goGroupRight: function (cm) {
        cm.moveH(1, 'group');
      },
      goGroupLeft: function (cm) {
        cm.moveH(-1, 'group');
      },
      goWordRight: function (cm) {
        cm.moveH(1, 'word');
      },
      delCharBefore: function (cm) {
        cm.deleteH(-1, 'char');
      },
      delCharAfter: function (cm) {
        cm.deleteH(1, 'char');
      },
      delWordBefore: function (cm) {
        cm.deleteH(-1, 'word');
      },
      delWordAfter: function (cm) {
        cm.deleteH(1, 'word');
      },
      delGroupBefore: function (cm) {
        cm.deleteH(-1, 'group');
      },
      delGroupAfter: function (cm) {
        cm.deleteH(1, 'group');
      },
      indentAuto: function (cm) {
        cm.indentSelection('smart');
      },
      indentMore: function (cm) {
        cm.indentSelection('add');
      },
      indentLess: function (cm) {
        cm.indentSelection('subtract');
      },
      insertTab: function (cm) {
        cm.replaceSelection('\t', 'end', '+input');
      },
      defaultTab: function (cm) {
        if (cm.somethingSelected())
          cm.indentSelection('add');
        else
          cm.replaceSelection('\t', 'end', '+input');
      },
      transposeChars: function (cm) {
        var cur = cm.getCursor(), line = cm.getLine(cur.line);
        if (cur.ch > 0 && cur.ch < line.length - 1)
          cm.replaceRange(line.charAt(cur.ch) + line.charAt(cur.ch - 1), Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1));
      },
      newlineAndIndent: function (cm) {
        operation(cm, function () {
          cm.replaceSelection('\n', 'end', '+input');
          cm.indentLine(cm.getCursor().line, null, true);
        })();
      },
      toggleOverwrite: function (cm) {
        cm.toggleOverwrite();
      }
    };
  var keyMap = CodeMirror.keyMap = {};
  keyMap.basic = {
    'Left': 'goCharLeft',
    'Right': 'goCharRight',
    'Up': 'goLineUp',
    'Down': 'goLineDown',
    'End': 'goLineEnd',
    'Home': 'goLineStartSmart',
    'PageUp': 'goPageUp',
    'PageDown': 'goPageDown',
    'Delete': 'delCharAfter',
    'Backspace': 'delCharBefore',
    'Tab': 'defaultTab',
    'Shift-Tab': 'indentAuto',
    'Enter': 'newlineAndIndent',
    'Insert': 'toggleOverwrite'
  };
  keyMap.pcDefault = {
    'Ctrl-A': 'selectAll',
    'Ctrl-D': 'deleteLine',
    'Ctrl-Z': 'undo',
    'Shift-Ctrl-Z': 'redo',
    'Ctrl-Y': 'redo',
    'Ctrl-Home': 'goDocStart',
    'Alt-Up': 'goDocStart',
    'Ctrl-End': 'goDocEnd',
    'Ctrl-Down': 'goDocEnd',
    'Ctrl-Left': 'goGroupLeft',
    'Ctrl-Right': 'goGroupRight',
    'Alt-Left': 'goLineStart',
    'Alt-Right': 'goLineEnd',
    'Ctrl-Backspace': 'delGroupBefore',
    'Ctrl-Delete': 'delGroupAfter',
    'Ctrl-S': 'save',
    'Ctrl-F': 'find',
    'Ctrl-G': 'findNext',
    'Shift-Ctrl-G': 'findPrev',
    'Shift-Ctrl-F': 'replace',
    'Shift-Ctrl-R': 'replaceAll',
    'Ctrl-[': 'indentLess',
    'Ctrl-]': 'indentMore',
    fallthrough: 'basic'
  };
  keyMap.macDefault = {
    'Cmd-A': 'selectAll',
    'Cmd-D': 'deleteLine',
    'Cmd-Z': 'undo',
    'Shift-Cmd-Z': 'redo',
    'Cmd-Y': 'redo',
    'Cmd-Up': 'goDocStart',
    'Cmd-End': 'goDocEnd',
    'Cmd-Down': 'goDocEnd',
    'Alt-Left': 'goGroupLeft',
    'Alt-Right': 'goGroupRight',
    'Cmd-Left': 'goLineStart',
    'Cmd-Right': 'goLineEnd',
    'Alt-Backspace': 'delGroupBefore',
    'Ctrl-Alt-Backspace': 'delGroupAfter',
    'Alt-Delete': 'delGroupAfter',
    'Cmd-S': 'save',
    'Cmd-F': 'find',
    'Cmd-G': 'findNext',
    'Shift-Cmd-G': 'findPrev',
    'Cmd-Alt-F': 'replace',
    'Shift-Cmd-Alt-F': 'replaceAll',
    'Cmd-[': 'indentLess',
    'Cmd-]': 'indentMore',
    fallthrough: [
      'basic',
      'emacsy'
    ]
  };
  keyMap['default'] = mac ? keyMap.macDefault : keyMap.pcDefault;
  keyMap.emacsy = {
    'Ctrl-F': 'goCharRight',
    'Ctrl-B': 'goCharLeft',
    'Ctrl-P': 'goLineUp',
    'Ctrl-N': 'goLineDown',
    'Alt-F': 'goWordRight',
    'Alt-B': 'goWordLeft',
    'Ctrl-A': 'goLineStart',
    'Ctrl-E': 'goLineEnd',
    'Ctrl-V': 'goPageDown',
    'Shift-Ctrl-V': 'goPageUp',
    'Ctrl-D': 'delCharAfter',
    'Ctrl-H': 'delCharBefore',
    'Alt-D': 'delWordAfter',
    'Alt-Backspace': 'delWordBefore',
    'Ctrl-K': 'killLine',
    'Ctrl-T': 'transposeChars'
  };
  function getKeyMap(val) {
    if (typeof val == 'string')
      return keyMap[val];
    else
      return val;
  }
  function lookupKey(name, maps, handle) {
    function lookup(map) {
      map = getKeyMap(map);
      var found = map[name];
      if (found === false)
        return 'stop';
      if (found != null && handle(found))
        return true;
      if (map.nofallthrough)
        return 'stop';
      var fallthrough = map.fallthrough;
      if (fallthrough == null)
        return false;
      if (Object.prototype.toString.call(fallthrough) != '[object Array]')
        return lookup(fallthrough);
      for (var i = 0, e = fallthrough.length; i < e; ++i) {
        var done = lookup(fallthrough[i]);
        if (done)
          return done;
      }
      return false;
    }
    for (var i = 0; i < maps.length; ++i) {
      var done = lookup(maps[i]);
      if (done)
        return done;
    }
  }
  function isModifierKey(event) {
    var name = keyNames[event.keyCode];
    return name == 'Ctrl' || name == 'Alt' || name == 'Shift' || name == 'Mod';
  }
  function keyName(event, noShift) {
    if (opera && event.keyCode == 34 && event['char'])
      return false;
    var name = keyNames[event.keyCode];
    if (name == null || event.altGraphKey)
      return false;
    if (event.altKey)
      name = 'Alt-' + name;
    if (flipCtrlCmd ? event.metaKey : event.ctrlKey)
      name = 'Ctrl-' + name;
    if (flipCtrlCmd ? event.ctrlKey : event.metaKey)
      name = 'Cmd-' + name;
    if (!noShift && event.shiftKey)
      name = 'Shift-' + name;
    return name;
  }
  CodeMirror.lookupKey = lookupKey;
  CodeMirror.isModifierKey = isModifierKey;
  CodeMirror.keyName = keyName;
  CodeMirror.fromTextArea = function (textarea, options) {
    if (!options)
      options = {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabindex)
      options.tabindex = textarea.tabindex;
    if (!options.placeholder && textarea.placeholder)
      options.placeholder = textarea.placeholder;
    if (options.autofocus == null) {
      var hasFocus = document.body;
      try {
        hasFocus = document.activeElement;
      } catch (e) {
      }
      options.autofocus = hasFocus == textarea || textarea.getAttribute('autofocus') != null && hasFocus == document.body;
    }
    function save() {
      textarea.value = cm.getValue();
    }
    if (textarea.form) {
      on(textarea.form, 'submit', save);
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form, realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function () {
              save();
              form.submit = realSubmit;
              form.submit();
              form.submit = wrappedSubmit;
            };
        } catch (e) {
        }
      }
    }
    textarea.style.display = 'none';
    var cm = CodeMirror(function (node) {
        textarea.parentNode.insertBefore(node, textarea.nextSibling);
      }, options);
    cm.save = save;
    cm.getTextArea = function () {
      return textarea;
    };
    cm.toTextArea = function () {
      save();
      textarea.parentNode.removeChild(cm.getWrapperElement());
      textarea.style.display = '';
      if (textarea.form) {
        off(textarea.form, 'submit', save);
        if (typeof textarea.form.submit == 'function')
          textarea.form.submit = realSubmit;
      }
    };
    return cm;
  };
  function StringStream(string, tabSize) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
  }
  StringStream.prototype = {
    eol: function () {
      return this.pos >= this.string.length;
    },
    sol: function () {
      return this.pos == 0;
    },
    peek: function () {
      return this.string.charAt(this.pos) || undefined;
    },
    next: function () {
      if (this.pos < this.string.length)
        return this.string.charAt(this.pos++);
    },
    eat: function (match) {
      var ch = this.string.charAt(this.pos);
      if (typeof match == 'string')
        var ok = ch == match;
      else
        var ok = ch && (match.test ? match.test(ch) : match(ch));
      if (ok) {
        ++this.pos;
        return ch;
      }
    },
    eatWhile: function (match) {
      var start = this.pos;
      while (this.eat(match)) {
      }
      return this.pos > start;
    },
    eatSpace: function () {
      var start = this.pos;
      while (/[\s\u00a0]/.test(this.string.charAt(this.pos)))
        ++this.pos;
      return this.pos > start;
    },
    skipToEnd: function () {
      this.pos = this.string.length;
    },
    skipTo: function (ch) {
      var found = this.string.indexOf(ch, this.pos);
      if (found > -1) {
        this.pos = found;
        return true;
      }
    },
    backUp: function (n) {
      this.pos -= n;
    },
    column: function () {
      if (this.lastColumnPos < this.start) {
        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
        this.lastColumnPos = this.start;
      }
      return this.lastColumnValue;
    },
    indentation: function () {
      return countColumn(this.string, null, this.tabSize);
    },
    match: function (pattern, consume, caseInsensitive) {
      if (typeof pattern == 'string') {
        var cased = function (str) {
          return caseInsensitive ? str.toLowerCase() : str;
        };
        var substr = this.string.substr(this.pos, pattern.length);
        if (cased(substr) == cased(pattern)) {
          if (consume !== false)
            this.pos += pattern.length;
          return true;
        }
      } else {
        var match = this.string.slice(this.pos).match(pattern);
        if (match && match.index > 0)
          return null;
        if (match && consume !== false)
          this.pos += match[0].length;
        return match;
      }
    },
    current: function () {
      return this.string.slice(this.start, this.pos);
    }
  };
  CodeMirror.StringStream = StringStream;
  function TextMarker(doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
  }
  CodeMirror.TextMarker = TextMarker;
  TextMarker.prototype.clear = function () {
    if (this.explicitlyCleared)
      return;
    var cm = this.doc.cm, withOp = cm && !cm.curOp;
    if (withOp)
      startOperation(cm);
    var min = null, max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.to != null)
        max = lineNo(line);
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from != null)
        min = lineNo(line);
      else if (this.collapsed && !lineIsHidden(this.doc, line) && cm)
        updateLineHeight(line, textHeight(cm.display));
    }
    if (cm && this.collapsed && !cm.options.lineWrapping)
      for (var i = 0; i < this.lines.length; ++i) {
        var visual = visualLine(cm.doc, this.lines[i]), len = lineLength(cm.doc, visual);
        if (len > cm.display.maxLineLength) {
          cm.display.maxLine = visual;
          cm.display.maxLineLength = len;
          cm.display.maxLineChanged = true;
        }
      }
    if (min != null && cm)
      regChange(cm, min, max + 1);
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.collapsed && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm)
        reCheckSelection(cm);
    }
    if (withOp)
      endOperation(cm);
    signalLater(this, 'clear');
  };
  TextMarker.prototype.find = function () {
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.from != null || span.to != null) {
        var found = lineNo(line);
        if (span.from != null)
          from = Pos(found, span.from);
        if (span.to != null)
          to = Pos(found, span.to);
      }
    }
    if (this.type == 'bookmark')
      return from;
    return from && {
      from: from,
      to: to
    };
  };
  TextMarker.prototype.getOptions = function (copyWidget) {
    var repl = this.replacedWith;
    return {
      className: this.className,
      inclusiveLeft: this.inclusiveLeft,
      inclusiveRight: this.inclusiveRight,
      atomic: this.atomic,
      collapsed: this.collapsed,
      replacedWith: copyWidget ? repl && repl.cloneNode(true) : repl,
      readOnly: this.readOnly,
      startStyle: this.startStyle,
      endStyle: this.endStyle
    };
  };
  TextMarker.prototype.attachLine = function (line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
    }
    this.lines.push(line);
  };
  TextMarker.prototype.detachLine = function (line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };
  function markText(doc, from, to, options, type) {
    if (options && options.shared)
      return markTextShared(doc, from, to, options, type);
    if (doc.cm && !doc.cm.curOp)
      return operation(doc.cm, markText)(doc, from, to, options, type);
    var marker = new TextMarker(doc, type);
    if (type == 'range' && !posLess(from, to))
      return marker;
    if (options)
      copyObj(options, marker);
    if (marker.replacedWith) {
      marker.collapsed = true;
      marker.replacedWith = elt('span', [marker.replacedWith], 'CodeMirror-widget');
    }
    if (marker.collapsed)
      sawCollapsedSpans = true;
    if (marker.addToHistory)
      addToHistory(doc, {
        from: from,
        to: to,
        origin: 'markText'
      }, {
        head: doc.sel.head,
        anchor: doc.sel.anchor
      }, NaN);
    var curLine = from.line, size = 0, collapsedAtStart, collapsedAtEnd, cm = doc.cm, updateMaxLine;
    doc.iter(curLine, to.line + 1, function (line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(doc, line) == cm.display.maxLine)
        updateMaxLine = true;
      var span = {
          from: null,
          to: null,
          marker: marker
        };
      size += line.text.length;
      if (curLine == from.line) {
        span.from = from.ch;
        size -= from.ch;
      }
      if (curLine == to.line) {
        span.to = to.ch;
        size -= line.text.length - to.ch;
      }
      if (marker.collapsed) {
        if (curLine == to.line)
          collapsedAtEnd = collapsedSpanAt(line, to.ch);
        if (curLine == from.line)
          collapsedAtStart = collapsedSpanAt(line, from.ch);
        else
          updateLineHeight(line, 0);
      }
      addMarkedSpan(line, span);
      ++curLine;
    });
    if (marker.collapsed)
      doc.iter(from.line, to.line + 1, function (line) {
        if (lineIsHidden(doc, line))
          updateLineHeight(line, 0);
      });
    if (marker.clearOnEnter)
      on(marker, 'beforeCursorEnter', function () {
        marker.clear();
      });
    if (marker.readOnly) {
      sawReadOnlySpans = true;
      if (doc.history.done.length || doc.history.undone.length)
        doc.clearHistory();
    }
    if (marker.collapsed) {
      if (collapsedAtStart != collapsedAtEnd)
        throw new Error('Inserting collapsed marker overlapping an existing one');
      marker.size = size;
      marker.atomic = true;
    }
    if (cm) {
      if (updateMaxLine)
        cm.curOp.updateMaxLine = true;
      if (marker.className || marker.startStyle || marker.endStyle || marker.collapsed)
        regChange(cm, from.line, to.line + 1);
      if (marker.atomic)
        reCheckSelection(cm);
    }
    return marker;
  }
  function SharedTextMarker(markers, primary) {
    this.markers = markers;
    this.primary = primary;
    for (var i = 0, me = this; i < markers.length; ++i) {
      markers[i].parent = this;
      on(markers[i], 'clear', function () {
        me.clear();
      });
    }
  }
  CodeMirror.SharedTextMarker = SharedTextMarker;
  SharedTextMarker.prototype.clear = function () {
    if (this.explicitlyCleared)
      return;
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i)
      this.markers[i].clear();
    signalLater(this, 'clear');
  };
  SharedTextMarker.prototype.find = function () {
    return this.primary.find();
  };
  SharedTextMarker.prototype.getOptions = function (copyWidget) {
    var inner = this.primary.getOptions(copyWidget);
    inner.shared = true;
    return inner;
  };
  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
    var widget = options.replacedWith;
    linkedDocs(doc, function (doc) {
      if (widget)
        options.replacedWith = widget.cloneNode(true);
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i)
        if (doc.linked[i].isParent)
          return;
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary);
  }
  function getMarkedSpanFor(spans, marker) {
    if (spans)
      for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if (span.marker == marker)
          return span;
      }
  }
  function removeMarkedSpan(spans, span) {
    for (var r, i = 0; i < spans.length; ++i)
      if (spans[i] != span)
        (r || (r = [])).push(spans[i]);
    return r;
  }
  function addMarkedSpan(line, span) {
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
    span.marker.attachLine(line);
  }
  function markedSpansBefore(old, startCh, isInsert) {
    if (old)
      for (var i = 0, nw; i < old.length; ++i) {
        var span = old[i], marker = span.marker;
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
        if (startsBefore || marker.type == 'bookmark' && span.from == startCh && (!isInsert || !span.marker.insertLeft)) {
          var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
          (nw || (nw = [])).push({
            from: span.from,
            to: endsAfter ? null : span.to,
            marker: marker
          });
        }
      }
    return nw;
  }
  function markedSpansAfter(old, endCh, isInsert) {
    if (old)
      for (var i = 0, nw; i < old.length; ++i) {
        var span = old[i], marker = span.marker;
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
        if (endsAfter || marker.type == 'bookmark' && span.from == endCh && (!isInsert || span.marker.insertLeft)) {
          var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
          (nw || (nw = [])).push({
            from: startsBefore ? null : span.from - endCh,
            to: span.to == null ? null : span.to - endCh,
            marker: marker
          });
        }
      }
    return nw;
  }
  function stretchSpansOverChange(doc, change) {
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast)
      return null;
    var startCh = change.from.ch, endCh = change.to.ch, isInsert = posEq(change.from, change.to);
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);
    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found)
            span.to = startCh;
          else if (sameLine)
            span.to = found.to == null ? null : found.to + offset;
        }
      }
    }
    if (last) {
      for (var i = 0; i < last.length; ++i) {
        var span = last[i];
        if (span.to != null)
          span.to += offset;
        if (span.from == null) {
          var found = getMarkedSpanFor(first, span.marker);
          if (!found) {
            span.from = offset;
            if (sameLine)
              (first || (first = [])).push(span);
          }
        } else {
          span.from += offset;
          if (sameLine)
            (first || (first = [])).push(span);
        }
      }
    }
    var newMarkers = [first];
    if (!sameLine) {
      var gap = change.text.length - 2, gapMarkers;
      if (gap > 0 && first)
        for (var i = 0; i < first.length; ++i)
          if (first[i].to == null)
            (gapMarkers || (gapMarkers = [])).push({
              from: null,
              to: null,
              marker: first[i].marker
            });
      for (var i = 0; i < gap; ++i)
        newMarkers.push(gapMarkers);
      newMarkers.push(last);
    }
    return newMarkers;
  }
  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old)
      return stretched;
    if (!stretched)
      return old;
    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i], stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans:
          for (var j = 0; j < stretchCur.length; ++j) {
            var span = stretchCur[j];
            for (var k = 0; k < oldCur.length; ++k)
              if (oldCur[k].marker == span.marker)
                continue spans;
            oldCur.push(span);
          }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old;
  }
  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function (line) {
      if (line.markedSpans)
        for (var i = 0; i < line.markedSpans.length; ++i) {
          var mark = line.markedSpans[i].marker;
          if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
            (markers || (markers = [])).push(mark);
        }
    });
    if (!markers)
      return null;
    var parts = [{
          from: from,
          to: to
        }];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i], m = mk.find();
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (posLess(p.to, m.from) || posLess(m.to, p.from))
          continue;
        var newParts = [
            j,
            1
          ];
        if (posLess(p.from, m.from) || !mk.inclusiveLeft && posEq(p.from, m.from))
          newParts.push({
            from: p.from,
            to: m.from
          });
        if (posLess(m.to, p.to) || !mk.inclusiveRight && posEq(p.to, m.to))
          newParts.push({
            from: m.to,
            to: p.to
          });
        parts.splice.apply(parts, newParts);
        j += newParts.length - 1;
      }
    }
    return parts;
  }
  function collapsedSpanAt(line, ch) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps)
      for (var sp, i = 0; i < sps.length; ++i) {
        sp = sps[i];
        if (!sp.marker.collapsed)
          continue;
        if ((sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || found.width < sp.marker.width))
          found = sp.marker;
      }
    return found;
  }
  function collapsedSpanAtStart(line) {
    return collapsedSpanAt(line, -1);
  }
  function collapsedSpanAtEnd(line) {
    return collapsedSpanAt(line, line.text.length + 1);
  }
  function visualLine(doc, line) {
    var merged;
    while (merged = collapsedSpanAtStart(line))
      line = getLine(doc, merged.find().from.line);
    return line;
  }
  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps)
      for (var sp, i = 0; i < sps.length; ++i) {
        sp = sps[i];
        if (!sp.marker.collapsed)
          continue;
        if (sp.from == null)
          return true;
        if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
          return true;
      }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find().to, endLine = getLine(doc, end.line);
      return lineIsHiddenInner(doc, endLine, getMarkedSpanFor(endLine.markedSpans, span.marker));
    }
    if (span.marker.inclusiveRight && span.to == line.text.length)
      return true;
    for (var sp, i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && sp.from == span.to && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp))
        return true;
    }
  }
  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans)
      return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.detachLine(line);
    line.markedSpans = null;
  }
  function attachMarkedSpans(line, spans) {
    if (!spans)
      return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.attachLine(line);
    line.markedSpans = spans;
  }
  var LineWidget = CodeMirror.LineWidget = function (cm, node, options) {
      for (var opt in options)
        if (options.hasOwnProperty(opt))
          this[opt] = options[opt];
      this.cm = cm;
      this.node = node;
    };
  function widgetOperation(f) {
    return function () {
      var withOp = !this.cm.curOp;
      if (withOp)
        startOperation(this.cm);
      try {
        var result = f.apply(this, arguments);
      } finally {
        if (withOp)
          endOperation(this.cm);
      }
      return result;
    };
  }
  LineWidget.prototype.clear = widgetOperation(function () {
    var ws = this.line.widgets, no = lineNo(this.line);
    if (no == null || !ws)
      return;
    for (var i = 0; i < ws.length; ++i)
      if (ws[i] == this)
        ws.splice(i--, 1);
    if (!ws.length)
      this.line.widgets = null;
    updateLineHeight(this.line, Math.max(0, this.line.height - widgetHeight(this)));
    regChange(this.cm, no, no + 1);
  });
  LineWidget.prototype.changed = widgetOperation(function () {
    var oldH = this.height;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff)
      return;
    updateLineHeight(this.line, this.line.height + diff);
    var no = lineNo(this.line);
    regChange(this.cm, no, no + 1);
  });
  function widgetHeight(widget) {
    if (widget.height != null)
      return widget.height;
    if (!widget.node.parentNode || widget.node.parentNode.nodeType != 1)
      removeChildrenAndAdd(widget.cm.display.measure, elt('div', [widget.node], null, 'position: relative'));
    return widget.height = widget.node.offsetHeight;
  }
  function addLineWidget(cm, handle, node, options) {
    var widget = new LineWidget(cm, node, options);
    if (widget.noHScroll)
      cm.display.alignWidgets = true;
    changeLine(cm, handle, function (line) {
      (line.widgets || (line.widgets = [])).push(widget);
      widget.line = line;
      if (!lineIsHidden(cm.doc, line) || widget.showIfHidden) {
        var aboveVisible = heightAtLine(cm, line) < cm.display.scroller.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible)
          addToScrollPos(cm, 0, widget.height);
      }
      return true;
    });
    return widget;
  }
  function makeLine(text, markedSpans, estimateHeight) {
    var line = { text: text };
    attachMarkedSpans(line, markedSpans);
    line.height = estimateHeight ? estimateHeight(line) : 1;
    return line;
  }
  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter)
      line.stateAfter = null;
    if (line.styles)
      line.styles = null;
    if (line.order != null)
      line.order = null;
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height)
      updateLineHeight(line, estHeight);
  }
  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }
  function runMode(cm, text, mode, state, f) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null)
      flattenSpans = cm.options.flattenSpans;
    var curText = '', curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize), style;
    if (text == '' && mode.blankLine)
      mode.blankLine(state);
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        stream.pos = Math.min(text.length, stream.start + 50000);
        style = null;
      } else {
        style = mode.token(stream, state);
      }
      var substr = stream.current();
      stream.start = stream.pos;
      if (!flattenSpans || curStyle != style) {
        if (curText)
          f(curText, curStyle);
        curText = substr;
        curStyle = style;
      } else
        curText = curText + substr;
    }
    if (curText)
      f(curText, curStyle);
  }
  function highlightLine(cm, line, state) {
    var st = [cm.state.modeGen];
    runMode(cm, line.text, cm.doc.mode, state, function (txt, style) {
      st.push(txt, style);
    });
    for (var o = 0; o < cm.state.overlays.length; ++o) {
      var overlay = cm.state.overlays[o], i = 1;
      runMode(cm, line.text, overlay.mode, true, function (txt, style) {
        var start = i, len = txt.length;
        while (len) {
          var cur = st[i], len_ = cur.length;
          if (len_ <= len) {
            len -= len_;
          } else {
            st.splice(i, 1, cur.slice(0, len), st[i + 1], cur.slice(len));
            len = 0;
          }
          i += 2;
        }
        if (!style)
          return;
        if (overlay.opaque) {
          st.splice(start, i - start, txt, style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start + 1];
            st[start + 1] = cur ? cur + ' ' + style : style;
          }
        }
      });
    }
    return st;
  }
  function getLineStyles(cm, line) {
    if (!line.styles || line.styles[0] != cm.state.modeGen)
      line.styles = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));
    return line.styles;
  }
  function processLine(cm, line, state) {
    var mode = cm.doc.mode;
    var stream = new StringStream(line.text, cm.options.tabSize);
    if (line.text == '' && mode.blankLine)
      mode.blankLine(state);
    while (!stream.eol() && stream.pos <= cm.options.maxHighlightLength) {
      mode.token(stream, state);
      stream.start = stream.pos;
    }
  }
  var styleToClassCache = {};
  function styleToClass(style) {
    if (!style)
      return null;
    return styleToClassCache[style] || (styleToClassCache[style] = 'cm-' + style.replace(/ +/g, ' cm-'));
  }
  function lineContent(cm, realLine, measure) {
    var merged, line = realLine, lineBefore, sawBefore, simple = true;
    while (merged = collapsedSpanAtStart(line)) {
      simple = false;
      line = getLine(cm.doc, merged.find().from.line);
      if (!lineBefore)
        lineBefore = line;
    }
    var builder = {
        pre: elt('pre'),
        col: 0,
        pos: 0,
        display: !measure,
        measure: null,
        addedOne: false,
        cm: cm
      };
    if (line.textClass)
      builder.pre.className = line.textClass;
    do {
      builder.measure = line == realLine && measure;
      builder.pos = 0;
      builder.addToken = builder.measure ? buildTokenMeasure : buildToken;
      if ((ie || webkit) && cm.getOption('lineWrapping'))
        builder.addToken = buildTokenSplitSpaces(builder.addToken);
      if (measure && sawBefore && line != realLine && !builder.addedOne) {
        measure[0] = builder.pre.appendChild(zeroWidthElement(cm.display.measure));
        builder.addedOne = true;
      }
      var next = insertLineContent(line, builder, getLineStyles(cm, line));
      sawBefore = line == lineBefore;
      if (next) {
        line = getLine(cm.doc, next.to.line);
        simple = false;
      }
    } while (next);
    if (measure && !builder.addedOne)
      measure[0] = builder.pre.appendChild(simple ? elt('span', '\xa0') : zeroWidthElement(cm.display.measure));
    if (!builder.pre.firstChild && !lineIsHidden(cm.doc, realLine))
      builder.pre.appendChild(document.createTextNode('\xa0'));
    var order;
    if (measure && ie && (order = getOrder(line))) {
      var l = order.length - 1;
      if (order[l].from == order[l].to)
        --l;
      var last = order[l], prev = order[l - 1];
      if (last.from + 1 == last.to && prev && last.level < prev.level) {
        var span = measure[builder.pos - 1];
        if (span)
          span.parentNode.insertBefore(span.measureRight = zeroWidthElement(cm.display.measure), span.nextSibling);
      }
    }
    signal(cm, 'renderLine', cm, realLine, builder.pre);
    return builder.pre;
  }
  var tokenSpecialChars = /[\t\u0000-\u0019\u00ad\u200b\u2028\u2029\uFEFF]/g;
  function buildToken(builder, text, style, startStyle, endStyle) {
    if (!text)
      return;
    if (!tokenSpecialChars.test(text)) {
      builder.col += text.length;
      var content = document.createTextNode(text);
    } else {
      var content = document.createDocumentFragment(), pos = 0;
      while (true) {
        tokenSpecialChars.lastIndex = pos;
        var m = tokenSpecialChars.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          content.appendChild(document.createTextNode(text.slice(pos, pos + skipped)));
          builder.col += skipped;
        }
        if (!m)
          break;
        pos += skipped + 1;
        if (m[0] == '\t') {
          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
          content.appendChild(elt('span', spaceStr(tabWidth), 'cm-tab'));
          builder.col += tabWidth;
        } else {
          var token = elt('span', '\u2022', 'cm-invalidchar');
          token.title = '\\u' + m[0].charCodeAt(0).toString(16);
          content.appendChild(token);
          builder.col += 1;
        }
      }
    }
    if (style || startStyle || endStyle || builder.measure) {
      var fullStyle = style || '';
      if (startStyle)
        fullStyle += startStyle;
      if (endStyle)
        fullStyle += endStyle;
      return builder.pre.appendChild(elt('span', [content], fullStyle));
    }
    builder.pre.appendChild(content);
  }
  function buildTokenMeasure(builder, text, style, startStyle, endStyle) {
    var wrapping = builder.cm.options.lineWrapping;
    for (var i = 0; i < text.length; ++i) {
      var ch = text.charAt(i), start = i == 0;
      if (ch >= '\ud800' && ch < '\udbff' && i < text.length - 1) {
        ch = text.slice(i, i + 2);
        ++i;
      } else if (i && wrapping && spanAffectsWrapping.test(text.slice(i - 1, i + 1))) {
        builder.pre.appendChild(elt('wbr'));
      }
      var span = builder.measure[builder.pos] = buildToken(builder, ch, style, start && startStyle, i == text.length - 1 && endStyle);
      if (ie && wrapping && ch == ' ' && i && !/\s/.test(text.charAt(i - 1)) && i < text.length - 1 && !/\s/.test(text.charAt(i + 1)))
        span.style.whiteSpace = 'normal';
      builder.pos += ch.length;
    }
    if (text.length)
      builder.addedOne = true;
  }
  function buildTokenSplitSpaces(inner) {
    function split(old) {
      var out = ' ';
      for (var i = 0; i < old.length - 2; ++i)
        out += i % 2 ? ' ' : '\xa0';
      out += ' ';
      return out;
    }
    return function (builder, text, style, startStyle, endStyle) {
      return inner(builder, text.replace(/ {3,}/, split), style, startStyle, endStyle);
    };
  }
  function buildCollapsedSpan(builder, size, widget) {
    if (widget) {
      if (!builder.display)
        widget = widget.cloneNode(true);
      builder.pre.appendChild(widget);
      if (builder.measure && size) {
        builder.measure[builder.pos] = widget;
        builder.addedOne = true;
      }
    }
    builder.pos += size;
  }
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans;
    if (!spans) {
      for (var i = 1; i < styles.length; i += 2)
        builder.addToken(builder, styles[i], styleToClass(styles[i + 1]));
      return;
    }
    var allText = line.text, len = allText.length;
    var pos = 0, i = 1, text = '', style;
    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed;
    for (;;) {
      if (nextChange == pos) {
        spanStyle = spanEndStyle = spanStartStyle = '';
        collapsed = null;
        nextChange = Infinity;
        var foundBookmark = null;
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j], m = sp.marker;
          if (sp.from <= pos && (sp.to == null || sp.to > pos)) {
            if (sp.to != null && nextChange > sp.to) {
              nextChange = sp.to;
              spanEndStyle = '';
            }
            if (m.className)
              spanStyle += ' ' + m.className;
            if (m.startStyle && sp.from == pos)
              spanStartStyle += ' ' + m.startStyle;
            if (m.endStyle && sp.to == nextChange)
              spanEndStyle += ' ' + m.endStyle;
            if (m.collapsed && (!collapsed || collapsed.marker.width < m.width))
              collapsed = sp;
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
          if (m.type == 'bookmark' && sp.from == pos && m.replacedWith)
            foundBookmark = m.replacedWith;
        }
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len : collapsed.to) - pos, collapsed.from != null && collapsed.marker.replacedWith);
          if (collapsed.to == null)
            return collapsed.marker.find();
        }
        if (foundBookmark && !collapsed)
          buildCollapsedSpan(builder, 0, foundBookmark);
      }
      if (pos >= len)
        break;
      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : '');
          }
          if (end >= upto) {
            text = text.slice(upto - pos);
            pos = upto;
            break;
          }
          pos = end;
          spanStartStyle = '';
        }
        text = styles[i++];
        style = styleToClass(styles[i++]);
      }
    }
  }
  function updateDoc(doc, change, markedSpans, selAfter, estimateHeight) {
    function spansFor(n) {
      return markedSpans ? markedSpans[n] : null;
    }
    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight);
      signalLater(line, 'change', line, change);
    }
    var from = change.from, to = change.to, text = change.text;
    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;
    if (from.ch == 0 && to.ch == 0 && lastText == '') {
      for (var i = 0, e = text.length - 1, added = []; i < e; ++i)
        added.push(makeLine(text[i], spansFor(i), estimateHeight));
      update(lastLine, lastLine.text, lastSpans);
      if (nlines)
        doc.remove(from.line, nlines);
      if (added.length)
        doc.insert(from.line, added);
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        for (var added = [], i = 1, e = text.length - 1; i < e; ++i)
          added.push(makeLine(text[i], spansFor(i), estimateHeight));
        added.push(makeLine(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      for (var i = 1, e = text.length - 1, added = []; i < e; ++i)
        added.push(makeLine(text[i], spansFor(i), estimateHeight));
      if (nlines > 1)
        doc.remove(from.line + 1, nlines - 1);
      doc.insert(from.line + 1, added);
    }
    signalLater(doc, 'change', doc, change);
    setSelection(doc, selAfter.anchor, selAfter.head, null, true);
  }
  function LeafChunk(lines) {
    this.lines = lines;
    this.parent = null;
    for (var i = 0, e = lines.length, height = 0; i < e; ++i) {
      lines[i].parent = this;
      height += lines[i].height;
    }
    this.height = height;
  }
  LeafChunk.prototype = {
    chunkSize: function () {
      return this.lines.length;
    },
    removeInner: function (at, n) {
      for (var i = at, e = at + n; i < e; ++i) {
        var line = this.lines[i];
        this.height -= line.height;
        cleanUpLine(line);
        signalLater(line, 'delete');
      }
      this.lines.splice(at, n);
    },
    collapse: function (lines) {
      lines.splice.apply(lines, [
        lines.length,
        0
      ].concat(this.lines));
    },
    insertInner: function (at, lines, height) {
      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0, e = lines.length; i < e; ++i)
        lines[i].parent = this;
    },
    iterN: function (at, n, op) {
      for (var e = at + n; at < e; ++at)
        if (op(this.lines[at]))
          return true;
    }
  };
  function BranchChunk(children) {
    this.children = children;
    var size = 0, height = 0;
    for (var i = 0, e = children.length; i < e; ++i) {
      var ch = children[i];
      size += ch.chunkSize();
      height += ch.height;
      ch.parent = this;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }
  BranchChunk.prototype = {
    chunkSize: function () {
      return this.size;
    },
    removeInner: function (at, n) {
      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at), oldHeight = child.height;
          child.removeInner(at, rm);
          this.height -= oldHeight - child.height;
          if (sz == rm) {
            this.children.splice(i--, 1);
            child.parent = null;
          }
          if ((n -= rm) == 0)
            break;
          at = 0;
        } else
          at -= sz;
      }
      if (this.size - n < 25) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },
    collapse: function (lines) {
      for (var i = 0, e = this.children.length; i < e; ++i)
        this.children[i].collapse(lines);
    },
    insertInner: function (at, lines, height) {
      this.size += lines.length;
      this.height += height;
      for (var i = 0, e = this.children.length; i < e; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            while (child.lines.length > 50) {
              var spilled = child.lines.splice(child.lines.length - 25, 25);
              var newleaf = new LeafChunk(spilled);
              child.height -= newleaf.height;
              this.children.splice(i + 1, 0, newleaf);
              newleaf.parent = this;
            }
            this.maybeSpill();
          }
          break;
        }
        at -= sz;
      }
    },
    maybeSpill: function () {
      if (this.children.length <= 10)
        return;
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) {
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [
            copy,
            sibling
          ];
          me = copy;
        } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10);
      me.parent.maybeSpill();
    },
    iterN: function (at, n, op) {
      for (var i = 0, e = this.children.length; i < e; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op))
            return true;
          if ((n -= used) == 0)
            break;
          at = 0;
        } else
          at -= sz;
      }
    }
  };
  var nextDocId = 0;
  var Doc = CodeMirror.Doc = function (text, mode, firstLine) {
      if (!(this instanceof Doc))
        return new Doc(text, mode, firstLine);
      if (firstLine == null)
        firstLine = 0;
      BranchChunk.call(this, [new LeafChunk([makeLine('', null)])]);
      this.first = firstLine;
      this.scrollTop = this.scrollLeft = 0;
      this.cantEdit = false;
      this.history = makeHistory();
      this.frontier = firstLine;
      var start = Pos(firstLine, 0);
      this.sel = {
        from: start,
        to: start,
        head: start,
        anchor: start,
        shift: false,
        extend: false,
        goalColumn: null
      };
      this.id = ++nextDocId;
      this.modeOption = mode;
      if (typeof text == 'string')
        text = splitLines(text);
      updateDoc(this, {
        from: start,
        to: start,
        text: text
      }, null, {
        head: start,
        anchor: start
      });
    };
  Doc.prototype = createObj(BranchChunk.prototype, {
    iter: function (from, to, op) {
      if (op)
        this.iterN(from - this.first, to - from, op);
      else
        this.iterN(this.first, this.first + this.size, from);
    },
    insert: function (at, lines) {
      var height = 0;
      for (var i = 0, e = lines.length; i < e; ++i)
        height += lines[i].height;
      this.insertInner(at - this.first, lines, height);
    },
    remove: function (at, n) {
      this.removeInner(at - this.first, n);
    },
    getValue: function (lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false)
        return lines;
      return lines.join(lineSep || '\n');
    },
    setValue: function (code) {
      var top = Pos(this.first, 0), last = this.first + this.size - 1;
      makeChange(this, {
        from: top,
        to: Pos(last, getLine(this, last).text.length),
        text: splitLines(code),
        origin: 'setValue'
      }, {
        head: top,
        anchor: top
      }, true);
    },
    replaceRange: function (code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function (from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false)
        return lines;
      return lines.join(lineSep || '\n');
    },
    getLine: function (line) {
      var l = this.getLineHandle(line);
      return l && l.text;
    },
    setLine: function (line, text) {
      if (isLine(this, line))
        replaceRange(this, text, Pos(line, 0), clipPos(this, Pos(line)));
    },
    removeLine: function (line) {
      if (line)
        replaceRange(this, '', clipPos(this, Pos(line - 1)), clipPos(this, Pos(line)));
      else
        replaceRange(this, '', Pos(0, 0), clipPos(this, Pos(1, 0)));
    },
    getLineHandle: function (line) {
      if (isLine(this, line))
        return getLine(this, line);
    },
    getLineNumber: function (line) {
      return lineNo(line);
    },
    lineCount: function () {
      return this.size;
    },
    firstLine: function () {
      return this.first;
    },
    lastLine: function () {
      return this.first + this.size - 1;
    },
    clipPos: function (pos) {
      return clipPos(this, pos);
    },
    getCursor: function (start) {
      var sel = this.sel, pos;
      if (start == null || start == 'head')
        pos = sel.head;
      else if (start == 'anchor')
        pos = sel.anchor;
      else if (start == 'end' || start === false)
        pos = sel.to;
      else
        pos = sel.from;
      return copyPos(pos);
    },
    somethingSelected: function () {
      return !posEq(this.sel.head, this.sel.anchor);
    },
    setCursor: docOperation(function (line, ch, extend) {
      var pos = clipPos(this, typeof line == 'number' ? Pos(line, ch || 0) : line);
      if (extend)
        extendSelection(this, pos);
      else
        setSelection(this, pos, pos);
    }),
    setSelection: docOperation(function (anchor, head) {
      setSelection(this, clipPos(this, anchor), clipPos(this, head || anchor));
    }),
    extendSelection: docOperation(function (from, to) {
      extendSelection(this, clipPos(this, from), to && clipPos(this, to));
    }),
    getSelection: function (lineSep) {
      return this.getRange(this.sel.from, this.sel.to, lineSep);
    },
    replaceSelection: function (code, collapse, origin) {
      makeChange(this, {
        from: this.sel.from,
        to: this.sel.to,
        text: splitLines(code),
        origin: origin
      }, collapse || 'around');
    },
    undo: docOperation(function () {
      makeChangeFromHistory(this, 'undo');
    }),
    redo: docOperation(function () {
      makeChangeFromHistory(this, 'redo');
    }),
    setExtending: function (val) {
      this.sel.extend = val;
    },
    historySize: function () {
      var hist = this.history;
      return {
        undo: hist.done.length,
        redo: hist.undone.length
      };
    },
    clearHistory: function () {
      this.history = makeHistory();
    },
    markClean: function () {
      this.history.dirtyCounter = 0;
      this.history.lastOp = this.history.lastOrigin = null;
    },
    isClean: function () {
      return this.history.dirtyCounter == 0;
    },
    getHistory: function () {
      return {
        done: copyHistoryArray(this.history.done),
        undone: copyHistoryArray(this.history.undone)
      };
    },
    setHistory: function (histData) {
      var hist = this.history = makeHistory();
      hist.done = histData.done.slice(0);
      hist.undone = histData.undone.slice(0);
    },
    markText: function (from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, 'range');
    },
    setBookmark: function (pos, options) {
      var realOpts = {
          replacedWith: options && (options.nodeType == null ? options.widget : options),
          insertLeft: options && options.insertLeft
        };
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, 'bookmark');
    },
    findMarksAt: function (pos) {
      pos = clipPos(this, pos);
      var markers = [], spans = getLine(this, pos.line).markedSpans;
      if (spans)
        for (var i = 0; i < spans.length; ++i) {
          var span = spans[i];
          if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch))
            markers.push(span.marker.parent || span.marker);
        }
      return markers;
    },
    getAllMarks: function () {
      var markers = [];
      this.iter(function (line) {
        var sps = line.markedSpans;
        if (sps)
          for (var i = 0; i < sps.length; ++i)
            if (sps[i].from != null)
              markers.push(sps[i].marker);
      });
      return markers;
    },
    posFromIndex: function (off) {
      var ch, lineNo = this.first;
      this.iter(function (line) {
        var sz = line.text.length + 1;
        if (sz > off) {
          ch = off;
          return true;
        }
        off -= sz;
        ++lineNo;
      });
      return clipPos(this, Pos(lineNo, ch));
    },
    indexFromPos: function (coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0)
        return 0;
      this.iter(this.first, coords.line, function (line) {
        index += line.text.length + 1;
      });
      return index;
    },
    copy: function (copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);
      doc.scrollTop = this.scrollTop;
      doc.scrollLeft = this.scrollLeft;
      doc.sel = {
        from: this.sel.from,
        to: this.sel.to,
        head: this.sel.head,
        anchor: this.sel.anchor,
        shift: this.sel.shift,
        extend: false,
        goalColumn: this.sel.goalColumn
      };
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc;
    },
    linkedDoc: function (options) {
      if (!options)
        options = {};
      var from = this.first, to = this.first + this.size;
      if (options.from != null && options.from > from)
        from = options.from;
      if (options.to != null && options.to < to)
        to = options.to;
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);
      if (options.sharedHist)
        copy.history = this.history;
      (this.linked || (this.linked = [])).push({
        doc: copy,
        sharedHist: options.sharedHist
      });
      copy.linked = [{
          doc: this,
          isParent: true,
          sharedHist: options.sharedHist
        }];
      return copy;
    },
    unlinkDoc: function (other) {
      if (other instanceof CodeMirror)
        other = other.doc;
      if (this.linked)
        for (var i = 0; i < this.linked.length; ++i) {
          var link = this.linked[i];
          if (link.doc != other)
            continue;
          this.linked.splice(i, 1);
          other.unlinkDoc(this);
          break;
        }
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function (doc) {
          splitIds.push(doc.id);
        }, true);
        other.history = makeHistory();
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function (f) {
      linkedDocs(this, f);
    },
    getMode: function () {
      return this.mode;
    },
    getEditor: function () {
      return this.cm;
    }
  });
  Doc.prototype.eachLine = Doc.prototype.iter;
  var dontDelegate = 'iter insert remove copy getEditor'.split(' ');
  for (var prop in Doc.prototype)
    if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
      CodeMirror.prototype[prop] = function (method) {
        return function () {
          return method.apply(this.doc, arguments);
        };
      }(Doc.prototype[prop]);
  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked)
        for (var i = 0; i < doc.linked.length; ++i) {
          var rel = doc.linked[i];
          if (rel.doc == skip)
            continue;
          var shared = sharedHist && rel.sharedHist;
          if (sharedHistOnly && !shared)
            continue;
          f(rel.doc, shared);
          propagate(rel.doc, doc, shared);
        }
    }
    propagate(doc, null, true);
  }
  function attachDoc(cm, doc) {
    if (doc.cm)
      throw new Error('This document is already in use.');
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    if (!cm.options.lineWrapping)
      computeMaxLength(cm);
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }
  function getLine(chunk, n) {
    n -= chunk.first;
    while (!chunk.lines) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i], sz = child.chunkSize();
        if (n < sz) {
          chunk = child;
          break;
        }
        n -= sz;
      }
    }
    return chunk.lines[n];
  }
  function getBetween(doc, start, end) {
    var out = [], n = start.line;
    doc.iter(start.line, end.line + 1, function (line) {
      var text = line.text;
      if (n == end.line)
        text = text.slice(0, end.ch);
      if (n == start.line)
        text = text.slice(start.ch);
      out.push(text);
      ++n;
    });
    return out;
  }
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function (line) {
      out.push(line.text);
    });
    return out;
  }
  function updateLineHeight(line, height) {
    var diff = height - line.height;
    for (var n = line; n; n = n.parent)
      n.height += diff;
  }
  function lineNo(line) {
    if (line.parent == null)
      return null;
    var cur = line.parent, no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur)
          break;
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first;
  }
  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer:
      do {
        for (var i = 0, e = chunk.children.length; i < e; ++i) {
          var child = chunk.children[i], ch = child.height;
          if (h < ch) {
            chunk = child;
            continue outer;
          }
          h -= ch;
          n += child.chunkSize();
        }
        return n;
      } while (!chunk.lines);
    for (var i = 0, e = chunk.lines.length; i < e; ++i) {
      var line = chunk.lines[i], lh = line.height;
      if (h < lh)
        break;
      h -= lh;
    }
    return n + i;
  }
  function heightAtLine(cm, lineObj) {
    lineObj = visualLine(cm.doc, lineObj);
    var h = 0, chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj)
        break;
      else
        h += line.height;
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i = 0; i < p.children.length; ++i) {
        var cur = p.children[i];
        if (cur == chunk)
          break;
        else
          h += cur.height;
      }
    }
    return h;
  }
  function getOrder(line) {
    var order = line.order;
    if (order == null)
      order = line.order = bidiOrdering(line.text);
    return order;
  }
  function makeHistory() {
    return {
      done: [],
      undone: [],
      undoDepth: Infinity,
      lastTime: 0,
      lastOp: null,
      lastOrigin: null,
      dirtyCounter: 0
    };
  }
  function attachLocalSpans(doc, change, from, to) {
    var existing = change['spans_' + doc.id], n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
      if (line.markedSpans)
        (existing || (existing = change['spans_' + doc.id] = {}))[n] = line.markedSpans;
      ++n;
    });
  }
  function historyChangeFromChange(doc, change) {
    var histChange = {
        from: change.from,
        to: changeEnd(change),
        text: getBetween(doc, change.from, change.to)
      };
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function (doc) {
      attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    }, true);
    return histChange;
  }
  function addToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date(), cur = lst(hist.done);
    if (cur && (hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == '+' && doc.cm && hist.lastTime > time - doc.cm.options.historyEventDelay || change.origin.charAt(0) == '*'))) {
      var last = lst(cur.changes);
      if (posEq(change.from, change.to) && posEq(change.from, last.to)) {
        last.to = changeEnd(change);
      } else {
        cur.changes.push(historyChangeFromChange(doc, change));
      }
      cur.anchorAfter = selAfter.anchor;
      cur.headAfter = selAfter.head;
    } else {
      cur = {
        changes: [historyChangeFromChange(doc, change)],
        anchorBefore: doc.sel.anchor,
        headBefore: doc.sel.head,
        anchorAfter: selAfter.anchor,
        headAfter: selAfter.head
      };
      hist.done.push(cur);
      while (hist.done.length > hist.undoDepth)
        hist.done.shift();
      if (hist.dirtyCounter < 0)
        hist.dirtyCounter = NaN;
      else
        hist.dirtyCounter++;
    }
    hist.lastTime = time;
    hist.lastOp = opId;
    hist.lastOrigin = change.origin;
  }
  function removeClearedSpans(spans) {
    if (!spans)
      return null;
    for (var i = 0, out; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) {
        if (!out)
          out = spans.slice(0, i);
      } else if (out)
        out.push(spans[i]);
    }
    return !out ? spans : out.length ? out : null;
  }
  function getOldSpans(doc, change) {
    var found = change['spans_' + doc.id];
    if (!found)
      return null;
    for (var i = 0, nw = []; i < change.text.length; ++i)
      nw.push(removeClearedSpans(found[i]));
    return nw;
  }
  function copyHistoryArray(events, newGroup) {
    for (var i = 0, copy = []; i < events.length; ++i) {
      var event = events[i], changes = event.changes, newChanges = [];
      copy.push({
        changes: newChanges,
        anchorBefore: event.anchorBefore,
        headBefore: event.headBefore,
        anchorAfter: event.anchorAfter,
        headAfter: event.headAfter
      });
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j], m;
        newChanges.push({
          from: change.from,
          to: change.to,
          text: change.text
        });
        if (newGroup)
          for (var prop in change)
            if (m = prop.match(/^spans_(\d+)$/)) {
              if (indexOf(newGroup, Number(m[1])) > -1) {
                lst(newChanges)[prop] = change[prop];
                delete change[prop];
              }
            }
      }
    }
    return copy;
  }
  function rebaseHistSel(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i], ok = true;
      for (var j = 0; j < sub.changes.length; ++j) {
        var cur = sub.changes[j];
        if (!sub.copied) {
          cur.from = copyPos(cur.from);
          cur.to = copyPos(cur.to);
        }
        if (to < cur.from.line) {
          cur.from.line += diff;
          cur.to.line += diff;
        } else if (from <= cur.to.line) {
          ok = false;
          break;
        }
      }
      if (!sub.copied) {
        sub.anchorBefore = copyPos(sub.anchorBefore);
        sub.headBefore = copyPos(sub.headBefore);
        sub.anchorAfter = copyPos(sub.anchorAfter);
        sub.readAfter = copyPos(sub.headAfter);
        sub.copied = true;
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      } else {
        rebaseHistSel(sub.anchorBefore);
        rebaseHistSel(sub.headBefore);
        rebaseHistSel(sub.anchorAfter);
        rebaseHistSel(sub.headAfter);
      }
    }
  }
  function rebaseHist(hist, change) {
    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }
  function stopMethod() {
    e_stop(this);
  }
  function addStop(event) {
    if (!event.stop)
      event.stop = stopMethod;
    return event;
  }
  function e_preventDefault(e) {
    if (e.preventDefault)
      e.preventDefault();
    else
      e.returnValue = false;
  }
  function e_stopPropagation(e) {
    if (e.stopPropagation)
      e.stopPropagation();
    else
      e.cancelBubble = true;
  }
  function e_stop(e) {
    e_preventDefault(e);
    e_stopPropagation(e);
  }
  CodeMirror.e_stop = e_stop;
  CodeMirror.e_preventDefault = e_preventDefault;
  CodeMirror.e_stopPropagation = e_stopPropagation;
  function e_target(e) {
    return e.target || e.srcElement;
  }
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1)
        b = 1;
      else if (e.button & 2)
        b = 3;
      else if (e.button & 4)
        b = 2;
    }
    if (mac && e.ctrlKey && b == 1)
      b = 3;
    return b;
  }
  function on(emitter, type, f) {
    if (emitter.addEventListener)
      emitter.addEventListener(type, f, false);
    else if (emitter.attachEvent)
      emitter.attachEvent('on' + type, f);
    else {
      var map = emitter._handlers || (emitter._handlers = {});
      var arr = map[type] || (map[type] = []);
      arr.push(f);
    }
  }
  function off(emitter, type, f) {
    if (emitter.removeEventListener)
      emitter.removeEventListener(type, f, false);
    else if (emitter.detachEvent)
      emitter.detachEvent('on' + type, f);
    else {
      var arr = emitter._handlers && emitter._handlers[type];
      if (!arr)
        return;
      for (var i = 0; i < arr.length; ++i)
        if (arr[i] == f) {
          arr.splice(i, 1);
          break;
        }
    }
  }
  function signal(emitter, type) {
    var arr = emitter._handlers && emitter._handlers[type];
    if (!arr)
      return;
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i = 0; i < arr.length; ++i)
      arr[i].apply(null, args);
  }
  var delayedCallbacks, delayedCallbackDepth = 0;
  function signalLater(emitter, type) {
    var arr = emitter._handlers && emitter._handlers[type];
    if (!arr)
      return;
    var args = Array.prototype.slice.call(arguments, 2);
    if (!delayedCallbacks) {
      ++delayedCallbackDepth;
      delayedCallbacks = [];
      setTimeout(fireDelayed, 0);
    }
    function bnd(f) {
      return function () {
        f.apply(null, args);
      };
    }
    ;
    for (var i = 0; i < arr.length; ++i)
      delayedCallbacks.push(bnd(arr[i]));
  }
  function fireDelayed() {
    --delayedCallbackDepth;
    var delayed = delayedCallbacks;
    delayedCallbacks = null;
    for (var i = 0; i < delayed.length; ++i)
      delayed[i]();
  }
  function hasHandler(emitter, type) {
    var arr = emitter._handlers && emitter._handlers[type];
    return arr && arr.length > 0;
  }
  CodeMirror.on = on;
  CodeMirror.off = off;
  CodeMirror.signal = signal;
  var scrollerCutOff = 30;
  var Pass = CodeMirror.Pass = {
      toString: function () {
        return 'CodeMirror.Pass';
      }
    };
  function Delayed() {
    this.id = null;
  }
  Delayed.prototype = {
    set: function (ms, f) {
      clearTimeout(this.id);
      this.id = setTimeout(f, ms);
    }
  };
  function countColumn(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);
      if (end == -1)
        end = string.length;
    }
    for (var i = startIndex || 0, n = startValue || 0; i < end; ++i) {
      if (string.charAt(i) == '\t')
        n += tabSize - n % tabSize;
      else
        ++n;
    }
    return n;
  }
  CodeMirror.countColumn = countColumn;
  var spaceStrs = [''];
  function spaceStr(n) {
    while (spaceStrs.length <= n)
      spaceStrs.push(lst(spaceStrs) + ' ');
    return spaceStrs[n];
  }
  function lst(arr) {
    return arr[arr.length - 1];
  }
  function selectInput(node) {
    if (ios) {
      node.selectionStart = 0;
      node.selectionEnd = node.value.length;
    } else
      node.select();
  }
  function indexOf(collection, elt) {
    if (collection.indexOf)
      return collection.indexOf(elt);
    for (var i = 0, e = collection.length; i < e; ++i)
      if (collection[i] == elt)
        return i;
    return -1;
  }
  function createObj(base, props) {
    function Obj() {
    }
    Obj.prototype = base;
    var inst = new Obj();
    if (props)
      copyObj(props, inst);
    return inst;
  }
  function copyObj(obj, target) {
    if (!target)
      target = {};
    for (var prop in obj)
      if (obj.hasOwnProperty(prop))
        target[prop] = obj[prop];
    return target;
  }
  function emptyArray(size) {
    for (var a = [], i = 0; i < size; ++i)
      a.push(undefined);
    return a;
  }
  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function () {
      return f.apply(null, args);
    };
  }
  var nonASCIISingleCaseWordChar = /[\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc]/;
  function isWordChar(ch) {
    return /\w/.test(ch) || ch > '\x80' && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
  }
  function isEmpty(obj) {
    for (var n in obj)
      if (obj.hasOwnProperty(n) && obj[n])
        return false;
    return true;
  }
  var isExtendingChar = /[\u0300-\u036F\u0483-\u0487\u0488-\u0489\u0591-\u05BD\u05BF\u05C1-\u05C2\u05C4-\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7-\u06E8\u06EA-\u06ED\uA66F\uA670-\uA672\uA674-\uA67D\uA69F\udc00-\udfff]/;
  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className)
      e.className = className;
    if (style)
      e.style.cssText = style;
    if (typeof content == 'string')
      setTextContent(e, content);
    else if (content)
      for (var i = 0; i < content.length; ++i)
        e.appendChild(content[i]);
    return e;
  }
  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count)
      e.removeChild(e.firstChild);
    return e;
  }
  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e);
  }
  function setTextContent(e, str) {
    if (ie_lt9) {
      e.innerHTML = '';
      e.appendChild(document.createTextNode(str));
    } else
      e.textContent = str;
  }
  function getRect(node) {
    return node.getBoundingClientRect();
  }
  CodeMirror.replaceGetRect = function (f) {
    getRect = f;
  };
  var dragAndDrop = function () {
      if (ie_lt9)
        return false;
      var div = elt('div');
      return 'draggable' in div || 'dragDrop' in div;
    }();
  var spanAffectsWrapping = /^$/;
  if (gecko)
    spanAffectsWrapping = /$'/;
  else if (safari && !/Version\/([6-9]|\d\d)\b/.test(navigator.userAgent))
    spanAffectsWrapping = /\-[^ \-?]|\?[^ !'\"\),.\-\/:;\?\]\}]/;
  else if (webkit)
    spanAffectsWrapping = /[~!#%&*)=+}\]|\"\.>,:;][({[<]|-[^\-?\.]|\?[\w~`@#$%\^&*(_=+{[|><]/;
  var knownScrollbarWidth;
  function scrollbarWidth(measure) {
    if (knownScrollbarWidth != null)
      return knownScrollbarWidth;
    var test = elt('div', null, null, 'width: 50px; height: 50px; overflow-x: scroll');
    removeChildrenAndAdd(measure, test);
    if (test.offsetWidth)
      knownScrollbarWidth = test.offsetHeight - test.clientHeight;
    return knownScrollbarWidth || 0;
  }
  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt('span', '\u200b');
      removeChildrenAndAdd(measure, elt('span', [
        test,
        document.createTextNode('x')
      ]));
      if (measure.firstChild.offsetHeight != 0)
        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !ie_lt8;
    }
    if (zwspSupported)
      return elt('span', '\u200b');
    else
      return elt('span', '\xa0', null, 'display: inline-block; width: 1px; margin-right: -1px');
  }
  var splitLines = '\n\nb'.split(/\n/).length != 3 ? function (string) {
      var pos = 0, result = [], l = string.length;
      while (pos <= l) {
        var nl = string.indexOf('\n', pos);
        if (nl == -1)
          nl = string.length;
        var line = string.slice(pos, string.charAt(nl - 1) == '\r' ? nl - 1 : nl);
        var rt = line.indexOf('\r');
        if (rt != -1) {
          result.push(line.slice(0, rt));
          pos += rt + 1;
        } else {
          result.push(line);
          pos = nl + 1;
        }
      }
      return result;
    } : function (string) {
      return string.split(/\r\n?|\n/);
    };
  CodeMirror.splitLines = splitLines;
  var hasSelection = window.getSelection ? function (te) {
      try {
        return te.selectionStart != te.selectionEnd;
      } catch (e) {
        return false;
      }
    } : function (te) {
      try {
        var range = te.ownerDocument.selection.createRange();
      } catch (e) {
      }
      if (!range || range.parentElement() != te)
        return false;
      return range.compareEndPoints('StartToEnd', range) != 0;
    };
  var hasCopyEvent = function () {
      var e = elt('div');
      if ('oncopy' in e)
        return true;
      e.setAttribute('oncopy', 'return;');
      return typeof e.oncopy == 'function';
    }();
  var keyNames = {
      3: 'Enter',
      8: 'Backspace',
      9: 'Tab',
      13: 'Enter',
      16: 'Shift',
      17: 'Ctrl',
      18: 'Alt',
      19: 'Pause',
      20: 'CapsLock',
      27: 'Esc',
      32: 'Space',
      33: 'PageUp',
      34: 'PageDown',
      35: 'End',
      36: 'Home',
      37: 'Left',
      38: 'Up',
      39: 'Right',
      40: 'Down',
      44: 'PrintScrn',
      45: 'Insert',
      46: 'Delete',
      59: ';',
      91: 'Mod',
      92: 'Mod',
      93: 'Mod',
      109: '-',
      107: '=',
      127: 'Delete',
      186: ';',
      187: '=',
      188: ',',
      189: '-',
      190: '.',
      191: '/',
      192: '`',
      219: '[',
      220: '\\',
      221: ']',
      222: '\'',
      63276: 'PageUp',
      63277: 'PageDown',
      63275: 'End',
      63273: 'Home',
      63234: 'Left',
      63232: 'Up',
      63235: 'Right',
      63233: 'Down',
      63302: 'Insert',
      63272: 'Delete'
    };
  CodeMirror.keyNames = keyNames;
  (function () {
    for (var i = 0; i < 10; i++)
      keyNames[i + 48] = String(i);
    for (var i = 65; i <= 90; i++)
      keyNames[i] = String.fromCharCode(i);
    for (var i = 1; i <= 12; i++)
      keyNames[i + 111] = keyNames[i + 63235] = 'F' + i;
  }());
  function iterateBidiSections(order, from, to, f) {
    if (!order)
      return f(from, to, 'ltr');
    for (var i = 0; i < order.length; ++i) {
      var part = order[i];
      if (part.from < to && part.to > from || from == to && part.to == from)
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? 'rtl' : 'ltr');
    }
  }
  function bidiLeft(part) {
    return part.level % 2 ? part.to : part.from;
  }
  function bidiRight(part) {
    return part.level % 2 ? part.from : part.to;
  }
  function lineLeft(line) {
    var order = getOrder(line);
    return order ? bidiLeft(order[0]) : 0;
  }
  function lineRight(line) {
    var order = getOrder(line);
    if (!order)
      return line.text.length;
    return bidiRight(lst(order));
  }
  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(cm.doc, line);
    if (visual != line)
      lineN = lineNo(visual);
    var order = getOrder(visual);
    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);
    return Pos(lineN, ch);
  }
  function lineEnd(cm, lineN) {
    var merged, line;
    while (merged = collapsedSpanAtEnd(line = getLine(cm.doc, lineN)))
      lineN = merged.find().to.line;
    var order = getOrder(line);
    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);
    return Pos(lineN, ch);
  }
  function moveVisually(line, start, dir, byUnit) {
    var bidi = getOrder(line);
    if (!bidi)
      return moveLogically(line, start, dir, byUnit);
    var moveOneUnit = byUnit ? function (pos, dir) {
        do
          pos += dir;
        while (pos > 0 && isExtendingChar.test(line.text.charAt(pos)));
        return pos;
      } : function (pos, dir) {
        return pos + dir;
      };
    var linedir = bidi[0].level;
    for (var i = 0; i < bidi.length; ++i) {
      var part = bidi[i], sticky = part.level % 2 == linedir;
      if (part.from < start && part.to > start || sticky && (part.from == start || part.to == start))
        break;
    }
    var target = moveOneUnit(start, part.level % 2 ? -dir : dir);
    while (target != null) {
      if (part.level % 2 == linedir) {
        if (target < part.from || target > part.to) {
          part = bidi[i += dir];
          target = part && (dir > 0 == part.level % 2 ? moveOneUnit(part.to, -1) : moveOneUnit(part.from, 1));
        } else
          break;
      } else {
        if (target == bidiLeft(part)) {
          part = bidi[--i];
          target = part && bidiRight(part);
        } else if (target == bidiRight(part)) {
          part = bidi[++i];
          target = part && bidiLeft(part);
        } else
          break;
      }
    }
    return target < 0 || target > line.text.length ? null : target;
  }
  function moveLogically(line, start, dir, byUnit) {
    var target = start + dir;
    if (byUnit)
      while (target > 0 && isExtendingChar.test(line.text.charAt(target)))
        target += dir;
    return target < 0 || target > line.text.length ? null : target;
  }
  var bidiOrdering = function () {
      var lowTypes = 'bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLL';
      var arabicTypes = 'rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmmrrrrrrrrrrrrrrrrrr';
      function charType(code) {
        if (code <= 255)
          return lowTypes.charAt(code);
        else if (1424 <= code && code <= 1524)
          return 'R';
        else if (1536 <= code && code <= 1791)
          return arabicTypes.charAt(code - 1536);
        else if (1792 <= code && code <= 2220)
          return 'r';
        else
          return 'L';
      }
      var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
      var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
      var outerType = 'L';
      return function (str) {
        if (!bidiRE.test(str))
          return false;
        var len = str.length, types = [];
        for (var i = 0, type; i < len; ++i)
          types.push(type = charType(str.charCodeAt(i)));
        for (var i = 0, prev = outerType; i < len; ++i) {
          var type = types[i];
          if (type == 'm')
            types[i] = prev;
          else
            prev = type;
        }
        for (var i = 0, cur = outerType; i < len; ++i) {
          var type = types[i];
          if (type == '1' && cur == 'r')
            types[i] = 'n';
          else if (isStrong.test(type)) {
            cur = type;
            if (type == 'r')
              types[i] = 'R';
          }
        }
        for (var i = 1, prev = types[0]; i < len - 1; ++i) {
          var type = types[i];
          if (type == '+' && prev == '1' && types[i + 1] == '1')
            types[i] = '1';
          else if (type == ',' && prev == types[i + 1] && (prev == '1' || prev == 'n'))
            types[i] = prev;
          prev = type;
        }
        for (var i = 0; i < len; ++i) {
          var type = types[i];
          if (type == ',')
            types[i] = 'N';
          else if (type == '%') {
            for (var end = i + 1; end < len && types[end] == '%'; ++end) {
            }
            var replace = i && types[i - 1] == '!' || end < len - 1 && types[end] == '1' ? '1' : 'N';
            for (var j = i; j < end; ++j)
              types[j] = replace;
            i = end - 1;
          }
        }
        for (var i = 0, cur = outerType; i < len; ++i) {
          var type = types[i];
          if (cur == 'L' && type == '1')
            types[i] = 'L';
          else if (isStrong.test(type))
            cur = type;
        }
        for (var i = 0; i < len; ++i) {
          if (isNeutral.test(types[i])) {
            for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {
            }
            var before = (i ? types[i - 1] : outerType) == 'L';
            var after = (end < len - 1 ? types[end] : outerType) == 'L';
            var replace = before || after ? 'L' : 'R';
            for (var j = i; j < end; ++j)
              types[j] = replace;
            i = end - 1;
          }
        }
        var order = [], m;
        for (var i = 0; i < len;) {
          if (countsAsLeft.test(types[i])) {
            var start = i;
            for (++i; i < len && countsAsLeft.test(types[i]); ++i) {
            }
            order.push({
              from: start,
              to: i,
              level: 0
            });
          } else {
            var pos = i, at = order.length;
            for (++i; i < len && types[i] != 'L'; ++i) {
            }
            for (var j = pos; j < i;) {
              if (countsAsNum.test(types[j])) {
                if (pos < j)
                  order.splice(at, 0, {
                    from: pos,
                    to: j,
                    level: 1
                  });
                var nstart = j;
                for (++j; j < i && countsAsNum.test(types[j]); ++j) {
                }
                order.splice(at, 0, {
                  from: nstart,
                  to: j,
                  level: 2
                });
                pos = j;
              } else
                ++j;
            }
            if (pos < i)
              order.splice(at, 0, {
                from: pos,
                to: i,
                level: 1
              });
          }
        }
        if (order[0].level == 1 && (m = str.match(/^\s+/))) {
          order[0].from = m[0].length;
          order.unshift({
            from: 0,
            to: m[0].length,
            level: 0
          });
        }
        if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
          lst(order).to -= m[0].length;
          order.push({
            from: len - m[0].length,
            to: len,
            level: 0
          });
        }
        if (order[0].level != lst(order).level)
          order.push({
            from: len,
            to: len,
            level: order[0].level
          });
        return order;
      };
    }();
  CodeMirror.version = '3.11 +';
  return CodeMirror;
}();
CodeMirror.defineMode('python', function (conf, parserConf) {
  var ERRORCLASS = 'error';
  function wordRegexp(words) {
    return new RegExp('^((' + words.join(')|(') + '))\\b');
  }
  var singleOperators = parserConf.singleOperators || new RegExp('^[\\+\\-\\*/%&|\\^~<>!]');
  var singleDelimiters = parserConf.singleDelimiters || new RegExp('^[\\(\\)\\[\\]\\{\\}@,:`=;\\.]');
  var doubleOperators = parserConf.doubleOperators || new RegExp('^((==)|(!=)|(<=)|(>=)|(<>)|(<<)|(>>)|(//)|(\\*\\*))');
  var doubleDelimiters = parserConf.doubleDelimiters || new RegExp('^((\\+=)|(\\-=)|(\\*=)|(%=)|(/=)|(&=)|(\\|=)|(\\^=))');
  var tripleDelimiters = parserConf.tripleDelimiters || new RegExp('^((//=)|(>>=)|(<<=)|(\\*\\*=))');
  var identifiers = parserConf.identifiers || new RegExp('^[_A-Za-z][_A-Za-z0-9]*');
  var wordOperators = wordRegexp([
      'and',
      'or',
      'not',
      'is',
      'in'
    ]);
  var commonkeywords = [
      'as',
      'assert',
      'break',
      'class',
      'continue',
      'def',
      'del',
      'elif',
      'else',
      'except',
      'finally',
      'for',
      'from',
      'global',
      'if',
      'import',
      'lambda',
      'pass',
      'raise',
      'return',
      'try',
      'while',
      'with',
      'yield'
    ];
  var commonBuiltins = [
      'abs',
      'all',
      'any',
      'bin',
      'bool',
      'bytearray',
      'callable',
      'chr',
      'classmethod',
      'compile',
      'complex',
      'delattr',
      'dict',
      'dir',
      'divmod',
      'enumerate',
      'eval',
      'filter',
      'float',
      'format',
      'frozenset',
      'getattr',
      'globals',
      'hasattr',
      'hash',
      'help',
      'hex',
      'id',
      'input',
      'int',
      'isinstance',
      'issubclass',
      'iter',
      'len',
      'list',
      'locals',
      'map',
      'max',
      'memoryview',
      'min',
      'next',
      'object',
      'oct',
      'open',
      'ord',
      'pow',
      'property',
      'range',
      'repr',
      'reversed',
      'round',
      'set',
      'setattr',
      'slice',
      'sorted',
      'staticmethod',
      'str',
      'sum',
      'super',
      'tuple',
      'type',
      'vars',
      'zip',
      '__import__',
      'NotImplemented',
      'Ellipsis',
      '__debug__'
    ];
  var py2 = {
      'builtins': [
        'apply',
        'basestring',
        'buffer',
        'cmp',
        'coerce',
        'execfile',
        'file',
        'intern',
        'long',
        'raw_input',
        'reduce',
        'reload',
        'unichr',
        'unicode',
        'xrange',
        'False',
        'True',
        'None'
      ],
      'keywords': [
        'exec',
        'print'
      ]
    };
  var py3 = {
      'builtins': [
        'ascii',
        'bytes',
        'exec',
        'print'
      ],
      'keywords': [
        'nonlocal',
        'False',
        'True',
        'None'
      ]
    };
  if (!!parserConf.version && parseInt(parserConf.version, 10) === 3) {
    commonkeywords = commonkeywords.concat(py3.keywords);
    commonBuiltins = commonBuiltins.concat(py3.builtins);
    var stringPrefixes = new RegExp('^(([rb]|(br))?(\'{3}|"{3}|[\'"]))', 'i');
  } else {
    commonkeywords = commonkeywords.concat(py2.keywords);
    commonBuiltins = commonBuiltins.concat(py2.builtins);
    var stringPrefixes = new RegExp('^(([rub]|(ur)|(br))?(\'{3}|"{3}|[\'"]))', 'i');
  }
  var keywords = wordRegexp(commonkeywords);
  var builtins = wordRegexp(commonBuiltins);
  var indentInfo = null;
  function tokenBase(stream, state) {
    if (stream.sol()) {
      var scopeOffset = state.scopes[0].offset;
      if (stream.eatSpace()) {
        var lineOffset = stream.indentation();
        if (lineOffset > scopeOffset) {
          indentInfo = 'indent';
        } else if (lineOffset < scopeOffset) {
          indentInfo = 'dedent';
        }
        return null;
      } else {
        if (scopeOffset > 0) {
          dedent(stream, state);
        }
      }
    }
    if (stream.eatSpace()) {
      return null;
    }
    var ch = stream.peek();
    if (ch === '#') {
      stream.skipToEnd();
      return 'comment';
    }
    if (stream.match(/^[0-9\.]/, false)) {
      var floatLiteral = false;
      if (stream.match(/^\d*\.\d+(e[\+\-]?\d+)?/i)) {
        floatLiteral = true;
      }
      if (stream.match(/^\d+\.\d*/)) {
        floatLiteral = true;
      }
      if (stream.match(/^\.\d+/)) {
        floatLiteral = true;
      }
      if (floatLiteral) {
        stream.eat(/J/i);
        return 'number';
      }
      var intLiteral = false;
      if (stream.match(/^0x[0-9a-f]+/i)) {
        intLiteral = true;
      }
      if (stream.match(/^0b[01]+/i)) {
        intLiteral = true;
      }
      if (stream.match(/^0o[0-7]+/i)) {
        intLiteral = true;
      }
      if (stream.match(/^[1-9]\d*(e[\+\-]?\d+)?/)) {
        stream.eat(/J/i);
        intLiteral = true;
      }
      if (stream.match(/^0(?![\dx])/i)) {
        intLiteral = true;
      }
      if (intLiteral) {
        stream.eat(/L/i);
        return 'number';
      }
    }
    if (stream.match(stringPrefixes)) {
      state.tokenize = tokenStringFactory(stream.current());
      return state.tokenize(stream, state);
    }
    if (stream.match(tripleDelimiters) || stream.match(doubleDelimiters)) {
      return null;
    }
    if (stream.match(doubleOperators) || stream.match(singleOperators) || stream.match(wordOperators)) {
      return 'operator';
    }
    if (stream.match(singleDelimiters)) {
      return null;
    }
    if (stream.match(keywords)) {
      return 'keyword';
    }
    if (stream.match(builtins)) {
      return 'builtin';
    }
    if (stream.match(identifiers)) {
      return 'variable';
    }
    stream.next();
    return ERRORCLASS;
  }
  function tokenStringFactory(delimiter) {
    while ('rub'.indexOf(delimiter.charAt(0).toLowerCase()) >= 0) {
      delimiter = delimiter.substr(1);
    }
    var singleline = delimiter.length == 1;
    var OUTCLASS = 'string';
    function tokenString(stream, state) {
      while (!stream.eol()) {
        stream.eatWhile(/[^'"\\]/);
        if (stream.eat('\\')) {
          stream.next();
          if (singleline && stream.eol()) {
            return OUTCLASS;
          }
        } else if (stream.match(delimiter)) {
          state.tokenize = tokenBase;
          return OUTCLASS;
        } else {
          stream.eat(/['"]/);
        }
      }
      if (singleline) {
        if (parserConf.singleLineStringErrors) {
          return ERRORCLASS;
        } else {
          state.tokenize = tokenBase;
        }
      }
      return OUTCLASS;
    }
    tokenString.isString = true;
    return tokenString;
  }
  function indent(stream, state, type) {
    type = type || 'py';
    var indentUnit = 0;
    if (type === 'py') {
      if (state.scopes[0].type !== 'py') {
        state.scopes[0].offset = stream.indentation();
        return;
      }
      for (var i = 0; i < state.scopes.length; ++i) {
        if (state.scopes[i].type === 'py') {
          indentUnit = state.scopes[i].offset + conf.indentUnit;
          break;
        }
      }
    } else {
      indentUnit = stream.column() + stream.current().length;
    }
    state.scopes.unshift({
      offset: indentUnit,
      type: type
    });
  }
  function dedent(stream, state, type) {
    type = type || 'py';
    if (state.scopes.length == 1)
      return;
    if (state.scopes[0].type === 'py') {
      var _indent = stream.indentation();
      var _indent_index = -1;
      for (var i = 0; i < state.scopes.length; ++i) {
        if (_indent === state.scopes[i].offset) {
          _indent_index = i;
          break;
        }
      }
      if (_indent_index === -1) {
        return true;
      }
      while (state.scopes[0].offset !== _indent) {
        state.scopes.shift();
      }
      return false;
    } else {
      if (type === 'py') {
        state.scopes[0].offset = stream.indentation();
        return false;
      } else {
        if (state.scopes[0].type != type) {
          return true;
        }
        state.scopes.shift();
        return false;
      }
    }
  }
  function tokenLexer(stream, state) {
    indentInfo = null;
    var style = state.tokenize(stream, state);
    var current = stream.current();
    if (current === '.') {
      style = stream.match(identifiers, false) ? null : ERRORCLASS;
      if (style === null && state.lastToken === 'meta') {
        style = 'meta';
      }
      return style;
    }
    if (current === '@') {
      return stream.match(identifiers, false) ? 'meta' : ERRORCLASS;
    }
    if ((style === 'variable' || style === 'builtin') && state.lastToken === 'meta') {
      style = 'meta';
    }
    if (current === 'pass' || current === 'return') {
      state.dedent += 1;
    }
    if (current === 'lambda')
      state.lambda = true;
    if (current === ':' && !state.lambda && state.scopes[0].type == 'py' || indentInfo === 'indent') {
      indent(stream, state);
    }
    var delimiter_index = '[({'.indexOf(current);
    if (delimiter_index !== -1) {
      indent(stream, state, '])}'.slice(delimiter_index, delimiter_index + 1));
    }
    if (indentInfo === 'dedent') {
      if (dedent(stream, state)) {
        return ERRORCLASS;
      }
    }
    delimiter_index = '])}'.indexOf(current);
    if (delimiter_index !== -1) {
      if (dedent(stream, state, current)) {
        return ERRORCLASS;
      }
    }
    if (state.dedent > 0 && stream.eol() && state.scopes[0].type == 'py') {
      if (state.scopes.length > 1)
        state.scopes.shift();
      state.dedent -= 1;
    }
    return style;
  }
  var external = {
      startState: function (basecolumn) {
        return {
          tokenize: tokenBase,
          scopes: [{
              offset: basecolumn || 0,
              type: 'py'
            }],
          lastToken: null,
          lambda: false,
          dedent: 0
        };
      },
      token: function (stream, state) {
        var style = tokenLexer(stream, state);
        state.lastToken = style;
        if (stream.eol() && stream.lambda) {
          state.lambda = false;
        }
        return style;
      },
      indent: function (state) {
        if (state.tokenize != tokenBase) {
          return state.tokenize.isString ? CodeMirror.Pass : 0;
        }
        return state.scopes[0].offset;
      }
    };
  return external;
});
CodeMirror.defineMIME('text/x-python', 'python');
!function () {
  function n(n, t) {
    return t > n ? -1 : n > t ? 1 : n >= t ? 0 : 0 / 0;
  }
  function t(n) {
    return null != n && !isNaN(n);
  }
  function e(n) {
    return {
      left: function (t, e, r, u) {
        for (arguments.length < 3 && (r = 0), arguments.length < 4 && (u = t.length); u > r;) {
          var i = r + u >>> 1;
          n(t[i], e) < 0 ? r = i + 1 : u = i;
        }
        return r;
      },
      right: function (t, e, r, u) {
        for (arguments.length < 3 && (r = 0), arguments.length < 4 && (u = t.length); u > r;) {
          var i = r + u >>> 1;
          n(t[i], e) > 0 ? u = i : r = i + 1;
        }
        return r;
      }
    };
  }
  function r(n) {
    return n.length;
  }
  function u(n) {
    for (var t = 1; n * t % 1;)
      t *= 10;
    return t;
  }
  function i(n, t) {
    try {
      for (var e in t)
        Object.defineProperty(n.prototype, e, {
          value: t[e],
          enumerable: !1
        });
    } catch (r) {
      n.prototype = t;
    }
  }
  function o() {
  }
  function a(n) {
    return ha + n in this;
  }
  function c(n) {
    return n = ha + n, n in this && delete this[n];
  }
  function s() {
    var n = [];
    return this.forEach(function (t) {
      n.push(t);
    }), n;
  }
  function l() {
    var n = 0;
    for (var t in this)
      t.charCodeAt(0) === ga && ++n;
    return n;
  }
  function f() {
    for (var n in this)
      if (n.charCodeAt(0) === ga)
        return !1;
    return !0;
  }
  function h() {
  }
  function g(n, t, e) {
    return function () {
      var r = e.apply(t, arguments);
      return r === t ? n : r;
    };
  }
  function p(n, t) {
    if (t in n)
      return t;
    t = t.charAt(0).toUpperCase() + t.substring(1);
    for (var e = 0, r = pa.length; r > e; ++e) {
      var u = pa[e] + t;
      if (u in n)
        return u;
    }
  }
  function v() {
  }
  function d() {
  }
  function m(n) {
    function t() {
      for (var t, r = e, u = -1, i = r.length; ++u < i;)
        (t = r[u].on) && t.apply(this, arguments);
      return n;
    }
    var e = [], r = new o();
    return t.on = function (t, u) {
      var i, o = r.get(t);
      return arguments.length < 2 ? o && o.on : (o && (o.on = null, e = e.slice(0, i = e.indexOf(o)).concat(e.slice(i + 1)), r.remove(t)), u && e.push(r.set(t, { on: u })), n);
    }, t;
  }
  function y() {
    Go.event.preventDefault();
  }
  function x() {
    for (var n, t = Go.event; n = t.sourceEvent;)
      t = n;
    return t;
  }
  function M(n) {
    for (var t = new d(), e = 0, r = arguments.length; ++e < r;)
      t[arguments[e]] = m(t);
    return t.of = function (e, r) {
      return function (u) {
        try {
          var i = u.sourceEvent = Go.event;
          u.target = n, Go.event = u, t[u.type].apply(e, r);
        } finally {
          Go.event = i;
        }
      };
    }, t;
  }
  function _(n) {
    return da(n, _a), n;
  }
  function b(n) {
    return 'function' == typeof n ? n : function () {
      return ma(n, this);
    };
  }
  function w(n) {
    return 'function' == typeof n ? n : function () {
      return ya(n, this);
    };
  }
  function S(n, t) {
    function e() {
      this.removeAttribute(n);
    }
    function r() {
      this.removeAttributeNS(n.space, n.local);
    }
    function u() {
      this.setAttribute(n, t);
    }
    function i() {
      this.setAttributeNS(n.space, n.local, t);
    }
    function o() {
      var e = t.apply(this, arguments);
      null == e ? this.removeAttribute(n) : this.setAttribute(n, e);
    }
    function a() {
      var e = t.apply(this, arguments);
      null == e ? this.removeAttributeNS(n.space, n.local) : this.setAttributeNS(n.space, n.local, e);
    }
    return n = Go.ns.qualify(n), null == t ? n.local ? r : e : 'function' == typeof t ? n.local ? a : o : n.local ? i : u;
  }
  function k(n) {
    return n.trim().replace(/\s+/g, ' ');
  }
  function E(n) {
    return new RegExp('(?:^|\\s+)' + Go.requote(n) + '(?:\\s+|$)', 'g');
  }
  function A(n) {
    return n.trim().split(/^|\s+/);
  }
  function C(n, t) {
    function e() {
      for (var e = -1; ++e < u;)
        n[e](this, t);
    }
    function r() {
      for (var e = -1, r = t.apply(this, arguments); ++e < u;)
        n[e](this, r);
    }
    n = A(n).map(N);
    var u = n.length;
    return 'function' == typeof t ? r : e;
  }
  function N(n) {
    var t = E(n);
    return function (e, r) {
      if (u = e.classList)
        return r ? u.add(n) : u.remove(n);
      var u = e.getAttribute('class') || '';
      r ? (t.lastIndex = 0, t.test(u) || e.setAttribute('class', k(u + ' ' + n))) : e.setAttribute('class', k(u.replace(t, ' ')));
    };
  }
  function L(n, t, e) {
    function r() {
      this.style.removeProperty(n);
    }
    function u() {
      this.style.setProperty(n, t, e);
    }
    function i() {
      var r = t.apply(this, arguments);
      null == r ? this.style.removeProperty(n) : this.style.setProperty(n, r, e);
    }
    return null == t ? r : 'function' == typeof t ? i : u;
  }
  function T(n, t) {
    function e() {
      delete this[n];
    }
    function r() {
      this[n] = t;
    }
    function u() {
      var e = t.apply(this, arguments);
      null == e ? delete this[n] : this[n] = e;
    }
    return null == t ? e : 'function' == typeof t ? u : r;
  }
  function q(n) {
    return 'function' == typeof n ? n : (n = Go.ns.qualify(n)).local ? function () {
      return this.ownerDocument.createElementNS(n.space, n.local);
    } : function () {
      return this.ownerDocument.createElementNS(this.namespaceURI, n);
    };
  }
  function z(n) {
    return { __data__: n };
  }
  function R(n) {
    return function () {
      return Ma(this, n);
    };
  }
  function D(t) {
    return arguments.length || (t = n), function (n, e) {
      return n && e ? t(n.__data__, e.__data__) : !n - !e;
    };
  }
  function P(n, t) {
    for (var e = 0, r = n.length; r > e; e++)
      for (var u, i = n[e], o = 0, a = i.length; a > o; o++)
        (u = i[o]) && t(u, o, e);
    return n;
  }
  function U(n) {
    return da(n, wa), n;
  }
  function j(n) {
    var t, e;
    return function (r, u, i) {
      var o, a = n[i].update, c = a.length;
      for (i != e && (e = i, t = 0), u >= t && (t = u + 1); !(o = a[t]) && ++t < c;);
      return o;
    };
  }
  function H() {
    var n = this.__transition__;
    n && ++n.active;
  }
  function F(n, t, e) {
    function r() {
      var t = this[o];
      t && (this.removeEventListener(n, t, t.$), delete this[o]);
    }
    function u() {
      var u = c(t, Qo(arguments));
      r.call(this), this.addEventListener(n, this[o] = u, u.$ = e), u._ = t;
    }
    function i() {
      var t, e = new RegExp('^__on([^.]+)' + Go.requote(n) + '$');
      for (var r in this)
        if (t = r.match(e)) {
          var u = this[r];
          this.removeEventListener(t[1], u, u.$), delete this[r];
        }
    }
    var o = '__on' + n, a = n.indexOf('.'), c = O;
    a > 0 && (n = n.substring(0, a));
    var s = ka.get(n);
    return s && (n = s, c = I), a ? t ? u : r : t ? v : i;
  }
  function O(n, t) {
    return function (e) {
      var r = Go.event;
      Go.event = e, t[0] = this.__data__;
      try {
        n.apply(this, t);
      } finally {
        Go.event = r;
      }
    };
  }
  function I(n, t) {
    var e = O(n, t);
    return function (n) {
      var t = this, r = n.relatedTarget;
      r && (r === t || 8 & r.compareDocumentPosition(t)) || e.call(t, n);
    };
  }
  function Y() {
    var n = '.dragsuppress-' + ++Aa, t = 'click' + n, e = Go.select(ea).on('touchmove' + n, y).on('dragstart' + n, y).on('selectstart' + n, y);
    if (Ea) {
      var r = ta.style, u = r[Ea];
      r[Ea] = 'none';
    }
    return function (i) {
      function o() {
        e.on(t, null);
      }
      e.on(n, null), Ea && (r[Ea] = u), i && (e.on(t, function () {
        y(), o();
      }, !0), setTimeout(o, 0));
    };
  }
  function Z(n, t) {
    t.changedTouches && (t = t.changedTouches[0]);
    var e = n.ownerSVGElement || n;
    if (e.createSVGPoint) {
      var r = e.createSVGPoint();
      return r.x = t.clientX, r.y = t.clientY, r = r.matrixTransform(n.getScreenCTM().inverse()), [
        r.x,
        r.y
      ];
    }
    var u = n.getBoundingClientRect();
    return [
      t.clientX - u.left - n.clientLeft,
      t.clientY - u.top - n.clientTop
    ];
  }
  function V() {
    return Go.event.changedTouches[0].identifier;
  }
  function $() {
    return Go.event.target;
  }
  function X() {
    return ea;
  }
  function B(n) {
    return n > 0 ? 1 : 0 > n ? -1 : 0;
  }
  function J(n, t, e) {
    return (t[0] - n[0]) * (e[1] - n[1]) - (t[1] - n[1]) * (e[0] - n[0]);
  }
  function W(n) {
    return n > 1 ? 0 : -1 > n ? Ca : Math.acos(n);
  }
  function G(n) {
    return n > 1 ? La : -1 > n ? -La : Math.asin(n);
  }
  function K(n) {
    return ((n = Math.exp(n)) - 1 / n) / 2;
  }
  function Q(n) {
    return ((n = Math.exp(n)) + 1 / n) / 2;
  }
  function nt(n) {
    return ((n = Math.exp(2 * n)) - 1) / (n + 1);
  }
  function tt(n) {
    return (n = Math.sin(n / 2)) * n;
  }
  function et() {
  }
  function rt(n, t, e) {
    return new ut(n, t, e);
  }
  function ut(n, t, e) {
    this.h = n, this.s = t, this.l = e;
  }
  function it(n, t, e) {
    function r(n) {
      return n > 360 ? n -= 360 : 0 > n && (n += 360), 60 > n ? i + (o - i) * n / 60 : 180 > n ? o : 240 > n ? i + (o - i) * (240 - n) / 60 : i;
    }
    function u(n) {
      return Math.round(255 * r(n));
    }
    var i, o;
    return n = isNaN(n) ? 0 : (n %= 360) < 0 ? n + 360 : n, t = isNaN(t) ? 0 : 0 > t ? 0 : t > 1 ? 1 : t, e = 0 > e ? 0 : e > 1 ? 1 : e, o = 0.5 >= e ? e * (1 + t) : e + t - e * t, i = 2 * e - o, yt(u(n + 120), u(n), u(n - 120));
  }
  function ot(n, t, e) {
    return new at(n, t, e);
  }
  function at(n, t, e) {
    this.h = n, this.c = t, this.l = e;
  }
  function ct(n, t, e) {
    return isNaN(n) && (n = 0), isNaN(t) && (t = 0), st(e, Math.cos(n *= za) * t, Math.sin(n) * t);
  }
  function st(n, t, e) {
    return new lt(n, t, e);
  }
  function lt(n, t, e) {
    this.l = n, this.a = t, this.b = e;
  }
  function ft(n, t, e) {
    var r = (n + 16) / 116, u = r + t / 500, i = r - e / 200;
    return u = gt(u) * Za, r = gt(r) * Va, i = gt(i) * $a, yt(vt(3.2404542 * u - 1.5371385 * r - 0.4985314 * i), vt(-0.969266 * u + 1.8760108 * r + 0.041556 * i), vt(0.0556434 * u - 0.2040259 * r + 1.0572252 * i));
  }
  function ht(n, t, e) {
    return n > 0 ? ot(Math.atan2(e, t) * Ra, Math.sqrt(t * t + e * e), n) : ot(0 / 0, 0 / 0, n);
  }
  function gt(n) {
    return n > 0.206893034 ? n * n * n : (n - 4 / 29) / 7.787037;
  }
  function pt(n) {
    return n > 0.008856 ? Math.pow(n, 1 / 3) : 7.787037 * n + 4 / 29;
  }
  function vt(n) {
    return Math.round(255 * (0.00304 >= n ? 12.92 * n : 1.055 * Math.pow(n, 1 / 2.4) - 0.055));
  }
  function dt(n) {
    return yt(n >> 16, 255 & n >> 8, 255 & n);
  }
  function mt(n) {
    return dt(n) + '';
  }
  function yt(n, t, e) {
    return new xt(n, t, e);
  }
  function xt(n, t, e) {
    this.r = n, this.g = t, this.b = e;
  }
  function Mt(n) {
    return 16 > n ? '0' + Math.max(0, n).toString(16) : Math.min(255, n).toString(16);
  }
  function _t(n, t, e) {
    var r, u, i, o = 0, a = 0, c = 0;
    if (r = /([a-z]+)\((.*)\)/i.exec(n))
      switch (u = r[2].split(','), r[1]) {
      case 'hsl':
        return e(parseFloat(u[0]), parseFloat(u[1]) / 100, parseFloat(u[2]) / 100);
      case 'rgb':
        return t(kt(u[0]), kt(u[1]), kt(u[2]));
      }
    return (i = Ja.get(n)) ? t(i.r, i.g, i.b) : (null == n || '#' !== n.charAt(0) || isNaN(i = parseInt(n.substring(1), 16)) || (4 === n.length ? (o = (3840 & i) >> 4, o = o >> 4 | o, a = 240 & i, a = a >> 4 | a, c = 15 & i, c = c << 4 | c) : 7 === n.length && (o = (16711680 & i) >> 16, a = (65280 & i) >> 8, c = 255 & i)), t(o, a, c));
  }
  function bt(n, t, e) {
    var r, u, i = Math.min(n /= 255, t /= 255, e /= 255), o = Math.max(n, t, e), a = o - i, c = (o + i) / 2;
    return a ? (u = 0.5 > c ? a / (o + i) : a / (2 - o - i), r = n == o ? (t - e) / a + (e > t ? 6 : 0) : t == o ? (e - n) / a + 2 : (n - t) / a + 4, r *= 60) : (r = 0 / 0, u = c > 0 && 1 > c ? 0 : r), rt(r, u, c);
  }
  function wt(n, t, e) {
    n = St(n), t = St(t), e = St(e);
    var r = pt((0.4124564 * n + 0.3575761 * t + 0.1804375 * e) / Za), u = pt((0.2126729 * n + 0.7151522 * t + 0.072175 * e) / Va), i = pt((0.0193339 * n + 0.119192 * t + 0.9503041 * e) / $a);
    return st(116 * u - 16, 500 * (r - u), 200 * (u - i));
  }
  function St(n) {
    return (n /= 255) <= 0.04045 ? n / 12.92 : Math.pow((n + 0.055) / 1.055, 2.4);
  }
  function kt(n) {
    var t = parseFloat(n);
    return '%' === n.charAt(n.length - 1) ? Math.round(2.55 * t) : t;
  }
  function Et(n) {
    return 'function' == typeof n ? n : function () {
      return n;
    };
  }
  function At(n) {
    return n;
  }
  function Ct(n) {
    return function (t, e, r) {
      return 2 === arguments.length && 'function' == typeof e && (r = e, e = null), Nt(t, e, n, r);
    };
  }
  function Nt(n, t, e, r) {
    function u() {
      var n, t = c.status;
      if (!t && c.responseText || t >= 200 && 300 > t || 304 === t) {
        try {
          n = e.call(i, c);
        } catch (r) {
          return o.error.call(i, r), void 0;
        }
        o.load.call(i, n);
      } else
        o.error.call(i, c);
    }
    var i = {}, o = Go.dispatch('beforesend', 'progress', 'load', 'error'), a = {}, c = new XMLHttpRequest(), s = null;
    return !ea.XDomainRequest || 'withCredentials' in c || !/^(http(s)?:)?\/\//.test(n) || (c = new XDomainRequest()), 'onload' in c ? c.onload = c.onerror = u : c.onreadystatechange = function () {
      c.readyState > 3 && u();
    }, c.onprogress = function (n) {
      var t = Go.event;
      Go.event = n;
      try {
        o.progress.call(i, c);
      } finally {
        Go.event = t;
      }
    }, i.header = function (n, t) {
      return n = (n + '').toLowerCase(), arguments.length < 2 ? a[n] : (null == t ? delete a[n] : a[n] = t + '', i);
    }, i.mimeType = function (n) {
      return arguments.length ? (t = null == n ? null : n + '', i) : t;
    }, i.responseType = function (n) {
      return arguments.length ? (s = n, i) : s;
    }, i.response = function (n) {
      return e = n, i;
    }, [
      'get',
      'post'
    ].forEach(function (n) {
      i[n] = function () {
        return i.send.apply(i, [n].concat(Qo(arguments)));
      };
    }), i.send = function (e, r, u) {
      if (2 === arguments.length && 'function' == typeof r && (u = r, r = null), c.open(e, n, !0), null == t || 'accept' in a || (a.accept = t + ',*/*'), c.setRequestHeader)
        for (var l in a)
          c.setRequestHeader(l, a[l]);
      return null != t && c.overrideMimeType && c.overrideMimeType(t), null != s && (c.responseType = s), null != u && i.on('error', u).on('load', function (n) {
        u(null, n);
      }), o.beforesend.call(i, c), c.send(null == r ? null : r), i;
    }, i.abort = function () {
      return c.abort(), i;
    }, Go.rebind(i, o, 'on'), null == r ? i : i.get(Lt(r));
  }
  function Lt(n) {
    return 1 === n.length ? function (t, e) {
      n(null == t ? e : null);
    } : n;
  }
  function Tt() {
    var n = qt(), t = zt() - n;
    t > 24 ? (isFinite(t) && (clearTimeout(Qa), Qa = setTimeout(Tt, t)), Ka = 0) : (Ka = 1, tc(Tt));
  }
  function qt() {
    var n = Date.now();
    for (nc = Wa; nc;)
      n >= nc.t && (nc.f = nc.c(n - nc.t)), nc = nc.n;
    return n;
  }
  function zt() {
    for (var n, t = Wa, e = 1 / 0; t;)
      t.f ? t = n ? n.n = t.n : Wa = t.n : (t.t < e && (e = t.t), t = (n = t).n);
    return Ga = n, e;
  }
  function Rt(n, t) {
    return t - (n ? Math.ceil(Math.log(n) / Math.LN10) : 1);
  }
  function Dt(n, t) {
    var e = Math.pow(10, 3 * fa(8 - t));
    return {
      scale: t > 8 ? function (n) {
        return n / e;
      } : function (n) {
        return n * e;
      },
      symbol: n
    };
  }
  function Pt(n) {
    var t = n.decimal, e = n.thousands, r = n.grouping, u = n.currency, i = r ? function (n) {
        for (var t = n.length, u = [], i = 0, o = r[0]; t > 0 && o > 0;)
          u.push(n.substring(t -= o, t + o)), o = r[i = (i + 1) % r.length];
        return u.reverse().join(e);
      } : At;
    return function (n) {
      var e = rc.exec(n), r = e[1] || ' ', o = e[2] || '>', a = e[3] || '', c = e[4] || '', s = e[5], l = +e[6], f = e[7], h = e[8], g = e[9], p = 1, v = '', d = '', m = !1;
      switch (h && (h = +h.substring(1)), (s || '0' === r && '=' === o) && (s = r = '0', o = '=', f && (l -= Math.floor((l - 1) / 4))), g) {
      case 'n':
        f = !0, g = 'g';
        break;
      case '%':
        p = 100, d = '%', g = 'f';
        break;
      case 'p':
        p = 100, d = '%', g = 'r';
        break;
      case 'b':
      case 'o':
      case 'x':
      case 'X':
        '#' === c && (v = '0' + g.toLowerCase());
      case 'c':
      case 'd':
        m = !0, h = 0;
        break;
      case 's':
        p = -1, g = 'r';
      }
      '$' === c && (v = u[0], d = u[1]), 'r' != g || h || (g = 'g'), null != h && ('g' == g ? h = Math.max(1, Math.min(21, h)) : ('e' == g || 'f' == g) && (h = Math.max(0, Math.min(20, h)))), g = uc.get(g) || Ut;
      var y = s && f;
      return function (n) {
        var e = d;
        if (m && n % 1)
          return '';
        var u = 0 > n || 0 === n && 0 > 1 / n ? (n = -n, '-') : a;
        if (0 > p) {
          var c = Go.formatPrefix(n, h);
          n = c.scale(n), e = c.symbol + d;
        } else
          n *= p;
        n = g(n, h);
        var x = n.lastIndexOf('.'), M = 0 > x ? n : n.substring(0, x), _ = 0 > x ? '' : t + n.substring(x + 1);
        !s && f && (M = i(M));
        var b = v.length + M.length + _.length + (y ? 0 : u.length), w = l > b ? new Array(b = l - b + 1).join(r) : '';
        return y && (M = i(w + M)), u += v, n = M + _, ('<' === o ? u + n + w : '>' === o ? w + u + n : '^' === o ? w.substring(0, b >>= 1) + u + n + w.substring(b) : u + (y ? n : w + n)) + e;
      };
    };
  }
  function Ut(n) {
    return n + '';
  }
  function jt() {
    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
  }
  function Ht(n, t, e) {
    function r(t) {
      var e = n(t), r = i(e, 1);
      return r - t > t - e ? e : r;
    }
    function u(e) {
      return t(e = n(new oc(e - 1)), 1), e;
    }
    function i(n, e) {
      return t(n = new oc(+n), e), n;
    }
    function o(n, r, i) {
      var o = u(n), a = [];
      if (i > 1)
        for (; r > o;)
          e(o) % i || a.push(new Date(+o)), t(o, 1);
      else
        for (; r > o;)
          a.push(new Date(+o)), t(o, 1);
      return a;
    }
    function a(n, t, e) {
      try {
        oc = jt;
        var r = new jt();
        return r._ = n, o(r, t, e);
      } finally {
        oc = Date;
      }
    }
    n.floor = n, n.round = r, n.ceil = u, n.offset = i, n.range = o;
    var c = n.utc = Ft(n);
    return c.floor = c, c.round = Ft(r), c.ceil = Ft(u), c.offset = Ft(i), c.range = a, n;
  }
  function Ft(n) {
    return function (t, e) {
      try {
        oc = jt;
        var r = new jt();
        return r._ = t, n(r, e)._;
      } finally {
        oc = Date;
      }
    };
  }
  function Ot(n) {
    function t(n) {
      function t(t) {
        for (var e, u, i, o = [], a = -1, c = 0; ++a < r;)
          37 === n.charCodeAt(a) && (o.push(n.substring(c, a)), null != (u = cc[e = n.charAt(++a)]) && (e = n.charAt(++a)), (i = C[e]) && (e = i(t, null == u ? 'e' === e ? ' ' : '0' : u)), o.push(e), c = a + 1);
        return o.push(n.substring(c, a)), o.join('');
      }
      var r = n.length;
      return t.parse = function (t) {
        var r = {
            y: 1900,
            m: 0,
            d: 1,
            H: 0,
            M: 0,
            S: 0,
            L: 0,
            Z: null
          }, u = e(r, n, t, 0);
        if (u != t.length)
          return null;
        'p' in r && (r.H = r.H % 12 + 12 * r.p);
        var i = null != r.Z && oc !== jt, o = new (i ? jt : oc)();
        return 'j' in r ? o.setFullYear(r.y, 0, r.j) : 'w' in r && ('W' in r || 'U' in r) ? (o.setFullYear(r.y, 0, 1), o.setFullYear(r.y, 0, 'W' in r ? (r.w + 6) % 7 + 7 * r.W - (o.getDay() + 5) % 7 : r.w + 7 * r.U - (o.getDay() + 6) % 7)) : o.setFullYear(r.y, r.m, r.d), o.setHours(r.H + Math.floor(r.Z / 100), r.M + r.Z % 100, r.S, r.L), i ? o._ : o;
      }, t.toString = function () {
        return n;
      }, t;
    }
    function e(n, t, e, r) {
      for (var u, i, o, a = 0, c = t.length, s = e.length; c > a;) {
        if (r >= s)
          return -1;
        if (u = t.charCodeAt(a++), 37 === u) {
          if (o = t.charAt(a++), i = N[o in cc ? t.charAt(a++) : o], !i || (r = i(n, e, r)) < 0)
            return -1;
        } else if (u != e.charCodeAt(r++))
          return -1;
      }
      return r;
    }
    function r(n, t, e) {
      b.lastIndex = 0;
      var r = b.exec(t.substring(e));
      return r ? (n.w = w.get(r[0].toLowerCase()), e + r[0].length) : -1;
    }
    function u(n, t, e) {
      M.lastIndex = 0;
      var r = M.exec(t.substring(e));
      return r ? (n.w = _.get(r[0].toLowerCase()), e + r[0].length) : -1;
    }
    function i(n, t, e) {
      E.lastIndex = 0;
      var r = E.exec(t.substring(e));
      return r ? (n.m = A.get(r[0].toLowerCase()), e + r[0].length) : -1;
    }
    function o(n, t, e) {
      S.lastIndex = 0;
      var r = S.exec(t.substring(e));
      return r ? (n.m = k.get(r[0].toLowerCase()), e + r[0].length) : -1;
    }
    function a(n, t, r) {
      return e(n, C.c.toString(), t, r);
    }
    function c(n, t, r) {
      return e(n, C.x.toString(), t, r);
    }
    function s(n, t, r) {
      return e(n, C.X.toString(), t, r);
    }
    function l(n, t, e) {
      var r = x.get(t.substring(e, e += 2).toLowerCase());
      return null == r ? -1 : (n.p = r, e);
    }
    var f = n.dateTime, h = n.date, g = n.time, p = n.periods, v = n.days, d = n.shortDays, m = n.months, y = n.shortMonths;
    t.utc = function (n) {
      function e(n) {
        try {
          oc = jt;
          var t = new oc();
          return t._ = n, r(t);
        } finally {
          oc = Date;
        }
      }
      var r = t(n);
      return e.parse = function (n) {
        try {
          oc = jt;
          var t = r.parse(n);
          return t && t._;
        } finally {
          oc = Date;
        }
      }, e.toString = r.toString, e;
    }, t.multi = t.utc.multi = ae;
    var x = Go.map(), M = Yt(v), _ = Zt(v), b = Yt(d), w = Zt(d), S = Yt(m), k = Zt(m), E = Yt(y), A = Zt(y);
    p.forEach(function (n, t) {
      x.set(n.toLowerCase(), t);
    });
    var C = {
        a: function (n) {
          return d[n.getDay()];
        },
        A: function (n) {
          return v[n.getDay()];
        },
        b: function (n) {
          return y[n.getMonth()];
        },
        B: function (n) {
          return m[n.getMonth()];
        },
        c: t(f),
        d: function (n, t) {
          return It(n.getDate(), t, 2);
        },
        e: function (n, t) {
          return It(n.getDate(), t, 2);
        },
        H: function (n, t) {
          return It(n.getHours(), t, 2);
        },
        I: function (n, t) {
          return It(n.getHours() % 12 || 12, t, 2);
        },
        j: function (n, t) {
          return It(1 + ic.dayOfYear(n), t, 3);
        },
        L: function (n, t) {
          return It(n.getMilliseconds(), t, 3);
        },
        m: function (n, t) {
          return It(n.getMonth() + 1, t, 2);
        },
        M: function (n, t) {
          return It(n.getMinutes(), t, 2);
        },
        p: function (n) {
          return p[+(n.getHours() >= 12)];
        },
        S: function (n, t) {
          return It(n.getSeconds(), t, 2);
        },
        U: function (n, t) {
          return It(ic.sundayOfYear(n), t, 2);
        },
        w: function (n) {
          return n.getDay();
        },
        W: function (n, t) {
          return It(ic.mondayOfYear(n), t, 2);
        },
        x: t(h),
        X: t(g),
        y: function (n, t) {
          return It(n.getFullYear() % 100, t, 2);
        },
        Y: function (n, t) {
          return It(n.getFullYear() % 10000, t, 4);
        },
        Z: ie,
        '%': function () {
          return '%';
        }
      }, N = {
        a: r,
        A: u,
        b: i,
        B: o,
        c: a,
        d: Qt,
        e: Qt,
        H: te,
        I: te,
        j: ne,
        L: ue,
        m: Kt,
        M: ee,
        p: l,
        S: re,
        U: $t,
        w: Vt,
        W: Xt,
        x: c,
        X: s,
        y: Jt,
        Y: Bt,
        Z: Wt,
        '%': oe
      };
    return t;
  }
  function It(n, t, e) {
    var r = 0 > n ? '-' : '', u = (r ? -n : n) + '', i = u.length;
    return r + (e > i ? new Array(e - i + 1).join(t) + u : u);
  }
  function Yt(n) {
    return new RegExp('^(?:' + n.map(Go.requote).join('|') + ')', 'i');
  }
  function Zt(n) {
    for (var t = new o(), e = -1, r = n.length; ++e < r;)
      t.set(n[e].toLowerCase(), e);
    return t;
  }
  function Vt(n, t, e) {
    sc.lastIndex = 0;
    var r = sc.exec(t.substring(e, e + 1));
    return r ? (n.w = +r[0], e + r[0].length) : -1;
  }
  function $t(n, t, e) {
    sc.lastIndex = 0;
    var r = sc.exec(t.substring(e));
    return r ? (n.U = +r[0], e + r[0].length) : -1;
  }
  function Xt(n, t, e) {
    sc.lastIndex = 0;
    var r = sc.exec(t.substring(e));
    return r ? (n.W = +r[0], e + r[0].length) : -1;
  }
  function Bt(n, t, e) {
    sc.lastIndex = 0;
    var r = sc.exec(t.substring(e, e + 4));
    return r ? (n.y = +r[0], e + r[0].length) : -1;
  }
  function Jt(n, t, e) {
    sc.lastIndex = 0;
    var r = sc.exec(t.substring(e, e + 2));
    return r ? (n.y = Gt(+r[0]), e + r[0].length) : -1;
  }
  function Wt(n, t, e) {
    return /^[+-]\d{4}$/.test(t = t.substring(e, e + 5)) ? (n.Z = -t, e + 5) : -1;
  }
  function Gt(n) {
    return n + (n > 68 ? 1900 : 2000);
  }
  function Kt(n, t, e) {
    sc.lastIndex = 0;
    var r = sc.exec(t.substring(e, e + 2));
    return r ? (n.m = r[0] - 1, e + r[0].length) : -1;
  }
  function Qt(n, t, e) {
    sc.lastIndex = 0;
    var r = sc.exec(t.substring(e, e + 2));
    return r ? (n.d = +r[0], e + r[0].length) : -1;
  }
  function ne(n, t, e) {
    sc.lastIndex = 0;
    var r = sc.exec(t.substring(e, e + 3));
    return r ? (n.j = +r[0], e + r[0].length) : -1;
  }
  function te(n, t, e) {
    sc.lastIndex = 0;
    var r = sc.exec(t.substring(e, e + 2));
    return r ? (n.H = +r[0], e + r[0].length) : -1;
  }
  function ee(n, t, e) {
    sc.lastIndex = 0;
    var r = sc.exec(t.substring(e, e + 2));
    return r ? (n.M = +r[0], e + r[0].length) : -1;
  }
  function re(n, t, e) {
    sc.lastIndex = 0;
    var r = sc.exec(t.substring(e, e + 2));
    return r ? (n.S = +r[0], e + r[0].length) : -1;
  }
  function ue(n, t, e) {
    sc.lastIndex = 0;
    var r = sc.exec(t.substring(e, e + 3));
    return r ? (n.L = +r[0], e + r[0].length) : -1;
  }
  function ie(n) {
    var t = n.getTimezoneOffset(), e = t > 0 ? '-' : '+', r = ~~(fa(t) / 60), u = fa(t) % 60;
    return e + It(r, '0', 2) + It(u, '0', 2);
  }
  function oe(n, t, e) {
    lc.lastIndex = 0;
    var r = lc.exec(t.substring(e, e + 1));
    return r ? e + r[0].length : -1;
  }
  function ae(n) {
    for (var t = n.length, e = -1; ++e < t;)
      n[e][0] = this(n[e][0]);
    return function (t) {
      for (var e = 0, r = n[e]; !r[1](t);)
        r = n[++e];
      return r[0](t);
    };
  }
  function ce() {
  }
  function se(n, t, e) {
    var r = e.s = n + t, u = r - n, i = r - u;
    e.t = n - i + (t - u);
  }
  function le(n, t) {
    n && pc.hasOwnProperty(n.type) && pc[n.type](n, t);
  }
  function fe(n, t, e) {
    var r, u = -1, i = n.length - e;
    for (t.lineStart(); ++u < i;)
      r = n[u], t.point(r[0], r[1], r[2]);
    t.lineEnd();
  }
  function he(n, t) {
    var e = -1, r = n.length;
    for (t.polygonStart(); ++e < r;)
      fe(n[e], t, 1);
    t.polygonEnd();
  }
  function ge() {
    function n(n, t) {
      n *= za, t = t * za / 2 + Ca / 4;
      var e = n - r, o = e >= 0 ? 1 : -1, a = o * e, c = Math.cos(t), s = Math.sin(t), l = i * s, f = u * c + l * Math.cos(a), h = l * o * Math.sin(a);
      dc.add(Math.atan2(h, f)), r = n, u = c, i = s;
    }
    var t, e, r, u, i;
    mc.point = function (o, a) {
      mc.point = n, r = (t = o) * za, u = Math.cos(a = (e = a) * za / 2 + Ca / 4), i = Math.sin(a);
    }, mc.lineEnd = function () {
      n(t, e);
    };
  }
  function pe(n) {
    var t = n[0], e = n[1], r = Math.cos(e);
    return [
      r * Math.cos(t),
      r * Math.sin(t),
      Math.sin(e)
    ];
  }
  function ve(n, t) {
    return n[0] * t[0] + n[1] * t[1] + n[2] * t[2];
  }
  function de(n, t) {
    return [
      n[1] * t[2] - n[2] * t[1],
      n[2] * t[0] - n[0] * t[2],
      n[0] * t[1] - n[1] * t[0]
    ];
  }
  function me(n, t) {
    n[0] += t[0], n[1] += t[1], n[2] += t[2];
  }
  function ye(n, t) {
    return [
      n[0] * t,
      n[1] * t,
      n[2] * t
    ];
  }
  function xe(n) {
    var t = Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]);
    n[0] /= t, n[1] /= t, n[2] /= t;
  }
  function Me(n) {
    return [
      Math.atan2(n[1], n[0]),
      G(n[2])
    ];
  }
  function _e(n, t) {
    return fa(n[0] - t[0]) < Ta && fa(n[1] - t[1]) < Ta;
  }
  function be(n, t) {
    n *= za;
    var e = Math.cos(t *= za);
    we(e * Math.cos(n), e * Math.sin(n), Math.sin(t));
  }
  function we(n, t, e) {
    ++yc, Mc += (n - Mc) / yc, _c += (t - _c) / yc, bc += (e - bc) / yc;
  }
  function Se() {
    function n(n, u) {
      n *= za;
      var i = Math.cos(u *= za), o = i * Math.cos(n), a = i * Math.sin(n), c = Math.sin(u), s = Math.atan2(Math.sqrt((s = e * c - r * a) * s + (s = r * o - t * c) * s + (s = t * a - e * o) * s), t * o + e * a + r * c);
      xc += s, wc += s * (t + (t = o)), Sc += s * (e + (e = a)), kc += s * (r + (r = c)), we(t, e, r);
    }
    var t, e, r;
    Nc.point = function (u, i) {
      u *= za;
      var o = Math.cos(i *= za);
      t = o * Math.cos(u), e = o * Math.sin(u), r = Math.sin(i), Nc.point = n, we(t, e, r);
    };
  }
  function ke() {
    Nc.point = be;
  }
  function Ee() {
    function n(n, t) {
      n *= za;
      var e = Math.cos(t *= za), o = e * Math.cos(n), a = e * Math.sin(n), c = Math.sin(t), s = u * c - i * a, l = i * o - r * c, f = r * a - u * o, h = Math.sqrt(s * s + l * l + f * f), g = r * o + u * a + i * c, p = h && -W(g) / h, v = Math.atan2(h, g);
      Ec += p * s, Ac += p * l, Cc += p * f, xc += v, wc += v * (r + (r = o)), Sc += v * (u + (u = a)), kc += v * (i + (i = c)), we(r, u, i);
    }
    var t, e, r, u, i;
    Nc.point = function (o, a) {
      t = o, e = a, Nc.point = n, o *= za;
      var c = Math.cos(a *= za);
      r = c * Math.cos(o), u = c * Math.sin(o), i = Math.sin(a), we(r, u, i);
    }, Nc.lineEnd = function () {
      n(t, e), Nc.lineEnd = ke, Nc.point = be;
    };
  }
  function Ae() {
    return !0;
  }
  function Ce(n, t, e, r, u) {
    var i = [], o = [];
    if (n.forEach(function (n) {
        if (!((t = n.length - 1) <= 0)) {
          var t, e = n[0], r = n[t];
          if (_e(e, r)) {
            u.lineStart();
            for (var a = 0; t > a; ++a)
              u.point((e = n[a])[0], e[1]);
            return u.lineEnd(), void 0;
          }
          var c = new Le(e, n, null, !0), s = new Le(e, null, c, !1);
          c.o = s, i.push(c), o.push(s), c = new Le(r, n, null, !1), s = new Le(r, null, c, !0), c.o = s, i.push(c), o.push(s);
        }
      }), o.sort(t), Ne(i), Ne(o), i.length) {
      for (var a = 0, c = e, s = o.length; s > a; ++a)
        o[a].e = c = !c;
      for (var l, f, h = i[0];;) {
        for (var g = h, p = !0; g.v;)
          if ((g = g.n) === h)
            return;
        l = g.z, u.lineStart();
        do {
          if (g.v = g.o.v = !0, g.e) {
            if (p)
              for (var a = 0, s = l.length; s > a; ++a)
                u.point((f = l[a])[0], f[1]);
            else
              r(g.x, g.n.x, 1, u);
            g = g.n;
          } else {
            if (p) {
              l = g.p.z;
              for (var a = l.length - 1; a >= 0; --a)
                u.point((f = l[a])[0], f[1]);
            } else
              r(g.x, g.p.x, -1, u);
            g = g.p;
          }
          g = g.o, l = g.z, p = !p;
        } while (!g.v);
        u.lineEnd();
      }
    }
  }
  function Ne(n) {
    if (t = n.length) {
      for (var t, e, r = 0, u = n[0]; ++r < t;)
        u.n = e = n[r], e.p = u, u = e;
      u.n = e = n[0], e.p = u;
    }
  }
  function Le(n, t, e, r) {
    this.x = n, this.z = t, this.o = e, this.e = r, this.v = !1, this.n = this.p = null;
  }
  function Te(n, t, e, r) {
    return function (u, i) {
      function o(t, e) {
        var r = u(t, e);
        n(t = r[0], e = r[1]) && i.point(t, e);
      }
      function a(n, t) {
        var e = u(n, t);
        d.point(e[0], e[1]);
      }
      function c() {
        y.point = a, d.lineStart();
      }
      function s() {
        y.point = o, d.lineEnd();
      }
      function l(n, t) {
        v.push([
          n,
          t
        ]);
        var e = u(n, t);
        M.point(e[0], e[1]);
      }
      function f() {
        M.lineStart(), v = [];
      }
      function h() {
        l(v[0][0], v[0][1]), M.lineEnd();
        var n, t = M.clean(), e = x.buffer(), r = e.length;
        if (v.pop(), p.push(v), v = null, r)
          if (1 & t) {
            n = e[0];
            var u, r = n.length - 1, o = -1;
            if (r > 0) {
              for (_ || (i.polygonStart(), _ = !0), i.lineStart(); ++o < r;)
                i.point((u = n[o])[0], u[1]);
              i.lineEnd();
            }
          } else
            r > 1 && 2 & t && e.push(e.pop().concat(e.shift())), g.push(e.filter(qe));
      }
      var g, p, v, d = t(i), m = u.invert(r[0], r[1]), y = {
          point: o,
          lineStart: c,
          lineEnd: s,
          polygonStart: function () {
            y.point = l, y.lineStart = f, y.lineEnd = h, g = [], p = [];
          },
          polygonEnd: function () {
            y.point = o, y.lineStart = c, y.lineEnd = s, g = Go.merge(g);
            var n = De(m, p);
            g.length ? (_ || (i.polygonStart(), _ = !0), Ce(g, Re, n, e, i)) : n && (_ || (i.polygonStart(), _ = !0), i.lineStart(), e(null, null, 1, i), i.lineEnd()), _ && (i.polygonEnd(), _ = !1), g = p = null;
          },
          sphere: function () {
            i.polygonStart(), i.lineStart(), e(null, null, 1, i), i.lineEnd(), i.polygonEnd();
          }
        }, x = ze(), M = t(x), _ = !1;
      return y;
    };
  }
  function qe(n) {
    return n.length > 1;
  }
  function ze() {
    var n, t = [];
    return {
      lineStart: function () {
        t.push(n = []);
      },
      point: function (t, e) {
        n.push([
          t,
          e
        ]);
      },
      lineEnd: v,
      buffer: function () {
        var e = t;
        return t = [], n = null, e;
      },
      rejoin: function () {
        t.length > 1 && t.push(t.pop().concat(t.shift()));
      }
    };
  }
  function Re(n, t) {
    return ((n = n.x)[0] < 0 ? n[1] - La - Ta : La - n[1]) - ((t = t.x)[0] < 0 ? t[1] - La - Ta : La - t[1]);
  }
  function De(n, t) {
    var e = n[0], r = n[1], u = [
        Math.sin(e),
        -Math.cos(e),
        0
      ], i = 0, o = 0;
    dc.reset();
    for (var a = 0, c = t.length; c > a; ++a) {
      var s = t[a], l = s.length;
      if (l)
        for (var f = s[0], h = f[0], g = f[1] / 2 + Ca / 4, p = Math.sin(g), v = Math.cos(g), d = 1;;) {
          d === l && (d = 0), n = s[d];
          var m = n[0], y = n[1] / 2 + Ca / 4, x = Math.sin(y), M = Math.cos(y), _ = m - h, b = _ >= 0 ? 1 : -1, w = b * _, S = w > Ca, k = p * x;
          if (dc.add(Math.atan2(k * b * Math.sin(w), v * M + k * Math.cos(w))), i += S ? _ + b * Na : _, S ^ h >= e ^ m >= e) {
            var E = de(pe(f), pe(n));
            xe(E);
            var A = de(u, E);
            xe(A);
            var C = (S ^ _ >= 0 ? -1 : 1) * G(A[2]);
            (r > C || r === C && (E[0] || E[1])) && (o += S ^ _ >= 0 ? 1 : -1);
          }
          if (!d++)
            break;
          h = m, p = x, v = M, f = n;
        }
    }
    return (-Ta > i || Ta > i && 0 > dc) ^ 1 & o;
  }
  function Pe(n) {
    var t, e = 0 / 0, r = 0 / 0, u = 0 / 0;
    return {
      lineStart: function () {
        n.lineStart(), t = 1;
      },
      point: function (i, o) {
        var a = i > 0 ? Ca : -Ca, c = fa(i - e);
        fa(c - Ca) < Ta ? (n.point(e, r = (r + o) / 2 > 0 ? La : -La), n.point(u, r), n.lineEnd(), n.lineStart(), n.point(a, r), n.point(i, r), t = 0) : u !== a && c >= Ca && (fa(e - u) < Ta && (e -= u * Ta), fa(i - a) < Ta && (i -= a * Ta), r = Ue(e, r, i, o), n.point(u, r), n.lineEnd(), n.lineStart(), n.point(a, r), t = 0), n.point(e = i, r = o), u = a;
      },
      lineEnd: function () {
        n.lineEnd(), e = r = 0 / 0;
      },
      clean: function () {
        return 2 - t;
      }
    };
  }
  function Ue(n, t, e, r) {
    var u, i, o = Math.sin(n - e);
    return fa(o) > Ta ? Math.atan((Math.sin(t) * (i = Math.cos(r)) * Math.sin(e) - Math.sin(r) * (u = Math.cos(t)) * Math.sin(n)) / (u * i * o)) : (t + r) / 2;
  }
  function je(n, t, e, r) {
    var u;
    if (null == n)
      u = e * La, r.point(-Ca, u), r.point(0, u), r.point(Ca, u), r.point(Ca, 0), r.point(Ca, -u), r.point(0, -u), r.point(-Ca, -u), r.point(-Ca, 0), r.point(-Ca, u);
    else if (fa(n[0] - t[0]) > Ta) {
      var i = n[0] < t[0] ? Ca : -Ca;
      u = e * i / 2, r.point(-i, u), r.point(0, u), r.point(i, u);
    } else
      r.point(t[0], t[1]);
  }
  function He(n) {
    function t(n, t) {
      return Math.cos(n) * Math.cos(t) > i;
    }
    function e(n) {
      var e, i, c, s, l;
      return {
        lineStart: function () {
          s = c = !1, l = 1;
        },
        point: function (f, h) {
          var g, p = [
              f,
              h
            ], v = t(f, h), d = o ? v ? 0 : u(f, h) : v ? u(f + (0 > f ? Ca : -Ca), h) : 0;
          if (!e && (s = c = v) && n.lineStart(), v !== c && (g = r(e, p), (_e(e, g) || _e(p, g)) && (p[0] += Ta, p[1] += Ta, v = t(p[0], p[1]))), v !== c)
            l = 0, v ? (n.lineStart(), g = r(p, e), n.point(g[0], g[1])) : (g = r(e, p), n.point(g[0], g[1]), n.lineEnd()), e = g;
          else if (a && e && o ^ v) {
            var m;
            d & i || !(m = r(p, e, !0)) || (l = 0, o ? (n.lineStart(), n.point(m[0][0], m[0][1]), n.point(m[1][0], m[1][1]), n.lineEnd()) : (n.point(m[1][0], m[1][1]), n.lineEnd(), n.lineStart(), n.point(m[0][0], m[0][1])));
          }
          !v || e && _e(e, p) || n.point(p[0], p[1]), e = p, c = v, i = d;
        },
        lineEnd: function () {
          c && n.lineEnd(), e = null;
        },
        clean: function () {
          return l | (s && c) << 1;
        }
      };
    }
    function r(n, t, e) {
      var r = pe(n), u = pe(t), o = [
          1,
          0,
          0
        ], a = de(r, u), c = ve(a, a), s = a[0], l = c - s * s;
      if (!l)
        return !e && n;
      var f = i * c / l, h = -i * s / l, g = de(o, a), p = ye(o, f), v = ye(a, h);
      me(p, v);
      var d = g, m = ve(p, d), y = ve(d, d), x = m * m - y * (ve(p, p) - 1);
      if (!(0 > x)) {
        var M = Math.sqrt(x), _ = ye(d, (-m - M) / y);
        if (me(_, p), _ = Me(_), !e)
          return _;
        var b, w = n[0], S = t[0], k = n[1], E = t[1];
        w > S && (b = w, w = S, S = b);
        var A = S - w, C = fa(A - Ca) < Ta, N = C || Ta > A;
        if (!C && k > E && (b = k, k = E, E = b), N ? C ? k + E > 0 ^ _[1] < (fa(_[0] - w) < Ta ? k : E) : k <= _[1] && _[1] <= E : A > Ca ^ (w <= _[0] && _[0] <= S)) {
          var L = ye(d, (-m + M) / y);
          return me(L, p), [
            _,
            Me(L)
          ];
        }
      }
    }
    function u(t, e) {
      var r = o ? n : Ca - n, u = 0;
      return -r > t ? u |= 1 : t > r && (u |= 2), -r > e ? u |= 4 : e > r && (u |= 8), u;
    }
    var i = Math.cos(n), o = i > 0, a = fa(i) > Ta, c = gr(n, 6 * za);
    return Te(t, e, c, o ? [
      0,
      -n
    ] : [
      -Ca,
      n - Ca
    ]);
  }
  function Fe(n, t, e, r) {
    return function (u) {
      var i, o = u.a, a = u.b, c = o.x, s = o.y, l = a.x, f = a.y, h = 0, g = 1, p = l - c, v = f - s;
      if (i = n - c, p || !(i > 0)) {
        if (i /= p, 0 > p) {
          if (h > i)
            return;
          g > i && (g = i);
        } else if (p > 0) {
          if (i > g)
            return;
          i > h && (h = i);
        }
        if (i = e - c, p || !(0 > i)) {
          if (i /= p, 0 > p) {
            if (i > g)
              return;
            i > h && (h = i);
          } else if (p > 0) {
            if (h > i)
              return;
            g > i && (g = i);
          }
          if (i = t - s, v || !(i > 0)) {
            if (i /= v, 0 > v) {
              if (h > i)
                return;
              g > i && (g = i);
            } else if (v > 0) {
              if (i > g)
                return;
              i > h && (h = i);
            }
            if (i = r - s, v || !(0 > i)) {
              if (i /= v, 0 > v) {
                if (i > g)
                  return;
                i > h && (h = i);
              } else if (v > 0) {
                if (h > i)
                  return;
                g > i && (g = i);
              }
              return h > 0 && (u.a = {
                x: c + h * p,
                y: s + h * v
              }), 1 > g && (u.b = {
                x: c + g * p,
                y: s + g * v
              }), u;
            }
          }
        }
      }
    };
  }
  function Oe(n, t, e, r) {
    function u(r, u) {
      return fa(r[0] - n) < Ta ? u > 0 ? 0 : 3 : fa(r[0] - e) < Ta ? u > 0 ? 2 : 1 : fa(r[1] - t) < Ta ? u > 0 ? 1 : 0 : u > 0 ? 3 : 2;
    }
    function i(n, t) {
      return o(n.x, t.x);
    }
    function o(n, t) {
      var e = u(n, 1), r = u(t, 1);
      return e !== r ? e - r : 0 === e ? t[1] - n[1] : 1 === e ? n[0] - t[0] : 2 === e ? n[1] - t[1] : t[0] - n[0];
    }
    return function (a) {
      function c(n) {
        for (var t = 0, e = d.length, r = n[1], u = 0; e > u; ++u)
          for (var i, o = 1, a = d[u], c = a.length, s = a[0]; c > o; ++o)
            i = a[o], s[1] <= r ? i[1] > r && J(s, i, n) > 0 && ++t : i[1] <= r && J(s, i, n) < 0 && --t, s = i;
        return 0 !== t;
      }
      function s(i, a, c, s) {
        var l = 0, f = 0;
        if (null == i || (l = u(i, c)) !== (f = u(a, c)) || o(i, a) < 0 ^ c > 0) {
          do
            s.point(0 === l || 3 === l ? n : e, l > 1 ? r : t);
          while ((l = (l + c + 4) % 4) !== f);
        } else
          s.point(a[0], a[1]);
      }
      function l(u, i) {
        return u >= n && e >= u && i >= t && r >= i;
      }
      function f(n, t) {
        l(n, t) && a.point(n, t);
      }
      function h() {
        N.point = p, d && d.push(m = []), S = !0, w = !1, _ = b = 0 / 0;
      }
      function g() {
        v && (p(y, x), M && w && A.rejoin(), v.push(A.buffer())), N.point = f, w && a.lineEnd();
      }
      function p(n, t) {
        n = Math.max(-Tc, Math.min(Tc, n)), t = Math.max(-Tc, Math.min(Tc, t));
        var e = l(n, t);
        if (d && m.push([
            n,
            t
          ]), S)
          y = n, x = t, M = e, S = !1, e && (a.lineStart(), a.point(n, t));
        else if (e && w)
          a.point(n, t);
        else {
          var r = {
              a: {
                x: _,
                y: b
              },
              b: {
                x: n,
                y: t
              }
            };
          C(r) ? (w || (a.lineStart(), a.point(r.a.x, r.a.y)), a.point(r.b.x, r.b.y), e || a.lineEnd(), k = !1) : e && (a.lineStart(), a.point(n, t), k = !1);
        }
        _ = n, b = t, w = e;
      }
      var v, d, m, y, x, M, _, b, w, S, k, E = a, A = ze(), C = Fe(n, t, e, r), N = {
          point: f,
          lineStart: h,
          lineEnd: g,
          polygonStart: function () {
            a = A, v = [], d = [], k = !0;
          },
          polygonEnd: function () {
            a = E, v = Go.merge(v);
            var t = c([
                n,
                r
              ]), e = k && t, u = v.length;
            (e || u) && (a.polygonStart(), e && (a.lineStart(), s(null, null, 1, a), a.lineEnd()), u && Ce(v, i, t, s, a), a.polygonEnd()), v = d = m = null;
          }
        };
      return N;
    };
  }
  function Ie(n, t) {
    function e(e, r) {
      return e = n(e, r), t(e[0], e[1]);
    }
    return n.invert && t.invert && (e.invert = function (e, r) {
      return e = t.invert(e, r), e && n.invert(e[0], e[1]);
    }), e;
  }
  function Ye(n) {
    var t = 0, e = Ca / 3, r = ir(n), u = r(t, e);
    return u.parallels = function (n) {
      return arguments.length ? r(t = n[0] * Ca / 180, e = n[1] * Ca / 180) : [
        180 * (t / Ca),
        180 * (e / Ca)
      ];
    }, u;
  }
  function Ze(n, t) {
    function e(n, t) {
      var e = Math.sqrt(i - 2 * u * Math.sin(t)) / u;
      return [
        e * Math.sin(n *= u),
        o - e * Math.cos(n)
      ];
    }
    var r = Math.sin(n), u = (r + Math.sin(t)) / 2, i = 1 + r * (2 * u - r), o = Math.sqrt(i) / u;
    return e.invert = function (n, t) {
      var e = o - t;
      return [
        Math.atan2(n, e) / u,
        G((i - (n * n + e * e) * u * u) / (2 * u))
      ];
    }, e;
  }
  function Ve() {
    function n(n, t) {
      zc += u * n - r * t, r = n, u = t;
    }
    var t, e, r, u;
    jc.point = function (i, o) {
      jc.point = n, t = r = i, e = u = o;
    }, jc.lineEnd = function () {
      n(t, e);
    };
  }
  function $e(n, t) {
    Rc > n && (Rc = n), n > Pc && (Pc = n), Dc > t && (Dc = t), t > Uc && (Uc = t);
  }
  function Xe() {
    function n(n, t) {
      o.push('M', n, ',', t, i);
    }
    function t(n, t) {
      o.push('M', n, ',', t), a.point = e;
    }
    function e(n, t) {
      o.push('L', n, ',', t);
    }
    function r() {
      a.point = n;
    }
    function u() {
      o.push('Z');
    }
    var i = Be(4.5), o = [], a = {
        point: n,
        lineStart: function () {
          a.point = t;
        },
        lineEnd: r,
        polygonStart: function () {
          a.lineEnd = u;
        },
        polygonEnd: function () {
          a.lineEnd = r, a.point = n;
        },
        pointRadius: function (n) {
          return i = Be(n), a;
        },
        result: function () {
          if (o.length) {
            var n = o.join('');
            return o = [], n;
          }
        }
      };
    return a;
  }
  function Be(n) {
    return 'm0,' + n + 'a' + n + ',' + n + ' 0 1,1 0,' + -2 * n + 'a' + n + ',' + n + ' 0 1,1 0,' + 2 * n + 'z';
  }
  function Je(n, t) {
    Mc += n, _c += t, ++bc;
  }
  function We() {
    function n(n, r) {
      var u = n - t, i = r - e, o = Math.sqrt(u * u + i * i);
      wc += o * (t + n) / 2, Sc += o * (e + r) / 2, kc += o, Je(t = n, e = r);
    }
    var t, e;
    Fc.point = function (r, u) {
      Fc.point = n, Je(t = r, e = u);
    };
  }
  function Ge() {
    Fc.point = Je;
  }
  function Ke() {
    function n(n, t) {
      var e = n - r, i = t - u, o = Math.sqrt(e * e + i * i);
      wc += o * (r + n) / 2, Sc += o * (u + t) / 2, kc += o, o = u * n - r * t, Ec += o * (r + n), Ac += o * (u + t), Cc += 3 * o, Je(r = n, u = t);
    }
    var t, e, r, u;
    Fc.point = function (i, o) {
      Fc.point = n, Je(t = r = i, e = u = o);
    }, Fc.lineEnd = function () {
      n(t, e);
    };
  }
  function Qe(n) {
    function t(t, e) {
      n.moveTo(t, e), n.arc(t, e, o, 0, Na);
    }
    function e(t, e) {
      n.moveTo(t, e), a.point = r;
    }
    function r(t, e) {
      n.lineTo(t, e);
    }
    function u() {
      a.point = t;
    }
    function i() {
      n.closePath();
    }
    var o = 4.5, a = {
        point: t,
        lineStart: function () {
          a.point = e;
        },
        lineEnd: u,
        polygonStart: function () {
          a.lineEnd = i;
        },
        polygonEnd: function () {
          a.lineEnd = u, a.point = t;
        },
        pointRadius: function (n) {
          return o = n, a;
        },
        result: v
      };
    return a;
  }
  function nr(n) {
    function t(n) {
      return (a ? r : e)(n);
    }
    function e(t) {
      return rr(t, function (e, r) {
        e = n(e, r), t.point(e[0], e[1]);
      });
    }
    function r(t) {
      function e(e, r) {
        e = n(e, r), t.point(e[0], e[1]);
      }
      function r() {
        x = 0 / 0, S.point = i, t.lineStart();
      }
      function i(e, r) {
        var i = pe([
            e,
            r
          ]), o = n(e, r);
        u(x, M, y, _, b, w, x = o[0], M = o[1], y = e, _ = i[0], b = i[1], w = i[2], a, t), t.point(x, M);
      }
      function o() {
        S.point = e, t.lineEnd();
      }
      function c() {
        r(), S.point = s, S.lineEnd = l;
      }
      function s(n, t) {
        i(f = n, h = t), g = x, p = M, v = _, d = b, m = w, S.point = i;
      }
      function l() {
        u(x, M, y, _, b, w, g, p, f, v, d, m, a, t), S.lineEnd = o, o();
      }
      var f, h, g, p, v, d, m, y, x, M, _, b, w, S = {
          point: e,
          lineStart: r,
          lineEnd: o,
          polygonStart: function () {
            t.polygonStart(), S.lineStart = c;
          },
          polygonEnd: function () {
            t.polygonEnd(), S.lineStart = r;
          }
        };
      return S;
    }
    function u(t, e, r, a, c, s, l, f, h, g, p, v, d, m) {
      var y = l - t, x = f - e, M = y * y + x * x;
      if (M > 4 * i && d--) {
        var _ = a + g, b = c + p, w = s + v, S = Math.sqrt(_ * _ + b * b + w * w), k = Math.asin(w /= S), E = fa(fa(w) - 1) < Ta || fa(r - h) < Ta ? (r + h) / 2 : Math.atan2(b, _), A = n(E, k), C = A[0], N = A[1], L = C - t, T = N - e, q = x * L - y * T;
        (q * q / M > i || fa((y * L + x * T) / M - 0.5) > 0.3 || o > a * g + c * p + s * v) && (u(t, e, r, a, c, s, C, N, E, _ /= S, b /= S, w, d, m), m.point(C, N), u(C, N, E, _, b, w, l, f, h, g, p, v, d, m));
      }
    }
    var i = 0.5, o = Math.cos(30 * za), a = 16;
    return t.precision = function (n) {
      return arguments.length ? (a = (i = n * n) > 0 && 16, t) : Math.sqrt(i);
    }, t;
  }
  function tr(n) {
    var t = nr(function (t, e) {
        return n([
          t * Ra,
          e * Ra
        ]);
      });
    return function (n) {
      return or(t(n));
    };
  }
  function er(n) {
    this.stream = n;
  }
  function rr(n, t) {
    return {
      point: t,
      sphere: function () {
        n.sphere();
      },
      lineStart: function () {
        n.lineStart();
      },
      lineEnd: function () {
        n.lineEnd();
      },
      polygonStart: function () {
        n.polygonStart();
      },
      polygonEnd: function () {
        n.polygonEnd();
      }
    };
  }
  function ur(n) {
    return ir(function () {
      return n;
    })();
  }
  function ir(n) {
    function t(n) {
      return n = a(n[0] * za, n[1] * za), [
        n[0] * h + c,
        s - n[1] * h
      ];
    }
    function e(n) {
      return n = a.invert((n[0] - c) / h, (s - n[1]) / h), n && [
        n[0] * Ra,
        n[1] * Ra
      ];
    }
    function r() {
      a = Ie(o = sr(m, y, x), i);
      var n = i(v, d);
      return c = g - n[0] * h, s = p + n[1] * h, u();
    }
    function u() {
      return l && (l.valid = !1, l = null), t;
    }
    var i, o, a, c, s, l, f = nr(function (n, t) {
        return n = i(n, t), [
          n[0] * h + c,
          s - n[1] * h
        ];
      }), h = 150, g = 480, p = 250, v = 0, d = 0, m = 0, y = 0, x = 0, M = Lc, _ = At, b = null, w = null;
    return t.stream = function (n) {
      return l && (l.valid = !1), l = or(M(o, f(_(n)))), l.valid = !0, l;
    }, t.clipAngle = function (n) {
      return arguments.length ? (M = null == n ? (b = n, Lc) : He((b = +n) * za), u()) : b;
    }, t.clipExtent = function (n) {
      return arguments.length ? (w = n, _ = n ? Oe(n[0][0], n[0][1], n[1][0], n[1][1]) : At, u()) : w;
    }, t.scale = function (n) {
      return arguments.length ? (h = +n, r()) : h;
    }, t.translate = function (n) {
      return arguments.length ? (g = +n[0], p = +n[1], r()) : [
        g,
        p
      ];
    }, t.center = function (n) {
      return arguments.length ? (v = n[0] % 360 * za, d = n[1] % 360 * za, r()) : [
        v * Ra,
        d * Ra
      ];
    }, t.rotate = function (n) {
      return arguments.length ? (m = n[0] % 360 * za, y = n[1] % 360 * za, x = n.length > 2 ? n[2] % 360 * za : 0, r()) : [
        m * Ra,
        y * Ra,
        x * Ra
      ];
    }, Go.rebind(t, f, 'precision'), function () {
      return i = n.apply(this, arguments), t.invert = i.invert && e, r();
    };
  }
  function or(n) {
    return rr(n, function (t, e) {
      n.point(t * za, e * za);
    });
  }
  function ar(n, t) {
    return [
      n,
      t
    ];
  }
  function cr(n, t) {
    return [
      n > Ca ? n - Na : -Ca > n ? n + Na : n,
      t
    ];
  }
  function sr(n, t, e) {
    return n ? t || e ? Ie(fr(n), hr(t, e)) : fr(n) : t || e ? hr(t, e) : cr;
  }
  function lr(n) {
    return function (t, e) {
      return t += n, [
        t > Ca ? t - Na : -Ca > t ? t + Na : t,
        e
      ];
    };
  }
  function fr(n) {
    var t = lr(n);
    return t.invert = lr(-n), t;
  }
  function hr(n, t) {
    function e(n, t) {
      var e = Math.cos(t), a = Math.cos(n) * e, c = Math.sin(n) * e, s = Math.sin(t), l = s * r + a * u;
      return [
        Math.atan2(c * i - l * o, a * r - s * u),
        G(l * i + c * o)
      ];
    }
    var r = Math.cos(n), u = Math.sin(n), i = Math.cos(t), o = Math.sin(t);
    return e.invert = function (n, t) {
      var e = Math.cos(t), a = Math.cos(n) * e, c = Math.sin(n) * e, s = Math.sin(t), l = s * i - c * o;
      return [
        Math.atan2(c * i + s * o, a * r + l * u),
        G(l * r - a * u)
      ];
    }, e;
  }
  function gr(n, t) {
    var e = Math.cos(n), r = Math.sin(n);
    return function (u, i, o, a) {
      var c = o * t;
      null != u ? (u = pr(e, u), i = pr(e, i), (o > 0 ? i > u : u > i) && (u += o * Na)) : (u = n + o * Na, i = n - 0.5 * c);
      for (var s, l = u; o > 0 ? l > i : i > l; l -= c)
        a.point((s = Me([
          e,
          -r * Math.cos(l),
          -r * Math.sin(l)
        ]))[0], s[1]);
    };
  }
  function pr(n, t) {
    var e = pe(t);
    e[0] -= n, xe(e);
    var r = W(-e[1]);
    return ((-e[2] < 0 ? -r : r) + 2 * Math.PI - Ta) % (2 * Math.PI);
  }
  function vr(n, t, e) {
    var r = Go.range(n, t - Ta, e).concat(t);
    return function (n) {
      return r.map(function (t) {
        return [
          n,
          t
        ];
      });
    };
  }
  function dr(n, t, e) {
    var r = Go.range(n, t - Ta, e).concat(t);
    return function (n) {
      return r.map(function (t) {
        return [
          t,
          n
        ];
      });
    };
  }
  function mr(n) {
    return n.source;
  }
  function yr(n) {
    return n.target;
  }
  function xr(n, t, e, r) {
    var u = Math.cos(t), i = Math.sin(t), o = Math.cos(r), a = Math.sin(r), c = u * Math.cos(n), s = u * Math.sin(n), l = o * Math.cos(e), f = o * Math.sin(e), h = 2 * Math.asin(Math.sqrt(tt(r - t) + u * o * tt(e - n))), g = 1 / Math.sin(h), p = h ? function (n) {
        var t = Math.sin(n *= h) * g, e = Math.sin(h - n) * g, r = e * c + t * l, u = e * s + t * f, o = e * i + t * a;
        return [
          Math.atan2(u, r) * Ra,
          Math.atan2(o, Math.sqrt(r * r + u * u)) * Ra
        ];
      } : function () {
        return [
          n * Ra,
          t * Ra
        ];
      };
    return p.distance = h, p;
  }
  function Mr() {
    function n(n, u) {
      var i = Math.sin(u *= za), o = Math.cos(u), a = fa((n *= za) - t), c = Math.cos(a);
      Oc += Math.atan2(Math.sqrt((a = o * Math.sin(a)) * a + (a = r * i - e * o * c) * a), e * i + r * o * c), t = n, e = i, r = o;
    }
    var t, e, r;
    Ic.point = function (u, i) {
      t = u * za, e = Math.sin(i *= za), r = Math.cos(i), Ic.point = n;
    }, Ic.lineEnd = function () {
      Ic.point = Ic.lineEnd = v;
    };
  }
  function _r(n, t) {
    function e(t, e) {
      var r = Math.cos(t), u = Math.cos(e), i = n(r * u);
      return [
        i * u * Math.sin(t),
        i * Math.sin(e)
      ];
    }
    return e.invert = function (n, e) {
      var r = Math.sqrt(n * n + e * e), u = t(r), i = Math.sin(u), o = Math.cos(u);
      return [
        Math.atan2(n * i, r * o),
        Math.asin(r && e * i / r)
      ];
    }, e;
  }
  function br(n, t) {
    function e(n, t) {
      o > 0 ? -La + Ta > t && (t = -La + Ta) : t > La - Ta && (t = La - Ta);
      var e = o / Math.pow(u(t), i);
      return [
        e * Math.sin(i * n),
        o - e * Math.cos(i * n)
      ];
    }
    var r = Math.cos(n), u = function (n) {
        return Math.tan(Ca / 4 + n / 2);
      }, i = n === t ? Math.sin(n) : Math.log(r / Math.cos(t)) / Math.log(u(t) / u(n)), o = r * Math.pow(u(n), i) / i;
    return i ? (e.invert = function (n, t) {
      var e = o - t, r = B(i) * Math.sqrt(n * n + e * e);
      return [
        Math.atan2(n, e) / i,
        2 * Math.atan(Math.pow(o / r, 1 / i)) - La
      ];
    }, e) : Sr;
  }
  function wr(n, t) {
    function e(n, t) {
      var e = i - t;
      return [
        e * Math.sin(u * n),
        i - e * Math.cos(u * n)
      ];
    }
    var r = Math.cos(n), u = n === t ? Math.sin(n) : (r - Math.cos(t)) / (t - n), i = r / u + n;
    return fa(u) < Ta ? ar : (e.invert = function (n, t) {
      var e = i - t;
      return [
        Math.atan2(n, e) / u,
        i - B(u) * Math.sqrt(n * n + e * e)
      ];
    }, e);
  }
  function Sr(n, t) {
    return [
      n,
      Math.log(Math.tan(Ca / 4 + t / 2))
    ];
  }
  function kr(n) {
    var t, e = ur(n), r = e.scale, u = e.translate, i = e.clipExtent;
    return e.scale = function () {
      var n = r.apply(e, arguments);
      return n === e ? t ? e.clipExtent(null) : e : n;
    }, e.translate = function () {
      var n = u.apply(e, arguments);
      return n === e ? t ? e.clipExtent(null) : e : n;
    }, e.clipExtent = function (n) {
      var o = i.apply(e, arguments);
      if (o === e) {
        if (t = null == n) {
          var a = Ca * r(), c = u();
          i([
            [
              c[0] - a,
              c[1] - a
            ],
            [
              c[0] + a,
              c[1] + a
            ]
          ]);
        }
      } else
        t && (o = null);
      return o;
    }, e.clipExtent(null);
  }
  function Er(n, t) {
    return [
      Math.log(Math.tan(Ca / 4 + t / 2)),
      -n
    ];
  }
  function Ar(n) {
    return n[0];
  }
  function Cr(n) {
    return n[1];
  }
  function Nr(n) {
    for (var t = n.length, e = [
          0,
          1
        ], r = 2, u = 2; t > u; u++) {
      for (; r > 1 && J(n[e[r - 2]], n[e[r - 1]], n[u]) <= 0;)
        --r;
      e[r++] = u;
    }
    return e.slice(0, r);
  }
  function Lr(n, t) {
    return n[0] - t[0] || n[1] - t[1];
  }
  function Tr(n, t, e) {
    return (e[0] - t[0]) * (n[1] - t[1]) < (e[1] - t[1]) * (n[0] - t[0]);
  }
  function qr(n, t, e, r) {
    var u = n[0], i = e[0], o = t[0] - u, a = r[0] - i, c = n[1], s = e[1], l = t[1] - c, f = r[1] - s, h = (a * (c - s) - f * (u - i)) / (f * o - a * l);
    return [
      u + h * o,
      c + h * l
    ];
  }
  function zr(n) {
    var t = n[0], e = n[n.length - 1];
    return !(t[0] - e[0] || t[1] - e[1]);
  }
  function Rr() {
    tu(this), this.edge = this.site = this.circle = null;
  }
  function Dr(n) {
    var t = ns.pop() || new Rr();
    return t.site = n, t;
  }
  function Pr(n) {
    $r(n), Gc.remove(n), ns.push(n), tu(n);
  }
  function Ur(n) {
    var t = n.circle, e = t.x, r = t.cy, u = {
        x: e,
        y: r
      }, i = n.P, o = n.N, a = [n];
    Pr(n);
    for (var c = i; c.circle && fa(e - c.circle.x) < Ta && fa(r - c.circle.cy) < Ta;)
      i = c.P, a.unshift(c), Pr(c), c = i;
    a.unshift(c), $r(c);
    for (var s = o; s.circle && fa(e - s.circle.x) < Ta && fa(r - s.circle.cy) < Ta;)
      o = s.N, a.push(s), Pr(s), s = o;
    a.push(s), $r(s);
    var l, f = a.length;
    for (l = 1; f > l; ++l)
      s = a[l], c = a[l - 1], Kr(s.edge, c.site, s.site, u);
    c = a[0], s = a[f - 1], s.edge = Wr(c.site, s.site, null, u), Vr(c), Vr(s);
  }
  function jr(n) {
    for (var t, e, r, u, i = n.x, o = n.y, a = Gc._; a;)
      if (r = Hr(a, o) - i, r > Ta)
        a = a.L;
      else {
        if (u = i - Fr(a, o), !(u > Ta)) {
          r > -Ta ? (t = a.P, e = a) : u > -Ta ? (t = a, e = a.N) : t = e = a;
          break;
        }
        if (!a.R) {
          t = a;
          break;
        }
        a = a.R;
      }
    var c = Dr(n);
    if (Gc.insert(t, c), t || e) {
      if (t === e)
        return $r(t), e = Dr(t.site), Gc.insert(c, e), c.edge = e.edge = Wr(t.site, c.site), Vr(t), Vr(e), void 0;
      if (!e)
        return c.edge = Wr(t.site, c.site), void 0;
      $r(t), $r(e);
      var s = t.site, l = s.x, f = s.y, h = n.x - l, g = n.y - f, p = e.site, v = p.x - l, d = p.y - f, m = 2 * (h * d - g * v), y = h * h + g * g, x = v * v + d * d, M = {
          x: (d * y - g * x) / m + l,
          y: (h * x - v * y) / m + f
        };
      Kr(e.edge, s, p, M), c.edge = Wr(s, n, null, M), e.edge = Wr(n, p, null, M), Vr(t), Vr(e);
    }
  }
  function Hr(n, t) {
    var e = n.site, r = e.x, u = e.y, i = u - t;
    if (!i)
      return r;
    var o = n.P;
    if (!o)
      return -1 / 0;
    e = o.site;
    var a = e.x, c = e.y, s = c - t;
    if (!s)
      return a;
    var l = a - r, f = 1 / i - 1 / s, h = l / s;
    return f ? (-h + Math.sqrt(h * h - 2 * f * (l * l / (-2 * s) - c + s / 2 + u - i / 2))) / f + r : (r + a) / 2;
  }
  function Fr(n, t) {
    var e = n.N;
    if (e)
      return Hr(e, t);
    var r = n.site;
    return r.y === t ? r.x : 1 / 0;
  }
  function Or(n) {
    this.site = n, this.edges = [];
  }
  function Ir(n) {
    for (var t, e, r, u, i, o, a, c, s, l, f = n[0][0], h = n[1][0], g = n[0][1], p = n[1][1], v = Wc, d = v.length; d--;)
      if (i = v[d], i && i.prepare())
        for (a = i.edges, c = a.length, o = 0; c > o;)
          l = a[o].end(), r = l.x, u = l.y, s = a[++o % c].start(), t = s.x, e = s.y, (fa(r - t) > Ta || fa(u - e) > Ta) && (a.splice(o, 0, new Qr(Gr(i.site, l, fa(r - f) < Ta && p - u > Ta ? {
            x: f,
            y: fa(t - f) < Ta ? e : p
          } : fa(u - p) < Ta && h - r > Ta ? {
            x: fa(e - p) < Ta ? t : h,
            y: p
          } : fa(r - h) < Ta && u - g > Ta ? {
            x: h,
            y: fa(t - h) < Ta ? e : g
          } : fa(u - g) < Ta && r - f > Ta ? {
            x: fa(e - g) < Ta ? t : f,
            y: g
          } : null), i.site, null)), ++c);
  }
  function Yr(n, t) {
    return t.angle - n.angle;
  }
  function Zr() {
    tu(this), this.x = this.y = this.arc = this.site = this.cy = null;
  }
  function Vr(n) {
    var t = n.P, e = n.N;
    if (t && e) {
      var r = t.site, u = n.site, i = e.site;
      if (r !== i) {
        var o = u.x, a = u.y, c = r.x - o, s = r.y - a, l = i.x - o, f = i.y - a, h = 2 * (c * f - s * l);
        if (!(h >= -qa)) {
          var g = c * c + s * s, p = l * l + f * f, v = (f * g - s * p) / h, d = (c * p - l * g) / h, f = d + a, m = ts.pop() || new Zr();
          m.arc = n, m.site = u, m.x = v + o, m.y = f + Math.sqrt(v * v + d * d), m.cy = f, n.circle = m;
          for (var y = null, x = Qc._; x;)
            if (m.y < x.y || m.y === x.y && m.x <= x.x) {
              if (!x.L) {
                y = x.P;
                break;
              }
              x = x.L;
            } else {
              if (!x.R) {
                y = x;
                break;
              }
              x = x.R;
            }
          Qc.insert(y, m), y || (Kc = m);
        }
      }
    }
  }
  function $r(n) {
    var t = n.circle;
    t && (t.P || (Kc = t.N), Qc.remove(t), ts.push(t), tu(t), n.circle = null);
  }
  function Xr(n) {
    for (var t, e = Jc, r = Fe(n[0][0], n[0][1], n[1][0], n[1][1]), u = e.length; u--;)
      t = e[u], (!Br(t, n) || !r(t) || fa(t.a.x - t.b.x) < Ta && fa(t.a.y - t.b.y) < Ta) && (t.a = t.b = null, e.splice(u, 1));
  }
  function Br(n, t) {
    var e = n.b;
    if (e)
      return !0;
    var r, u, i = n.a, o = t[0][0], a = t[1][0], c = t[0][1], s = t[1][1], l = n.l, f = n.r, h = l.x, g = l.y, p = f.x, v = f.y, d = (h + p) / 2, m = (g + v) / 2;
    if (v === g) {
      if (o > d || d >= a)
        return;
      if (h > p) {
        if (i) {
          if (i.y >= s)
            return;
        } else
          i = {
            x: d,
            y: c
          };
        e = {
          x: d,
          y: s
        };
      } else {
        if (i) {
          if (i.y < c)
            return;
        } else
          i = {
            x: d,
            y: s
          };
        e = {
          x: d,
          y: c
        };
      }
    } else if (r = (h - p) / (v - g), u = m - r * d, -1 > r || r > 1)
      if (h > p) {
        if (i) {
          if (i.y >= s)
            return;
        } else
          i = {
            x: (c - u) / r,
            y: c
          };
        e = {
          x: (s - u) / r,
          y: s
        };
      } else {
        if (i) {
          if (i.y < c)
            return;
        } else
          i = {
            x: (s - u) / r,
            y: s
          };
        e = {
          x: (c - u) / r,
          y: c
        };
      }
    else if (v > g) {
      if (i) {
        if (i.x >= a)
          return;
      } else
        i = {
          x: o,
          y: r * o + u
        };
      e = {
        x: a,
        y: r * a + u
      };
    } else {
      if (i) {
        if (i.x < o)
          return;
      } else
        i = {
          x: a,
          y: r * a + u
        };
      e = {
        x: o,
        y: r * o + u
      };
    }
    return n.a = i, n.b = e, !0;
  }
  function Jr(n, t) {
    this.l = n, this.r = t, this.a = this.b = null;
  }
  function Wr(n, t, e, r) {
    var u = new Jr(n, t);
    return Jc.push(u), e && Kr(u, n, t, e), r && Kr(u, t, n, r), Wc[n.i].edges.push(new Qr(u, n, t)), Wc[t.i].edges.push(new Qr(u, t, n)), u;
  }
  function Gr(n, t, e) {
    var r = new Jr(n, null);
    return r.a = t, r.b = e, Jc.push(r), r;
  }
  function Kr(n, t, e, r) {
    n.a || n.b ? n.l === e ? n.b = r : n.a = r : (n.a = r, n.l = t, n.r = e);
  }
  function Qr(n, t, e) {
    var r = n.a, u = n.b;
    this.edge = n, this.site = t, this.angle = e ? Math.atan2(e.y - t.y, e.x - t.x) : n.l === t ? Math.atan2(u.x - r.x, r.y - u.y) : Math.atan2(r.x - u.x, u.y - r.y);
  }
  function nu() {
    this._ = null;
  }
  function tu(n) {
    n.U = n.C = n.L = n.R = n.P = n.N = null;
  }
  function eu(n, t) {
    var e = t, r = t.R, u = e.U;
    u ? u.L === e ? u.L = r : u.R = r : n._ = r, r.U = u, e.U = r, e.R = r.L, e.R && (e.R.U = e), r.L = e;
  }
  function ru(n, t) {
    var e = t, r = t.L, u = e.U;
    u ? u.L === e ? u.L = r : u.R = r : n._ = r, r.U = u, e.U = r, e.L = r.R, e.L && (e.L.U = e), r.R = e;
  }
  function uu(n) {
    for (; n.L;)
      n = n.L;
    return n;
  }
  function iu(n, t) {
    var e, r, u, i = n.sort(ou).pop();
    for (Jc = [], Wc = new Array(n.length), Gc = new nu(), Qc = new nu();;)
      if (u = Kc, i && (!u || i.y < u.y || i.y === u.y && i.x < u.x))
        (i.x !== e || i.y !== r) && (Wc[i.i] = new Or(i), jr(i), e = i.x, r = i.y), i = n.pop();
      else {
        if (!u)
          break;
        Ur(u.arc);
      }
    t && (Xr(t), Ir(t));
    var o = {
        cells: Wc,
        edges: Jc
      };
    return Gc = Qc = Jc = Wc = null, o;
  }
  function ou(n, t) {
    return t.y - n.y || t.x - n.x;
  }
  function au(n, t, e) {
    return (n.x - e.x) * (t.y - n.y) - (n.x - t.x) * (e.y - n.y);
  }
  function cu(n) {
    return n.x;
  }
  function su(n) {
    return n.y;
  }
  function lu() {
    return {
      leaf: !0,
      nodes: [],
      point: null,
      x: null,
      y: null
    };
  }
  function fu(n, t, e, r, u, i) {
    if (!n(t, e, r, u, i)) {
      var o = 0.5 * (e + u), a = 0.5 * (r + i), c = t.nodes;
      c[0] && fu(n, c[0], e, r, o, a), c[1] && fu(n, c[1], o, r, u, a), c[2] && fu(n, c[2], e, a, o, i), c[3] && fu(n, c[3], o, a, u, i);
    }
  }
  function hu(n, t) {
    n = Go.rgb(n), t = Go.rgb(t);
    var e = n.r, r = n.g, u = n.b, i = t.r - e, o = t.g - r, a = t.b - u;
    return function (n) {
      return '#' + Mt(Math.round(e + i * n)) + Mt(Math.round(r + o * n)) + Mt(Math.round(u + a * n));
    };
  }
  function gu(n, t) {
    var e, r = {}, u = {};
    for (e in n)
      e in t ? r[e] = du(n[e], t[e]) : u[e] = n[e];
    for (e in t)
      e in n || (u[e] = t[e]);
    return function (n) {
      for (e in r)
        u[e] = r[e](n);
      return u;
    };
  }
  function pu(n, t) {
    return t -= n = +n, function (e) {
      return n + t * e;
    };
  }
  function vu(n, t) {
    var e, r, u, i = rs.lastIndex = us.lastIndex = 0, o = -1, a = [], c = [];
    for (n += '', t += ''; (e = rs.exec(n)) && (r = us.exec(t));)
      (u = r.index) > i && (u = t.substring(i, u), a[o] ? a[o] += u : a[++o] = u), (e = e[0]) === (r = r[0]) ? a[o] ? a[o] += r : a[++o] = r : (a[++o] = null, c.push({
        i: o,
        x: pu(e, r)
      })), i = us.lastIndex;
    return i < t.length && (u = t.substring(i), a[o] ? a[o] += u : a[++o] = u), a.length < 2 ? c[0] ? (t = c[0].x, function (n) {
      return t(n) + '';
    }) : function () {
      return t;
    } : (t = c.length, function (n) {
      for (var e, r = 0; t > r; ++r)
        a[(e = c[r]).i] = e.x(n);
      return a.join('');
    });
  }
  function du(n, t) {
    for (var e, r = Go.interpolators.length; --r >= 0 && !(e = Go.interpolators[r](n, t)););
    return e;
  }
  function mu(n, t) {
    var e, r = [], u = [], i = n.length, o = t.length, a = Math.min(n.length, t.length);
    for (e = 0; a > e; ++e)
      r.push(du(n[e], t[e]));
    for (; i > e; ++e)
      u[e] = n[e];
    for (; o > e; ++e)
      u[e] = t[e];
    return function (n) {
      for (e = 0; a > e; ++e)
        u[e] = r[e](n);
      return u;
    };
  }
  function yu(n) {
    return function (t) {
      return 0 >= t ? 0 : t >= 1 ? 1 : n(t);
    };
  }
  function xu(n) {
    return function (t) {
      return 1 - n(1 - t);
    };
  }
  function Mu(n) {
    return function (t) {
      return 0.5 * (0.5 > t ? n(2 * t) : 2 - n(2 - 2 * t));
    };
  }
  function _u(n) {
    return n * n;
  }
  function bu(n) {
    return n * n * n;
  }
  function wu(n) {
    if (0 >= n)
      return 0;
    if (n >= 1)
      return 1;
    var t = n * n, e = t * n;
    return 4 * (0.5 > n ? e : 3 * (n - t) + e - 0.75);
  }
  function Su(n) {
    return function (t) {
      return Math.pow(t, n);
    };
  }
  function ku(n) {
    return 1 - Math.cos(n * La);
  }
  function Eu(n) {
    return Math.pow(2, 10 * (n - 1));
  }
  function Au(n) {
    return 1 - Math.sqrt(1 - n * n);
  }
  function Cu(n, t) {
    var e;
    return arguments.length < 2 && (t = 0.45), arguments.length ? e = t / Na * Math.asin(1 / n) : (n = 1, e = t / 4), function (r) {
      return 1 + n * Math.pow(2, -10 * r) * Math.sin((r - e) * Na / t);
    };
  }
  function Nu(n) {
    return n || (n = 1.70158), function (t) {
      return t * t * ((n + 1) * t - n);
    };
  }
  function Lu(n) {
    return 1 / 2.75 > n ? 7.5625 * n * n : 2 / 2.75 > n ? 7.5625 * (n -= 1.5 / 2.75) * n + 0.75 : 2.5 / 2.75 > n ? 7.5625 * (n -= 2.25 / 2.75) * n + 0.9375 : 7.5625 * (n -= 2.625 / 2.75) * n + 0.984375;
  }
  function Tu(n, t) {
    n = Go.hcl(n), t = Go.hcl(t);
    var e = n.h, r = n.c, u = n.l, i = t.h - e, o = t.c - r, a = t.l - u;
    return isNaN(o) && (o = 0, r = isNaN(r) ? t.c : r), isNaN(i) ? (i = 0, e = isNaN(e) ? t.h : e) : i > 180 ? i -= 360 : -180 > i && (i += 360), function (n) {
      return ct(e + i * n, r + o * n, u + a * n) + '';
    };
  }
  function qu(n, t) {
    n = Go.hsl(n), t = Go.hsl(t);
    var e = n.h, r = n.s, u = n.l, i = t.h - e, o = t.s - r, a = t.l - u;
    return isNaN(o) && (o = 0, r = isNaN(r) ? t.s : r), isNaN(i) ? (i = 0, e = isNaN(e) ? t.h : e) : i > 180 ? i -= 360 : -180 > i && (i += 360), function (n) {
      return it(e + i * n, r + o * n, u + a * n) + '';
    };
  }
  function zu(n, t) {
    n = Go.lab(n), t = Go.lab(t);
    var e = n.l, r = n.a, u = n.b, i = t.l - e, o = t.a - r, a = t.b - u;
    return function (n) {
      return ft(e + i * n, r + o * n, u + a * n) + '';
    };
  }
  function Ru(n, t) {
    return t -= n, function (e) {
      return Math.round(n + t * e);
    };
  }
  function Du(n) {
    var t = [
        n.a,
        n.b
      ], e = [
        n.c,
        n.d
      ], r = Uu(t), u = Pu(t, e), i = Uu(ju(e, t, -u)) || 0;
    t[0] * e[1] < e[0] * t[1] && (t[0] *= -1, t[1] *= -1, r *= -1, u *= -1), this.rotate = (r ? Math.atan2(t[1], t[0]) : Math.atan2(-e[0], e[1])) * Ra, this.translate = [
      n.e,
      n.f
    ], this.scale = [
      r,
      i
    ], this.skew = i ? Math.atan2(u, i) * Ra : 0;
  }
  function Pu(n, t) {
    return n[0] * t[0] + n[1] * t[1];
  }
  function Uu(n) {
    var t = Math.sqrt(Pu(n, n));
    return t && (n[0] /= t, n[1] /= t), t;
  }
  function ju(n, t, e) {
    return n[0] += e * t[0], n[1] += e * t[1], n;
  }
  function Hu(n, t) {
    var e, r = [], u = [], i = Go.transform(n), o = Go.transform(t), a = i.translate, c = o.translate, s = i.rotate, l = o.rotate, f = i.skew, h = o.skew, g = i.scale, p = o.scale;
    return a[0] != c[0] || a[1] != c[1] ? (r.push('translate(', null, ',', null, ')'), u.push({
      i: 1,
      x: pu(a[0], c[0])
    }, {
      i: 3,
      x: pu(a[1], c[1])
    })) : c[0] || c[1] ? r.push('translate(' + c + ')') : r.push(''), s != l ? (s - l > 180 ? l += 360 : l - s > 180 && (s += 360), u.push({
      i: r.push(r.pop() + 'rotate(', null, ')') - 2,
      x: pu(s, l)
    })) : l && r.push(r.pop() + 'rotate(' + l + ')'), f != h ? u.push({
      i: r.push(r.pop() + 'skewX(', null, ')') - 2,
      x: pu(f, h)
    }) : h && r.push(r.pop() + 'skewX(' + h + ')'), g[0] != p[0] || g[1] != p[1] ? (e = r.push(r.pop() + 'scale(', null, ',', null, ')'), u.push({
      i: e - 4,
      x: pu(g[0], p[0])
    }, {
      i: e - 2,
      x: pu(g[1], p[1])
    })) : (1 != p[0] || 1 != p[1]) && r.push(r.pop() + 'scale(' + p + ')'), e = u.length, function (n) {
      for (var t, i = -1; ++i < e;)
        r[(t = u[i]).i] = t.x(n);
      return r.join('');
    };
  }
  function Fu(n, t) {
    return t = t - (n = +n) ? 1 / (t - n) : 0, function (e) {
      return (e - n) * t;
    };
  }
  function Ou(n, t) {
    return t = t - (n = +n) ? 1 / (t - n) : 0, function (e) {
      return Math.max(0, Math.min(1, (e - n) * t));
    };
  }
  function Iu(n) {
    for (var t = n.source, e = n.target, r = Zu(t, e), u = [t]; t !== r;)
      t = t.parent, u.push(t);
    for (var i = u.length; e !== r;)
      u.splice(i, 0, e), e = e.parent;
    return u;
  }
  function Yu(n) {
    for (var t = [], e = n.parent; null != e;)
      t.push(n), n = e, e = e.parent;
    return t.push(n), t;
  }
  function Zu(n, t) {
    if (n === t)
      return n;
    for (var e = Yu(n), r = Yu(t), u = e.pop(), i = r.pop(), o = null; u === i;)
      o = u, u = e.pop(), i = r.pop();
    return o;
  }
  function Vu(n) {
    n.fixed |= 2;
  }
  function $u(n) {
    n.fixed &= -7;
  }
  function Xu(n) {
    n.fixed |= 4, n.px = n.x, n.py = n.y;
  }
  function Bu(n) {
    n.fixed &= -5;
  }
  function Ju(n, t, e) {
    var r = 0, u = 0;
    if (n.charge = 0, !n.leaf)
      for (var i, o = n.nodes, a = o.length, c = -1; ++c < a;)
        i = o[c], null != i && (Ju(i, t, e), n.charge += i.charge, r += i.charge * i.cx, u += i.charge * i.cy);
    if (n.point) {
      n.leaf || (n.point.x += Math.random() - 0.5, n.point.y += Math.random() - 0.5);
      var s = t * e[n.point.index];
      n.charge += n.pointCharge = s, r += s * n.point.x, u += s * n.point.y;
    }
    n.cx = r / n.charge, n.cy = u / n.charge;
  }
  function Wu(n, t) {
    return Go.rebind(n, t, 'sort', 'children', 'value'), n.nodes = n, n.links = ni, n;
  }
  function Gu(n) {
    return n.children;
  }
  function Ku(n) {
    return n.value;
  }
  function Qu(n, t) {
    return t.value - n.value;
  }
  function ni(n) {
    return Go.merge(n.map(function (n) {
      return (n.children || []).map(function (t) {
        return {
          source: n,
          target: t
        };
      });
    }));
  }
  function ti(n) {
    return n.x;
  }
  function ei(n) {
    return n.y;
  }
  function ri(n, t, e) {
    n.y0 = t, n.y = e;
  }
  function ui(n) {
    return Go.range(n.length);
  }
  function ii(n) {
    for (var t = -1, e = n[0].length, r = []; ++t < e;)
      r[t] = 0;
    return r;
  }
  function oi(n) {
    for (var t, e = 1, r = 0, u = n[0][1], i = n.length; i > e; ++e)
      (t = n[e][1]) > u && (r = e, u = t);
    return r;
  }
  function ai(n) {
    return n.reduce(ci, 0);
  }
  function ci(n, t) {
    return n + t[1];
  }
  function si(n, t) {
    return li(n, Math.ceil(Math.log(t.length) / Math.LN2 + 1));
  }
  function li(n, t) {
    for (var e = -1, r = +n[0], u = (n[1] - r) / t, i = []; ++e <= t;)
      i[e] = u * e + r;
    return i;
  }
  function fi(n) {
    return [
      Go.min(n),
      Go.max(n)
    ];
  }
  function hi(n, t) {
    return n.parent == t.parent ? 1 : 2;
  }
  function gi(n) {
    var t = n.children;
    return t && t.length ? t[0] : n._tree.thread;
  }
  function pi(n) {
    var t, e = n.children;
    return e && (t = e.length) ? e[t - 1] : n._tree.thread;
  }
  function vi(n, t) {
    var e = n.children;
    if (e && (u = e.length))
      for (var r, u, i = -1; ++i < u;)
        t(r = vi(e[i], t), n) > 0 && (n = r);
    return n;
  }
  function di(n, t) {
    return n.x - t.x;
  }
  function mi(n, t) {
    return t.x - n.x;
  }
  function yi(n, t) {
    return n.depth - t.depth;
  }
  function xi(n, t) {
    function e(n, r) {
      var u = n.children;
      if (u && (o = u.length))
        for (var i, o, a = null, c = -1; ++c < o;)
          i = u[c], e(i, a), a = i;
      t(n, r);
    }
    e(n, null);
  }
  function Mi(n) {
    for (var t, e = 0, r = 0, u = n.children, i = u.length; --i >= 0;)
      t = u[i]._tree, t.prelim += e, t.mod += e, e += t.shift + (r += t.change);
  }
  function _i(n, t, e) {
    n = n._tree, t = t._tree;
    var r = e / (t.number - n.number);
    n.change += r, t.change -= r, t.shift += e, t.prelim += e, t.mod += e;
  }
  function bi(n, t, e) {
    return n._tree.ancestor.parent == t.parent ? n._tree.ancestor : e;
  }
  function wi(n, t) {
    return n.value - t.value;
  }
  function Si(n, t) {
    var e = n._pack_next;
    n._pack_next = t, t._pack_prev = n, t._pack_next = e, e._pack_prev = t;
  }
  function ki(n, t) {
    n._pack_next = t, t._pack_prev = n;
  }
  function Ei(n, t) {
    var e = t.x - n.x, r = t.y - n.y, u = n.r + t.r;
    return 0.999 * u * u > e * e + r * r;
  }
  function Ai(n) {
    function t(n) {
      l = Math.min(n.x - n.r, l), f = Math.max(n.x + n.r, f), h = Math.min(n.y - n.r, h), g = Math.max(n.y + n.r, g);
    }
    if ((e = n.children) && (s = e.length)) {
      var e, r, u, i, o, a, c, s, l = 1 / 0, f = -1 / 0, h = 1 / 0, g = -1 / 0;
      if (e.forEach(Ci), r = e[0], r.x = -r.r, r.y = 0, t(r), s > 1 && (u = e[1], u.x = u.r, u.y = 0, t(u), s > 2))
        for (i = e[2], Ti(r, u, i), t(i), Si(r, i), r._pack_prev = i, Si(i, u), u = r._pack_next, o = 3; s > o; o++) {
          Ti(r, u, i = e[o]);
          var p = 0, v = 1, d = 1;
          for (a = u._pack_next; a !== u; a = a._pack_next, v++)
            if (Ei(a, i)) {
              p = 1;
              break;
            }
          if (1 == p)
            for (c = r._pack_prev; c !== a._pack_prev && !Ei(c, i); c = c._pack_prev, d++);
          p ? (d > v || v == d && u.r < r.r ? ki(r, u = a) : ki(r = c, u), o--) : (Si(r, i), u = i, t(i));
        }
      var m = (l + f) / 2, y = (h + g) / 2, x = 0;
      for (o = 0; s > o; o++)
        i = e[o], i.x -= m, i.y -= y, x = Math.max(x, i.r + Math.sqrt(i.x * i.x + i.y * i.y));
      n.r = x, e.forEach(Ni);
    }
  }
  function Ci(n) {
    n._pack_next = n._pack_prev = n;
  }
  function Ni(n) {
    delete n._pack_next, delete n._pack_prev;
  }
  function Li(n, t, e, r) {
    var u = n.children;
    if (n.x = t += r * n.x, n.y = e += r * n.y, n.r *= r, u)
      for (var i = -1, o = u.length; ++i < o;)
        Li(u[i], t, e, r);
  }
  function Ti(n, t, e) {
    var r = n.r + e.r, u = t.x - n.x, i = t.y - n.y;
    if (r && (u || i)) {
      var o = t.r + e.r, a = u * u + i * i;
      o *= o, r *= r;
      var c = 0.5 + (r - o) / (2 * a), s = Math.sqrt(Math.max(0, 2 * o * (r + a) - (r -= a) * r - o * o)) / (2 * a);
      e.x = n.x + c * u + s * i, e.y = n.y + c * i - s * u;
    } else
      e.x = n.x + r, e.y = n.y;
  }
  function qi(n) {
    return 1 + Go.max(n, function (n) {
      return n.y;
    });
  }
  function zi(n) {
    return n.reduce(function (n, t) {
      return n + t.x;
    }, 0) / n.length;
  }
  function Ri(n) {
    var t = n.children;
    return t && t.length ? Ri(t[0]) : n;
  }
  function Di(n) {
    var t, e = n.children;
    return e && (t = e.length) ? Di(e[t - 1]) : n;
  }
  function Pi(n) {
    return {
      x: n.x,
      y: n.y,
      dx: n.dx,
      dy: n.dy
    };
  }
  function Ui(n, t) {
    var e = n.x + t[3], r = n.y + t[0], u = n.dx - t[1] - t[3], i = n.dy - t[0] - t[2];
    return 0 > u && (e += u / 2, u = 0), 0 > i && (r += i / 2, i = 0), {
      x: e,
      y: r,
      dx: u,
      dy: i
    };
  }
  function ji(n) {
    var t = n[0], e = n[n.length - 1];
    return e > t ? [
      t,
      e
    ] : [
      e,
      t
    ];
  }
  function Hi(n) {
    return n.rangeExtent ? n.rangeExtent() : ji(n.range());
  }
  function Fi(n, t, e, r) {
    var u = e(n[0], n[1]), i = r(t[0], t[1]);
    return function (n) {
      return i(u(n));
    };
  }
  function Oi(n, t) {
    var e, r = 0, u = n.length - 1, i = n[r], o = n[u];
    return i > o && (e = r, r = u, u = e, e = i, i = o, o = e), n[r] = t.floor(i), n[u] = t.ceil(o), n;
  }
  function Ii(n) {
    return n ? {
      floor: function (t) {
        return Math.floor(t / n) * n;
      },
      ceil: function (t) {
        return Math.ceil(t / n) * n;
      }
    } : vs;
  }
  function Yi(n, t, e, r) {
    var u = [], i = [], o = 0, a = Math.min(n.length, t.length) - 1;
    for (n[a] < n[0] && (n = n.slice().reverse(), t = t.slice().reverse()); ++o <= a;)
      u.push(e(n[o - 1], n[o])), i.push(r(t[o - 1], t[o]));
    return function (t) {
      var e = Go.bisect(n, t, 1, a) - 1;
      return i[e](u[e](t));
    };
  }
  function Zi(n, t, e, r) {
    function u() {
      var u = Math.min(n.length, t.length) > 2 ? Yi : Fi, c = r ? Ou : Fu;
      return o = u(n, t, c, e), a = u(t, n, c, du), i;
    }
    function i(n) {
      return o(n);
    }
    var o, a;
    return i.invert = function (n) {
      return a(n);
    }, i.domain = function (t) {
      return arguments.length ? (n = t.map(Number), u()) : n;
    }, i.range = function (n) {
      return arguments.length ? (t = n, u()) : t;
    }, i.rangeRound = function (n) {
      return i.range(n).interpolate(Ru);
    }, i.clamp = function (n) {
      return arguments.length ? (r = n, u()) : r;
    }, i.interpolate = function (n) {
      return arguments.length ? (e = n, u()) : e;
    }, i.ticks = function (t) {
      return Bi(n, t);
    }, i.tickFormat = function (t, e) {
      return Ji(n, t, e);
    }, i.nice = function (t) {
      return $i(n, t), u();
    }, i.copy = function () {
      return Zi(n, t, e, r);
    }, u();
  }
  function Vi(n, t) {
    return Go.rebind(n, t, 'range', 'rangeRound', 'interpolate', 'clamp');
  }
  function $i(n, t) {
    return Oi(n, Ii(Xi(n, t)[2]));
  }
  function Xi(n, t) {
    null == t && (t = 10);
    var e = ji(n), r = e[1] - e[0], u = Math.pow(10, Math.floor(Math.log(r / t) / Math.LN10)), i = t / r * u;
    return 0.15 >= i ? u *= 10 : 0.35 >= i ? u *= 5 : 0.75 >= i && (u *= 2), e[0] = Math.ceil(e[0] / u) * u, e[1] = Math.floor(e[1] / u) * u + 0.5 * u, e[2] = u, e;
  }
  function Bi(n, t) {
    return Go.range.apply(Go, Xi(n, t));
  }
  function Ji(n, t, e) {
    var r = Xi(n, t);
    if (e) {
      var u = rc.exec(e);
      if (u.shift(), 's' === u[8]) {
        var i = Go.formatPrefix(Math.max(fa(r[0]), fa(r[1])));
        return u[7] || (u[7] = '.' + Wi(i.scale(r[2]))), u[8] = 'f', e = Go.format(u.join('')), function (n) {
          return e(i.scale(n)) + i.symbol;
        };
      }
      u[7] || (u[7] = '.' + Gi(u[8], r)), e = u.join('');
    } else
      e = ',.' + Wi(r[2]) + 'f';
    return Go.format(e);
  }
  function Wi(n) {
    return -Math.floor(Math.log(n) / Math.LN10 + 0.01);
  }
  function Gi(n, t) {
    var e = Wi(t[2]);
    return n in ds ? Math.abs(e - Wi(Math.max(fa(t[0]), fa(t[1])))) + +('e' !== n) : e - 2 * ('%' === n);
  }
  function Ki(n, t, e, r) {
    function u(n) {
      return (e ? Math.log(0 > n ? 0 : n) : -Math.log(n > 0 ? 0 : -n)) / Math.log(t);
    }
    function i(n) {
      return e ? Math.pow(t, n) : -Math.pow(t, -n);
    }
    function o(t) {
      return n(u(t));
    }
    return o.invert = function (t) {
      return i(n.invert(t));
    }, o.domain = function (t) {
      return arguments.length ? (e = t[0] >= 0, n.domain((r = t.map(Number)).map(u)), o) : r;
    }, o.base = function (e) {
      return arguments.length ? (t = +e, n.domain(r.map(u)), o) : t;
    }, o.nice = function () {
      var t = Oi(r.map(u), e ? Math : ys);
      return n.domain(t), r = t.map(i), o;
    }, o.ticks = function () {
      var n = ji(r), o = [], a = n[0], c = n[1], s = Math.floor(u(a)), l = Math.ceil(u(c)), f = t % 1 ? 2 : t;
      if (isFinite(l - s)) {
        if (e) {
          for (; l > s; s++)
            for (var h = 1; f > h; h++)
              o.push(i(s) * h);
          o.push(i(s));
        } else
          for (o.push(i(s)); s++ < l;)
            for (var h = f - 1; h > 0; h--)
              o.push(i(s) * h);
        for (s = 0; o[s] < a; s++);
        for (l = o.length; o[l - 1] > c; l--);
        o = o.slice(s, l);
      }
      return o;
    }, o.tickFormat = function (n, t) {
      if (!arguments.length)
        return ms;
      arguments.length < 2 ? t = ms : 'function' != typeof t && (t = Go.format(t));
      var r, a = Math.max(0.1, n / o.ticks().length), c = e ? (r = 1e-12, Math.ceil) : (r = -1e-12, Math.floor);
      return function (n) {
        return n / i(c(u(n) + r)) <= a ? t(n) : '';
      };
    }, o.copy = function () {
      return Ki(n.copy(), t, e, r);
    }, Vi(o, n);
  }
  function Qi(n, t, e) {
    function r(t) {
      return n(u(t));
    }
    var u = no(t), i = no(1 / t);
    return r.invert = function (t) {
      return i(n.invert(t));
    }, r.domain = function (t) {
      return arguments.length ? (n.domain((e = t.map(Number)).map(u)), r) : e;
    }, r.ticks = function (n) {
      return Bi(e, n);
    }, r.tickFormat = function (n, t) {
      return Ji(e, n, t);
    }, r.nice = function (n) {
      return r.domain($i(e, n));
    }, r.exponent = function (o) {
      return arguments.length ? (u = no(t = o), i = no(1 / t), n.domain(e.map(u)), r) : t;
    }, r.copy = function () {
      return Qi(n.copy(), t, e);
    }, Vi(r, n);
  }
  function no(n) {
    return function (t) {
      return 0 > t ? -Math.pow(-t, n) : Math.pow(t, n);
    };
  }
  function to(n, t) {
    function e(e) {
      return i[((u.get(e) || ('range' === t.t ? u.set(e, n.push(e)) : 0 / 0)) - 1) % i.length];
    }
    function r(t, e) {
      return Go.range(n.length).map(function (n) {
        return t + e * n;
      });
    }
    var u, i, a;
    return e.domain = function (r) {
      if (!arguments.length)
        return n;
      n = [], u = new o();
      for (var i, a = -1, c = r.length; ++a < c;)
        u.has(i = r[a]) || u.set(i, n.push(i));
      return e[t.t].apply(e, t.a);
    }, e.range = function (n) {
      return arguments.length ? (i = n, a = 0, t = {
        t: 'range',
        a: arguments
      }, e) : i;
    }, e.rangePoints = function (u, o) {
      arguments.length < 2 && (o = 0);
      var c = u[0], s = u[1], l = (s - c) / (Math.max(1, n.length - 1) + o);
      return i = r(n.length < 2 ? (c + s) / 2 : c + l * o / 2, l), a = 0, t = {
        t: 'rangePoints',
        a: arguments
      }, e;
    }, e.rangeBands = function (u, o, c) {
      arguments.length < 2 && (o = 0), arguments.length < 3 && (c = o);
      var s = u[1] < u[0], l = u[s - 0], f = u[1 - s], h = (f - l) / (n.length - o + 2 * c);
      return i = r(l + h * c, h), s && i.reverse(), a = h * (1 - o), t = {
        t: 'rangeBands',
        a: arguments
      }, e;
    }, e.rangeRoundBands = function (u, o, c) {
      arguments.length < 2 && (o = 0), arguments.length < 3 && (c = o);
      var s = u[1] < u[0], l = u[s - 0], f = u[1 - s], h = Math.floor((f - l) / (n.length - o + 2 * c)), g = f - l - (n.length - o) * h;
      return i = r(l + Math.round(g / 2), h), s && i.reverse(), a = Math.round(h * (1 - o)), t = {
        t: 'rangeRoundBands',
        a: arguments
      }, e;
    }, e.rangeBand = function () {
      return a;
    }, e.rangeExtent = function () {
      return ji(t.a[0]);
    }, e.copy = function () {
      return to(n, t);
    }, e.domain(n);
  }
  function eo(e, r) {
    function u() {
      var n = 0, t = r.length;
      for (o = []; ++n < t;)
        o[n - 1] = Go.quantile(e, n / t);
      return i;
    }
    function i(n) {
      return isNaN(n = +n) ? void 0 : r[Go.bisect(o, n)];
    }
    var o;
    return i.domain = function (r) {
      return arguments.length ? (e = r.filter(t).sort(n), u()) : e;
    }, i.range = function (n) {
      return arguments.length ? (r = n, u()) : r;
    }, i.quantiles = function () {
      return o;
    }, i.invertExtent = function (n) {
      return n = r.indexOf(n), 0 > n ? [
        0 / 0,
        0 / 0
      ] : [
        n > 0 ? o[n - 1] : e[0],
        n < o.length ? o[n] : e[e.length - 1]
      ];
    }, i.copy = function () {
      return eo(e, r);
    }, u();
  }
  function ro(n, t, e) {
    function r(t) {
      return e[Math.max(0, Math.min(o, Math.floor(i * (t - n))))];
    }
    function u() {
      return i = e.length / (t - n), o = e.length - 1, r;
    }
    var i, o;
    return r.domain = function (e) {
      return arguments.length ? (n = +e[0], t = +e[e.length - 1], u()) : [
        n,
        t
      ];
    }, r.range = function (n) {
      return arguments.length ? (e = n, u()) : e;
    }, r.invertExtent = function (t) {
      return t = e.indexOf(t), t = 0 > t ? 0 / 0 : t / i + n, [
        t,
        t + 1 / i
      ];
    }, r.copy = function () {
      return ro(n, t, e);
    }, u();
  }
  function uo(n, t) {
    function e(e) {
      return e >= e ? t[Go.bisect(n, e)] : void 0;
    }
    return e.domain = function (t) {
      return arguments.length ? (n = t, e) : n;
    }, e.range = function (n) {
      return arguments.length ? (t = n, e) : t;
    }, e.invertExtent = function (e) {
      return e = t.indexOf(e), [
        n[e - 1],
        n[e]
      ];
    }, e.copy = function () {
      return uo(n, t);
    }, e;
  }
  function io(n) {
    function t(n) {
      return +n;
    }
    return t.invert = t, t.domain = t.range = function (e) {
      return arguments.length ? (n = e.map(t), t) : n;
    }, t.ticks = function (t) {
      return Bi(n, t);
    }, t.tickFormat = function (t, e) {
      return Ji(n, t, e);
    }, t.copy = function () {
      return io(n);
    }, t;
  }
  function oo(n) {
    return n.innerRadius;
  }
  function ao(n) {
    return n.outerRadius;
  }
  function co(n) {
    return n.startAngle;
  }
  function so(n) {
    return n.endAngle;
  }
  function lo(n) {
    function t(t) {
      function o() {
        s.push('M', i(n(l), a));
      }
      for (var c, s = [], l = [], f = -1, h = t.length, g = Et(e), p = Et(r); ++f < h;)
        u.call(this, c = t[f], f) ? l.push([
          +g.call(this, c, f),
          +p.call(this, c, f)
        ]) : l.length && (o(), l = []);
      return l.length && o(), s.length ? s.join('') : null;
    }
    var e = Ar, r = Cr, u = Ae, i = fo, o = i.key, a = 0.7;
    return t.x = function (n) {
      return arguments.length ? (e = n, t) : e;
    }, t.y = function (n) {
      return arguments.length ? (r = n, t) : r;
    }, t.defined = function (n) {
      return arguments.length ? (u = n, t) : u;
    }, t.interpolate = function (n) {
      return arguments.length ? (o = 'function' == typeof n ? i = n : (i = ks.get(n) || fo).key, t) : o;
    }, t.tension = function (n) {
      return arguments.length ? (a = n, t) : a;
    }, t;
  }
  function fo(n) {
    return n.join('L');
  }
  function ho(n) {
    return fo(n) + 'Z';
  }
  function go(n) {
    for (var t = 0, e = n.length, r = n[0], u = [
          r[0],
          ',',
          r[1]
        ]; ++t < e;)
      u.push('H', (r[0] + (r = n[t])[0]) / 2, 'V', r[1]);
    return e > 1 && u.push('H', r[0]), u.join('');
  }
  function po(n) {
    for (var t = 0, e = n.length, r = n[0], u = [
          r[0],
          ',',
          r[1]
        ]; ++t < e;)
      u.push('V', (r = n[t])[1], 'H', r[0]);
    return u.join('');
  }
  function vo(n) {
    for (var t = 0, e = n.length, r = n[0], u = [
          r[0],
          ',',
          r[1]
        ]; ++t < e;)
      u.push('H', (r = n[t])[0], 'V', r[1]);
    return u.join('');
  }
  function mo(n, t) {
    return n.length < 4 ? fo(n) : n[1] + Mo(n.slice(1, n.length - 1), _o(n, t));
  }
  function yo(n, t) {
    return n.length < 3 ? fo(n) : n[0] + Mo((n.push(n[0]), n), _o([n[n.length - 2]].concat(n, [n[1]]), t));
  }
  function xo(n, t) {
    return n.length < 3 ? fo(n) : n[0] + Mo(n, _o(n, t));
  }
  function Mo(n, t) {
    if (t.length < 1 || n.length != t.length && n.length != t.length + 2)
      return fo(n);
    var e = n.length != t.length, r = '', u = n[0], i = n[1], o = t[0], a = o, c = 1;
    if (e && (r += 'Q' + (i[0] - 2 * o[0] / 3) + ',' + (i[1] - 2 * o[1] / 3) + ',' + i[0] + ',' + i[1], u = n[1], c = 2), t.length > 1) {
      a = t[1], i = n[c], c++, r += 'C' + (u[0] + o[0]) + ',' + (u[1] + o[1]) + ',' + (i[0] - a[0]) + ',' + (i[1] - a[1]) + ',' + i[0] + ',' + i[1];
      for (var s = 2; s < t.length; s++, c++)
        i = n[c], a = t[s], r += 'S' + (i[0] - a[0]) + ',' + (i[1] - a[1]) + ',' + i[0] + ',' + i[1];
    }
    if (e) {
      var l = n[c];
      r += 'Q' + (i[0] + 2 * a[0] / 3) + ',' + (i[1] + 2 * a[1] / 3) + ',' + l[0] + ',' + l[1];
    }
    return r;
  }
  function _o(n, t) {
    for (var e, r = [], u = (1 - t) / 2, i = n[0], o = n[1], a = 1, c = n.length; ++a < c;)
      e = i, i = o, o = n[a], r.push([
        u * (o[0] - e[0]),
        u * (o[1] - e[1])
      ]);
    return r;
  }
  function bo(n) {
    if (n.length < 3)
      return fo(n);
    var t = 1, e = n.length, r = n[0], u = r[0], i = r[1], o = [
        u,
        u,
        u,
        (r = n[1])[0]
      ], a = [
        i,
        i,
        i,
        r[1]
      ], c = [
        u,
        ',',
        i,
        'L',
        Eo(Cs, o),
        ',',
        Eo(Cs, a)
      ];
    for (n.push(n[e - 1]); ++t <= e;)
      r = n[t], o.shift(), o.push(r[0]), a.shift(), a.push(r[1]), Ao(c, o, a);
    return n.pop(), c.push('L', r), c.join('');
  }
  function wo(n) {
    if (n.length < 4)
      return fo(n);
    for (var t, e = [], r = -1, u = n.length, i = [0], o = [0]; ++r < 3;)
      t = n[r], i.push(t[0]), o.push(t[1]);
    for (e.push(Eo(Cs, i) + ',' + Eo(Cs, o)), --r; ++r < u;)
      t = n[r], i.shift(), i.push(t[0]), o.shift(), o.push(t[1]), Ao(e, i, o);
    return e.join('');
  }
  function So(n) {
    for (var t, e, r = -1, u = n.length, i = u + 4, o = [], a = []; ++r < 4;)
      e = n[r % u], o.push(e[0]), a.push(e[1]);
    for (t = [
        Eo(Cs, o),
        ',',
        Eo(Cs, a)
      ], --r; ++r < i;)
      e = n[r % u], o.shift(), o.push(e[0]), a.shift(), a.push(e[1]), Ao(t, o, a);
    return t.join('');
  }
  function ko(n, t) {
    var e = n.length - 1;
    if (e)
      for (var r, u, i = n[0][0], o = n[0][1], a = n[e][0] - i, c = n[e][1] - o, s = -1; ++s <= e;)
        r = n[s], u = s / e, r[0] = t * r[0] + (1 - t) * (i + u * a), r[1] = t * r[1] + (1 - t) * (o + u * c);
    return bo(n);
  }
  function Eo(n, t) {
    return n[0] * t[0] + n[1] * t[1] + n[2] * t[2] + n[3] * t[3];
  }
  function Ao(n, t, e) {
    n.push('C', Eo(Es, t), ',', Eo(Es, e), ',', Eo(As, t), ',', Eo(As, e), ',', Eo(Cs, t), ',', Eo(Cs, e));
  }
  function Co(n, t) {
    return (t[1] - n[1]) / (t[0] - n[0]);
  }
  function No(n) {
    for (var t = 0, e = n.length - 1, r = [], u = n[0], i = n[1], o = r[0] = Co(u, i); ++t < e;)
      r[t] = (o + (o = Co(u = i, i = n[t + 1]))) / 2;
    return r[t] = o, r;
  }
  function Lo(n) {
    for (var t, e, r, u, i = [], o = No(n), a = -1, c = n.length - 1; ++a < c;)
      t = Co(n[a], n[a + 1]), fa(t) < Ta ? o[a] = o[a + 1] = 0 : (e = o[a] / t, r = o[a + 1] / t, u = e * e + r * r, u > 9 && (u = 3 * t / Math.sqrt(u), o[a] = u * e, o[a + 1] = u * r));
    for (a = -1; ++a <= c;)
      u = (n[Math.min(c, a + 1)][0] - n[Math.max(0, a - 1)][0]) / (6 * (1 + o[a] * o[a])), i.push([
        u || 0,
        o[a] * u || 0
      ]);
    return i;
  }
  function To(n) {
    return n.length < 3 ? fo(n) : n[0] + Mo(n, Lo(n));
  }
  function qo(n) {
    for (var t, e, r, u = -1, i = n.length; ++u < i;)
      t = n[u], e = t[0], r = t[1] + ws, t[0] = e * Math.cos(r), t[1] = e * Math.sin(r);
    return n;
  }
  function zo(n) {
    function t(t) {
      function c() {
        v.push('M', a(n(m), f), l, s(n(d.reverse()), f), 'Z');
      }
      for (var h, g, p, v = [], d = [], m = [], y = -1, x = t.length, M = Et(e), _ = Et(u), b = e === r ? function () {
            return g;
          } : Et(r), w = u === i ? function () {
            return p;
          } : Et(i); ++y < x;)
        o.call(this, h = t[y], y) ? (d.push([
          g = +M.call(this, h, y),
          p = +_.call(this, h, y)
        ]), m.push([
          +b.call(this, h, y),
          +w.call(this, h, y)
        ])) : d.length && (c(), d = [], m = []);
      return d.length && c(), v.length ? v.join('') : null;
    }
    var e = Ar, r = Ar, u = 0, i = Cr, o = Ae, a = fo, c = a.key, s = a, l = 'L', f = 0.7;
    return t.x = function (n) {
      return arguments.length ? (e = r = n, t) : r;
    }, t.x0 = function (n) {
      return arguments.length ? (e = n, t) : e;
    }, t.x1 = function (n) {
      return arguments.length ? (r = n, t) : r;
    }, t.y = function (n) {
      return arguments.length ? (u = i = n, t) : i;
    }, t.y0 = function (n) {
      return arguments.length ? (u = n, t) : u;
    }, t.y1 = function (n) {
      return arguments.length ? (i = n, t) : i;
    }, t.defined = function (n) {
      return arguments.length ? (o = n, t) : o;
    }, t.interpolate = function (n) {
      return arguments.length ? (c = 'function' == typeof n ? a = n : (a = ks.get(n) || fo).key, s = a.reverse || a, l = a.closed ? 'M' : 'L', t) : c;
    }, t.tension = function (n) {
      return arguments.length ? (f = n, t) : f;
    }, t;
  }
  function Ro(n) {
    return n.radius;
  }
  function Do(n) {
    return [
      n.x,
      n.y
    ];
  }
  function Po(n) {
    return function () {
      var t = n.apply(this, arguments), e = t[0], r = t[1] + ws;
      return [
        e * Math.cos(r),
        e * Math.sin(r)
      ];
    };
  }
  function Uo() {
    return 64;
  }
  function jo() {
    return 'circle';
  }
  function Ho(n) {
    var t = Math.sqrt(n / Ca);
    return 'M0,' + t + 'A' + t + ',' + t + ' 0 1,1 0,' + -t + 'A' + t + ',' + t + ' 0 1,1 0,' + t + 'Z';
  }
  function Fo(n, t) {
    return da(n, Rs), n.id = t, n;
  }
  function Oo(n, t, e, r) {
    var u = n.id;
    return P(n, 'function' == typeof e ? function (n, i, o) {
      n.__transition__[u].tween.set(t, r(e.call(n, n.__data__, i, o)));
    } : (e = r(e), function (n) {
      n.__transition__[u].tween.set(t, e);
    }));
  }
  function Io(n) {
    return null == n && (n = ''), function () {
      this.textContent = n;
    };
  }
  function Yo(n, t, e, r) {
    var u = n.__transition__ || (n.__transition__ = {
        active: 0,
        count: 0
      }), i = u[e];
    if (!i) {
      var a = r.time;
      i = u[e] = {
        tween: new o(),
        time: a,
        ease: r.ease,
        delay: r.delay,
        duration: r.duration
      }, ++u.count, Go.timer(function (r) {
        function o(r) {
          return u.active > e ? s() : (u.active = e, i.event && i.event.start.call(n, l, t), i.tween.forEach(function (e, r) {
            (r = r.call(n, l, t)) && v.push(r);
          }), Go.timer(function () {
            return p.c = c(r || 1) ? Ae : c, 1;
          }, 0, a), void 0);
        }
        function c(r) {
          if (u.active !== e)
            return s();
          for (var o = r / g, a = f(o), c = v.length; c > 0;)
            v[--c].call(n, a);
          return o >= 1 ? (i.event && i.event.end.call(n, l, t), s()) : void 0;
        }
        function s() {
          return --u.count ? delete u[e] : delete n.__transition__, 1;
        }
        var l = n.__data__, f = i.ease, h = i.delay, g = i.duration, p = nc, v = [];
        return p.t = h + a, r >= h ? o(r - h) : (p.c = o, void 0);
      }, 0, a);
    }
  }
  function Zo(n, t) {
    n.attr('transform', function (n) {
      return 'translate(' + t(n) + ',0)';
    });
  }
  function Vo(n, t) {
    n.attr('transform', function (n) {
      return 'translate(0,' + t(n) + ')';
    });
  }
  function $o(n) {
    return n.toISOString();
  }
  function Xo(n, t, e) {
    function r(t) {
      return n(t);
    }
    function u(n, e) {
      var r = n[1] - n[0], u = r / e, i = Go.bisect(Ys, u);
      return i == Ys.length ? [
        t.year,
        Xi(n.map(function (n) {
          return n / 31536000000;
        }), e)[2]
      ] : i ? t[u / Ys[i - 1] < Ys[i] / u ? i - 1 : i] : [
        $s,
        Xi(n, e)[2]
      ];
    }
    return r.invert = function (t) {
      return Bo(n.invert(t));
    }, r.domain = function (t) {
      return arguments.length ? (n.domain(t), r) : n.domain().map(Bo);
    }, r.nice = function (n, t) {
      function e(e) {
        return !isNaN(e) && !n.range(e, Bo(+e + 1), t).length;
      }
      var i = r.domain(), o = ji(i), a = null == n ? u(o, 10) : 'number' == typeof n && u(o, n);
      return a && (n = a[0], t = a[1]), r.domain(Oi(i, t > 1 ? {
        floor: function (t) {
          for (; e(t = n.floor(t));)
            t = Bo(t - 1);
          return t;
        },
        ceil: function (t) {
          for (; e(t = n.ceil(t));)
            t = Bo(+t + 1);
          return t;
        }
      } : n));
    }, r.ticks = function (n, t) {
      var e = ji(r.domain()), i = null == n ? u(e, 10) : 'number' == typeof n ? u(e, n) : !n.range && [
          { range: n },
          t
        ];
      return i && (n = i[0], t = i[1]), n.range(e[0], Bo(+e[1] + 1), 1 > t ? 1 : t);
    }, r.tickFormat = function () {
      return e;
    }, r.copy = function () {
      return Xo(n.copy(), t, e);
    }, Vi(r, n);
  }
  function Bo(n) {
    return new Date(n);
  }
  function Jo(n) {
    return JSON.parse(n.responseText);
  }
  function Wo(n) {
    var t = na.createRange();
    return t.selectNode(na.body), t.createContextualFragment(n.responseText);
  }
  var Go = { version: '3.4.6' };
  Date.now || (Date.now = function () {
    return +new Date();
  });
  var Ko = [].slice, Qo = function (n) {
      return Ko.call(n);
    }, na = document, ta = na.documentElement, ea = window;
  try {
    Qo(ta.childNodes)[0].nodeType;
  } catch (ra) {
    Qo = function (n) {
      for (var t = n.length, e = new Array(t); t--;)
        e[t] = n[t];
      return e;
    };
  }
  try {
    na.createElement('div').style.setProperty('opacity', 0, '');
  } catch (ua) {
    var ia = ea.Element.prototype, oa = ia.setAttribute, aa = ia.setAttributeNS, ca = ea.CSSStyleDeclaration.prototype, sa = ca.setProperty;
    ia.setAttribute = function (n, t) {
      oa.call(this, n, t + '');
    }, ia.setAttributeNS = function (n, t, e) {
      aa.call(this, n, t, e + '');
    }, ca.setProperty = function (n, t, e) {
      sa.call(this, n, t + '', e);
    };
  }
  Go.ascending = n, Go.descending = function (n, t) {
    return n > t ? -1 : t > n ? 1 : t >= n ? 0 : 0 / 0;
  }, Go.min = function (n, t) {
    var e, r, u = -1, i = n.length;
    if (1 === arguments.length) {
      for (; ++u < i && !(null != (e = n[u]) && e >= e);)
        e = void 0;
      for (; ++u < i;)
        null != (r = n[u]) && e > r && (e = r);
    } else {
      for (; ++u < i && !(null != (e = t.call(n, n[u], u)) && e >= e);)
        e = void 0;
      for (; ++u < i;)
        null != (r = t.call(n, n[u], u)) && e > r && (e = r);
    }
    return e;
  }, Go.max = function (n, t) {
    var e, r, u = -1, i = n.length;
    if (1 === arguments.length) {
      for (; ++u < i && !(null != (e = n[u]) && e >= e);)
        e = void 0;
      for (; ++u < i;)
        null != (r = n[u]) && r > e && (e = r);
    } else {
      for (; ++u < i && !(null != (e = t.call(n, n[u], u)) && e >= e);)
        e = void 0;
      for (; ++u < i;)
        null != (r = t.call(n, n[u], u)) && r > e && (e = r);
    }
    return e;
  }, Go.extent = function (n, t) {
    var e, r, u, i = -1, o = n.length;
    if (1 === arguments.length) {
      for (; ++i < o && !(null != (e = u = n[i]) && e >= e);)
        e = u = void 0;
      for (; ++i < o;)
        null != (r = n[i]) && (e > r && (e = r), r > u && (u = r));
    } else {
      for (; ++i < o && !(null != (e = u = t.call(n, n[i], i)) && e >= e);)
        e = void 0;
      for (; ++i < o;)
        null != (r = t.call(n, n[i], i)) && (e > r && (e = r), r > u && (u = r));
    }
    return [
      e,
      u
    ];
  }, Go.sum = function (n, t) {
    var e, r = 0, u = n.length, i = -1;
    if (1 === arguments.length)
      for (; ++i < u;)
        isNaN(e = +n[i]) || (r += e);
    else
      for (; ++i < u;)
        isNaN(e = +t.call(n, n[i], i)) || (r += e);
    return r;
  }, Go.mean = function (n, e) {
    var r, u = 0, i = n.length, o = -1, a = i;
    if (1 === arguments.length)
      for (; ++o < i;)
        t(r = n[o]) ? u += r : --a;
    else
      for (; ++o < i;)
        t(r = e.call(n, n[o], o)) ? u += r : --a;
    return a ? u / a : void 0;
  }, Go.quantile = function (n, t) {
    var e = (n.length - 1) * t + 1, r = Math.floor(e), u = +n[r - 1], i = e - r;
    return i ? u + i * (n[r] - u) : u;
  }, Go.median = function (e, r) {
    return arguments.length > 1 && (e = e.map(r)), e = e.filter(t), e.length ? Go.quantile(e.sort(n), 0.5) : void 0;
  };
  var la = e(n);
  Go.bisectLeft = la.left, Go.bisect = Go.bisectRight = la.right, Go.bisector = function (t) {
    return e(1 === t.length ? function (e, r) {
      return n(t(e), r);
    } : t);
  }, Go.shuffle = function (n) {
    for (var t, e, r = n.length; r;)
      e = 0 | Math.random() * r--, t = n[r], n[r] = n[e], n[e] = t;
    return n;
  }, Go.permute = function (n, t) {
    for (var e = t.length, r = new Array(e); e--;)
      r[e] = n[t[e]];
    return r;
  }, Go.pairs = function (n) {
    for (var t, e = 0, r = n.length - 1, u = n[0], i = new Array(0 > r ? 0 : r); r > e;)
      i[e] = [
        t = u,
        u = n[++e]
      ];
    return i;
  }, Go.zip = function () {
    if (!(u = arguments.length))
      return [];
    for (var n = -1, t = Go.min(arguments, r), e = new Array(t); ++n < t;)
      for (var u, i = -1, o = e[n] = new Array(u); ++i < u;)
        o[i] = arguments[i][n];
    return e;
  }, Go.transpose = function (n) {
    return Go.zip.apply(Go, n);
  }, Go.keys = function (n) {
    var t = [];
    for (var e in n)
      t.push(e);
    return t;
  }, Go.values = function (n) {
    var t = [];
    for (var e in n)
      t.push(n[e]);
    return t;
  }, Go.entries = function (n) {
    var t = [];
    for (var e in n)
      t.push({
        key: e,
        value: n[e]
      });
    return t;
  }, Go.merge = function (n) {
    for (var t, e, r, u = n.length, i = -1, o = 0; ++i < u;)
      o += n[i].length;
    for (e = new Array(o); --u >= 0;)
      for (r = n[u], t = r.length; --t >= 0;)
        e[--o] = r[t];
    return e;
  };
  var fa = Math.abs;
  Go.range = function (n, t, e) {
    if (arguments.length < 3 && (e = 1, arguments.length < 2 && (t = n, n = 0)), 1 / 0 === (t - n) / e)
      throw new Error('infinite range');
    var r, i = [], o = u(fa(e)), a = -1;
    if (n *= o, t *= o, e *= o, 0 > e)
      for (; (r = n + e * ++a) > t;)
        i.push(r / o);
    else
      for (; (r = n + e * ++a) < t;)
        i.push(r / o);
    return i;
  }, Go.map = function (n) {
    var t = new o();
    if (n instanceof o)
      n.forEach(function (n, e) {
        t.set(n, e);
      });
    else
      for (var e in n)
        t.set(e, n[e]);
    return t;
  }, i(o, {
    has: a,
    get: function (n) {
      return this[ha + n];
    },
    set: function (n, t) {
      return this[ha + n] = t;
    },
    remove: c,
    keys: s,
    values: function () {
      var n = [];
      return this.forEach(function (t, e) {
        n.push(e);
      }), n;
    },
    entries: function () {
      var n = [];
      return this.forEach(function (t, e) {
        n.push({
          key: t,
          value: e
        });
      }), n;
    },
    size: l,
    empty: f,
    forEach: function (n) {
      for (var t in this)
        t.charCodeAt(0) === ga && n.call(this, t.substring(1), this[t]);
    }
  });
  var ha = '\0', ga = ha.charCodeAt(0);
  Go.nest = function () {
    function n(t, a, c) {
      if (c >= i.length)
        return r ? r.call(u, a) : e ? a.sort(e) : a;
      for (var s, l, f, h, g = -1, p = a.length, v = i[c++], d = new o(); ++g < p;)
        (h = d.get(s = v(l = a[g]))) ? h.push(l) : d.set(s, [l]);
      return t ? (l = t(), f = function (e, r) {
        l.set(e, n(t, r, c));
      }) : (l = {}, f = function (e, r) {
        l[e] = n(t, r, c);
      }), d.forEach(f), l;
    }
    function t(n, e) {
      if (e >= i.length)
        return n;
      var r = [], u = a[e++];
      return n.forEach(function (n, u) {
        r.push({
          key: n,
          values: t(u, e)
        });
      }), u ? r.sort(function (n, t) {
        return u(n.key, t.key);
      }) : r;
    }
    var e, r, u = {}, i = [], a = [];
    return u.map = function (t, e) {
      return n(e, t, 0);
    }, u.entries = function (e) {
      return t(n(Go.map, e, 0), 0);
    }, u.key = function (n) {
      return i.push(n), u;
    }, u.sortKeys = function (n) {
      return a[i.length - 1] = n, u;
    }, u.sortValues = function (n) {
      return e = n, u;
    }, u.rollup = function (n) {
      return r = n, u;
    }, u;
  }, Go.set = function (n) {
    var t = new h();
    if (n)
      for (var e = 0, r = n.length; r > e; ++e)
        t.add(n[e]);
    return t;
  }, i(h, {
    has: a,
    add: function (n) {
      return this[ha + n] = !0, n;
    },
    remove: function (n) {
      return n = ha + n, n in this && delete this[n];
    },
    values: s,
    size: l,
    empty: f,
    forEach: function (n) {
      for (var t in this)
        t.charCodeAt(0) === ga && n.call(this, t.substring(1));
    }
  }), Go.behavior = {}, Go.rebind = function (n, t) {
    for (var e, r = 1, u = arguments.length; ++r < u;)
      n[e = arguments[r]] = g(n, t, t[e]);
    return n;
  };
  var pa = [
      'webkit',
      'ms',
      'moz',
      'Moz',
      'o',
      'O'
    ];
  Go.dispatch = function () {
    for (var n = new d(), t = -1, e = arguments.length; ++t < e;)
      n[arguments[t]] = m(n);
    return n;
  }, d.prototype.on = function (n, t) {
    var e = n.indexOf('.'), r = '';
    if (e >= 0 && (r = n.substring(e + 1), n = n.substring(0, e)), n)
      return arguments.length < 2 ? this[n].on(r) : this[n].on(r, t);
    if (2 === arguments.length) {
      if (null == t)
        for (n in this)
          this.hasOwnProperty(n) && this[n].on(r, null);
      return this;
    }
  }, Go.event = null, Go.requote = function (n) {
    return n.replace(va, '\\$&');
  };
  var va = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g, da = {}.__proto__ ? function (n, t) {
      n.__proto__ = t;
    } : function (n, t) {
      for (var e in t)
        n[e] = t[e];
    }, ma = function (n, t) {
      return t.querySelector(n);
    }, ya = function (n, t) {
      return t.querySelectorAll(n);
    }, xa = ta[p(ta, 'matchesSelector')], Ma = function (n, t) {
      return xa.call(n, t);
    };
  'function' == typeof Sizzle && (ma = function (n, t) {
    return Sizzle(n, t)[0] || null;
  }, ya = Sizzle, Ma = Sizzle.matchesSelector), Go.selection = function () {
    return Sa;
  };
  var _a = Go.selection.prototype = [];
  _a.select = function (n) {
    var t, e, r, u, i = [];
    n = b(n);
    for (var o = -1, a = this.length; ++o < a;) {
      i.push(t = []), t.parentNode = (r = this[o]).parentNode;
      for (var c = -1, s = r.length; ++c < s;)
        (u = r[c]) ? (t.push(e = n.call(u, u.__data__, c, o)), e && '__data__' in u && (e.__data__ = u.__data__)) : t.push(null);
    }
    return _(i);
  }, _a.selectAll = function (n) {
    var t, e, r = [];
    n = w(n);
    for (var u = -1, i = this.length; ++u < i;)
      for (var o = this[u], a = -1, c = o.length; ++a < c;)
        (e = o[a]) && (r.push(t = Qo(n.call(e, e.__data__, a, u))), t.parentNode = e);
    return _(r);
  };
  var ba = {
      svg: 'http://www.w3.org/2000/svg',
      xhtml: 'http://www.w3.org/1999/xhtml',
      xlink: 'http://www.w3.org/1999/xlink',
      xml: 'http://www.w3.org/XML/1998/namespace',
      xmlns: 'http://www.w3.org/2000/xmlns/'
    };
  Go.ns = {
    prefix: ba,
    qualify: function (n) {
      var t = n.indexOf(':'), e = n;
      return t >= 0 && (e = n.substring(0, t), n = n.substring(t + 1)), ba.hasOwnProperty(e) ? {
        space: ba[e],
        local: n
      } : n;
    }
  }, _a.attr = function (n, t) {
    if (arguments.length < 2) {
      if ('string' == typeof n) {
        var e = this.node();
        return n = Go.ns.qualify(n), n.local ? e.getAttributeNS(n.space, n.local) : e.getAttribute(n);
      }
      for (t in n)
        this.each(S(t, n[t]));
      return this;
    }
    return this.each(S(n, t));
  }, _a.classed = function (n, t) {
    if (arguments.length < 2) {
      if ('string' == typeof n) {
        var e = this.node(), r = (n = A(n)).length, u = -1;
        if (t = e.classList) {
          for (; ++u < r;)
            if (!t.contains(n[u]))
              return !1;
        } else
          for (t = e.getAttribute('class'); ++u < r;)
            if (!E(n[u]).test(t))
              return !1;
        return !0;
      }
      for (t in n)
        this.each(C(t, n[t]));
      return this;
    }
    return this.each(C(n, t));
  }, _a.style = function (n, t, e) {
    var r = arguments.length;
    if (3 > r) {
      if ('string' != typeof n) {
        2 > r && (t = '');
        for (e in n)
          this.each(L(e, n[e], t));
        return this;
      }
      if (2 > r)
        return ea.getComputedStyle(this.node(), null).getPropertyValue(n);
      e = '';
    }
    return this.each(L(n, t, e));
  }, _a.property = function (n, t) {
    if (arguments.length < 2) {
      if ('string' == typeof n)
        return this.node()[n];
      for (t in n)
        this.each(T(t, n[t]));
      return this;
    }
    return this.each(T(n, t));
  }, _a.text = function (n) {
    return arguments.length ? this.each('function' == typeof n ? function () {
      var t = n.apply(this, arguments);
      this.textContent = null == t ? '' : t;
    } : null == n ? function () {
      this.textContent = '';
    } : function () {
      this.textContent = n;
    }) : this.node().textContent;
  }, _a.html = function (n) {
    return arguments.length ? this.each('function' == typeof n ? function () {
      var t = n.apply(this, arguments);
      this.innerHTML = null == t ? '' : t;
    } : null == n ? function () {
      this.innerHTML = '';
    } : function () {
      this.innerHTML = n;
    }) : this.node().innerHTML;
  }, _a.append = function (n) {
    return n = q(n), this.select(function () {
      return this.appendChild(n.apply(this, arguments));
    });
  }, _a.insert = function (n, t) {
    return n = q(n), t = b(t), this.select(function () {
      return this.insertBefore(n.apply(this, arguments), t.apply(this, arguments) || null);
    });
  }, _a.remove = function () {
    return this.each(function () {
      var n = this.parentNode;
      n && n.removeChild(this);
    });
  }, _a.data = function (n, t) {
    function e(n, e) {
      var r, u, i, a = n.length, f = e.length, h = Math.min(a, f), g = new Array(f), p = new Array(f), v = new Array(a);
      if (t) {
        var d, m = new o(), y = new o(), x = [];
        for (r = -1; ++r < a;)
          d = t.call(u = n[r], u.__data__, r), m.has(d) ? v[r] = u : m.set(d, u), x.push(d);
        for (r = -1; ++r < f;)
          d = t.call(e, i = e[r], r), (u = m.get(d)) ? (g[r] = u, u.__data__ = i) : y.has(d) || (p[r] = z(i)), y.set(d, i), m.remove(d);
        for (r = -1; ++r < a;)
          m.has(x[r]) && (v[r] = n[r]);
      } else {
        for (r = -1; ++r < h;)
          u = n[r], i = e[r], u ? (u.__data__ = i, g[r] = u) : p[r] = z(i);
        for (; f > r; ++r)
          p[r] = z(e[r]);
        for (; a > r; ++r)
          v[r] = n[r];
      }
      p.update = g, p.parentNode = g.parentNode = v.parentNode = n.parentNode, c.push(p), s.push(g), l.push(v);
    }
    var r, u, i = -1, a = this.length;
    if (!arguments.length) {
      for (n = new Array(a = (r = this[0]).length); ++i < a;)
        (u = r[i]) && (n[i] = u.__data__);
      return n;
    }
    var c = U([]), s = _([]), l = _([]);
    if ('function' == typeof n)
      for (; ++i < a;)
        e(r = this[i], n.call(r, r.parentNode.__data__, i));
    else
      for (; ++i < a;)
        e(r = this[i], n);
    return s.enter = function () {
      return c;
    }, s.exit = function () {
      return l;
    }, s;
  }, _a.datum = function (n) {
    return arguments.length ? this.property('__data__', n) : this.property('__data__');
  }, _a.filter = function (n) {
    var t, e, r, u = [];
    'function' != typeof n && (n = R(n));
    for (var i = 0, o = this.length; o > i; i++) {
      u.push(t = []), t.parentNode = (e = this[i]).parentNode;
      for (var a = 0, c = e.length; c > a; a++)
        (r = e[a]) && n.call(r, r.__data__, a, i) && t.push(r);
    }
    return _(u);
  }, _a.order = function () {
    for (var n = -1, t = this.length; ++n < t;)
      for (var e, r = this[n], u = r.length - 1, i = r[u]; --u >= 0;)
        (e = r[u]) && (i && i !== e.nextSibling && i.parentNode.insertBefore(e, i), i = e);
    return this;
  }, _a.sort = function (n) {
    n = D.apply(this, arguments);
    for (var t = -1, e = this.length; ++t < e;)
      this[t].sort(n);
    return this.order();
  }, _a.each = function (n) {
    return P(this, function (t, e, r) {
      n.call(t, t.__data__, e, r);
    });
  }, _a.call = function (n) {
    var t = Qo(arguments);
    return n.apply(t[0] = this, t), this;
  }, _a.empty = function () {
    return !this.node();
  }, _a.node = function () {
    for (var n = 0, t = this.length; t > n; n++)
      for (var e = this[n], r = 0, u = e.length; u > r; r++) {
        var i = e[r];
        if (i)
          return i;
      }
    return null;
  }, _a.size = function () {
    var n = 0;
    return this.each(function () {
      ++n;
    }), n;
  };
  var wa = [];
  Go.selection.enter = U, Go.selection.enter.prototype = wa, wa.append = _a.append, wa.empty = _a.empty, wa.node = _a.node, wa.call = _a.call, wa.size = _a.size, wa.select = function (n) {
    for (var t, e, r, u, i, o = [], a = -1, c = this.length; ++a < c;) {
      r = (u = this[a]).update, o.push(t = []), t.parentNode = u.parentNode;
      for (var s = -1, l = u.length; ++s < l;)
        (i = u[s]) ? (t.push(r[s] = e = n.call(u.parentNode, i.__data__, s, a)), e.__data__ = i.__data__) : t.push(null);
    }
    return _(o);
  }, wa.insert = function (n, t) {
    return arguments.length < 2 && (t = j(this)), _a.insert.call(this, n, t);
  }, _a.transition = function () {
    for (var n, t, e = Ls || ++Ds, r = [], u = Ts || {
          time: Date.now(),
          ease: wu,
          delay: 0,
          duration: 250
        }, i = -1, o = this.length; ++i < o;) {
      r.push(n = []);
      for (var a = this[i], c = -1, s = a.length; ++c < s;)
        (t = a[c]) && Yo(t, c, e, u), n.push(t);
    }
    return Fo(r, e);
  }, _a.interrupt = function () {
    return this.each(H);
  }, Go.select = function (n) {
    var t = ['string' == typeof n ? ma(n, na) : n];
    return t.parentNode = ta, _([t]);
  }, Go.selectAll = function (n) {
    var t = Qo('string' == typeof n ? ya(n, na) : n);
    return t.parentNode = ta, _([t]);
  };
  var Sa = Go.select(ta);
  _a.on = function (n, t, e) {
    var r = arguments.length;
    if (3 > r) {
      if ('string' != typeof n) {
        2 > r && (t = !1);
        for (e in n)
          this.each(F(e, n[e], t));
        return this;
      }
      if (2 > r)
        return (r = this.node()['__on' + n]) && r._;
      e = !1;
    }
    return this.each(F(n, t, e));
  };
  var ka = Go.map({
      mouseenter: 'mouseover',
      mouseleave: 'mouseout'
    });
  ka.forEach(function (n) {
    'on' + n in na && ka.remove(n);
  });
  var Ea = 'onselectstart' in na ? null : p(ta.style, 'userSelect'), Aa = 0;
  Go.mouse = function (n) {
    return Z(n, x());
  }, Go.touches = function (n, t) {
    return arguments.length < 2 && (t = x().touches), t ? Qo(t).map(function (t) {
      var e = Z(n, t);
      return e.identifier = t.identifier, e;
    }) : [];
  }, Go.behavior.drag = function () {
    function n() {
      this.on('mousedown.drag', u).on('touchstart.drag', i);
    }
    function t(n, t, u, i, o) {
      return function () {
        function a() {
          var n, e, r = t(h, v);
          r && (n = r[0] - x[0], e = r[1] - x[1], p |= n | e, x = r, g({
            type: 'drag',
            x: r[0] + s[0],
            y: r[1] + s[1],
            dx: n,
            dy: e
          }));
        }
        function c() {
          t(h, v) && (m.on(i + d, null).on(o + d, null), y(p && Go.event.target === f), g({ type: 'dragend' }));
        }
        var s, l = this, f = Go.event.target, h = l.parentNode, g = e.of(l, arguments), p = 0, v = n(), d = '.drag' + (null == v ? '' : '-' + v), m = Go.select(u()).on(i + d, a).on(o + d, c), y = Y(), x = t(h, v);
        r ? (s = r.apply(l, arguments), s = [
          s.x - x[0],
          s.y - x[1]
        ]) : s = [
          0,
          0
        ], g({ type: 'dragstart' });
      };
    }
    var e = M(n, 'drag', 'dragstart', 'dragend'), r = null, u = t(v, Go.mouse, X, 'mousemove', 'mouseup'), i = t(V, Go.touch, $, 'touchmove', 'touchend');
    return n.origin = function (t) {
      return arguments.length ? (r = t, n) : r;
    }, Go.rebind(n, e, 'on');
  };
  var Ca = Math.PI, Na = 2 * Ca, La = Ca / 2, Ta = 0.000001, qa = Ta * Ta, za = Ca / 180, Ra = 180 / Ca, Da = Math.SQRT2, Pa = 2, Ua = 4;
  Go.interpolateZoom = function (n, t) {
    function e(n) {
      var t = n * y;
      if (m) {
        var e = Q(v), o = i / (Pa * h) * (e * nt(Da * t + v) - K(v));
        return [
          r + o * s,
          u + o * l,
          i * e / Q(Da * t + v)
        ];
      }
      return [
        r + n * s,
        u + n * l,
        i * Math.exp(Da * t)
      ];
    }
    var r = n[0], u = n[1], i = n[2], o = t[0], a = t[1], c = t[2], s = o - r, l = a - u, f = s * s + l * l, h = Math.sqrt(f), g = (c * c - i * i + Ua * f) / (2 * i * Pa * h), p = (c * c - i * i - Ua * f) / (2 * c * Pa * h), v = Math.log(Math.sqrt(g * g + 1) - g), d = Math.log(Math.sqrt(p * p + 1) - p), m = d - v, y = (m || Math.log(c / i)) / Da;
    return e.duration = 1000 * y, e;
  }, Go.behavior.zoom = function () {
    function n(n) {
      n.on(A, s).on(Fa + '.zoom', f).on(C, h).on('dblclick.zoom', g).on(L, l);
    }
    function t(n) {
      return [
        (n[0] - S.x) / S.k,
        (n[1] - S.y) / S.k
      ];
    }
    function e(n) {
      return [
        n[0] * S.k + S.x,
        n[1] * S.k + S.y
      ];
    }
    function r(n) {
      S.k = Math.max(E[0], Math.min(E[1], n));
    }
    function u(n, t) {
      t = e(t), S.x += n[0] - t[0], S.y += n[1] - t[1];
    }
    function i() {
      _ && _.domain(x.range().map(function (n) {
        return (n - S.x) / S.k;
      }).map(x.invert)), w && w.domain(b.range().map(function (n) {
        return (n - S.y) / S.k;
      }).map(b.invert));
    }
    function o(n) {
      n({ type: 'zoomstart' });
    }
    function a(n) {
      i(), n({
        type: 'zoom',
        scale: S.k,
        translate: [
          S.x,
          S.y
        ]
      });
    }
    function c(n) {
      n({ type: 'zoomend' });
    }
    function s() {
      function n() {
        l = 1, u(Go.mouse(r), g), a(s);
      }
      function e() {
        f.on(C, ea === r ? h : null).on(N, null), p(l && Go.event.target === i), c(s);
      }
      var r = this, i = Go.event.target, s = T.of(r, arguments), l = 0, f = Go.select(ea).on(C, n).on(N, e), g = t(Go.mouse(r)), p = Y();
      H.call(r), o(s);
    }
    function l() {
      function n() {
        var n = Go.touches(g);
        return h = S.k, n.forEach(function (n) {
          n.identifier in v && (v[n.identifier] = t(n));
        }), n;
      }
      function e() {
        for (var t = Go.event.changedTouches, e = 0, i = t.length; i > e; ++e)
          v[t[e].identifier] = null;
        var o = n(), c = Date.now();
        if (1 === o.length) {
          if (500 > c - m) {
            var s = o[0], l = v[s.identifier];
            r(2 * S.k), u(s, l), y(), a(p);
          }
          m = c;
        } else if (o.length > 1) {
          var s = o[0], f = o[1], h = s[0] - f[0], g = s[1] - f[1];
          d = h * h + g * g;
        }
      }
      function i() {
        for (var n, t, e, i, o = Go.touches(g), c = 0, s = o.length; s > c; ++c, i = null)
          if (e = o[c], i = v[e.identifier]) {
            if (t)
              break;
            n = e, t = i;
          }
        if (i) {
          var l = (l = e[0] - n[0]) * l + (l = e[1] - n[1]) * l, f = d && Math.sqrt(l / d);
          n = [
            (n[0] + e[0]) / 2,
            (n[1] + e[1]) / 2
          ], t = [
            (t[0] + i[0]) / 2,
            (t[1] + i[1]) / 2
          ], r(f * h);
        }
        m = null, u(n, t), a(p);
      }
      function f() {
        if (Go.event.touches.length) {
          for (var t = Go.event.changedTouches, e = 0, r = t.length; r > e; ++e)
            delete v[t[e].identifier];
          for (var u in v)
            return void n();
        }
        b.on(x, null), w.on(A, s).on(L, l), k(), c(p);
      }
      var h, g = this, p = T.of(g, arguments), v = {}, d = 0, x = '.zoom-' + Go.event.changedTouches[0].identifier, M = 'touchmove' + x, _ = 'touchend' + x, b = Go.select(Go.event.target).on(M, i).on(_, f), w = Go.select(g).on(A, null).on(L, e), k = Y();
      H.call(g), e(), o(p);
    }
    function f() {
      var n = T.of(this, arguments);
      d ? clearTimeout(d) : (H.call(this), o(n)), d = setTimeout(function () {
        d = null, c(n);
      }, 50), y();
      var e = v || Go.mouse(this);
      p || (p = t(e)), r(Math.pow(2, 0.002 * ja()) * S.k), u(e, p), a(n);
    }
    function h() {
      p = null;
    }
    function g() {
      var n = T.of(this, arguments), e = Go.mouse(this), i = t(e), s = Math.log(S.k) / Math.LN2;
      o(n), r(Math.pow(2, Go.event.shiftKey ? Math.ceil(s) - 1 : Math.floor(s) + 1)), u(e, i), a(n), c(n);
    }
    var p, v, d, m, x, _, b, w, S = {
        x: 0,
        y: 0,
        k: 1
      }, k = [
        960,
        500
      ], E = Ha, A = 'mousedown.zoom', C = 'mousemove.zoom', N = 'mouseup.zoom', L = 'touchstart.zoom', T = M(n, 'zoomstart', 'zoom', 'zoomend');
    return n.event = function (n) {
      n.each(function () {
        var n = T.of(this, arguments), t = S;
        Ls ? Go.select(this).transition().each('start.zoom', function () {
          S = this.__chart__ || {
            x: 0,
            y: 0,
            k: 1
          }, o(n);
        }).tween('zoom:zoom', function () {
          var e = k[0], r = k[1], u = e / 2, i = r / 2, o = Go.interpolateZoom([
              (u - S.x) / S.k,
              (i - S.y) / S.k,
              e / S.k
            ], [
              (u - t.x) / t.k,
              (i - t.y) / t.k,
              e / t.k
            ]);
          return function (t) {
            var r = o(t), c = e / r[2];
            this.__chart__ = S = {
              x: u - r[0] * c,
              y: i - r[1] * c,
              k: c
            }, a(n);
          };
        }).each('end.zoom', function () {
          c(n);
        }) : (this.__chart__ = S, o(n), a(n), c(n));
      });
    }, n.translate = function (t) {
      return arguments.length ? (S = {
        x: +t[0],
        y: +t[1],
        k: S.k
      }, i(), n) : [
        S.x,
        S.y
      ];
    }, n.scale = function (t) {
      return arguments.length ? (S = {
        x: S.x,
        y: S.y,
        k: +t
      }, i(), n) : S.k;
    }, n.scaleExtent = function (t) {
      return arguments.length ? (E = null == t ? Ha : [
        +t[0],
        +t[1]
      ], n) : E;
    }, n.center = function (t) {
      return arguments.length ? (v = t && [
        +t[0],
        +t[1]
      ], n) : v;
    }, n.size = function (t) {
      return arguments.length ? (k = t && [
        +t[0],
        +t[1]
      ], n) : k;
    }, n.x = function (t) {
      return arguments.length ? (_ = t, x = t.copy(), S = {
        x: 0,
        y: 0,
        k: 1
      }, n) : _;
    }, n.y = function (t) {
      return arguments.length ? (w = t, b = t.copy(), S = {
        x: 0,
        y: 0,
        k: 1
      }, n) : w;
    }, Go.rebind(n, T, 'on');
  };
  var ja, Ha = [
      0,
      1 / 0
    ], Fa = 'onwheel' in na ? (ja = function () {
      return -Go.event.deltaY * (Go.event.deltaMode ? 120 : 1);
    }, 'wheel') : 'onmousewheel' in na ? (ja = function () {
      return Go.event.wheelDelta;
    }, 'mousewheel') : (ja = function () {
      return -Go.event.detail;
    }, 'MozMousePixelScroll');
  et.prototype.toString = function () {
    return this.rgb() + '';
  }, Go.hsl = function (n, t, e) {
    return 1 === arguments.length ? n instanceof ut ? rt(n.h, n.s, n.l) : _t('' + n, bt, rt) : rt(+n, +t, +e);
  };
  var Oa = ut.prototype = new et();
  Oa.brighter = function (n) {
    return n = Math.pow(0.7, arguments.length ? n : 1), rt(this.h, this.s, this.l / n);
  }, Oa.darker = function (n) {
    return n = Math.pow(0.7, arguments.length ? n : 1), rt(this.h, this.s, n * this.l);
  }, Oa.rgb = function () {
    return it(this.h, this.s, this.l);
  }, Go.hcl = function (n, t, e) {
    return 1 === arguments.length ? n instanceof at ? ot(n.h, n.c, n.l) : n instanceof lt ? ht(n.l, n.a, n.b) : ht((n = wt((n = Go.rgb(n)).r, n.g, n.b)).l, n.a, n.b) : ot(+n, +t, +e);
  };
  var Ia = at.prototype = new et();
  Ia.brighter = function (n) {
    return ot(this.h, this.c, Math.min(100, this.l + Ya * (arguments.length ? n : 1)));
  }, Ia.darker = function (n) {
    return ot(this.h, this.c, Math.max(0, this.l - Ya * (arguments.length ? n : 1)));
  }, Ia.rgb = function () {
    return ct(this.h, this.c, this.l).rgb();
  }, Go.lab = function (n, t, e) {
    return 1 === arguments.length ? n instanceof lt ? st(n.l, n.a, n.b) : n instanceof at ? ct(n.l, n.c, n.h) : wt((n = Go.rgb(n)).r, n.g, n.b) : st(+n, +t, +e);
  };
  var Ya = 18, Za = 0.95047, Va = 1, $a = 1.08883, Xa = lt.prototype = new et();
  Xa.brighter = function (n) {
    return st(Math.min(100, this.l + Ya * (arguments.length ? n : 1)), this.a, this.b);
  }, Xa.darker = function (n) {
    return st(Math.max(0, this.l - Ya * (arguments.length ? n : 1)), this.a, this.b);
  }, Xa.rgb = function () {
    return ft(this.l, this.a, this.b);
  }, Go.rgb = function (n, t, e) {
    return 1 === arguments.length ? n instanceof xt ? yt(n.r, n.g, n.b) : _t('' + n, yt, it) : yt(~~n, ~~t, ~~e);
  };
  var Ba = xt.prototype = new et();
  Ba.brighter = function (n) {
    n = Math.pow(0.7, arguments.length ? n : 1);
    var t = this.r, e = this.g, r = this.b, u = 30;
    return t || e || r ? (t && u > t && (t = u), e && u > e && (e = u), r && u > r && (r = u), yt(Math.min(255, ~~(t / n)), Math.min(255, ~~(e / n)), Math.min(255, ~~(r / n)))) : yt(u, u, u);
  }, Ba.darker = function (n) {
    return n = Math.pow(0.7, arguments.length ? n : 1), yt(~~(n * this.r), ~~(n * this.g), ~~(n * this.b));
  }, Ba.hsl = function () {
    return bt(this.r, this.g, this.b);
  }, Ba.toString = function () {
    return '#' + Mt(this.r) + Mt(this.g) + Mt(this.b);
  };
  var Ja = Go.map({
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074
    });
  Ja.forEach(function (n, t) {
    Ja.set(n, dt(t));
  }), Go.functor = Et, Go.xhr = Ct(At), Go.dsv = function (n, t) {
    function e(n, e, i) {
      arguments.length < 3 && (i = e, e = null);
      var o = Nt(n, t, null == e ? r : u(e), i);
      return o.row = function (n) {
        return arguments.length ? o.response(null == (e = n) ? r : u(n)) : e;
      }, o;
    }
    function r(n) {
      return e.parse(n.responseText);
    }
    function u(n) {
      return function (t) {
        return e.parse(t.responseText, n);
      };
    }
    function i(t) {
      return t.map(o).join(n);
    }
    function o(n) {
      return a.test(n) ? '"' + n.replace(/\"/g, '""') + '"' : n;
    }
    var a = new RegExp('["' + n + '\n]'), c = n.charCodeAt(0);
    return e.parse = function (n, t) {
      var r;
      return e.parseRows(n, function (n, e) {
        if (r)
          return r(n, e - 1);
        var u = new Function('d', 'return {' + n.map(function (n, t) {
            return JSON.stringify(n) + ': d[' + t + ']';
          }).join(',') + '}');
        r = t ? function (n, e) {
          return t(u(n), e);
        } : u;
      });
    }, e.parseRows = function (n, t) {
      function e() {
        if (l >= s)
          return o;
        if (u)
          return u = !1, i;
        var t = l;
        if (34 === n.charCodeAt(t)) {
          for (var e = t; e++ < s;)
            if (34 === n.charCodeAt(e)) {
              if (34 !== n.charCodeAt(e + 1))
                break;
              ++e;
            }
          l = e + 2;
          var r = n.charCodeAt(e + 1);
          return 13 === r ? (u = !0, 10 === n.charCodeAt(e + 2) && ++l) : 10 === r && (u = !0), n.substring(t + 1, e).replace(/""/g, '"');
        }
        for (; s > l;) {
          var r = n.charCodeAt(l++), a = 1;
          if (10 === r)
            u = !0;
          else if (13 === r)
            u = !0, 10 === n.charCodeAt(l) && (++l, ++a);
          else if (r !== c)
            continue;
          return n.substring(t, l - a);
        }
        return n.substring(t);
      }
      for (var r, u, i = {}, o = {}, a = [], s = n.length, l = 0, f = 0; (r = e()) !== o;) {
        for (var h = []; r !== i && r !== o;)
          h.push(r), r = e();
        (!t || (h = t(h, f++))) && a.push(h);
      }
      return a;
    }, e.format = function (t) {
      if (Array.isArray(t[0]))
        return e.formatRows(t);
      var r = new h(), u = [];
      return t.forEach(function (n) {
        for (var t in n)
          r.has(t) || u.push(r.add(t));
      }), [u.map(o).join(n)].concat(t.map(function (t) {
        return u.map(function (n) {
          return o(t[n]);
        }).join(n);
      })).join('\n');
    }, e.formatRows = function (n) {
      return n.map(i).join('\n');
    }, e;
  }, Go.csv = Go.dsv(',', 'text/csv'), Go.tsv = Go.dsv('\t', 'text/tab-separated-values'), Go.touch = function (n, t, e) {
    if (arguments.length < 3 && (e = t, t = x().changedTouches), t)
      for (var r, u = 0, i = t.length; i > u; ++u)
        if ((r = t[u]).identifier === e)
          return Z(n, r);
  };
  var Wa, Ga, Ka, Qa, nc, tc = ea[p(ea, 'requestAnimationFrame')] || function (n) {
      setTimeout(n, 17);
    };
  Go.timer = function (n, t, e) {
    var r = arguments.length;
    2 > r && (t = 0), 3 > r && (e = Date.now());
    var u = e + t, i = {
        c: n,
        t: u,
        f: !1,
        n: null
      };
    Ga ? Ga.n = i : Wa = i, Ga = i, Ka || (Qa = clearTimeout(Qa), Ka = 1, tc(Tt));
  }, Go.timer.flush = function () {
    qt(), zt();
  }, Go.round = function (n, t) {
    return t ? Math.round(n * (t = Math.pow(10, t))) / t : Math.round(n);
  };
  var ec = [
      'y',
      'z',
      'a',
      'f',
      'p',
      'n',
      '\xb5',
      'm',
      '',
      'k',
      'M',
      'G',
      'T',
      'P',
      'E',
      'Z',
      'Y'
    ].map(Dt);
  Go.formatPrefix = function (n, t) {
    var e = 0;
    return n && (0 > n && (n *= -1), t && (n = Go.round(n, Rt(n, t))), e = 1 + Math.floor(1e-12 + Math.log(n) / Math.LN10), e = Math.max(-24, Math.min(24, 3 * Math.floor((e - 1) / 3)))), ec[8 + e / 3];
  };
  var rc = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i, uc = Go.map({
      b: function (n) {
        return n.toString(2);
      },
      c: function (n) {
        return String.fromCharCode(n);
      },
      o: function (n) {
        return n.toString(8);
      },
      x: function (n) {
        return n.toString(16);
      },
      X: function (n) {
        return n.toString(16).toUpperCase();
      },
      g: function (n, t) {
        return n.toPrecision(t);
      },
      e: function (n, t) {
        return n.toExponential(t);
      },
      f: function (n, t) {
        return n.toFixed(t);
      },
      r: function (n, t) {
        return (n = Go.round(n, Rt(n, t))).toFixed(Math.max(0, Math.min(20, Rt(n * (1 + 1e-15), t))));
      }
    }), ic = Go.time = {}, oc = Date;
  jt.prototype = {
    getDate: function () {
      return this._.getUTCDate();
    },
    getDay: function () {
      return this._.getUTCDay();
    },
    getFullYear: function () {
      return this._.getUTCFullYear();
    },
    getHours: function () {
      return this._.getUTCHours();
    },
    getMilliseconds: function () {
      return this._.getUTCMilliseconds();
    },
    getMinutes: function () {
      return this._.getUTCMinutes();
    },
    getMonth: function () {
      return this._.getUTCMonth();
    },
    getSeconds: function () {
      return this._.getUTCSeconds();
    },
    getTime: function () {
      return this._.getTime();
    },
    getTimezoneOffset: function () {
      return 0;
    },
    valueOf: function () {
      return this._.valueOf();
    },
    setDate: function () {
      ac.setUTCDate.apply(this._, arguments);
    },
    setDay: function () {
      ac.setUTCDay.apply(this._, arguments);
    },
    setFullYear: function () {
      ac.setUTCFullYear.apply(this._, arguments);
    },
    setHours: function () {
      ac.setUTCHours.apply(this._, arguments);
    },
    setMilliseconds: function () {
      ac.setUTCMilliseconds.apply(this._, arguments);
    },
    setMinutes: function () {
      ac.setUTCMinutes.apply(this._, arguments);
    },
    setMonth: function () {
      ac.setUTCMonth.apply(this._, arguments);
    },
    setSeconds: function () {
      ac.setUTCSeconds.apply(this._, arguments);
    },
    setTime: function () {
      ac.setTime.apply(this._, arguments);
    }
  };
  var ac = Date.prototype;
  ic.year = Ht(function (n) {
    return n = ic.day(n), n.setMonth(0, 1), n;
  }, function (n, t) {
    n.setFullYear(n.getFullYear() + t);
  }, function (n) {
    return n.getFullYear();
  }), ic.years = ic.year.range, ic.years.utc = ic.year.utc.range, ic.day = Ht(function (n) {
    var t = new oc(2000, 0);
    return t.setFullYear(n.getFullYear(), n.getMonth(), n.getDate()), t;
  }, function (n, t) {
    n.setDate(n.getDate() + t);
  }, function (n) {
    return n.getDate() - 1;
  }), ic.days = ic.day.range, ic.days.utc = ic.day.utc.range, ic.dayOfYear = function (n) {
    var t = ic.year(n);
    return Math.floor((n - t - 60000 * (n.getTimezoneOffset() - t.getTimezoneOffset())) / 86400000);
  }, [
    'sunday',
    'monday',
    'tuesday',
    'wednesday',
    'thursday',
    'friday',
    'saturday'
  ].forEach(function (n, t) {
    t = 7 - t;
    var e = ic[n] = Ht(function (n) {
        return (n = ic.day(n)).setDate(n.getDate() - (n.getDay() + t) % 7), n;
      }, function (n, t) {
        n.setDate(n.getDate() + 7 * Math.floor(t));
      }, function (n) {
        var e = ic.year(n).getDay();
        return Math.floor((ic.dayOfYear(n) + (e + t) % 7) / 7) - (e !== t);
      });
    ic[n + 's'] = e.range, ic[n + 's'].utc = e.utc.range, ic[n + 'OfYear'] = function (n) {
      var e = ic.year(n).getDay();
      return Math.floor((ic.dayOfYear(n) + (e + t) % 7) / 7);
    };
  }), ic.week = ic.sunday, ic.weeks = ic.sunday.range, ic.weeks.utc = ic.sunday.utc.range, ic.weekOfYear = ic.sundayOfYear;
  var cc = {
      '-': '',
      _: ' ',
      0: '0'
    }, sc = /^\s*\d+/, lc = /^%/;
  Go.locale = function (n) {
    return {
      numberFormat: Pt(n),
      timeFormat: Ot(n)
    };
  };
  var fc = Go.locale({
      decimal: '.',
      thousands: ',',
      grouping: [3],
      currency: [
        '$',
        ''
      ],
      dateTime: '%a %b %e %X %Y',
      date: '%m/%d/%Y',
      time: '%H:%M:%S',
      periods: [
        'AM',
        'PM'
      ],
      days: [
        'Sunday',
        'Monday',
        'Tuesday',
        'Wednesday',
        'Thursday',
        'Friday',
        'Saturday'
      ],
      shortDays: [
        'Sun',
        'Mon',
        'Tue',
        'Wed',
        'Thu',
        'Fri',
        'Sat'
      ],
      months: [
        'January',
        'February',
        'March',
        'April',
        'May',
        'June',
        'July',
        'August',
        'September',
        'October',
        'November',
        'December'
      ],
      shortMonths: [
        'Jan',
        'Feb',
        'Mar',
        'Apr',
        'May',
        'Jun',
        'Jul',
        'Aug',
        'Sep',
        'Oct',
        'Nov',
        'Dec'
      ]
    });
  Go.format = fc.numberFormat, Go.geo = {}, ce.prototype = {
    s: 0,
    t: 0,
    add: function (n) {
      se(n, this.t, hc), se(hc.s, this.s, this), this.s ? this.t += hc.t : this.s = hc.t;
    },
    reset: function () {
      this.s = this.t = 0;
    },
    valueOf: function () {
      return this.s;
    }
  };
  var hc = new ce();
  Go.geo.stream = function (n, t) {
    n && gc.hasOwnProperty(n.type) ? gc[n.type](n, t) : le(n, t);
  };
  var gc = {
      Feature: function (n, t) {
        le(n.geometry, t);
      },
      FeatureCollection: function (n, t) {
        for (var e = n.features, r = -1, u = e.length; ++r < u;)
          le(e[r].geometry, t);
      }
    }, pc = {
      Sphere: function (n, t) {
        t.sphere();
      },
      Point: function (n, t) {
        n = n.coordinates, t.point(n[0], n[1], n[2]);
      },
      MultiPoint: function (n, t) {
        for (var e = n.coordinates, r = -1, u = e.length; ++r < u;)
          n = e[r], t.point(n[0], n[1], n[2]);
      },
      LineString: function (n, t) {
        fe(n.coordinates, t, 0);
      },
      MultiLineString: function (n, t) {
        for (var e = n.coordinates, r = -1, u = e.length; ++r < u;)
          fe(e[r], t, 0);
      },
      Polygon: function (n, t) {
        he(n.coordinates, t);
      },
      MultiPolygon: function (n, t) {
        for (var e = n.coordinates, r = -1, u = e.length; ++r < u;)
          he(e[r], t);
      },
      GeometryCollection: function (n, t) {
        for (var e = n.geometries, r = -1, u = e.length; ++r < u;)
          le(e[r], t);
      }
    };
  Go.geo.area = function (n) {
    return vc = 0, Go.geo.stream(n, mc), vc;
  };
  var vc, dc = new ce(), mc = {
      sphere: function () {
        vc += 4 * Ca;
      },
      point: v,
      lineStart: v,
      lineEnd: v,
      polygonStart: function () {
        dc.reset(), mc.lineStart = ge;
      },
      polygonEnd: function () {
        var n = 2 * dc;
        vc += 0 > n ? 4 * Ca + n : n, mc.lineStart = mc.lineEnd = mc.point = v;
      }
    };
  Go.geo.bounds = function () {
    function n(n, t) {
      x.push(M = [
        l = n,
        h = n
      ]), f > t && (f = t), t > g && (g = t);
    }
    function t(t, e) {
      var r = pe([
          t * za,
          e * za
        ]);
      if (m) {
        var u = de(m, r), i = [
            u[1],
            -u[0],
            0
          ], o = de(i, u);
        xe(o), o = Me(o);
        var c = t - p, s = c > 0 ? 1 : -1, v = o[0] * Ra * s, d = fa(c) > 180;
        if (d ^ (v > s * p && s * t > v)) {
          var y = o[1] * Ra;
          y > g && (g = y);
        } else if (v = (v + 360) % 360 - 180, d ^ (v > s * p && s * t > v)) {
          var y = -o[1] * Ra;
          f > y && (f = y);
        } else
          f > e && (f = e), e > g && (g = e);
        d ? p > t ? a(l, t) > a(l, h) && (h = t) : a(t, h) > a(l, h) && (l = t) : h >= l ? (l > t && (l = t), t > h && (h = t)) : t > p ? a(l, t) > a(l, h) && (h = t) : a(t, h) > a(l, h) && (l = t);
      } else
        n(t, e);
      m = r, p = t;
    }
    function e() {
      _.point = t;
    }
    function r() {
      M[0] = l, M[1] = h, _.point = n, m = null;
    }
    function u(n, e) {
      if (m) {
        var r = n - p;
        y += fa(r) > 180 ? r + (r > 0 ? 360 : -360) : r;
      } else
        v = n, d = e;
      mc.point(n, e), t(n, e);
    }
    function i() {
      mc.lineStart();
    }
    function o() {
      u(v, d), mc.lineEnd(), fa(y) > Ta && (l = -(h = 180)), M[0] = l, M[1] = h, m = null;
    }
    function a(n, t) {
      return (t -= n) < 0 ? t + 360 : t;
    }
    function c(n, t) {
      return n[0] - t[0];
    }
    function s(n, t) {
      return t[0] <= t[1] ? t[0] <= n && n <= t[1] : n < t[0] || t[1] < n;
    }
    var l, f, h, g, p, v, d, m, y, x, M, _ = {
        point: n,
        lineStart: e,
        lineEnd: r,
        polygonStart: function () {
          _.point = u, _.lineStart = i, _.lineEnd = o, y = 0, mc.polygonStart();
        },
        polygonEnd: function () {
          mc.polygonEnd(), _.point = n, _.lineStart = e, _.lineEnd = r, 0 > dc ? (l = -(h = 180), f = -(g = 90)) : y > Ta ? g = 90 : -Ta > y && (f = -90), M[0] = l, M[1] = h;
        }
      };
    return function (n) {
      g = h = -(l = f = 1 / 0), x = [], Go.geo.stream(n, _);
      var t = x.length;
      if (t) {
        x.sort(c);
        for (var e, r = 1, u = x[0], i = [u]; t > r; ++r)
          e = x[r], s(e[0], u) || s(e[1], u) ? (a(u[0], e[1]) > a(u[0], u[1]) && (u[1] = e[1]), a(e[0], u[1]) > a(u[0], u[1]) && (u[0] = e[0])) : i.push(u = e);
        for (var o, e, p = -1 / 0, t = i.length - 1, r = 0, u = i[t]; t >= r; u = e, ++r)
          e = i[r], (o = a(u[1], e[0])) > p && (p = o, l = e[0], h = u[1]);
      }
      return x = M = null, 1 / 0 === l || 1 / 0 === f ? [
        [
          0 / 0,
          0 / 0
        ],
        [
          0 / 0,
          0 / 0
        ]
      ] : [
        [
          l,
          f
        ],
        [
          h,
          g
        ]
      ];
    };
  }(), Go.geo.centroid = function (n) {
    yc = xc = Mc = _c = bc = wc = Sc = kc = Ec = Ac = Cc = 0, Go.geo.stream(n, Nc);
    var t = Ec, e = Ac, r = Cc, u = t * t + e * e + r * r;
    return qa > u && (t = wc, e = Sc, r = kc, Ta > xc && (t = Mc, e = _c, r = bc), u = t * t + e * e + r * r, qa > u) ? [
      0 / 0,
      0 / 0
    ] : [
      Math.atan2(e, t) * Ra,
      G(r / Math.sqrt(u)) * Ra
    ];
  };
  var yc, xc, Mc, _c, bc, wc, Sc, kc, Ec, Ac, Cc, Nc = {
      sphere: v,
      point: be,
      lineStart: Se,
      lineEnd: ke,
      polygonStart: function () {
        Nc.lineStart = Ee;
      },
      polygonEnd: function () {
        Nc.lineStart = Se;
      }
    }, Lc = Te(Ae, Pe, je, [
      -Ca,
      -Ca / 2
    ]), Tc = 1000000000;
  Go.geo.clipExtent = function () {
    var n, t, e, r, u, i, o = {
        stream: function (n) {
          return u && (u.valid = !1), u = i(n), u.valid = !0, u;
        },
        extent: function (a) {
          return arguments.length ? (i = Oe(n = +a[0][0], t = +a[0][1], e = +a[1][0], r = +a[1][1]), u && (u.valid = !1, u = null), o) : [
            [
              n,
              t
            ],
            [
              e,
              r
            ]
          ];
        }
      };
    return o.extent([
      [
        0,
        0
      ],
      [
        960,
        500
      ]
    ]);
  }, (Go.geo.conicEqualArea = function () {
    return Ye(Ze);
  }).raw = Ze, Go.geo.albers = function () {
    return Go.geo.conicEqualArea().rotate([
      96,
      0
    ]).center([
      -0.6,
      38.7
    ]).parallels([
      29.5,
      45.5
    ]).scale(1070);
  }, Go.geo.albersUsa = function () {
    function n(n) {
      var i = n[0], o = n[1];
      return t = null, e(i, o), t || (r(i, o), t) || u(i, o), t;
    }
    var t, e, r, u, i = Go.geo.albers(), o = Go.geo.conicEqualArea().rotate([
        154,
        0
      ]).center([
        -2,
        58.5
      ]).parallels([
        55,
        65
      ]), a = Go.geo.conicEqualArea().rotate([
        157,
        0
      ]).center([
        -3,
        19.9
      ]).parallels([
        8,
        18
      ]), c = {
        point: function (n, e) {
          t = [
            n,
            e
          ];
        }
      };
    return n.invert = function (n) {
      var t = i.scale(), e = i.translate(), r = (n[0] - e[0]) / t, u = (n[1] - e[1]) / t;
      return (u >= 0.12 && 0.234 > u && r >= -0.425 && -0.214 > r ? o : u >= 0.166 && 0.234 > u && r >= -0.214 && -0.115 > r ? a : i).invert(n);
    }, n.stream = function (n) {
      var t = i.stream(n), e = o.stream(n), r = a.stream(n);
      return {
        point: function (n, u) {
          t.point(n, u), e.point(n, u), r.point(n, u);
        },
        sphere: function () {
          t.sphere(), e.sphere(), r.sphere();
        },
        lineStart: function () {
          t.lineStart(), e.lineStart(), r.lineStart();
        },
        lineEnd: function () {
          t.lineEnd(), e.lineEnd(), r.lineEnd();
        },
        polygonStart: function () {
          t.polygonStart(), e.polygonStart(), r.polygonStart();
        },
        polygonEnd: function () {
          t.polygonEnd(), e.polygonEnd(), r.polygonEnd();
        }
      };
    }, n.precision = function (t) {
      return arguments.length ? (i.precision(t), o.precision(t), a.precision(t), n) : i.precision();
    }, n.scale = function (t) {
      return arguments.length ? (i.scale(t), o.scale(0.35 * t), a.scale(t), n.translate(i.translate())) : i.scale();
    }, n.translate = function (t) {
      if (!arguments.length)
        return i.translate();
      var s = i.scale(), l = +t[0], f = +t[1];
      return e = i.translate(t).clipExtent([
        [
          l - 0.455 * s,
          f - 0.238 * s
        ],
        [
          l + 0.455 * s,
          f + 0.238 * s
        ]
      ]).stream(c).point, r = o.translate([
        l - 0.307 * s,
        f + 0.201 * s
      ]).clipExtent([
        [
          l - 0.425 * s + Ta,
          f + 0.12 * s + Ta
        ],
        [
          l - 0.214 * s - Ta,
          f + 0.234 * s - Ta
        ]
      ]).stream(c).point, u = a.translate([
        l - 0.205 * s,
        f + 0.212 * s
      ]).clipExtent([
        [
          l - 0.214 * s + Ta,
          f + 0.166 * s + Ta
        ],
        [
          l - 0.115 * s - Ta,
          f + 0.234 * s - Ta
        ]
      ]).stream(c).point, n;
    }, n.scale(1070);
  };
  var qc, zc, Rc, Dc, Pc, Uc, jc = {
      point: v,
      lineStart: v,
      lineEnd: v,
      polygonStart: function () {
        zc = 0, jc.lineStart = Ve;
      },
      polygonEnd: function () {
        jc.lineStart = jc.lineEnd = jc.point = v, qc += fa(zc / 2);
      }
    }, Hc = {
      point: $e,
      lineStart: v,
      lineEnd: v,
      polygonStart: v,
      polygonEnd: v
    }, Fc = {
      point: Je,
      lineStart: We,
      lineEnd: Ge,
      polygonStart: function () {
        Fc.lineStart = Ke;
      },
      polygonEnd: function () {
        Fc.point = Je, Fc.lineStart = We, Fc.lineEnd = Ge;
      }
    };
  Go.geo.path = function () {
    function n(n) {
      return n && ('function' == typeof a && i.pointRadius(+a.apply(this, arguments)), o && o.valid || (o = u(i)), Go.geo.stream(n, o)), i.result();
    }
    function t() {
      return o = null, n;
    }
    var e, r, u, i, o, a = 4.5;
    return n.area = function (n) {
      return qc = 0, Go.geo.stream(n, u(jc)), qc;
    }, n.centroid = function (n) {
      return Mc = _c = bc = wc = Sc = kc = Ec = Ac = Cc = 0, Go.geo.stream(n, u(Fc)), Cc ? [
        Ec / Cc,
        Ac / Cc
      ] : kc ? [
        wc / kc,
        Sc / kc
      ] : bc ? [
        Mc / bc,
        _c / bc
      ] : [
        0 / 0,
        0 / 0
      ];
    }, n.bounds = function (n) {
      return Pc = Uc = -(Rc = Dc = 1 / 0), Go.geo.stream(n, u(Hc)), [
        [
          Rc,
          Dc
        ],
        [
          Pc,
          Uc
        ]
      ];
    }, n.projection = function (n) {
      return arguments.length ? (u = (e = n) ? n.stream || tr(n) : At, t()) : e;
    }, n.context = function (n) {
      return arguments.length ? (i = null == (r = n) ? new Xe() : new Qe(n), 'function' != typeof a && i.pointRadius(a), t()) : r;
    }, n.pointRadius = function (t) {
      return arguments.length ? (a = 'function' == typeof t ? t : (i.pointRadius(+t), +t), n) : a;
    }, n.projection(Go.geo.albersUsa()).context(null);
  }, Go.geo.transform = function (n) {
    return {
      stream: function (t) {
        var e = new er(t);
        for (var r in n)
          e[r] = n[r];
        return e;
      }
    };
  }, er.prototype = {
    point: function (n, t) {
      this.stream.point(n, t);
    },
    sphere: function () {
      this.stream.sphere();
    },
    lineStart: function () {
      this.stream.lineStart();
    },
    lineEnd: function () {
      this.stream.lineEnd();
    },
    polygonStart: function () {
      this.stream.polygonStart();
    },
    polygonEnd: function () {
      this.stream.polygonEnd();
    }
  }, Go.geo.projection = ur, Go.geo.projectionMutator = ir, (Go.geo.equirectangular = function () {
    return ur(ar);
  }).raw = ar.invert = ar, Go.geo.rotation = function (n) {
    function t(t) {
      return t = n(t[0] * za, t[1] * za), t[0] *= Ra, t[1] *= Ra, t;
    }
    return n = sr(n[0] % 360 * za, n[1] * za, n.length > 2 ? n[2] * za : 0), t.invert = function (t) {
      return t = n.invert(t[0] * za, t[1] * za), t[0] *= Ra, t[1] *= Ra, t;
    }, t;
  }, cr.invert = ar, Go.geo.circle = function () {
    function n() {
      var n = 'function' == typeof r ? r.apply(this, arguments) : r, t = sr(-n[0] * za, -n[1] * za, 0).invert, u = [];
      return e(null, null, 1, {
        point: function (n, e) {
          u.push(n = t(n, e)), n[0] *= Ra, n[1] *= Ra;
        }
      }), {
        type: 'Polygon',
        coordinates: [u]
      };
    }
    var t, e, r = [
        0,
        0
      ], u = 6;
    return n.origin = function (t) {
      return arguments.length ? (r = t, n) : r;
    }, n.angle = function (r) {
      return arguments.length ? (e = gr((t = +r) * za, u * za), n) : t;
    }, n.precision = function (r) {
      return arguments.length ? (e = gr(t * za, (u = +r) * za), n) : u;
    }, n.angle(90);
  }, Go.geo.distance = function (n, t) {
    var e, r = (t[0] - n[0]) * za, u = n[1] * za, i = t[1] * za, o = Math.sin(r), a = Math.cos(r), c = Math.sin(u), s = Math.cos(u), l = Math.sin(i), f = Math.cos(i);
    return Math.atan2(Math.sqrt((e = f * o) * e + (e = s * l - c * f * a) * e), c * l + s * f * a);
  }, Go.geo.graticule = function () {
    function n() {
      return {
        type: 'MultiLineString',
        coordinates: t()
      };
    }
    function t() {
      return Go.range(Math.ceil(i / d) * d, u, d).map(h).concat(Go.range(Math.ceil(s / m) * m, c, m).map(g)).concat(Go.range(Math.ceil(r / p) * p, e, p).filter(function (n) {
        return fa(n % d) > Ta;
      }).map(l)).concat(Go.range(Math.ceil(a / v) * v, o, v).filter(function (n) {
        return fa(n % m) > Ta;
      }).map(f));
    }
    var e, r, u, i, o, a, c, s, l, f, h, g, p = 10, v = p, d = 90, m = 360, y = 2.5;
    return n.lines = function () {
      return t().map(function (n) {
        return {
          type: 'LineString',
          coordinates: n
        };
      });
    }, n.outline = function () {
      return {
        type: 'Polygon',
        coordinates: [h(i).concat(g(c).slice(1), h(u).reverse().slice(1), g(s).reverse().slice(1))]
      };
    }, n.extent = function (t) {
      return arguments.length ? n.majorExtent(t).minorExtent(t) : n.minorExtent();
    }, n.majorExtent = function (t) {
      return arguments.length ? (i = +t[0][0], u = +t[1][0], s = +t[0][1], c = +t[1][1], i > u && (t = i, i = u, u = t), s > c && (t = s, s = c, c = t), n.precision(y)) : [
        [
          i,
          s
        ],
        [
          u,
          c
        ]
      ];
    }, n.minorExtent = function (t) {
      return arguments.length ? (r = +t[0][0], e = +t[1][0], a = +t[0][1], o = +t[1][1], r > e && (t = r, r = e, e = t), a > o && (t = a, a = o, o = t), n.precision(y)) : [
        [
          r,
          a
        ],
        [
          e,
          o
        ]
      ];
    }, n.step = function (t) {
      return arguments.length ? n.majorStep(t).minorStep(t) : n.minorStep();
    }, n.majorStep = function (t) {
      return arguments.length ? (d = +t[0], m = +t[1], n) : [
        d,
        m
      ];
    }, n.minorStep = function (t) {
      return arguments.length ? (p = +t[0], v = +t[1], n) : [
        p,
        v
      ];
    }, n.precision = function (t) {
      return arguments.length ? (y = +t, l = vr(a, o, 90), f = dr(r, e, y), h = vr(s, c, 90), g = dr(i, u, y), n) : y;
    }, n.majorExtent([
      [
        -180,
        -90 + Ta
      ],
      [
        180,
        90 - Ta
      ]
    ]).minorExtent([
      [
        -180,
        -80 - Ta
      ],
      [
        180,
        80 + Ta
      ]
    ]);
  }, Go.geo.greatArc = function () {
    function n() {
      return {
        type: 'LineString',
        coordinates: [
          t || r.apply(this, arguments),
          e || u.apply(this, arguments)
        ]
      };
    }
    var t, e, r = mr, u = yr;
    return n.distance = function () {
      return Go.geo.distance(t || r.apply(this, arguments), e || u.apply(this, arguments));
    }, n.source = function (e) {
      return arguments.length ? (r = e, t = 'function' == typeof e ? null : e, n) : r;
    }, n.target = function (t) {
      return arguments.length ? (u = t, e = 'function' == typeof t ? null : t, n) : u;
    }, n.precision = function () {
      return arguments.length ? n : 0;
    }, n;
  }, Go.geo.interpolate = function (n, t) {
    return xr(n[0] * za, n[1] * za, t[0] * za, t[1] * za);
  }, Go.geo.length = function (n) {
    return Oc = 0, Go.geo.stream(n, Ic), Oc;
  };
  var Oc, Ic = {
      sphere: v,
      point: v,
      lineStart: Mr,
      lineEnd: v,
      polygonStart: v,
      polygonEnd: v
    }, Yc = _r(function (n) {
      return Math.sqrt(2 / (1 + n));
    }, function (n) {
      return 2 * Math.asin(n / 2);
    });
  (Go.geo.azimuthalEqualArea = function () {
    return ur(Yc);
  }).raw = Yc;
  var Zc = _r(function (n) {
      var t = Math.acos(n);
      return t && t / Math.sin(t);
    }, At);
  (Go.geo.azimuthalEquidistant = function () {
    return ur(Zc);
  }).raw = Zc, (Go.geo.conicConformal = function () {
    return Ye(br);
  }).raw = br, (Go.geo.conicEquidistant = function () {
    return Ye(wr);
  }).raw = wr;
  var Vc = _r(function (n) {
      return 1 / n;
    }, Math.atan);
  (Go.geo.gnomonic = function () {
    return ur(Vc);
  }).raw = Vc, Sr.invert = function (n, t) {
    return [
      n,
      2 * Math.atan(Math.exp(t)) - La
    ];
  }, (Go.geo.mercator = function () {
    return kr(Sr);
  }).raw = Sr;
  var $c = _r(function () {
      return 1;
    }, Math.asin);
  (Go.geo.orthographic = function () {
    return ur($c);
  }).raw = $c;
  var Xc = _r(function (n) {
      return 1 / (1 + n);
    }, function (n) {
      return 2 * Math.atan(n);
    });
  (Go.geo.stereographic = function () {
    return ur(Xc);
  }).raw = Xc, Er.invert = function (n, t) {
    return [
      -t,
      2 * Math.atan(Math.exp(n)) - La
    ];
  }, (Go.geo.transverseMercator = function () {
    var n = kr(Er), t = n.center, e = n.rotate;
    return n.center = function (n) {
      return n ? t([
        -n[1],
        n[0]
      ]) : (n = t(), [
        -n[1],
        n[0]
      ]);
    }, n.rotate = function (n) {
      return n ? e([
        n[0],
        n[1],
        n.length > 2 ? n[2] + 90 : 90
      ]) : (n = e(), [
        n[0],
        n[1],
        n[2] - 90
      ]);
    }, n.rotate([
      0,
      0
    ]);
  }).raw = Er, Go.geom = {}, Go.geom.hull = function (n) {
    function t(n) {
      if (n.length < 3)
        return [];
      var t, u = Et(e), i = Et(r), o = n.length, a = [], c = [];
      for (t = 0; o > t; t++)
        a.push([
          +u.call(this, n[t], t),
          +i.call(this, n[t], t),
          t
        ]);
      for (a.sort(Lr), t = 0; o > t; t++)
        c.push([
          a[t][0],
          -a[t][1]
        ]);
      var s = Nr(a), l = Nr(c), f = l[0] === s[0], h = l[l.length - 1] === s[s.length - 1], g = [];
      for (t = s.length - 1; t >= 0; --t)
        g.push(n[a[s[t]][2]]);
      for (t = +f; t < l.length - h; ++t)
        g.push(n[a[l[t]][2]]);
      return g;
    }
    var e = Ar, r = Cr;
    return arguments.length ? t(n) : (t.x = function (n) {
      return arguments.length ? (e = n, t) : e;
    }, t.y = function (n) {
      return arguments.length ? (r = n, t) : r;
    }, t);
  }, Go.geom.polygon = function (n) {
    return da(n, Bc), n;
  };
  var Bc = Go.geom.polygon.prototype = [];
  Bc.area = function () {
    for (var n, t = -1, e = this.length, r = this[e - 1], u = 0; ++t < e;)
      n = r, r = this[t], u += n[1] * r[0] - n[0] * r[1];
    return 0.5 * u;
  }, Bc.centroid = function (n) {
    var t, e, r = -1, u = this.length, i = 0, o = 0, a = this[u - 1];
    for (arguments.length || (n = -1 / (6 * this.area())); ++r < u;)
      t = a, a = this[r], e = t[0] * a[1] - a[0] * t[1], i += (t[0] + a[0]) * e, o += (t[1] + a[1]) * e;
    return [
      i * n,
      o * n
    ];
  }, Bc.clip = function (n) {
    for (var t, e, r, u, i, o, a = zr(n), c = -1, s = this.length - zr(this), l = this[s - 1]; ++c < s;) {
      for (t = n.slice(), n.length = 0, u = this[c], i = t[(r = t.length - a) - 1], e = -1; ++e < r;)
        o = t[e], Tr(o, l, u) ? (Tr(i, l, u) || n.push(qr(i, o, l, u)), n.push(o)) : Tr(i, l, u) && n.push(qr(i, o, l, u)), i = o;
      a && n.push(n[0]), l = u;
    }
    return n;
  };
  var Jc, Wc, Gc, Kc, Qc, ns = [], ts = [];
  Or.prototype.prepare = function () {
    for (var n, t = this.edges, e = t.length; e--;)
      n = t[e].edge, n.b && n.a || t.splice(e, 1);
    return t.sort(Yr), t.length;
  }, Qr.prototype = {
    start: function () {
      return this.edge.l === this.site ? this.edge.a : this.edge.b;
    },
    end: function () {
      return this.edge.l === this.site ? this.edge.b : this.edge.a;
    }
  }, nu.prototype = {
    insert: function (n, t) {
      var e, r, u;
      if (n) {
        if (t.P = n, t.N = n.N, n.N && (n.N.P = t), n.N = t, n.R) {
          for (n = n.R; n.L;)
            n = n.L;
          n.L = t;
        } else
          n.R = t;
        e = n;
      } else
        this._ ? (n = uu(this._), t.P = null, t.N = n, n.P = n.L = t, e = n) : (t.P = t.N = null, this._ = t, e = null);
      for (t.L = t.R = null, t.U = e, t.C = !0, n = t; e && e.C;)
        r = e.U, e === r.L ? (u = r.R, u && u.C ? (e.C = u.C = !1, r.C = !0, n = r) : (n === e.R && (eu(this, e), n = e, e = n.U), e.C = !1, r.C = !0, ru(this, r))) : (u = r.L, u && u.C ? (e.C = u.C = !1, r.C = !0, n = r) : (n === e.L && (ru(this, e), n = e, e = n.U), e.C = !1, r.C = !0, eu(this, r))), e = n.U;
      this._.C = !1;
    },
    remove: function (n) {
      n.N && (n.N.P = n.P), n.P && (n.P.N = n.N), n.N = n.P = null;
      var t, e, r, u = n.U, i = n.L, o = n.R;
      if (e = i ? o ? uu(o) : i : o, u ? u.L === n ? u.L = e : u.R = e : this._ = e, i && o ? (r = e.C, e.C = n.C, e.L = i, i.U = e, e !== o ? (u = e.U, e.U = n.U, n = e.R, u.L = n, e.R = o, o.U = e) : (e.U = u, u = e, n = e.R)) : (r = n.C, n = e), n && (n.U = u), !r) {
        if (n && n.C)
          return n.C = !1, void 0;
        do {
          if (n === this._)
            break;
          if (n === u.L) {
            if (t = u.R, t.C && (t.C = !1, u.C = !0, eu(this, u), t = u.R), t.L && t.L.C || t.R && t.R.C) {
              t.R && t.R.C || (t.L.C = !1, t.C = !0, ru(this, t), t = u.R), t.C = u.C, u.C = t.R.C = !1, eu(this, u), n = this._;
              break;
            }
          } else if (t = u.L, t.C && (t.C = !1, u.C = !0, ru(this, u), t = u.L), t.L && t.L.C || t.R && t.R.C) {
            t.L && t.L.C || (t.R.C = !1, t.C = !0, eu(this, t), t = u.L), t.C = u.C, u.C = t.L.C = !1, ru(this, u), n = this._;
            break;
          }
          t.C = !0, n = u, u = u.U;
        } while (!n.C);
        n && (n.C = !1);
      }
    }
  }, Go.geom.voronoi = function (n) {
    function t(n) {
      var t = new Array(n.length), r = a[0][0], u = a[0][1], i = a[1][0], o = a[1][1];
      return iu(e(n), a).cells.forEach(function (e, a) {
        var c = e.edges, s = e.site, l = t[a] = c.length ? c.map(function (n) {
            var t = n.start();
            return [
              t.x,
              t.y
            ];
          }) : s.x >= r && s.x <= i && s.y >= u && s.y <= o ? [
            [
              r,
              o
            ],
            [
              i,
              o
            ],
            [
              i,
              u
            ],
            [
              r,
              u
            ]
          ] : [];
        l.point = n[a];
      }), t;
    }
    function e(n) {
      return n.map(function (n, t) {
        return {
          x: Math.round(i(n, t) / Ta) * Ta,
          y: Math.round(o(n, t) / Ta) * Ta,
          i: t
        };
      });
    }
    var r = Ar, u = Cr, i = r, o = u, a = es;
    return n ? t(n) : (t.links = function (n) {
      return iu(e(n)).edges.filter(function (n) {
        return n.l && n.r;
      }).map(function (t) {
        return {
          source: n[t.l.i],
          target: n[t.r.i]
        };
      });
    }, t.triangles = function (n) {
      var t = [];
      return iu(e(n)).cells.forEach(function (e, r) {
        for (var u, i, o = e.site, a = e.edges.sort(Yr), c = -1, s = a.length, l = a[s - 1].edge, f = l.l === o ? l.r : l.l; ++c < s;)
          u = l, i = f, l = a[c].edge, f = l.l === o ? l.r : l.l, r < i.i && r < f.i && au(o, i, f) < 0 && t.push([
            n[r],
            n[i.i],
            n[f.i]
          ]);
      }), t;
    }, t.x = function (n) {
      return arguments.length ? (i = Et(r = n), t) : r;
    }, t.y = function (n) {
      return arguments.length ? (o = Et(u = n), t) : u;
    }, t.clipExtent = function (n) {
      return arguments.length ? (a = null == n ? es : n, t) : a === es ? null : a;
    }, t.size = function (n) {
      return arguments.length ? t.clipExtent(n && [
        [
          0,
          0
        ],
        n
      ]) : a === es ? null : a && a[1];
    }, t);
  };
  var es = [
      [
        -1000000,
        -1000000
      ],
      [
        1000000,
        1000000
      ]
    ];
  Go.geom.delaunay = function (n) {
    return Go.geom.voronoi().triangles(n);
  }, Go.geom.quadtree = function (n, t, e, r, u) {
    function i(n) {
      function i(n, t, e, r, u, i, o, a) {
        if (!isNaN(e) && !isNaN(r))
          if (n.leaf) {
            var c = n.x, l = n.y;
            if (null != c)
              if (fa(c - e) + fa(l - r) < 0.01)
                s(n, t, e, r, u, i, o, a);
              else {
                var f = n.point;
                n.x = n.y = n.point = null, s(n, f, c, l, u, i, o, a), s(n, t, e, r, u, i, o, a);
              }
            else
              n.x = e, n.y = r, n.point = t;
          } else
            s(n, t, e, r, u, i, o, a);
      }
      function s(n, t, e, r, u, o, a, c) {
        var s = 0.5 * (u + a), l = 0.5 * (o + c), f = e >= s, h = r >= l, g = (h << 1) + f;
        n.leaf = !1, n = n.nodes[g] || (n.nodes[g] = lu()), f ? u = s : a = s, h ? o = l : c = l, i(n, t, e, r, u, o, a, c);
      }
      var l, f, h, g, p, v, d, m, y, x = Et(a), M = Et(c);
      if (null != t)
        v = t, d = e, m = r, y = u;
      else if (m = y = -(v = d = 1 / 0), f = [], h = [], p = n.length, o)
        for (g = 0; p > g; ++g)
          l = n[g], l.x < v && (v = l.x), l.y < d && (d = l.y), l.x > m && (m = l.x), l.y > y && (y = l.y), f.push(l.x), h.push(l.y);
      else
        for (g = 0; p > g; ++g) {
          var _ = +x(l = n[g], g), b = +M(l, g);
          v > _ && (v = _), d > b && (d = b), _ > m && (m = _), b > y && (y = b), f.push(_), h.push(b);
        }
      var w = m - v, S = y - d;
      w > S ? y = d + w : m = v + S;
      var k = lu();
      if (k.add = function (n) {
          i(k, n, +x(n, ++g), +M(n, g), v, d, m, y);
        }, k.visit = function (n) {
          fu(n, k, v, d, m, y);
        }, g = -1, null == t) {
        for (; ++g < p;)
          i(k, n[g], f[g], h[g], v, d, m, y);
        --g;
      } else
        n.forEach(k.add);
      return f = h = n = l = null, k;
    }
    var o, a = Ar, c = Cr;
    return (o = arguments.length) ? (a = cu, c = su, 3 === o && (u = e, r = t, e = t = 0), i(n)) : (i.x = function (n) {
      return arguments.length ? (a = n, i) : a;
    }, i.y = function (n) {
      return arguments.length ? (c = n, i) : c;
    }, i.extent = function (n) {
      return arguments.length ? (null == n ? t = e = r = u = null : (t = +n[0][0], e = +n[0][1], r = +n[1][0], u = +n[1][1]), i) : null == t ? null : [
        [
          t,
          e
        ],
        [
          r,
          u
        ]
      ];
    }, i.size = function (n) {
      return arguments.length ? (null == n ? t = e = r = u = null : (t = e = 0, r = +n[0], u = +n[1]), i) : null == t ? null : [
        r - t,
        u - e
      ];
    }, i);
  }, Go.interpolateRgb = hu, Go.interpolateObject = gu, Go.interpolateNumber = pu, Go.interpolateString = vu;
  var rs = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, us = new RegExp(rs.source, 'g');
  Go.interpolate = du, Go.interpolators = [function (n, t) {
      var e = typeof t;
      return ('string' === e ? Ja.has(t) || /^(#|rgb\(|hsl\()/.test(t) ? hu : vu : t instanceof et ? hu : Array.isArray(t) ? mu : 'object' === e && isNaN(t) ? gu : pu)(n, t);
    }], Go.interpolateArray = mu;
  var is = function () {
      return At;
    }, os = Go.map({
      linear: is,
      poly: Su,
      quad: function () {
        return _u;
      },
      cubic: function () {
        return bu;
      },
      sin: function () {
        return ku;
      },
      exp: function () {
        return Eu;
      },
      circle: function () {
        return Au;
      },
      elastic: Cu,
      back: Nu,
      bounce: function () {
        return Lu;
      }
    }), as = Go.map({
      'in': At,
      out: xu,
      'in-out': Mu,
      'out-in': function (n) {
        return Mu(xu(n));
      }
    });
  Go.ease = function (n) {
    var t = n.indexOf('-'), e = t >= 0 ? n.substring(0, t) : n, r = t >= 0 ? n.substring(t + 1) : 'in';
    return e = os.get(e) || is, r = as.get(r) || At, yu(r(e.apply(null, Ko.call(arguments, 1))));
  }, Go.interpolateHcl = Tu, Go.interpolateHsl = qu, Go.interpolateLab = zu, Go.interpolateRound = Ru, Go.transform = function (n) {
    var t = na.createElementNS(Go.ns.prefix.svg, 'g');
    return (Go.transform = function (n) {
      if (null != n) {
        t.setAttribute('transform', n);
        var e = t.transform.baseVal.consolidate();
      }
      return new Du(e ? e.matrix : cs);
    })(n);
  }, Du.prototype.toString = function () {
    return 'translate(' + this.translate + ')rotate(' + this.rotate + ')skewX(' + this.skew + ')scale(' + this.scale + ')';
  };
  var cs = {
      a: 1,
      b: 0,
      c: 0,
      d: 1,
      e: 0,
      f: 0
    };
  Go.interpolateTransform = Hu, Go.layout = {}, Go.layout.bundle = function () {
    return function (n) {
      for (var t = [], e = -1, r = n.length; ++e < r;)
        t.push(Iu(n[e]));
      return t;
    };
  }, Go.layout.chord = function () {
    function n() {
      var n, s, f, h, g, p = {}, v = [], d = Go.range(i), m = [];
      for (e = [], r = [], n = 0, h = -1; ++h < i;) {
        for (s = 0, g = -1; ++g < i;)
          s += u[h][g];
        v.push(s), m.push(Go.range(i)), n += s;
      }
      for (o && d.sort(function (n, t) {
          return o(v[n], v[t]);
        }), a && m.forEach(function (n, t) {
          n.sort(function (n, e) {
            return a(u[t][n], u[t][e]);
          });
        }), n = (Na - l * i) / n, s = 0, h = -1; ++h < i;) {
        for (f = s, g = -1; ++g < i;) {
          var y = d[h], x = m[y][g], M = u[y][x], _ = s, b = s += M * n;
          p[y + '-' + x] = {
            index: y,
            subindex: x,
            startAngle: _,
            endAngle: b,
            value: M
          };
        }
        r[y] = {
          index: y,
          startAngle: f,
          endAngle: s,
          value: (s - f) / n
        }, s += l;
      }
      for (h = -1; ++h < i;)
        for (g = h - 1; ++g < i;) {
          var w = p[h + '-' + g], S = p[g + '-' + h];
          (w.value || S.value) && e.push(w.value < S.value ? {
            source: S,
            target: w
          } : {
            source: w,
            target: S
          });
        }
      c && t();
    }
    function t() {
      e.sort(function (n, t) {
        return c((n.source.value + n.target.value) / 2, (t.source.value + t.target.value) / 2);
      });
    }
    var e, r, u, i, o, a, c, s = {}, l = 0;
    return s.matrix = function (n) {
      return arguments.length ? (i = (u = n) && u.length, e = r = null, s) : u;
    }, s.padding = function (n) {
      return arguments.length ? (l = n, e = r = null, s) : l;
    }, s.sortGroups = function (n) {
      return arguments.length ? (o = n, e = r = null, s) : o;
    }, s.sortSubgroups = function (n) {
      return arguments.length ? (a = n, e = null, s) : a;
    }, s.sortChords = function (n) {
      return arguments.length ? (c = n, e && t(), s) : c;
    }, s.chords = function () {
      return e || n(), e;
    }, s.groups = function () {
      return r || n(), r;
    }, s;
  }, Go.layout.force = function () {
    function n(n) {
      return function (t, e, r, u) {
        if (t.point !== n) {
          var i = t.cx - n.x, o = t.cy - n.y, a = u - e, c = i * i + o * o;
          if (c > a * a / d) {
            if (p > c) {
              var s = t.charge / c;
              n.px -= i * s, n.py -= o * s;
            }
            return !0;
          }
          if (t.point && c && p > c) {
            var s = t.pointCharge / c;
            n.px -= i * s, n.py -= o * s;
          }
        }
        return !t.charge;
      };
    }
    function t(n) {
      n.px = Go.event.x, n.py = Go.event.y, a.resume();
    }
    var e, r, u, i, o, a = {}, c = Go.dispatch('start', 'tick', 'end'), s = [
        1,
        1
      ], l = 0.9, f = ss, h = ls, g = -30, p = fs, v = 0.1, d = 0.64, m = [], y = [];
    return a.tick = function () {
      if ((r *= 0.99) < 0.005)
        return c.end({
          type: 'end',
          alpha: r = 0
        }), !0;
      var t, e, a, f, h, p, d, x, M, _ = m.length, b = y.length;
      for (e = 0; b > e; ++e)
        a = y[e], f = a.source, h = a.target, x = h.x - f.x, M = h.y - f.y, (p = x * x + M * M) && (p = r * i[e] * ((p = Math.sqrt(p)) - u[e]) / p, x *= p, M *= p, h.x -= x * (d = f.weight / (h.weight + f.weight)), h.y -= M * d, f.x += x * (d = 1 - d), f.y += M * d);
      if ((d = r * v) && (x = s[0] / 2, M = s[1] / 2, e = -1, d))
        for (; ++e < _;)
          a = m[e], a.x += (x - a.x) * d, a.y += (M - a.y) * d;
      if (g)
        for (Ju(t = Go.geom.quadtree(m), r, o), e = -1; ++e < _;)
          (a = m[e]).fixed || t.visit(n(a));
      for (e = -1; ++e < _;)
        a = m[e], a.fixed ? (a.x = a.px, a.y = a.py) : (a.x -= (a.px - (a.px = a.x)) * l, a.y -= (a.py - (a.py = a.y)) * l);
      c.tick({
        type: 'tick',
        alpha: r
      });
    }, a.nodes = function (n) {
      return arguments.length ? (m = n, a) : m;
    }, a.links = function (n) {
      return arguments.length ? (y = n, a) : y;
    }, a.size = function (n) {
      return arguments.length ? (s = n, a) : s;
    }, a.linkDistance = function (n) {
      return arguments.length ? (f = 'function' == typeof n ? n : +n, a) : f;
    }, a.distance = a.linkDistance, a.linkStrength = function (n) {
      return arguments.length ? (h = 'function' == typeof n ? n : +n, a) : h;
    }, a.friction = function (n) {
      return arguments.length ? (l = +n, a) : l;
    }, a.charge = function (n) {
      return arguments.length ? (g = 'function' == typeof n ? n : +n, a) : g;
    }, a.chargeDistance = function (n) {
      return arguments.length ? (p = n * n, a) : Math.sqrt(p);
    }, a.gravity = function (n) {
      return arguments.length ? (v = +n, a) : v;
    }, a.theta = function (n) {
      return arguments.length ? (d = n * n, a) : Math.sqrt(d);
    }, a.alpha = function (n) {
      return arguments.length ? (n = +n, r ? r = n > 0 ? n : 0 : n > 0 && (c.start({
        type: 'start',
        alpha: r = n
      }), Go.timer(a.tick)), a) : r;
    }, a.start = function () {
      function n(n, r) {
        if (!e) {
          for (e = new Array(c), a = 0; c > a; ++a)
            e[a] = [];
          for (a = 0; s > a; ++a) {
            var u = y[a];
            e[u.source.index].push(u.target), e[u.target.index].push(u.source);
          }
        }
        for (var i, o = e[t], a = -1, s = o.length; ++a < s;)
          if (!isNaN(i = o[a][n]))
            return i;
        return Math.random() * r;
      }
      var t, e, r, c = m.length, l = y.length, p = s[0], v = s[1];
      for (t = 0; c > t; ++t)
        (r = m[t]).index = t, r.weight = 0;
      for (t = 0; l > t; ++t)
        r = y[t], 'number' == typeof r.source && (r.source = m[r.source]), 'number' == typeof r.target && (r.target = m[r.target]), ++r.source.weight, ++r.target.weight;
      for (t = 0; c > t; ++t)
        r = m[t], isNaN(r.x) && (r.x = n('x', p)), isNaN(r.y) && (r.y = n('y', v)), isNaN(r.px) && (r.px = r.x), isNaN(r.py) && (r.py = r.y);
      if (u = [], 'function' == typeof f)
        for (t = 0; l > t; ++t)
          u[t] = +f.call(this, y[t], t);
      else
        for (t = 0; l > t; ++t)
          u[t] = f;
      if (i = [], 'function' == typeof h)
        for (t = 0; l > t; ++t)
          i[t] = +h.call(this, y[t], t);
      else
        for (t = 0; l > t; ++t)
          i[t] = h;
      if (o = [], 'function' == typeof g)
        for (t = 0; c > t; ++t)
          o[t] = +g.call(this, m[t], t);
      else
        for (t = 0; c > t; ++t)
          o[t] = g;
      return a.resume();
    }, a.resume = function () {
      return a.alpha(0.1);
    }, a.stop = function () {
      return a.alpha(0);
    }, a.drag = function () {
      return e || (e = Go.behavior.drag().origin(At).on('dragstart.force', Vu).on('drag.force', t).on('dragend.force', $u)), arguments.length ? (this.on('mouseover.force', Xu).on('mouseout.force', Bu).call(e), void 0) : e;
    }, Go.rebind(a, c, 'on');
  };
  var ss = 20, ls = 1, fs = 1 / 0;
  Go.layout.hierarchy = function () {
    function n(t, o, a) {
      var c = u.call(e, t, o);
      if (t.depth = o, a.push(t), c && (s = c.length)) {
        for (var s, l, f = -1, h = t.children = new Array(s), g = 0, p = o + 1; ++f < s;)
          l = h[f] = n(c[f], p, a), l.parent = t, g += l.value;
        r && h.sort(r), i && (t.value = g);
      } else
        delete t.children, i && (t.value = +i.call(e, t, o) || 0);
      return t;
    }
    function t(n, r) {
      var u = n.children, o = 0;
      if (u && (a = u.length))
        for (var a, c = -1, s = r + 1; ++c < a;)
          o += t(u[c], s);
      else
        i && (o = +i.call(e, n, r) || 0);
      return i && (n.value = o), o;
    }
    function e(t) {
      var e = [];
      return n(t, 0, e), e;
    }
    var r = Qu, u = Gu, i = Ku;
    return e.sort = function (n) {
      return arguments.length ? (r = n, e) : r;
    }, e.children = function (n) {
      return arguments.length ? (u = n, e) : u;
    }, e.value = function (n) {
      return arguments.length ? (i = n, e) : i;
    }, e.revalue = function (n) {
      return t(n, 0), n;
    }, e;
  }, Go.layout.partition = function () {
    function n(t, e, r, u) {
      var i = t.children;
      if (t.x = e, t.y = t.depth * u, t.dx = r, t.dy = u, i && (o = i.length)) {
        var o, a, c, s = -1;
        for (r = t.value ? r / t.value : 0; ++s < o;)
          n(a = i[s], e, c = a.value * r, u), e += c;
      }
    }
    function t(n) {
      var e = n.children, r = 0;
      if (e && (u = e.length))
        for (var u, i = -1; ++i < u;)
          r = Math.max(r, t(e[i]));
      return 1 + r;
    }
    function e(e, i) {
      var o = r.call(this, e, i);
      return n(o[0], 0, u[0], u[1] / t(o[0])), o;
    }
    var r = Go.layout.hierarchy(), u = [
        1,
        1
      ];
    return e.size = function (n) {
      return arguments.length ? (u = n, e) : u;
    }, Wu(e, r);
  }, Go.layout.pie = function () {
    function n(i) {
      var o = i.map(function (e, r) {
          return +t.call(n, e, r);
        }), a = +('function' == typeof r ? r.apply(this, arguments) : r), c = (('function' == typeof u ? u.apply(this, arguments) : u) - a) / Go.sum(o), s = Go.range(i.length);
      null != e && s.sort(e === hs ? function (n, t) {
        return o[t] - o[n];
      } : function (n, t) {
        return e(i[n], i[t]);
      });
      var l = [];
      return s.forEach(function (n) {
        var t;
        l[n] = {
          data: i[n],
          value: t = o[n],
          startAngle: a,
          endAngle: a += t * c
        };
      }), l;
    }
    var t = Number, e = hs, r = 0, u = Na;
    return n.value = function (e) {
      return arguments.length ? (t = e, n) : t;
    }, n.sort = function (t) {
      return arguments.length ? (e = t, n) : e;
    }, n.startAngle = function (t) {
      return arguments.length ? (r = t, n) : r;
    }, n.endAngle = function (t) {
      return arguments.length ? (u = t, n) : u;
    }, n;
  };
  var hs = {};
  Go.layout.stack = function () {
    function n(a, c) {
      var s = a.map(function (e, r) {
          return t.call(n, e, r);
        }), l = s.map(function (t) {
          return t.map(function (t, e) {
            return [
              i.call(n, t, e),
              o.call(n, t, e)
            ];
          });
        }), f = e.call(n, l, c);
      s = Go.permute(s, f), l = Go.permute(l, f);
      var h, g, p, v = r.call(n, l, c), d = s.length, m = s[0].length;
      for (g = 0; m > g; ++g)
        for (u.call(n, s[0][g], p = v[g], l[0][g][1]), h = 1; d > h; ++h)
          u.call(n, s[h][g], p += l[h - 1][g][1], l[h][g][1]);
      return a;
    }
    var t = At, e = ui, r = ii, u = ri, i = ti, o = ei;
    return n.values = function (e) {
      return arguments.length ? (t = e, n) : t;
    }, n.order = function (t) {
      return arguments.length ? (e = 'function' == typeof t ? t : gs.get(t) || ui, n) : e;
    }, n.offset = function (t) {
      return arguments.length ? (r = 'function' == typeof t ? t : ps.get(t) || ii, n) : r;
    }, n.x = function (t) {
      return arguments.length ? (i = t, n) : i;
    }, n.y = function (t) {
      return arguments.length ? (o = t, n) : o;
    }, n.out = function (t) {
      return arguments.length ? (u = t, n) : u;
    }, n;
  };
  var gs = Go.map({
      'inside-out': function (n) {
        var t, e, r = n.length, u = n.map(oi), i = n.map(ai), o = Go.range(r).sort(function (n, t) {
            return u[n] - u[t];
          }), a = 0, c = 0, s = [], l = [];
        for (t = 0; r > t; ++t)
          e = o[t], c > a ? (a += i[e], s.push(e)) : (c += i[e], l.push(e));
        return l.reverse().concat(s);
      },
      reverse: function (n) {
        return Go.range(n.length).reverse();
      },
      'default': ui
    }), ps = Go.map({
      silhouette: function (n) {
        var t, e, r, u = n.length, i = n[0].length, o = [], a = 0, c = [];
        for (e = 0; i > e; ++e) {
          for (t = 0, r = 0; u > t; t++)
            r += n[t][e][1];
          r > a && (a = r), o.push(r);
        }
        for (e = 0; i > e; ++e)
          c[e] = (a - o[e]) / 2;
        return c;
      },
      wiggle: function (n) {
        var t, e, r, u, i, o, a, c, s, l = n.length, f = n[0], h = f.length, g = [];
        for (g[0] = c = s = 0, e = 1; h > e; ++e) {
          for (t = 0, u = 0; l > t; ++t)
            u += n[t][e][1];
          for (t = 0, i = 0, a = f[e][0] - f[e - 1][0]; l > t; ++t) {
            for (r = 0, o = (n[t][e][1] - n[t][e - 1][1]) / (2 * a); t > r; ++r)
              o += (n[r][e][1] - n[r][e - 1][1]) / a;
            i += o * n[t][e][1];
          }
          g[e] = c -= u ? i / u * a : 0, s > c && (s = c);
        }
        for (e = 0; h > e; ++e)
          g[e] -= s;
        return g;
      },
      expand: function (n) {
        var t, e, r, u = n.length, i = n[0].length, o = 1 / u, a = [];
        for (e = 0; i > e; ++e) {
          for (t = 0, r = 0; u > t; t++)
            r += n[t][e][1];
          if (r)
            for (t = 0; u > t; t++)
              n[t][e][1] /= r;
          else
            for (t = 0; u > t; t++)
              n[t][e][1] = o;
        }
        for (e = 0; i > e; ++e)
          a[e] = 0;
        return a;
      },
      zero: ii
    });
  Go.layout.histogram = function () {
    function n(n, i) {
      for (var o, a, c = [], s = n.map(e, this), l = r.call(this, s, i), f = u.call(this, l, s, i), i = -1, h = s.length, g = f.length - 1, p = t ? 1 : 1 / h; ++i < g;)
        o = c[i] = [], o.dx = f[i + 1] - (o.x = f[i]), o.y = 0;
      if (g > 0)
        for (i = -1; ++i < h;)
          a = s[i], a >= l[0] && a <= l[1] && (o = c[Go.bisect(f, a, 1, g) - 1], o.y += p, o.push(n[i]));
      return c;
    }
    var t = !0, e = Number, r = fi, u = si;
    return n.value = function (t) {
      return arguments.length ? (e = t, n) : e;
    }, n.range = function (t) {
      return arguments.length ? (r = Et(t), n) : r;
    }, n.bins = function (t) {
      return arguments.length ? (u = 'number' == typeof t ? function (n) {
        return li(n, t);
      } : Et(t), n) : u;
    }, n.frequency = function (e) {
      return arguments.length ? (t = !!e, n) : t;
    }, n;
  }, Go.layout.tree = function () {
    function n(n, i) {
      function o(n, t) {
        var r = n.children, u = n._tree;
        if (r && (i = r.length)) {
          for (var i, a, s, l = r[0], f = l, h = -1; ++h < i;)
            s = r[h], o(s, a), f = c(s, a, f), a = s;
          Mi(n);
          var g = 0.5 * (l._tree.prelim + s._tree.prelim);
          t ? (u.prelim = t._tree.prelim + e(n, t), u.mod = u.prelim - g) : u.prelim = g;
        } else
          t && (u.prelim = t._tree.prelim + e(n, t));
      }
      function a(n, t) {
        n.x = n._tree.prelim + t;
        var e = n.children;
        if (e && (r = e.length)) {
          var r, u = -1;
          for (t += n._tree.mod; ++u < r;)
            a(e[u], t);
        }
      }
      function c(n, t, r) {
        if (t) {
          for (var u, i = n, o = n, a = t, c = n.parent.children[0], s = i._tree.mod, l = o._tree.mod, f = a._tree.mod, h = c._tree.mod; a = pi(a), i = gi(i), a && i;)
            c = gi(c), o = pi(o), o._tree.ancestor = n, u = a._tree.prelim + f - i._tree.prelim - s + e(a, i), u > 0 && (_i(bi(a, n, r), n, u), s += u, l += u), f += a._tree.mod, s += i._tree.mod, h += c._tree.mod, l += o._tree.mod;
          a && !pi(o) && (o._tree.thread = a, o._tree.mod += f - l), i && !gi(c) && (c._tree.thread = i, c._tree.mod += s - h, r = n);
        }
        return r;
      }
      var s = t.call(this, n, i), l = s[0];
      xi(l, function (n, t) {
        n._tree = {
          ancestor: n,
          prelim: 0,
          mod: 0,
          change: 0,
          shift: 0,
          number: t ? t._tree.number + 1 : 0
        };
      }), o(l), a(l, -l._tree.prelim);
      var f = vi(l, mi), h = vi(l, di), g = vi(l, yi), p = f.x - e(f, h) / 2, v = h.x + e(h, f) / 2, d = g.depth || 1;
      return xi(l, u ? function (n) {
        n.x *= r[0], n.y = n.depth * r[1], delete n._tree;
      } : function (n) {
        n.x = (n.x - p) / (v - p) * r[0], n.y = n.depth / d * r[1], delete n._tree;
      }), s;
    }
    var t = Go.layout.hierarchy().sort(null).value(null), e = hi, r = [
        1,
        1
      ], u = !1;
    return n.separation = function (t) {
      return arguments.length ? (e = t, n) : e;
    }, n.size = function (t) {
      return arguments.length ? (u = null == (r = t), n) : u ? null : r;
    }, n.nodeSize = function (t) {
      return arguments.length ? (u = null != (r = t), n) : u ? r : null;
    }, Wu(n, t);
  }, Go.layout.pack = function () {
    function n(n, i) {
      var o = e.call(this, n, i), a = o[0], c = u[0], s = u[1], l = null == t ? Math.sqrt : 'function' == typeof t ? t : function () {
          return t;
        };
      if (a.x = a.y = 0, xi(a, function (n) {
          n.r = +l(n.value);
        }), xi(a, Ai), r) {
        var f = r * (t ? 1 : Math.max(2 * a.r / c, 2 * a.r / s)) / 2;
        xi(a, function (n) {
          n.r += f;
        }), xi(a, Ai), xi(a, function (n) {
          n.r -= f;
        });
      }
      return Li(a, c / 2, s / 2, t ? 1 : 1 / Math.max(2 * a.r / c, 2 * a.r / s)), o;
    }
    var t, e = Go.layout.hierarchy().sort(wi), r = 0, u = [
        1,
        1
      ];
    return n.size = function (t) {
      return arguments.length ? (u = t, n) : u;
    }, n.radius = function (e) {
      return arguments.length ? (t = null == e || 'function' == typeof e ? e : +e, n) : t;
    }, n.padding = function (t) {
      return arguments.length ? (r = +t, n) : r;
    }, Wu(n, e);
  }, Go.layout.cluster = function () {
    function n(n, i) {
      var o, a = t.call(this, n, i), c = a[0], s = 0;
      xi(c, function (n) {
        var t = n.children;
        t && t.length ? (n.x = zi(t), n.y = qi(t)) : (n.x = o ? s += e(n, o) : 0, n.y = 0, o = n);
      });
      var l = Ri(c), f = Di(c), h = l.x - e(l, f) / 2, g = f.x + e(f, l) / 2;
      return xi(c, u ? function (n) {
        n.x = (n.x - c.x) * r[0], n.y = (c.y - n.y) * r[1];
      } : function (n) {
        n.x = (n.x - h) / (g - h) * r[0], n.y = (1 - (c.y ? n.y / c.y : 1)) * r[1];
      }), a;
    }
    var t = Go.layout.hierarchy().sort(null).value(null), e = hi, r = [
        1,
        1
      ], u = !1;
    return n.separation = function (t) {
      return arguments.length ? (e = t, n) : e;
    }, n.size = function (t) {
      return arguments.length ? (u = null == (r = t), n) : u ? null : r;
    }, n.nodeSize = function (t) {
      return arguments.length ? (u = null != (r = t), n) : u ? r : null;
    }, Wu(n, t);
  }, Go.layout.treemap = function () {
    function n(n, t) {
      for (var e, r, u = -1, i = n.length; ++u < i;)
        r = (e = n[u]).value * (0 > t ? 0 : t), e.area = isNaN(r) || 0 >= r ? 0 : r;
    }
    function t(e) {
      var i = e.children;
      if (i && i.length) {
        var o, a, c, s = f(e), l = [], h = i.slice(), p = 1 / 0, v = 'slice' === g ? s.dx : 'dice' === g ? s.dy : 'slice-dice' === g ? 1 & e.depth ? s.dy : s.dx : Math.min(s.dx, s.dy);
        for (n(h, s.dx * s.dy / e.value), l.area = 0; (c = h.length) > 0;)
          l.push(o = h[c - 1]), l.area += o.area, 'squarify' !== g || (a = r(l, v)) <= p ? (h.pop(), p = a) : (l.area -= l.pop().area, u(l, v, s, !1), v = Math.min(s.dx, s.dy), l.length = l.area = 0, p = 1 / 0);
        l.length && (u(l, v, s, !0), l.length = l.area = 0), i.forEach(t);
      }
    }
    function e(t) {
      var r = t.children;
      if (r && r.length) {
        var i, o = f(t), a = r.slice(), c = [];
        for (n(a, o.dx * o.dy / t.value), c.area = 0; i = a.pop();)
          c.push(i), c.area += i.area, null != i.z && (u(c, i.z ? o.dx : o.dy, o, !a.length), c.length = c.area = 0);
        r.forEach(e);
      }
    }
    function r(n, t) {
      for (var e, r = n.area, u = 0, i = 1 / 0, o = -1, a = n.length; ++o < a;)
        (e = n[o].area) && (i > e && (i = e), e > u && (u = e));
      return r *= r, t *= t, r ? Math.max(t * u * p / r, r / (t * i * p)) : 1 / 0;
    }
    function u(n, t, e, r) {
      var u, i = -1, o = n.length, a = e.x, s = e.y, l = t ? c(n.area / t) : 0;
      if (t == e.dx) {
        for ((r || l > e.dy) && (l = e.dy); ++i < o;)
          u = n[i], u.x = a, u.y = s, u.dy = l, a += u.dx = Math.min(e.x + e.dx - a, l ? c(u.area / l) : 0);
        u.z = !0, u.dx += e.x + e.dx - a, e.y += l, e.dy -= l;
      } else {
        for ((r || l > e.dx) && (l = e.dx); ++i < o;)
          u = n[i], u.x = a, u.y = s, u.dx = l, s += u.dy = Math.min(e.y + e.dy - s, l ? c(u.area / l) : 0);
        u.z = !1, u.dy += e.y + e.dy - s, e.x += l, e.dx -= l;
      }
    }
    function i(r) {
      var u = o || a(r), i = u[0];
      return i.x = 0, i.y = 0, i.dx = s[0], i.dy = s[1], o && a.revalue(i), n([i], i.dx * i.dy / i.value), (o ? e : t)(i), h && (o = u), u;
    }
    var o, a = Go.layout.hierarchy(), c = Math.round, s = [
        1,
        1
      ], l = null, f = Pi, h = !1, g = 'squarify', p = 0.5 * (1 + Math.sqrt(5));
    return i.size = function (n) {
      return arguments.length ? (s = n, i) : s;
    }, i.padding = function (n) {
      function t(t) {
        var e = n.call(i, t, t.depth);
        return null == e ? Pi(t) : Ui(t, 'number' == typeof e ? [
          e,
          e,
          e,
          e
        ] : e);
      }
      function e(t) {
        return Ui(t, n);
      }
      if (!arguments.length)
        return l;
      var r;
      return f = null == (l = n) ? Pi : 'function' == (r = typeof n) ? t : 'number' === r ? (n = [
        n,
        n,
        n,
        n
      ], e) : e, i;
    }, i.round = function (n) {
      return arguments.length ? (c = n ? Math.round : Number, i) : c != Number;
    }, i.sticky = function (n) {
      return arguments.length ? (h = n, o = null, i) : h;
    }, i.ratio = function (n) {
      return arguments.length ? (p = n, i) : p;
    }, i.mode = function (n) {
      return arguments.length ? (g = n + '', i) : g;
    }, Wu(i, a);
  }, Go.random = {
    normal: function (n, t) {
      var e = arguments.length;
      return 2 > e && (t = 1), 1 > e && (n = 0), function () {
        var e, r, u;
        do
          e = 2 * Math.random() - 1, r = 2 * Math.random() - 1, u = e * e + r * r;
        while (!u || u > 1);
        return n + t * e * Math.sqrt(-2 * Math.log(u) / u);
      };
    },
    logNormal: function () {
      var n = Go.random.normal.apply(Go, arguments);
      return function () {
        return Math.exp(n());
      };
    },
    bates: function (n) {
      var t = Go.random.irwinHall(n);
      return function () {
        return t() / n;
      };
    },
    irwinHall: function (n) {
      return function () {
        for (var t = 0, e = 0; n > e; e++)
          t += Math.random();
        return t;
      };
    }
  }, Go.scale = {};
  var vs = {
      floor: At,
      ceil: At
    };
  Go.scale.linear = function () {
    return Zi([
      0,
      1
    ], [
      0,
      1
    ], du, !1);
  };
  var ds = {
      s: 1,
      g: 1,
      p: 1,
      r: 1,
      e: 1
    };
  Go.scale.log = function () {
    return Ki(Go.scale.linear().domain([
      0,
      1
    ]), 10, !0, [
      1,
      10
    ]);
  };
  var ms = Go.format('.0e'), ys = {
      floor: function (n) {
        return -Math.ceil(-n);
      },
      ceil: function (n) {
        return -Math.floor(-n);
      }
    };
  Go.scale.pow = function () {
    return Qi(Go.scale.linear(), 1, [
      0,
      1
    ]);
  }, Go.scale.sqrt = function () {
    return Go.scale.pow().exponent(0.5);
  }, Go.scale.ordinal = function () {
    return to([], {
      t: 'range',
      a: [[]]
    });
  }, Go.scale.category10 = function () {
    return Go.scale.ordinal().range(xs);
  }, Go.scale.category20 = function () {
    return Go.scale.ordinal().range(Ms);
  }, Go.scale.category20b = function () {
    return Go.scale.ordinal().range(_s);
  }, Go.scale.category20c = function () {
    return Go.scale.ordinal().range(bs);
  };
  var xs = [
      2062260,
      16744206,
      2924588,
      14034728,
      9725885,
      9197131,
      14907330,
      8355711,
      12369186,
      1556175
    ].map(mt), Ms = [
      2062260,
      11454440,
      16744206,
      16759672,
      2924588,
      10018698,
      14034728,
      16750742,
      9725885,
      12955861,
      9197131,
      12885140,
      14907330,
      16234194,
      8355711,
      13092807,
      12369186,
      14408589,
      1556175,
      10410725
    ].map(mt), _s = [
      3750777,
      5395619,
      7040719,
      10264286,
      6519097,
      9216594,
      11915115,
      13556636,
      9202993,
      12426809,
      15186514,
      15190932,
      8666169,
      11356490,
      14049643,
      15177372,
      8077683,
      10834324,
      13528509,
      14589654
    ].map(mt), bs = [
      3244733,
      7057110,
      10406625,
      13032431,
      15095053,
      16616764,
      16625259,
      16634018,
      3253076,
      7652470,
      10607003,
      13101504,
      7695281,
      10394312,
      12369372,
      14342891,
      6513507,
      9868950,
      12434877,
      14277081
    ].map(mt);
  Go.scale.quantile = function () {
    return eo([], []);
  }, Go.scale.quantize = function () {
    return ro(0, 1, [
      0,
      1
    ]);
  }, Go.scale.threshold = function () {
    return uo([0.5], [
      0,
      1
    ]);
  }, Go.scale.identity = function () {
    return io([
      0,
      1
    ]);
  }, Go.svg = {}, Go.svg.arc = function () {
    function n() {
      var n = t.apply(this, arguments), i = e.apply(this, arguments), o = r.apply(this, arguments) + ws, a = u.apply(this, arguments) + ws, c = (o > a && (c = o, o = a, a = c), a - o), s = Ca > c ? '0' : '1', l = Math.cos(o), f = Math.sin(o), h = Math.cos(a), g = Math.sin(a);
      return c >= Ss ? n ? 'M0,' + i + 'A' + i + ',' + i + ' 0 1,1 0,' + -i + 'A' + i + ',' + i + ' 0 1,1 0,' + i + 'M0,' + n + 'A' + n + ',' + n + ' 0 1,0 0,' + -n + 'A' + n + ',' + n + ' 0 1,0 0,' + n + 'Z' : 'M0,' + i + 'A' + i + ',' + i + ' 0 1,1 0,' + -i + 'A' + i + ',' + i + ' 0 1,1 0,' + i + 'Z' : n ? 'M' + i * l + ',' + i * f + 'A' + i + ',' + i + ' 0 ' + s + ',1 ' + i * h + ',' + i * g + 'L' + n * h + ',' + n * g + 'A' + n + ',' + n + ' 0 ' + s + ',0 ' + n * l + ',' + n * f + 'Z' : 'M' + i * l + ',' + i * f + 'A' + i + ',' + i + ' 0 ' + s + ',1 ' + i * h + ',' + i * g + 'L0,0' + 'Z';
    }
    var t = oo, e = ao, r = co, u = so;
    return n.innerRadius = function (e) {
      return arguments.length ? (t = Et(e), n) : t;
    }, n.outerRadius = function (t) {
      return arguments.length ? (e = Et(t), n) : e;
    }, n.startAngle = function (t) {
      return arguments.length ? (r = Et(t), n) : r;
    }, n.endAngle = function (t) {
      return arguments.length ? (u = Et(t), n) : u;
    }, n.centroid = function () {
      var n = (t.apply(this, arguments) + e.apply(this, arguments)) / 2, i = (r.apply(this, arguments) + u.apply(this, arguments)) / 2 + ws;
      return [
        Math.cos(i) * n,
        Math.sin(i) * n
      ];
    }, n;
  };
  var ws = -La, Ss = Na - Ta;
  Go.svg.line = function () {
    return lo(At);
  };
  var ks = Go.map({
      linear: fo,
      'linear-closed': ho,
      step: go,
      'step-before': po,
      'step-after': vo,
      basis: bo,
      'basis-open': wo,
      'basis-closed': So,
      bundle: ko,
      cardinal: xo,
      'cardinal-open': mo,
      'cardinal-closed': yo,
      monotone: To
    });
  ks.forEach(function (n, t) {
    t.key = n, t.closed = /-closed$/.test(n);
  });
  var Es = [
      0,
      2 / 3,
      1 / 3,
      0
    ], As = [
      0,
      1 / 3,
      2 / 3,
      0
    ], Cs = [
      0,
      1 / 6,
      2 / 3,
      1 / 6
    ];
  Go.svg.line.radial = function () {
    var n = lo(qo);
    return n.radius = n.x, delete n.x, n.angle = n.y, delete n.y, n;
  }, po.reverse = vo, vo.reverse = po, Go.svg.area = function () {
    return zo(At);
  }, Go.svg.area.radial = function () {
    var n = zo(qo);
    return n.radius = n.x, delete n.x, n.innerRadius = n.x0, delete n.x0, n.outerRadius = n.x1, delete n.x1, n.angle = n.y, delete n.y, n.startAngle = n.y0, delete n.y0, n.endAngle = n.y1, delete n.y1, n;
  }, Go.svg.chord = function () {
    function n(n, a) {
      var c = t(this, i, n, a), s = t(this, o, n, a);
      return 'M' + c.p0 + r(c.r, c.p1, c.a1 - c.a0) + (e(c, s) ? u(c.r, c.p1, c.r, c.p0) : u(c.r, c.p1, s.r, s.p0) + r(s.r, s.p1, s.a1 - s.a0) + u(s.r, s.p1, c.r, c.p0)) + 'Z';
    }
    function t(n, t, e, r) {
      var u = t.call(n, e, r), i = a.call(n, u, r), o = c.call(n, u, r) + ws, l = s.call(n, u, r) + ws;
      return {
        r: i,
        a0: o,
        a1: l,
        p0: [
          i * Math.cos(o),
          i * Math.sin(o)
        ],
        p1: [
          i * Math.cos(l),
          i * Math.sin(l)
        ]
      };
    }
    function e(n, t) {
      return n.a0 == t.a0 && n.a1 == t.a1;
    }
    function r(n, t, e) {
      return 'A' + n + ',' + n + ' 0 ' + +(e > Ca) + ',1 ' + t;
    }
    function u(n, t, e, r) {
      return 'Q 0,0 ' + r;
    }
    var i = mr, o = yr, a = Ro, c = co, s = so;
    return n.radius = function (t) {
      return arguments.length ? (a = Et(t), n) : a;
    }, n.source = function (t) {
      return arguments.length ? (i = Et(t), n) : i;
    }, n.target = function (t) {
      return arguments.length ? (o = Et(t), n) : o;
    }, n.startAngle = function (t) {
      return arguments.length ? (c = Et(t), n) : c;
    }, n.endAngle = function (t) {
      return arguments.length ? (s = Et(t), n) : s;
    }, n;
  }, Go.svg.diagonal = function () {
    function n(n, u) {
      var i = t.call(this, n, u), o = e.call(this, n, u), a = (i.y + o.y) / 2, c = [
          i,
          {
            x: i.x,
            y: a
          },
          {
            x: o.x,
            y: a
          },
          o
        ];
      return c = c.map(r), 'M' + c[0] + 'C' + c[1] + ' ' + c[2] + ' ' + c[3];
    }
    var t = mr, e = yr, r = Do;
    return n.source = function (e) {
      return arguments.length ? (t = Et(e), n) : t;
    }, n.target = function (t) {
      return arguments.length ? (e = Et(t), n) : e;
    }, n.projection = function (t) {
      return arguments.length ? (r = t, n) : r;
    }, n;
  }, Go.svg.diagonal.radial = function () {
    var n = Go.svg.diagonal(), t = Do, e = n.projection;
    return n.projection = function (n) {
      return arguments.length ? e(Po(t = n)) : t;
    }, n;
  }, Go.svg.symbol = function () {
    function n(n, r) {
      return (Ns.get(t.call(this, n, r)) || Ho)(e.call(this, n, r));
    }
    var t = jo, e = Uo;
    return n.type = function (e) {
      return arguments.length ? (t = Et(e), n) : t;
    }, n.size = function (t) {
      return arguments.length ? (e = Et(t), n) : e;
    }, n;
  };
  var Ns = Go.map({
      circle: Ho,
      cross: function (n) {
        var t = Math.sqrt(n / 5) / 2;
        return 'M' + -3 * t + ',' + -t + 'H' + -t + 'V' + -3 * t + 'H' + t + 'V' + -t + 'H' + 3 * t + 'V' + t + 'H' + t + 'V' + 3 * t + 'H' + -t + 'V' + t + 'H' + -3 * t + 'Z';
      },
      diamond: function (n) {
        var t = Math.sqrt(n / (2 * zs)), e = t * zs;
        return 'M0,' + -t + 'L' + e + ',0' + ' 0,' + t + ' ' + -e + ',0' + 'Z';
      },
      square: function (n) {
        var t = Math.sqrt(n) / 2;
        return 'M' + -t + ',' + -t + 'L' + t + ',' + -t + ' ' + t + ',' + t + ' ' + -t + ',' + t + 'Z';
      },
      'triangle-down': function (n) {
        var t = Math.sqrt(n / qs), e = t * qs / 2;
        return 'M0,' + e + 'L' + t + ',' + -e + ' ' + -t + ',' + -e + 'Z';
      },
      'triangle-up': function (n) {
        var t = Math.sqrt(n / qs), e = t * qs / 2;
        return 'M0,' + -e + 'L' + t + ',' + e + ' ' + -t + ',' + e + 'Z';
      }
    });
  Go.svg.symbolTypes = Ns.keys();
  var Ls, Ts, qs = Math.sqrt(3), zs = Math.tan(30 * za), Rs = [], Ds = 0;
  Rs.call = _a.call, Rs.empty = _a.empty, Rs.node = _a.node, Rs.size = _a.size, Go.transition = function (n) {
    return arguments.length ? Ls ? n.transition() : n : Sa.transition();
  }, Go.transition.prototype = Rs, Rs.select = function (n) {
    var t, e, r, u = this.id, i = [];
    n = b(n);
    for (var o = -1, a = this.length; ++o < a;) {
      i.push(t = []);
      for (var c = this[o], s = -1, l = c.length; ++s < l;)
        (r = c[s]) && (e = n.call(r, r.__data__, s, o)) ? ('__data__' in r && (e.__data__ = r.__data__), Yo(e, s, u, r.__transition__[u]), t.push(e)) : t.push(null);
    }
    return Fo(i, u);
  }, Rs.selectAll = function (n) {
    var t, e, r, u, i, o = this.id, a = [];
    n = w(n);
    for (var c = -1, s = this.length; ++c < s;)
      for (var l = this[c], f = -1, h = l.length; ++f < h;)
        if (r = l[f]) {
          i = r.__transition__[o], e = n.call(r, r.__data__, f, c), a.push(t = []);
          for (var g = -1, p = e.length; ++g < p;)
            (u = e[g]) && Yo(u, g, o, i), t.push(u);
        }
    return Fo(a, o);
  }, Rs.filter = function (n) {
    var t, e, r, u = [];
    'function' != typeof n && (n = R(n));
    for (var i = 0, o = this.length; o > i; i++) {
      u.push(t = []);
      for (var e = this[i], a = 0, c = e.length; c > a; a++)
        (r = e[a]) && n.call(r, r.__data__, a, i) && t.push(r);
    }
    return Fo(u, this.id);
  }, Rs.tween = function (n, t) {
    var e = this.id;
    return arguments.length < 2 ? this.node().__transition__[e].tween.get(n) : P(this, null == t ? function (t) {
      t.__transition__[e].tween.remove(n);
    } : function (r) {
      r.__transition__[e].tween.set(n, t);
    });
  }, Rs.attr = function (n, t) {
    function e() {
      this.removeAttribute(a);
    }
    function r() {
      this.removeAttributeNS(a.space, a.local);
    }
    function u(n) {
      return null == n ? e : (n += '', function () {
        var t, e = this.getAttribute(a);
        return e !== n && (t = o(e, n), function (n) {
          this.setAttribute(a, t(n));
        });
      });
    }
    function i(n) {
      return null == n ? r : (n += '', function () {
        var t, e = this.getAttributeNS(a.space, a.local);
        return e !== n && (t = o(e, n), function (n) {
          this.setAttributeNS(a.space, a.local, t(n));
        });
      });
    }
    if (arguments.length < 2) {
      for (t in n)
        this.attr(t, n[t]);
      return this;
    }
    var o = 'transform' == n ? Hu : du, a = Go.ns.qualify(n);
    return Oo(this, 'attr.' + n, t, a.local ? i : u);
  }, Rs.attrTween = function (n, t) {
    function e(n, e) {
      var r = t.call(this, n, e, this.getAttribute(u));
      return r && function (n) {
        this.setAttribute(u, r(n));
      };
    }
    function r(n, e) {
      var r = t.call(this, n, e, this.getAttributeNS(u.space, u.local));
      return r && function (n) {
        this.setAttributeNS(u.space, u.local, r(n));
      };
    }
    var u = Go.ns.qualify(n);
    return this.tween('attr.' + n, u.local ? r : e);
  }, Rs.style = function (n, t, e) {
    function r() {
      this.style.removeProperty(n);
    }
    function u(t) {
      return null == t ? r : (t += '', function () {
        var r, u = ea.getComputedStyle(this, null).getPropertyValue(n);
        return u !== t && (r = du(u, t), function (t) {
          this.style.setProperty(n, r(t), e);
        });
      });
    }
    var i = arguments.length;
    if (3 > i) {
      if ('string' != typeof n) {
        2 > i && (t = '');
        for (e in n)
          this.style(e, n[e], t);
        return this;
      }
      e = '';
    }
    return Oo(this, 'style.' + n, t, u);
  }, Rs.styleTween = function (n, t, e) {
    function r(r, u) {
      var i = t.call(this, r, u, ea.getComputedStyle(this, null).getPropertyValue(n));
      return i && function (t) {
        this.style.setProperty(n, i(t), e);
      };
    }
    return arguments.length < 3 && (e = ''), this.tween('style.' + n, r);
  }, Rs.text = function (n) {
    return Oo(this, 'text', n, Io);
  }, Rs.remove = function () {
    return this.each('end.transition', function () {
      var n;
      this.__transition__.count < 2 && (n = this.parentNode) && n.removeChild(this);
    });
  }, Rs.ease = function (n) {
    var t = this.id;
    return arguments.length < 1 ? this.node().__transition__[t].ease : ('function' != typeof n && (n = Go.ease.apply(Go, arguments)), P(this, function (e) {
      e.__transition__[t].ease = n;
    }));
  }, Rs.delay = function (n) {
    var t = this.id;
    return arguments.length < 1 ? this.node().__transition__[t].delay : P(this, 'function' == typeof n ? function (e, r, u) {
      e.__transition__[t].delay = +n.call(e, e.__data__, r, u);
    } : (n = +n, function (e) {
      e.__transition__[t].delay = n;
    }));
  }, Rs.duration = function (n) {
    var t = this.id;
    return arguments.length < 1 ? this.node().__transition__[t].duration : P(this, 'function' == typeof n ? function (e, r, u) {
      e.__transition__[t].duration = Math.max(1, n.call(e, e.__data__, r, u));
    } : (n = Math.max(1, n), function (e) {
      e.__transition__[t].duration = n;
    }));
  }, Rs.each = function (n, t) {
    var e = this.id;
    if (arguments.length < 2) {
      var r = Ts, u = Ls;
      Ls = e, P(this, function (t, r, u) {
        Ts = t.__transition__[e], n.call(t, t.__data__, r, u);
      }), Ts = r, Ls = u;
    } else
      P(this, function (r) {
        var u = r.__transition__[e];
        (u.event || (u.event = Go.dispatch('start', 'end'))).on(n, t);
      });
    return this;
  }, Rs.transition = function () {
    for (var n, t, e, r, u = this.id, i = ++Ds, o = [], a = 0, c = this.length; c > a; a++) {
      o.push(n = []);
      for (var t = this[a], s = 0, l = t.length; l > s; s++)
        (e = t[s]) && (r = Object.create(e.__transition__[u]), r.delay += r.duration, Yo(e, s, i, r)), n.push(e);
    }
    return Fo(o, i);
  }, Go.svg.axis = function () {
    function n(n) {
      n.each(function () {
        var n, s = Go.select(this), l = this.__chart__ || e, f = this.__chart__ = e.copy(), h = null == c ? f.ticks ? f.ticks.apply(f, a) : f.domain() : c, g = null == t ? f.tickFormat ? f.tickFormat.apply(f, a) : At : t, p = s.selectAll('.tick').data(h, f), v = p.enter().insert('g', '.domain').attr('class', 'tick').style('opacity', Ta), d = Go.transition(p.exit()).style('opacity', Ta).remove(), m = Go.transition(p.order()).style('opacity', 1), y = Hi(f), x = s.selectAll('.domain').data([0]), M = (x.enter().append('path').attr('class', 'domain'), Go.transition(x));
        v.append('line'), v.append('text');
        var _ = v.select('line'), b = m.select('line'), w = p.select('text').text(g), S = v.select('text'), k = m.select('text');
        switch (r) {
        case 'bottom':
          n = Zo, _.attr('y2', u), S.attr('y', Math.max(u, 0) + o), b.attr('x2', 0).attr('y2', u), k.attr('x', 0).attr('y', Math.max(u, 0) + o), w.attr('dy', '.71em').style('text-anchor', 'middle'), M.attr('d', 'M' + y[0] + ',' + i + 'V0H' + y[1] + 'V' + i);
          break;
        case 'top':
          n = Zo, _.attr('y2', -u), S.attr('y', -(Math.max(u, 0) + o)), b.attr('x2', 0).attr('y2', -u), k.attr('x', 0).attr('y', -(Math.max(u, 0) + o)), w.attr('dy', '0em').style('text-anchor', 'middle'), M.attr('d', 'M' + y[0] + ',' + -i + 'V0H' + y[1] + 'V' + -i);
          break;
        case 'left':
          n = Vo, _.attr('x2', -u), S.attr('x', -(Math.max(u, 0) + o)), b.attr('x2', -u).attr('y2', 0), k.attr('x', -(Math.max(u, 0) + o)).attr('y', 0), w.attr('dy', '.32em').style('text-anchor', 'end'), M.attr('d', 'M' + -i + ',' + y[0] + 'H0V' + y[1] + 'H' + -i);
          break;
        case 'right':
          n = Vo, _.attr('x2', u), S.attr('x', Math.max(u, 0) + o), b.attr('x2', u).attr('y2', 0), k.attr('x', Math.max(u, 0) + o).attr('y', 0), w.attr('dy', '.32em').style('text-anchor', 'start'), M.attr('d', 'M' + i + ',' + y[0] + 'H0V' + y[1] + 'H' + i);
        }
        if (f.rangeBand) {
          var E = f, A = E.rangeBand() / 2;
          l = f = function (n) {
            return E(n) + A;
          };
        } else
          l.rangeBand ? l = f : d.call(n, f);
        v.call(n, l), m.call(n, f);
      });
    }
    var t, e = Go.scale.linear(), r = Ps, u = 6, i = 6, o = 3, a = [10], c = null;
    return n.scale = function (t) {
      return arguments.length ? (e = t, n) : e;
    }, n.orient = function (t) {
      return arguments.length ? (r = t in Us ? t + '' : Ps, n) : r;
    }, n.ticks = function () {
      return arguments.length ? (a = arguments, n) : a;
    }, n.tickValues = function (t) {
      return arguments.length ? (c = t, n) : c;
    }, n.tickFormat = function (e) {
      return arguments.length ? (t = e, n) : t;
    }, n.tickSize = function (t) {
      var e = arguments.length;
      return e ? (u = +t, i = +arguments[e - 1], n) : u;
    }, n.innerTickSize = function (t) {
      return arguments.length ? (u = +t, n) : u;
    }, n.outerTickSize = function (t) {
      return arguments.length ? (i = +t, n) : i;
    }, n.tickPadding = function (t) {
      return arguments.length ? (o = +t, n) : o;
    }, n.tickSubdivide = function () {
      return arguments.length && n;
    }, n;
  };
  var Ps = 'bottom', Us = {
      top: 1,
      right: 1,
      bottom: 1,
      left: 1
    };
  Go.svg.brush = function () {
    function n(i) {
      i.each(function () {
        var i = Go.select(this).style('pointer-events', 'all').style('-webkit-tap-highlight-color', 'rgba(0,0,0,0)').on('mousedown.brush', u).on('touchstart.brush', u), o = i.selectAll('.background').data([0]);
        o.enter().append('rect').attr('class', 'background').style('visibility', 'hidden').style('cursor', 'crosshair'), i.selectAll('.extent').data([0]).enter().append('rect').attr('class', 'extent').style('cursor', 'move');
        var a = i.selectAll('.resize').data(p, At);
        a.exit().remove(), a.enter().append('g').attr('class', function (n) {
          return 'resize ' + n;
        }).style('cursor', function (n) {
          return js[n];
        }).append('rect').attr('x', function (n) {
          return /[ew]$/.test(n) ? -3 : null;
        }).attr('y', function (n) {
          return /^[ns]/.test(n) ? -3 : null;
        }).attr('width', 6).attr('height', 6).style('visibility', 'hidden'), a.style('display', n.empty() ? 'none' : null);
        var l, f = Go.transition(i), h = Go.transition(o);
        c && (l = Hi(c), h.attr('x', l[0]).attr('width', l[1] - l[0]), e(f)), s && (l = Hi(s), h.attr('y', l[0]).attr('height', l[1] - l[0]), r(f)), t(f);
      });
    }
    function t(n) {
      n.selectAll('.resize').attr('transform', function (n) {
        return 'translate(' + l[+/e$/.test(n)] + ',' + f[+/^s/.test(n)] + ')';
      });
    }
    function e(n) {
      n.select('.extent').attr('x', l[0]), n.selectAll('.extent,.n>rect,.s>rect').attr('width', l[1] - l[0]);
    }
    function r(n) {
      n.select('.extent').attr('y', f[0]), n.selectAll('.extent,.e>rect,.w>rect').attr('height', f[1] - f[0]);
    }
    function u() {
      function u() {
        32 == Go.event.keyCode && (C || (x = null, L[0] -= l[1], L[1] -= f[1], C = 2), y());
      }
      function p() {
        32 == Go.event.keyCode && 2 == C && (L[0] += l[1], L[1] += f[1], C = 0, y());
      }
      function v() {
        var n = Go.mouse(_), u = !1;
        M && (n[0] += M[0], n[1] += M[1]), C || (Go.event.altKey ? (x || (x = [
          (l[0] + l[1]) / 2,
          (f[0] + f[1]) / 2
        ]), L[0] = l[+(n[0] < x[0])], L[1] = f[+(n[1] < x[1])]) : x = null), E && d(n, c, 0) && (e(S), u = !0), A && d(n, s, 1) && (r(S), u = !0), u && (t(S), w({
          type: 'brush',
          mode: C ? 'move' : 'resize'
        }));
      }
      function d(n, t, e) {
        var r, u, a = Hi(t), c = a[0], s = a[1], p = L[e], v = e ? f : l, d = v[1] - v[0];
        return C && (c -= p, s -= d + p), r = (e ? g : h) ? Math.max(c, Math.min(s, n[e])) : n[e], C ? u = (r += p) + d : (x && (p = Math.max(c, Math.min(s, 2 * x[e] - r))), r > p ? (u = r, r = p) : u = p), v[0] != r || v[1] != u ? (e ? o = null : i = null, v[0] = r, v[1] = u, !0) : void 0;
      }
      function m() {
        v(), S.style('pointer-events', 'all').selectAll('.resize').style('display', n.empty() ? 'none' : null), Go.select('body').style('cursor', null), T.on('mousemove.brush', null).on('mouseup.brush', null).on('touchmove.brush', null).on('touchend.brush', null).on('keydown.brush', null).on('keyup.brush', null), N(), w({ type: 'brushend' });
      }
      var x, M, _ = this, b = Go.select(Go.event.target), w = a.of(_, arguments), S = Go.select(_), k = b.datum(), E = !/^(n|s)$/.test(k) && c, A = !/^(e|w)$/.test(k) && s, C = b.classed('extent'), N = Y(), L = Go.mouse(_), T = Go.select(ea).on('keydown.brush', u).on('keyup.brush', p);
      if (Go.event.changedTouches ? T.on('touchmove.brush', v).on('touchend.brush', m) : T.on('mousemove.brush', v).on('mouseup.brush', m), S.interrupt().selectAll('*').interrupt(), C)
        L[0] = l[0] - L[0], L[1] = f[0] - L[1];
      else if (k) {
        var q = +/w$/.test(k), z = +/^n/.test(k);
        M = [
          l[1 - q] - L[0],
          f[1 - z] - L[1]
        ], L[0] = l[q], L[1] = f[z];
      } else
        Go.event.altKey && (x = L.slice());
      S.style('pointer-events', 'none').selectAll('.resize').style('display', null), Go.select('body').style('cursor', b.style('cursor')), w({ type: 'brushstart' }), v();
    }
    var i, o, a = M(n, 'brushstart', 'brush', 'brushend'), c = null, s = null, l = [
        0,
        0
      ], f = [
        0,
        0
      ], h = !0, g = !0, p = Hs[0];
    return n.event = function (n) {
      n.each(function () {
        var n = a.of(this, arguments), t = {
            x: l,
            y: f,
            i: i,
            j: o
          }, e = this.__chart__ || t;
        this.__chart__ = t, Ls ? Go.select(this).transition().each('start.brush', function () {
          i = e.i, o = e.j, l = e.x, f = e.y, n({ type: 'brushstart' });
        }).tween('brush:brush', function () {
          var e = mu(l, t.x), r = mu(f, t.y);
          return i = o = null, function (u) {
            l = t.x = e(u), f = t.y = r(u), n({
              type: 'brush',
              mode: 'resize'
            });
          };
        }).each('end.brush', function () {
          i = t.i, o = t.j, n({
            type: 'brush',
            mode: 'resize'
          }), n({ type: 'brushend' });
        }) : (n({ type: 'brushstart' }), n({
          type: 'brush',
          mode: 'resize'
        }), n({ type: 'brushend' }));
      });
    }, n.x = function (t) {
      return arguments.length ? (c = t, p = Hs[!c << 1 | !s], n) : c;
    }, n.y = function (t) {
      return arguments.length ? (s = t, p = Hs[!c << 1 | !s], n) : s;
    }, n.clamp = function (t) {
      return arguments.length ? (c && s ? (h = !!t[0], g = !!t[1]) : c ? h = !!t : s && (g = !!t), n) : c && s ? [
        h,
        g
      ] : c ? h : s ? g : null;
    }, n.extent = function (t) {
      var e, r, u, a, h;
      return arguments.length ? (c && (e = t[0], r = t[1], s && (e = e[0], r = r[0]), i = [
        e,
        r
      ], c.invert && (e = c(e), r = c(r)), e > r && (h = e, e = r, r = h), (e != l[0] || r != l[1]) && (l = [
        e,
        r
      ])), s && (u = t[0], a = t[1], c && (u = u[1], a = a[1]), o = [
        u,
        a
      ], s.invert && (u = s(u), a = s(a)), u > a && (h = u, u = a, a = h), (u != f[0] || a != f[1]) && (f = [
        u,
        a
      ])), n) : (c && (i ? (e = i[0], r = i[1]) : (e = l[0], r = l[1], c.invert && (e = c.invert(e), r = c.invert(r)), e > r && (h = e, e = r, r = h))), s && (o ? (u = o[0], a = o[1]) : (u = f[0], a = f[1], s.invert && (u = s.invert(u), a = s.invert(a)), u > a && (h = u, u = a, a = h))), c && s ? [
        [
          e,
          u
        ],
        [
          r,
          a
        ]
      ] : c ? [
        e,
        r
      ] : s && [
        u,
        a
      ]);
    }, n.clear = function () {
      return n.empty() || (l = [
        0,
        0
      ], f = [
        0,
        0
      ], i = o = null), n;
    }, n.empty = function () {
      return !!c && l[0] == l[1] || !!s && f[0] == f[1];
    }, Go.rebind(n, a, 'on');
  };
  var js = {
      n: 'ns-resize',
      e: 'ew-resize',
      s: 'ns-resize',
      w: 'ew-resize',
      nw: 'nwse-resize',
      ne: 'nesw-resize',
      se: 'nwse-resize',
      sw: 'nesw-resize'
    }, Hs = [
      [
        'n',
        'e',
        's',
        'w',
        'nw',
        'ne',
        'se',
        'sw'
      ],
      [
        'e',
        'w'
      ],
      [
        'n',
        's'
      ],
      []
    ], Fs = ic.format = fc.timeFormat, Os = Fs.utc, Is = Os('%Y-%m-%dT%H:%M:%S.%LZ');
  Fs.iso = Date.prototype.toISOString && +new Date('2000-01-01T00:00:00.000Z') ? $o : Is, $o.parse = function (n) {
    var t = new Date(n);
    return isNaN(t) ? null : t;
  }, $o.toString = Is.toString, ic.second = Ht(function (n) {
    return new oc(1000 * Math.floor(n / 1000));
  }, function (n, t) {
    n.setTime(n.getTime() + 1000 * Math.floor(t));
  }, function (n) {
    return n.getSeconds();
  }), ic.seconds = ic.second.range, ic.seconds.utc = ic.second.utc.range, ic.minute = Ht(function (n) {
    return new oc(60000 * Math.floor(n / 60000));
  }, function (n, t) {
    n.setTime(n.getTime() + 60000 * Math.floor(t));
  }, function (n) {
    return n.getMinutes();
  }), ic.minutes = ic.minute.range, ic.minutes.utc = ic.minute.utc.range, ic.hour = Ht(function (n) {
    var t = n.getTimezoneOffset() / 60;
    return new oc(3600000 * (Math.floor(n / 3600000 - t) + t));
  }, function (n, t) {
    n.setTime(n.getTime() + 3600000 * Math.floor(t));
  }, function (n) {
    return n.getHours();
  }), ic.hours = ic.hour.range, ic.hours.utc = ic.hour.utc.range, ic.month = Ht(function (n) {
    return n = ic.day(n), n.setDate(1), n;
  }, function (n, t) {
    n.setMonth(n.getMonth() + t);
  }, function (n) {
    return n.getMonth();
  }), ic.months = ic.month.range, ic.months.utc = ic.month.utc.range;
  var Ys = [
      1000,
      5000,
      15000,
      30000,
      60000,
      300000,
      900000,
      1800000,
      3600000,
      10800000,
      21600000,
      43200000,
      86400000,
      172800000,
      604800000,
      2592000000,
      7776000000,
      31536000000
    ], Zs = [
      [
        ic.second,
        1
      ],
      [
        ic.second,
        5
      ],
      [
        ic.second,
        15
      ],
      [
        ic.second,
        30
      ],
      [
        ic.minute,
        1
      ],
      [
        ic.minute,
        5
      ],
      [
        ic.minute,
        15
      ],
      [
        ic.minute,
        30
      ],
      [
        ic.hour,
        1
      ],
      [
        ic.hour,
        3
      ],
      [
        ic.hour,
        6
      ],
      [
        ic.hour,
        12
      ],
      [
        ic.day,
        1
      ],
      [
        ic.day,
        2
      ],
      [
        ic.week,
        1
      ],
      [
        ic.month,
        1
      ],
      [
        ic.month,
        3
      ],
      [
        ic.year,
        1
      ]
    ], Vs = Fs.multi([
      [
        '.%L',
        function (n) {
          return n.getMilliseconds();
        }
      ],
      [
        ':%S',
        function (n) {
          return n.getSeconds();
        }
      ],
      [
        '%I:%M',
        function (n) {
          return n.getMinutes();
        }
      ],
      [
        '%I %p',
        function (n) {
          return n.getHours();
        }
      ],
      [
        '%a %d',
        function (n) {
          return n.getDay() && 1 != n.getDate();
        }
      ],
      [
        '%b %d',
        function (n) {
          return 1 != n.getDate();
        }
      ],
      [
        '%B',
        function (n) {
          return n.getMonth();
        }
      ],
      [
        '%Y',
        Ae
      ]
    ]), $s = {
      range: function (n, t, e) {
        return Go.range(Math.ceil(n / e) * e, +t, e).map(Bo);
      },
      floor: At,
      ceil: At
    };
  Zs.year = ic.year, ic.scale = function () {
    return Xo(Go.scale.linear(), Zs, Vs);
  };
  var Xs = Zs.map(function (n) {
      return [
        n[0].utc,
        n[1]
      ];
    }), Bs = Os.multi([
      [
        '.%L',
        function (n) {
          return n.getUTCMilliseconds();
        }
      ],
      [
        ':%S',
        function (n) {
          return n.getUTCSeconds();
        }
      ],
      [
        '%I:%M',
        function (n) {
          return n.getUTCMinutes();
        }
      ],
      [
        '%I %p',
        function (n) {
          return n.getUTCHours();
        }
      ],
      [
        '%a %d',
        function (n) {
          return n.getUTCDay() && 1 != n.getUTCDate();
        }
      ],
      [
        '%b %d',
        function (n) {
          return 1 != n.getUTCDate();
        }
      ],
      [
        '%B',
        function (n) {
          return n.getUTCMonth();
        }
      ],
      [
        '%Y',
        Ae
      ]
    ]);
  Xs.year = ic.year.utc, ic.scale.utc = function () {
    return Xo(Go.scale.linear(), Xs, Bs);
  }, Go.text = Ct(function (n) {
    return n.responseText;
  }), Go.json = function (n, t) {
    return Nt(n, 'application/json', Jo, t);
  }, Go.html = function (n, t) {
    return Nt(n, 'text/html', Wo, t);
  }, Go.xml = Ct(function (n) {
    return n.responseXML;
  }), 'function' == typeof define && define.amd ? define(Go) : 'object' == typeof module && module.exports ? module.exports = Go : this.d3 = Go;
}();
this.createjs = this.createjs || {};
(function () {
  var c = function () {
    throw 'UID cannot be instantiated';
  };
  c._nextID = 0;
  c.get = function () {
    return c._nextID++;
  };
  createjs.UID = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
      this.initialize();
    }, b = c.prototype;
  c.initialize = function (a) {
    a.addEventListener = b.addEventListener;
    a.removeEventListener = b.removeEventListener;
    a.removeAllEventListeners = b.removeAllEventListeners;
    a.hasEventListener = b.hasEventListener;
    a.dispatchEvent = b.dispatchEvent;
  };
  b._listeners = null;
  b.initialize = function () {
  };
  b.addEventListener = function (a, m) {
    var b = this._listeners;
    b ? this.removeEventListener(a, m) : b = this._listeners = {};
    var d = b[a];
    d || (d = b[a] = []);
    d.push(m);
    return m;
  };
  b.removeEventListener = function (a, m) {
    var b = this._listeners;
    if (b) {
      var d = b[a];
      if (d)
        for (var e = 0, c = d.length; e < c; e++)
          if (d[e] == m) {
            1 == c ? delete b[a] : d.splice(e, 1);
            break;
          }
    }
  };
  b.removeAllEventListeners = function (a) {
    a ? this._listeners && delete this._listeners[a] : this._listeners = null;
  };
  b.dispatchEvent = function (a, m) {
    var b = !1, d = this._listeners;
    if (a && d) {
      'string' == typeof a && (a = { type: a });
      d = d[a.type];
      if (!d)
        return b;
      a.target = m || this;
      for (var d = d.slice(), e = 0, c = d.length; e < c; e++)
        var h = d[e], b = h.handleEvent ? b || h.handleEvent(a) : b || h(a);
    }
    return !!b;
  };
  b.hasEventListener = function (a) {
    var m = this._listeners;
    return !(!m || !m[a]);
  };
  b.toString = function () {
    return '[EventDispatcher]';
  };
  createjs.EventDispatcher = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
    throw 'Ticker cannot be instantiated.';
  };
  c.useRAF = !1;
  c.addEventListener = null;
  c.removeEventListener = null;
  c.removeAllEventListeners = null;
  c.dispatchEvent = null;
  c.hasEventListener = null;
  c._listeners = null;
  createjs.EventDispatcher.initialize(c);
  c._listeners = null;
  c._pauseable = null;
  c._paused = !1;
  c._inited = !1;
  c._startTime = 0;
  c._pausedTime = 0;
  c._ticks = 0;
  c._pausedTicks = 0;
  c._interval = 50;
  c._lastTime = 0;
  c._times = null;
  c._tickTimes = null;
  c._rafActive = !1;
  c._timeoutID = null;
  c.addListener = function (a, m) {
    null != a && (c.removeListener(a), c._pauseable[c._listeners.length] = null == m ? !0 : m, c._listeners.push(a));
  };
  c.init = function () {
    c._inited = !0;
    c._times = [];
    c._tickTimes = [];
    c._pauseable = [];
    c._listeners = [];
    c._times.push(c._lastTime = c._startTime = c._getTime());
    c.setInterval(c._interval);
  };
  c.removeListener = function (a) {
    var m = c._listeners;
    m && (a = m.indexOf(a), -1 != a && (m.splice(a, 1), c._pauseable.splice(a, 1)));
  };
  c.removeAllListeners = function () {
    c._listeners = [];
    c._pauseable = [];
  };
  c.setInterval = function (a) {
    c._interval = a;
    c._inited && c._setupTick();
  };
  c.getInterval = function () {
    return c._interval;
  };
  c.setFPS = function (a) {
    c.setInterval(1000 / a);
  };
  c.getFPS = function () {
    return 1000 / c._interval;
  };
  c.getMeasuredFPS = function (a) {
    if (2 > c._times.length)
      return -1;
    null == a && (a = c.getFPS() | 0);
    a = Math.min(c._times.length - 1, a);
    return 1000 / ((c._times[0] - c._times[a]) / a);
  };
  c.setPaused = function (a) {
    c._paused = a;
  };
  c.getPaused = function () {
    return c._paused;
  };
  c.getTime = function (a) {
    return c._getTime() - c._startTime - (a ? c._pausedTime : 0);
  };
  c.getTicks = function (a) {
    return c._ticks - (a ? c._pausedTicks : 0);
  };
  c._handleAF = function () {
    c._rafActive = !1;
    c._setupTick();
    c._getTime() - c._lastTime >= 0.97 * (c._interval - 1) && c._tick();
  };
  c._handleTimeout = function () {
    c.timeoutID = null;
    c._setupTick();
    c._tick();
  };
  c._setupTick = function () {
    if (!(c._rafActive || null != c.timeoutID)) {
      if (c.useRAF) {
        var a = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;
        if (a) {
          a(c._handleAF);
          c._rafActive = !0;
          return;
        }
      }
      c.timeoutID = setTimeout(c._handleTimeout, c._interval);
    }
  };
  c._tick = function () {
    var a = c._getTime();
    c._ticks++;
    var m = a - c._lastTime, b = c._paused;
    b && (c._pausedTicks++, c._pausedTime += m);
    c._lastTime = a;
    for (var d = c._pauseable, e = c._listeners.slice(), f = e ? e.length : 0, h = 0; h < f; h++) {
      var k = e[h];
      null == k || b && d[h] || (k.tick ? k.tick(m, b) : k instanceof Function && k(m, b));
    }
    c.dispatchEvent({
      type: 'tick',
      paused: b,
      delta: m,
      time: a,
      runTime: a - c._pausedTime
    });
    for (c._tickTimes.unshift(c._getTime() - a); 100 < c._tickTimes.length;)
      c._tickTimes.pop();
    for (c._times.unshift(a); 100 < c._times.length;)
      c._times.pop();
  };
  var b = window.performance && (performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow);
  c._getTime = function () {
    return b && b.call(performance) || new Date().getTime();
  };
  c.init();
  createjs.Ticker = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a, m, b, d, e, c, h, k, j) {
      this.initialize(a, m, b, d, e, c, h, k, j);
    }, b = c.prototype;
  b.stageX = 0;
  b.stageY = 0;
  b.rawX = 0;
  b.rawY = 0;
  b.type = null;
  b.nativeEvent = null;
  b.onMouseMove = null;
  b.onMouseUp = null;
  b.target = null;
  b.pointerID = 0;
  b.primary = !1;
  b.addEventListener = null;
  b.removeEventListener = null;
  b.removeAllEventListeners = null;
  b.dispatchEvent = null;
  b.hasEventListener = null;
  b._listeners = null;
  createjs.EventDispatcher.initialize(b);
  b.initialize = function (a, m, b, d, e, c, h, k, j) {
    this.type = a;
    this.stageX = m;
    this.stageY = b;
    this.target = d;
    this.nativeEvent = e;
    this.pointerID = c;
    this.primary = h;
    this.rawX = null == k ? m : k;
    this.rawY = null == j ? b : j;
  };
  b.clone = function () {
    return new c(this.type, this.stageX, this.stageY, this.target, this.nativeEvent, this.pointerID, this.primary, this.rawX, this.rawY);
  };
  b.toString = function () {
    return '[MouseEvent (type=' + this.type + ' stageX=' + this.stageX + ' stageY=' + this.stageY + ')]';
  };
  createjs.MouseEvent = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a, m, b, d, c, f) {
      this.initialize(a, m, b, d, c, f);
    }, b = c.prototype;
  c.identity = null;
  c.DEG_TO_RAD = Math.PI / 180;
  b.a = 1;
  b.b = 0;
  b.c = 0;
  b.d = 1;
  b.tx = 0;
  b.ty = 0;
  b.alpha = 1;
  b.shadow = null;
  b.compositeOperation = null;
  b.initialize = function (a, m, b, d, c, f) {
    null != a && (this.a = a);
    this.b = m || 0;
    this.c = b || 0;
    null != d && (this.d = d);
    this.tx = c || 0;
    this.ty = f || 0;
    return this;
  };
  b.prepend = function (a, b, g, d, c, f) {
    var h = this.tx;
    if (1 != a || 0 != b || 0 != g || 1 != d) {
      var k = this.a, j = this.c;
      this.a = k * a + this.b * g;
      this.b = k * b + this.b * d;
      this.c = j * a + this.d * g;
      this.d = j * b + this.d * d;
    }
    this.tx = h * a + this.ty * g + c;
    this.ty = h * b + this.ty * d + f;
    return this;
  };
  b.append = function (a, b, g, d, c, f) {
    var h = this.a, k = this.b, j = this.c, l = this.d;
    this.a = a * h + b * j;
    this.b = a * k + b * l;
    this.c = g * h + d * j;
    this.d = g * k + d * l;
    this.tx = c * h + f * j + this.tx;
    this.ty = c * k + f * l + this.ty;
    return this;
  };
  b.prependMatrix = function (a) {
    this.prepend(a.a, a.b, a.c, a.d, a.tx, a.ty);
    this.prependProperties(a.alpha, a.shadow, a.compositeOperation);
    return this;
  };
  b.appendMatrix = function (a) {
    this.append(a.a, a.b, a.c, a.d, a.tx, a.ty);
    this.appendProperties(a.alpha, a.shadow, a.compositeOperation);
    return this;
  };
  b.prependTransform = function (a, b, g, d, e, f, h, k, j) {
    if (e % 360) {
      var l = e * c.DEG_TO_RAD;
      e = Math.cos(l);
      l = Math.sin(l);
    } else
      e = 1, l = 0;
    if (k || j)
      this.tx -= k, this.ty -= j;
    f || h ? (f *= c.DEG_TO_RAD, h *= c.DEG_TO_RAD, this.prepend(e * g, l * g, -l * d, e * d, 0, 0), this.prepend(Math.cos(h), Math.sin(h), -Math.sin(f), Math.cos(f), a, b)) : this.prepend(e * g, l * g, -l * d, e * d, a, b);
    return this;
  };
  b.appendTransform = function (a, b, g, d, e, f, h, k, j) {
    if (e % 360) {
      var l = e * c.DEG_TO_RAD;
      e = Math.cos(l);
      l = Math.sin(l);
    } else
      e = 1, l = 0;
    f || h ? (f *= c.DEG_TO_RAD, h *= c.DEG_TO_RAD, this.append(Math.cos(h), Math.sin(h), -Math.sin(f), Math.cos(f), a, b), this.append(e * g, l * g, -l * d, e * d, 0, 0)) : this.append(e * g, l * g, -l * d, e * d, a, b);
    if (k || j)
      this.tx -= k * this.a + j * this.c, this.ty -= k * this.b + j * this.d;
    return this;
  };
  b.rotate = function (a) {
    var b = Math.cos(a);
    a = Math.sin(a);
    var g = this.a, d = this.c, c = this.tx;
    this.a = g * b - this.b * a;
    this.b = g * a + this.b * b;
    this.c = d * b - this.d * a;
    this.d = d * a + this.d * b;
    this.tx = c * b - this.ty * a;
    this.ty = c * a + this.ty * b;
    return this;
  };
  b.skew = function (a, b) {
    a *= c.DEG_TO_RAD;
    b *= c.DEG_TO_RAD;
    this.append(Math.cos(b), Math.sin(b), -Math.sin(a), Math.cos(a), 0, 0);
    return this;
  };
  b.scale = function (a, b) {
    this.a *= a;
    this.d *= b;
    this.c *= a;
    this.b *= b;
    this.tx *= a;
    this.ty *= b;
    return this;
  };
  b.translate = function (a, b) {
    this.tx += a;
    this.ty += b;
    return this;
  };
  b.identity = function () {
    this.alpha = this.a = this.d = 1;
    this.b = this.c = this.tx = this.ty = 0;
    this.shadow = this.compositeOperation = null;
    return this;
  };
  b.invert = function () {
    var a = this.a, b = this.b, g = this.c, d = this.d, c = this.tx, f = a * d - b * g;
    this.a = d / f;
    this.b = -b / f;
    this.c = -g / f;
    this.d = a / f;
    this.tx = (g * this.ty - d * c) / f;
    this.ty = -(a * this.ty - b * c) / f;
    return this;
  };
  b.isIdentity = function () {
    return 0 == this.tx && 0 == this.ty && 1 == this.a && 0 == this.b && 0 == this.c && 1 == this.d;
  };
  b.decompose = function (a) {
    null == a && (a = {});
    a.x = this.tx;
    a.y = this.ty;
    a.scaleX = Math.sqrt(this.a * this.a + this.b * this.b);
    a.scaleY = Math.sqrt(this.c * this.c + this.d * this.d);
    var b = Math.atan2(-this.c, this.d), g = Math.atan2(this.b, this.a);
    b == g ? (a.rotation = g / c.DEG_TO_RAD, 0 > this.a && 0 <= this.d && (a.rotation += 0 >= a.rotation ? 180 : -180), a.skewX = a.skewY = 0) : (a.skewX = b / c.DEG_TO_RAD, a.skewY = g / c.DEG_TO_RAD);
    return a;
  };
  b.reinitialize = function (a, b, g, d, c, f, h, k, j) {
    this.initialize(a, b, g, d, c, f);
    this.alpha = h || 1;
    this.shadow = k;
    this.compositeOperation = j;
    return this;
  };
  b.appendProperties = function (a, b, g) {
    this.alpha *= a;
    this.shadow = b || this.shadow;
    this.compositeOperation = g || this.compositeOperation;
    return this;
  };
  b.prependProperties = function (a, b, g) {
    this.alpha *= a;
    this.shadow = this.shadow || b;
    this.compositeOperation = this.compositeOperation || g;
    return this;
  };
  b.clone = function () {
    var a = new c(this.a, this.b, this.c, this.d, this.tx, this.ty);
    a.shadow = this.shadow;
    a.alpha = this.alpha;
    a.compositeOperation = this.compositeOperation;
    return a;
  };
  b.toString = function () {
    return '[Matrix2D (a=' + this.a + ' b=' + this.b + ' c=' + this.c + ' d=' + this.d + ' tx=' + this.tx + ' ty=' + this.ty + ')]';
  };
  c.identity = new c(1, 0, 0, 1, 0, 0);
  createjs.Matrix2D = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a, b) {
      this.initialize(a, b);
    }, b = c.prototype;
  b.x = 0;
  b.y = 0;
  b.initialize = function (a, b) {
    this.x = null == a ? 0 : a;
    this.y = null == b ? 0 : b;
  };
  b.clone = function () {
    return new c(this.x, this.y);
  };
  b.toString = function () {
    return '[Point (x=' + this.x + ' y=' + this.y + ')]';
  };
  createjs.Point = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a, b, g, d) {
      this.initialize(a, b, g, d);
    }, b = c.prototype;
  b.x = 0;
  b.y = 0;
  b.width = 0;
  b.height = 0;
  b.initialize = function (a, b, g, d) {
    this.x = null == a ? 0 : a;
    this.y = null == b ? 0 : b;
    this.width = null == g ? 0 : g;
    this.height = null == d ? 0 : d;
  };
  b.clone = function () {
    return new c(this.x, this.y, this.width, this.height);
  };
  b.toString = function () {
    return '[Rectangle (x=' + this.x + ' y=' + this.y + ' width=' + this.width + ' height=' + this.height + ')]';
  };
  createjs.Rectangle = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a, b, g, d, c, f, h) {
      this.initialize(a, b, g, d, c, f, h);
    }, b = c.prototype;
  b.target = null;
  b.overLabel = null;
  b.outLabel = null;
  b.downLabel = null;
  b.play = !1;
  b._isPressed = !1;
  b._isOver = !1;
  b.initialize = function (a, b, g, d, c, f, h) {
    a.addEventListener && (this.target = a, a.cursor = 'pointer', this.overLabel = null == g ? 'over' : g, this.outLabel = null == b ? 'out' : b, this.downLabel = null == d ? 'down' : d, this.play = c, this.setEnabled(!0), this.handleEvent({}), f && (h && (f.actionsEnabled = !1, f.gotoAndStop && f.gotoAndStop(h)), a.hitArea = f));
  };
  b.setEnabled = function (a) {
    var b = this.target;
    a ? (b.addEventListener('mouseover', this), b.addEventListener('mouseout', this), b.addEventListener('mousedown', this)) : (b.removeEventListener('mouseover', this), b.removeEventListener('mouseout', this), b.removeEventListener('mousedown', this));
  };
  b.toString = function () {
    return '[ButtonHelper]';
  };
  b.handleEvent = function (a) {
    var b = this.target, g = a.type;
    'mousedown' == g ? (a.addEventListener('mouseup', this), this._isPressed = !0, a = this.downLabel) : 'mouseup' == g ? (this._isPressed = !1, a = this._isOver ? this.overLabel : this.outLabel) : 'mouseover' == g ? (this._isOver = !0, a = this._isPressed ? this.downLabel : this.overLabel) : (this._isOver = !1, a = this._isPressed ? this.overLabel : this.outLabel);
    this.play ? b.gotoAndPlay && b.gotoAndPlay(a) : b.gotoAndStop && b.gotoAndStop(a);
  };
  createjs.ButtonHelper = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a, b, g, d) {
      this.initialize(a, b, g, d);
    }, b = c.prototype;
  c.identity = null;
  b.color = null;
  b.offsetX = 0;
  b.offsetY = 0;
  b.blur = 0;
  b.initialize = function (a, b, g, d) {
    this.color = a;
    this.offsetX = b;
    this.offsetY = g;
    this.blur = d;
  };
  b.toString = function () {
    return '[Shadow]';
  };
  b.clone = function () {
    return new c(this.color, this.offsetX, this.offsetY, this.blur);
  };
  c.identity = new c('transparent', 0, 0, 0);
  createjs.Shadow = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a) {
      this.initialize(a);
    }, b = c.prototype;
  b.complete = !0;
  b.onComplete = null;
  b.addEventListener = null;
  b.removeEventListener = null;
  b.removeAllEventListeners = null;
  b.dispatchEvent = null;
  b.hasEventListener = null;
  b._listeners = null;
  createjs.EventDispatcher.initialize(b);
  b._animations = null;
  b._frames = null;
  b._images = null;
  b._data = null;
  b._loadCount = 0;
  b._frameHeight = 0;
  b._frameWidth = 0;
  b._numFrames = 0;
  b._regX = 0;
  b._regY = 0;
  b.initialize = function (a) {
    var b, g, d;
    if (null != a) {
      if (a.images && 0 < (g = a.images.length)) {
        d = this._images = [];
        for (b = 0; b < g; b++) {
          var c = a.images[b];
          if ('string' == typeof c) {
            var f = c, c = new Image();
            c.src = f;
          }
          d.push(c);
          !c.getContext && !c.complete && (this._loadCount++, this.complete = !1, function (a) {
            c.onload = function () {
              a._handleImageLoad();
            };
          }(this));
        }
      }
      if (null != a.frames)
        if (a.frames instanceof Array) {
          this._frames = [];
          d = a.frames;
          b = 0;
          for (g = d.length; b < g; b++)
            f = d[b], this._frames.push({
              image: this._images[f[4] ? f[4] : 0],
              rect: new createjs.Rectangle(f[0], f[1], f[2], f[3]),
              regX: f[5] || 0,
              regY: f[6] || 0
            });
        } else
          g = a.frames, this._frameWidth = g.width, this._frameHeight = g.height, this._regX = g.regX || 0, this._regY = g.regY || 0, this._numFrames = g.count, 0 == this._loadCount && this._calculateFrames();
      if (null != (g = a.animations)) {
        this._animations = [];
        this._data = {};
        for (var h in g) {
          a = { name: h };
          f = g[h];
          if ('number' == typeof f)
            d = a.frames = [f];
          else if (f instanceof Array)
            if (1 == f.length)
              a.frames = [f[0]];
            else {
              a.frequency = f[3];
              a.next = f[2];
              d = a.frames = [];
              for (b = f[0]; b <= f[1]; b++)
                d.push(b);
            }
          else
            a.frequency = f.frequency, a.next = f.next, b = f.frames, d = a.frames = 'number' == typeof b ? [b] : b.slice(0);
          a.next = 2 > d.length || !1 == a.next ? null : null == a.next || !0 == a.next ? h : a.next;
          a.frequency || (a.frequency = 1);
          this._animations.push(h);
          this._data[h] = a;
        }
      }
    }
  };
  b.getNumFrames = function (a) {
    if (null == a)
      return this._frames ? this._frames.length : this._numFrames;
    a = this._data[a];
    return null == a ? 0 : a.frames.length;
  };
  b.getAnimations = function () {
    return this._animations.slice(0);
  };
  b.getAnimation = function (a) {
    return this._data[a];
  };
  b.getFrame = function (a) {
    var b;
    return this.complete && this._frames && (b = this._frames[a]) ? b : null;
  };
  b.getFrameBounds = function (a) {
    return (a = this.getFrame(a)) ? new createjs.Rectangle(-a.regX, -a.regY, a.rect.width, a.rect.height) : null;
  };
  b.toString = function () {
    return '[SpriteSheet]';
  };
  b.clone = function () {
    var a = new c();
    a.complete = this.complete;
    a._animations = this._animations;
    a._frames = this._frames;
    a._images = this._images;
    a._data = this._data;
    a._frameHeight = this._frameHeight;
    a._frameWidth = this._frameWidth;
    a._numFrames = this._numFrames;
    a._loadCount = this._loadCount;
    return a;
  };
  b._handleImageLoad = function () {
    0 == --this._loadCount && (this._calculateFrames(), this.complete = !0, this.onComplete && this.onComplete(), this.dispatchEvent('complete'));
  };
  b._calculateFrames = function () {
    if (!(this._frames || 0 == this._frameWidth)) {
      this._frames = [];
      for (var a = 0, b = this._frameWidth, g = this._frameHeight, d = 0, c = this._images; d < c.length; d++) {
        for (var f = c[d], h = (f.width + 1) / b | 0, k = (f.height + 1) / g | 0, k = 0 < this._numFrames ? Math.min(this._numFrames - a, h * k) : h * k, j = 0; j < k; j++)
          this._frames.push({
            image: f,
            rect: new createjs.Rectangle(j % h * b, (j / h | 0) * g, b, g),
            regX: this._regX,
            regY: this._regY
          });
        a += k;
      }
      this._numFrames = a;
    }
  };
  createjs.SpriteSheet = c;
}());
this.createjs = this.createjs || {};
(function () {
  function c(a, b, d) {
    this.f = a;
    this.params = b;
    this.path = null == d ? !0 : d;
  }
  c.prototype.exec = function (a) {
    this.f.apply(a, this.params);
  };
  var b = function () {
      this.initialize();
    }, a = b.prototype;
  b.getRGB = function (a, b, d, c) {
    null != a && null == d && (c = b, d = a & 255, b = a >> 8 & 255, a = a >> 16 & 255);
    return null == c ? 'rgb(' + a + ',' + b + ',' + d + ')' : 'rgba(' + a + ',' + b + ',' + d + ',' + c + ')';
  };
  b.getHSL = function (a, b, d, c) {
    return null == c ? 'hsl(' + a % 360 + ',' + b + '%,' + d + '%)' : 'hsla(' + a % 360 + ',' + b + '%,' + d + '%,' + c + ')';
  };
  b.BASE_64 = {
    A: 0,
    B: 1,
    C: 2,
    D: 3,
    E: 4,
    F: 5,
    G: 6,
    H: 7,
    I: 8,
    J: 9,
    K: 10,
    L: 11,
    M: 12,
    N: 13,
    O: 14,
    P: 15,
    Q: 16,
    R: 17,
    S: 18,
    T: 19,
    U: 20,
    V: 21,
    W: 22,
    X: 23,
    Y: 24,
    Z: 25,
    a: 26,
    b: 27,
    c: 28,
    d: 29,
    e: 30,
    f: 31,
    g: 32,
    h: 33,
    i: 34,
    j: 35,
    k: 36,
    l: 37,
    m: 38,
    n: 39,
    o: 40,
    p: 41,
    q: 42,
    r: 43,
    s: 44,
    t: 45,
    u: 46,
    v: 47,
    w: 48,
    x: 49,
    y: 50,
    z: 51,
    '0': 52,
    1: 53,
    2: 54,
    3: 55,
    4: 56,
    5: 57,
    6: 58,
    7: 59,
    8: 60,
    9: 61,
    '+': 62,
    '/': 63
  };
  b.STROKE_CAPS_MAP = [
    'butt',
    'round',
    'square'
  ];
  b.STROKE_JOINTS_MAP = [
    'miter',
    'round',
    'bevel'
  ];
  b._ctx = (createjs.createCanvas ? createjs.createCanvas() : document.createElement('canvas')).getContext('2d');
  b.beginCmd = new c(b._ctx.beginPath, [], !1);
  b.fillCmd = new c(b._ctx.fill, [], !1);
  b.strokeCmd = new c(b._ctx.stroke, [], !1);
  a._strokeInstructions = null;
  a._strokeStyleInstructions = null;
  a._ignoreScaleStroke = !1;
  a._fillInstructions = null;
  a._instructions = null;
  a._oldInstructions = null;
  a._activeInstructions = null;
  a._active = !1;
  a._dirty = !1;
  a.initialize = function () {
    this.clear();
    this._ctx = b._ctx;
  };
  a.isEmpty = function () {
    return !(this._instructions.length || this._oldInstructions.length || this._activeInstructions.length);
  };
  a.draw = function (a) {
    this._dirty && this._updateInstructions();
    for (var b = this._instructions, d = 0, c = b.length; d < c; d++)
      b[d].exec(a);
  };
  a.drawAsPath = function (a) {
    this._dirty && this._updateInstructions();
    for (var b, d = this._instructions, c = 0, f = d.length; c < f; c++)
      ((b = d[c]).path || 0 == c) && b.exec(a);
  };
  a.moveTo = function (a, b) {
    this._activeInstructions.push(new c(this._ctx.moveTo, [
      a,
      b
    ]));
    return this;
  };
  a.lineTo = function (a, b) {
    this._dirty = this._active = !0;
    this._activeInstructions.push(new c(this._ctx.lineTo, [
      a,
      b
    ]));
    return this;
  };
  a.arcTo = function (a, b, d, e, f) {
    this._dirty = this._active = !0;
    this._activeInstructions.push(new c(this._ctx.arcTo, [
      a,
      b,
      d,
      e,
      f
    ]));
    return this;
  };
  a.arc = function (a, b, d, e, f, h) {
    this._dirty = this._active = !0;
    null == h && (h = !1);
    this._activeInstructions.push(new c(this._ctx.arc, [
      a,
      b,
      d,
      e,
      f,
      h
    ]));
    return this;
  };
  a.quadraticCurveTo = function (a, b, d, e) {
    this._dirty = this._active = !0;
    this._activeInstructions.push(new c(this._ctx.quadraticCurveTo, [
      a,
      b,
      d,
      e
    ]));
    return this;
  };
  a.bezierCurveTo = function (a, b, d, e, f, h) {
    this._dirty = this._active = !0;
    this._activeInstructions.push(new c(this._ctx.bezierCurveTo, [
      a,
      b,
      d,
      e,
      f,
      h
    ]));
    return this;
  };
  a.rect = function (a, b, d, e) {
    this._dirty = this._active = !0;
    this._activeInstructions.push(new c(this._ctx.rect, [
      a,
      b,
      d,
      e
    ]));
    return this;
  };
  a.closePath = function () {
    this._active && (this._dirty = !0, this._activeInstructions.push(new c(this._ctx.closePath, [])));
    return this;
  };
  a.clear = function () {
    this._instructions = [];
    this._oldInstructions = [];
    this._activeInstructions = [];
    this._strokeStyleInstructions = this._strokeInstructions = this._fillInstructions = null;
    this._active = this._dirty = !1;
    return this;
  };
  a.beginFill = function (a) {
    this._active && this._newPath();
    this._fillInstructions = a ? [
      new c(this._setProp, [
        'fillStyle',
        a
      ], !1),
      b.fillCmd
    ] : null;
    return this;
  };
  a.beginLinearGradientFill = function (a, g, d, e, f, h) {
    this._active && this._newPath();
    d = this._ctx.createLinearGradient(d, e, f, h);
    e = 0;
    for (f = a.length; e < f; e++)
      d.addColorStop(g[e], a[e]);
    this._fillInstructions = [
      new c(this._setProp, [
        'fillStyle',
        d
      ], !1),
      b.fillCmd
    ];
    return this;
  };
  a.beginRadialGradientFill = function (a, g, d, e, f, h, k, j) {
    this._active && this._newPath();
    d = this._ctx.createRadialGradient(d, e, f, h, k, j);
    e = 0;
    for (f = a.length; e < f; e++)
      d.addColorStop(g[e], a[e]);
    this._fillInstructions = [
      new c(this._setProp, [
        'fillStyle',
        d
      ], !1),
      b.fillCmd
    ];
    return this;
  };
  a.beginBitmapFill = function (a, g, d) {
    this._active && this._newPath();
    a = this._ctx.createPattern(a, g || '');
    a = new c(this._setProp, [
      'fillStyle',
      a
    ], !1);
    this._fillInstructions = d ? [
      a,
      new c(this._ctx.save, [], !1),
      new c(this._ctx.transform, [
        d.a,
        d.b,
        d.c,
        d.d,
        d.tx,
        d.ty
      ], !1),
      b.fillCmd,
      new c(this._ctx.restore, [], !1)
    ] : [
      a,
      b.fillCmd
    ];
    return this;
  };
  a.endFill = function () {
    return this.beginFill();
  };
  a.setStrokeStyle = function (a, g, d, e, f) {
    this._active && this._newPath();
    this._strokeStyleInstructions = [
      new c(this._setProp, [
        'lineWidth',
        null == a ? '1' : a
      ], !1),
      new c(this._setProp, [
        'lineCap',
        null == g ? 'butt' : isNaN(g) ? g : b.STROKE_CAPS_MAP[g]
      ], !1),
      new c(this._setProp, [
        'lineJoin',
        null == d ? 'miter' : isNaN(d) ? d : b.STROKE_JOINTS_MAP[d]
      ], !1),
      new c(this._setProp, [
        'miterLimit',
        null == e ? '10' : e
      ], !1)
    ];
    this._ignoreScaleStroke = f;
    return this;
  };
  a.beginStroke = function (a) {
    this._active && this._newPath();
    this._strokeInstructions = a ? [new c(this._setProp, [
        'strokeStyle',
        a
      ], !1)] : null;
    return this;
  };
  a.beginLinearGradientStroke = function (a, b, d, e, f, h) {
    this._active && this._newPath();
    d = this._ctx.createLinearGradient(d, e, f, h);
    e = 0;
    for (f = a.length; e < f; e++)
      d.addColorStop(b[e], a[e]);
    this._strokeInstructions = [new c(this._setProp, [
        'strokeStyle',
        d
      ], !1)];
    return this;
  };
  a.beginRadialGradientStroke = function (a, b, d, e, f, h, k, j) {
    this._active && this._newPath();
    d = this._ctx.createRadialGradient(d, e, f, h, k, j);
    e = 0;
    for (f = a.length; e < f; e++)
      d.addColorStop(b[e], a[e]);
    this._strokeInstructions = [new c(this._setProp, [
        'strokeStyle',
        d
      ], !1)];
    return this;
  };
  a.beginBitmapStroke = function (a, b) {
    this._active && this._newPath();
    var d = this._ctx.createPattern(a, b || '');
    this._strokeInstructions = [new c(this._setProp, [
        'strokeStyle',
        d
      ], !1)];
    return this;
  };
  a.endStroke = function () {
    this.beginStroke();
    return this;
  };
  a.curveTo = a.quadraticCurveTo;
  a.drawRect = a.rect;
  a.drawRoundRect = function (a, b, d, c, f) {
    this.drawRoundRectComplex(a, b, d, c, f, f, f, f);
    return this;
  };
  a.drawRoundRectComplex = function (a, b, d, e, f, h, k, j) {
    var l = (d < e ? d : e) / 2, n = 0, q = 0, p = 0, s = 0;
    0 > f && (f *= n = -1);
    f > l && (f = l);
    0 > h && (h *= q = -1);
    h > l && (h = l);
    0 > k && (k *= p = -1);
    k > l && (k = l);
    0 > j && (j *= s = -1);
    j > l && (j = l);
    this._dirty = this._active = !0;
    var l = this._ctx.arcTo, r = this._ctx.lineTo;
    this._activeInstructions.push(new c(this._ctx.moveTo, [
      a + d - h,
      b
    ]), new c(l, [
      a + d + h * q,
      b - h * q,
      a + d,
      b + h,
      h
    ]), new c(r, [
      a + d,
      b + e - k
    ]), new c(l, [
      a + d + k * p,
      b + e + k * p,
      a + d - k,
      b + e,
      k
    ]), new c(r, [
      a + j,
      b + e
    ]), new c(l, [
      a - j * s,
      b + e + j * s,
      a,
      b + e - j,
      j
    ]), new c(r, [
      a,
      b + f
    ]), new c(l, [
      a - f * n,
      b - f * n,
      a + f,
      b,
      f
    ]), new c(this._ctx.closePath));
    return this;
  };
  a.drawCircle = function (a, b, d) {
    this.arc(a, b, d, 0, 2 * Math.PI);
    return this;
  };
  a.drawEllipse = function (a, b, d, e) {
    this._dirty = this._active = !0;
    var f = 0.5522848 * (d / 2), h = 0.5522848 * (e / 2), k = a + d, j = b + e;
    d = a + d / 2;
    e = b + e / 2;
    this._activeInstructions.push(new c(this._ctx.moveTo, [
      a,
      e
    ]), new c(this._ctx.bezierCurveTo, [
      a,
      e - h,
      d - f,
      b,
      d,
      b
    ]), new c(this._ctx.bezierCurveTo, [
      d + f,
      b,
      k,
      e - h,
      k,
      e
    ]), new c(this._ctx.bezierCurveTo, [
      k,
      e + h,
      d + f,
      j,
      d,
      j
    ]), new c(this._ctx.bezierCurveTo, [
      d - f,
      j,
      a,
      e + h,
      a,
      e
    ]));
    return this;
  };
  a.drawPolyStar = function (a, b, d, e, f, h) {
    this._dirty = this._active = !0;
    null == f && (f = 0);
    f = 1 - f;
    h = null == h ? 0 : h / (180 / Math.PI);
    var k = Math.PI / e;
    this._activeInstructions.push(new c(this._ctx.moveTo, [
      a + Math.cos(h) * d,
      b + Math.sin(h) * d
    ]));
    for (var j = 0; j < e; j++)
      h += k, 1 != f && this._activeInstructions.push(new c(this._ctx.lineTo, [
        a + Math.cos(h) * d * f,
        b + Math.sin(h) * d * f
      ])), h += k, this._activeInstructions.push(new c(this._ctx.lineTo, [
        a + Math.cos(h) * d,
        b + Math.sin(h) * d
      ]));
    return this;
  };
  a.decodePath = function (a) {
    for (var g = [
          this.moveTo,
          this.lineTo,
          this.quadraticCurveTo,
          this.bezierCurveTo,
          this.closePath
        ], d = [
          2,
          2,
          4,
          6,
          0
        ], c = 0, f = a.length, h = [], k = 0, j = 0, l = b.BASE_64; c < f;) {
      var n = a.charAt(c), q = l[n], p = q >> 3, s = g[p];
      if (!s || q & 3)
        throw 'bad path data (@' + c + '): ' + n;
      n = d[p];
      p || (k = j = 0);
      h.length = 0;
      c++;
      q = (q >> 2 & 1) + 2;
      for (p = 0; p < n; p++) {
        var r = l[a.charAt(c)], u = r >> 5 ? -1 : 1, r = (r & 31) << 6 | l[a.charAt(c + 1)];
        3 == q && (r = r << 6 | l[a.charAt(c + 2)]);
        r = u * r / 10;
        p % 2 ? k = r += k : j = r += j;
        h[p] = r;
        c += q;
      }
      s.apply(this, h);
    }
    return this;
  };
  a.clone = function () {
    var a = new b();
    a._instructions = this._instructions.slice();
    a._activeInstructions = this._activeInstructions.slice();
    a._oldInstructions = this._oldInstructions.slice();
    this._fillInstructions && (a._fillInstructions = this._fillInstructions.slice());
    this._strokeInstructions && (a._strokeInstructions = this._strokeInstructions.slice());
    this._strokeStyleInstructions && (a._strokeStyleInstructions = this._strokeStyleInstructions.slice());
    a._active = this._active;
    a._dirty = this._dirty;
    return a;
  };
  a.toString = function () {
    return '[Graphics]';
  };
  a.mt = a.moveTo;
  a.lt = a.lineTo;
  a.at = a.arcTo;
  a.bt = a.bezierCurveTo;
  a.qt = a.quadraticCurveTo;
  a.a = a.arc;
  a.r = a.rect;
  a.cp = a.closePath;
  a.c = a.clear;
  a.f = a.beginFill;
  a.lf = a.beginLinearGradientFill;
  a.rf = a.beginRadialGradientFill;
  a.bf = a.beginBitmapFill;
  a.ef = a.endFill;
  a.ss = a.setStrokeStyle;
  a.s = a.beginStroke;
  a.ls = a.beginLinearGradientStroke;
  a.rs = a.beginRadialGradientStroke;
  a.bs = a.beginBitmapStroke;
  a.es = a.endStroke;
  a.dr = a.drawRect;
  a.rr = a.drawRoundRect;
  a.rc = a.drawRoundRectComplex;
  a.dc = a.drawCircle;
  a.de = a.drawEllipse;
  a.dp = a.drawPolyStar;
  a.p = a.decodePath;
  a._updateInstructions = function () {
    this._instructions = this._oldInstructions.slice();
    this._instructions.push(b.beginCmd);
    this._instructions.push.apply(this._instructions, this._activeInstructions);
    this._fillInstructions && this._instructions.push.apply(this._instructions, this._fillInstructions);
    this._strokeInstructions && (this._strokeStyleInstructions && this._instructions.push.apply(this._instructions, this._strokeStyleInstructions), this._instructions.push.apply(this._instructions, this._strokeInstructions), this._ignoreScaleStroke ? this._instructions.push(new c(this._ctx.save, [], !1), new c(this._ctx.setTransform, [
      1,
      0,
      0,
      1,
      0,
      0
    ], !1), b.strokeCmd, new c(this._ctx.restore, [], !1)) : this._instructions.push(b.strokeCmd));
  };
  a._newPath = function () {
    this._dirty && this._updateInstructions();
    this._oldInstructions = this._instructions;
    this._activeInstructions = [];
    this._active = this._dirty = !1;
  };
  a._setProp = function (a, b) {
    this[a] = b;
  };
  createjs.Graphics = b;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
      this.initialize();
    }, b = c.prototype;
  c.suppressCrossDomainErrors = !1;
  c._hitTestCanvas = createjs.createCanvas ? createjs.createCanvas() : document.createElement('canvas');
  c._hitTestCanvas.width = c._hitTestCanvas.height = 1;
  c._hitTestContext = c._hitTestCanvas.getContext('2d');
  c._nextCacheID = 1;
  b.alpha = 1;
  b.cacheCanvas = null;
  b.id = -1;
  b.mouseEnabled = !0;
  b.name = null;
  b.parent = null;
  b.regX = 0;
  b.regY = 0;
  b.rotation = 0;
  b.scaleX = 1;
  b.scaleY = 1;
  b.skewX = 0;
  b.skewY = 0;
  b.shadow = null;
  b.visible = !0;
  b.x = 0;
  b.y = 0;
  b.compositeOperation = null;
  b.snapToPixel = !1;
  b.onPress = null;
  b.onClick = null;
  b.onDoubleClick = null;
  b.onMouseOver = null;
  b.onMouseOut = null;
  b.onTick = null;
  b.filters = null;
  b.cacheID = 0;
  b.mask = null;
  b.hitArea = null;
  b.cursor = null;
  b.addEventListener = null;
  b.removeEventListener = null;
  b.removeAllEventListeners = null;
  b.dispatchEvent = null;
  b.hasEventListener = null;
  b._listeners = null;
  createjs.EventDispatcher.initialize(b);
  b._cacheOffsetX = 0;
  b._cacheOffsetY = 0;
  b._cacheScale = 1;
  b._cacheDataURLID = 0;
  b._cacheDataURL = null;
  b._matrix = null;
  b.initialize = function () {
    this.id = createjs.UID.get();
    this._matrix = new createjs.Matrix2D();
  };
  b.isVisible = function () {
    return !(!this.visible || !(0 < this.alpha && 0 != this.scaleX && 0 != this.scaleY));
  };
  b.draw = function (a, b) {
    var c = this.cacheCanvas;
    if (b || !c)
      return !1;
    var d = this._cacheScale;
    a.drawImage(c, this._cacheOffsetX, this._cacheOffsetY, c.width / d, c.height / d);
    return !0;
  };
  b.updateContext = function (a) {
    var b, c = this.mask;
    c && (c.graphics && !c.graphics.isEmpty()) && (b = c.getMatrix(c._matrix), a.transform(b.a, b.b, b.c, b.d, b.tx, b.ty), c.graphics.drawAsPath(a), a.clip(), b.invert(), a.transform(b.a, b.b, b.c, b.d, b.tx, b.ty));
    b = this._matrix.identity().appendTransform(this.x, this.y, this.scaleX, this.scaleY, this.rotation, this.skewX, this.skewY, this.regX, this.regY);
    createjs.Stage._snapToPixelEnabled && this.snapToPixel ? a.transform(b.a, b.b, b.c, b.d, b.tx + 0.5 | 0, b.ty + 0.5 | 0) : a.transform(b.a, b.b, b.c, b.d, b.tx, b.ty);
    a.globalAlpha *= this.alpha;
    this.compositeOperation && (a.globalCompositeOperation = this.compositeOperation);
    this.shadow && this._applyShadow(a, this.shadow);
  };
  b.cache = function (a, b, c, d, e) {
    e = e || 1;
    this.cacheCanvas || (this.cacheCanvas = createjs.createCanvas ? createjs.createCanvas() : document.createElement('canvas'));
    this.cacheCanvas.width = Math.ceil(c * e);
    this.cacheCanvas.height = Math.ceil(d * e);
    this._cacheOffsetX = a;
    this._cacheOffsetY = b;
    this._cacheScale = e || 1;
    this.updateCache();
  };
  b.updateCache = function (a) {
    var b = this.cacheCanvas, g = this._cacheScale, d = this._cacheOffsetX * g, e = this._cacheOffsetY * g;
    if (!b)
      throw 'cache() must be called before updateCache()';
    var f = b.getContext('2d');
    f.save();
    a || f.clearRect(0, 0, b.width + 1, b.height + 1);
    f.globalCompositeOperation = a;
    f.setTransform(g, 0, 0, g, -d, -e);
    this.draw(f, !0);
    this._applyFilters();
    f.restore();
    this.cacheID = c._nextCacheID++;
  };
  b.uncache = function () {
    this._cacheDataURL = this.cacheCanvas = null;
    this.cacheID = this._cacheOffsetX = this._cacheOffsetY = 0;
    this._cacheScale = 1;
  };
  b.getCacheDataURL = function () {
    if (!this.cacheCanvas)
      return null;
    this.cacheID != this._cacheDataURLID && (this._cacheDataURL = this.cacheCanvas.toDataURL());
    return this._cacheDataURL;
  };
  b.getStage = function () {
    for (var a = this; a.parent;)
      a = a.parent;
    return a instanceof createjs.Stage ? a : null;
  };
  b.localToGlobal = function (a, b) {
    var c = this.getConcatenatedMatrix(this._matrix);
    if (null == c)
      return null;
    c.append(1, 0, 0, 1, a, b);
    return new createjs.Point(c.tx, c.ty);
  };
  b.globalToLocal = function (a, b) {
    var c = this.getConcatenatedMatrix(this._matrix);
    if (null == c)
      return null;
    c.invert();
    c.append(1, 0, 0, 1, a, b);
    return new createjs.Point(c.tx, c.ty);
  };
  b.localToLocal = function (a, b, c) {
    a = this.localToGlobal(a, b);
    return c.globalToLocal(a.x, a.y);
  };
  b.setTransform = function (a, b, c, d, e, f, h, k, j) {
    this.x = a || 0;
    this.y = b || 0;
    this.scaleX = null == c ? 1 : c;
    this.scaleY = null == d ? 1 : d;
    this.rotation = e || 0;
    this.skewX = f || 0;
    this.skewY = h || 0;
    this.regX = k || 0;
    this.regY = j || 0;
    return this;
  };
  b.getMatrix = function (a) {
    return (a ? a.identity() : new createjs.Matrix2D()).appendTransform(this.x, this.y, this.scaleX, this.scaleY, this.rotation, this.skewX, this.skewY, this.regX, this.regY).appendProperties(this.alpha, this.shadow, this.compositeOperation);
  };
  b.getConcatenatedMatrix = function (a) {
    a ? a.identity() : a = new createjs.Matrix2D();
    for (var b = this; null != b;)
      a.prependTransform(b.x, b.y, b.scaleX, b.scaleY, b.rotation, b.skewX, b.skewY, b.regX, b.regY).prependProperties(b.alpha, b.shadow, b.compositeOperation), b = b.parent;
    return a;
  };
  b.hitTest = function (a, b) {
    var g = c._hitTestContext;
    g.setTransform(1, 0, 0, 1, -a, -b);
    this.draw(g);
    var d = this._testHit(g);
    g.setTransform(1, 0, 0, 1, 0, 0);
    g.clearRect(0, 0, 2, 2);
    return d;
  };
  b.set = function (a) {
    for (var b in a)
      this[b] = a[b];
    return this;
  };
  b.clone = function () {
    var a = new c();
    this.cloneProps(a);
    return a;
  };
  b.toString = function () {
    return '[DisplayObject (name=' + this.name + ')]';
  };
  b.cloneProps = function (a) {
    a.alpha = this.alpha;
    a.name = this.name;
    a.regX = this.regX;
    a.regY = this.regY;
    a.rotation = this.rotation;
    a.scaleX = this.scaleX;
    a.scaleY = this.scaleY;
    a.shadow = this.shadow;
    a.skewX = this.skewX;
    a.skewY = this.skewY;
    a.visible = this.visible;
    a.x = this.x;
    a.y = this.y;
    a.mouseEnabled = this.mouseEnabled;
    a.compositeOperation = this.compositeOperation;
    this.cacheCanvas && (a.cacheCanvas = this.cacheCanvas.cloneNode(!0), a.cacheCanvas.getContext('2d').putImageData(this.cacheCanvas.getContext('2d').getImageData(0, 0, this.cacheCanvas.width, this.cacheCanvas.height), 0, 0));
  };
  b._applyShadow = function (a, b) {
    b = b || Shadow.identity;
    a.shadowColor = b.color;
    a.shadowOffsetX = b.offsetX;
    a.shadowOffsetY = b.offsetY;
    a.shadowBlur = b.blur;
  };
  b._tick = function (a) {
    this.onTick && this.onTick.apply(this, a);
    var b = this._listeners;
    b && b.tick && this.dispatchEvent({
      type: 'tick',
      params: a
    });
  };
  b._testHit = function (a) {
    try {
      var b = 1 < a.getImageData(0, 0, 1, 1).data[3];
    } catch (g) {
      if (!c.suppressCrossDomainErrors)
        throw 'An error has occurred. This is most likely due to security restrictions on reading canvas pixel data with local or cross-domain images.';
    }
    return b;
  };
  b._applyFilters = function () {
    if (this.filters && 0 != this.filters.length && this.cacheCanvas)
      for (var a = this.filters.length, b = this.cacheCanvas.getContext('2d'), c = this.cacheCanvas.width, d = this.cacheCanvas.height, e = 0; e < a; e++)
        this.filters[e].applyFilter(b, 0, 0, c, d);
  };
  b._hasMouseHandler = function (a) {
    var b = this._listeners;
    return !!(a & 1 && (this.onPress || this.onClick || this.onDoubleClick || b && (this.hasEventListener('mousedown') || this.hasEventListener('click') || this.hasEventListener('dblclick'))) || a & 2 && (this.onMouseOver || this.onMouseOut || this.cursor || b && (this.hasEventListener('mouseover') || this.hasEventListener('mouseout'))));
  };
  createjs.DisplayObject = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
      this.initialize();
    }, b = c.prototype = new createjs.DisplayObject();
  b.children = null;
  b.DisplayObject_initialize = b.initialize;
  b.initialize = function () {
    this.DisplayObject_initialize();
    this.children = [];
  };
  b.isVisible = function () {
    var a = this.cacheCanvas || this.children.length;
    return !(!this.visible || !(0 < this.alpha && 0 != this.scaleX && 0 != this.scaleY && a));
  };
  b.DisplayObject_draw = b.draw;
  b.draw = function (a, b) {
    if (this.DisplayObject_draw(a, b))
      return !0;
    for (var c = this.children.slice(0), d = 0, e = c.length; d < e; d++) {
      var f = c[d];
      f.isVisible() && (a.save(), f.updateContext(a), f.draw(a), a.restore());
    }
    return !0;
  };
  b.addChild = function (a) {
    if (null == a)
      return a;
    var b = arguments.length;
    if (1 < b) {
      for (var c = 0; c < b; c++)
        this.addChild(arguments[c]);
      return arguments[b - 1];
    }
    a.parent && a.parent.removeChild(a);
    a.parent = this;
    this.children.push(a);
    return a;
  };
  b.addChildAt = function (a, b) {
    var c = arguments.length, d = arguments[c - 1];
    if (0 > d || d > this.children.length)
      return arguments[c - 2];
    if (2 < c) {
      for (var e = 0; e < c - 1; e++)
        this.addChildAt(arguments[e], d + e);
      return arguments[c - 2];
    }
    a.parent && a.parent.removeChild(a);
    a.parent = this;
    this.children.splice(b, 0, a);
    return a;
  };
  b.removeChild = function (a) {
    var b = arguments.length;
    if (1 < b) {
      for (var c = !0, d = 0; d < b; d++)
        c = c && this.removeChild(arguments[d]);
      return c;
    }
    return this.removeChildAt(this.children.indexOf(a));
  };
  b.removeChildAt = function (a) {
    var b = arguments.length;
    if (1 < b) {
      for (var c = [], d = 0; d < b; d++)
        c[d] = arguments[d];
      c.sort(function (a, b) {
        return b - a;
      });
      for (var e = !0, d = 0; d < b; d++)
        e = e && this.removeChildAt(c[d]);
      return e;
    }
    if (0 > a || a > this.children.length - 1)
      return !1;
    if (b = this.children[a])
      b.parent = null;
    this.children.splice(a, 1);
    return !0;
  };
  b.removeAllChildren = function () {
    for (var a = this.children; a.length;)
      a.pop().parent = null;
  };
  b.getChildAt = function (a) {
    return this.children[a];
  };
  b.getChildByName = function (a) {
    for (var b = this.children, c = 0, d = b.length; c < d; c++)
      if (b[c].name == a)
        return b[c];
    return null;
  };
  b.sortChildren = function (a) {
    this.children.sort(a);
  };
  b.getChildIndex = function (a) {
    return this.children.indexOf(a);
  };
  b.getNumChildren = function () {
    return this.children.length;
  };
  b.swapChildrenAt = function (a, b) {
    var c = this.children, d = c[a], e = c[b];
    d && e && (c[a] = e, c[b] = d);
  };
  b.swapChildren = function (a, b) {
    for (var c = this.children, d, e, f = 0, h = c.length; f < h && !(c[f] == a && (d = f), c[f] == b && (e = f), null != d && null != e); f++);
    f != h && (c[d] = b, c[e] = a);
  };
  b.setChildIndex = function (a, b) {
    var c = this.children, d = c.length;
    if (!(a.parent != this || 0 > b || b >= d)) {
      for (var e = 0; e < d && c[e] != a; e++);
      e == d || e == b || (c.splice(e, 1), b < e && b--, c.splice(b, 0, a));
    }
  };
  b.contains = function (a) {
    for (; a;) {
      if (a == this)
        return !0;
      a = a.parent;
    }
    return !1;
  };
  b.hitTest = function (a, b) {
    return null != this.getObjectUnderPoint(a, b);
  };
  b.getObjectsUnderPoint = function (a, b) {
    var c = [], d = this.localToGlobal(a, b);
    this._getObjectsUnderPoint(d.x, d.y, c);
    return c;
  };
  b.getObjectUnderPoint = function (a, b) {
    var c = this.localToGlobal(a, b);
    return this._getObjectsUnderPoint(c.x, c.y);
  };
  b.clone = function (a) {
    var b = new c();
    this.cloneProps(b);
    if (a)
      for (var g = b.children = [], d = 0, e = this.children.length; d < e; d++) {
        var f = this.children[d].clone(a);
        f.parent = b;
        g.push(f);
      }
    return b;
  };
  b.toString = function () {
    return '[Container (name=' + this.name + ')]';
  };
  b.DisplayObject__tick = b._tick;
  b._tick = function (a) {
    for (var b = this.children.length - 1; 0 <= b; b--) {
      var c = this.children[b];
      c._tick && c._tick(a);
    }
    this.DisplayObject__tick(a);
  };
  b._getObjectsUnderPoint = function (a, b, g, d) {
    var e = createjs.DisplayObject._hitTestContext, f = this._matrix, h = this._hasMouseHandler(d);
    if (!this.hitArea && (this.cacheCanvas && h) && (this.getConcatenatedMatrix(f), e.setTransform(f.a, f.b, f.c, f.d, f.tx - a, f.ty - b), e.globalAlpha = f.alpha, this.draw(e), this._testHit(e)))
      return e.setTransform(1, 0, 0, 1, 0, 0), e.clearRect(0, 0, 2, 2), this;
    for (var k = this.children.length - 1; 0 <= k; k--) {
      var j = this.children[k], l = j.hitArea;
      if (j.visible && !(!l && !j.isVisible() || d && !j.mouseEnabled)) {
        var n = d && j._hasMouseHandler(d);
        if (j instanceof c && (!l || !n))
          if (h) {
            if (j = j._getObjectsUnderPoint(a, b))
              return this;
          } else {
            if (j = j._getObjectsUnderPoint(a, b, g, d), !g && j)
              return j;
          }
        else if (!d || h || n)
          if (j.getConcatenatedMatrix(f), l && (f.appendTransform(l.x, l.y, l.scaleX, l.scaleY, l.rotation, l.skewX, l.skewY, l.regX, l.regY), f.alpha = l.alpha), e.globalAlpha = f.alpha, e.setTransform(f.a, f.b, f.c, f.d, f.tx - a, f.ty - b), (l || j).draw(e), this._testHit(e)) {
            e.setTransform(1, 0, 0, 1, 0, 0);
            e.clearRect(0, 0, 2, 2);
            if (h)
              return this;
            if (g)
              g.push(j);
            else
              return j;
          }
      }
    }
    return null;
  };
  createjs.Container = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a) {
      this.initialize(a);
    }, b = c.prototype = new createjs.Container();
  c._snapToPixelEnabled = !1;
  b.autoClear = !0;
  b.canvas = null;
  b.mouseX = 0;
  b.mouseY = 0;
  b.onMouseMove = null;
  b.onMouseUp = null;
  b.onMouseDown = null;
  b.snapToPixelEnabled = !1;
  b.mouseInBounds = !1;
  b.tickOnUpdate = !0;
  b.mouseMoveOutside = !1;
  b._pointerData = null;
  b._pointerCount = 0;
  b._primaryPointerID = null;
  b._mouseOverIntervalID = null;
  b.Container_initialize = b.initialize;
  b.initialize = function (a) {
    this.Container_initialize();
    this.canvas = 'string' == typeof a ? document.getElementById(a) : a;
    this._pointerData = {};
    this.enableDOMEvents(!0);
  };
  b.update = function () {
    if (this.canvas) {
      this.autoClear && this.clear();
      c._snapToPixelEnabled = this.snapToPixelEnabled;
      this.tickOnUpdate && this._tick(arguments.length ? arguments : null);
      var a = this.canvas.getContext('2d');
      a.save();
      this.updateContext(a);
      this.draw(a, !1);
      a.restore();
    }
  };
  b.tick = b.update;
  b.handleEvent = function (a) {
    'tick' == a.type && this.update(a);
  };
  b.clear = function () {
    if (this.canvas) {
      var a = this.canvas.getContext('2d');
      a.setTransform(1, 0, 0, 1, 0, 0);
      a.clearRect(0, 0, this.canvas.width + 1, this.canvas.height + 1);
    }
  };
  b.toDataURL = function (a, b) {
    b || (b = 'image/png');
    var c = this.canvas.getContext('2d'), d = this.canvas.width, e = this.canvas.height, f;
    if (a) {
      f = c.getImageData(0, 0, d, e);
      var h = c.globalCompositeOperation;
      c.globalCompositeOperation = 'destination-over';
      c.fillStyle = a;
      c.fillRect(0, 0, d, e);
    }
    var k = this.canvas.toDataURL(b);
    a && (c.clearRect(0, 0, d + 1, e + 1), c.putImageData(f, 0, 0), c.globalCompositeOperation = h);
    return k;
  };
  b.enableMouseOver = function (a) {
    this._mouseOverIntervalID && (clearInterval(this._mouseOverIntervalID), this._mouseOverIntervalID = null);
    if (null == a)
      a = 20;
    else if (0 >= a)
      return;
    var b = this;
    this._mouseOverIntervalID = setInterval(function () {
      b._testMouseOver();
    }, 1000 / Math.min(50, a));
  };
  b.enableDOMEvents = function (a) {
    null == a && (a = !0);
    var b, c = this._eventListeners;
    if (!a && c) {
      for (b in c)
        a = c[b], a.t.removeEventListener(b, a.f);
      this._eventListeners = null;
    } else if (a && !c && this.canvas) {
      a = window.addEventListener ? window : document;
      var d = this, c = this._eventListeners = {};
      c.mouseup = {
        t: a,
        f: function (a) {
          d._handleMouseUp(a);
        }
      };
      c.mousemove = {
        t: a,
        f: function (a) {
          d._handleMouseMove(a);
        }
      };
      c.dblclick = {
        t: a,
        f: function (a) {
          d._handleDoubleClick(a);
        }
      };
      c.mousedown = {
        t: this.canvas,
        f: function (a) {
          d._handleMouseDown(a);
        }
      };
      for (b in c)
        a = c[b], a.t.addEventListener(b, a.f);
    }
  };
  b.clone = function () {
    var a = new c(null);
    this.cloneProps(a);
    return a;
  };
  b.toString = function () {
    return '[Stage (name=' + this.name + ')]';
  };
  b._getPointerData = function (a) {
    var b = this._pointerData[a];
    if (!b && (b = this._pointerData[a] = {
        x: 0,
        y: 0
      }, null == this._primaryPointerID || -1 == this._primaryPointerID))
      this._primaryPointerID = a;
    return b;
  };
  b._handleMouseMove = function (a) {
    a || (a = window.event);
    this._handlePointerMove(-1, a, a.pageX, a.pageY);
  };
  b._handlePointerMove = function (a, b, c, d) {
    if (this.canvas) {
      var e = this._getPointerData(a), f = e.inBounds;
      this._updatePointerPosition(a, c, d);
      if (f || e.inBounds || this.mouseMoveOutside) {
        if (this.onMouseMove || this.hasEventListener('stagemousemove'))
          c = new createjs.MouseEvent('stagemousemove', e.x, e.y, this, b, a, a == this._primaryPointerID, e.rawX, e.rawY), this.onMouseMove && this.onMouseMove(c), this.dispatchEvent(c);
        if ((d = e.event) && (d.onMouseMove || d.hasEventListener('mousemove')))
          c = new createjs.MouseEvent('mousemove', e.x, e.y, d.target, b, a, a == this._primaryPointerID, e.rawX, e.rawY), d.onMouseMove && d.onMouseMove(c), d.dispatchEvent(c, d.target);
      }
    }
  };
  b._updatePointerPosition = function (a, b, c) {
    var d = this._getElementRect(this.canvas);
    b -= d.left;
    c -= d.top;
    var e = this.canvas.width, f = this.canvas.height;
    b /= (d.right - d.left) / e;
    c /= (d.bottom - d.top) / f;
    d = this._getPointerData(a);
    (d.inBounds = 0 <= b && 0 <= c && b <= e - 1 && c <= f - 1) ? (d.x = b, d.y = c) : this.mouseMoveOutside && (d.x = 0 > b ? 0 : b > e - 1 ? e - 1 : b, d.y = 0 > c ? 0 : c > f - 1 ? f - 1 : c);
    d.rawX = b;
    d.rawY = c;
    a == this._primaryPointerID && (this.mouseX = d.x, this.mouseY = d.y, this.mouseInBounds = d.inBounds);
  };
  b._getElementRect = function (a) {
    var b;
    try {
      b = a.getBoundingClientRect();
    } catch (c) {
      b = {
        top: a.offsetTop,
        left: a.offsetLeft,
        width: a.offsetWidth,
        height: a.offsetHeight
      };
    }
    var d = (window.pageXOffset || document.scrollLeft || 0) - (document.clientLeft || document.body.clientLeft || 0), e = (window.pageYOffset || document.scrollTop || 0) - (document.clientTop || document.body.clientTop || 0), f = window.getComputedStyle ? getComputedStyle(a) : a.currentStyle;
    a = parseInt(f.paddingLeft) + parseInt(f.borderLeftWidth);
    var h = parseInt(f.paddingTop) + parseInt(f.borderTopWidth), k = parseInt(f.paddingRight) + parseInt(f.borderRightWidth), f = parseInt(f.paddingBottom) + parseInt(f.borderBottomWidth);
    return {
      left: b.left + d + a,
      right: b.right + d - k,
      top: b.top + e + h,
      bottom: b.bottom + e - f
    };
  };
  b._handleMouseUp = function (a) {
    this._handlePointerUp(-1, a, !1);
  };
  b._handlePointerUp = function (a, b, c) {
    var d = this._getPointerData(a), e;
    if (this.onMouseMove || this.hasEventListener('stagemouseup'))
      e = new createjs.MouseEvent('stagemouseup', d.x, d.y, this, b, a, a == this._primaryPointerID, d.rawX, d.rawY), this.onMouseUp && this.onMouseUp(e), this.dispatchEvent(e);
    var f = d.event;
    if (f && (f.onMouseUp || f.hasEventListener('mouseup')))
      e = new createjs.MouseEvent('mouseup', d.x, d.y, f.target, b, a, a == this._primaryPointerID, d.rawX, d.rawY), f.onMouseUp && f.onMouseUp(e), f.dispatchEvent(e, f.target);
    if ((f = d.target) && (f.onClick || f.hasEventListener('click')) && this._getObjectsUnderPoint(d.x, d.y, null, !0, this._mouseOverIntervalID ? 3 : 1) == f)
      e = new createjs.MouseEvent('click', d.x, d.y, f, b, a, a == this._primaryPointerID, d.rawX, d.rawY), f.onClick && f.onClick(e), f.dispatchEvent(e);
    c ? (a == this._primaryPointerID && (this._primaryPointerID = null), delete this._pointerData[a]) : d.event = d.target = null;
  };
  b._handleMouseDown = function (a) {
    this._handlePointerDown(-1, a, !1);
  };
  b._handlePointerDown = function (a, b, c, d) {
    var e = this._getPointerData(a);
    null != d && this._updatePointerPosition(a, c, d);
    if (this.onMouseDown || this.hasEventListener('stagemousedown'))
      c = new createjs.MouseEvent('stagemousedown', e.x, e.y, this, b, a, a == this._primaryPointerID, e.rawX, e.rawY), this.onMouseDown && this.onMouseDown(c), this.dispatchEvent(c);
    if (d = this._getObjectsUnderPoint(e.x, e.y, null, this._mouseOverIntervalID ? 3 : 1))
      if (e.target = d, d.onPress || d.hasEventListener('mousedown'))
        if (c = new createjs.MouseEvent('mousedown', e.x, e.y, d, b, a, a == this._primaryPointerID, e.rawX, e.rawY), d.onPress && d.onPress(c), d.dispatchEvent(c), c.onMouseMove || c.onMouseUp || c.hasEventListener('mousemove') || c.hasEventListener('mouseup'))
          e.event = c;
  };
  b._testMouseOver = function () {
    if (-1 == this._primaryPointerID && !(this.mouseX == this._mouseOverX && this.mouseY == this._mouseOverY && this.mouseInBounds)) {
      var a = null;
      this.mouseInBounds && (a = this._getObjectsUnderPoint(this.mouseX, this.mouseY, null, 3), this._mouseOverX = this.mouseX, this._mouseOverY = this.mouseY);
      var b = this._mouseOverTarget;
      if (b != a) {
        var c = this._getPointerData(-1);
        if (b && (b.onMouseOut || b.hasEventListener('mouseout'))) {
          var d = new createjs.MouseEvent('mouseout', c.x, c.y, b, null, -1, c.rawX, c.rawY);
          b.onMouseOut && b.onMouseOut(d);
          b.dispatchEvent(d);
        }
        b && (this.canvas.style.cursor = '');
        if (a && (a.onMouseOver || a.hasEventListener('mouseover')))
          d = new createjs.MouseEvent('mouseover', c.x, c.y, a, null, -1, c.rawX, c.rawY), a.onMouseOver && a.onMouseOver(d), a.dispatchEvent(d);
        a && (this.canvas.style.cursor = a.cursor || '');
        this._mouseOverTarget = a;
      }
    }
  };
  b._handleDoubleClick = function (a) {
    var b = this._getPointerData(-1), c = this._getObjectsUnderPoint(b.x, b.y, null, this._mouseOverIntervalID ? 3 : 1);
    if (c && (c.onDoubleClick || c.hasEventListener('dblclick')))
      evt = new createjs.MouseEvent('dblclick', b.x, b.y, c, a, -1, !0, b.rawX, b.rawY), c.onDoubleClick && c.onDoubleClick(evt), c.dispatchEvent(evt);
  };
  createjs.Stage = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a) {
      this.initialize(a);
    }, b = c.prototype = new createjs.DisplayObject();
  b.image = null;
  b.snapToPixel = !0;
  b.sourceRect = null;
  b.DisplayObject_initialize = b.initialize;
  b.initialize = function (a) {
    this.DisplayObject_initialize();
    'string' == typeof a ? (this.image = new Image(), this.image.src = a) : this.image = a;
  };
  b.isVisible = function () {
    var a = this.cacheCanvas || this.image && (this.image.complete || this.image.getContext || 2 <= this.image.readyState);
    return !(!this.visible || !(0 < this.alpha && 0 != this.scaleX && 0 != this.scaleY && a));
  };
  b.DisplayObject_draw = b.draw;
  b.draw = function (a, b) {
    if (this.DisplayObject_draw(a, b))
      return !0;
    var c = this.sourceRect;
    c ? a.drawImage(this.image, c.x, c.y, c.width, c.height, 0, 0, c.width, c.height) : a.drawImage(this.image, 0, 0);
    return !0;
  };
  b.clone = function () {
    var a = new c(this.image);
    this.sourceRect && (a.sourceRect = this.sourceRect.clone());
    this.cloneProps(a);
    return a;
  };
  b.toString = function () {
    return '[Bitmap (name=' + this.name + ')]';
  };
  createjs.Bitmap = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a) {
      this.initialize(a);
    }, b = c.prototype = new createjs.DisplayObject();
  b.onAnimationEnd = null;
  b.currentFrame = -1;
  b.currentAnimation = null;
  b.paused = !0;
  b.spriteSheet = null;
  b.snapToPixel = !0;
  b.offset = 0;
  b.currentAnimationFrame = 0;
  b.addEventListener = null;
  b.removeEventListener = null;
  b.removeAllEventListeners = null;
  b.dispatchEvent = null;
  b.hasEventListener = null;
  b._listeners = null;
  createjs.EventDispatcher.initialize(b);
  b._advanceCount = 0;
  b._animation = null;
  b.DisplayObject_initialize = b.initialize;
  b.initialize = function (a) {
    this.DisplayObject_initialize();
    this.spriteSheet = a;
  };
  b.isVisible = function () {
    var a = this.cacheCanvas || this.spriteSheet.complete && 0 <= this.currentFrame;
    return !(!this.visible || !(0 < this.alpha && 0 != this.scaleX && 0 != this.scaleY && a));
  };
  b.DisplayObject_draw = b.draw;
  b.draw = function (a, b) {
    if (this.DisplayObject_draw(a, b))
      return !0;
    this._normalizeFrame();
    var c = this.spriteSheet.getFrame(this.currentFrame);
    if (c) {
      var d = c.rect;
      a.drawImage(c.image, d.x, d.y, d.width, d.height, -c.regX, -c.regY, d.width, d.height);
      return !0;
    }
  };
  b.play = function () {
    this.paused = !1;
  };
  b.stop = function () {
    this.paused = !0;
  };
  b.gotoAndPlay = function (a) {
    this.paused = !1;
    this._goto(a);
  };
  b.gotoAndStop = function (a) {
    this.paused = !0;
    this._goto(a);
  };
  b.advance = function () {
    this._animation ? this.currentAnimationFrame++ : this.currentFrame++;
    this._normalizeFrame();
  };
  b.getBounds = function () {
    return this.spriteSheet.getFrameBounds(this.currentFrame);
  };
  b.clone = function () {
    var a = new c(this.spriteSheet);
    this.cloneProps(a);
    return a;
  };
  b.toString = function () {
    return '[BitmapAnimation (name=' + this.name + ')]';
  };
  b.DisplayObject__tick = b._tick;
  b._tick = function (a) {
    var b = this._animation ? this._animation.frequency : 1;
    !this.paused && 0 == (++this._advanceCount + this.offset) % b && this.advance();
    this.DisplayObject__tick(a);
  };
  b._normalizeFrame = function () {
    var a = this._animation, b = this.currentFrame, c = this.paused, d;
    if (a)
      if (d = a.frames.length, this.currentAnimationFrame >= d) {
        var e = a.next;
        this._dispatchAnimationEnd(a, b, c, e, d - 1) || (e ? this._goto(e) : (this.paused = !0, this.currentAnimationFrame = a.frames.length - 1, this.currentFrame = a.frames[this.currentAnimationFrame]));
      } else
        this.currentFrame = a.frames[this.currentAnimationFrame];
    else
      d = this.spriteSheet.getNumFrames(), b >= d && !this._dispatchAnimationEnd(a, b, c, d - 1) && (this.currentFrame = 0);
  };
  b._dispatchAnimationEnd = function (a, b, c, d, e) {
    var f = a ? a.name : null;
    this.onAnimationEnd && this.onAnimationEnd(this, f, d);
    this.dispatchEvent({
      type: 'animationend',
      name: f,
      next: d
    });
    !c && this.paused && (this.currentAnimationFrame = e);
    return this.paused != c || this._animation != a || this.currentFrame != b;
  };
  b.DisplayObject_cloneProps = b.cloneProps;
  b.cloneProps = function (a) {
    this.DisplayObject_cloneProps(a);
    a.onAnimationEnd = this.onAnimationEnd;
    a.currentFrame = this.currentFrame;
    a.currentAnimation = this.currentAnimation;
    a.paused = this.paused;
    a.offset = this.offset;
    a._animation = this._animation;
    a.currentAnimationFrame = this.currentAnimationFrame;
  };
  b._goto = function (a) {
    if (isNaN(a)) {
      var b = this.spriteSheet.getAnimation(a);
      b && (this.currentAnimationFrame = 0, this._animation = b, this.currentAnimation = a, this._normalizeFrame());
    } else
      this.currentAnimation = this._animation = null, this.currentFrame = a;
  };
  createjs.BitmapAnimation = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a) {
      this.initialize(a);
    }, b = c.prototype = new createjs.DisplayObject();
  b.graphics = null;
  b.DisplayObject_initialize = b.initialize;
  b.initialize = function (a) {
    this.DisplayObject_initialize();
    this.graphics = a ? a : new createjs.Graphics();
  };
  b.isVisible = function () {
    var a = this.cacheCanvas || this.graphics && !this.graphics.isEmpty();
    return !(!this.visible || !(0 < this.alpha && 0 != this.scaleX && 0 != this.scaleY && a));
  };
  b.DisplayObject_draw = b.draw;
  b.draw = function (a, b) {
    if (this.DisplayObject_draw(a, b))
      return !0;
    this.graphics.draw(a);
    return !0;
  };
  b.clone = function (a) {
    a = new c(a && this.graphics ? this.graphics.clone() : this.graphics);
    this.cloneProps(a);
    return a;
  };
  b.toString = function () {
    return '[Shape (name=' + this.name + ')]';
  };
  createjs.Shape = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a, b, c) {
      this.initialize(a, b, c);
    }, b = c.prototype = new createjs.DisplayObject();
  c._workingContext = (createjs.createCanvas ? createjs.createCanvas() : document.createElement('canvas')).getContext('2d');
  b.text = '';
  b.font = null;
  b.color = '#000';
  b.textAlign = 'left';
  b.textBaseline = 'top';
  b.maxWidth = null;
  b.outline = !1;
  b.lineHeight = 0;
  b.lineWidth = null;
  b.DisplayObject_initialize = b.initialize;
  b.initialize = function (a, b, c) {
    this.DisplayObject_initialize();
    this.text = a;
    this.font = b;
    this.color = c ? c : '#000';
  };
  b.isVisible = function () {
    var a = this.cacheCanvas || null != this.text && '' !== this.text;
    return !(!this.visible || !(0 < this.alpha && 0 != this.scaleX && 0 != this.scaleY && a));
  };
  b.DisplayObject_draw = b.draw;
  b.draw = function (a, b) {
    if (this.DisplayObject_draw(a, b))
      return !0;
    this.outline ? a.strokeStyle = this.color : a.fillStyle = this.color;
    a.font = this.font;
    a.textAlign = this.textAlign || 'start';
    a.textBaseline = this.textBaseline || 'alphabetic';
    this._drawText(a);
    return !0;
  };
  b.getMeasuredWidth = function () {
    return this._getWorkingContext().measureText(this.text).width;
  };
  b.getMeasuredLineHeight = function () {
    return 1.2 * this._getWorkingContext().measureText('M').width;
  };
  b.getMeasuredHeight = function () {
    return this._drawText() * (this.lineHeight || this.getMeasuredLineHeight());
  };
  b.clone = function () {
    var a = new c(this.text, this.font, this.color);
    this.cloneProps(a);
    return a;
  };
  b.toString = function () {
    return '[Text (text=' + (20 < this.text.length ? this.text.substr(0, 17) + '...' : this.text) + ')]';
  };
  b.DisplayObject_cloneProps = b.cloneProps;
  b.cloneProps = function (a) {
    this.DisplayObject_cloneProps(a);
    a.textAlign = this.textAlign;
    a.textBaseline = this.textBaseline;
    a.maxWidth = this.maxWidth;
    a.outline = this.outline;
    a.lineHeight = this.lineHeight;
    a.lineWidth = this.lineWidth;
  };
  b._getWorkingContext = function () {
    var a = c._workingContext;
    a.font = this.font;
    a.textAlign = this.textAlign || 'start';
    a.textBaseline = this.textBaseline || 'alphabetic';
    return a;
  };
  b._drawText = function (a) {
    var b = !!a;
    b || (a = this._getWorkingContext());
    for (var c = String(this.text).split(/(?:\r\n|\r|\n)/), d = this.lineHeight || this.getMeasuredLineHeight(), e = 0, f = 0, h = c.length; f < h; f++) {
      var k = a.measureText(c[f]).width;
      if (null == this.lineWidth || k < this.lineWidth)
        b && this._drawTextLine(a, c[f], e * d);
      else {
        for (var k = c[f].split(/(\s)/), j = k[0], l = 1, n = k.length; l < n; l += 2)
          a.measureText(j + k[l] + k[l + 1]).width > this.lineWidth ? (b && this._drawTextLine(a, j, e * d), e++, j = k[l + 1]) : j += k[l] + k[l + 1];
        b && this._drawTextLine(a, j, e * d);
      }
      e++;
    }
    return e;
  };
  b._drawTextLine = function (a, b, c) {
    this.outline ? a.strokeText(b, 0, c, this.maxWidth || 65535) : a.fillText(b, 0, c, this.maxWidth || 65535);
  };
  createjs.Text = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
    throw 'SpriteSheetUtils cannot be instantiated';
  };
  c._workingCanvas = createjs.createCanvas ? createjs.createCanvas() : document.createElement('canvas');
  c._workingContext = c._workingCanvas.getContext('2d');
  c.addFlippedFrames = function (b, a, m, g) {
    if (a || m || g) {
      var d = 0;
      a && c._flip(b, ++d, !0, !1);
      m && c._flip(b, ++d, !1, !0);
      g && c._flip(b, ++d, !0, !0);
    }
  };
  c.extractFrame = function (b, a) {
    isNaN(a) && (a = b.getAnimation(a).frames[0]);
    var m = b.getFrame(a);
    if (!m)
      return null;
    var g = m.rect, d = c._workingCanvas;
    d.width = g.width;
    d.height = g.height;
    c._workingContext.drawImage(m.image, g.x, g.y, g.width, g.height, 0, 0, g.width, g.height);
    m = new Image();
    m.src = d.toDataURL('image/png');
    return m;
  };
  c.mergeAlpha = function (b, a, c) {
    c || (c = createjs.createCanvas ? createjs.createCanvas() : document.createElement('canvas'));
    c.width = Math.max(a.width, b.width);
    c.height = Math.max(a.height, b.height);
    var g = c.getContext('2d');
    g.save();
    g.drawImage(b, 0, 0);
    g.globalCompositeOperation = 'destination-in';
    g.drawImage(a, 0, 0);
    g.restore();
    return c;
  };
  c._flip = function (b, a, m, g) {
    for (var d = b._images, e = c._workingCanvas, f = c._workingContext, h = d.length / a, k = 0; k < h; k++) {
      var j = d[k];
      j.__tmp = k;
      f.setTransform(1, 0, 0, 1, 0, 0);
      f.clearRect(0, 0, e.width + 1, e.height + 1);
      e.width = j.width;
      e.height = j.height;
      f.setTransform(m ? -1 : 1, 0, 0, g ? -1 : 1, m ? j.width : 0, g ? j.height : 0);
      f.drawImage(j, 0, 0);
      var l = new Image();
      l.src = e.toDataURL('image/png');
      l.width = j.width;
      l.height = j.height;
      d.push(l);
    }
    f = b._frames;
    e = f.length / a;
    for (k = 0; k < e; k++) {
      var j = f[k], n = j.rect.clone(), l = d[j.image.__tmp + h * a], q = {
          image: l,
          rect: n,
          regX: j.regX,
          regY: j.regY
        };
      m && (n.x = l.width - n.x - n.width, q.regX = n.width - j.regX);
      g && (n.y = l.height - n.y - n.height, q.regY = n.height - j.regY);
      f.push(q);
    }
    m = '_' + (m ? 'h' : '') + (g ? 'v' : '');
    g = b._animations;
    b = b._data;
    d = g.length / a;
    for (k = 0; k < d; k++) {
      f = g[k];
      j = b[f];
      h = {
        name: f + m,
        frequency: j.frequency,
        next: j.next,
        frames: []
      };
      j.next && (h.next += m);
      f = j.frames;
      j = 0;
      for (l = f.length; j < l; j++)
        h.frames.push(f[j] + e * a);
      b[h.name] = h;
      g.push(h.name);
    }
  };
  createjs.SpriteSheetUtils = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
      this.initialize();
    }, b = c.prototype;
  c.ERR_DIMENSIONS = 'frame dimensions exceed max spritesheet dimensions';
  c.ERR_RUNNING = 'a build is already running';
  b.maxWidth = 2048;
  b.maxHeight = 2048;
  b.spriteSheet = null;
  b.scale = 1;
  b.padding = 1;
  b.timeSlice = 0.3;
  b.progress = -1;
  b.onComplete = null;
  b.onProgress = null;
  b.addEventListener = null;
  b.removeEventListener = null;
  b.removeAllEventListeners = null;
  b.dispatchEvent = null;
  b.hasEventListener = null;
  b._listeners = null;
  createjs.EventDispatcher.initialize(b);
  b._frames = null;
  b._animations = null;
  b._data = null;
  b._nextFrameIndex = 0;
  b._index = 0;
  b._timerID = null;
  b._scale = 1;
  b.initialize = function () {
    this._frames = [];
    this._animations = {};
  };
  b.addFrame = function (a, b, g, d, e, f) {
    if (this._data)
      throw c.ERR_RUNNING;
    b = b || a.bounds || a.nominalBounds;
    !b && a.getBounds && (b = a.getBounds());
    if (!b)
      return null;
    g = g || 1;
    return this._frames.push({
      source: a,
      sourceRect: b,
      scale: g,
      funct: d,
      params: e,
      scope: f,
      index: this._frames.length,
      height: b.height * g
    }) - 1;
  };
  b.addAnimation = function (a, b, g, d) {
    if (this._data)
      throw c.ERR_RUNNING;
    this._animations[a] = {
      frames: b,
      next: g,
      frequency: d
    };
  };
  b.addMovieClip = function (a, b, g) {
    if (this._data)
      throw c.ERR_RUNNING;
    var d = a.frameBounds, e = b || a.bounds || a.nominalBounds;
    !e && a.getBounds && (e = a.getBounds());
    if (!e && !d)
      return null;
    b = this._frames.length;
    for (var f = a.timeline.duration, h = 0; h < f; h++)
      this.addFrame(a, d && d[h] ? d[h] : e, g, function (a) {
        var b = this.actionsEnabled;
        this.actionsEnabled = !1;
        this.gotoAndStop(a);
        this.actionsEnabled = b;
      }, [h], a);
    h = a.timeline._labels;
    a = [];
    for (var k in h)
      a.push({
        index: h[k],
        label: k
      });
    if (a.length) {
      a.sort(function (a, b) {
        return a.index - b.index;
      });
      h = 0;
      for (k = a.length; h < k; h++) {
        g = a[h].label;
        for (var d = b + (h == k - 1 ? f : a[h + 1].index), e = [], j = b + a[h].index; j < d; j++)
          e.push(j);
        this.addAnimation(g, e, !0);
      }
    }
  };
  b.build = function () {
    if (this._data)
      throw c.ERR_RUNNING;
    for (this._startBuild(); this._drawNext(););
    this._endBuild();
    return this.spriteSheet;
  };
  b.buildAsync = function (a) {
    if (this._data)
      throw c.ERR_RUNNING;
    this.timeSlice = a;
    this._startBuild();
    var b = this;
    this._timerID = setTimeout(function () {
      b._run();
    }, 50 - 50 * Math.max(0.01, Math.min(0.99, this.timeSlice || 0.3)));
  };
  b.stopAsync = function () {
    clearTimeout(this._timerID);
    this._data = null;
  };
  b.clone = function () {
    throw 'SpriteSheetBuilder cannot be cloned.';
  };
  b.toString = function () {
    return '[SpriteSheetBuilder]';
  };
  b._startBuild = function () {
    var a = this.padding || 0;
    this.progress = 0;
    this.spriteSheet = null;
    this._index = 0;
    this._scale = this.scale;
    var b = [];
    this._data = {
      images: [],
      frames: b,
      animations: this._animations
    };
    var g = this._frames.slice();
    g.sort(function (a, b) {
      return a.height <= b.height ? -1 : 1;
    });
    if (g[g.length - 1].height + 2 * a > this.maxHeight)
      throw c.ERR_DIMENSIONS;
    for (var d = 0, e = 0, f = 0; g.length;) {
      var h = this._fillRow(g, d, f, b, a);
      h.w > e && (e = h.w);
      d += h.h;
      if (!h.h || !g.length) {
        var k = createjs.createCanvas ? createjs.createCanvas() : document.createElement('canvas');
        k.width = this._getSize(e, this.maxWidth);
        k.height = this._getSize(d, this.maxHeight);
        this._data.images[f] = k;
        h.h || (e = d = 0, f++);
      }
    }
  };
  b._getSize = function (a, b) {
    for (var c = 4; Math.pow(2, ++c) < a;);
    return Math.min(b, Math.pow(2, c));
  };
  b._fillRow = function (a, b, g, d, e) {
    var f = this.maxWidth, h = this.maxHeight;
    b += e;
    for (var h = h - b, k = e, j = 0, l = a.length - 1; 0 <= l; l--) {
      var n = a[l], q = this._scale * n.scale, p = n.sourceRect, s = n.source, r = Math.floor(q * p.x - e), u = Math.floor(q * p.y - e), t = Math.ceil(q * p.height + 2 * e), p = Math.ceil(q * p.width + 2 * e);
      if (p > f)
        throw c.ERR_DIMENSIONS;
      t > h || k + p > f || (n.img = g, n.rect = new createjs.Rectangle(k, b, p, t), j = j || t, a.splice(l, 1), d[n.index] = [
        k,
        b,
        p,
        t,
        g,
        Math.round(-r + q * s.regX - e),
        Math.round(-u + q * s.regY - e)
      ], k += p);
    }
    return {
      w: k,
      h: j
    };
  };
  b._endBuild = function () {
    this.spriteSheet = new createjs.SpriteSheet(this._data);
    this._data = null;
    this.progress = 1;
    this.onComplete && this.onComplete(this);
    this.dispatchEvent('complete');
  };
  b._run = function () {
    for (var a = 50 * Math.max(0.01, Math.min(0.99, this.timeSlice || 0.3)), b = new Date().getTime() + a, c = !1; b > new Date().getTime();)
      if (!this._drawNext()) {
        c = !0;
        break;
      }
    if (c)
      this._endBuild();
    else {
      var d = this;
      this._timerID = setTimeout(function () {
        d._run();
      }, 50 - a);
    }
    a = this.progress = this._index / this._frames.length;
    this.onProgress && this.onProgress(this, a);
    this.dispatchEvent({
      type: 'progress',
      progress: a
    });
  };
  b._drawNext = function () {
    var a = this._frames[this._index], b = a.scale * this._scale, c = a.rect, d = a.sourceRect, e = this._data.images[a.img].getContext('2d');
    a.funct && a.funct.apply(a.scope, a.params);
    e.save();
    e.beginPath();
    e.rect(c.x, c.y, c.width, c.height);
    e.clip();
    e.translate(Math.ceil(c.x - d.x * b), Math.ceil(c.y - d.y * b));
    e.scale(b, b);
    a.source.draw(e);
    e.restore();
    return ++this._index < this._frames.length;
  };
  createjs.SpriteSheetBuilder = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function (a) {
      this.initialize(a);
    }, b = c.prototype = new createjs.DisplayObject();
  b.htmlElement = null;
  b._oldMtx = null;
  b.DisplayObject_initialize = b.initialize;
  b.initialize = function (a) {
    'string' == typeof a && (a = document.getElementById(a));
    this.DisplayObject_initialize();
    this.mouseEnabled = !1;
    this.htmlElement = a;
    a = a.style;
    a.position = 'absolute';
    a.transformOrigin = a.WebkitTransformOrigin = a.msTransformOrigin = a.MozTransformOrigin = a.OTransformOrigin = '0% 0%';
  };
  b.isVisible = function () {
    return null != this.htmlElement;
  };
  b.draw = function () {
    if (null != this.htmlElement) {
      var a = this.getConcatenatedMatrix(this._matrix), b = this.htmlElement.style;
      if (this.visible)
        b.visibility = 'visible';
      else
        return !0;
      var c = this._oldMtx || {};
      c.alpha != a.alpha && (b.opacity = '' + a.alpha, c.alpha = a.alpha);
      if (c.tx != a.tx || c.ty != a.ty || c.a != a.a || c.b != a.b || c.c != a.c || c.d != a.d)
        b.transform = b.WebkitTransform = b.OTransform = b.msTransform = [
          'matrix(' + a.a,
          a.b,
          a.c,
          a.d,
          a.tx + 0.5 | 0,
          (a.ty + 0.5 | 0) + ')'
        ].join(), b.MozTransform = [
          'matrix(' + a.a,
          a.b,
          a.c,
          a.d,
          (a.tx + 0.5 | 0) + 'px',
          (a.ty + 0.5 | 0) + 'px)'
        ].join(), this._oldMtx = a.clone();
      return !0;
    }
  };
  b.cache = function () {
  };
  b.uncache = function () {
  };
  b.updateCache = function () {
  };
  b.hitTest = function () {
  };
  b.localToGlobal = function () {
  };
  b.globalToLocal = function () {
  };
  b.localToLocal = function () {
  };
  b.clone = function () {
    throw 'DOMElement cannot be cloned.';
  };
  b.toString = function () {
    return '[DOMElement (name=' + this.name + ')]';
  };
  b.DisplayObject__tick = b._tick;
  b._tick = function (a) {
    this.htmlElement.style.visibility = 'hidden';
    this.DisplayObject__tick(a);
  };
  createjs.DOMElement = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
      this.initialize();
    }, b = c.prototype;
  b.initialize = function () {
  };
  b.getBounds = function () {
    return new createjs.Rectangle(0, 0, 0, 0);
  };
  b.applyFilter = function () {
  };
  b.toString = function () {
    return '[Filter]';
  };
  b.clone = function () {
    return new c();
  };
  createjs.Filter = c;
}());
this.createjs = this.createjs || {};
(function () {
  var c = function () {
    throw 'Touch cannot be instantiated';
  };
  c.isSupported = function () {
    return 'ontouchstart' in window || window.navigator.msPointerEnabled;
  };
  c.enable = function (b, a, m) {
    if (!b || !b.canvas || !c.isSupported())
      return !1;
    b.__touch = {
      pointers: {},
      multitouch: !a,
      preventDefault: !m,
      count: 0
    };
    'ontouchstart' in window ? c._IOS_enable(b) : window.navigator.msPointerEnabled && c._IE_enable(b);
    return !0;
  };
  c.disable = function (b) {
    b && ('ontouchstart' in window ? c._IOS_disable(b) : window.navigator.msPointerEnabled && c._IE_disable(b));
  };
  c._IOS_enable = function (b) {
    var a = b.canvas, m = b.__touch.f = function (a) {
        c._IOS_handleEvent(b, a);
      };
    a.addEventListener('touchstart', m, !1);
    a.addEventListener('touchmove', m, !1);
    a.addEventListener('touchend', m, !1);
    a.addEventListener('touchcancel', m, !1);
  };
  c._IOS_disable = function (b) {
    var a = b.canvas;
    a && (b = b.__touch.f, a.removeEventListener('touchstart', b, !1), a.removeEventListener('touchmove', b, !1), a.removeEventListener('touchend', b, !1), a.removeEventListener('touchcancel', b, !1));
  };
  c._IOS_handleEvent = function (b, a) {
    if (b) {
      b.__touch.preventDefault && a.preventDefault && a.preventDefault();
      for (var c = a.changedTouches, g = a.type, d = 0, e = c.length; d < e; d++) {
        var f = c[d], h = f.identifier;
        f.target == b.canvas && ('touchstart' == g ? this._handleStart(b, h, a, f.pageX, f.pageY) : 'touchmove' == g ? this._handleMove(b, h, a, f.pageX, f.pageY) : ('touchend' == g || 'touchcancel' == g) && this._handleEnd(b, h, a));
      }
    }
  };
  c._IE_enable = function (b) {
    var a = b.canvas, m = b.__touch.f = function (a) {
        c._IE_handleEvent(b, a);
      };
    a.addEventListener('MSPointerDown', m, !1);
    window.addEventListener('MSPointerMove', m, !1);
    window.addEventListener('MSPointerUp', m, !1);
    window.addEventListener('MSPointerCancel', m, !1);
    b.__touch.preventDefault && (a.style.msTouchAction = 'none');
    b.__touch.activeIDs = {};
  };
  c._IE_disable = function (b) {
    var a = b.__touch.f;
    window.removeEventListener('MSPointerMove', a, !1);
    window.removeEventListener('MSPointerUp', a, !1);
    window.removeEventListener('MSPointerCancel', a, !1);
    b.canvas && b.canvas.removeEventListener('MSPointerDown', a, !1);
  };
  c._IE_handleEvent = function (b, a) {
    if (b) {
      b.__touch.preventDefault && a.preventDefault && a.preventDefault();
      var c = a.type, g = a.pointerId, d = b.__touch.activeIDs;
      if ('MSPointerDown' == c)
        a.srcElement == b.canvas && (d[g] = !0, this._handleStart(b, g, a, a.pageX, a.pageY));
      else if (d[g])
        if ('MSPointerMove' == c)
          this._handleMove(b, g, a, a.pageX, a.pageY);
        else if ('MSPointerUp' == c || 'MSPointerCancel' == c)
          delete d[g], this._handleEnd(b, g, a);
    }
  };
  c._handleStart = function (b, a, c, g, d) {
    var e = b.__touch;
    if (e.multitouch || !e.count) {
      var f = e.pointers;
      f[a] || (f[a] = !0, e.count++, b._handlePointerDown(a, c, g, d));
    }
  };
  c._handleMove = function (b, a, c, g, d) {
    b.__touch.pointers[a] && b._handlePointerMove(a, c, g, d);
  };
  c._handleEnd = function (b, a, c) {
    var g = b.__touch, d = g.pointers;
    d[a] && (g.count--, b._handlePointerUp(a, c, !0), delete d[a]);
  };
  createjs.Touch = c;
}());
(function () {
  var c = this.createjs = this.createjs || {}, c = c.EaselJS = c.EaselJS || {};
  c.version = '0.6.1';
  c.buildDate = 'Tue, 14 May 2013 21:43:02 GMT';
}());
this.createjs = this.createjs || {};
(function () {
  var b = function () {
      this.initialize();
    }, a = b.prototype;
  b.initialize = function (d) {
    d.addEventListener = a.addEventListener;
    d.removeEventListener = a.removeEventListener;
    d.removeAllEventListeners = a.removeAllEventListeners;
    d.hasEventListener = a.hasEventListener;
    d.dispatchEvent = a.dispatchEvent;
  };
  a._listeners = null;
  a.initialize = function () {
  };
  a.addEventListener = function (d, a) {
    var c = this._listeners;
    c ? this.removeEventListener(d, a) : c = this._listeners = {};
    var b = c[d];
    b || (b = c[d] = []);
    b.push(a);
    return a;
  };
  a.removeEventListener = function (d, a) {
    var c = this._listeners;
    if (c) {
      var b = c[d];
      if (b)
        for (var f = 0, g = b.length; f < g; f++)
          if (b[f] == a) {
            1 == g ? delete c[d] : b.splice(f, 1);
            break;
          }
    }
  };
  a.removeAllEventListeners = function (d) {
    d ? this._listeners && delete this._listeners[d] : this._listeners = null;
  };
  a.dispatchEvent = function (d, a) {
    var c = !1, b = this._listeners;
    if (d && b) {
      'string' == typeof d && (d = { type: d });
      b = b[d.type];
      if (!b)
        return c;
      d.target = a || this;
      for (var b = b.slice(), f = 0, g = b.length; f < g; f++)
        var j = b[f], c = j.handleEvent ? c || j.handleEvent(d) : c || j(d);
    }
    return !!c;
  };
  a.hasEventListener = function (d) {
    var a = this._listeners;
    return !(!a || !a[d]);
  };
  a.toString = function () {
    return '[EventDispatcher]';
  };
  createjs.EventDispatcher = b;
}());
this.createjs = this.createjs || {};
(function () {
  var b = function (d, a, c) {
      this.initialize(d, a, c);
    }, a = b.prototype;
  b.NONE = 0;
  b.LOOP = 1;
  b.REVERSE = 2;
  b.IGNORE = {};
  b._tweens = [];
  b._plugins = {};
  b.get = function (d, a, c, e) {
    e && b.removeTweens(d);
    return new b(d, a, c);
  };
  b.tick = function (d, a) {
    for (var c = b._tweens.slice(), e = c.length - 1; 0 <= e; e--) {
      var f = c[e];
      a && !f.ignoreGlobalPause || f._paused || f.tick(f._useTicks ? 1 : d);
    }
  };
  createjs.Ticker && createjs.Ticker.addListener(b, !1);
  b.removeTweens = function (d) {
    if (d.tweenjs_count) {
      for (var a = b._tweens, c = a.length - 1; 0 <= c; c--)
        a[c]._target == d && (a[c]._paused = !0, a.splice(c, 1));
      d.tweenjs_count = 0;
    }
  };
  b.removeAllTweens = function () {
    for (var d = b._tweens, a = 0, c = d.length; a < c; a++) {
      var e = d[a];
      e.paused = !0;
      e.target.tweenjs_count = 0;
    }
    d.length = 0;
  };
  b.hasActiveTweens = function (d) {
    return d ? d.tweenjs_count : b._tweens && b._tweens.length;
  };
  b.installPlugin = function (d, a) {
    var c = d.priority;
    null == c && (d.priority = c = 0);
    for (var e = 0, f = a.length, g = b._plugins; e < f; e++) {
      var j = a[e];
      if (g[j]) {
        for (var l = g[j], k = 0, p = l.length; k < p && !(c < l[k].priority); k++);
        g[j].splice(k, 0, d);
      } else
        g[j] = [d];
    }
  };
  b._register = function (d, a) {
    var c = d._target;
    a ? (c && (c.tweenjs_count = c.tweenjs_count ? c.tweenjs_count + 1 : 1), b._tweens.push(d)) : (c && c.tweenjs_count--, c = b._tweens.indexOf(d), -1 != c && b._tweens.splice(c, 1));
  };
  a.addEventListener = null;
  a.removeEventListener = null;
  a.removeAllEventListeners = null;
  a.dispatchEvent = null;
  a.hasEventListener = null;
  a._listeners = null;
  createjs.EventDispatcher.initialize(a);
  a.ignoreGlobalPause = !1;
  a.loop = !1;
  a.duration = 0;
  a.pluginData = null;
  a.onChange = null;
  a.change = null;
  a.target = null;
  a.position = null;
  a._paused = !1;
  a._curQueueProps = null;
  a._initQueueProps = null;
  a._steps = null;
  a._actions = null;
  a._prevPosition = 0;
  a._stepPosition = 0;
  a._prevPos = -1;
  a._target = null;
  a._useTicks = !1;
  a.initialize = function (d, a, c) {
    this.target = this._target = d;
    a && (this._useTicks = a.useTicks, this.ignoreGlobalPause = a.ignoreGlobalPause, this.loop = a.loop, this.onChange = a.onChange, a.override && b.removeTweens(d));
    this.pluginData = c || {};
    this._curQueueProps = {};
    this._initQueueProps = {};
    this._steps = [];
    this._actions = [];
    a && a.paused ? this._paused = !0 : b._register(this, !0);
    a && null != a.position && this.setPosition(a.position, b.NONE);
  };
  a.wait = function (a) {
    if (null == a || 0 >= a)
      return this;
    var b = this._cloneProps(this._curQueueProps);
    return this._addStep({
      d: a,
      p0: b,
      e: this._linearEase,
      p1: b
    });
  };
  a.to = function (a, b, c) {
    if (isNaN(b) || 0 > b)
      b = 0;
    return this._addStep({
      d: b || 0,
      p0: this._cloneProps(this._curQueueProps),
      e: c,
      p1: this._cloneProps(this._appendQueueProps(a))
    });
  };
  a.call = function (a, b, c) {
    return this._addAction({
      f: a,
      p: b ? b : [this],
      o: c ? c : this._target
    });
  };
  a.set = function (a, b) {
    return this._addAction({
      f: this._set,
      o: this,
      p: [
        a,
        b ? b : this._target
      ]
    });
  };
  a.play = function (a) {
    return this.call(a.setPaused, [!1], a);
  };
  a.pause = function (a) {
    a || (a = this);
    return this.call(a.setPaused, [!0], a);
  };
  a.setPosition = function (a, b) {
    0 > a && (a = 0);
    null == b && (b = 1);
    var c = a, e = !1;
    c >= this.duration && (this.loop ? c %= this.duration : (c = this.duration, e = !0));
    if (c == this._prevPos)
      return e;
    var f = this._prevPos;
    this.position = this._prevPos = c;
    this._prevPosition = a;
    if (this._target)
      if (e)
        this._updateTargetProps(null, 1);
      else if (0 < this._steps.length) {
        for (var g = 0, j = this._steps.length; g < j && !(this._steps[g].t > c); g++);
        g = this._steps[g - 1];
        this._updateTargetProps(g, (this._stepPosition = c - g.t) / g.d);
      }
    0 != b && 0 < this._actions.length && (this._useTicks ? this._runActions(c, c) : 1 == b && c < f ? (f != this.duration && this._runActions(f, this.duration), this._runActions(0, c, !0)) : this._runActions(f, c));
    e && this.setPaused(!0);
    this.onChange && this.onChange(this);
    this.dispatchEvent('change');
    return e;
  };
  a.tick = function (a) {
    this._paused || this.setPosition(this._prevPosition + a);
  };
  a.setPaused = function (a) {
    this._paused = !!a;
    b._register(this, !a);
    return this;
  };
  a.w = a.wait;
  a.t = a.to;
  a.c = a.call;
  a.s = a.set;
  a.toString = function () {
    return '[Tween]';
  };
  a.clone = function () {
    throw 'Tween can not be cloned.';
  };
  a._updateTargetProps = function (a, h) {
    var c, e, f, g;
    !a && 1 == h ? c = e = this._curQueueProps : (a.e && (h = a.e(h, 0, 1, 1)), c = a.p0, e = a.p1);
    for (n in this._initQueueProps) {
      if (null == (f = c[n]))
        c[n] = f = this._initQueueProps[n];
      if (null == (g = e[n]))
        e[n] = g = f;
      f = f == g || 0 == h || 1 == h || 'number' != typeof f ? 1 == h ? g : f : f + (g - f) * h;
      var j = !1;
      if (g = b._plugins[n])
        for (var l = 0, k = g.length; l < k; l++) {
          var p = g[l].tween(this, n, f, c, e, h, !!a && c == e, !a);
          p == b.IGNORE ? j = !0 : f = p;
        }
      j || (this._target[n] = f);
    }
  };
  a._runActions = function (a, b, c) {
    var e = a, f = b, g = -1, j = this._actions.length, l = 1;
    a > b && (e = b, f = a, g = j, j = l = -1);
    for (; (g += l) != j;) {
      b = this._actions[g];
      var k = b.t;
      (k == f || k > e && k < f || c && k == a) && b.f.apply(b.o, b.p);
    }
  };
  a._appendQueueProps = function (a) {
    var h, c, e, f, g, j;
    for (j in a) {
      if (void 0 === this._initQueueProps[j]) {
        c = this._target[j];
        if (h = b._plugins[j]) {
          e = 0;
          for (f = h.length; e < f; e++)
            c = h[e].init(this, j, c);
        }
        this._initQueueProps[j] = void 0 === c ? null : c;
      } else
        c = this._curQueueProps[j];
      if (h = b._plugins[j]) {
        g = g || {};
        e = 0;
        for (f = h.length; e < f; e++)
          h[e].step && h[e].step(this, j, c, a[j], g);
      }
      this._curQueueProps[j] = a[j];
    }
    g && this._appendQueueProps(g);
    return this._curQueueProps;
  };
  a._cloneProps = function (a) {
    var b = {}, c;
    for (c in a)
      b[c] = a[c];
    return b;
  };
  a._addStep = function (a) {
    0 < a.d && (this._steps.push(a), a.t = this.duration, this.duration += a.d);
    return this;
  };
  a._addAction = function (a) {
    a.t = this.duration;
    this._actions.push(a);
    return this;
  };
  a._set = function (a, b) {
    for (var c in a)
      b[c] = a[c];
  };
  createjs.Tween = b;
}());
this.createjs = this.createjs || {};
(function () {
  var b = function (a, b, c) {
      this.initialize(a, b, c);
    }, a = b.prototype;
  a.ignoreGlobalPause = !1;
  a.duration = 0;
  a.loop = !1;
  a.onChange = null;
  a.position = null;
  a._paused = !1;
  a._tweens = null;
  a._labels = null;
  a._prevPosition = 0;
  a._prevPos = -1;
  a._useTicks = !1;
  a.initialize = function (a, b, c) {
    this._tweens = [];
    c && (this._useTicks = c.useTicks, this.loop = c.loop, this.ignoreGlobalPause = c.ignoreGlobalPause, this.onChange = c.onChange);
    a && this.addTween.apply(this, a);
    this.setLabels(b);
    c && c.paused ? this._paused = !0 : createjs.Tween._register(this, !0);
    c && null != c.position && this.setPosition(c.position, createjs.Tween.NONE);
  };
  a.addTween = function (a) {
    var b = arguments.length;
    if (1 < b) {
      for (var c = 0; c < b; c++)
        this.addTween(arguments[c]);
      return arguments[0];
    }
    if (0 == b)
      return null;
    this.removeTween(a);
    this._tweens.push(a);
    a.setPaused(!0);
    a._paused = !1;
    a._useTicks = this._useTicks;
    a.duration > this.duration && (this.duration = a.duration);
    0 <= this._prevPos && a.setPosition(this._prevPos, createjs.Tween.NONE);
    return a;
  };
  a.removeTween = function (a) {
    var b = arguments.length;
    if (1 < b) {
      for (var c = !0, e = 0; e < b; e++)
        c = c && this.removeTween(arguments[e]);
      return c;
    }
    if (0 == b)
      return !1;
    b = this._tweens.indexOf(a);
    return -1 != b ? (this._tweens.splice(b, 1), a.duration >= this.duration && this.updateDuration(), !0) : !1;
  };
  a.addLabel = function (a, b) {
    this._labels[a] = b;
  };
  a.setLabels = function (a) {
    this._labels = a ? a : {};
  };
  a.gotoAndPlay = function (a) {
    this.setPaused(!1);
    this._goto(a);
  };
  a.gotoAndStop = function (a) {
    this.setPaused(!0);
    this._goto(a);
  };
  a.setPosition = function (a, b) {
    0 > a && (a = 0);
    var c = this.loop ? a % this.duration : a, e = !this.loop && a >= this.duration;
    if (c == this._prevPos)
      return e;
    this._prevPosition = a;
    this.position = this._prevPos = c;
    for (var f = 0, g = this._tweens.length; f < g; f++)
      if (this._tweens[f].setPosition(c, b), c != this._prevPos)
        return !1;
    e && this.setPaused(!0);
    this.onChange && this.onChange(this);
    return e;
  };
  a.setPaused = function (a) {
    this._paused = !!a;
    createjs.Tween._register(this, !a);
  };
  a.updateDuration = function () {
    for (var a = this.duration = 0, b = this._tweens.length; a < b; a++) {
      var c = this._tweens[a];
      c.duration > this.duration && (this.duration = c.duration);
    }
  };
  a.tick = function (a) {
    this.setPosition(this._prevPosition + a);
  };
  a.resolve = function (a) {
    var b = parseFloat(a);
    isNaN(b) && (b = this._labels[a]);
    return b;
  };
  a.toString = function () {
    return '[Timeline]';
  };
  a.clone = function () {
    throw 'Timeline can not be cloned.';
  };
  a._goto = function (a) {
    a = this.resolve(a);
    null != a && this.setPosition(a);
  };
  createjs.Timeline = b;
}());
this.createjs = this.createjs || {};
(function () {
  var b = function () {
    throw 'Ease cannot be instantiated.';
  };
  b.linear = function (a) {
    return a;
  };
  b.none = b.linear;
  b.get = function (a) {
    -1 > a && (a = -1);
    1 < a && (a = 1);
    return function (b) {
      return 0 == a ? b : 0 > a ? b * (b * -a + 1 + a) : b * ((2 - b) * a + (1 - a));
    };
  };
  b.getPowIn = function (a) {
    return function (b) {
      return Math.pow(b, a);
    };
  };
  b.getPowOut = function (a) {
    return function (b) {
      return 1 - Math.pow(1 - b, a);
    };
  };
  b.getPowInOut = function (a) {
    return function (b) {
      return 1 > (b *= 2) ? 0.5 * Math.pow(b, a) : 1 - 0.5 * Math.abs(Math.pow(2 - b, a));
    };
  };
  b.quadIn = b.getPowIn(2);
  b.quadOut = b.getPowOut(2);
  b.quadInOut = b.getPowInOut(2);
  b.cubicIn = b.getPowIn(3);
  b.cubicOut = b.getPowOut(3);
  b.cubicInOut = b.getPowInOut(3);
  b.quartIn = b.getPowIn(4);
  b.quartOut = b.getPowOut(4);
  b.quartInOut = b.getPowInOut(4);
  b.quintIn = b.getPowIn(5);
  b.quintOut = b.getPowOut(5);
  b.quintInOut = b.getPowInOut(5);
  b.sineIn = function (a) {
    return 1 - Math.cos(a * Math.PI / 2);
  };
  b.sineOut = function (a) {
    return Math.sin(a * Math.PI / 2);
  };
  b.sineInOut = function (a) {
    return -0.5 * (Math.cos(Math.PI * a) - 1);
  };
  b.getBackIn = function (a) {
    return function (b) {
      return b * b * ((a + 1) * b - a);
    };
  };
  b.backIn = b.getBackIn(1.7);
  b.getBackOut = function (a) {
    return function (b) {
      return --b * b * ((a + 1) * b + a) + 1;
    };
  };
  b.backOut = b.getBackOut(1.7);
  b.getBackInOut = function (a) {
    a *= 1.525;
    return function (b) {
      return 1 > (b *= 2) ? 0.5 * b * b * ((a + 1) * b - a) : 0.5 * ((b -= 2) * b * ((a + 1) * b + a) + 2);
    };
  };
  b.backInOut = b.getBackInOut(1.7);
  b.circIn = function (a) {
    return -(Math.sqrt(1 - a * a) - 1);
  };
  b.circOut = function (a) {
    return Math.sqrt(1 - --a * a);
  };
  b.circInOut = function (a) {
    return 1 > (a *= 2) ? -0.5 * (Math.sqrt(1 - a * a) - 1) : 0.5 * (Math.sqrt(1 - (a -= 2) * a) + 1);
  };
  b.bounceIn = function (a) {
    return 1 - b.bounceOut(1 - a);
  };
  b.bounceOut = function (a) {
    return a < 1 / 2.75 ? 7.5625 * a * a : a < 2 / 2.75 ? 7.5625 * (a -= 1.5 / 2.75) * a + 0.75 : a < 2.5 / 2.75 ? 7.5625 * (a -= 2.25 / 2.75) * a + 0.9375 : 7.5625 * (a -= 2.625 / 2.75) * a + 0.984375;
  };
  b.bounceInOut = function (a) {
    return 0.5 > a ? 0.5 * b.bounceIn(2 * a) : 0.5 * b.bounceOut(2 * a - 1) + 0.5;
  };
  b.getElasticIn = function (a, b) {
    var h = 2 * Math.PI;
    return function (c) {
      if (0 == c || 1 == c)
        return c;
      var e = b / h * Math.asin(1 / a);
      return -(a * Math.pow(2, 10 * (c -= 1)) * Math.sin((c - e) * h / b));
    };
  };
  b.elasticIn = b.getElasticIn(1, 0.3);
  b.getElasticOut = function (a, b) {
    var h = 2 * Math.PI;
    return function (c) {
      if (0 == c || 1 == c)
        return c;
      var e = b / h * Math.asin(1 / a);
      return a * Math.pow(2, -10 * c) * Math.sin((c - e) * h / b) + 1;
    };
  };
  b.elasticOut = b.getElasticOut(1, 0.3);
  b.getElasticInOut = function (a, b) {
    var h = 2 * Math.PI;
    return function (c) {
      var e = b / h * Math.asin(1 / a);
      return 1 > (c *= 2) ? -0.5 * a * Math.pow(2, 10 * (c -= 1)) * Math.sin((c - e) * h / b) : 0.5 * a * Math.pow(2, -10 * (c -= 1)) * Math.sin((c - e) * h / b) + 1;
    };
  };
  b.elasticInOut = b.getElasticInOut(1, 0.3 * 1.5);
  createjs.Ease = b;
}());
this.createjs = this.createjs || {};
(function () {
  var b = function () {
    throw 'MotionGuidePlugin cannot be instantiated.';
  };
  b.priority = 0;
  b.install = function () {
    createjs.Tween.installPlugin(b, [
      'guide',
      'x',
      'y',
      'rotation'
    ]);
    return createjs.Tween.IGNORE;
  };
  b.init = function (a, b, h) {
    a = a.target;
    a.hasOwnProperty('x') || (a.x = 0);
    a.hasOwnProperty('y') || (a.y = 0);
    a.hasOwnProperty('rotation') || (a.rotation = 0);
    return 'guide' == b ? null : h;
  };
  b.step = function (a, d, h, c, e) {
    if ('guide' != d)
      return c;
    var f;
    c.hasOwnProperty('path') || (c.path = []);
    a = c.path;
    c.hasOwnProperty('end') || (c.end = 1);
    c.hasOwnProperty('start') || (c.start = h && h.hasOwnProperty('end') && h.path === a ? h.end : 0);
    if (c.hasOwnProperty('_segments') && c._length)
      return c;
    h = a.length;
    if (6 <= h && 0 == (h - 2) % 4) {
      c._segments = [];
      c._length = 0;
      for (d = 2; d < h; d += 4) {
        for (var g = a[d - 2], j = a[d - 1], l = a[d + 0], k = a[d + 1], p = a[d + 2], x = a[d + 3], v = g, w = j, s, m, r = 0, t = [], u = 1; 10 >= u; u++) {
          m = u / 10;
          var q = 1 - m;
          s = q * q * g + 2 * q * m * l + m * m * p;
          m = q * q * j + 2 * q * m * k + m * m * x;
          r += t[t.push(Math.sqrt((f = s - v) * f + (f = m - w) * f)) - 1];
          v = s;
          w = m;
        }
        c._segments.push(r);
        c._segments.push(t);
        c._length += r;
      }
    } else
      throw 'invalid \'path\' data, please see documentation for valid paths';
    f = c.orient;
    c.orient = !1;
    b.calc(c, c.end, e);
    c.orient = f;
    return c;
  };
  b.tween = function (a, d, h, c, e, f, g) {
    e = e.guide;
    if (void 0 == e || e === c.guide)
      return h;
    e.lastRatio != f && (b.calc(e, (e.end - e.start) * (g ? e.end : f) + e.start, a.target), e.orient && (a.target.rotation += c.rotation || 0), e.lastRatio = f);
    return !e.orient && 'rotation' == d ? h : a.target[d];
  };
  b.calc = function (a, d, h) {
    void 0 == a._segments && b.validate(a);
    void 0 == h && (h = {
      x: 0,
      y: 0,
      rotation: 0
    });
    var c = a._segments, e = a.path, f = a._length * d, g = c.length - 2;
    for (d = 0; f > c[d] && d < g;)
      f -= c[d], d += 2;
    for (var c = c[d + 1], j = 0, g = c.length - 1; f > c[j] && j < g;)
      f -= c[j], j++;
    f = j / ++g + f / (g * c[j]);
    d = 2 * d + 2;
    g = 1 - f;
    h.x = g * g * e[d - 2] + 2 * g * f * e[d + 0] + f * f * e[d + 2];
    h.y = g * g * e[d - 1] + 2 * g * f * e[d + 1] + f * f * e[d + 3];
    a.orient && (h.rotation = 57.2957795 * Math.atan2((e[d + 1] - e[d - 1]) * g + (e[d + 3] - e[d + 1]) * f, (e[d + 0] - e[d - 2]) * g + (e[d + 2] - e[d + 0]) * f));
    return h;
  };
  createjs.MotionGuidePlugin = b;
}());
(function () {
  var b = this.createjs = this.createjs || {}, b = b.TweenJS = b.TweenJS || {};
  b.version = '0.4.0';
  b.buildDate = 'Tue, 12 Feb 2013 21:08:16 GMT';
}());
this.createjs = this.createjs || {};
(function () {
  var d = function (b, a, c, f) {
      this.initialize(b, a, c, f);
    }, a = d.prototype = new createjs.Container();
  d.INDEPENDENT = 'independent';
  d.SINGLE_FRAME = 'single';
  d.SYNCHED = 'synched';
  a.startPosition = 0;
  a.loop = !0;
  a.currentFrame = 0;
  a.timeline = null;
  a.paused = !1;
  a.actionsEnabled = !0;
  a.autoReset = !0;
  a._synchOffset = 0;
  a._prevPos = -1;
  a._prevPosition = 0;
  a.Container_initialize = a.initialize;
  a.initialize = function (b, a, c, f) {
    this.mode = b || d.INDEPENDENT;
    this.startPosition = a || 0;
    this.loop = c;
    props = {
      paused: !0,
      position: a,
      useTicks: !0
    };
    this.Container_initialize();
    this.timeline = new createjs.Timeline(null, f, props);
    this._managed = {};
  };
  a.isVisible = function () {
    return !(!this.visible || !(0 < this.alpha && 0 != this.scaleX && 0 != this.scaleY));
  };
  a.Container_draw = a.draw;
  a.draw = function (b, a, c) {
    if (this.DisplayObject_draw(b, a))
      return !0;
    this._updateTimeline();
    this.Container_draw(b, a, c);
  };
  a.play = function () {
    this.paused = !1;
  };
  a.stop = function () {
    this.paused = !0;
  };
  a.gotoAndPlay = function (b) {
    this.paused = !1;
    this._goto(b);
  };
  a.gotoAndStop = function (b) {
    this.paused = !0;
    this._goto(b);
  };
  a.clone = function () {
    throw 'MovieClip cannot be cloned.';
  };
  a.toString = function () {
    return '[MovieClip (name=' + this.name + ')]';
  };
  a.Container__tick = a._tick;
  a._tick = function (b) {
    !this.paused && this.mode == d.INDEPENDENT && (this._prevPosition = 0 > this._prevPos ? 0 : this._prevPosition + 1);
    this.Container__tick(b);
  };
  a._goto = function (b) {
    b = this.timeline.resolve(b);
    null != b && (-1 == this._prevPos && (this._prevPos = NaN), this._prevPosition = b, this._updateTimeline());
  };
  a._reset = function () {
    this._prevPos = -1;
    this.currentFrame = 0;
  };
  a._updateTimeline = function () {
    var b = this.timeline, a = b._tweens, c = this.children, f = this.mode != d.INDEPENDENT;
    b.loop = null == this.loop ? !0 : this.loop;
    f ? b.setPosition(this.startPosition + (this.mode == d.SINGLE_FRAME ? 0 : this._synchOffset), createjs.Tween.NONE) : b.setPosition(0 > this._prevPos ? 0 : this._prevPosition, this.actionsEnabled ? null : createjs.Tween.NONE);
    this._prevPosition = b._prevPosition;
    if (this._prevPos != b._prevPos) {
      this.currentFrame = this._prevPos = b._prevPos;
      for (var e in this._managed)
        this._managed[e] = 1;
      for (b = a.length - 1; 0 <= b; b--)
        e = a[b], f = e._target, f != this && (e = e._stepPosition, f instanceof createjs.DisplayObject ? this._addManagedChild(f, e) : this._setState(f.state, e));
      for (b = c.length - 1; 0 <= b; b--)
        a = c[b].id, 1 == this._managed[a] && (this.removeChildAt(b), delete this._managed[a]);
    }
  };
  a._setState = function (b, a) {
    if (b)
      for (var c = 0, f = b.length; c < f; c++) {
        var e = b[c], d = e.t, e = e.p, g;
        for (g in e)
          d[g] = e[g];
        this._addManagedChild(d, a);
      }
  };
  a._addManagedChild = function (b, a) {
    b._off || (this.addChild(b), b instanceof d && (b._synchOffset = a, b.mode == d.INDEPENDENT && (b.autoReset && !this._managed[b.id]) && b._reset()), this._managed[b.id] = 2);
  };
  createjs.MovieClip = d;
  var g = function () {
    throw 'MovieClipPlugin cannot be instantiated.';
  };
  g.priority = 100;
  g.install = function () {
    createjs.Tween.installPlugin(g, ['startPosition']);
  };
  g.init = function (b, a, c) {
    return c;
  };
  g.step = function () {
  };
  g.tween = function (b, a, c, f, e, g) {
    return !(b.target instanceof d) ? c : 1 == g ? e[a] : f[a];
  };
  g.install();
}());
'use strict';
var THREE = { REVISION: '66' };
self.console = self.console || {
  info: function () {
  },
  log: function () {
  },
  debug: function () {
  },
  warn: function () {
  },
  error: function () {
  }
};
(function () {
  for (var a = 0, b = [
        'ms',
        'moz',
        'webkit',
        'o'
      ], c = 0; c < b.length && !self.requestAnimationFrame; ++c)
    self.requestAnimationFrame = self[b[c] + 'RequestAnimationFrame'], self.cancelAnimationFrame = self[b[c] + 'CancelAnimationFrame'] || self[b[c] + 'CancelRequestAnimationFrame'];
  void 0 === self.requestAnimationFrame && void 0 !== self.setTimeout && (self.requestAnimationFrame = function (b) {
    var c = Date.now(), f = Math.max(0, 16 - (c - a)), g = self.setTimeout(function () {
        b(c + f);
      }, f);
    a = c + f;
    return g;
  });
  void 0 === self.cancelAnimationFrame && void 0 !== self.clearTimeout && (self.cancelAnimationFrame = function (a) {
    self.clearTimeout(a);
  });
}());
THREE.CullFaceNone = 0;
THREE.CullFaceBack = 1;
THREE.CullFaceFront = 2;
THREE.CullFaceFrontBack = 3;
THREE.FrontFaceDirectionCW = 0;
THREE.FrontFaceDirectionCCW = 1;
THREE.BasicShadowMap = 0;
THREE.PCFShadowMap = 1;
THREE.PCFSoftShadowMap = 2;
THREE.FrontSide = 0;
THREE.BackSide = 1;
THREE.DoubleSide = 2;
THREE.NoShading = 0;
THREE.FlatShading = 1;
THREE.SmoothShading = 2;
THREE.NoColors = 0;
THREE.FaceColors = 1;
THREE.VertexColors = 2;
THREE.NoBlending = 0;
THREE.NormalBlending = 1;
THREE.AdditiveBlending = 2;
THREE.SubtractiveBlending = 3;
THREE.MultiplyBlending = 4;
THREE.CustomBlending = 5;
THREE.AddEquation = 100;
THREE.SubtractEquation = 101;
THREE.ReverseSubtractEquation = 102;
THREE.ZeroFactor = 200;
THREE.OneFactor = 201;
THREE.SrcColorFactor = 202;
THREE.OneMinusSrcColorFactor = 203;
THREE.SrcAlphaFactor = 204;
THREE.OneMinusSrcAlphaFactor = 205;
THREE.DstAlphaFactor = 206;
THREE.OneMinusDstAlphaFactor = 207;
THREE.DstColorFactor = 208;
THREE.OneMinusDstColorFactor = 209;
THREE.SrcAlphaSaturateFactor = 210;
THREE.MultiplyOperation = 0;
THREE.MixOperation = 1;
THREE.AddOperation = 2;
THREE.UVMapping = function () {
};
THREE.CubeReflectionMapping = function () {
};
THREE.CubeRefractionMapping = function () {
};
THREE.SphericalReflectionMapping = function () {
};
THREE.SphericalRefractionMapping = function () {
};
THREE.RepeatWrapping = 1000;
THREE.ClampToEdgeWrapping = 1001;
THREE.MirroredRepeatWrapping = 1002;
THREE.NearestFilter = 1003;
THREE.NearestMipMapNearestFilter = 1004;
THREE.NearestMipMapLinearFilter = 1005;
THREE.LinearFilter = 1006;
THREE.LinearMipMapNearestFilter = 1007;
THREE.LinearMipMapLinearFilter = 1008;
THREE.UnsignedByteType = 1009;
THREE.ByteType = 1010;
THREE.ShortType = 1011;
THREE.UnsignedShortType = 1012;
THREE.IntType = 1013;
THREE.UnsignedIntType = 1014;
THREE.FloatType = 1015;
THREE.UnsignedShort4444Type = 1016;
THREE.UnsignedShort5551Type = 1017;
THREE.UnsignedShort565Type = 1018;
THREE.AlphaFormat = 1019;
THREE.RGBFormat = 1020;
THREE.RGBAFormat = 1021;
THREE.LuminanceFormat = 1022;
THREE.LuminanceAlphaFormat = 1023;
THREE.RGB_S3TC_DXT1_Format = 2001;
THREE.RGBA_S3TC_DXT1_Format = 2002;
THREE.RGBA_S3TC_DXT3_Format = 2003;
THREE.RGBA_S3TC_DXT5_Format = 2004;
THREE.Color = function (a) {
  return 3 === arguments.length ? this.setRGB(arguments[0], arguments[1], arguments[2]) : this.set(a);
};
THREE.Color.prototype = {
  constructor: THREE.Color,
  r: 1,
  g: 1,
  b: 1,
  set: function (a) {
    a instanceof THREE.Color ? this.copy(a) : 'number' === typeof a ? this.setHex(a) : 'string' === typeof a && this.setStyle(a);
    return this;
  },
  setHex: function (a) {
    a = Math.floor(a);
    this.r = (a >> 16 & 255) / 255;
    this.g = (a >> 8 & 255) / 255;
    this.b = (a & 255) / 255;
    return this;
  },
  setRGB: function (a, b, c) {
    this.r = a;
    this.g = b;
    this.b = c;
    return this;
  },
  setHSL: function (a, b, c) {
    if (0 === b)
      this.r = this.g = this.b = c;
    else {
      var d = function (a, b, c) {
        0 > c && (c += 1);
        1 < c && (c -= 1);
        return c < 1 / 6 ? a + 6 * (b - a) * c : 0.5 > c ? b : c < 2 / 3 ? a + 6 * (b - a) * (2 / 3 - c) : a;
      };
      b = 0.5 >= c ? c * (1 + b) : c + b - c * b;
      c = 2 * c - b;
      this.r = d(c, b, a + 1 / 3);
      this.g = d(c, b, a);
      this.b = d(c, b, a - 1 / 3);
    }
    return this;
  },
  setStyle: function (a) {
    if (/^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test(a))
      return a = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec(a), this.r = Math.min(255, parseInt(a[1], 10)) / 255, this.g = Math.min(255, parseInt(a[2], 10)) / 255, this.b = Math.min(255, parseInt(a[3], 10)) / 255, this;
    if (/^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test(a))
      return a = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec(a), this.r = Math.min(100, parseInt(a[1], 10)) / 100, this.g = Math.min(100, parseInt(a[2], 10)) / 100, this.b = Math.min(100, parseInt(a[3], 10)) / 100, this;
    if (/^\#([0-9a-f]{6})$/i.test(a))
      return a = /^\#([0-9a-f]{6})$/i.exec(a), this.setHex(parseInt(a[1], 16)), this;
    if (/^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(a))
      return a = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(a), this.setHex(parseInt(a[1] + a[1] + a[2] + a[2] + a[3] + a[3], 16)), this;
    if (/^(\w+)$/i.test(a))
      return this.setHex(THREE.ColorKeywords[a]), this;
  },
  copy: function (a) {
    this.r = a.r;
    this.g = a.g;
    this.b = a.b;
    return this;
  },
  copyGammaToLinear: function (a) {
    this.r = a.r * a.r;
    this.g = a.g * a.g;
    this.b = a.b * a.b;
    return this;
  },
  copyLinearToGamma: function (a) {
    this.r = Math.sqrt(a.r);
    this.g = Math.sqrt(a.g);
    this.b = Math.sqrt(a.b);
    return this;
  },
  convertGammaToLinear: function () {
    var a = this.r, b = this.g, c = this.b;
    this.r = a * a;
    this.g = b * b;
    this.b = c * c;
    return this;
  },
  convertLinearToGamma: function () {
    this.r = Math.sqrt(this.r);
    this.g = Math.sqrt(this.g);
    this.b = Math.sqrt(this.b);
    return this;
  },
  getHex: function () {
    return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;
  },
  getHexString: function () {
    return ('000000' + this.getHex().toString(16)).slice(-6);
  },
  getHSL: function (a) {
    a = a || {
      h: 0,
      s: 0,
      l: 0
    };
    var b = this.r, c = this.g, d = this.b, e = Math.max(b, c, d), f = Math.min(b, c, d), g, h = (f + e) / 2;
    if (f === e)
      f = g = 0;
    else {
      var k = e - f, f = 0.5 >= h ? k / (e + f) : k / (2 - e - f);
      switch (e) {
      case b:
        g = (c - d) / k + (c < d ? 6 : 0);
        break;
      case c:
        g = (d - b) / k + 2;
        break;
      case d:
        g = (b - c) / k + 4;
      }
      g /= 6;
    }
    a.h = g;
    a.s = f;
    a.l = h;
    return a;
  },
  getStyle: function () {
    return 'rgb(' + (255 * this.r | 0) + ',' + (255 * this.g | 0) + ',' + (255 * this.b | 0) + ')';
  },
  offsetHSL: function (a, b, c) {
    var d = this.getHSL();
    d.h += a;
    d.s += b;
    d.l += c;
    this.setHSL(d.h, d.s, d.l);
    return this;
  },
  add: function (a) {
    this.r += a.r;
    this.g += a.g;
    this.b += a.b;
    return this;
  },
  addColors: function (a, b) {
    this.r = a.r + b.r;
    this.g = a.g + b.g;
    this.b = a.b + b.b;
    return this;
  },
  addScalar: function (a) {
    this.r += a;
    this.g += a;
    this.b += a;
    return this;
  },
  multiply: function (a) {
    this.r *= a.r;
    this.g *= a.g;
    this.b *= a.b;
    return this;
  },
  multiplyScalar: function (a) {
    this.r *= a;
    this.g *= a;
    this.b *= a;
    return this;
  },
  lerp: function (a, b) {
    this.r += (a.r - this.r) * b;
    this.g += (a.g - this.g) * b;
    this.b += (a.b - this.b) * b;
    return this;
  },
  equals: function (a) {
    return a.r === this.r && a.g === this.g && a.b === this.b;
  },
  fromArray: function (a) {
    this.r = a[0];
    this.g = a[1];
    this.b = a[2];
    return this;
  },
  toArray: function () {
    return [
      this.r,
      this.g,
      this.b
    ];
  },
  clone: function () {
    return new THREE.Color().setRGB(this.r, this.g, this.b);
  }
};
THREE.ColorKeywords = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
THREE.Quaternion = function (a, b, c, d) {
  this._x = a || 0;
  this._y = b || 0;
  this._z = c || 0;
  this._w = void 0 !== d ? d : 1;
};
THREE.Quaternion.prototype = {
  constructor: THREE.Quaternion,
  _x: 0,
  _y: 0,
  _z: 0,
  _w: 0,
  _euler: void 0,
  _updateEuler: function (a) {
    void 0 !== this._euler && this._euler.setFromQuaternion(this, void 0, !1);
  },
  get x() {
    return this._x;
  },
  set x(a) {
    this._x = a;
    this._updateEuler();
  },
  get y() {
    return this._y;
  },
  set y(a) {
    this._y = a;
    this._updateEuler();
  },
  get z() {
    return this._z;
  },
  set z(a) {
    this._z = a;
    this._updateEuler();
  },
  get w() {
    return this._w;
  },
  set w(a) {
    this._w = a;
    this._updateEuler();
  },
  set: function (a, b, c, d) {
    this._x = a;
    this._y = b;
    this._z = c;
    this._w = d;
    this._updateEuler();
    return this;
  },
  copy: function (a) {
    this._x = a._x;
    this._y = a._y;
    this._z = a._z;
    this._w = a._w;
    this._updateEuler();
    return this;
  },
  setFromEuler: function (a, b) {
    if (!1 === a instanceof THREE.Euler)
      throw Error('ERROR: Quaternion\'s .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.');
    var c = Math.cos(a._x / 2), d = Math.cos(a._y / 2), e = Math.cos(a._z / 2), f = Math.sin(a._x / 2), g = Math.sin(a._y / 2), h = Math.sin(a._z / 2);
    'XYZ' === a.order ? (this._x = f * d * e + c * g * h, this._y = c * g * e - f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e - f * g * h) : 'YXZ' === a.order ? (this._x = f * d * e + c * g * h, this._y = c * g * e - f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e + f * g * h) : 'ZXY' === a.order ? (this._x = f * d * e - c * g * h, this._y = c * g * e + f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e - f * g * h) : 'ZYX' === a.order ? (this._x = f * d * e - c * g * h, this._y = c * g * e + f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e + f * g * h) : 'YZX' === a.order ? (this._x = f * d * e + c * g * h, this._y = c * g * e + f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e - f * g * h) : 'XZY' === a.order && (this._x = f * d * e - c * g * h, this._y = c * g * e - f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e + f * g * h);
    !1 !== b && this._updateEuler();
    return this;
  },
  setFromAxisAngle: function (a, b) {
    var c = b / 2, d = Math.sin(c);
    this._x = a.x * d;
    this._y = a.y * d;
    this._z = a.z * d;
    this._w = Math.cos(c);
    this._updateEuler();
    return this;
  },
  setFromRotationMatrix: function (a) {
    var b = a.elements, c = b[0];
    a = b[4];
    var d = b[8], e = b[1], f = b[5], g = b[9], h = b[2], k = b[6], b = b[10], l = c + f + b;
    0 < l ? (c = 0.5 / Math.sqrt(l + 1), this._w = 0.25 / c, this._x = (k - g) * c, this._y = (d - h) * c, this._z = (e - a) * c) : c > f && c > b ? (c = 2 * Math.sqrt(1 + c - f - b), this._w = (k - g) / c, this._x = 0.25 * c, this._y = (a + e) / c, this._z = (d + h) / c) : f > b ? (c = 2 * Math.sqrt(1 + f - c - b), this._w = (d - h) / c, this._x = (a + e) / c, this._y = 0.25 * c, this._z = (g + k) / c) : (c = 2 * Math.sqrt(1 + b - c - f), this._w = (e - a) / c, this._x = (d + h) / c, this._y = (g + k) / c, this._z = 0.25 * c);
    this._updateEuler();
    return this;
  },
  inverse: function () {
    this.conjugate().normalize();
    return this;
  },
  conjugate: function () {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._updateEuler();
    return this;
  },
  lengthSq: function () {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  },
  length: function () {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  },
  normalize: function () {
    var a = this.length();
    0 === a ? (this._z = this._y = this._x = 0, this._w = 1) : (a = 1 / a, this._x *= a, this._y *= a, this._z *= a, this._w *= a);
    return this;
  },
  multiply: function (a, b) {
    return void 0 !== b ? (console.warn('DEPRECATED: Quaternion\'s .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.'), this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a);
  },
  multiplyQuaternions: function (a, b) {
    var c = a._x, d = a._y, e = a._z, f = a._w, g = b._x, h = b._y, k = b._z, l = b._w;
    this._x = c * l + f * g + d * k - e * h;
    this._y = d * l + f * h + e * g - c * k;
    this._z = e * l + f * k + c * h - d * g;
    this._w = f * l - c * g - d * h - e * k;
    this._updateEuler();
    return this;
  },
  multiplyVector3: function (a) {
    console.warn('DEPRECATED: Quaternion\'s .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
    return a.applyQuaternion(this);
  },
  slerp: function (a, b) {
    var c = this._x, d = this._y, e = this._z, f = this._w, g = f * a._w + c * a._x + d * a._y + e * a._z;
    0 > g ? (this._w = -a._w, this._x = -a._x, this._y = -a._y, this._z = -a._z, g = -g) : this.copy(a);
    if (1 <= g)
      return this._w = f, this._x = c, this._y = d, this._z = e, this;
    var h = Math.acos(g), k = Math.sqrt(1 - g * g);
    if (0.001 > Math.abs(k))
      return this._w = 0.5 * (f + this._w), this._x = 0.5 * (c + this._x), this._y = 0.5 * (d + this._y), this._z = 0.5 * (e + this._z), this;
    g = Math.sin((1 - b) * h) / k;
    h = Math.sin(b * h) / k;
    this._w = f * g + this._w * h;
    this._x = c * g + this._x * h;
    this._y = d * g + this._y * h;
    this._z = e * g + this._z * h;
    this._updateEuler();
    return this;
  },
  equals: function (a) {
    return a._x === this._x && a._y === this._y && a._z === this._z && a._w === this._w;
  },
  fromArray: function (a) {
    this._x = a[0];
    this._y = a[1];
    this._z = a[2];
    this._w = a[3];
    this._updateEuler();
    return this;
  },
  toArray: function () {
    return [
      this._x,
      this._y,
      this._z,
      this._w
    ];
  },
  clone: function () {
    return new THREE.Quaternion(this._x, this._y, this._z, this._w);
  }
};
THREE.Quaternion.slerp = function (a, b, c, d) {
  return c.copy(a).slerp(b, d);
};
THREE.Vector2 = function (a, b) {
  this.x = a || 0;
  this.y = b || 0;
};
THREE.Vector2.prototype = {
  constructor: THREE.Vector2,
  set: function (a, b) {
    this.x = a;
    this.y = b;
    return this;
  },
  setX: function (a) {
    this.x = a;
    return this;
  },
  setY: function (a) {
    this.y = a;
    return this;
  },
  setComponent: function (a, b) {
    switch (a) {
    case 0:
      this.x = b;
      break;
    case 1:
      this.y = b;
      break;
    default:
      throw Error('index is out of range: ' + a);
    }
  },
  getComponent: function (a) {
    switch (a) {
    case 0:
      return this.x;
    case 1:
      return this.y;
    default:
      throw Error('index is out of range: ' + a);
    }
  },
  copy: function (a) {
    this.x = a.x;
    this.y = a.y;
    return this;
  },
  add: function (a, b) {
    if (void 0 !== b)
      return console.warn('DEPRECATED: Vector2\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.'), this.addVectors(a, b);
    this.x += a.x;
    this.y += a.y;
    return this;
  },
  addVectors: function (a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
  },
  addScalar: function (a) {
    this.x += a;
    this.y += a;
    return this;
  },
  sub: function (a, b) {
    if (void 0 !== b)
      return console.warn('DEPRECATED: Vector2\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.'), this.subVectors(a, b);
    this.x -= a.x;
    this.y -= a.y;
    return this;
  },
  subVectors: function (a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
  },
  multiplyScalar: function (a) {
    this.x *= a;
    this.y *= a;
    return this;
  },
  divideScalar: function (a) {
    0 !== a ? (a = 1 / a, this.x *= a, this.y *= a) : this.y = this.x = 0;
    return this;
  },
  min: function (a) {
    this.x > a.x && (this.x = a.x);
    this.y > a.y && (this.y = a.y);
    return this;
  },
  max: function (a) {
    this.x < a.x && (this.x = a.x);
    this.y < a.y && (this.y = a.y);
    return this;
  },
  clamp: function (a, b) {
    this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x);
    this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y);
    return this;
  },
  clampScalar: function () {
    var a, b;
    return function (c, d) {
      void 0 === a && (a = new THREE.Vector2(), b = new THREE.Vector2());
      a.set(c, c);
      b.set(d, d);
      return this.clamp(a, b);
    };
  }(),
  floor: function () {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  },
  ceil: function () {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  },
  round: function () {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  },
  roundToZero: function () {
    this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
    return this;
  },
  negate: function () {
    return this.multiplyScalar(-1);
  },
  dot: function (a) {
    return this.x * a.x + this.y * a.y;
  },
  lengthSq: function () {
    return this.x * this.x + this.y * this.y;
  },
  length: function () {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  },
  normalize: function () {
    return this.divideScalar(this.length());
  },
  distanceTo: function (a) {
    return Math.sqrt(this.distanceToSquared(a));
  },
  distanceToSquared: function (a) {
    var b = this.x - a.x;
    a = this.y - a.y;
    return b * b + a * a;
  },
  setLength: function (a) {
    var b = this.length();
    0 !== b && a !== b && this.multiplyScalar(a / b);
    return this;
  },
  lerp: function (a, b) {
    this.x += (a.x - this.x) * b;
    this.y += (a.y - this.y) * b;
    return this;
  },
  equals: function (a) {
    return a.x === this.x && a.y === this.y;
  },
  fromArray: function (a) {
    this.x = a[0];
    this.y = a[1];
    return this;
  },
  toArray: function () {
    return [
      this.x,
      this.y
    ];
  },
  clone: function () {
    return new THREE.Vector2(this.x, this.y);
  }
};
THREE.Vector3 = function (a, b, c) {
  this.x = a || 0;
  this.y = b || 0;
  this.z = c || 0;
};
THREE.Vector3.prototype = {
  constructor: THREE.Vector3,
  set: function (a, b, c) {
    this.x = a;
    this.y = b;
    this.z = c;
    return this;
  },
  setX: function (a) {
    this.x = a;
    return this;
  },
  setY: function (a) {
    this.y = a;
    return this;
  },
  setZ: function (a) {
    this.z = a;
    return this;
  },
  setComponent: function (a, b) {
    switch (a) {
    case 0:
      this.x = b;
      break;
    case 1:
      this.y = b;
      break;
    case 2:
      this.z = b;
      break;
    default:
      throw Error('index is out of range: ' + a);
    }
  },
  getComponent: function (a) {
    switch (a) {
    case 0:
      return this.x;
    case 1:
      return this.y;
    case 2:
      return this.z;
    default:
      throw Error('index is out of range: ' + a);
    }
  },
  copy: function (a) {
    this.x = a.x;
    this.y = a.y;
    this.z = a.z;
    return this;
  },
  add: function (a, b) {
    if (void 0 !== b)
      return console.warn('DEPRECATED: Vector3\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.'), this.addVectors(a, b);
    this.x += a.x;
    this.y += a.y;
    this.z += a.z;
    return this;
  },
  addScalar: function (a) {
    this.x += a;
    this.y += a;
    this.z += a;
    return this;
  },
  addVectors: function (a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
  },
  sub: function (a, b) {
    if (void 0 !== b)
      return console.warn('DEPRECATED: Vector3\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.'), this.subVectors(a, b);
    this.x -= a.x;
    this.y -= a.y;
    this.z -= a.z;
    return this;
  },
  subVectors: function (a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  },
  multiply: function (a, b) {
    if (void 0 !== b)
      return console.warn('DEPRECATED: Vector3\'s .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.'), this.multiplyVectors(a, b);
    this.x *= a.x;
    this.y *= a.y;
    this.z *= a.z;
    return this;
  },
  multiplyScalar: function (a) {
    this.x *= a;
    this.y *= a;
    this.z *= a;
    return this;
  },
  multiplyVectors: function (a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this;
  },
  applyEuler: function () {
    var a;
    return function (b) {
      !1 === b instanceof THREE.Euler && console.error('ERROR: Vector3\'s .applyEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.');
      void 0 === a && (a = new THREE.Quaternion());
      this.applyQuaternion(a.setFromEuler(b));
      return this;
    };
  }(),
  applyAxisAngle: function () {
    var a;
    return function (b, c) {
      void 0 === a && (a = new THREE.Quaternion());
      this.applyQuaternion(a.setFromAxisAngle(b, c));
      return this;
    };
  }(),
  applyMatrix3: function (a) {
    var b = this.x, c = this.y, d = this.z;
    a = a.elements;
    this.x = a[0] * b + a[3] * c + a[6] * d;
    this.y = a[1] * b + a[4] * c + a[7] * d;
    this.z = a[2] * b + a[5] * c + a[8] * d;
    return this;
  },
  applyMatrix4: function (a) {
    var b = this.x, c = this.y, d = this.z;
    a = a.elements;
    this.x = a[0] * b + a[4] * c + a[8] * d + a[12];
    this.y = a[1] * b + a[5] * c + a[9] * d + a[13];
    this.z = a[2] * b + a[6] * c + a[10] * d + a[14];
    return this;
  },
  applyProjection: function (a) {
    var b = this.x, c = this.y, d = this.z;
    a = a.elements;
    var e = 1 / (a[3] * b + a[7] * c + a[11] * d + a[15]);
    this.x = (a[0] * b + a[4] * c + a[8] * d + a[12]) * e;
    this.y = (a[1] * b + a[5] * c + a[9] * d + a[13]) * e;
    this.z = (a[2] * b + a[6] * c + a[10] * d + a[14]) * e;
    return this;
  },
  applyQuaternion: function (a) {
    var b = this.x, c = this.y, d = this.z, e = a.x, f = a.y, g = a.z;
    a = a.w;
    var h = a * b + f * d - g * c, k = a * c + g * b - e * d, l = a * d + e * c - f * b, b = -e * b - f * c - g * d;
    this.x = h * a + b * -e + k * -g - l * -f;
    this.y = k * a + b * -f + l * -e - h * -g;
    this.z = l * a + b * -g + h * -f - k * -e;
    return this;
  },
  transformDirection: function (a) {
    var b = this.x, c = this.y, d = this.z;
    a = a.elements;
    this.x = a[0] * b + a[4] * c + a[8] * d;
    this.y = a[1] * b + a[5] * c + a[9] * d;
    this.z = a[2] * b + a[6] * c + a[10] * d;
    this.normalize();
    return this;
  },
  divide: function (a) {
    this.x /= a.x;
    this.y /= a.y;
    this.z /= a.z;
    return this;
  },
  divideScalar: function (a) {
    0 !== a ? (a = 1 / a, this.x *= a, this.y *= a, this.z *= a) : this.z = this.y = this.x = 0;
    return this;
  },
  min: function (a) {
    this.x > a.x && (this.x = a.x);
    this.y > a.y && (this.y = a.y);
    this.z > a.z && (this.z = a.z);
    return this;
  },
  max: function (a) {
    this.x < a.x && (this.x = a.x);
    this.y < a.y && (this.y = a.y);
    this.z < a.z && (this.z = a.z);
    return this;
  },
  clamp: function (a, b) {
    this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x);
    this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y);
    this.z < a.z ? this.z = a.z : this.z > b.z && (this.z = b.z);
    return this;
  },
  clampScalar: function () {
    var a, b;
    return function (c, d) {
      void 0 === a && (a = new THREE.Vector3(), b = new THREE.Vector3());
      a.set(c, c, c);
      b.set(d, d, d);
      return this.clamp(a, b);
    };
  }(),
  floor: function () {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  },
  ceil: function () {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  },
  round: function () {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  },
  roundToZero: function () {
    this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
    return this;
  },
  negate: function () {
    return this.multiplyScalar(-1);
  },
  dot: function (a) {
    return this.x * a.x + this.y * a.y + this.z * a.z;
  },
  lengthSq: function () {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  },
  length: function () {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  },
  lengthManhattan: function () {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  },
  normalize: function () {
    return this.divideScalar(this.length());
  },
  setLength: function (a) {
    var b = this.length();
    0 !== b && a !== b && this.multiplyScalar(a / b);
    return this;
  },
  lerp: function (a, b) {
    this.x += (a.x - this.x) * b;
    this.y += (a.y - this.y) * b;
    this.z += (a.z - this.z) * b;
    return this;
  },
  cross: function (a, b) {
    if (void 0 !== b)
      return console.warn('DEPRECATED: Vector3\'s .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.'), this.crossVectors(a, b);
    var c = this.x, d = this.y, e = this.z;
    this.x = d * a.z - e * a.y;
    this.y = e * a.x - c * a.z;
    this.z = c * a.y - d * a.x;
    return this;
  },
  crossVectors: function (a, b) {
    var c = a.x, d = a.y, e = a.z, f = b.x, g = b.y, h = b.z;
    this.x = d * h - e * g;
    this.y = e * f - c * h;
    this.z = c * g - d * f;
    return this;
  },
  projectOnVector: function () {
    var a, b;
    return function (c) {
      void 0 === a && (a = new THREE.Vector3());
      a.copy(c).normalize();
      b = this.dot(a);
      return this.copy(a).multiplyScalar(b);
    };
  }(),
  projectOnPlane: function () {
    var a;
    return function (b) {
      void 0 === a && (a = new THREE.Vector3());
      a.copy(this).projectOnVector(b);
      return this.sub(a);
    };
  }(),
  reflect: function () {
    var a;
    return function (b) {
      void 0 === a && (a = new THREE.Vector3());
      return this.sub(a.copy(b).multiplyScalar(2 * this.dot(b)));
    };
  }(),
  angleTo: function (a) {
    a = this.dot(a) / (this.length() * a.length());
    return Math.acos(THREE.Math.clamp(a, -1, 1));
  },
  distanceTo: function (a) {
    return Math.sqrt(this.distanceToSquared(a));
  },
  distanceToSquared: function (a) {
    var b = this.x - a.x, c = this.y - a.y;
    a = this.z - a.z;
    return b * b + c * c + a * a;
  },
  setEulerFromRotationMatrix: function (a, b) {
    console.error('REMOVED: Vector3\'s setEulerFromRotationMatrix has been removed in favor of Euler.setFromRotationMatrix(), please update your code.');
  },
  setEulerFromQuaternion: function (a, b) {
    console.error('REMOVED: Vector3\'s setEulerFromQuaternion: has been removed in favor of Euler.setFromQuaternion(), please update your code.');
  },
  getPositionFromMatrix: function (a) {
    console.warn('DEPRECATED: Vector3\'s .getPositionFromMatrix() has been renamed to .setFromMatrixPosition(). Please update your code.');
    return this.setFromMatrixPosition(a);
  },
  getScaleFromMatrix: function (a) {
    console.warn('DEPRECATED: Vector3\'s .getScaleFromMatrix() has been renamed to .setFromMatrixScale(). Please update your code.');
    return this.setFromMatrixScale(a);
  },
  getColumnFromMatrix: function (a, b) {
    console.warn('DEPRECATED: Vector3\'s .getColumnFromMatrix() has been renamed to .setFromMatrixColumn(). Please update your code.');
    return this.setFromMatrixColumn(a, b);
  },
  setFromMatrixPosition: function (a) {
    this.x = a.elements[12];
    this.y = a.elements[13];
    this.z = a.elements[14];
    return this;
  },
  setFromMatrixScale: function (a) {
    var b = this.set(a.elements[0], a.elements[1], a.elements[2]).length(), c = this.set(a.elements[4], a.elements[5], a.elements[6]).length();
    a = this.set(a.elements[8], a.elements[9], a.elements[10]).length();
    this.x = b;
    this.y = c;
    this.z = a;
    return this;
  },
  setFromMatrixColumn: function (a, b) {
    var c = 4 * a, d = b.elements;
    this.x = d[c];
    this.y = d[c + 1];
    this.z = d[c + 2];
    return this;
  },
  equals: function (a) {
    return a.x === this.x && a.y === this.y && a.z === this.z;
  },
  fromArray: function (a) {
    this.x = a[0];
    this.y = a[1];
    this.z = a[2];
    return this;
  },
  toArray: function () {
    return [
      this.x,
      this.y,
      this.z
    ];
  },
  clone: function () {
    return new THREE.Vector3(this.x, this.y, this.z);
  }
};
THREE.Vector4 = function (a, b, c, d) {
  this.x = a || 0;
  this.y = b || 0;
  this.z = c || 0;
  this.w = void 0 !== d ? d : 1;
};
THREE.Vector4.prototype = {
  constructor: THREE.Vector4,
  set: function (a, b, c, d) {
    this.x = a;
    this.y = b;
    this.z = c;
    this.w = d;
    return this;
  },
  setX: function (a) {
    this.x = a;
    return this;
  },
  setY: function (a) {
    this.y = a;
    return this;
  },
  setZ: function (a) {
    this.z = a;
    return this;
  },
  setW: function (a) {
    this.w = a;
    return this;
  },
  setComponent: function (a, b) {
    switch (a) {
    case 0:
      this.x = b;
      break;
    case 1:
      this.y = b;
      break;
    case 2:
      this.z = b;
      break;
    case 3:
      this.w = b;
      break;
    default:
      throw Error('index is out of range: ' + a);
    }
  },
  getComponent: function (a) {
    switch (a) {
    case 0:
      return this.x;
    case 1:
      return this.y;
    case 2:
      return this.z;
    case 3:
      return this.w;
    default:
      throw Error('index is out of range: ' + a);
    }
  },
  copy: function (a) {
    this.x = a.x;
    this.y = a.y;
    this.z = a.z;
    this.w = void 0 !== a.w ? a.w : 1;
    return this;
  },
  add: function (a, b) {
    if (void 0 !== b)
      return console.warn('DEPRECATED: Vector4\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.'), this.addVectors(a, b);
    this.x += a.x;
    this.y += a.y;
    this.z += a.z;
    this.w += a.w;
    return this;
  },
  addScalar: function (a) {
    this.x += a;
    this.y += a;
    this.z += a;
    this.w += a;
    return this;
  },
  addVectors: function (a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;
    return this;
  },
  sub: function (a, b) {
    if (void 0 !== b)
      return console.warn('DEPRECATED: Vector4\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.'), this.subVectors(a, b);
    this.x -= a.x;
    this.y -= a.y;
    this.z -= a.z;
    this.w -= a.w;
    return this;
  },
  subVectors: function (a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;
    return this;
  },
  multiplyScalar: function (a) {
    this.x *= a;
    this.y *= a;
    this.z *= a;
    this.w *= a;
    return this;
  },
  applyMatrix4: function (a) {
    var b = this.x, c = this.y, d = this.z, e = this.w;
    a = a.elements;
    this.x = a[0] * b + a[4] * c + a[8] * d + a[12] * e;
    this.y = a[1] * b + a[5] * c + a[9] * d + a[13] * e;
    this.z = a[2] * b + a[6] * c + a[10] * d + a[14] * e;
    this.w = a[3] * b + a[7] * c + a[11] * d + a[15] * e;
    return this;
  },
  divideScalar: function (a) {
    0 !== a ? (a = 1 / a, this.x *= a, this.y *= a, this.z *= a, this.w *= a) : (this.z = this.y = this.x = 0, this.w = 1);
    return this;
  },
  setAxisAngleFromQuaternion: function (a) {
    this.w = 2 * Math.acos(a.w);
    var b = Math.sqrt(1 - a.w * a.w);
    0.0001 > b ? (this.x = 1, this.z = this.y = 0) : (this.x = a.x / b, this.y = a.y / b, this.z = a.z / b);
    return this;
  },
  setAxisAngleFromRotationMatrix: function (a) {
    var b, c, d;
    a = a.elements;
    var e = a[0];
    d = a[4];
    var f = a[8], g = a[1], h = a[5], k = a[9];
    c = a[2];
    b = a[6];
    var l = a[10];
    if (0.01 > Math.abs(d - g) && 0.01 > Math.abs(f - c) && 0.01 > Math.abs(k - b)) {
      if (0.1 > Math.abs(d + g) && 0.1 > Math.abs(f + c) && 0.1 > Math.abs(k + b) && 0.1 > Math.abs(e + h + l - 3))
        return this.set(1, 0, 0, 0), this;
      a = Math.PI;
      e = (e + 1) / 2;
      h = (h + 1) / 2;
      l = (l + 1) / 2;
      d = (d + g) / 4;
      f = (f + c) / 4;
      k = (k + b) / 4;
      e > h && e > l ? 0.01 > e ? (b = 0, d = c = 0.707106781) : (b = Math.sqrt(e), c = d / b, d = f / b) : h > l ? 0.01 > h ? (b = 0.707106781, c = 0, d = 0.707106781) : (c = Math.sqrt(h), b = d / c, d = k / c) : 0.01 > l ? (c = b = 0.707106781, d = 0) : (d = Math.sqrt(l), b = f / d, c = k / d);
      this.set(b, c, d, a);
      return this;
    }
    a = Math.sqrt((b - k) * (b - k) + (f - c) * (f - c) + (g - d) * (g - d));
    0.001 > Math.abs(a) && (a = 1);
    this.x = (b - k) / a;
    this.y = (f - c) / a;
    this.z = (g - d) / a;
    this.w = Math.acos((e + h + l - 1) / 2);
    return this;
  },
  min: function (a) {
    this.x > a.x && (this.x = a.x);
    this.y > a.y && (this.y = a.y);
    this.z > a.z && (this.z = a.z);
    this.w > a.w && (this.w = a.w);
    return this;
  },
  max: function (a) {
    this.x < a.x && (this.x = a.x);
    this.y < a.y && (this.y = a.y);
    this.z < a.z && (this.z = a.z);
    this.w < a.w && (this.w = a.w);
    return this;
  },
  clamp: function (a, b) {
    this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x);
    this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y);
    this.z < a.z ? this.z = a.z : this.z > b.z && (this.z = b.z);
    this.w < a.w ? this.w = a.w : this.w > b.w && (this.w = b.w);
    return this;
  },
  clampScalar: function () {
    var a, b;
    return function (c, d) {
      void 0 === a && (a = new THREE.Vector4(), b = new THREE.Vector4());
      a.set(c, c, c, c);
      b.set(d, d, d, d);
      return this.clamp(a, b);
    };
  }(),
  floor: function () {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  },
  ceil: function () {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  },
  round: function () {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  },
  roundToZero: function () {
    this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
    this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w);
    return this;
  },
  negate: function () {
    return this.multiplyScalar(-1);
  },
  dot: function (a) {
    return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w;
  },
  lengthSq: function () {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  },
  length: function () {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  },
  lengthManhattan: function () {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  },
  normalize: function () {
    return this.divideScalar(this.length());
  },
  setLength: function (a) {
    var b = this.length();
    0 !== b && a !== b && this.multiplyScalar(a / b);
    return this;
  },
  lerp: function (a, b) {
    this.x += (a.x - this.x) * b;
    this.y += (a.y - this.y) * b;
    this.z += (a.z - this.z) * b;
    this.w += (a.w - this.w) * b;
    return this;
  },
  equals: function (a) {
    return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w;
  },
  fromArray: function (a) {
    this.x = a[0];
    this.y = a[1];
    this.z = a[2];
    this.w = a[3];
    return this;
  },
  toArray: function () {
    return [
      this.x,
      this.y,
      this.z,
      this.w
    ];
  },
  clone: function () {
    return new THREE.Vector4(this.x, this.y, this.z, this.w);
  }
};
THREE.Euler = function (a, b, c, d) {
  this._x = a || 0;
  this._y = b || 0;
  this._z = c || 0;
  this._order = d || THREE.Euler.DefaultOrder;
};
THREE.Euler.RotationOrders = 'XYZ YZX ZXY XZY YXZ ZYX'.split(' ');
THREE.Euler.DefaultOrder = 'XYZ';
THREE.Euler.prototype = {
  constructor: THREE.Euler,
  _x: 0,
  _y: 0,
  _z: 0,
  _order: THREE.Euler.DefaultOrder,
  _quaternion: void 0,
  _updateQuaternion: function () {
    void 0 !== this._quaternion && this._quaternion.setFromEuler(this, !1);
  },
  get x() {
    return this._x;
  },
  set x(a) {
    this._x = a;
    this._updateQuaternion();
  },
  get y() {
    return this._y;
  },
  set y(a) {
    this._y = a;
    this._updateQuaternion();
  },
  get z() {
    return this._z;
  },
  set z(a) {
    this._z = a;
    this._updateQuaternion();
  },
  get order() {
    return this._order;
  },
  set order(a) {
    this._order = a;
    this._updateQuaternion();
  },
  set: function (a, b, c, d) {
    this._x = a;
    this._y = b;
    this._z = c;
    this._order = d || this._order;
    this._updateQuaternion();
    return this;
  },
  copy: function (a) {
    this._x = a._x;
    this._y = a._y;
    this._z = a._z;
    this._order = a._order;
    this._updateQuaternion();
    return this;
  },
  setFromRotationMatrix: function (a, b) {
    function c(a) {
      return Math.min(Math.max(a, -1), 1);
    }
    var d = a.elements, e = d[0], f = d[4], g = d[8], h = d[1], k = d[5], l = d[9], n = d[2], s = d[6], d = d[10];
    b = b || this._order;
    'XYZ' === b ? (this._y = Math.asin(c(g)), 0.99999 > Math.abs(g) ? (this._x = Math.atan2(-l, d), this._z = Math.atan2(-f, e)) : (this._x = Math.atan2(s, k), this._z = 0)) : 'YXZ' === b ? (this._x = Math.asin(-c(l)), 0.99999 > Math.abs(l) ? (this._y = Math.atan2(g, d), this._z = Math.atan2(h, k)) : (this._y = Math.atan2(-n, e), this._z = 0)) : 'ZXY' === b ? (this._x = Math.asin(c(s)), 0.99999 > Math.abs(s) ? (this._y = Math.atan2(-n, d), this._z = Math.atan2(-f, k)) : (this._y = 0, this._z = Math.atan2(h, e))) : 'ZYX' === b ? (this._y = Math.asin(-c(n)), 0.99999 > Math.abs(n) ? (this._x = Math.atan2(s, d), this._z = Math.atan2(h, e)) : (this._x = 0, this._z = Math.atan2(-f, k))) : 'YZX' === b ? (this._z = Math.asin(c(h)), 0.99999 > Math.abs(h) ? (this._x = Math.atan2(-l, k), this._y = Math.atan2(-n, e)) : (this._x = 0, this._y = Math.atan2(g, d))) : 'XZY' === b ? (this._z = Math.asin(-c(f)), 0.99999 > Math.abs(f) ? (this._x = Math.atan2(s, k), this._y = Math.atan2(g, e)) : (this._x = Math.atan2(-l, d), this._y = 0)) : console.warn('WARNING: Euler.setFromRotationMatrix() given unsupported order: ' + b);
    this._order = b;
    this._updateQuaternion();
    return this;
  },
  setFromQuaternion: function (a, b, c) {
    function d(a) {
      return Math.min(Math.max(a, -1), 1);
    }
    var e = a.x * a.x, f = a.y * a.y, g = a.z * a.z, h = a.w * a.w;
    b = b || this._order;
    'XYZ' === b ? (this._x = Math.atan2(2 * (a.x * a.w - a.y * a.z), h - e - f + g), this._y = Math.asin(d(2 * (a.x * a.z + a.y * a.w))), this._z = Math.atan2(2 * (a.z * a.w - a.x * a.y), h + e - f - g)) : 'YXZ' === b ? (this._x = Math.asin(d(2 * (a.x * a.w - a.y * a.z))), this._y = Math.atan2(2 * (a.x * a.z + a.y * a.w), h - e - f + g), this._z = Math.atan2(2 * (a.x * a.y + a.z * a.w), h - e + f - g)) : 'ZXY' === b ? (this._x = Math.asin(d(2 * (a.x * a.w + a.y * a.z))), this._y = Math.atan2(2 * (a.y * a.w - a.z * a.x), h - e - f + g), this._z = Math.atan2(2 * (a.z * a.w - a.x * a.y), h - e + f - g)) : 'ZYX' === b ? (this._x = Math.atan2(2 * (a.x * a.w + a.z * a.y), h - e - f + g), this._y = Math.asin(d(2 * (a.y * a.w - a.x * a.z))), this._z = Math.atan2(2 * (a.x * a.y + a.z * a.w), h + e - f - g)) : 'YZX' === b ? (this._x = Math.atan2(2 * (a.x * a.w - a.z * a.y), h - e + f - g), this._y = Math.atan2(2 * (a.y * a.w - a.x * a.z), h + e - f - g), this._z = Math.asin(d(2 * (a.x * a.y + a.z * a.w)))) : 'XZY' === b ? (this._x = Math.atan2(2 * (a.x * a.w + a.y * a.z), h - e + f - g), this._y = Math.atan2(2 * (a.x * a.z + a.y * a.w), h + e - f - g), this._z = Math.asin(d(2 * (a.z * a.w - a.x * a.y)))) : console.warn('WARNING: Euler.setFromQuaternion() given unsupported order: ' + b);
    this._order = b;
    !1 !== c && this._updateQuaternion();
    return this;
  },
  reorder: function () {
    var a = new THREE.Quaternion();
    return function (b) {
      a.setFromEuler(this);
      this.setFromQuaternion(a, b);
    };
  }(),
  fromArray: function (a) {
    this._x = a[0];
    this._y = a[1];
    this._z = a[2];
    void 0 !== a[3] && (this._order = a[3]);
    this._updateQuaternion();
    return this;
  },
  toArray: function () {
    return [
      this._x,
      this._y,
      this._z,
      this._order
    ];
  },
  equals: function (a) {
    return a._x === this._x && a._y === this._y && a._z === this._z && a._order === this._order;
  },
  clone: function () {
    return new THREE.Euler(this._x, this._y, this._z, this._order);
  }
};
THREE.Line3 = function (a, b) {
  this.start = void 0 !== a ? a : new THREE.Vector3();
  this.end = void 0 !== b ? b : new THREE.Vector3();
};
THREE.Line3.prototype = {
  constructor: THREE.Line3,
  set: function (a, b) {
    this.start.copy(a);
    this.end.copy(b);
    return this;
  },
  copy: function (a) {
    this.start.copy(a.start);
    this.end.copy(a.end);
    return this;
  },
  center: function (a) {
    return (a || new THREE.Vector3()).addVectors(this.start, this.end).multiplyScalar(0.5);
  },
  delta: function (a) {
    return (a || new THREE.Vector3()).subVectors(this.end, this.start);
  },
  distanceSq: function () {
    return this.start.distanceToSquared(this.end);
  },
  distance: function () {
    return this.start.distanceTo(this.end);
  },
  at: function (a, b) {
    var c = b || new THREE.Vector3();
    return this.delta(c).multiplyScalar(a).add(this.start);
  },
  closestPointToPointParameter: function () {
    var a = new THREE.Vector3(), b = new THREE.Vector3();
    return function (c, d) {
      a.subVectors(c, this.start);
      b.subVectors(this.end, this.start);
      var e = b.dot(b), e = b.dot(a) / e;
      d && (e = THREE.Math.clamp(e, 0, 1));
      return e;
    };
  }(),
  closestPointToPoint: function (a, b, c) {
    a = this.closestPointToPointParameter(a, b);
    c = c || new THREE.Vector3();
    return this.delta(c).multiplyScalar(a).add(this.start);
  },
  applyMatrix4: function (a) {
    this.start.applyMatrix4(a);
    this.end.applyMatrix4(a);
    return this;
  },
  equals: function (a) {
    return a.start.equals(this.start) && a.end.equals(this.end);
  },
  clone: function () {
    return new THREE.Line3().copy(this);
  }
};
THREE.Box2 = function (a, b) {
  this.min = void 0 !== a ? a : new THREE.Vector2(Infinity, Infinity);
  this.max = void 0 !== b ? b : new THREE.Vector2(-Infinity, -Infinity);
};
THREE.Box2.prototype = {
  constructor: THREE.Box2,
  set: function (a, b) {
    this.min.copy(a);
    this.max.copy(b);
    return this;
  },
  setFromPoints: function (a) {
    if (0 < a.length) {
      var b = a[0];
      this.min.copy(b);
      this.max.copy(b);
      for (var c = 1, d = a.length; c < d; c++)
        b = a[c], b.x < this.min.x ? this.min.x = b.x : b.x > this.max.x && (this.max.x = b.x), b.y < this.min.y ? this.min.y = b.y : b.y > this.max.y && (this.max.y = b.y);
    } else
      this.makeEmpty();
    return this;
  },
  setFromCenterAndSize: function () {
    var a = new THREE.Vector2();
    return function (b, c) {
      var d = a.copy(c).multiplyScalar(0.5);
      this.min.copy(b).sub(d);
      this.max.copy(b).add(d);
      return this;
    };
  }(),
  copy: function (a) {
    this.min.copy(a.min);
    this.max.copy(a.max);
    return this;
  },
  makeEmpty: function () {
    this.min.x = this.min.y = Infinity;
    this.max.x = this.max.y = -Infinity;
    return this;
  },
  empty: function () {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  },
  center: function (a) {
    return (a || new THREE.Vector2()).addVectors(this.min, this.max).multiplyScalar(0.5);
  },
  size: function (a) {
    return (a || new THREE.Vector2()).subVectors(this.max, this.min);
  },
  expandByPoint: function (a) {
    this.min.min(a);
    this.max.max(a);
    return this;
  },
  expandByVector: function (a) {
    this.min.sub(a);
    this.max.add(a);
    return this;
  },
  expandByScalar: function (a) {
    this.min.addScalar(-a);
    this.max.addScalar(a);
    return this;
  },
  containsPoint: function (a) {
    return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y ? !1 : !0;
  },
  containsBox: function (a) {
    return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y ? !0 : !1;
  },
  getParameter: function (a, b) {
    return (b || new THREE.Vector2()).set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y));
  },
  isIntersectionBox: function (a) {
    return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y ? !1 : !0;
  },
  clampPoint: function (a, b) {
    return (b || new THREE.Vector2()).copy(a).clamp(this.min, this.max);
  },
  distanceToPoint: function () {
    var a = new THREE.Vector2();
    return function (b) {
      return a.copy(b).clamp(this.min, this.max).sub(b).length();
    };
  }(),
  intersect: function (a) {
    this.min.max(a.min);
    this.max.min(a.max);
    return this;
  },
  union: function (a) {
    this.min.min(a.min);
    this.max.max(a.max);
    return this;
  },
  translate: function (a) {
    this.min.add(a);
    this.max.add(a);
    return this;
  },
  equals: function (a) {
    return a.min.equals(this.min) && a.max.equals(this.max);
  },
  clone: function () {
    return new THREE.Box2().copy(this);
  }
};
THREE.Box3 = function (a, b) {
  this.min = void 0 !== a ? a : new THREE.Vector3(Infinity, Infinity, Infinity);
  this.max = void 0 !== b ? b : new THREE.Vector3(-Infinity, -Infinity, -Infinity);
};
THREE.Box3.prototype = {
  constructor: THREE.Box3,
  set: function (a, b) {
    this.min.copy(a);
    this.max.copy(b);
    return this;
  },
  addPoint: function (a) {
    a.x < this.min.x ? this.min.x = a.x : a.x > this.max.x && (this.max.x = a.x);
    a.y < this.min.y ? this.min.y = a.y : a.y > this.max.y && (this.max.y = a.y);
    a.z < this.min.z ? this.min.z = a.z : a.z > this.max.z && (this.max.z = a.z);
  },
  setFromPoints: function (a) {
    if (0 < a.length) {
      var b = a[0];
      this.min.copy(b);
      this.max.copy(b);
      for (var b = 1, c = a.length; b < c; b++)
        this.addPoint(a[b]);
    } else
      this.makeEmpty();
    return this;
  },
  setFromCenterAndSize: function () {
    var a = new THREE.Vector3();
    return function (b, c) {
      var d = a.copy(c).multiplyScalar(0.5);
      this.min.copy(b).sub(d);
      this.max.copy(b).add(d);
      return this;
    };
  }(),
  setFromObject: function () {
    var a = new THREE.Vector3();
    return function (b) {
      var c = this;
      b.updateMatrixWorld(!0);
      this.makeEmpty();
      b.traverse(function (b) {
        if (void 0 !== b.geometry && void 0 !== b.geometry.vertices)
          for (var e = b.geometry.vertices, f = 0, g = e.length; f < g; f++)
            a.copy(e[f]), a.applyMatrix4(b.matrixWorld), c.expandByPoint(a);
      });
      return this;
    };
  }(),
  copy: function (a) {
    this.min.copy(a.min);
    this.max.copy(a.max);
    return this;
  },
  makeEmpty: function () {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  },
  empty: function () {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  },
  center: function (a) {
    return (a || new THREE.Vector3()).addVectors(this.min, this.max).multiplyScalar(0.5);
  },
  size: function (a) {
    return (a || new THREE.Vector3()).subVectors(this.max, this.min);
  },
  expandByPoint: function (a) {
    this.min.min(a);
    this.max.max(a);
    return this;
  },
  expandByVector: function (a) {
    this.min.sub(a);
    this.max.add(a);
    return this;
  },
  expandByScalar: function (a) {
    this.min.addScalar(-a);
    this.max.addScalar(a);
    return this;
  },
  containsPoint: function (a) {
    return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y || a.z < this.min.z || a.z > this.max.z ? !1 : !0;
  },
  containsBox: function (a) {
    return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z && a.max.z <= this.max.z ? !0 : !1;
  },
  getParameter: function (a, b) {
    return (b || new THREE.Vector3()).set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z - this.min.z) / (this.max.z - this.min.z));
  },
  isIntersectionBox: function (a) {
    return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max.z < this.min.z || a.min.z > this.max.z ? !1 : !0;
  },
  clampPoint: function (a, b) {
    return (b || new THREE.Vector3()).copy(a).clamp(this.min, this.max);
  },
  distanceToPoint: function () {
    var a = new THREE.Vector3();
    return function (b) {
      return a.copy(b).clamp(this.min, this.max).sub(b).length();
    };
  }(),
  getBoundingSphere: function () {
    var a = new THREE.Vector3();
    return function (b) {
      b = b || new THREE.Sphere();
      b.center = this.center();
      b.radius = 0.5 * this.size(a).length();
      return b;
    };
  }(),
  intersect: function (a) {
    this.min.max(a.min);
    this.max.min(a.max);
    return this;
  },
  union: function (a) {
    this.min.min(a.min);
    this.max.max(a.max);
    return this;
  },
  applyMatrix4: function () {
    var a = [
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3()
      ];
    return function (b) {
      a[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(b);
      a[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(b);
      a[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(b);
      a[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(b);
      a[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(b);
      a[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(b);
      a[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(b);
      a[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(b);
      this.makeEmpty();
      this.setFromPoints(a);
      return this;
    };
  }(),
  translate: function (a) {
    this.min.add(a);
    this.max.add(a);
    return this;
  },
  equals: function (a) {
    return a.min.equals(this.min) && a.max.equals(this.max);
  },
  clone: function () {
    return new THREE.Box3().copy(this);
  }
};
THREE.Matrix3 = function (a, b, c, d, e, f, g, h, k) {
  this.elements = new Float32Array(9);
  this.set(void 0 !== a ? a : 1, b || 0, c || 0, d || 0, void 0 !== e ? e : 1, f || 0, g || 0, h || 0, void 0 !== k ? k : 1);
};
THREE.Matrix3.prototype = {
  constructor: THREE.Matrix3,
  set: function (a, b, c, d, e, f, g, h, k) {
    var l = this.elements;
    l[0] = a;
    l[3] = b;
    l[6] = c;
    l[1] = d;
    l[4] = e;
    l[7] = f;
    l[2] = g;
    l[5] = h;
    l[8] = k;
    return this;
  },
  identity: function () {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  },
  copy: function (a) {
    a = a.elements;
    this.set(a[0], a[3], a[6], a[1], a[4], a[7], a[2], a[5], a[8]);
    return this;
  },
  multiplyVector3: function (a) {
    console.warn('DEPRECATED: Matrix3\'s .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
    return a.applyMatrix3(this);
  },
  multiplyVector3Array: function () {
    var a = new THREE.Vector3();
    return function (b) {
      for (var c = 0, d = b.length; c < d; c += 3)
        a.x = b[c], a.y = b[c + 1], a.z = b[c + 2], a.applyMatrix3(this), b[c] = a.x, b[c + 1] = a.y, b[c + 2] = a.z;
      return b;
    };
  }(),
  multiplyScalar: function (a) {
    var b = this.elements;
    b[0] *= a;
    b[3] *= a;
    b[6] *= a;
    b[1] *= a;
    b[4] *= a;
    b[7] *= a;
    b[2] *= a;
    b[5] *= a;
    b[8] *= a;
    return this;
  },
  determinant: function () {
    var a = this.elements, b = a[0], c = a[1], d = a[2], e = a[3], f = a[4], g = a[5], h = a[6], k = a[7], a = a[8];
    return b * f * a - b * g * k - c * e * a + c * g * h + d * e * k - d * f * h;
  },
  getInverse: function (a, b) {
    var c = a.elements, d = this.elements;
    d[0] = c[10] * c[5] - c[6] * c[9];
    d[1] = -c[10] * c[1] + c[2] * c[9];
    d[2] = c[6] * c[1] - c[2] * c[5];
    d[3] = -c[10] * c[4] + c[6] * c[8];
    d[4] = c[10] * c[0] - c[2] * c[8];
    d[5] = -c[6] * c[0] + c[2] * c[4];
    d[6] = c[9] * c[4] - c[5] * c[8];
    d[7] = -c[9] * c[0] + c[1] * c[8];
    d[8] = c[5] * c[0] - c[1] * c[4];
    c = c[0] * d[0] + c[1] * d[3] + c[2] * d[6];
    if (0 === c) {
      if (b)
        throw Error('Matrix3.getInverse(): can\'t invert matrix, determinant is 0');
      console.warn('Matrix3.getInverse(): can\'t invert matrix, determinant is 0');
      this.identity();
      return this;
    }
    this.multiplyScalar(1 / c);
    return this;
  },
  transpose: function () {
    var a, b = this.elements;
    a = b[1];
    b[1] = b[3];
    b[3] = a;
    a = b[2];
    b[2] = b[6];
    b[6] = a;
    a = b[5];
    b[5] = b[7];
    b[7] = a;
    return this;
  },
  getNormalMatrix: function (a) {
    this.getInverse(a).transpose();
    return this;
  },
  transposeIntoArray: function (a) {
    var b = this.elements;
    a[0] = b[0];
    a[1] = b[3];
    a[2] = b[6];
    a[3] = b[1];
    a[4] = b[4];
    a[5] = b[7];
    a[6] = b[2];
    a[7] = b[5];
    a[8] = b[8];
    return this;
  },
  fromArray: function (a) {
    this.elements.set(a);
    return this;
  },
  toArray: function () {
    var a = this.elements;
    return [
      a[0],
      a[1],
      a[2],
      a[3],
      a[4],
      a[5],
      a[6],
      a[7],
      a[8]
    ];
  },
  clone: function () {
    var a = this.elements;
    return new THREE.Matrix3(a[0], a[3], a[6], a[1], a[4], a[7], a[2], a[5], a[8]);
  }
};
THREE.Matrix4 = function (a, b, c, d, e, f, g, h, k, l, n, s, r, q, u, p) {
  var v = this.elements = new Float32Array(16);
  v[0] = void 0 !== a ? a : 1;
  v[4] = b || 0;
  v[8] = c || 0;
  v[12] = d || 0;
  v[1] = e || 0;
  v[5] = void 0 !== f ? f : 1;
  v[9] = g || 0;
  v[13] = h || 0;
  v[2] = k || 0;
  v[6] = l || 0;
  v[10] = void 0 !== n ? n : 1;
  v[14] = s || 0;
  v[3] = r || 0;
  v[7] = q || 0;
  v[11] = u || 0;
  v[15] = void 0 !== p ? p : 1;
};
THREE.Matrix4.prototype = {
  constructor: THREE.Matrix4,
  set: function (a, b, c, d, e, f, g, h, k, l, n, s, r, q, u, p) {
    var v = this.elements;
    v[0] = a;
    v[4] = b;
    v[8] = c;
    v[12] = d;
    v[1] = e;
    v[5] = f;
    v[9] = g;
    v[13] = h;
    v[2] = k;
    v[6] = l;
    v[10] = n;
    v[14] = s;
    v[3] = r;
    v[7] = q;
    v[11] = u;
    v[15] = p;
    return this;
  },
  identity: function () {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  },
  copy: function (a) {
    this.elements.set(a.elements);
    return this;
  },
  extractPosition: function (a) {
    console.warn('DEPRECATED: Matrix4\'s .extractPosition() has been renamed to .copyPosition().');
    return this.copyPosition(a);
  },
  copyPosition: function (a) {
    var b = this.elements;
    a = a.elements;
    b[12] = a[12];
    b[13] = a[13];
    b[14] = a[14];
    return this;
  },
  extractRotation: function () {
    var a = new THREE.Vector3();
    return function (b) {
      var c = this.elements;
      b = b.elements;
      var d = 1 / a.set(b[0], b[1], b[2]).length(), e = 1 / a.set(b[4], b[5], b[6]).length(), f = 1 / a.set(b[8], b[9], b[10]).length();
      c[0] = b[0] * d;
      c[1] = b[1] * d;
      c[2] = b[2] * d;
      c[4] = b[4] * e;
      c[5] = b[5] * e;
      c[6] = b[6] * e;
      c[8] = b[8] * f;
      c[9] = b[9] * f;
      c[10] = b[10] * f;
      return this;
    };
  }(),
  makeRotationFromEuler: function (a) {
    !1 === a instanceof THREE.Euler && console.error('ERROR: Matrix\'s .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.');
    var b = this.elements, c = a.x, d = a.y, e = a.z, f = Math.cos(c), c = Math.sin(c), g = Math.cos(d), d = Math.sin(d), h = Math.cos(e), e = Math.sin(e);
    if ('XYZ' === a.order) {
      a = f * h;
      var k = f * e, l = c * h, n = c * e;
      b[0] = g * h;
      b[4] = -g * e;
      b[8] = d;
      b[1] = k + l * d;
      b[5] = a - n * d;
      b[9] = -c * g;
      b[2] = n - a * d;
      b[6] = l + k * d;
      b[10] = f * g;
    } else
      'YXZ' === a.order ? (a = g * h, k = g * e, l = d * h, n = d * e, b[0] = a + n * c, b[4] = l * c - k, b[8] = f * d, b[1] = f * e, b[5] = f * h, b[9] = -c, b[2] = k * c - l, b[6] = n + a * c, b[10] = f * g) : 'ZXY' === a.order ? (a = g * h, k = g * e, l = d * h, n = d * e, b[0] = a - n * c, b[4] = -f * e, b[8] = l + k * c, b[1] = k + l * c, b[5] = f * h, b[9] = n - a * c, b[2] = -f * d, b[6] = c, b[10] = f * g) : 'ZYX' === a.order ? (a = f * h, k = f * e, l = c * h, n = c * e, b[0] = g * h, b[4] = l * d - k, b[8] = a * d + n, b[1] = g * e, b[5] = n * d + a, b[9] = k * d - l, b[2] = -d, b[6] = c * g, b[10] = f * g) : 'YZX' === a.order ? (a = f * g, k = f * d, l = c * g, n = c * d, b[0] = g * h, b[4] = n - a * e, b[8] = l * e + k, b[1] = e, b[5] = f * h, b[9] = -c * h, b[2] = -d * h, b[6] = k * e + l, b[10] = a - n * e) : 'XZY' === a.order && (a = f * g, k = f * d, l = c * g, n = c * d, b[0] = g * h, b[4] = -e, b[8] = d * h, b[1] = a * e + n, b[5] = f * h, b[9] = k * e - l, b[2] = l * e - k, b[6] = c * h, b[10] = n * e + a);
    b[3] = 0;
    b[7] = 0;
    b[11] = 0;
    b[12] = 0;
    b[13] = 0;
    b[14] = 0;
    b[15] = 1;
    return this;
  },
  setRotationFromQuaternion: function (a) {
    console.warn('DEPRECATED: Matrix4\'s .setRotationFromQuaternion() has been deprecated in favor of makeRotationFromQuaternion.  Please update your code.');
    return this.makeRotationFromQuaternion(a);
  },
  makeRotationFromQuaternion: function (a) {
    var b = this.elements, c = a.x, d = a.y, e = a.z, f = a.w, g = c + c, h = d + d, k = e + e;
    a = c * g;
    var l = c * h, c = c * k, n = d * h, d = d * k, e = e * k, g = f * g, h = f * h, f = f * k;
    b[0] = 1 - (n + e);
    b[4] = l - f;
    b[8] = c + h;
    b[1] = l + f;
    b[5] = 1 - (a + e);
    b[9] = d - g;
    b[2] = c - h;
    b[6] = d + g;
    b[10] = 1 - (a + n);
    b[3] = 0;
    b[7] = 0;
    b[11] = 0;
    b[12] = 0;
    b[13] = 0;
    b[14] = 0;
    b[15] = 1;
    return this;
  },
  lookAt: function () {
    var a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Vector3();
    return function (d, e, f) {
      var g = this.elements;
      c.subVectors(d, e).normalize();
      0 === c.length() && (c.z = 1);
      a.crossVectors(f, c).normalize();
      0 === a.length() && (c.x += 0.0001, a.crossVectors(f, c).normalize());
      b.crossVectors(c, a);
      g[0] = a.x;
      g[4] = b.x;
      g[8] = c.x;
      g[1] = a.y;
      g[5] = b.y;
      g[9] = c.y;
      g[2] = a.z;
      g[6] = b.z;
      g[10] = c.z;
      return this;
    };
  }(),
  multiply: function (a, b) {
    return void 0 !== b ? (console.warn('DEPRECATED: Matrix4\'s .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.'), this.multiplyMatrices(a, b)) : this.multiplyMatrices(this, a);
  },
  multiplyMatrices: function (a, b) {
    var c = a.elements, d = b.elements, e = this.elements, f = c[0], g = c[4], h = c[8], k = c[12], l = c[1], n = c[5], s = c[9], r = c[13], q = c[2], u = c[6], p = c[10], v = c[14], w = c[3], t = c[7], x = c[11], c = c[15], z = d[0], B = d[4], E = d[8], H = d[12], D = d[1], G = d[5], I = d[9], O = d[13], K = d[2], y = d[6], F = d[10], C = d[14], A = d[3], L = d[7], Q = d[11], d = d[15];
    e[0] = f * z + g * D + h * K + k * A;
    e[4] = f * B + g * G + h * y + k * L;
    e[8] = f * E + g * I + h * F + k * Q;
    e[12] = f * H + g * O + h * C + k * d;
    e[1] = l * z + n * D + s * K + r * A;
    e[5] = l * B + n * G + s * y + r * L;
    e[9] = l * E + n * I + s * F + r * Q;
    e[13] = l * H + n * O + s * C + r * d;
    e[2] = q * z + u * D + p * K + v * A;
    e[6] = q * B + u * G + p * y + v * L;
    e[10] = q * E + u * I + p * F + v * Q;
    e[14] = q * H + u * O + p * C + v * d;
    e[3] = w * z + t * D + x * K + c * A;
    e[7] = w * B + t * G + x * y + c * L;
    e[11] = w * E + t * I + x * F + c * Q;
    e[15] = w * H + t * O + x * C + c * d;
    return this;
  },
  multiplyToArray: function (a, b, c) {
    var d = this.elements;
    this.multiplyMatrices(a, b);
    c[0] = d[0];
    c[1] = d[1];
    c[2] = d[2];
    c[3] = d[3];
    c[4] = d[4];
    c[5] = d[5];
    c[6] = d[6];
    c[7] = d[7];
    c[8] = d[8];
    c[9] = d[9];
    c[10] = d[10];
    c[11] = d[11];
    c[12] = d[12];
    c[13] = d[13];
    c[14] = d[14];
    c[15] = d[15];
    return this;
  },
  multiplyScalar: function (a) {
    var b = this.elements;
    b[0] *= a;
    b[4] *= a;
    b[8] *= a;
    b[12] *= a;
    b[1] *= a;
    b[5] *= a;
    b[9] *= a;
    b[13] *= a;
    b[2] *= a;
    b[6] *= a;
    b[10] *= a;
    b[14] *= a;
    b[3] *= a;
    b[7] *= a;
    b[11] *= a;
    b[15] *= a;
    return this;
  },
  multiplyVector3: function (a) {
    console.warn('DEPRECATED: Matrix4\'s .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.');
    return a.applyProjection(this);
  },
  multiplyVector4: function (a) {
    console.warn('DEPRECATED: Matrix4\'s .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
    return a.applyMatrix4(this);
  },
  multiplyVector3Array: function () {
    var a = new THREE.Vector3();
    return function (b) {
      for (var c = 0, d = b.length; c < d; c += 3)
        a.x = b[c], a.y = b[c + 1], a.z = b[c + 2], a.applyProjection(this), b[c] = a.x, b[c + 1] = a.y, b[c + 2] = a.z;
      return b;
    };
  }(),
  rotateAxis: function (a) {
    console.warn('DEPRECATED: Matrix4\'s .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
    a.transformDirection(this);
  },
  crossVector: function (a) {
    console.warn('DEPRECATED: Matrix4\'s .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
    return a.applyMatrix4(this);
  },
  determinant: function () {
    var a = this.elements, b = a[0], c = a[4], d = a[8], e = a[12], f = a[1], g = a[5], h = a[9], k = a[13], l = a[2], n = a[6], s = a[10], r = a[14];
    return a[3] * (+e * h * n - d * k * n - e * g * s + c * k * s + d * g * r - c * h * r) + a[7] * (+b * h * r - b * k * s + e * f * s - d * f * r + d * k * l - e * h * l) + a[11] * (+b * k * n - b * g * r - e * f * n + c * f * r + e * g * l - c * k * l) + a[15] * (-d * g * l - b * h * n + b * g * s + d * f * n - c * f * s + c * h * l);
  },
  transpose: function () {
    var a = this.elements, b;
    b = a[1];
    a[1] = a[4];
    a[4] = b;
    b = a[2];
    a[2] = a[8];
    a[8] = b;
    b = a[6];
    a[6] = a[9];
    a[9] = b;
    b = a[3];
    a[3] = a[12];
    a[12] = b;
    b = a[7];
    a[7] = a[13];
    a[13] = b;
    b = a[11];
    a[11] = a[14];
    a[14] = b;
    return this;
  },
  flattenToArray: function (a) {
    var b = this.elements;
    a[0] = b[0];
    a[1] = b[1];
    a[2] = b[2];
    a[3] = b[3];
    a[4] = b[4];
    a[5] = b[5];
    a[6] = b[6];
    a[7] = b[7];
    a[8] = b[8];
    a[9] = b[9];
    a[10] = b[10];
    a[11] = b[11];
    a[12] = b[12];
    a[13] = b[13];
    a[14] = b[14];
    a[15] = b[15];
    return a;
  },
  flattenToArrayOffset: function (a, b) {
    var c = this.elements;
    a[b] = c[0];
    a[b + 1] = c[1];
    a[b + 2] = c[2];
    a[b + 3] = c[3];
    a[b + 4] = c[4];
    a[b + 5] = c[5];
    a[b + 6] = c[6];
    a[b + 7] = c[7];
    a[b + 8] = c[8];
    a[b + 9] = c[9];
    a[b + 10] = c[10];
    a[b + 11] = c[11];
    a[b + 12] = c[12];
    a[b + 13] = c[13];
    a[b + 14] = c[14];
    a[b + 15] = c[15];
    return a;
  },
  getPosition: function () {
    var a = new THREE.Vector3();
    return function () {
      console.warn('DEPRECATED: Matrix4\'s .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
      var b = this.elements;
      return a.set(b[12], b[13], b[14]);
    };
  }(),
  setPosition: function (a) {
    var b = this.elements;
    b[12] = a.x;
    b[13] = a.y;
    b[14] = a.z;
    return this;
  },
  getInverse: function (a, b) {
    var c = this.elements, d = a.elements, e = d[0], f = d[4], g = d[8], h = d[12], k = d[1], l = d[5], n = d[9], s = d[13], r = d[2], q = d[6], u = d[10], p = d[14], v = d[3], w = d[7], t = d[11], d = d[15];
    c[0] = n * p * w - s * u * w + s * q * t - l * p * t - n * q * d + l * u * d;
    c[4] = h * u * w - g * p * w - h * q * t + f * p * t + g * q * d - f * u * d;
    c[8] = g * s * w - h * n * w + h * l * t - f * s * t - g * l * d + f * n * d;
    c[12] = h * n * q - g * s * q - h * l * u + f * s * u + g * l * p - f * n * p;
    c[1] = s * u * v - n * p * v - s * r * t + k * p * t + n * r * d - k * u * d;
    c[5] = g * p * v - h * u * v + h * r * t - e * p * t - g * r * d + e * u * d;
    c[9] = h * n * v - g * s * v - h * k * t + e * s * t + g * k * d - e * n * d;
    c[13] = g * s * r - h * n * r + h * k * u - e * s * u - g * k * p + e * n * p;
    c[2] = l * p * v - s * q * v + s * r * w - k * p * w - l * r * d + k * q * d;
    c[6] = h * q * v - f * p * v - h * r * w + e * p * w + f * r * d - e * q * d;
    c[10] = f * s * v - h * l * v + h * k * w - e * s * w - f * k * d + e * l * d;
    c[14] = h * l * r - f * s * r - h * k * q + e * s * q + f * k * p - e * l * p;
    c[3] = n * q * v - l * u * v - n * r * w + k * u * w + l * r * t - k * q * t;
    c[7] = f * u * v - g * q * v + g * r * w - e * u * w - f * r * t + e * q * t;
    c[11] = g * l * v - f * n * v - g * k * w + e * n * w + f * k * t - e * l * t;
    c[15] = f * n * r - g * l * r + g * k * q - e * n * q - f * k * u + e * l * u;
    c = e * c[0] + k * c[4] + r * c[8] + v * c[12];
    if (0 == c) {
      if (b)
        throw Error('Matrix4.getInverse(): can\'t invert matrix, determinant is 0');
      console.warn('Matrix4.getInverse(): can\'t invert matrix, determinant is 0');
      this.identity();
      return this;
    }
    this.multiplyScalar(1 / c);
    return this;
  },
  translate: function (a) {
    console.warn('DEPRECATED: Matrix4\'s .translate() has been removed.');
  },
  rotateX: function (a) {
    console.warn('DEPRECATED: Matrix4\'s .rotateX() has been removed.');
  },
  rotateY: function (a) {
    console.warn('DEPRECATED: Matrix4\'s .rotateY() has been removed.');
  },
  rotateZ: function (a) {
    console.warn('DEPRECATED: Matrix4\'s .rotateZ() has been removed.');
  },
  rotateByAxis: function (a, b) {
    console.warn('DEPRECATED: Matrix4\'s .rotateByAxis() has been removed.');
  },
  scale: function (a) {
    var b = this.elements, c = a.x, d = a.y;
    a = a.z;
    b[0] *= c;
    b[4] *= d;
    b[8] *= a;
    b[1] *= c;
    b[5] *= d;
    b[9] *= a;
    b[2] *= c;
    b[6] *= d;
    b[10] *= a;
    b[3] *= c;
    b[7] *= d;
    b[11] *= a;
    return this;
  },
  getMaxScaleOnAxis: function () {
    var a = this.elements;
    return Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], Math.max(a[4] * a[4] + a[5] * a[5] + a[6] * a[6], a[8] * a[8] + a[9] * a[9] + a[10] * a[10])));
  },
  makeTranslation: function (a, b, c) {
    this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1);
    return this;
  },
  makeRotationX: function (a) {
    var b = Math.cos(a);
    a = Math.sin(a);
    this.set(1, 0, 0, 0, 0, b, -a, 0, 0, a, b, 0, 0, 0, 0, 1);
    return this;
  },
  makeRotationY: function (a) {
    var b = Math.cos(a);
    a = Math.sin(a);
    this.set(b, 0, a, 0, 0, 1, 0, 0, -a, 0, b, 0, 0, 0, 0, 1);
    return this;
  },
  makeRotationZ: function (a) {
    var b = Math.cos(a);
    a = Math.sin(a);
    this.set(b, -a, 0, 0, a, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  },
  makeRotationAxis: function (a, b) {
    var c = Math.cos(b), d = Math.sin(b), e = 1 - c, f = a.x, g = a.y, h = a.z, k = e * f, l = e * g;
    this.set(k * f + c, k * g - d * h, k * h + d * g, 0, k * g + d * h, l * g + c, l * h - d * f, 0, k * h - d * g, l * h + d * f, e * h * h + c, 0, 0, 0, 0, 1);
    return this;
  },
  makeScale: function (a, b, c) {
    this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1);
    return this;
  },
  compose: function (a, b, c) {
    this.makeRotationFromQuaternion(b);
    this.scale(c);
    this.setPosition(a);
    return this;
  },
  decompose: function () {
    var a = new THREE.Vector3(), b = new THREE.Matrix4();
    return function (c, d, e) {
      var f = this.elements, g = a.set(f[0], f[1], f[2]).length(), h = a.set(f[4], f[5], f[6]).length(), k = a.set(f[8], f[9], f[10]).length();
      0 > this.determinant() && (g = -g);
      c.x = f[12];
      c.y = f[13];
      c.z = f[14];
      b.elements.set(this.elements);
      c = 1 / g;
      var f = 1 / h, l = 1 / k;
      b.elements[0] *= c;
      b.elements[1] *= c;
      b.elements[2] *= c;
      b.elements[4] *= f;
      b.elements[5] *= f;
      b.elements[6] *= f;
      b.elements[8] *= l;
      b.elements[9] *= l;
      b.elements[10] *= l;
      d.setFromRotationMatrix(b);
      e.x = g;
      e.y = h;
      e.z = k;
      return this;
    };
  }(),
  makeFrustum: function (a, b, c, d, e, f) {
    var g = this.elements;
    g[0] = 2 * e / (b - a);
    g[4] = 0;
    g[8] = (b + a) / (b - a);
    g[12] = 0;
    g[1] = 0;
    g[5] = 2 * e / (d - c);
    g[9] = (d + c) / (d - c);
    g[13] = 0;
    g[2] = 0;
    g[6] = 0;
    g[10] = -(f + e) / (f - e);
    g[14] = -2 * f * e / (f - e);
    g[3] = 0;
    g[7] = 0;
    g[11] = -1;
    g[15] = 0;
    return this;
  },
  makePerspective: function (a, b, c, d) {
    a = c * Math.tan(THREE.Math.degToRad(0.5 * a));
    var e = -a;
    return this.makeFrustum(e * b, a * b, e, a, c, d);
  },
  makeOrthographic: function (a, b, c, d, e, f) {
    var g = this.elements, h = b - a, k = c - d, l = f - e;
    g[0] = 2 / h;
    g[4] = 0;
    g[8] = 0;
    g[12] = -((b + a) / h);
    g[1] = 0;
    g[5] = 2 / k;
    g[9] = 0;
    g[13] = -((c + d) / k);
    g[2] = 0;
    g[6] = 0;
    g[10] = -2 / l;
    g[14] = -((f + e) / l);
    g[3] = 0;
    g[7] = 0;
    g[11] = 0;
    g[15] = 1;
    return this;
  },
  fromArray: function (a) {
    this.elements.set(a);
    return this;
  },
  toArray: function () {
    var a = this.elements;
    return [
      a[0],
      a[1],
      a[2],
      a[3],
      a[4],
      a[5],
      a[6],
      a[7],
      a[8],
      a[9],
      a[10],
      a[11],
      a[12],
      a[13],
      a[14],
      a[15]
    ];
  },
  clone: function () {
    var a = this.elements;
    return new THREE.Matrix4(a[0], a[4], a[8], a[12], a[1], a[5], a[9], a[13], a[2], a[6], a[10], a[14], a[3], a[7], a[11], a[15]);
  }
};
THREE.Ray = function (a, b) {
  this.origin = void 0 !== a ? a : new THREE.Vector3();
  this.direction = void 0 !== b ? b : new THREE.Vector3();
};
THREE.Ray.prototype = {
  constructor: THREE.Ray,
  set: function (a, b) {
    this.origin.copy(a);
    this.direction.copy(b);
    return this;
  },
  copy: function (a) {
    this.origin.copy(a.origin);
    this.direction.copy(a.direction);
    return this;
  },
  at: function (a, b) {
    return (b || new THREE.Vector3()).copy(this.direction).multiplyScalar(a).add(this.origin);
  },
  recast: function () {
    var a = new THREE.Vector3();
    return function (b) {
      this.origin.copy(this.at(b, a));
      return this;
    };
  }(),
  closestPointToPoint: function (a, b) {
    var c = b || new THREE.Vector3();
    c.subVectors(a, this.origin);
    var d = c.dot(this.direction);
    return 0 > d ? c.copy(this.origin) : c.copy(this.direction).multiplyScalar(d).add(this.origin);
  },
  distanceToPoint: function () {
    var a = new THREE.Vector3();
    return function (b) {
      var c = a.subVectors(b, this.origin).dot(this.direction);
      if (0 > c)
        return this.origin.distanceTo(b);
      a.copy(this.direction).multiplyScalar(c).add(this.origin);
      return a.distanceTo(b);
    };
  }(),
  distanceSqToSegment: function (a, b, c, d) {
    var e = a.clone().add(b).multiplyScalar(0.5), f = b.clone().sub(a).normalize(), g = 0.5 * a.distanceTo(b), h = this.origin.clone().sub(e);
    a = -this.direction.dot(f);
    b = h.dot(this.direction);
    var k = -h.dot(f), l = h.lengthSq(), n = Math.abs(1 - a * a), s, r;
    0 <= n ? (h = a * k - b, s = a * b - k, r = g * n, 0 <= h ? s >= -r ? s <= r ? (g = 1 / n, h *= g, s *= g, a = h * (h + a * s + 2 * b) + s * (a * h + s + 2 * k) + l) : (s = g, h = Math.max(0, -(a * s + b)), a = -h * h + s * (s + 2 * k) + l) : (s = -g, h = Math.max(0, -(a * s + b)), a = -h * h + s * (s + 2 * k) + l) : s <= -r ? (h = Math.max(0, -(-a * g + b)), s = 0 < h ? -g : Math.min(Math.max(-g, -k), g), a = -h * h + s * (s + 2 * k) + l) : s <= r ? (h = 0, s = Math.min(Math.max(-g, -k), g), a = s * (s + 2 * k) + l) : (h = Math.max(0, -(a * g + b)), s = 0 < h ? g : Math.min(Math.max(-g, -k), g), a = -h * h + s * (s + 2 * k) + l)) : (s = 0 < a ? -g : g, h = Math.max(0, -(a * s + b)), a = -h * h + s * (s + 2 * k) + l);
    c && c.copy(this.direction.clone().multiplyScalar(h).add(this.origin));
    d && d.copy(f.clone().multiplyScalar(s).add(e));
    return a;
  },
  isIntersectionSphere: function (a) {
    return this.distanceToPoint(a.center) <= a.radius;
  },
  isIntersectionPlane: function (a) {
    var b = a.distanceToPoint(this.origin);
    return 0 === b || 0 > a.normal.dot(this.direction) * b ? !0 : !1;
  },
  distanceToPlane: function (a) {
    var b = a.normal.dot(this.direction);
    if (0 == b)
      return 0 == a.distanceToPoint(this.origin) ? 0 : null;
    a = -(this.origin.dot(a.normal) + a.constant) / b;
    return 0 <= a ? a : null;
  },
  intersectPlane: function (a, b) {
    var c = this.distanceToPlane(a);
    return null === c ? null : this.at(c, b);
  },
  isIntersectionBox: function () {
    var a = new THREE.Vector3();
    return function (b) {
      return null !== this.intersectBox(b, a);
    };
  }(),
  intersectBox: function (a, b) {
    var c, d, e, f, g;
    d = 1 / this.direction.x;
    f = 1 / this.direction.y;
    g = 1 / this.direction.z;
    var h = this.origin;
    0 <= d ? (c = (a.min.x - h.x) * d, d *= a.max.x - h.x) : (c = (a.max.x - h.x) * d, d *= a.min.x - h.x);
    0 <= f ? (e = (a.min.y - h.y) * f, f *= a.max.y - h.y) : (e = (a.max.y - h.y) * f, f *= a.min.y - h.y);
    if (c > f || e > d)
      return null;
    if (e > c || c !== c)
      c = e;
    if (f < d || d !== d)
      d = f;
    0 <= g ? (e = (a.min.z - h.z) * g, g *= a.max.z - h.z) : (e = (a.max.z - h.z) * g, g *= a.min.z - h.z);
    if (c > g || e > d)
      return null;
    if (e > c || c !== c)
      c = e;
    if (g < d || d !== d)
      d = g;
    return 0 > d ? null : this.at(0 <= c ? c : d, b);
  },
  intersectTriangle: function () {
    var a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Vector3(), d = new THREE.Vector3();
    return function (e, f, g, h, k) {
      b.subVectors(f, e);
      c.subVectors(g, e);
      d.crossVectors(b, c);
      f = this.direction.dot(d);
      if (0 < f) {
        if (h)
          return null;
        h = 1;
      } else if (0 > f)
        h = -1, f = -f;
      else
        return null;
      a.subVectors(this.origin, e);
      e = h * this.direction.dot(c.crossVectors(a, c));
      if (0 > e)
        return null;
      g = h * this.direction.dot(b.cross(a));
      if (0 > g || e + g > f)
        return null;
      e = -h * a.dot(d);
      return 0 > e ? null : this.at(e / f, k);
    };
  }(),
  applyMatrix4: function (a) {
    this.direction.add(this.origin).applyMatrix4(a);
    this.origin.applyMatrix4(a);
    this.direction.sub(this.origin);
    this.direction.normalize();
    return this;
  },
  equals: function (a) {
    return a.origin.equals(this.origin) && a.direction.equals(this.direction);
  },
  clone: function () {
    return new THREE.Ray().copy(this);
  }
};
THREE.Sphere = function (a, b) {
  this.center = void 0 !== a ? a : new THREE.Vector3();
  this.radius = void 0 !== b ? b : 0;
};
THREE.Sphere.prototype = {
  constructor: THREE.Sphere,
  set: function (a, b) {
    this.center.copy(a);
    this.radius = b;
    return this;
  },
  setFromPoints: function () {
    var a = new THREE.Box3();
    return function (b, c) {
      var d = this.center;
      void 0 !== c ? d.copy(c) : a.setFromPoints(b).center(d);
      for (var e = 0, f = 0, g = b.length; f < g; f++)
        e = Math.max(e, d.distanceToSquared(b[f]));
      this.radius = Math.sqrt(e);
      return this;
    };
  }(),
  copy: function (a) {
    this.center.copy(a.center);
    this.radius = a.radius;
    return this;
  },
  empty: function () {
    return 0 >= this.radius;
  },
  containsPoint: function (a) {
    return a.distanceToSquared(this.center) <= this.radius * this.radius;
  },
  distanceToPoint: function (a) {
    return a.distanceTo(this.center) - this.radius;
  },
  intersectsSphere: function (a) {
    var b = this.radius + a.radius;
    return a.center.distanceToSquared(this.center) <= b * b;
  },
  clampPoint: function (a, b) {
    var c = this.center.distanceToSquared(a), d = b || new THREE.Vector3();
    d.copy(a);
    c > this.radius * this.radius && (d.sub(this.center).normalize(), d.multiplyScalar(this.radius).add(this.center));
    return d;
  },
  getBoundingBox: function (a) {
    a = a || new THREE.Box3();
    a.set(this.center, this.center);
    a.expandByScalar(this.radius);
    return a;
  },
  applyMatrix4: function (a) {
    this.center.applyMatrix4(a);
    this.radius *= a.getMaxScaleOnAxis();
    return this;
  },
  translate: function (a) {
    this.center.add(a);
    return this;
  },
  equals: function (a) {
    return a.center.equals(this.center) && a.radius === this.radius;
  },
  clone: function () {
    return new THREE.Sphere().copy(this);
  }
};
THREE.Frustum = function (a, b, c, d, e, f) {
  this.planes = [
    void 0 !== a ? a : new THREE.Plane(),
    void 0 !== b ? b : new THREE.Plane(),
    void 0 !== c ? c : new THREE.Plane(),
    void 0 !== d ? d : new THREE.Plane(),
    void 0 !== e ? e : new THREE.Plane(),
    void 0 !== f ? f : new THREE.Plane()
  ];
};
THREE.Frustum.prototype = {
  constructor: THREE.Frustum,
  set: function (a, b, c, d, e, f) {
    var g = this.planes;
    g[0].copy(a);
    g[1].copy(b);
    g[2].copy(c);
    g[3].copy(d);
    g[4].copy(e);
    g[5].copy(f);
    return this;
  },
  copy: function (a) {
    for (var b = this.planes, c = 0; 6 > c; c++)
      b[c].copy(a.planes[c]);
    return this;
  },
  setFromMatrix: function (a) {
    var b = this.planes, c = a.elements;
    a = c[0];
    var d = c[1], e = c[2], f = c[3], g = c[4], h = c[5], k = c[6], l = c[7], n = c[8], s = c[9], r = c[10], q = c[11], u = c[12], p = c[13], v = c[14], c = c[15];
    b[0].setComponents(f - a, l - g, q - n, c - u).normalize();
    b[1].setComponents(f + a, l + g, q + n, c + u).normalize();
    b[2].setComponents(f + d, l + h, q + s, c + p).normalize();
    b[3].setComponents(f - d, l - h, q - s, c - p).normalize();
    b[4].setComponents(f - e, l - k, q - r, c - v).normalize();
    b[5].setComponents(f + e, l + k, q + r, c + v).normalize();
    return this;
  },
  intersectsObject: function () {
    var a = new THREE.Sphere();
    return function (b) {
      var c = b.geometry;
      null === c.boundingSphere && c.computeBoundingSphere();
      a.copy(c.boundingSphere);
      a.applyMatrix4(b.matrixWorld);
      return this.intersectsSphere(a);
    };
  }(),
  intersectsSphere: function (a) {
    var b = this.planes, c = a.center;
    a = -a.radius;
    for (var d = 0; 6 > d; d++)
      if (b[d].distanceToPoint(c) < a)
        return !1;
    return !0;
  },
  intersectsBox: function () {
    var a = new THREE.Vector3(), b = new THREE.Vector3();
    return function (c) {
      for (var d = this.planes, e = 0; 6 > e; e++) {
        var f = d[e];
        a.x = 0 < f.normal.x ? c.min.x : c.max.x;
        b.x = 0 < f.normal.x ? c.max.x : c.min.x;
        a.y = 0 < f.normal.y ? c.min.y : c.max.y;
        b.y = 0 < f.normal.y ? c.max.y : c.min.y;
        a.z = 0 < f.normal.z ? c.min.z : c.max.z;
        b.z = 0 < f.normal.z ? c.max.z : c.min.z;
        var g = f.distanceToPoint(a), f = f.distanceToPoint(b);
        if (0 > g && 0 > f)
          return !1;
      }
      return !0;
    };
  }(),
  containsPoint: function (a) {
    for (var b = this.planes, c = 0; 6 > c; c++)
      if (0 > b[c].distanceToPoint(a))
        return !1;
    return !0;
  },
  clone: function () {
    return new THREE.Frustum().copy(this);
  }
};
THREE.Plane = function (a, b) {
  this.normal = void 0 !== a ? a : new THREE.Vector3(1, 0, 0);
  this.constant = void 0 !== b ? b : 0;
};
THREE.Plane.prototype = {
  constructor: THREE.Plane,
  set: function (a, b) {
    this.normal.copy(a);
    this.constant = b;
    return this;
  },
  setComponents: function (a, b, c, d) {
    this.normal.set(a, b, c);
    this.constant = d;
    return this;
  },
  setFromNormalAndCoplanarPoint: function (a, b) {
    this.normal.copy(a);
    this.constant = -b.dot(this.normal);
    return this;
  },
  setFromCoplanarPoints: function () {
    var a = new THREE.Vector3(), b = new THREE.Vector3();
    return function (c, d, e) {
      d = a.subVectors(e, d).cross(b.subVectors(c, d)).normalize();
      this.setFromNormalAndCoplanarPoint(d, c);
      return this;
    };
  }(),
  copy: function (a) {
    this.normal.copy(a.normal);
    this.constant = a.constant;
    return this;
  },
  normalize: function () {
    var a = 1 / this.normal.length();
    this.normal.multiplyScalar(a);
    this.constant *= a;
    return this;
  },
  negate: function () {
    this.constant *= -1;
    this.normal.negate();
    return this;
  },
  distanceToPoint: function (a) {
    return this.normal.dot(a) + this.constant;
  },
  distanceToSphere: function (a) {
    return this.distanceToPoint(a.center) - a.radius;
  },
  projectPoint: function (a, b) {
    return this.orthoPoint(a, b).sub(a).negate();
  },
  orthoPoint: function (a, b) {
    var c = this.distanceToPoint(a);
    return (b || new THREE.Vector3()).copy(this.normal).multiplyScalar(c);
  },
  isIntersectionLine: function (a) {
    var b = this.distanceToPoint(a.start);
    a = this.distanceToPoint(a.end);
    return 0 > b && 0 < a || 0 > a && 0 < b;
  },
  intersectLine: function () {
    var a = new THREE.Vector3();
    return function (b, c) {
      var d = c || new THREE.Vector3(), e = b.delta(a), f = this.normal.dot(e);
      if (0 == f) {
        if (0 == this.distanceToPoint(b.start))
          return d.copy(b.start);
      } else
        return f = -(b.start.dot(this.normal) + this.constant) / f, 0 > f || 1 < f ? void 0 : d.copy(e).multiplyScalar(f).add(b.start);
    };
  }(),
  coplanarPoint: function (a) {
    return (a || new THREE.Vector3()).copy(this.normal).multiplyScalar(-this.constant);
  },
  applyMatrix4: function () {
    var a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Matrix3();
    return function (d, e) {
      var f = e || c.getNormalMatrix(d), f = a.copy(this.normal).applyMatrix3(f), g = this.coplanarPoint(b);
      g.applyMatrix4(d);
      this.setFromNormalAndCoplanarPoint(f, g);
      return this;
    };
  }(),
  translate: function (a) {
    this.constant -= a.dot(this.normal);
    return this;
  },
  equals: function (a) {
    return a.normal.equals(this.normal) && a.constant == this.constant;
  },
  clone: function () {
    return new THREE.Plane().copy(this);
  }
};
THREE.Math = {
  PI2: 2 * Math.PI,
  generateUUID: function () {
    var a = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''), b = Array(36), c = 0, d;
    return function () {
      for (var e = 0; 36 > e; e++)
        8 == e || 13 == e || 18 == e || 23 == e ? b[e] = '-' : 14 == e ? b[e] = '4' : (2 >= c && (c = 33554432 + 16777216 * Math.random() | 0), d = c & 15, c >>= 4, b[e] = a[19 == e ? d & 3 | 8 : d]);
      return b.join('');
    };
  }(),
  clamp: function (a, b, c) {
    return a < b ? b : a > c ? c : a;
  },
  clampBottom: function (a, b) {
    return a < b ? b : a;
  },
  mapLinear: function (a, b, c, d, e) {
    return d + (a - b) * (e - d) / (c - b);
  },
  smoothstep: function (a, b, c) {
    if (a <= b)
      return 0;
    if (a >= c)
      return 1;
    a = (a - b) / (c - b);
    return a * a * (3 - 2 * a);
  },
  smootherstep: function (a, b, c) {
    if (a <= b)
      return 0;
    if (a >= c)
      return 1;
    a = (a - b) / (c - b);
    return a * a * a * (a * (6 * a - 15) + 10);
  },
  random16: function () {
    return (65280 * Math.random() + 255 * Math.random()) / 65535;
  },
  randInt: function (a, b) {
    return a + Math.floor(Math.random() * (b - a + 1));
  },
  randFloat: function (a, b) {
    return a + Math.random() * (b - a);
  },
  randFloatSpread: function (a) {
    return a * (0.5 - Math.random());
  },
  sign: function (a) {
    return 0 > a ? -1 : 0 < a ? 1 : 0;
  },
  degToRad: function () {
    var a = Math.PI / 180;
    return function (b) {
      return b * a;
    };
  }(),
  radToDeg: function () {
    var a = 180 / Math.PI;
    return function (b) {
      return b * a;
    };
  }(),
  isPowerOfTwo: function (a) {
    return 0 === (a & a - 1) && 0 !== a;
  }
};
THREE.Spline = function (a) {
  function b(a, b, c, d, e, f, g) {
    a = 0.5 * (c - a);
    d = 0.5 * (d - b);
    return (2 * (b - c) + a + d) * g + (-3 * (b - c) - 2 * a - d) * f + a * e + b;
  }
  this.points = a;
  var c = [], d = {
      x: 0,
      y: 0,
      z: 0
    }, e, f, g, h, k, l, n, s, r;
  this.initFromArray = function (a) {
    this.points = [];
    for (var b = 0; b < a.length; b++)
      this.points[b] = {
        x: a[b][0],
        y: a[b][1],
        z: a[b][2]
      };
  };
  this.getPoint = function (a) {
    e = (this.points.length - 1) * a;
    f = Math.floor(e);
    g = e - f;
    c[0] = 0 === f ? f : f - 1;
    c[1] = f;
    c[2] = f > this.points.length - 2 ? this.points.length - 1 : f + 1;
    c[3] = f > this.points.length - 3 ? this.points.length - 1 : f + 2;
    l = this.points[c[0]];
    n = this.points[c[1]];
    s = this.points[c[2]];
    r = this.points[c[3]];
    h = g * g;
    k = g * h;
    d.x = b(l.x, n.x, s.x, r.x, g, h, k);
    d.y = b(l.y, n.y, s.y, r.y, g, h, k);
    d.z = b(l.z, n.z, s.z, r.z, g, h, k);
    return d;
  };
  this.getControlPointsArray = function () {
    var a, b, c = this.points.length, d = [];
    for (a = 0; a < c; a++)
      b = this.points[a], d[a] = [
        b.x,
        b.y,
        b.z
      ];
    return d;
  };
  this.getLength = function (a) {
    var b, c, d, e = b = b = 0, f = new THREE.Vector3(), g = new THREE.Vector3(), h = [], k = 0;
    h[0] = 0;
    a || (a = 100);
    c = this.points.length * a;
    f.copy(this.points[0]);
    for (a = 1; a < c; a++)
      b = a / c, d = this.getPoint(b), g.copy(d), k += g.distanceTo(f), f.copy(d), b *= this.points.length - 1, b = Math.floor(b), b != e && (h[b] = k, e = b);
    h[h.length] = k;
    return {
      chunks: h,
      total: k
    };
  };
  this.reparametrizeByArcLength = function (a) {
    var b, c, d, e, f, g, h = [], k = new THREE.Vector3(), l = this.getLength();
    h.push(k.copy(this.points[0]).clone());
    for (b = 1; b < this.points.length; b++) {
      c = l.chunks[b] - l.chunks[b - 1];
      g = Math.ceil(a * c / l.total);
      e = (b - 1) / (this.points.length - 1);
      f = b / (this.points.length - 1);
      for (c = 1; c < g - 1; c++)
        d = e + 1 / g * c * (f - e), d = this.getPoint(d), h.push(k.copy(d).clone());
      h.push(k.copy(this.points[b]).clone());
    }
    this.points = h;
  };
};
THREE.Triangle = function (a, b, c) {
  this.a = void 0 !== a ? a : new THREE.Vector3();
  this.b = void 0 !== b ? b : new THREE.Vector3();
  this.c = void 0 !== c ? c : new THREE.Vector3();
};
THREE.Triangle.normal = function () {
  var a = new THREE.Vector3();
  return function (b, c, d, e) {
    e = e || new THREE.Vector3();
    e.subVectors(d, c);
    a.subVectors(b, c);
    e.cross(a);
    b = e.lengthSq();
    return 0 < b ? e.multiplyScalar(1 / Math.sqrt(b)) : e.set(0, 0, 0);
  };
}();
THREE.Triangle.barycoordFromPoint = function () {
  var a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Vector3();
  return function (d, e, f, g, h) {
    a.subVectors(g, e);
    b.subVectors(f, e);
    c.subVectors(d, e);
    d = a.dot(a);
    e = a.dot(b);
    f = a.dot(c);
    var k = b.dot(b);
    g = b.dot(c);
    var l = d * k - e * e;
    h = h || new THREE.Vector3();
    if (0 == l)
      return h.set(-2, -1, -1);
    l = 1 / l;
    k = (k * f - e * g) * l;
    d = (d * g - e * f) * l;
    return h.set(1 - k - d, d, k);
  };
}();
THREE.Triangle.containsPoint = function () {
  var a = new THREE.Vector3();
  return function (b, c, d, e) {
    b = THREE.Triangle.barycoordFromPoint(b, c, d, e, a);
    return 0 <= b.x && 0 <= b.y && 1 >= b.x + b.y;
  };
}();
THREE.Triangle.prototype = {
  constructor: THREE.Triangle,
  set: function (a, b, c) {
    this.a.copy(a);
    this.b.copy(b);
    this.c.copy(c);
    return this;
  },
  setFromPointsAndIndices: function (a, b, c, d) {
    this.a.copy(a[b]);
    this.b.copy(a[c]);
    this.c.copy(a[d]);
    return this;
  },
  copy: function (a) {
    this.a.copy(a.a);
    this.b.copy(a.b);
    this.c.copy(a.c);
    return this;
  },
  area: function () {
    var a = new THREE.Vector3(), b = new THREE.Vector3();
    return function () {
      a.subVectors(this.c, this.b);
      b.subVectors(this.a, this.b);
      return 0.5 * a.cross(b).length();
    };
  }(),
  midpoint: function (a) {
    return (a || new THREE.Vector3()).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  },
  normal: function (a) {
    return THREE.Triangle.normal(this.a, this.b, this.c, a);
  },
  plane: function (a) {
    return (a || new THREE.Plane()).setFromCoplanarPoints(this.a, this.b, this.c);
  },
  barycoordFromPoint: function (a, b) {
    return THREE.Triangle.barycoordFromPoint(a, this.a, this.b, this.c, b);
  },
  containsPoint: function (a) {
    return THREE.Triangle.containsPoint(a, this.a, this.b, this.c);
  },
  equals: function (a) {
    return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c);
  },
  clone: function () {
    return new THREE.Triangle().copy(this);
  }
};
THREE.Vertex = function (a) {
  console.warn('THREE.Vertex has been DEPRECATED. Use THREE.Vector3 instead.');
  return a;
};
THREE.UV = function (a, b) {
  console.warn('THREE.UV has been DEPRECATED. Use THREE.Vector2 instead.');
  return new THREE.Vector2(a, b);
};
THREE.Clock = function (a) {
  this.autoStart = void 0 !== a ? a : !0;
  this.elapsedTime = this.oldTime = this.startTime = 0;
  this.running = !1;
};
THREE.Clock.prototype = {
  constructor: THREE.Clock,
  start: function () {
    this.oldTime = this.startTime = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now();
    this.running = !0;
  },
  stop: function () {
    this.getElapsedTime();
    this.running = !1;
  },
  getElapsedTime: function () {
    this.getDelta();
    return this.elapsedTime;
  },
  getDelta: function () {
    var a = 0;
    this.autoStart && !this.running && this.start();
    if (this.running) {
      var b = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now(), a = 0.001 * (b - this.oldTime);
      this.oldTime = b;
      this.elapsedTime += a;
    }
    return a;
  }
};
THREE.EventDispatcher = function () {
};
THREE.EventDispatcher.prototype = {
  constructor: THREE.EventDispatcher,
  apply: function (a) {
    a.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
    a.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
    a.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
    a.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;
  },
  addEventListener: function (a, b) {
    void 0 === this._listeners && (this._listeners = {});
    var c = this._listeners;
    void 0 === c[a] && (c[a] = []);
    -1 === c[a].indexOf(b) && c[a].push(b);
  },
  hasEventListener: function (a, b) {
    if (void 0 === this._listeners)
      return !1;
    var c = this._listeners;
    return void 0 !== c[a] && -1 !== c[a].indexOf(b) ? !0 : !1;
  },
  removeEventListener: function (a, b) {
    if (void 0 !== this._listeners) {
      var c = this._listeners[a];
      if (void 0 !== c) {
        var d = c.indexOf(b);
        -1 !== d && c.splice(d, 1);
      }
    }
  },
  dispatchEvent: function () {
    var a = [];
    return function (b) {
      if (void 0 !== this._listeners) {
        var c = this._listeners[b.type];
        if (void 0 !== c) {
          b.target = this;
          for (var d = c.length, e = 0; e < d; e++)
            a[e] = c[e];
          for (e = 0; e < d; e++)
            a[e].call(this, b);
        }
      }
    };
  }()
};
(function (a) {
  a.Raycaster = function (b, c, d, e) {
    this.ray = new a.Ray(b, c);
    this.near = d || 0;
    this.far = e || Infinity;
  };
  var b = new a.Sphere(), c = new a.Ray();
  new a.Plane();
  new a.Vector3();
  var d = new a.Vector3(), e = new a.Matrix4(), f = function (a, b) {
      return a.distance - b.distance;
    }, g = new a.Vector3(), h = new a.Vector3(), k = new a.Vector3(), l = function (f, n, q) {
      if (f instanceof a.Sprite) {
        d.setFromMatrixPosition(f.matrixWorld);
        var u = n.ray.distanceToPoint(d);
        if (u > f.scale.x)
          return q;
        q.push({
          distance: u,
          point: f.position,
          face: null,
          object: f
        });
      } else if (f instanceof a.LOD)
        d.setFromMatrixPosition(f.matrixWorld), u = n.ray.origin.distanceTo(d), l(f.getObjectForDistance(u), n, q);
      else if (f instanceof a.Mesh) {
        var p = f.geometry;
        null === p.boundingSphere && p.computeBoundingSphere();
        b.copy(p.boundingSphere);
        b.applyMatrix4(f.matrixWorld);
        if (!1 === n.ray.isIntersectionSphere(b))
          return q;
        e.getInverse(f.matrixWorld);
        c.copy(n.ray).applyMatrix4(e);
        if (null !== p.boundingBox && !1 === c.isIntersectionBox(p.boundingBox))
          return q;
        if (p instanceof a.BufferGeometry) {
          var v = f.material;
          if (void 0 === v)
            return q;
          var w = p.attributes, t, x, z = n.precision;
          if (void 0 !== w.index)
            for (var B = p.offsets, E = w.index.array, H = w.position.array, D = 0, G = B.length; D < G; ++D)
              for (var w = B[D].start, I = B[D].index, p = w, O = w + B[D].count; p < O; p += 3) {
                w = I + E[p];
                t = I + E[p + 1];
                x = I + E[p + 2];
                g.set(H[3 * w], H[3 * w + 1], H[3 * w + 2]);
                h.set(H[3 * t], H[3 * t + 1], H[3 * t + 2]);
                k.set(H[3 * x], H[3 * x + 1], H[3 * x + 2]);
                var K = v.side === a.BackSide ? c.intersectTriangle(k, h, g, !0) : c.intersectTriangle(g, h, k, v.side !== a.DoubleSide);
                null !== K && (K.applyMatrix4(f.matrixWorld), u = n.ray.origin.distanceTo(K), u < z || u < n.near || u > n.far || q.push({
                  distance: u,
                  point: K,
                  indices: [
                    w,
                    t,
                    x
                  ],
                  face: null,
                  faceIndex: null,
                  object: f
                }));
              }
          else
            for (H = w.position.array, p = 0, O = w.position.array.length; p < O; p += 3)
              w = p, t = p + 1, x = p + 2, g.set(H[3 * w], H[3 * w + 1], H[3 * w + 2]), h.set(H[3 * t], H[3 * t + 1], H[3 * t + 2]), k.set(H[3 * x], H[3 * x + 1], H[3 * x + 2]), K = v.side === a.BackSide ? c.intersectTriangle(k, h, g, !0) : c.intersectTriangle(g, h, k, v.side !== a.DoubleSide), null !== K && (K.applyMatrix4(f.matrixWorld), u = n.ray.origin.distanceTo(K), u < z || u < n.near || u > n.far || q.push({
                distance: u,
                point: K,
                indices: [
                  w,
                  t,
                  x
                ],
                face: null,
                faceIndex: null,
                object: f
              }));
        } else if (p instanceof a.Geometry)
          for (E = f.material instanceof a.MeshFaceMaterial, H = !0 === E ? f.material.materials : null, z = n.precision, B = p.vertices, D = 0, G = p.faces.length; D < G; D++)
            if (I = p.faces[D], v = !0 === E ? H[I.materialIndex] : f.material, void 0 !== v) {
              w = B[I.a];
              t = B[I.b];
              x = B[I.c];
              if (!0 === v.morphTargets) {
                u = p.morphTargets;
                K = f.morphTargetInfluences;
                g.set(0, 0, 0);
                h.set(0, 0, 0);
                k.set(0, 0, 0);
                for (var O = 0, y = u.length; O < y; O++) {
                  var F = K[O];
                  if (0 !== F) {
                    var C = u[O].vertices;
                    g.x += (C[I.a].x - w.x) * F;
                    g.y += (C[I.a].y - w.y) * F;
                    g.z += (C[I.a].z - w.z) * F;
                    h.x += (C[I.b].x - t.x) * F;
                    h.y += (C[I.b].y - t.y) * F;
                    h.z += (C[I.b].z - t.z) * F;
                    k.x += (C[I.c].x - x.x) * F;
                    k.y += (C[I.c].y - x.y) * F;
                    k.z += (C[I.c].z - x.z) * F;
                  }
                }
                g.add(w);
                h.add(t);
                k.add(x);
                w = g;
                t = h;
                x = k;
              }
              K = v.side === a.BackSide ? c.intersectTriangle(x, t, w, !0) : c.intersectTriangle(w, t, x, v.side !== a.DoubleSide);
              null !== K && (K.applyMatrix4(f.matrixWorld), u = n.ray.origin.distanceTo(K), u < z || u < n.near || u > n.far || q.push({
                distance: u,
                point: K,
                face: I,
                faceIndex: D,
                object: f
              }));
            }
      } else if (f instanceof a.Line) {
        z = n.linePrecision;
        v = z * z;
        p = f.geometry;
        null === p.boundingSphere && p.computeBoundingSphere();
        b.copy(p.boundingSphere);
        b.applyMatrix4(f.matrixWorld);
        if (!1 === n.ray.isIntersectionSphere(b))
          return q;
        e.getInverse(f.matrixWorld);
        c.copy(n.ray).applyMatrix4(e);
        if (p instanceof a.Geometry)
          for (B = p.vertices, z = B.length, w = new a.Vector3(), t = new a.Vector3(), x = f.type === a.LineStrip ? 1 : 2, p = 0; p < z - 1; p += x)
            c.distanceSqToSegment(B[p], B[p + 1], t, w) > v || (u = c.origin.distanceTo(t), u < n.near || u > n.far || q.push({
              distance: u,
              point: w.clone().applyMatrix4(f.matrixWorld),
              face: null,
              faceIndex: null,
              object: f
            }));
      }
    }, n = function (a, b, c) {
      a = a.getDescendants();
      for (var d = 0, e = a.length; d < e; d++)
        l(a[d], b, c);
    };
  a.Raycaster.prototype.precision = 0.0001;
  a.Raycaster.prototype.linePrecision = 1;
  a.Raycaster.prototype.set = function (a, b) {
    this.ray.set(a, b);
  };
  a.Raycaster.prototype.intersectObject = function (a, b) {
    var c = [];
    !0 === b && n(a, this, c);
    l(a, this, c);
    c.sort(f);
    return c;
  };
  a.Raycaster.prototype.intersectObjects = function (a, b) {
    for (var c = [], d = 0, e = a.length; d < e; d++)
      l(a[d], this, c), !0 === b && n(a[d], this, c);
    c.sort(f);
    return c;
  };
}(THREE));
THREE.Object3D = function () {
  this.id = THREE.Object3DIdCount++;
  this.uuid = THREE.Math.generateUUID();
  this.name = '';
  this.parent = void 0;
  this.children = [];
  this.up = new THREE.Vector3(0, 1, 0);
  this.position = new THREE.Vector3();
  this._rotation = new THREE.Euler();
  this._quaternion = new THREE.Quaternion();
  this.scale = new THREE.Vector3(1, 1, 1);
  this._rotation._quaternion = this.quaternion;
  this._quaternion._euler = this.rotation;
  this.renderDepth = null;
  this.rotationAutoUpdate = !0;
  this.matrix = new THREE.Matrix4();
  this.matrixWorld = new THREE.Matrix4();
  this.visible = this.matrixWorldNeedsUpdate = this.matrixAutoUpdate = !0;
  this.receiveShadow = this.castShadow = !1;
  this.frustumCulled = !0;
  this.userData = {};
};
THREE.Object3D.prototype = {
  constructor: THREE.Object3D,
  get rotation() {
    return this._rotation;
  },
  set rotation(a) {
    this._rotation = a;
    this._rotation._quaternion = this._quaternion;
    this._quaternion._euler = this._rotation;
    this._rotation._updateQuaternion();
  },
  get quaternion() {
    return this._quaternion;
  },
  set quaternion(a) {
    this._quaternion = a;
    this._quaternion._euler = this._rotation;
    this._rotation._quaternion = this._quaternion;
    this._quaternion._updateEuler();
  },
  get eulerOrder() {
    console.warn('DEPRECATED: Object3D\'s .eulerOrder has been moved to Object3D\'s .rotation.order.');
    return this.rotation.order;
  },
  set eulerOrder(a) {
    console.warn('DEPRECATED: Object3D\'s .eulerOrder has been moved to Object3D\'s .rotation.order.');
    this.rotation.order = a;
  },
  get useQuaternion() {
    console.warn('DEPRECATED: Object3D\'s .useQuaternion has been removed. The library now uses quaternions by default.');
  },
  set useQuaternion(a) {
    console.warn('DEPRECATED: Object3D\'s .useQuaternion has been removed. The library now uses quaternions by default.');
  },
  applyMatrix: function (a) {
    this.matrix.multiplyMatrices(a, this.matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  },
  setRotationFromAxisAngle: function (a, b) {
    this.quaternion.setFromAxisAngle(a, b);
  },
  setRotationFromEuler: function (a) {
    this.quaternion.setFromEuler(a, !0);
  },
  setRotationFromMatrix: function (a) {
    this.quaternion.setFromRotationMatrix(a);
  },
  setRotationFromQuaternion: function (a) {
    this.quaternion.copy(a);
  },
  rotateOnAxis: function () {
    var a = new THREE.Quaternion();
    return function (b, c) {
      a.setFromAxisAngle(b, c);
      this.quaternion.multiply(a);
      return this;
    };
  }(),
  rotateX: function () {
    var a = new THREE.Vector3(1, 0, 0);
    return function (b) {
      return this.rotateOnAxis(a, b);
    };
  }(),
  rotateY: function () {
    var a = new THREE.Vector3(0, 1, 0);
    return function (b) {
      return this.rotateOnAxis(a, b);
    };
  }(),
  rotateZ: function () {
    var a = new THREE.Vector3(0, 0, 1);
    return function (b) {
      return this.rotateOnAxis(a, b);
    };
  }(),
  translateOnAxis: function () {
    var a = new THREE.Vector3();
    return function (b, c) {
      a.copy(b);
      a.applyQuaternion(this.quaternion);
      this.position.add(a.multiplyScalar(c));
      return this;
    };
  }(),
  translate: function (a, b) {
    console.warn('DEPRECATED: Object3D\'s .translate() has been removed. Use .translateOnAxis( axis, distance ) instead. Note args have been changed.');
    return this.translateOnAxis(b, a);
  },
  translateX: function () {
    var a = new THREE.Vector3(1, 0, 0);
    return function (b) {
      return this.translateOnAxis(a, b);
    };
  }(),
  translateY: function () {
    var a = new THREE.Vector3(0, 1, 0);
    return function (b) {
      return this.translateOnAxis(a, b);
    };
  }(),
  translateZ: function () {
    var a = new THREE.Vector3(0, 0, 1);
    return function (b) {
      return this.translateOnAxis(a, b);
    };
  }(),
  localToWorld: function (a) {
    return a.applyMatrix4(this.matrixWorld);
  },
  worldToLocal: function () {
    var a = new THREE.Matrix4();
    return function (b) {
      return b.applyMatrix4(a.getInverse(this.matrixWorld));
    };
  }(),
  lookAt: function () {
    var a = new THREE.Matrix4();
    return function (b) {
      a.lookAt(b, this.position, this.up);
      this.quaternion.setFromRotationMatrix(a);
    };
  }(),
  add: function (a) {
    if (a === this)
      console.warn('THREE.Object3D.add: An object can\'t be added as a child of itself.');
    else if (a instanceof THREE.Object3D) {
      void 0 !== a.parent && a.parent.remove(a);
      a.parent = this;
      a.dispatchEvent({ type: 'added' });
      this.children.push(a);
      for (var b = this; void 0 !== b.parent;)
        b = b.parent;
      void 0 !== b && b instanceof THREE.Scene && b.__addObject(a);
    }
  },
  remove: function (a) {
    var b = this.children.indexOf(a);
    if (-1 !== b) {
      a.parent = void 0;
      a.dispatchEvent({ type: 'removed' });
      this.children.splice(b, 1);
      for (b = this; void 0 !== b.parent;)
        b = b.parent;
      void 0 !== b && b instanceof THREE.Scene && b.__removeObject(a);
    }
  },
  traverse: function (a) {
    a(this);
    for (var b = 0, c = this.children.length; b < c; b++)
      this.children[b].traverse(a);
  },
  getObjectById: function (a, b) {
    for (var c = 0, d = this.children.length; c < d; c++) {
      var e = this.children[c];
      if (e.id === a || !0 === b && (e = e.getObjectById(a, b), void 0 !== e))
        return e;
    }
  },
  getObjectByName: function (a, b) {
    for (var c = 0, d = this.children.length; c < d; c++) {
      var e = this.children[c];
      if (e.name === a || !0 === b && (e = e.getObjectByName(a, b), void 0 !== e))
        return e;
    }
  },
  getChildByName: function (a, b) {
    console.warn('DEPRECATED: Object3D\'s .getChildByName() has been renamed to .getObjectByName().');
    return this.getObjectByName(a, b);
  },
  getDescendants: function (a) {
    void 0 === a && (a = []);
    Array.prototype.push.apply(a, this.children);
    for (var b = 0, c = this.children.length; b < c; b++)
      this.children[b].getDescendants(a);
    return a;
  },
  updateMatrix: function () {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = !0;
  },
  updateMatrixWorld: function (a) {
    !0 === this.matrixAutoUpdate && this.updateMatrix();
    if (!0 === this.matrixWorldNeedsUpdate || !0 === a)
      void 0 === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, a = !0;
    for (var b = 0, c = this.children.length; b < c; b++)
      this.children[b].updateMatrixWorld(a);
  },
  clone: function (a, b) {
    void 0 === a && (a = new THREE.Object3D());
    void 0 === b && (b = !0);
    a.name = this.name;
    a.up.copy(this.up);
    a.position.copy(this.position);
    a.quaternion.copy(this.quaternion);
    a.scale.copy(this.scale);
    a.renderDepth = this.renderDepth;
    a.rotationAutoUpdate = this.rotationAutoUpdate;
    a.matrix.copy(this.matrix);
    a.matrixWorld.copy(this.matrixWorld);
    a.matrixAutoUpdate = this.matrixAutoUpdate;
    a.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;
    a.visible = this.visible;
    a.castShadow = this.castShadow;
    a.receiveShadow = this.receiveShadow;
    a.frustumCulled = this.frustumCulled;
    a.userData = JSON.parse(JSON.stringify(this.userData));
    if (!0 === b)
      for (var c = 0; c < this.children.length; c++)
        a.add(this.children[c].clone());
    return a;
  }
};
THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype);
THREE.Object3DIdCount = 0;
THREE.Projector = function () {
  function a() {
    if (n === r) {
      var a = new THREE.RenderableVertex();
      s.push(a);
      r++;
      n++;
      return a;
    }
    return s[n++];
  }
  function b() {
    if (u === v) {
      var a = new THREE.RenderableFace();
      p.push(a);
      v++;
      u++;
      return a;
    }
    return p[u++];
  }
  function c() {
    if (t === z) {
      var a = new THREE.RenderableLine();
      x.push(a);
      z++;
      t++;
      return a;
    }
    return x[t++];
  }
  function d(a, b) {
    return a.z !== b.z ? b.z - a.z : a.id !== b.id ? a.id - b.id : 0;
  }
  function e(a, b) {
    var c = 0, d = 1, e = a.z + a.w, f = b.z + b.w, g = -a.z + a.w, h = -b.z + b.w;
    if (0 <= e && 0 <= f && 0 <= g && 0 <= h)
      return !0;
    if (0 > e && 0 > f || 0 > g && 0 > h)
      return !1;
    0 > e ? c = Math.max(c, e / (e - f)) : 0 > f && (d = Math.min(d, e / (e - f)));
    0 > g ? c = Math.max(c, g / (g - h)) : 0 > h && (d = Math.min(d, g / (g - h)));
    if (d < c)
      return !1;
    a.lerp(b, c);
    b.lerp(a, 1 - d);
    return !0;
  }
  var f, g, h = [], k = 0, l, n, s = [], r = 0, q, u, p = [], v = 0, w, t, x = [], z = 0, B, E, H = [], D = 0, G = {
      objects: [],
      lights: [],
      elements: []
    }, I = new THREE.Vector3(), O = new THREE.Vector3(), K = new THREE.Vector3(), y = new THREE.Vector3(), F = new THREE.Vector4(), C = new THREE.Box3(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1)), A = new THREE.Box3(), L = Array(3), Q = new THREE.Matrix4(), Y = new THREE.Matrix4(), R, fa = new THREE.Matrix4(), V = new THREE.Matrix3(), ga = new THREE.Frustum(), J = new THREE.Vector4(), da = new THREE.Vector4();
  this.projectVector = function (a, b) {
    b.matrixWorldInverse.getInverse(b.matrixWorld);
    Y.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse);
    return a.applyProjection(Y);
  };
  this.unprojectVector = function () {
    var a = new THREE.Matrix4();
    return function (b, c) {
      a.getInverse(c.projectionMatrix);
      Y.multiplyMatrices(c.matrixWorld, a);
      return b.applyProjection(Y);
    };
  }();
  this.pickingRay = function (a, b) {
    a.z = -1;
    var c = new THREE.Vector3(a.x, a.y, 1);
    this.unprojectVector(a, b);
    this.unprojectVector(c, b);
    c.sub(a).normalize();
    return new THREE.Raycaster(a, c);
  };
  var W = function (a) {
      if (!1 !== a.visible) {
        if (a instanceof THREE.Light)
          G.lights.push(a);
        else if (a instanceof THREE.Mesh || a instanceof THREE.Line || a instanceof THREE.Sprite)
          if (!1 === a.frustumCulled || !0 === ga.intersectsObject(a)) {
            if (g === k) {
              var b = new THREE.RenderableObject();
              h.push(b);
              k++;
              g++;
              f = b;
            } else
              f = h[g++];
            f.id = a.id;
            f.object = a;
            null !== a.renderDepth ? f.z = a.renderDepth : (y.setFromMatrixPosition(a.matrixWorld), y.applyProjection(Y), f.z = y.z);
            G.objects.push(f);
          }
        for (var b = 0, c = a.children.length; b < c; b++)
          W(a.children[b]);
      }
    }, N = new function () {
      var d = [], e = null, f = new THREE.Matrix3(), g = function (a) {
          var b = a.positionWorld, c = a.positionScreen;
          b.copy(a.position).applyMatrix4(R);
          c.copy(b).applyMatrix4(Y);
          b = 1 / c.w;
          c.x *= b;
          c.y *= b;
          c.z *= b;
          a.visible = -1 <= c.x && 1 >= c.x && -1 <= c.y && 1 >= c.y && -1 <= c.z && 1 >= c.z;
        }, h = function (a, b, c) {
          L[0] = a.positionScreen;
          L[1] = b.positionScreen;
          L[2] = c.positionScreen;
          return !0 === a.visible || !0 === b.visible || !0 === c.visible || C.isIntersectionBox(A.setFromPoints(L)) ? 0 > (c.positionScreen.x - a.positionScreen.x) * (b.positionScreen.y - a.positionScreen.y) - (c.positionScreen.y - a.positionScreen.y) * (b.positionScreen.x - a.positionScreen.x) : !1;
        };
      return {
        setObject: function (a) {
          e = a;
          f.getNormalMatrix(e.matrixWorld);
          d.length = 0;
        },
        projectVertex: g,
        checkTriangleVisibility: h,
        pushVertex: function (b, c, d) {
          l = a();
          l.position.set(b, c, d);
          g(l);
        },
        pushNormal: function (a, b, c) {
          d.push(a, b, c);
        },
        pushLine: function (a, b) {
          var d = s[a], f = s[b];
          w = c();
          w.id = e.id;
          w.v1.copy(d);
          w.v2.copy(f);
          w.z = (d.positionScreen.z + f.positionScreen.z) / 2;
          w.material = e.material;
          G.elements.push(w);
        },
        pushTriangle: function (a, c, g) {
          var k = s[a], l = s[c], n = s[g];
          if (!0 === h(k, l, n)) {
            q = b();
            q.id = e.id;
            q.v1.copy(k);
            q.v2.copy(l);
            q.v3.copy(n);
            q.z = (k.positionScreen.z + l.positionScreen.z + n.positionScreen.z) / 3;
            for (k = 0; 3 > k; k++)
              l = 3 * arguments[k], n = q.vertexNormalsModel[k], n.set(d[l + 0], d[l + 1], d[l + 2]), n.applyMatrix3(f).normalize();
            q.vertexNormalsLength = 3;
            q.material = e.material;
            G.elements.push(q);
          }
        }
      };
    }();
  this.projectScene = function (f, h, k, l) {
    var p, r, v, x, y, z, C, L, A;
    E = t = u = 0;
    G.elements.length = 0;
    !0 === f.autoUpdate && f.updateMatrixWorld();
    void 0 === h.parent && h.updateMatrixWorld();
    Q.copy(h.matrixWorldInverse.getInverse(h.matrixWorld));
    Y.multiplyMatrices(h.projectionMatrix, Q);
    ga.setFromMatrix(Y);
    g = 0;
    G.objects.length = 0;
    G.lights.length = 0;
    W(f);
    !0 === k && G.objects.sort(d);
    f = 0;
    for (k = G.objects.length; f < k; f++)
      if (p = G.objects[f].object, r = p.geometry, N.setObject(p), R = p.matrixWorld, n = 0, p instanceof THREE.Mesh)
        if (r instanceof THREE.BufferGeometry) {
          if (z = r.attributes, p = r.offsets, void 0 !== z.position) {
            L = z.position.array;
            r = 0;
            for (x = L.length; r < x; r += 3)
              N.pushVertex(L[r], L[r + 1], L[r + 2]);
            A = z.normal.array;
            r = 0;
            for (x = A.length; r < x; r += 3)
              N.pushNormal(A[r], A[r + 1], A[r + 2]);
            if (void 0 !== z.index)
              if (z = z.index.array, 0 < p.length)
                for (f = 0; f < p.length; f++)
                  for (x = p[f], L = x.index, r = x.start, x = x.start + x.count; r < x; r += 3)
                    N.pushTriangle(z[r] + L, z[r + 1] + L, z[r + 2] + L);
              else
                for (r = 0, x = z.length; r < x; r += 3)
                  N.pushTriangle(z[r], z[r + 1], z[r + 2]);
            else
              for (r = 0, x = L.length / 3; r < x; r += 3)
                N.pushTriangle(r, r + 1, r + 2);
          }
        } else {
          if (r instanceof THREE.Geometry) {
            v = r.vertices;
            x = r.faces;
            z = r.faceVertexUvs;
            V.getNormalMatrix(R);
            L = p.material instanceof THREE.MeshFaceMaterial;
            A = !0 === L ? p.material : null;
            for (var ka = 0, Ka = v.length; ka < Ka; ka++) {
              var la = v[ka];
              N.pushVertex(la.x, la.y, la.z);
            }
            ka = 0;
            for (Ka = x.length; ka < Ka; ka++) {
              v = x[ka];
              var Ba = !0 === L ? A.materials[v.materialIndex] : p.material;
              if (void 0 !== Ba) {
                C = Ba.side;
                var la = s[v.a], Ia = s[v.b], ma = s[v.c];
                if (!0 === Ba.morphTargets) {
                  y = r.morphTargets;
                  var Ca = p.morphTargetInfluences, ba = la.position, wa = Ia.position, xa = ma.position;
                  I.set(0, 0, 0);
                  O.set(0, 0, 0);
                  K.set(0, 0, 0);
                  for (var Da = 0, Wa = y.length; Da < Wa; Da++) {
                    var La = Ca[Da];
                    if (0 !== La) {
                      var Ea = y[Da].vertices;
                      I.x += (Ea[v.a].x - ba.x) * La;
                      I.y += (Ea[v.a].y - ba.y) * La;
                      I.z += (Ea[v.a].z - ba.z) * La;
                      O.x += (Ea[v.b].x - wa.x) * La;
                      O.y += (Ea[v.b].y - wa.y) * La;
                      O.z += (Ea[v.b].z - wa.z) * La;
                      K.x += (Ea[v.c].x - xa.x) * La;
                      K.y += (Ea[v.c].y - xa.y) * La;
                      K.z += (Ea[v.c].z - xa.z) * La;
                    }
                  }
                  la.position.add(I);
                  Ia.position.add(O);
                  ma.position.add(K);
                  N.projectVertex(la);
                  N.projectVertex(Ia);
                  N.projectVertex(ma);
                }
                Ca = N.checkTriangleVisibility(la, Ia, ma);
                if (!(!1 === Ca && C === THREE.FrontSide || !0 === Ca && C === THREE.BackSide)) {
                  q = b();
                  q.id = p.id;
                  q.v1.copy(la);
                  q.v2.copy(Ia);
                  q.v3.copy(ma);
                  q.normalModel.copy(v.normal);
                  !1 !== Ca || C !== THREE.BackSide && C !== THREE.DoubleSide || q.normalModel.negate();
                  q.normalModel.applyMatrix3(V).normalize();
                  q.centroidModel.copy(v.centroid).applyMatrix4(R);
                  y = v.vertexNormals;
                  ba = 0;
                  for (wa = Math.min(y.length, 3); ba < wa; ba++)
                    xa = q.vertexNormalsModel[ba], xa.copy(y[ba]), !1 !== Ca || C !== THREE.BackSide && C !== THREE.DoubleSide || xa.negate(), xa.applyMatrix3(V).normalize();
                  q.vertexNormalsLength = y.length;
                  y = 0;
                  for (Ca = Math.min(z.length, 3); y < Ca; y++)
                    if (C = z[y][ka], void 0 !== C)
                      for (ba = 0, wa = C.length; ba < wa; ba++)
                        q.uvs[y][ba] = C[ba];
                  q.color = v.color;
                  q.material = Ba;
                  q.z = (la.positionScreen.z + Ia.positionScreen.z + ma.positionScreen.z) / 3;
                  G.elements.push(q);
                }
              }
            }
          }
        }
      else if (p instanceof THREE.Line)
        if (r instanceof THREE.BufferGeometry) {
          if (z = r.attributes, void 0 !== z.position) {
            L = z.position.array;
            r = 0;
            for (x = L.length; r < x; r += 3)
              N.pushVertex(L[r], L[r + 1], L[r + 2]);
            if (void 0 !== z.index)
              for (z = z.index.array, r = 0, x = z.length; r < x; r += 2)
                N.pushLine(z[r], z[r + 1]);
            else
              for (r = 0, x = L.length / 3 - 1; r < x; r++)
                N.pushLine(r, r + 1);
          }
        } else {
          if (r instanceof THREE.Geometry && (fa.multiplyMatrices(Y, R), v = p.geometry.vertices, 0 !== v.length))
            for (la = a(), la.positionScreen.copy(v[0]).applyMatrix4(fa), r = p.type === THREE.LinePieces ? 2 : 1, ka = 1, Ka = v.length; ka < Ka; ka++)
              la = a(), la.positionScreen.copy(v[ka]).applyMatrix4(fa), 0 < (ka + 1) % r || (Ia = s[n - 2], J.copy(la.positionScreen), da.copy(Ia.positionScreen), !0 === e(J, da) && (J.multiplyScalar(1 / J.w), da.multiplyScalar(1 / da.w), w = c(), w.id = p.id, w.v1.positionScreen.copy(J), w.v2.positionScreen.copy(da), w.z = Math.max(J.z, da.z), w.material = p.material, p.material.vertexColors === THREE.VertexColors && (w.vertexColors[0].copy(p.geometry.colors[ka]), w.vertexColors[1].copy(p.geometry.colors[ka - 1])), G.elements.push(w)));
        }
      else
        p instanceof THREE.Sprite && (F.set(R.elements[12], R.elements[13], R.elements[14], 1), F.applyMatrix4(Y), r = 1 / F.w, F.z *= r, -1 <= F.z && 1 >= F.z && (E === D ? (x = new THREE.RenderableSprite(), H.push(x), D++, E++, B = x) : B = H[E++], B.id = p.id, B.x = F.x * r, B.y = F.y * r, B.z = F.z, B.object = p, B.rotation = p.rotation, B.scale.x = p.scale.x * Math.abs(B.x - (F.x + h.projectionMatrix.elements[0]) / (F.w + h.projectionMatrix.elements[12])), B.scale.y = p.scale.y * Math.abs(B.y - (F.y + h.projectionMatrix.elements[5]) / (F.w + h.projectionMatrix.elements[13])), B.material = p.material, G.elements.push(B)));
    !0 === l && G.elements.sort(d);
    return G;
  };
};
THREE.Face3 = function (a, b, c, d, e, f) {
  this.a = a;
  this.b = b;
  this.c = c;
  this.normal = d instanceof THREE.Vector3 ? d : new THREE.Vector3();
  this.vertexNormals = d instanceof Array ? d : [];
  this.color = e instanceof THREE.Color ? e : new THREE.Color();
  this.vertexColors = e instanceof Array ? e : [];
  this.vertexTangents = [];
  this.materialIndex = void 0 !== f ? f : 0;
  this.centroid = new THREE.Vector3();
};
THREE.Face3.prototype = {
  constructor: THREE.Face3,
  clone: function () {
    var a = new THREE.Face3(this.a, this.b, this.c);
    a.normal.copy(this.normal);
    a.color.copy(this.color);
    a.centroid.copy(this.centroid);
    a.materialIndex = this.materialIndex;
    var b, c;
    b = 0;
    for (c = this.vertexNormals.length; b < c; b++)
      a.vertexNormals[b] = this.vertexNormals[b].clone();
    b = 0;
    for (c = this.vertexColors.length; b < c; b++)
      a.vertexColors[b] = this.vertexColors[b].clone();
    b = 0;
    for (c = this.vertexTangents.length; b < c; b++)
      a.vertexTangents[b] = this.vertexTangents[b].clone();
    return a;
  }
};
THREE.Face4 = function (a, b, c, d, e, f, g) {
  console.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');
  return new THREE.Face3(a, b, c, e, f, g);
};
THREE.BufferGeometry = function () {
  this.id = THREE.GeometryIdCount++;
  this.uuid = THREE.Math.generateUUID();
  this.name = '';
  this.attributes = {};
  this.offsets = [];
  this.boundingSphere = this.boundingBox = null;
};
THREE.BufferGeometry.prototype = {
  constructor: THREE.BufferGeometry,
  addAttribute: function (a, b, c, d) {
    this.attributes[a] = {
      array: new b(c * d),
      itemSize: d
    };
    return this.attributes[a];
  },
  applyMatrix: function (a) {
    var b = this.attributes.position;
    void 0 !== b && (a.multiplyVector3Array(b.array), b.needsUpdate = !0);
    b = this.attributes.normal;
    void 0 !== b && (new THREE.Matrix3().getNormalMatrix(a).multiplyVector3Array(b.array), b.needsUpdate = !0);
  },
  computeBoundingBox: function () {
    null === this.boundingBox && (this.boundingBox = new THREE.Box3());
    var a = this.attributes.position.array;
    if (a) {
      var b = this.boundingBox;
      3 <= a.length && (b.min.x = b.max.x = a[0], b.min.y = b.max.y = a[1], b.min.z = b.max.z = a[2]);
      for (var c = 3, d = a.length; c < d; c += 3) {
        var e = a[c], f = a[c + 1], g = a[c + 2];
        e < b.min.x ? b.min.x = e : e > b.max.x && (b.max.x = e);
        f < b.min.y ? b.min.y = f : f > b.max.y && (b.max.y = f);
        g < b.min.z ? b.min.z = g : g > b.max.z && (b.max.z = g);
      }
    }
    if (void 0 === a || 0 === a.length)
      this.boundingBox.min.set(0, 0, 0), this.boundingBox.max.set(0, 0, 0);
  },
  computeBoundingSphere: function () {
    var a = new THREE.Box3(), b = new THREE.Vector3();
    return function () {
      null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere());
      var c = this.attributes.position.array;
      if (c) {
        a.makeEmpty();
        for (var d = this.boundingSphere.center, e = 0, f = c.length; e < f; e += 3)
          b.set(c[e], c[e + 1], c[e + 2]), a.addPoint(b);
        a.center(d);
        for (var g = 0, e = 0, f = c.length; e < f; e += 3)
          b.set(c[e], c[e + 1], c[e + 2]), g = Math.max(g, d.distanceToSquared(b));
        this.boundingSphere.radius = Math.sqrt(g);
      }
    };
  }(),
  computeVertexNormals: function () {
    if (this.attributes.position) {
      var a, b, c, d;
      a = this.attributes.position.array.length;
      if (void 0 === this.attributes.normal)
        this.attributes.normal = {
          itemSize: 3,
          array: new Float32Array(a)
        };
      else
        for (a = 0, b = this.attributes.normal.array.length; a < b; a++)
          this.attributes.normal.array[a] = 0;
      var e = this.attributes.position.array, f = this.attributes.normal.array, g, h, k, l, n, s, r = new THREE.Vector3(), q = new THREE.Vector3(), u = new THREE.Vector3(), p = new THREE.Vector3(), v = new THREE.Vector3();
      if (this.attributes.index) {
        var w = this.attributes.index.array, t = this.offsets;
        c = 0;
        for (d = t.length; c < d; ++c) {
          b = t[c].start;
          g = t[c].count;
          var x = t[c].index;
          a = b;
          for (b += g; a < b; a += 3)
            g = x + w[a], h = x + w[a + 1], k = x + w[a + 2], l = e[3 * g], n = e[3 * g + 1], s = e[3 * g + 2], r.set(l, n, s), l = e[3 * h], n = e[3 * h + 1], s = e[3 * h + 2], q.set(l, n, s), l = e[3 * k], n = e[3 * k + 1], s = e[3 * k + 2], u.set(l, n, s), p.subVectors(u, q), v.subVectors(r, q), p.cross(v), f[3 * g] += p.x, f[3 * g + 1] += p.y, f[3 * g + 2] += p.z, f[3 * h] += p.x, f[3 * h + 1] += p.y, f[3 * h + 2] += p.z, f[3 * k] += p.x, f[3 * k + 1] += p.y, f[3 * k + 2] += p.z;
        }
      } else
        for (a = 0, b = e.length; a < b; a += 9)
          l = e[a], n = e[a + 1], s = e[a + 2], r.set(l, n, s), l = e[a + 3], n = e[a + 4], s = e[a + 5], q.set(l, n, s), l = e[a + 6], n = e[a + 7], s = e[a + 8], u.set(l, n, s), p.subVectors(u, q), v.subVectors(r, q), p.cross(v), f[a] = p.x, f[a + 1] = p.y, f[a + 2] = p.z, f[a + 3] = p.x, f[a + 4] = p.y, f[a + 5] = p.z, f[a + 6] = p.x, f[a + 7] = p.y, f[a + 8] = p.z;
      this.normalizeNormals();
      this.normalsNeedUpdate = !0;
    }
  },
  normalizeNormals: function () {
    for (var a = this.attributes.normal.array, b, c, d, e = 0, f = a.length; e < f; e += 3)
      b = a[e], c = a[e + 1], d = a[e + 2], b = 1 / Math.sqrt(b * b + c * c + d * d), a[e] *= b, a[e + 1] *= b, a[e + 2] *= b;
  },
  computeTangents: function () {
    function a(a, b, c) {
      s = d[3 * a];
      r = d[3 * a + 1];
      q = d[3 * a + 2];
      u = d[3 * b];
      p = d[3 * b + 1];
      v = d[3 * b + 2];
      w = d[3 * c];
      t = d[3 * c + 1];
      x = d[3 * c + 2];
      z = f[2 * a];
      B = f[2 * a + 1];
      E = f[2 * b];
      H = f[2 * b + 1];
      D = f[2 * c];
      G = f[2 * c + 1];
      I = u - s;
      O = w - s;
      K = p - r;
      y = t - r;
      F = v - q;
      C = x - q;
      A = E - z;
      L = D - z;
      Q = H - B;
      Y = G - B;
      R = 1 / (A * Y - L * Q);
      fa.set((Y * I - Q * O) * R, (Y * K - Q * y) * R, (Y * F - Q * C) * R);
      V.set((A * O - L * I) * R, (A * y - L * K) * R, (A * C - L * F) * R);
      k[a].add(fa);
      k[b].add(fa);
      k[c].add(fa);
      l[a].add(V);
      l[b].add(V);
      l[c].add(V);
    }
    function b(a) {
      S.x = e[3 * a];
      S.y = e[3 * a + 1];
      S.z = e[3 * a + 2];
      $.copy(S);
      ta = k[a];
      T.copy(ta);
      T.sub(S.multiplyScalar(S.dot(ta))).normalize();
      Ja.crossVectors($, ta);
      oa = Ja.dot(l[a]);
      Fa = 0 > oa ? -1 : 1;
      h[4 * a] = T.x;
      h[4 * a + 1] = T.y;
      h[4 * a + 2] = T.z;
      h[4 * a + 3] = Fa;
    }
    if (void 0 === this.attributes.index || void 0 === this.attributes.position || void 0 === this.attributes.normal || void 0 === this.attributes.uv)
      console.warn('Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()');
    else {
      var c = this.attributes.index.array, d = this.attributes.position.array, e = this.attributes.normal.array, f = this.attributes.uv.array, g = d.length / 3;
      void 0 === this.attributes.tangent && (this.attributes.tangent = {
        itemSize: 4,
        array: new Float32Array(4 * g)
      });
      for (var h = this.attributes.tangent.array, k = [], l = [], n = 0; n < g; n++)
        k[n] = new THREE.Vector3(), l[n] = new THREE.Vector3();
      var s, r, q, u, p, v, w, t, x, z, B, E, H, D, G, I, O, K, y, F, C, A, L, Q, Y, R, fa = new THREE.Vector3(), V = new THREE.Vector3(), ga, J, da, W, N, ca = this.offsets, n = 0;
      for (J = ca.length; n < J; ++n) {
        ga = ca[n].start;
        da = ca[n].count;
        var sa = ca[n].index, g = ga;
        for (ga += da; g < ga; g += 3)
          da = sa + c[g], W = sa + c[g + 1], N = sa + c[g + 2], a(da, W, N);
      }
      var T = new THREE.Vector3(), Ja = new THREE.Vector3(), S = new THREE.Vector3(), $ = new THREE.Vector3(), Fa, ta, oa, n = 0;
      for (J = ca.length; n < J; ++n)
        for (ga = ca[n].start, da = ca[n].count, sa = ca[n].index, g = ga, ga += da; g < ga; g += 3)
          da = sa + c[g], W = sa + c[g + 1], N = sa + c[g + 2], b(da), b(W), b(N);
    }
  },
  computeOffsets: function (a) {
    var b = a;
    void 0 === a && (b = 65535);
    Date.now();
    a = this.attributes.index.array;
    for (var c = this.attributes.position.array, d = a.length / 3, e = new Uint16Array(a.length), f = 0, g = 0, h = [{
            start: 0,
            count: 0,
            index: 0
          }], k = h[0], l = 0, n = 0, s = new Int32Array(6), r = new Int32Array(c.length), q = new Int32Array(c.length), u = 0; u < c.length; u++)
      r[u] = -1, q[u] = -1;
    for (c = 0; c < d; c++) {
      for (var p = n = 0; 3 > p; p++)
        u = a[3 * c + p], -1 == r[u] ? (s[2 * p] = u, s[2 * p + 1] = -1, n++) : r[u] < k.index ? (s[2 * p] = u, s[2 * p + 1] = -1, l++) : (s[2 * p] = u, s[2 * p + 1] = r[u]);
      if (g + n > k.index + b)
        for (k = {
            start: f,
            count: 0,
            index: g
          }, h.push(k), n = 0; 6 > n; n += 2)
          p = s[n + 1], -1 < p && p < k.index && (s[n + 1] = -1);
      for (n = 0; 6 > n; n += 2)
        u = s[n], p = s[n + 1], -1 === p && (p = g++), r[u] = p, q[p] = u, e[f++] = p - k.index, k.count++;
    }
    this.reorderBuffers(e, q, g);
    return this.offsets = h;
  },
  reorderBuffers: function (a, b, c) {
    var d = {}, e = [
        Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array
      ], f;
    for (f in this.attributes)
      if ('index' != f)
        for (var g = this.attributes[f].array, h = 0, k = e.length; h < k; h++) {
          var l = e[h];
          if (g instanceof l) {
            d[f] = new l(this.attributes[f].itemSize * c);
            break;
          }
        }
    for (e = 0; e < c; e++)
      for (f in g = b[e], this.attributes)
        if ('index' != f)
          for (var h = this.attributes[f].array, k = this.attributes[f].itemSize, l = d[f], n = 0; n < k; n++)
            l[e * k + n] = h[g * k + n];
    this.attributes.index.array = a;
    for (f in this.attributes)
      'index' != f && (this.attributes[f].array = d[f], this.attributes[f].numItems = this.attributes[f].itemSize * c);
  },
  clone: function () {
    var a = new THREE.BufferGeometry(), b = [
        Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array
      ], c;
    for (c in this.attributes) {
      for (var d = this.attributes[c], e = d.array, f = {
            itemSize: d.itemSize,
            array: null
          }, d = 0, g = b.length; d < g; d++) {
        var h = b[d];
        if (e instanceof h) {
          f.array = new h(e);
          break;
        }
      }
      a.attributes[c] = f;
    }
    d = 0;
    for (g = this.offsets.length; d < g; d++)
      b = this.offsets[d], a.offsets.push({
        start: b.start,
        index: b.index,
        count: b.count
      });
    return a;
  },
  dispose: function () {
    this.dispatchEvent({ type: 'dispose' });
  }
};
THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype);
THREE.Geometry = function () {
  this.id = THREE.GeometryIdCount++;
  this.uuid = THREE.Math.generateUUID();
  this.name = '';
  this.vertices = [];
  this.colors = [];
  this.faces = [];
  this.faceVertexUvs = [[]];
  this.morphTargets = [];
  this.morphColors = [];
  this.morphNormals = [];
  this.skinWeights = [];
  this.skinIndices = [];
  this.lineDistances = [];
  this.boundingSphere = this.boundingBox = null;
  this.hasTangents = !1;
  this.dynamic = !0;
  this.buffersNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.tangentsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.elementsNeedUpdate = this.verticesNeedUpdate = !1;
};
THREE.Geometry.prototype = {
  constructor: THREE.Geometry,
  applyMatrix: function (a) {
    for (var b = new THREE.Matrix3().getNormalMatrix(a), c = 0, d = this.vertices.length; c < d; c++)
      this.vertices[c].applyMatrix4(a);
    c = 0;
    for (d = this.faces.length; c < d; c++) {
      var e = this.faces[c];
      e.normal.applyMatrix3(b).normalize();
      for (var f = 0, g = e.vertexNormals.length; f < g; f++)
        e.vertexNormals[f].applyMatrix3(b).normalize();
      e.centroid.applyMatrix4(a);
    }
    this.boundingBox instanceof THREE.Box3 && this.computeBoundingBox();
    this.boundingSphere instanceof THREE.Sphere && this.computeBoundingSphere();
  },
  computeCentroids: function () {
    var a, b, c;
    a = 0;
    for (b = this.faces.length; a < b; a++)
      c = this.faces[a], c.centroid.set(0, 0, 0), c.centroid.add(this.vertices[c.a]), c.centroid.add(this.vertices[c.b]), c.centroid.add(this.vertices[c.c]), c.centroid.divideScalar(3);
  },
  computeFaceNormals: function () {
    for (var a = new THREE.Vector3(), b = new THREE.Vector3(), c = 0, d = this.faces.length; c < d; c++) {
      var e = this.faces[c], f = this.vertices[e.a], g = this.vertices[e.b];
      a.subVectors(this.vertices[e.c], g);
      b.subVectors(f, g);
      a.cross(b);
      a.normalize();
      e.normal.copy(a);
    }
  },
  computeVertexNormals: function (a) {
    var b, c, d;
    d = Array(this.vertices.length);
    b = 0;
    for (c = this.vertices.length; b < c; b++)
      d[b] = new THREE.Vector3();
    if (a) {
      var e, f, g, h = new THREE.Vector3(), k = new THREE.Vector3();
      new THREE.Vector3();
      new THREE.Vector3();
      new THREE.Vector3();
      a = 0;
      for (b = this.faces.length; a < b; a++)
        c = this.faces[a], e = this.vertices[c.a], f = this.vertices[c.b], g = this.vertices[c.c], h.subVectors(g, f), k.subVectors(e, f), h.cross(k), d[c.a].add(h), d[c.b].add(h), d[c.c].add(h);
    } else
      for (a = 0, b = this.faces.length; a < b; a++)
        c = this.faces[a], d[c.a].add(c.normal), d[c.b].add(c.normal), d[c.c].add(c.normal);
    b = 0;
    for (c = this.vertices.length; b < c; b++)
      d[b].normalize();
    a = 0;
    for (b = this.faces.length; a < b; a++)
      c = this.faces[a], c.vertexNormals[0] = d[c.a].clone(), c.vertexNormals[1] = d[c.b].clone(), c.vertexNormals[2] = d[c.c].clone();
  },
  computeMorphNormals: function () {
    var a, b, c, d, e;
    c = 0;
    for (d = this.faces.length; c < d; c++)
      for (e = this.faces[c], e.__originalFaceNormal ? e.__originalFaceNormal.copy(e.normal) : e.__originalFaceNormal = e.normal.clone(), e.__originalVertexNormals || (e.__originalVertexNormals = []), a = 0, b = e.vertexNormals.length; a < b; a++)
        e.__originalVertexNormals[a] ? e.__originalVertexNormals[a].copy(e.vertexNormals[a]) : e.__originalVertexNormals[a] = e.vertexNormals[a].clone();
    var f = new THREE.Geometry();
    f.faces = this.faces;
    a = 0;
    for (b = this.morphTargets.length; a < b; a++) {
      if (!this.morphNormals[a]) {
        this.morphNormals[a] = {};
        this.morphNormals[a].faceNormals = [];
        this.morphNormals[a].vertexNormals = [];
        e = this.morphNormals[a].faceNormals;
        var g = this.morphNormals[a].vertexNormals, h, k;
        c = 0;
        for (d = this.faces.length; c < d; c++)
          h = new THREE.Vector3(), k = {
            a: new THREE.Vector3(),
            b: new THREE.Vector3(),
            c: new THREE.Vector3()
          }, e.push(h), g.push(k);
      }
      g = this.morphNormals[a];
      f.vertices = this.morphTargets[a].vertices;
      f.computeFaceNormals();
      f.computeVertexNormals();
      c = 0;
      for (d = this.faces.length; c < d; c++)
        e = this.faces[c], h = g.faceNormals[c], k = g.vertexNormals[c], h.copy(e.normal), k.a.copy(e.vertexNormals[0]), k.b.copy(e.vertexNormals[1]), k.c.copy(e.vertexNormals[2]);
    }
    c = 0;
    for (d = this.faces.length; c < d; c++)
      e = this.faces[c], e.normal = e.__originalFaceNormal, e.vertexNormals = e.__originalVertexNormals;
  },
  computeTangents: function () {
    var a, b, c, d, e, f, g, h, k, l, n, s, r, q, u, p, v, w = [], t = [];
    c = new THREE.Vector3();
    var x = new THREE.Vector3(), z = new THREE.Vector3(), B = new THREE.Vector3(), E = new THREE.Vector3();
    a = 0;
    for (b = this.vertices.length; a < b; a++)
      w[a] = new THREE.Vector3(), t[a] = new THREE.Vector3();
    a = 0;
    for (b = this.faces.length; a < b; a++)
      e = this.faces[a], f = this.faceVertexUvs[0][a], d = e.a, v = e.b, e = e.c, g = this.vertices[d], h = this.vertices[v], k = this.vertices[e], l = f[0], n = f[1], s = f[2], f = h.x - g.x, r = k.x - g.x, q = h.y - g.y, u = k.y - g.y, h = h.z - g.z, g = k.z - g.z, k = n.x - l.x, p = s.x - l.x, n = n.y - l.y, l = s.y - l.y, s = 1 / (k * l - p * n), c.set((l * f - n * r) * s, (l * q - n * u) * s, (l * h - n * g) * s), x.set((k * r - p * f) * s, (k * u - p * q) * s, (k * g - p * h) * s), w[d].add(c), w[v].add(c), w[e].add(c), t[d].add(x), t[v].add(x), t[e].add(x);
    x = [
      'a',
      'b',
      'c',
      'd'
    ];
    a = 0;
    for (b = this.faces.length; a < b; a++)
      for (e = this.faces[a], c = 0; c < Math.min(e.vertexNormals.length, 3); c++)
        E.copy(e.vertexNormals[c]), d = e[x[c]], v = w[d], z.copy(v), z.sub(E.multiplyScalar(E.dot(v))).normalize(), B.crossVectors(e.vertexNormals[c], v), d = B.dot(t[d]), d = 0 > d ? -1 : 1, e.vertexTangents[c] = new THREE.Vector4(z.x, z.y, z.z, d);
    this.hasTangents = !0;
  },
  computeLineDistances: function () {
    for (var a = 0, b = this.vertices, c = 0, d = b.length; c < d; c++)
      0 < c && (a += b[c].distanceTo(b[c - 1])), this.lineDistances[c] = a;
  },
  computeBoundingBox: function () {
    null === this.boundingBox && (this.boundingBox = new THREE.Box3());
    this.boundingBox.setFromPoints(this.vertices);
  },
  computeBoundingSphere: function () {
    null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere());
    this.boundingSphere.setFromPoints(this.vertices);
  },
  mergeVertices: function () {
    var a = {}, b = [], c = [], d, e = Math.pow(10, 4), f, g;
    f = 0;
    for (g = this.vertices.length; f < g; f++)
      d = this.vertices[f], d = Math.round(d.x * e) + '_' + Math.round(d.y * e) + '_' + Math.round(d.z * e), void 0 === a[d] ? (a[d] = f, b.push(this.vertices[f]), c[f] = b.length - 1) : c[f] = c[a[d]];
    a = [];
    f = 0;
    for (g = this.faces.length; f < g; f++)
      for (e = this.faces[f], e.a = c[e.a], e.b = c[e.b], e.c = c[e.c], e = [
          e.a,
          e.b,
          e.c
        ], d = 0; 3 > d; d++)
        if (e[d] == e[(d + 1) % 3]) {
          a.push(f);
          break;
        }
    for (f = a.length - 1; 0 <= f; f--)
      for (e = a[f], this.faces.splice(e, 1), c = 0, g = this.faceVertexUvs.length; c < g; c++)
        this.faceVertexUvs[c].splice(e, 1);
    f = this.vertices.length - b.length;
    this.vertices = b;
    return f;
  },
  makeGroups: function () {
    var a = 0;
    return function (b) {
      var c, d, e, f, g = {}, h = this.morphTargets.length, k = this.morphNormals.length;
      this.geometryGroups = {};
      c = 0;
      for (d = this.faces.length; c < d; c++)
        e = this.faces[c], e = b ? e.materialIndex : 0, e in g || (g[e] = {
          hash: e,
          counter: 0
        }), f = g[e].hash + '_' + g[e].counter, f in this.geometryGroups || (this.geometryGroups[f] = {
          faces3: [],
          materialIndex: e,
          vertices: 0,
          numMorphTargets: h,
          numMorphNormals: k
        }), 65535 < this.geometryGroups[f].vertices + 3 && (g[e].counter += 1, f = g[e].hash + '_' + g[e].counter, f in this.geometryGroups || (this.geometryGroups[f] = {
          faces3: [],
          materialIndex: e,
          vertices: 0,
          numMorphTargets: h,
          numMorphNormals: k
        })), this.geometryGroups[f].faces3.push(c), this.geometryGroups[f].vertices += 3;
      this.geometryGroupsList = [];
      for (var l in this.geometryGroups)
        this.geometryGroups[l].id = a++, this.geometryGroupsList.push(this.geometryGroups[l]);
    };
  }(),
  clone: function () {
    for (var a = new THREE.Geometry(), b = this.vertices, c = 0, d = b.length; c < d; c++)
      a.vertices.push(b[c].clone());
    b = this.faces;
    c = 0;
    for (d = b.length; c < d; c++)
      a.faces.push(b[c].clone());
    b = this.faceVertexUvs[0];
    c = 0;
    for (d = b.length; c < d; c++) {
      for (var e = b[c], f = [], g = 0, h = e.length; g < h; g++)
        f.push(new THREE.Vector2(e[g].x, e[g].y));
      a.faceVertexUvs[0].push(f);
    }
    return a;
  },
  dispose: function () {
    this.dispatchEvent({ type: 'dispose' });
  }
};
THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype);
THREE.GeometryIdCount = 0;
THREE.Geometry2 = function (a) {
  THREE.BufferGeometry.call(this);
  this.vertices = this.addAttribute('position', Float32Array, a, 3).array;
  this.normals = this.addAttribute('normal', Float32Array, a, 3).array;
  this.uvs = this.addAttribute('uv', Float32Array, a, 2).array;
  this.boundingSphere = this.boundingBox = null;
};
THREE.Geometry2.prototype = Object.create(THREE.BufferGeometry.prototype);
THREE.Camera = function () {
  THREE.Object3D.call(this);
  this.matrixWorldInverse = new THREE.Matrix4();
  this.projectionMatrix = new THREE.Matrix4();
};
THREE.Camera.prototype = Object.create(THREE.Object3D.prototype);
THREE.Camera.prototype.lookAt = function () {
  var a = new THREE.Matrix4();
  return function (b) {
    a.lookAt(this.position, b, this.up);
    this.quaternion.setFromRotationMatrix(a);
  };
}();
THREE.Camera.prototype.clone = function (a) {
  void 0 === a && (a = new THREE.Camera());
  THREE.Object3D.prototype.clone.call(this, a);
  a.matrixWorldInverse.copy(this.matrixWorldInverse);
  a.projectionMatrix.copy(this.projectionMatrix);
  return a;
};
THREE.OrthographicCamera = function (a, b, c, d, e, f) {
  THREE.Camera.call(this);
  this.left = a;
  this.right = b;
  this.top = c;
  this.bottom = d;
  this.near = void 0 !== e ? e : 0.1;
  this.far = void 0 !== f ? f : 2000;
  this.updateProjectionMatrix();
};
THREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype);
THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {
  this.projectionMatrix.makeOrthographic(this.left, this.right, this.top, this.bottom, this.near, this.far);
};
THREE.OrthographicCamera.prototype.clone = function () {
  var a = new THREE.OrthographicCamera();
  THREE.Camera.prototype.clone.call(this, a);
  a.left = this.left;
  a.right = this.right;
  a.top = this.top;
  a.bottom = this.bottom;
  a.near = this.near;
  a.far = this.far;
  return a;
};
THREE.PerspectiveCamera = function (a, b, c, d) {
  THREE.Camera.call(this);
  this.fov = void 0 !== a ? a : 50;
  this.aspect = void 0 !== b ? b : 1;
  this.near = void 0 !== c ? c : 0.1;
  this.far = void 0 !== d ? d : 2000;
  this.updateProjectionMatrix();
};
THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype);
THREE.PerspectiveCamera.prototype.setLens = function (a, b) {
  void 0 === b && (b = 24);
  this.fov = 2 * THREE.Math.radToDeg(Math.atan(b / (2 * a)));
  this.updateProjectionMatrix();
};
THREE.PerspectiveCamera.prototype.setViewOffset = function (a, b, c, d, e, f) {
  this.fullWidth = a;
  this.fullHeight = b;
  this.x = c;
  this.y = d;
  this.width = e;
  this.height = f;
  this.updateProjectionMatrix();
};
THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {
  if (this.fullWidth) {
    var a = this.fullWidth / this.fullHeight, b = Math.tan(THREE.Math.degToRad(0.5 * this.fov)) * this.near, c = -b, d = a * c, a = Math.abs(a * b - d), c = Math.abs(b - c);
    this.projectionMatrix.makeFrustum(d + this.x * a / this.fullWidth, d + (this.x + this.width) * a / this.fullWidth, b - (this.y + this.height) * c / this.fullHeight, b - this.y * c / this.fullHeight, this.near, this.far);
  } else
    this.projectionMatrix.makePerspective(this.fov, this.aspect, this.near, this.far);
};
THREE.PerspectiveCamera.prototype.clone = function () {
  var a = new THREE.PerspectiveCamera();
  THREE.Camera.prototype.clone.call(this, a);
  a.fov = this.fov;
  a.aspect = this.aspect;
  a.near = this.near;
  a.far = this.far;
  return a;
};
THREE.Light = function (a) {
  THREE.Object3D.call(this);
  this.color = new THREE.Color(a);
};
THREE.Light.prototype = Object.create(THREE.Object3D.prototype);
THREE.Light.prototype.clone = function (a) {
  void 0 === a && (a = new THREE.Light());
  THREE.Object3D.prototype.clone.call(this, a);
  a.color.copy(this.color);
  return a;
};
THREE.AmbientLight = function (a) {
  THREE.Light.call(this, a);
};
THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype);
THREE.AmbientLight.prototype.clone = function () {
  var a = new THREE.AmbientLight();
  THREE.Light.prototype.clone.call(this, a);
  return a;
};
THREE.AreaLight = function (a, b) {
  THREE.Light.call(this, a);
  this.normal = new THREE.Vector3(0, -1, 0);
  this.right = new THREE.Vector3(1, 0, 0);
  this.intensity = void 0 !== b ? b : 1;
  this.height = this.width = 1;
  this.constantAttenuation = 1.5;
  this.linearAttenuation = 0.5;
  this.quadraticAttenuation = 0.1;
};
THREE.AreaLight.prototype = Object.create(THREE.Light.prototype);
THREE.DirectionalLight = function (a, b) {
  THREE.Light.call(this, a);
  this.position.set(0, 1, 0);
  this.target = new THREE.Object3D();
  this.intensity = void 0 !== b ? b : 1;
  this.onlyShadow = this.castShadow = !1;
  this.shadowCameraNear = 50;
  this.shadowCameraFar = 5000;
  this.shadowCameraLeft = -500;
  this.shadowCameraTop = this.shadowCameraRight = 500;
  this.shadowCameraBottom = -500;
  this.shadowCameraVisible = !1;
  this.shadowBias = 0;
  this.shadowDarkness = 0.5;
  this.shadowMapHeight = this.shadowMapWidth = 512;
  this.shadowCascade = !1;
  this.shadowCascadeOffset = new THREE.Vector3(0, 0, -1000);
  this.shadowCascadeCount = 2;
  this.shadowCascadeBias = [
    0,
    0,
    0
  ];
  this.shadowCascadeWidth = [
    512,
    512,
    512
  ];
  this.shadowCascadeHeight = [
    512,
    512,
    512
  ];
  this.shadowCascadeNearZ = [
    -1,
    0.99,
    0.998
  ];
  this.shadowCascadeFarZ = [
    0.99,
    0.998,
    1
  ];
  this.shadowCascadeArray = [];
  this.shadowMatrix = this.shadowCamera = this.shadowMapSize = this.shadowMap = null;
};
THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype);
THREE.DirectionalLight.prototype.clone = function () {
  var a = new THREE.DirectionalLight();
  THREE.Light.prototype.clone.call(this, a);
  a.target = this.target.clone();
  a.intensity = this.intensity;
  a.castShadow = this.castShadow;
  a.onlyShadow = this.onlyShadow;
  return a;
};
THREE.HemisphereLight = function (a, b, c) {
  THREE.Light.call(this, a);
  this.position.set(0, 100, 0);
  this.groundColor = new THREE.Color(b);
  this.intensity = void 0 !== c ? c : 1;
};
THREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype);
THREE.HemisphereLight.prototype.clone = function () {
  var a = new THREE.HemisphereLight();
  THREE.Light.prototype.clone.call(this, a);
  a.groundColor.copy(this.groundColor);
  a.intensity = this.intensity;
  return a;
};
THREE.PointLight = function (a, b, c) {
  THREE.Light.call(this, a);
  this.intensity = void 0 !== b ? b : 1;
  this.distance = void 0 !== c ? c : 0;
};
THREE.PointLight.prototype = Object.create(THREE.Light.prototype);
THREE.PointLight.prototype.clone = function () {
  var a = new THREE.PointLight();
  THREE.Light.prototype.clone.call(this, a);
  a.intensity = this.intensity;
  a.distance = this.distance;
  return a;
};
THREE.SpotLight = function (a, b, c, d, e) {
  THREE.Light.call(this, a);
  this.position.set(0, 1, 0);
  this.target = new THREE.Object3D();
  this.intensity = void 0 !== b ? b : 1;
  this.distance = void 0 !== c ? c : 0;
  this.angle = void 0 !== d ? d : Math.PI / 3;
  this.exponent = void 0 !== e ? e : 10;
  this.onlyShadow = this.castShadow = !1;
  this.shadowCameraNear = 50;
  this.shadowCameraFar = 5000;
  this.shadowCameraFov = 50;
  this.shadowCameraVisible = !1;
  this.shadowBias = 0;
  this.shadowDarkness = 0.5;
  this.shadowMapHeight = this.shadowMapWidth = 512;
  this.shadowMatrix = this.shadowCamera = this.shadowMapSize = this.shadowMap = null;
};
THREE.SpotLight.prototype = Object.create(THREE.Light.prototype);
THREE.SpotLight.prototype.clone = function () {
  var a = new THREE.SpotLight();
  THREE.Light.prototype.clone.call(this, a);
  a.target = this.target.clone();
  a.intensity = this.intensity;
  a.distance = this.distance;
  a.angle = this.angle;
  a.exponent = this.exponent;
  a.castShadow = this.castShadow;
  a.onlyShadow = this.onlyShadow;
  return a;
};
THREE.Loader = function (a) {
  this.statusDomElement = (this.showStatus = a) ? THREE.Loader.prototype.addStatusElement() : null;
  this.onLoadStart = function () {
  };
  this.onLoadProgress = function () {
  };
  this.onLoadComplete = function () {
  };
};
THREE.Loader.prototype = {
  constructor: THREE.Loader,
  crossOrigin: void 0,
  addStatusElement: function () {
    var a = document.createElement('div');
    a.style.position = 'absolute';
    a.style.right = '0px';
    a.style.top = '0px';
    a.style.fontSize = '0.8em';
    a.style.textAlign = 'left';
    a.style.background = 'rgba(0,0,0,0.25)';
    a.style.color = '#fff';
    a.style.width = '120px';
    a.style.padding = '0.5em 0.5em 0.5em 0.5em';
    a.style.zIndex = 1000;
    a.innerHTML = 'Loading ...';
    return a;
  },
  updateProgress: function (a) {
    var b = 'Loaded ', b = a.total ? b + ((100 * a.loaded / a.total).toFixed(0) + '%') : b + ((a.loaded / 1000).toFixed(2) + ' KB');
    this.statusDomElement.innerHTML = b;
  },
  extractUrlBase: function (a) {
    a = a.split('/');
    if (1 === a.length)
      return './';
    a.pop();
    return a.join('/') + '/';
  },
  initMaterials: function (a, b) {
    for (var c = [], d = 0; d < a.length; ++d)
      c[d] = THREE.Loader.prototype.createMaterial(a[d], b);
    return c;
  },
  needsTangents: function (a) {
    for (var b = 0, c = a.length; b < c; b++)
      if (a[b] instanceof THREE.ShaderMaterial)
        return !0;
    return !1;
  },
  createMaterial: function (a, b) {
    function c(a) {
      a = Math.log(a) / Math.LN2;
      return Math.floor(a) == a;
    }
    function d(a) {
      a = Math.log(a) / Math.LN2;
      return Math.pow(2, Math.round(a));
    }
    function e(a, b) {
      var e = new Image();
      e.onload = function () {
        if (c(this.width) && c(this.height))
          a.image = this;
        else {
          var b = d(this.width), e = d(this.height);
          a.image.width = b;
          a.image.height = e;
          a.image.getContext('2d').drawImage(this, 0, 0, b, e);
        }
        a.needsUpdate = !0;
      };
      void 0 !== h.crossOrigin && (e.crossOrigin = h.crossOrigin);
      e.src = b;
    }
    function f(a, c, d, f, g, h, k) {
      var l = /\.dds$/i.test(d), n = b + d;
      if (l) {
        var z = THREE.ImageUtils.loadCompressedTexture(n);
        a[c] = z;
      } else
        z = document.createElement('canvas'), a[c] = new THREE.Texture(z);
      a[c].sourceFile = d;
      f && (a[c].repeat.set(f[0], f[1]), 1 !== f[0] && (a[c].wrapS = THREE.RepeatWrapping), 1 !== f[1] && (a[c].wrapT = THREE.RepeatWrapping));
      g && a[c].offset.set(g[0], g[1]);
      h && (d = {
        repeat: THREE.RepeatWrapping,
        mirror: THREE.MirroredRepeatWrapping
      }, void 0 !== d[h[0]] && (a[c].wrapS = d[h[0]]), void 0 !== d[h[1]] && (a[c].wrapT = d[h[1]]));
      k && (a[c].anisotropy = k);
      l || e(a[c], n);
    }
    function g(a) {
      return (255 * a[0] << 16) + (255 * a[1] << 8) + 255 * a[2];
    }
    var h = this, k = 'MeshLambertMaterial', l = {
        color: 15658734,
        opacity: 1,
        map: null,
        lightMap: null,
        normalMap: null,
        bumpMap: null,
        wireframe: !1
      };
    if (a.shading) {
      var n = a.shading.toLowerCase();
      'phong' === n ? k = 'MeshPhongMaterial' : 'basic' === n && (k = 'MeshBasicMaterial');
    }
    void 0 !== a.blending && void 0 !== THREE[a.blending] && (l.blending = THREE[a.blending]);
    if (void 0 !== a.transparent || 1 > a.opacity)
      l.transparent = a.transparent;
    void 0 !== a.depthTest && (l.depthTest = a.depthTest);
    void 0 !== a.depthWrite && (l.depthWrite = a.depthWrite);
    void 0 !== a.visible && (l.visible = a.visible);
    void 0 !== a.flipSided && (l.side = THREE.BackSide);
    void 0 !== a.doubleSided && (l.side = THREE.DoubleSide);
    void 0 !== a.wireframe && (l.wireframe = a.wireframe);
    void 0 !== a.vertexColors && ('face' === a.vertexColors ? l.vertexColors = THREE.FaceColors : a.vertexColors && (l.vertexColors = THREE.VertexColors));
    a.colorDiffuse ? l.color = g(a.colorDiffuse) : a.DbgColor && (l.color = a.DbgColor);
    a.colorSpecular && (l.specular = g(a.colorSpecular));
    a.colorAmbient && (l.ambient = g(a.colorAmbient));
    a.transparency && (l.opacity = a.transparency);
    a.specularCoef && (l.shininess = a.specularCoef);
    a.mapDiffuse && b && f(l, 'map', a.mapDiffuse, a.mapDiffuseRepeat, a.mapDiffuseOffset, a.mapDiffuseWrap, a.mapDiffuseAnisotropy);
    a.mapLight && b && f(l, 'lightMap', a.mapLight, a.mapLightRepeat, a.mapLightOffset, a.mapLightWrap, a.mapLightAnisotropy);
    a.mapBump && b && f(l, 'bumpMap', a.mapBump, a.mapBumpRepeat, a.mapBumpOffset, a.mapBumpWrap, a.mapBumpAnisotropy);
    a.mapNormal && b && f(l, 'normalMap', a.mapNormal, a.mapNormalRepeat, a.mapNormalOffset, a.mapNormalWrap, a.mapNormalAnisotropy);
    a.mapSpecular && b && f(l, 'specularMap', a.mapSpecular, a.mapSpecularRepeat, a.mapSpecularOffset, a.mapSpecularWrap, a.mapSpecularAnisotropy);
    a.mapBumpScale && (l.bumpScale = a.mapBumpScale);
    a.mapNormal ? (k = THREE.ShaderLib.normalmap, n = THREE.UniformsUtils.clone(k.uniforms), n.tNormal.value = l.normalMap, a.mapNormalFactor && n.uNormalScale.value.set(a.mapNormalFactor, a.mapNormalFactor), l.map && (n.tDiffuse.value = l.map, n.enableDiffuse.value = !0), l.specularMap && (n.tSpecular.value = l.specularMap, n.enableSpecular.value = !0), l.lightMap && (n.tAO.value = l.lightMap, n.enableAO.value = !0), n.diffuse.value.setHex(l.color), n.specular.value.setHex(l.specular), n.ambient.value.setHex(l.ambient), n.shininess.value = l.shininess, void 0 !== l.opacity && (n.opacity.value = l.opacity), k = new THREE.ShaderMaterial({
      fragmentShader: k.fragmentShader,
      vertexShader: k.vertexShader,
      uniforms: n,
      lights: !0,
      fog: !0
    }), l.transparent && (k.transparent = !0)) : k = new THREE[k](l);
    void 0 !== a.DbgName && (k.name = a.DbgName);
    return k;
  }
};
THREE.XHRLoader = function (a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
};
THREE.XHRLoader.prototype = {
  constructor: THREE.XHRLoader,
  load: function (a, b, c, d) {
    var e = this, f = new XMLHttpRequest();
    void 0 !== b && f.addEventListener('load', function (c) {
      b(c.target.responseText);
      e.manager.itemEnd(a);
    }, !1);
    void 0 !== c && f.addEventListener('progress', function (a) {
      c(a);
    }, !1);
    void 0 !== d && f.addEventListener('error', function (a) {
      d(a);
    }, !1);
    void 0 !== this.crossOrigin && (f.crossOrigin = this.crossOrigin);
    f.open('GET', a, !0);
    f.send(null);
    e.manager.itemStart(a);
  },
  setCrossOrigin: function (a) {
    this.crossOrigin = a;
  }
};
THREE.ImageLoader = function (a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
};
THREE.ImageLoader.prototype = {
  constructor: THREE.ImageLoader,
  load: function (a, b, c, d) {
    var e = this, f = document.createElement('img');
    void 0 !== b && f.addEventListener('load', function (c) {
      e.manager.itemEnd(a);
      b(this);
    }, !1);
    void 0 !== c && f.addEventListener('progress', function (a) {
      c(a);
    }, !1);
    void 0 !== d && f.addEventListener('error', function (a) {
      d(a);
    }, !1);
    void 0 !== this.crossOrigin && (f.crossOrigin = this.crossOrigin);
    f.src = a;
    e.manager.itemStart(a);
    return f;
  },
  setCrossOrigin: function (a) {
    this.crossOrigin = a;
  }
};
THREE.JSONLoader = function (a) {
  THREE.Loader.call(this, a);
  this.withCredentials = !1;
};
THREE.JSONLoader.prototype = Object.create(THREE.Loader.prototype);
THREE.JSONLoader.prototype.load = function (a, b, c) {
  c = c && 'string' === typeof c ? c : this.extractUrlBase(a);
  this.onLoadStart();
  this.loadAjaxJSON(this, a, b, c);
};
THREE.JSONLoader.prototype.loadAjaxJSON = function (a, b, c, d, e) {
  var f = new XMLHttpRequest(), g = 0;
  f.onreadystatechange = function () {
    if (f.readyState === f.DONE)
      if (200 === f.status || 0 === f.status) {
        if (f.responseText) {
          var h = JSON.parse(f.responseText);
          if ('scene' === h.metadata.type) {
            console.error('THREE.JSONLoader: "' + b + '" seems to be a Scene. Use THREE.SceneLoader instead.');
            return;
          }
          h = a.parse(h, d);
          c(h.geometry, h.materials);
        } else
          console.error('THREE.JSONLoader: "' + b + '" seems to be unreachable or the file is empty.');
        a.onLoadComplete();
      } else
        console.error('THREE.JSONLoader: Couldn\'t load "' + b + '" (' + f.status + ')');
    else
      f.readyState === f.LOADING ? e && (0 === g && (g = f.getResponseHeader('Content-Length')), e({
        total: g,
        loaded: f.responseText.length
      })) : f.readyState === f.HEADERS_RECEIVED && void 0 !== e && (g = f.getResponseHeader('Content-Length'));
  };
  f.open('GET', b, !0);
  f.withCredentials = this.withCredentials;
  f.send(null);
};
THREE.JSONLoader.prototype.parse = function (a, b) {
  var c = new THREE.Geometry(), d = void 0 !== a.scale ? 1 / a.scale : 1;
  (function (b) {
    var d, g, h, k, l, n, s, r, q, u, p, v, w, t = a.faces;
    n = a.vertices;
    var x = a.normals, z = a.colors, B = 0;
    if (void 0 !== a.uvs) {
      for (d = 0; d < a.uvs.length; d++)
        a.uvs[d].length && B++;
      for (d = 0; d < B; d++)
        c.faceVertexUvs[d] = [];
    }
    k = 0;
    for (l = n.length; k < l;)
      d = new THREE.Vector3(), d.x = n[k++] * b, d.y = n[k++] * b, d.z = n[k++] * b, c.vertices.push(d);
    k = 0;
    for (l = t.length; k < l;)
      if (b = t[k++], q = b & 1, h = b & 2, d = b & 8, s = b & 16, u = b & 32, n = b & 64, b &= 128, q) {
        q = new THREE.Face3();
        q.a = t[k];
        q.b = t[k + 1];
        q.c = t[k + 3];
        p = new THREE.Face3();
        p.a = t[k + 1];
        p.b = t[k + 2];
        p.c = t[k + 3];
        k += 4;
        h && (h = t[k++], q.materialIndex = h, p.materialIndex = h);
        h = c.faces.length;
        if (d)
          for (d = 0; d < B; d++)
            for (v = a.uvs[d], c.faceVertexUvs[d][h] = [], c.faceVertexUvs[d][h + 1] = [], g = 0; 4 > g; g++)
              r = t[k++], w = v[2 * r], r = v[2 * r + 1], w = new THREE.Vector2(w, r), 2 !== g && c.faceVertexUvs[d][h].push(w), 0 !== g && c.faceVertexUvs[d][h + 1].push(w);
        s && (s = 3 * t[k++], q.normal.set(x[s++], x[s++], x[s]), p.normal.copy(q.normal));
        if (u)
          for (d = 0; 4 > d; d++)
            s = 3 * t[k++], u = new THREE.Vector3(x[s++], x[s++], x[s]), 2 !== d && q.vertexNormals.push(u), 0 !== d && p.vertexNormals.push(u);
        n && (n = t[k++], n = z[n], q.color.setHex(n), p.color.setHex(n));
        if (b)
          for (d = 0; 4 > d; d++)
            n = t[k++], n = z[n], 2 !== d && q.vertexColors.push(new THREE.Color(n)), 0 !== d && p.vertexColors.push(new THREE.Color(n));
        c.faces.push(q);
        c.faces.push(p);
      } else {
        q = new THREE.Face3();
        q.a = t[k++];
        q.b = t[k++];
        q.c = t[k++];
        h && (h = t[k++], q.materialIndex = h);
        h = c.faces.length;
        if (d)
          for (d = 0; d < B; d++)
            for (v = a.uvs[d], c.faceVertexUvs[d][h] = [], g = 0; 3 > g; g++)
              r = t[k++], w = v[2 * r], r = v[2 * r + 1], w = new THREE.Vector2(w, r), c.faceVertexUvs[d][h].push(w);
        s && (s = 3 * t[k++], q.normal.set(x[s++], x[s++], x[s]));
        if (u)
          for (d = 0; 3 > d; d++)
            s = 3 * t[k++], u = new THREE.Vector3(x[s++], x[s++], x[s]), q.vertexNormals.push(u);
        n && (n = t[k++], q.color.setHex(z[n]));
        if (b)
          for (d = 0; 3 > d; d++)
            n = t[k++], q.vertexColors.push(new THREE.Color(z[n]));
        c.faces.push(q);
      }
  }(d));
  (function () {
    if (a.skinWeights)
      for (var b = 0, d = a.skinWeights.length; b < d; b += 2)
        c.skinWeights.push(new THREE.Vector4(a.skinWeights[b], a.skinWeights[b + 1], 0, 0));
    if (a.skinIndices)
      for (b = 0, d = a.skinIndices.length; b < d; b += 2)
        c.skinIndices.push(new THREE.Vector4(a.skinIndices[b], a.skinIndices[b + 1], 0, 0));
    c.bones = a.bones;
    c.bones && 0 < c.bones.length && (c.skinWeights.length !== c.skinIndices.length || c.skinIndices.length !== c.vertices.length) && console.warn('When skinning, number of vertices (' + c.vertices.length + '), skinIndices (' + c.skinIndices.length + '), and skinWeights (' + c.skinWeights.length + ') should match.');
    c.animation = a.animation;
    c.animations = a.animations;
  }());
  (function (b) {
    if (void 0 !== a.morphTargets) {
      var d, g, h, k, l, n;
      d = 0;
      for (g = a.morphTargets.length; d < g; d++)
        for (c.morphTargets[d] = {}, c.morphTargets[d].name = a.morphTargets[d].name, c.morphTargets[d].vertices = [], l = c.morphTargets[d].vertices, n = a.morphTargets[d].vertices, h = 0, k = n.length; h < k; h += 3) {
          var s = new THREE.Vector3();
          s.x = n[h] * b;
          s.y = n[h + 1] * b;
          s.z = n[h + 2] * b;
          l.push(s);
        }
    }
    if (void 0 !== a.morphColors)
      for (d = 0, g = a.morphColors.length; d < g; d++)
        for (c.morphColors[d] = {}, c.morphColors[d].name = a.morphColors[d].name, c.morphColors[d].colors = [], k = c.morphColors[d].colors, l = a.morphColors[d].colors, b = 0, h = l.length; b < h; b += 3)
          n = new THREE.Color(16755200), n.setRGB(l[b], l[b + 1], l[b + 2]), k.push(n);
  }(d));
  c.computeCentroids();
  c.computeFaceNormals();
  c.computeBoundingSphere();
  if (void 0 === a.materials)
    return { geometry: c };
  d = this.initMaterials(a.materials, b);
  this.needsTangents(d) && c.computeTangents();
  return {
    geometry: c,
    materials: d
  };
};
THREE.LoadingManager = function (a, b, c) {
  var d = this, e = 0, f = 0;
  this.onLoad = a;
  this.onProgress = b;
  this.onError = c;
  this.itemStart = function (a) {
    f++;
  };
  this.itemEnd = function (a) {
    e++;
    if (void 0 !== d.onProgress)
      d.onProgress(a, e, f);
    if (e === f && void 0 !== d.onLoad)
      d.onLoad();
  };
};
THREE.DefaultLoadingManager = new THREE.LoadingManager();
THREE.BufferGeometryLoader = function (a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
};
THREE.BufferGeometryLoader.prototype = {
  constructor: THREE.BufferGeometryLoader,
  load: function (a, b, c, d) {
    var e = this;
    c = new THREE.XHRLoader();
    c.setCrossOrigin(this.crossOrigin);
    c.load(a, function (a) {
      b(e.parse(JSON.parse(a)));
    });
  },
  setCrossOrigin: function (a) {
    this.crossOrigin = a;
  },
  parse: function (a) {
    var b = new THREE.BufferGeometry(), c = a.attributes, d = a.offsets;
    a = a.boundingSphere;
    for (var e in c) {
      var f = c[e];
      b.attributes[e] = {
        itemSize: f.itemSize,
        array: new self[f.type](f.array)
      };
    }
    void 0 !== d && (b.offsets = JSON.parse(JSON.stringify(d)));
    void 0 !== a && (b.boundingSphere = new THREE.Sphere(new THREE.Vector3().fromArray(void 0 !== a.center ? a.center : [
      0,
      0,
      0
    ]), a.radius));
    return b;
  }
};
THREE.Geometry2Loader = function (a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
};
THREE.Geometry2Loader.prototype = {
  constructor: THREE.Geometry2Loader,
  load: function (a, b, c, d) {
    var e = this;
    c = new THREE.XHRLoader();
    c.setCrossOrigin(this.crossOrigin);
    c.load(a, function (a) {
      b(e.parse(JSON.parse(a)));
    });
  },
  setCrossOrigin: function (a) {
    this.crossOrigin = a;
  },
  parse: function (a) {
    var b = new THREE.Geometry2(a.vertices.length / 3), c = [
        'vertices',
        'normals',
        'uvs'
      ], d = a.boundingSphere, e;
    for (e in c) {
      var f = c[e];
      b[f].set(a[f]);
    }
    void 0 !== d && (b.boundingSphere = new THREE.Sphere(new THREE.Vector3().fromArray(void 0 !== d.center ? d.center : [
      0,
      0,
      0
    ]), d.radius));
    return b;
  }
};
THREE.MaterialLoader = function (a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
};
THREE.MaterialLoader.prototype = {
  constructor: THREE.MaterialLoader,
  load: function (a, b, c, d) {
    var e = this;
    c = new THREE.XHRLoader();
    c.setCrossOrigin(this.crossOrigin);
    c.load(a, function (a) {
      b(e.parse(JSON.parse(a)));
    });
  },
  setCrossOrigin: function (a) {
    this.crossOrigin = a;
  },
  parse: function (a) {
    var b = new THREE[a.type]();
    void 0 !== a.color && b.color.setHex(a.color);
    void 0 !== a.ambient && b.ambient.setHex(a.ambient);
    void 0 !== a.emissive && b.emissive.setHex(a.emissive);
    void 0 !== a.specular && b.specular.setHex(a.specular);
    void 0 !== a.shininess && (b.shininess = a.shininess);
    void 0 !== a.vertexColors && (b.vertexColors = a.vertexColors);
    void 0 !== a.blending && (b.blending = a.blending);
    void 0 !== a.side && (b.side = a.side);
    void 0 !== a.opacity && (b.opacity = a.opacity);
    void 0 !== a.transparent && (b.transparent = a.transparent);
    void 0 !== a.wireframe && (b.wireframe = a.wireframe);
    if (void 0 !== a.materials)
      for (var c = 0, d = a.materials.length; c < d; c++)
        b.materials.push(this.parse(a.materials[c]));
    return b;
  }
};
THREE.ObjectLoader = function (a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
};
THREE.ObjectLoader.prototype = {
  constructor: THREE.ObjectLoader,
  load: function (a, b, c, d) {
    var e = this;
    c = new THREE.XHRLoader(e.manager);
    c.setCrossOrigin(this.crossOrigin);
    c.load(a, function (a) {
      b(e.parse(JSON.parse(a)));
    });
  },
  setCrossOrigin: function (a) {
    this.crossOrigin = a;
  },
  parse: function (a) {
    var b = this.parseGeometries(a.geometries), c = this.parseMaterials(a.materials);
    return this.parseObject(a.object, b, c);
  },
  parseGeometries: function (a) {
    var b = {};
    if (void 0 !== a)
      for (var c = new THREE.JSONLoader(), d = new THREE.Geometry2Loader(), e = new THREE.BufferGeometryLoader(), f = 0, g = a.length; f < g; f++) {
        var h, k = a[f];
        switch (k.type) {
        case 'PlaneGeometry':
          h = new THREE.PlaneGeometry(k.width, k.height, k.widthSegments, k.heightSegments);
          break;
        case 'BoxGeometry':
        case 'CubeGeometry':
          h = new THREE.BoxGeometry(k.width, k.height, k.depth, k.widthSegments, k.heightSegments, k.depthSegments);
          break;
        case 'CircleGeometry':
          h = new THREE.CircleGeometry(k.radius, k.segments);
          break;
        case 'CylinderGeometry':
          h = new THREE.CylinderGeometry(k.radiusTop, k.radiusBottom, k.height, k.radialSegments, k.heightSegments, k.openEnded);
          break;
        case 'SphereGeometry':
          h = new THREE.SphereGeometry(k.radius, k.widthSegments, k.heightSegments, k.phiStart, k.phiLength, k.thetaStart, k.thetaLength);
          break;
        case 'IcosahedronGeometry':
          h = new THREE.IcosahedronGeometry(k.radius, k.detail);
          break;
        case 'TorusGeometry':
          h = new THREE.TorusGeometry(k.radius, k.tube, k.radialSegments, k.tubularSegments, k.arc);
          break;
        case 'TorusKnotGeometry':
          h = new THREE.TorusKnotGeometry(k.radius, k.tube, k.radialSegments, k.tubularSegments, k.p, k.q, k.heightScale);
          break;
        case 'BufferGeometry':
          h = e.parse(k.data);
          break;
        case 'Geometry2':
          h = d.parse(k.data);
          break;
        case 'Geometry':
          h = c.parse(k.data).geometry;
        }
        h.uuid = k.uuid;
        void 0 !== k.name && (h.name = k.name);
        b[k.uuid] = h;
      }
    return b;
  },
  parseMaterials: function (a) {
    var b = {};
    if (void 0 !== a)
      for (var c = new THREE.MaterialLoader(), d = 0, e = a.length; d < e; d++) {
        var f = a[d], g = c.parse(f);
        g.uuid = f.uuid;
        void 0 !== f.name && (g.name = f.name);
        b[f.uuid] = g;
      }
    return b;
  },
  parseObject: function () {
    var a = new THREE.Matrix4();
    return function (b, c, d) {
      var e;
      switch (b.type) {
      case 'Scene':
        e = new THREE.Scene();
        break;
      case 'PerspectiveCamera':
        e = new THREE.PerspectiveCamera(b.fov, b.aspect, b.near, b.far);
        break;
      case 'OrthographicCamera':
        e = new THREE.OrthographicCamera(b.left, b.right, b.top, b.bottom, b.near, b.far);
        break;
      case 'AmbientLight':
        e = new THREE.AmbientLight(b.color);
        break;
      case 'DirectionalLight':
        e = new THREE.DirectionalLight(b.color, b.intensity);
        break;
      case 'PointLight':
        e = new THREE.PointLight(b.color, b.intensity, b.distance);
        break;
      case 'SpotLight':
        e = new THREE.SpotLight(b.color, b.intensity, b.distance, b.angle, b.exponent);
        break;
      case 'HemisphereLight':
        e = new THREE.HemisphereLight(b.color, b.groundColor, b.intensity);
        break;
      case 'Mesh':
        e = c[b.geometry];
        var f = d[b.material];
        void 0 === e && console.error('THREE.ObjectLoader: Undefined geometry ' + b.geometry);
        void 0 === f && console.error('THREE.ObjectLoader: Undefined material ' + b.material);
        e = new THREE.Mesh(e, f);
        break;
      case 'Sprite':
        f = d[b.material];
        void 0 === f && console.error('THREE.ObjectLoader: Undefined material ' + b.material);
        e = new THREE.Sprite(f);
        break;
      default:
        e = new THREE.Object3D();
      }
      e.uuid = b.uuid;
      void 0 !== b.name && (e.name = b.name);
      void 0 !== b.matrix ? (a.fromArray(b.matrix), a.decompose(e.position, e.quaternion, e.scale)) : (void 0 !== b.position && e.position.fromArray(b.position), void 0 !== b.rotation && e.rotation.fromArray(b.rotation), void 0 !== b.scale && e.scale.fromArray(b.scale));
      void 0 !== b.visible && (e.visible = b.visible);
      void 0 !== b.userData && (e.userData = b.userData);
      if (void 0 !== b.children)
        for (var g in b.children)
          e.add(this.parseObject(b.children[g], c, d));
      return e;
    };
  }()
};
THREE.SceneLoader = function () {
  this.onLoadStart = function () {
  };
  this.onLoadProgress = function () {
  };
  this.onLoadComplete = function () {
  };
  this.callbackSync = function () {
  };
  this.callbackProgress = function () {
  };
  this.geometryHandlers = {};
  this.hierarchyHandlers = {};
  this.addGeometryHandler('ascii', THREE.JSONLoader);
};
THREE.SceneLoader.prototype = {
  constructor: THREE.SceneLoader,
  load: function (a, b, c, d) {
    var e = this;
    c = new THREE.XHRLoader(e.manager);
    c.setCrossOrigin(this.crossOrigin);
    c.load(a, function (c) {
      e.parse(JSON.parse(c), b, a);
    });
  },
  setCrossOrigin: function (a) {
    this.crossOrigin = a;
  },
  addGeometryHandler: function (a, b) {
    this.geometryHandlers[a] = { loaderClass: b };
  },
  addHierarchyHandler: function (a, b) {
    this.hierarchyHandlers[a] = { loaderClass: b };
  },
  parse: function (a, b, c) {
    function d(a, b) {
      return 'relativeToHTML' == b ? a : q + a;
    }
    function e() {
      f(D.scene, I.objects);
    }
    function f(a, b) {
      var c, e, g, h, l, n;
      for (n in b) {
        var s = D.objects[n], q = b[n];
        if (void 0 === s) {
          if (q.type && q.type in r.hierarchyHandlers) {
            if (void 0 === q.loading) {
              c = {
                type: 1,
                url: 1,
                material: 1,
                position: 1,
                rotation: 1,
                scale: 1,
                visible: 1,
                children: 1,
                userData: 1,
                skin: 1,
                morph: 1,
                mirroredLoop: 1,
                duration: 1
              };
              var t = {}, w;
              for (w in q)
                w in c || (t[w] = q[w]);
              p = D.materials[q.material];
              q.loading = !0;
              c = r.hierarchyHandlers[q.type].loaderObject;
              c.options ? c.load(d(q.url, I.urlBaseType), k(n, a, p, q)) : c.load(d(q.url, I.urlBaseType), k(n, a, p, q), t);
            }
          } else if (void 0 !== q.geometry) {
            if (u = D.geometries[q.geometry]) {
              s = !1;
              p = D.materials[q.material];
              s = p instanceof THREE.ShaderMaterial;
              e = q.position;
              g = q.rotation;
              h = q.scale;
              c = q.matrix;
              l = q.quaternion;
              q.material || (p = new THREE.MeshFaceMaterial(D.face_materials[q.geometry]));
              p instanceof THREE.MeshFaceMaterial && 0 === p.materials.length && (p = new THREE.MeshFaceMaterial(D.face_materials[q.geometry]));
              if (p instanceof THREE.MeshFaceMaterial)
                for (t = 0; t < p.materials.length; t++)
                  s = s || p.materials[t] instanceof THREE.ShaderMaterial;
              s && u.computeTangents();
              q.skin ? s = new THREE.SkinnedMesh(u, p) : q.morph ? (s = new THREE.MorphAnimMesh(u, p), void 0 !== q.duration && (s.duration = q.duration), void 0 !== q.time && (s.time = q.time), void 0 !== q.mirroredLoop && (s.mirroredLoop = q.mirroredLoop), p.morphNormals && u.computeMorphNormals()) : s = new THREE.Mesh(u, p);
              s.name = n;
              c ? (s.matrixAutoUpdate = !1, s.matrix.set(c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7], c[8], c[9], c[10], c[11], c[12], c[13], c[14], c[15])) : (s.position.fromArray(e), l ? s.quaternion.fromArray(l) : s.rotation.fromArray(g), s.scale.fromArray(h));
              s.visible = q.visible;
              s.castShadow = q.castShadow;
              s.receiveShadow = q.receiveShadow;
              a.add(s);
              D.objects[n] = s;
            }
          } else if ('AmbientLight' === q.type || 'PointLight' === q.type || 'DirectionalLight' === q.type || 'SpotLight' === q.type || 'HemisphereLight' === q.type || 'AreaLight' === q.type) {
            t = q.color;
            c = q.intensity;
            e = q.distance;
            g = q.position;
            h = q.rotation;
            switch (q.type) {
            case 'AmbientLight':
              x = new THREE.AmbientLight(t);
              break;
            case 'PointLight':
              x = new THREE.PointLight(t, c, e);
              x.position.fromArray(g);
              break;
            case 'DirectionalLight':
              x = new THREE.DirectionalLight(t, c);
              x.position.fromArray(q.direction);
              break;
            case 'SpotLight':
              x = new THREE.SpotLight(t, c, e, 1);
              x.angle = q.angle;
              x.position.fromArray(g);
              x.target.set(g[0], g[1] - e, g[2]);
              x.target.applyEuler(new THREE.Euler(h[0], h[1], h[2], 'XYZ'));
              break;
            case 'HemisphereLight':
              x = new THREE.DirectionalLight(t, c, e);
              x.target.set(g[0], g[1] - e, g[2]);
              x.target.applyEuler(new THREE.Euler(h[0], h[1], h[2], 'XYZ'));
              break;
            case 'AreaLight':
              x = new THREE.AreaLight(t, c), x.position.fromArray(g), x.width = q.size, x.height = q.size_y;
            }
            a.add(x);
            x.name = n;
            D.lights[n] = x;
            D.objects[n] = x;
          } else
            'PerspectiveCamera' === q.type || 'OrthographicCamera' === q.type ? (e = q.position, g = q.rotation, l = q.quaternion, 'PerspectiveCamera' === q.type ? v = new THREE.PerspectiveCamera(q.fov, q.aspect, q.near, q.far) : 'OrthographicCamera' === q.type && (v = new THREE.OrthographicCamera(q.left, q.right, q.top, q.bottom, q.near, q.far)), v.name = n, v.position.fromArray(e), void 0 !== l ? v.quaternion.fromArray(l) : void 0 !== g && v.rotation.fromArray(g), a.add(v), D.cameras[n] = v, D.objects[n] = v) : (e = q.position, g = q.rotation, h = q.scale, l = q.quaternion, s = new THREE.Object3D(), s.name = n, s.position.fromArray(e), l ? s.quaternion.fromArray(l) : s.rotation.fromArray(g), s.scale.fromArray(h), s.visible = void 0 !== q.visible ? q.visible : !1, a.add(s), D.objects[n] = s, D.empties[n] = s);
          if (s) {
            if (void 0 !== q.userData)
              for (var z in q.userData)
                s.userData[z] = q.userData[z];
            if (void 0 !== q.groups)
              for (t = 0; t < q.groups.length; t++)
                c = q.groups[t], void 0 === D.groups[c] && (D.groups[c] = []), D.groups[c].push(n);
          }
        }
        void 0 !== s && void 0 !== q.children && f(s, q.children);
      }
    }
    function g(a, b, c, d, f) {
      var g = f.rotation, h = f.quaternion, k = f.scale;
      a.position.fromArray(f.position);
      h ? a.quaternion.fromArray(h) : a.rotation.fromArray(g);
      a.scale.fromArray(k);
      d && a.traverse(function (a) {
        a.material = d;
      });
      var l = void 0 !== f.visible ? f.visible : !0;
      a.traverse(function (a) {
        a.visible = l;
      });
      c.add(a);
      a.name = b;
      D.objects[b] = a;
      e();
    }
    function h(a) {
      return function (b, c) {
        b.name = a;
        D.geometries[a] = b;
        D.face_materials[a] = c;
        e();
        z -= 1;
        r.onLoadComplete();
        n();
      };
    }
    function k(a, b, c, d) {
      return function (e) {
        g(e.content ? e.content : e.dae ? e.scene : e, a, b, c, d);
        z -= 1;
        r.onLoadComplete();
        n();
      };
    }
    function l(a) {
      return function (b, c) {
        b.name = a;
        D.geometries[a] = b;
        D.face_materials[a] = c;
      };
    }
    function n() {
      r.callbackProgress({
        totalModels: E,
        totalTextures: H,
        loadedModels: E - z,
        loadedTextures: H - B
      }, D);
      r.onLoadProgress();
      if (0 === z && 0 === B) {
        for (var a = 0; a < G.length; a++) {
          var c = G[a], d = D.objects[c.targetName];
          d ? c.object.target = d : (c.object.target = new THREE.Object3D(), D.scene.add(c.object.target));
          c.object.target.userData.targetInverse = c.object;
        }
        b(D);
      }
    }
    function s(a, b) {
      b(a);
      if (void 0 !== a.children)
        for (var c in a.children)
          s(a.children[c], b);
    }
    var r = this, q = THREE.Loader.prototype.extractUrlBase(c), u, p, v, w, t, x, z, B, E, H, D, G = [], I = a, O;
    for (O in this.geometryHandlers)
      a = this.geometryHandlers[O].loaderClass, this.geometryHandlers[O].loaderObject = new a();
    for (O in this.hierarchyHandlers)
      a = this.hierarchyHandlers[O].loaderClass, this.hierarchyHandlers[O].loaderObject = new a();
    B = z = 0;
    D = {
      scene: new THREE.Scene(),
      geometries: {},
      face_materials: {},
      materials: {},
      textures: {},
      objects: {},
      cameras: {},
      lights: {},
      fogs: {},
      empties: {},
      groups: {}
    };
    I.transform && (O = I.transform.position, a = I.transform.rotation, c = I.transform.scale, O && D.scene.position.fromArray(O), a && D.scene.rotation.fromArray(a), c && D.scene.scale.fromArray(c), O || a || c) && (D.scene.updateMatrix(), D.scene.updateMatrixWorld());
    O = function (a) {
      return function () {
        B -= a;
        n();
        r.onLoadComplete();
      };
    };
    for (var K in I.fogs)
      a = I.fogs[K], 'linear' === a.type ? w = new THREE.Fog(0, a.near, a.far) : 'exp2' === a.type && (w = new THREE.FogExp2(0, a.density)), a = a.color, w.color.setRGB(a[0], a[1], a[2]), D.fogs[K] = w;
    for (var y in I.geometries)
      w = I.geometries[y], w.type in this.geometryHandlers && (z += 1, r.onLoadStart());
    for (var F in I.objects)
      s(I.objects[F], function (a) {
        a.type && a.type in r.hierarchyHandlers && (z += 1, r.onLoadStart());
      });
    E = z;
    for (y in I.geometries)
      if (w = I.geometries[y], 'cube' === w.type)
        u = new THREE.BoxGeometry(w.width, w.height, w.depth, w.widthSegments, w.heightSegments, w.depthSegments), u.name = y, D.geometries[y] = u;
      else if ('plane' === w.type)
        u = new THREE.PlaneGeometry(w.width, w.height, w.widthSegments, w.heightSegments), u.name = y, D.geometries[y] = u;
      else if ('sphere' === w.type)
        u = new THREE.SphereGeometry(w.radius, w.widthSegments, w.heightSegments), u.name = y, D.geometries[y] = u;
      else if ('cylinder' === w.type)
        u = new THREE.CylinderGeometry(w.topRad, w.botRad, w.height, w.radSegs, w.heightSegs), u.name = y, D.geometries[y] = u;
      else if ('torus' === w.type)
        u = new THREE.TorusGeometry(w.radius, w.tube, w.segmentsR, w.segmentsT), u.name = y, D.geometries[y] = u;
      else if ('icosahedron' === w.type)
        u = new THREE.IcosahedronGeometry(w.radius, w.subdivisions), u.name = y, D.geometries[y] = u;
      else if (w.type in this.geometryHandlers) {
        F = {};
        for (t in w)
          'type' !== t && 'url' !== t && (F[t] = w[t]);
        this.geometryHandlers[w.type].loaderObject.load(d(w.url, I.urlBaseType), h(y), F);
      } else
        'embedded' === w.type && (F = I.embeds[w.id], F.metadata = I.metadata, F && (F = this.geometryHandlers.ascii.loaderObject.parse(F, ''), l(y)(F.geometry, F.materials)));
    for (var C in I.textures)
      if (y = I.textures[C], y.url instanceof Array)
        for (B += y.url.length, t = 0; t < y.url.length; t++)
          r.onLoadStart();
      else
        B += 1, r.onLoadStart();
    H = B;
    for (C in I.textures) {
      y = I.textures[C];
      void 0 !== y.mapping && void 0 !== THREE[y.mapping] && (y.mapping = new THREE[y.mapping]());
      if (y.url instanceof Array) {
        F = y.url.length;
        w = [];
        for (t = 0; t < F; t++)
          w[t] = d(y.url[t], I.urlBaseType);
        t = (t = /\.dds$/i.test(w[0])) ? THREE.ImageUtils.loadCompressedTextureCube(w, y.mapping, O(F)) : THREE.ImageUtils.loadTextureCube(w, y.mapping, O(F));
      } else
        t = /\.dds$/i.test(y.url), F = d(y.url, I.urlBaseType), w = O(1), t = t ? THREE.ImageUtils.loadCompressedTexture(F, y.mapping, w) : THREE.ImageUtils.loadTexture(F, y.mapping, w), void 0 !== THREE[y.minFilter] && (t.minFilter = THREE[y.minFilter]), void 0 !== THREE[y.magFilter] && (t.magFilter = THREE[y.magFilter]), y.anisotropy && (t.anisotropy = y.anisotropy), y.repeat && (t.repeat.set(y.repeat[0], y.repeat[1]), 1 !== y.repeat[0] && (t.wrapS = THREE.RepeatWrapping), 1 !== y.repeat[1] && (t.wrapT = THREE.RepeatWrapping)), y.offset && t.offset.set(y.offset[0], y.offset[1]), y.wrap && (F = {
          repeat: THREE.RepeatWrapping,
          mirror: THREE.MirroredRepeatWrapping
        }, void 0 !== F[y.wrap[0]] && (t.wrapS = F[y.wrap[0]]), void 0 !== F[y.wrap[1]] && (t.wrapT = F[y.wrap[1]]));
      D.textures[C] = t;
    }
    var A, L;
    for (A in I.materials) {
      C = I.materials[A];
      for (L in C.parameters)
        'envMap' === L || 'map' === L || 'lightMap' === L || 'bumpMap' === L ? C.parameters[L] = D.textures[C.parameters[L]] : 'shading' === L ? C.parameters[L] = 'flat' === C.parameters[L] ? THREE.FlatShading : THREE.SmoothShading : 'side' === L ? C.parameters[L] = 'double' == C.parameters[L] ? THREE.DoubleSide : 'back' == C.parameters[L] ? THREE.BackSide : THREE.FrontSide : 'blending' === L ? C.parameters[L] = C.parameters[L] in THREE ? THREE[C.parameters[L]] : THREE.NormalBlending : 'combine' === L ? C.parameters[L] = C.parameters[L] in THREE ? THREE[C.parameters[L]] : THREE.MultiplyOperation : 'vertexColors' === L ? 'face' == C.parameters[L] ? C.parameters[L] = THREE.FaceColors : C.parameters[L] && (C.parameters[L] = THREE.VertexColors) : 'wrapRGB' === L && (O = C.parameters[L], C.parameters[L] = new THREE.Vector3(O[0], O[1], O[2]));
      void 0 !== C.parameters.opacity && 1 > C.parameters.opacity && (C.parameters.transparent = !0);
      C.parameters.normalMap ? (O = THREE.ShaderLib.normalmap, y = THREE.UniformsUtils.clone(O.uniforms), t = C.parameters.color, F = C.parameters.specular, w = C.parameters.ambient, K = C.parameters.shininess, y.tNormal.value = D.textures[C.parameters.normalMap], C.parameters.normalScale && y.uNormalScale.value.set(C.parameters.normalScale[0], C.parameters.normalScale[1]), C.parameters.map && (y.tDiffuse.value = C.parameters.map, y.enableDiffuse.value = !0), C.parameters.envMap && (y.tCube.value = C.parameters.envMap, y.enableReflection.value = !0, y.reflectivity.value = C.parameters.reflectivity), C.parameters.lightMap && (y.tAO.value = C.parameters.lightMap, y.enableAO.value = !0), C.parameters.specularMap && (y.tSpecular.value = D.textures[C.parameters.specularMap], y.enableSpecular.value = !0), C.parameters.displacementMap && (y.tDisplacement.value = D.textures[C.parameters.displacementMap], y.enableDisplacement.value = !0, y.uDisplacementBias.value = C.parameters.displacementBias, y.uDisplacementScale.value = C.parameters.displacementScale), y.diffuse.value.setHex(t), y.specular.value.setHex(F), y.ambient.value.setHex(w), y.shininess.value = K, C.parameters.opacity && (y.opacity.value = C.parameters.opacity), p = new THREE.ShaderMaterial({
        fragmentShader: O.fragmentShader,
        vertexShader: O.vertexShader,
        uniforms: y,
        lights: !0,
        fog: !0
      })) : p = new THREE[C.type](C.parameters);
      p.name = A;
      D.materials[A] = p;
    }
    for (A in I.materials)
      if (C = I.materials[A], C.parameters.materials) {
        L = [];
        for (t = 0; t < C.parameters.materials.length; t++)
          L.push(D.materials[C.parameters.materials[t]]);
        D.materials[A].materials = L;
      }
    e();
    D.cameras && I.defaults.camera && (D.currentCamera = D.cameras[I.defaults.camera]);
    D.fogs && I.defaults.fog && (D.scene.fog = D.fogs[I.defaults.fog]);
    r.callbackSync(D);
    n();
  }
};
THREE.TextureLoader = function (a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
};
THREE.TextureLoader.prototype = {
  constructor: THREE.TextureLoader,
  load: function (a, b, c, d) {
    c = new THREE.ImageLoader(this.manager);
    c.setCrossOrigin(this.crossOrigin);
    c.load(a, function (a) {
      a = new THREE.Texture(a);
      a.needsUpdate = !0;
      void 0 !== b && b(a);
    });
  },
  setCrossOrigin: function (a) {
    this.crossOrigin = a;
  }
};
THREE.Material = function () {
  this.id = THREE.MaterialIdCount++;
  this.uuid = THREE.Math.generateUUID();
  this.name = '';
  this.side = THREE.FrontSide;
  this.opacity = 1;
  this.transparent = !1;
  this.blending = THREE.NormalBlending;
  this.blendSrc = THREE.SrcAlphaFactor;
  this.blendDst = THREE.OneMinusSrcAlphaFactor;
  this.blendEquation = THREE.AddEquation;
  this.depthWrite = this.depthTest = !0;
  this.polygonOffset = !1;
  this.overdraw = this.alphaTest = this.polygonOffsetUnits = this.polygonOffsetFactor = 0;
  this.needsUpdate = this.visible = !0;
};
THREE.Material.prototype = {
  constructor: THREE.Material,
  setValues: function (a) {
    if (void 0 !== a)
      for (var b in a) {
        var c = a[b];
        if (void 0 === c)
          console.warn('THREE.Material: \'' + b + '\' parameter is undefined.');
        else if (b in this) {
          var d = this[b];
          d instanceof THREE.Color ? d.set(c) : d instanceof THREE.Vector3 && c instanceof THREE.Vector3 ? d.copy(c) : this[b] = 'overdraw' == b ? Number(c) : c;
        }
      }
  },
  clone: function (a) {
    void 0 === a && (a = new THREE.Material());
    a.name = this.name;
    a.side = this.side;
    a.opacity = this.opacity;
    a.transparent = this.transparent;
    a.blending = this.blending;
    a.blendSrc = this.blendSrc;
    a.blendDst = this.blendDst;
    a.blendEquation = this.blendEquation;
    a.depthTest = this.depthTest;
    a.depthWrite = this.depthWrite;
    a.polygonOffset = this.polygonOffset;
    a.polygonOffsetFactor = this.polygonOffsetFactor;
    a.polygonOffsetUnits = this.polygonOffsetUnits;
    a.alphaTest = this.alphaTest;
    a.overdraw = this.overdraw;
    a.visible = this.visible;
    return a;
  },
  dispose: function () {
    this.dispatchEvent({ type: 'dispose' });
  }
};
THREE.EventDispatcher.prototype.apply(THREE.Material.prototype);
THREE.MaterialIdCount = 0;
THREE.LineBasicMaterial = function (a) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.linewidth = 1;
  this.linejoin = this.linecap = 'round';
  this.vertexColors = !1;
  this.fog = !0;
  this.setValues(a);
};
THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.LineBasicMaterial.prototype.clone = function () {
  var a = new THREE.LineBasicMaterial();
  THREE.Material.prototype.clone.call(this, a);
  a.color.copy(this.color);
  a.linewidth = this.linewidth;
  a.linecap = this.linecap;
  a.linejoin = this.linejoin;
  a.vertexColors = this.vertexColors;
  a.fog = this.fog;
  return a;
};
THREE.LineDashedMaterial = function (a) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.scale = this.linewidth = 1;
  this.dashSize = 3;
  this.gapSize = 1;
  this.vertexColors = !1;
  this.fog = !0;
  this.setValues(a);
};
THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.LineDashedMaterial.prototype.clone = function () {
  var a = new THREE.LineDashedMaterial();
  THREE.Material.prototype.clone.call(this, a);
  a.color.copy(this.color);
  a.linewidth = this.linewidth;
  a.scale = this.scale;
  a.dashSize = this.dashSize;
  a.gapSize = this.gapSize;
  a.vertexColors = this.vertexColors;
  a.fog = this.fog;
  return a;
};
THREE.MeshBasicMaterial = function (a) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.envMap = this.specularMap = this.lightMap = this.map = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.fog = !0;
  this.shading = THREE.SmoothShading;
  this.wireframe = !1;
  this.wireframeLinewidth = 1;
  this.wireframeLinejoin = this.wireframeLinecap = 'round';
  this.vertexColors = THREE.NoColors;
  this.morphTargets = this.skinning = !1;
  this.setValues(a);
};
THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshBasicMaterial.prototype.clone = function () {
  var a = new THREE.MeshBasicMaterial();
  THREE.Material.prototype.clone.call(this, a);
  a.color.copy(this.color);
  a.map = this.map;
  a.lightMap = this.lightMap;
  a.specularMap = this.specularMap;
  a.envMap = this.envMap;
  a.combine = this.combine;
  a.reflectivity = this.reflectivity;
  a.refractionRatio = this.refractionRatio;
  a.fog = this.fog;
  a.shading = this.shading;
  a.wireframe = this.wireframe;
  a.wireframeLinewidth = this.wireframeLinewidth;
  a.wireframeLinecap = this.wireframeLinecap;
  a.wireframeLinejoin = this.wireframeLinejoin;
  a.vertexColors = this.vertexColors;
  a.skinning = this.skinning;
  a.morphTargets = this.morphTargets;
  return a;
};
THREE.MeshLambertMaterial = function (a) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.ambient = new THREE.Color(16777215);
  this.emissive = new THREE.Color(0);
  this.wrapAround = !1;
  this.wrapRGB = new THREE.Vector3(1, 1, 1);
  this.envMap = this.specularMap = this.lightMap = this.map = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.fog = !0;
  this.shading = THREE.SmoothShading;
  this.wireframe = !1;
  this.wireframeLinewidth = 1;
  this.wireframeLinejoin = this.wireframeLinecap = 'round';
  this.vertexColors = THREE.NoColors;
  this.morphNormals = this.morphTargets = this.skinning = !1;
  this.setValues(a);
};
THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshLambertMaterial.prototype.clone = function () {
  var a = new THREE.MeshLambertMaterial();
  THREE.Material.prototype.clone.call(this, a);
  a.color.copy(this.color);
  a.ambient.copy(this.ambient);
  a.emissive.copy(this.emissive);
  a.wrapAround = this.wrapAround;
  a.wrapRGB.copy(this.wrapRGB);
  a.map = this.map;
  a.lightMap = this.lightMap;
  a.specularMap = this.specularMap;
  a.envMap = this.envMap;
  a.combine = this.combine;
  a.reflectivity = this.reflectivity;
  a.refractionRatio = this.refractionRatio;
  a.fog = this.fog;
  a.shading = this.shading;
  a.wireframe = this.wireframe;
  a.wireframeLinewidth = this.wireframeLinewidth;
  a.wireframeLinecap = this.wireframeLinecap;
  a.wireframeLinejoin = this.wireframeLinejoin;
  a.vertexColors = this.vertexColors;
  a.skinning = this.skinning;
  a.morphTargets = this.morphTargets;
  a.morphNormals = this.morphNormals;
  return a;
};
THREE.MeshPhongMaterial = function (a) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.ambient = new THREE.Color(16777215);
  this.emissive = new THREE.Color(0);
  this.specular = new THREE.Color(1118481);
  this.shininess = 30;
  this.wrapAround = this.metal = !1;
  this.wrapRGB = new THREE.Vector3(1, 1, 1);
  this.bumpMap = this.lightMap = this.map = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalScale = new THREE.Vector2(1, 1);
  this.envMap = this.specularMap = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;
  this.fog = !0;
  this.shading = THREE.SmoothShading;
  this.wireframe = !1;
  this.wireframeLinewidth = 1;
  this.wireframeLinejoin = this.wireframeLinecap = 'round';
  this.vertexColors = THREE.NoColors;
  this.morphNormals = this.morphTargets = this.skinning = !1;
  this.setValues(a);
};
THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshPhongMaterial.prototype.clone = function () {
  var a = new THREE.MeshPhongMaterial();
  THREE.Material.prototype.clone.call(this, a);
  a.color.copy(this.color);
  a.ambient.copy(this.ambient);
  a.emissive.copy(this.emissive);
  a.specular.copy(this.specular);
  a.shininess = this.shininess;
  a.metal = this.metal;
  a.wrapAround = this.wrapAround;
  a.wrapRGB.copy(this.wrapRGB);
  a.map = this.map;
  a.lightMap = this.lightMap;
  a.bumpMap = this.bumpMap;
  a.bumpScale = this.bumpScale;
  a.normalMap = this.normalMap;
  a.normalScale.copy(this.normalScale);
  a.specularMap = this.specularMap;
  a.envMap = this.envMap;
  a.combine = this.combine;
  a.reflectivity = this.reflectivity;
  a.refractionRatio = this.refractionRatio;
  a.fog = this.fog;
  a.shading = this.shading;
  a.wireframe = this.wireframe;
  a.wireframeLinewidth = this.wireframeLinewidth;
  a.wireframeLinecap = this.wireframeLinecap;
  a.wireframeLinejoin = this.wireframeLinejoin;
  a.vertexColors = this.vertexColors;
  a.skinning = this.skinning;
  a.morphTargets = this.morphTargets;
  a.morphNormals = this.morphNormals;
  return a;
};
THREE.MeshDepthMaterial = function (a) {
  THREE.Material.call(this);
  this.wireframe = !1;
  this.wireframeLinewidth = 1;
  this.setValues(a);
};
THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshDepthMaterial.prototype.clone = function () {
  var a = new THREE.MeshDepthMaterial();
  THREE.Material.prototype.clone.call(this, a);
  a.wireframe = this.wireframe;
  a.wireframeLinewidth = this.wireframeLinewidth;
  return a;
};
THREE.MeshNormalMaterial = function (a) {
  THREE.Material.call(this, a);
  this.shading = THREE.FlatShading;
  this.wireframe = !1;
  this.wireframeLinewidth = 1;
  this.morphTargets = !1;
  this.setValues(a);
};
THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshNormalMaterial.prototype.clone = function () {
  var a = new THREE.MeshNormalMaterial();
  THREE.Material.prototype.clone.call(this, a);
  a.shading = this.shading;
  a.wireframe = this.wireframe;
  a.wireframeLinewidth = this.wireframeLinewidth;
  return a;
};
THREE.MeshFaceMaterial = function (a) {
  this.materials = a instanceof Array ? a : [];
};
THREE.MeshFaceMaterial.prototype.clone = function () {
  for (var a = new THREE.MeshFaceMaterial(), b = 0; b < this.materials.length; b++)
    a.materials.push(this.materials[b].clone());
  return a;
};
THREE.ParticleSystemMaterial = function (a) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.map = null;
  this.size = 1;
  this.sizeAttenuation = !0;
  this.vertexColors = !1;
  this.fog = !0;
  this.setValues(a);
};
THREE.ParticleSystemMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.ParticleSystemMaterial.prototype.clone = function () {
  var a = new THREE.ParticleSystemMaterial();
  THREE.Material.prototype.clone.call(this, a);
  a.color.copy(this.color);
  a.map = this.map;
  a.size = this.size;
  a.sizeAttenuation = this.sizeAttenuation;
  a.vertexColors = this.vertexColors;
  a.fog = this.fog;
  return a;
};
THREE.ParticleBasicMaterial = THREE.ParticleSystemMaterial;
THREE.ShaderMaterial = function (a) {
  THREE.Material.call(this);
  this.vertexShader = this.fragmentShader = 'void main() {}';
  this.uniforms = {};
  this.defines = {};
  this.attributes = null;
  this.shading = THREE.SmoothShading;
  this.linewidth = 1;
  this.wireframe = !1;
  this.wireframeLinewidth = 1;
  this.lights = this.fog = !1;
  this.vertexColors = THREE.NoColors;
  this.morphNormals = this.morphTargets = this.skinning = !1;
  this.defaultAttributeValues = {
    color: [
      1,
      1,
      1
    ],
    uv: [
      0,
      0
    ],
    uv2: [
      0,
      0
    ]
  };
  this.index0AttributeName = 'position';
  this.setValues(a);
};
THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.ShaderMaterial.prototype.clone = function () {
  var a = new THREE.ShaderMaterial();
  THREE.Material.prototype.clone.call(this, a);
  a.fragmentShader = this.fragmentShader;
  a.vertexShader = this.vertexShader;
  a.uniforms = THREE.UniformsUtils.clone(this.uniforms);
  a.attributes = this.attributes;
  a.defines = this.defines;
  a.shading = this.shading;
  a.wireframe = this.wireframe;
  a.wireframeLinewidth = this.wireframeLinewidth;
  a.fog = this.fog;
  a.lights = this.lights;
  a.vertexColors = this.vertexColors;
  a.skinning = this.skinning;
  a.morphTargets = this.morphTargets;
  a.morphNormals = this.morphNormals;
  return a;
};
THREE.SpriteMaterial = function (a) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.map = null;
  this.rotation = 0;
  this.fog = !1;
  this.setValues(a);
};
THREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.SpriteMaterial.prototype.clone = function () {
  var a = new THREE.SpriteMaterial();
  THREE.Material.prototype.clone.call(this, a);
  a.color.copy(this.color);
  a.map = this.map;
  a.rotation = this.rotation;
  a.fog = this.fog;
  return a;
};
THREE.SpriteCanvasMaterial = function (a) {
  THREE.Material.call(this);
  this.color = new THREE.Color(16777215);
  this.program = function (a, c) {
  };
  this.setValues(a);
};
THREE.SpriteCanvasMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.SpriteCanvasMaterial.prototype.clone = function () {
  var a = new THREE.SpriteCanvasMaterial();
  THREE.Material.prototype.clone.call(this, a);
  a.color.copy(this.color);
  a.program = this.program;
  return a;
};
THREE.ParticleCanvasMaterial = THREE.SpriteCanvasMaterial;
THREE.Texture = function (a, b, c, d, e, f, g, h, k) {
  this.id = THREE.TextureIdCount++;
  this.uuid = THREE.Math.generateUUID();
  this.name = '';
  this.image = a;
  this.mipmaps = [];
  this.mapping = void 0 !== b ? b : new THREE.UVMapping();
  this.wrapS = void 0 !== c ? c : THREE.ClampToEdgeWrapping;
  this.wrapT = void 0 !== d ? d : THREE.ClampToEdgeWrapping;
  this.magFilter = void 0 !== e ? e : THREE.LinearFilter;
  this.minFilter = void 0 !== f ? f : THREE.LinearMipMapLinearFilter;
  this.anisotropy = void 0 !== k ? k : 1;
  this.format = void 0 !== g ? g : THREE.RGBAFormat;
  this.type = void 0 !== h ? h : THREE.UnsignedByteType;
  this.offset = new THREE.Vector2(0, 0);
  this.repeat = new THREE.Vector2(1, 1);
  this.generateMipmaps = !0;
  this.premultiplyAlpha = !1;
  this.flipY = !0;
  this.unpackAlignment = 4;
  this._needsUpdate = !1;
  this.onUpdate = null;
};
THREE.Texture.prototype = {
  constructor: THREE.Texture,
  get needsUpdate() {
    return this._needsUpdate;
  },
  set needsUpdate(a) {
    !0 === a && this.update();
    this._needsUpdate = a;
  },
  clone: function (a) {
    void 0 === a && (a = new THREE.Texture());
    a.image = this.image;
    a.mipmaps = this.mipmaps.slice(0);
    a.mapping = this.mapping;
    a.wrapS = this.wrapS;
    a.wrapT = this.wrapT;
    a.magFilter = this.magFilter;
    a.minFilter = this.minFilter;
    a.anisotropy = this.anisotropy;
    a.format = this.format;
    a.type = this.type;
    a.offset.copy(this.offset);
    a.repeat.copy(this.repeat);
    a.generateMipmaps = this.generateMipmaps;
    a.premultiplyAlpha = this.premultiplyAlpha;
    a.flipY = this.flipY;
    a.unpackAlignment = this.unpackAlignment;
    return a;
  },
  update: function () {
    this.dispatchEvent({ type: 'update' });
  },
  dispose: function () {
    this.dispatchEvent({ type: 'dispose' });
  }
};
THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype);
THREE.TextureIdCount = 0;
THREE.CompressedTexture = function (a, b, c, d, e, f, g, h, k, l, n) {
  THREE.Texture.call(this, null, f, g, h, k, l, d, e, n);
  this.image = {
    width: b,
    height: c
  };
  this.mipmaps = a;
  this.generateMipmaps = !1;
};
THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.CompressedTexture.prototype.clone = function () {
  var a = new THREE.CompressedTexture();
  THREE.Texture.prototype.clone.call(this, a);
  return a;
};
THREE.DataTexture = function (a, b, c, d, e, f, g, h, k, l, n) {
  THREE.Texture.call(this, null, f, g, h, k, l, d, e, n);
  this.image = {
    data: a,
    width: b,
    height: c
  };
};
THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.DataTexture.prototype.clone = function () {
  var a = new THREE.DataTexture();
  THREE.Texture.prototype.clone.call(this, a);
  return a;
};
THREE.ParticleSystem = function (a, b) {
  THREE.Object3D.call(this);
  this.geometry = void 0 !== a ? a : new THREE.Geometry();
  this.material = void 0 !== b ? b : new THREE.ParticleSystemMaterial({ color: 16777215 * Math.random() });
  this.frustumCulled = this.sortParticles = !1;
};
THREE.ParticleSystem.prototype = Object.create(THREE.Object3D.prototype);
THREE.ParticleSystem.prototype.clone = function (a) {
  void 0 === a && (a = new THREE.ParticleSystem(this.geometry, this.material));
  a.sortParticles = this.sortParticles;
  THREE.Object3D.prototype.clone.call(this, a);
  return a;
};
THREE.Line = function (a, b, c) {
  THREE.Object3D.call(this);
  this.geometry = void 0 !== a ? a : new THREE.Geometry();
  this.material = void 0 !== b ? b : new THREE.LineBasicMaterial({ color: 16777215 * Math.random() });
  this.type = void 0 !== c ? c : THREE.LineStrip;
};
THREE.LineStrip = 0;
THREE.LinePieces = 1;
THREE.Line.prototype = Object.create(THREE.Object3D.prototype);
THREE.Line.prototype.clone = function (a) {
  void 0 === a && (a = new THREE.Line(this.geometry, this.material, this.type));
  THREE.Object3D.prototype.clone.call(this, a);
  return a;
};
THREE.Mesh = function (a, b) {
  THREE.Object3D.call(this);
  this.geometry = void 0 !== a ? a : new THREE.Geometry();
  this.material = void 0 !== b ? b : new THREE.MeshBasicMaterial({ color: 16777215 * Math.random() });
  this.updateMorphTargets();
};
THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype);
THREE.Mesh.prototype.updateMorphTargets = function () {
  if (void 0 !== this.geometry.morphTargets && 0 < this.geometry.morphTargets.length) {
    this.morphTargetBase = -1;
    this.morphTargetForcedOrder = [];
    this.morphTargetInfluences = [];
    this.morphTargetDictionary = {};
    for (var a = 0, b = this.geometry.morphTargets.length; a < b; a++)
      this.morphTargetInfluences.push(0), this.morphTargetDictionary[this.geometry.morphTargets[a].name] = a;
  }
};
THREE.Mesh.prototype.getMorphTargetIndexByName = function (a) {
  if (void 0 !== this.morphTargetDictionary[a])
    return this.morphTargetDictionary[a];
  console.log('THREE.Mesh.getMorphTargetIndexByName: morph target ' + a + ' does not exist. Returning 0.');
  return 0;
};
THREE.Mesh.prototype.clone = function (a) {
  void 0 === a && (a = new THREE.Mesh(this.geometry, this.material));
  THREE.Object3D.prototype.clone.call(this, a);
  return a;
};
THREE.Bone = function (a) {
  THREE.Object3D.call(this);
  this.skin = a;
  this.skinMatrix = new THREE.Matrix4();
};
THREE.Bone.prototype = Object.create(THREE.Object3D.prototype);
THREE.Bone.prototype.update = function (a, b) {
  this.matrixAutoUpdate && (b |= this.updateMatrix());
  if (b || this.matrixWorldNeedsUpdate)
    a ? this.skinMatrix.multiplyMatrices(a, this.matrix) : this.skinMatrix.copy(this.matrix), this.matrixWorldNeedsUpdate = !1, b = !0;
  var c, d = this.children.length;
  for (c = 0; c < d; c++)
    this.children[c].update(this.skinMatrix, b);
};
THREE.SkinnedMesh = function (a, b, c) {
  THREE.Mesh.call(this, a, b);
  this.useVertexTexture = void 0 !== c ? c : !0;
  this.identityMatrix = new THREE.Matrix4();
  this.bones = [];
  this.boneMatrices = [];
  var d, e, f;
  if (this.geometry && void 0 !== this.geometry.bones) {
    for (a = 0; a < this.geometry.bones.length; a++)
      c = this.geometry.bones[a], d = c.pos, e = c.rotq, f = c.scl, b = this.addBone(), b.name = c.name, b.position.set(d[0], d[1], d[2]), b.quaternion.set(e[0], e[1], e[2], e[3]), void 0 !== f ? b.scale.set(f[0], f[1], f[2]) : b.scale.set(1, 1, 1);
    for (a = 0; a < this.bones.length; a++)
      c = this.geometry.bones[a], b = this.bones[a], -1 === c.parent ? this.add(b) : this.bones[c.parent].add(b);
    a = this.bones.length;
    this.useVertexTexture ? (this.boneTextureHeight = this.boneTextureWidth = a = 256 < a ? 64 : 64 < a ? 32 : 16 < a ? 16 : 8, this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4), this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType), this.boneTexture.minFilter = THREE.NearestFilter, this.boneTexture.magFilter = THREE.NearestFilter, this.boneTexture.generateMipmaps = !1, this.boneTexture.flipY = !1) : this.boneMatrices = new Float32Array(16 * a);
    this.pose();
  }
};
THREE.SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype);
THREE.SkinnedMesh.prototype.addBone = function (a) {
  void 0 === a && (a = new THREE.Bone(this));
  this.bones.push(a);
  return a;
};
THREE.SkinnedMesh.prototype.updateMatrixWorld = function () {
  var a = new THREE.Matrix4();
  return function (b) {
    this.matrixAutoUpdate && this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || b)
      this.parent ? this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix) : this.matrixWorld.copy(this.matrix), this.matrixWorldNeedsUpdate = !1;
    b = 0;
    for (var c = this.children.length; b < c; b++) {
      var d = this.children[b];
      d instanceof THREE.Bone ? d.update(this.identityMatrix, !1) : d.updateMatrixWorld(!0);
    }
    if (void 0 == this.boneInverses)
      for (this.boneInverses = [], b = 0, c = this.bones.length; b < c; b++)
        d = new THREE.Matrix4(), d.getInverse(this.bones[b].skinMatrix), this.boneInverses.push(d);
    b = 0;
    for (c = this.bones.length; b < c; b++)
      a.multiplyMatrices(this.bones[b].skinMatrix, this.boneInverses[b]), a.flattenToArrayOffset(this.boneMatrices, 16 * b);
    this.useVertexTexture && (this.boneTexture.needsUpdate = !0);
  };
}();
THREE.SkinnedMesh.prototype.pose = function () {
  this.updateMatrixWorld(!0);
  this.normalizeSkinWeights();
};
THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {
  if (this.geometry instanceof THREE.Geometry)
    for (var a = 0; a < this.geometry.skinIndices.length; a++) {
      var b = this.geometry.skinWeights[a], c = 1 / b.lengthManhattan();
      Infinity !== c ? b.multiplyScalar(c) : b.set(1);
    }
};
THREE.SkinnedMesh.prototype.clone = function (a) {
  void 0 === a && (a = new THREE.SkinnedMesh(this.geometry, this.material, this.useVertexTexture));
  THREE.Mesh.prototype.clone.call(this, a);
  return a;
};
THREE.MorphAnimMesh = function (a, b) {
  THREE.Mesh.call(this, a, b);
  this.duration = 1000;
  this.mirroredLoop = !1;
  this.currentKeyframe = this.lastKeyframe = this.time = 0;
  this.direction = 1;
  this.directionBackwards = !1;
  this.setFrameRange(0, this.geometry.morphTargets.length - 1);
};
THREE.MorphAnimMesh.prototype = Object.create(THREE.Mesh.prototype);
THREE.MorphAnimMesh.prototype.setFrameRange = function (a, b) {
  this.startKeyframe = a;
  this.endKeyframe = b;
  this.length = this.endKeyframe - this.startKeyframe + 1;
};
THREE.MorphAnimMesh.prototype.setDirectionForward = function () {
  this.direction = 1;
  this.directionBackwards = !1;
};
THREE.MorphAnimMesh.prototype.setDirectionBackward = function () {
  this.direction = -1;
  this.directionBackwards = !0;
};
THREE.MorphAnimMesh.prototype.parseAnimations = function () {
  var a = this.geometry;
  a.animations || (a.animations = {});
  for (var b, c = a.animations, d = /([a-z]+)(\d+)/, e = 0, f = a.morphTargets.length; e < f; e++) {
    var g = a.morphTargets[e].name.match(d);
    if (g && 1 < g.length) {
      g = g[1];
      c[g] || (c[g] = {
        start: Infinity,
        end: -Infinity
      });
      var h = c[g];
      e < h.start && (h.start = e);
      e > h.end && (h.end = e);
      b || (b = g);
    }
  }
  a.firstAnimation = b;
};
THREE.MorphAnimMesh.prototype.setAnimationLabel = function (a, b, c) {
  this.geometry.animations || (this.geometry.animations = {});
  this.geometry.animations[a] = {
    start: b,
    end: c
  };
};
THREE.MorphAnimMesh.prototype.playAnimation = function (a, b) {
  var c = this.geometry.animations[a];
  c ? (this.setFrameRange(c.start, c.end), this.duration = (c.end - c.start) / b * 1000, this.time = 0) : console.warn('animation[' + a + '] undefined');
};
THREE.MorphAnimMesh.prototype.updateAnimation = function (a) {
  var b = this.duration / this.length;
  this.time += this.direction * a;
  if (this.mirroredLoop) {
    if (this.time > this.duration || 0 > this.time)
      this.direction *= -1, this.time > this.duration && (this.time = this.duration, this.directionBackwards = !0), 0 > this.time && (this.time = 0, this.directionBackwards = !1);
  } else
    this.time %= this.duration, 0 > this.time && (this.time += this.duration);
  a = this.startKeyframe + THREE.Math.clamp(Math.floor(this.time / b), 0, this.length - 1);
  a !== this.currentKeyframe && (this.morphTargetInfluences[this.lastKeyframe] = 0, this.morphTargetInfluences[this.currentKeyframe] = 1, this.morphTargetInfluences[a] = 0, this.lastKeyframe = this.currentKeyframe, this.currentKeyframe = a);
  b = this.time % b / b;
  this.directionBackwards && (b = 1 - b);
  this.morphTargetInfluences[this.currentKeyframe] = b;
  this.morphTargetInfluences[this.lastKeyframe] = 1 - b;
};
THREE.MorphAnimMesh.prototype.clone = function (a) {
  void 0 === a && (a = new THREE.MorphAnimMesh(this.geometry, this.material));
  a.duration = this.duration;
  a.mirroredLoop = this.mirroredLoop;
  a.time = this.time;
  a.lastKeyframe = this.lastKeyframe;
  a.currentKeyframe = this.currentKeyframe;
  a.direction = this.direction;
  a.directionBackwards = this.directionBackwards;
  THREE.Mesh.prototype.clone.call(this, a);
  return a;
};
THREE.LOD = function () {
  THREE.Object3D.call(this);
  this.objects = [];
};
THREE.LOD.prototype = Object.create(THREE.Object3D.prototype);
THREE.LOD.prototype.addLevel = function (a, b) {
  void 0 === b && (b = 0);
  b = Math.abs(b);
  for (var c = 0; c < this.objects.length && !(b < this.objects[c].distance); c++);
  this.objects.splice(c, 0, {
    distance: b,
    object: a
  });
  this.add(a);
};
THREE.LOD.prototype.getObjectForDistance = function (a) {
  for (var b = 1, c = this.objects.length; b < c && !(a < this.objects[b].distance); b++);
  return this.objects[b - 1].object;
};
THREE.LOD.prototype.update = function () {
  var a = new THREE.Vector3(), b = new THREE.Vector3();
  return function (c) {
    if (1 < this.objects.length) {
      a.setFromMatrixPosition(c.matrixWorld);
      b.setFromMatrixPosition(this.matrixWorld);
      c = a.distanceTo(b);
      this.objects[0].object.visible = !0;
      for (var d = 1, e = this.objects.length; d < e; d++)
        if (c >= this.objects[d].distance)
          this.objects[d - 1].object.visible = !1, this.objects[d].object.visible = !0;
        else
          break;
      for (; d < e; d++)
        this.objects[d].object.visible = !1;
    }
  };
}();
THREE.LOD.prototype.clone = function (a) {
  void 0 === a && (a = new THREE.LOD());
  THREE.Object3D.prototype.clone.call(this, a);
  for (var b = 0, c = this.objects.length; b < c; b++) {
    var d = this.objects[b].object.clone();
    d.visible = 0 === b;
    a.addLevel(d, this.objects[b].distance);
  }
  return a;
};
THREE.Sprite = function () {
  var a = new THREE.Geometry2(3);
  a.vertices.set([
    -0.5,
    -0.5,
    0,
    0.5,
    -0.5,
    0,
    0.5,
    0.5,
    0
  ]);
  return function (b) {
    THREE.Object3D.call(this);
    this.geometry = a;
    this.material = void 0 !== b ? b : new THREE.SpriteMaterial();
  };
}();
THREE.Sprite.prototype = Object.create(THREE.Object3D.prototype);
THREE.Sprite.prototype.updateMatrix = function () {
  this.matrix.compose(this.position, this.quaternion, this.scale);
  this.matrixWorldNeedsUpdate = !0;
};
THREE.Sprite.prototype.clone = function (a) {
  void 0 === a && (a = new THREE.Sprite(this.material));
  THREE.Object3D.prototype.clone.call(this, a);
  return a;
};
THREE.Particle = THREE.Sprite;
THREE.Scene = function () {
  THREE.Object3D.call(this);
  this.overrideMaterial = this.fog = null;
  this.autoUpdate = !0;
  this.matrixAutoUpdate = !1;
  this.__lights = [];
  this.__objectsAdded = [];
  this.__objectsRemoved = [];
};
THREE.Scene.prototype = Object.create(THREE.Object3D.prototype);
THREE.Scene.prototype.__addObject = function (a) {
  if (a instanceof THREE.Light)
    -1 === this.__lights.indexOf(a) && this.__lights.push(a), a.target && void 0 === a.target.parent && this.add(a.target);
  else if (!(a instanceof THREE.Camera || a instanceof THREE.Bone)) {
    this.__objectsAdded.push(a);
    var b = this.__objectsRemoved.indexOf(a);
    -1 !== b && this.__objectsRemoved.splice(b, 1);
  }
  this.dispatchEvent({
    type: 'objectAdded',
    object: a
  });
  a.dispatchEvent({
    type: 'addedToScene',
    scene: this
  });
  for (b = 0; b < a.children.length; b++)
    this.__addObject(a.children[b]);
};
THREE.Scene.prototype.__removeObject = function (a) {
  if (a instanceof THREE.Light) {
    var b = this.__lights.indexOf(a);
    -1 !== b && this.__lights.splice(b, 1);
    if (a.shadowCascadeArray)
      for (b = 0; b < a.shadowCascadeArray.length; b++)
        this.__removeObject(a.shadowCascadeArray[b]);
  } else
    a instanceof THREE.Camera || (this.__objectsRemoved.push(a), b = this.__objectsAdded.indexOf(a), -1 !== b && this.__objectsAdded.splice(b, 1));
  this.dispatchEvent({
    type: 'objectRemoved',
    object: a
  });
  a.dispatchEvent({
    type: 'removedFromScene',
    scene: this
  });
  for (b = 0; b < a.children.length; b++)
    this.__removeObject(a.children[b]);
};
THREE.Scene.prototype.clone = function (a) {
  void 0 === a && (a = new THREE.Scene());
  THREE.Object3D.prototype.clone.call(this, a);
  null !== this.fog && (a.fog = this.fog.clone());
  null !== this.overrideMaterial && (a.overrideMaterial = this.overrideMaterial.clone());
  a.autoUpdate = this.autoUpdate;
  a.matrixAutoUpdate = this.matrixAutoUpdate;
  return a;
};
THREE.Fog = function (a, b, c) {
  this.name = '';
  this.color = new THREE.Color(a);
  this.near = void 0 !== b ? b : 1;
  this.far = void 0 !== c ? c : 1000;
};
THREE.Fog.prototype.clone = function () {
  return new THREE.Fog(this.color.getHex(), this.near, this.far);
};
THREE.FogExp2 = function (a, b) {
  this.name = '';
  this.color = new THREE.Color(a);
  this.density = void 0 !== b ? b : 0.00025;
};
THREE.FogExp2.prototype.clone = function () {
  return new THREE.FogExp2(this.color.getHex(), this.density);
};
THREE.CanvasRenderer = function (a) {
  function b(a, b, c) {
    for (var d = 0, e = E.length; d < e; d++) {
      var f = E[d];
      Ka.copy(f.color);
      if (f instanceof THREE.DirectionalLight) {
        var g = Na.setFromMatrixPosition(f.matrixWorld).normalize(), h = b.dot(g);
        0 >= h || (h *= f.intensity, c.add(Ka.multiplyScalar(h)));
      } else
        f instanceof THREE.PointLight && (g = Na.setFromMatrixPosition(f.matrixWorld), h = b.dot(Na.subVectors(g, a).normalize()), 0 >= h || (h *= 0 == f.distance ? 1 : 1 - Math.min(a.distanceTo(g) / f.distance, 1), 0 != h && (h *= f.intensity, c.add(Ka.multiplyScalar(h)))));
    }
  }
  function c(a, b, c, d) {
    r(b);
    q(c);
    u(d);
    p(a.getStyle());
    y.stroke();
    Oa.expandByScalar(2 * b);
  }
  function d(a) {
    v(a.getStyle());
    y.fill();
  }
  function e(a) {
    f(a.target);
  }
  function f(a) {
    var b = a.wrapS === THREE.RepeatWrapping, c = a.wrapT === THREE.RepeatWrapping, d = a.image, e = document.createElement('canvas');
    e.width = d.width;
    e.height = d.height;
    var f = e.getContext('2d');
    f.setTransform(1, 0, 0, -1, 0, d.height);
    f.drawImage(d, 0, 0);
    la[a.id] = y.createPattern(e, !0 === b && !0 === c ? 'repeat' : !0 === b && !1 === c ? 'repeat-x' : !1 === b && !0 === c ? 'repeat-y' : 'no-repeat');
  }
  function g(a, b, c, d, g, h, k, m, l, n, p, r, q) {
    if (!(q instanceof THREE.DataTexture)) {
      !1 === q.hasEventListener('update', e) && (void 0 !== q.image && 0 < q.image.width && f(q), q.addEventListener('update', e));
      var s = la[q.id];
      if (void 0 !== s) {
        v(s);
        var s = q.offset.x / q.repeat.x, u = q.offset.y / q.repeat.y, Nb = q.image.width * q.repeat.x;
        q = q.image.height * q.repeat.y;
        k = (k + s) * Nb;
        m = (m + u) * q;
        c -= a;
        d -= b;
        g -= a;
        h -= b;
        l = (l + s) * Nb - k;
        n = (n + u) * q - m;
        p = (p + s) * Nb - k;
        r = (r + u) * q - m;
        q = l * r - p * n;
        0 !== q && (s = 1 / q, q = (r * c - n * g) * s, n = (r * d - n * h) * s, c = (l * g - p * c) * s, d = (l * h - p * d) * s, a = a - q * k - c * m, b = b - n * k - d * m, y.save(), y.transform(q, n, c, d, a, b), y.fill(), y.restore());
      } else
        v('rgba(0,0,0,1)'), y.fill();
    }
  }
  function h(a, b, c, d, e, f, g, h, k, m, l, n, p) {
    var q, r;
    q = p.width - 1;
    r = p.height - 1;
    g *= q;
    h *= r;
    c -= a;
    d -= b;
    e -= a;
    f -= b;
    k = k * q - g;
    m = m * r - h;
    l = l * q - g;
    n = n * r - h;
    r = 1 / (k * n - l * m);
    q = (n * c - m * e) * r;
    m = (n * d - m * f) * r;
    c = (k * e - l * c) * r;
    d = (k * f - l * d) * r;
    a = a - q * g - c * h;
    b = b - m * g - d * h;
    y.save();
    y.transform(q, m, c, d, a, b);
    y.clip();
    y.drawImage(p, 0, 0);
    y.restore();
  }
  function k(a, b, c, d) {
    qa[0] = 255 * a.r | 0;
    qa[1] = 255 * a.g | 0;
    qa[2] = 255 * a.b | 0;
    qa[4] = 255 * b.r | 0;
    qa[5] = 255 * b.g | 0;
    qa[6] = 255 * b.b | 0;
    qa[8] = 255 * c.r | 0;
    qa[9] = 255 * c.g | 0;
    qa[10] = 255 * c.b | 0;
    qa[12] = 255 * d.r | 0;
    qa[13] = 255 * d.g | 0;
    qa[14] = 255 * d.b | 0;
    Ma.putImageData(Pa, 0, 0);
    qb.drawImage(Qa, 0, 0);
    return cb;
  }
  function l(a, b, c) {
    var d = b.x - a.x, e = b.y - a.y, f = d * d + e * e;
    0 !== f && (c /= Math.sqrt(f), d *= c, e *= c, b.x += d, b.y += e, a.x -= d, a.y -= e);
  }
  function n(a) {
    A !== a && (A = y.globalAlpha = a);
  }
  function s(a) {
    L !== a && (a === THREE.NormalBlending ? y.globalCompositeOperation = 'source-over' : a === THREE.AdditiveBlending ? y.globalCompositeOperation = 'lighter' : a === THREE.SubtractiveBlending && (y.globalCompositeOperation = 'darker'), L = a);
  }
  function r(a) {
    R !== a && (R = y.lineWidth = a);
  }
  function q(a) {
    fa !== a && (fa = y.lineCap = a);
  }
  function u(a) {
    V !== a && (V = y.lineJoin = a);
  }
  function p(a) {
    Q !== a && (Q = y.strokeStyle = a);
  }
  function v(a) {
    Y !== a && (Y = y.fillStyle = a);
  }
  function w(a, b) {
    if (ga !== a || J !== b)
      y.setLineDash([
        a,
        b
      ]), ga = a, J = b;
  }
  console.log('THREE.CanvasRenderer', THREE.REVISION);
  var t = THREE.Math.smoothstep;
  a = a || {};
  var x = this, z, B, E, H = new THREE.Projector(), D = void 0 !== a.canvas ? a.canvas : document.createElement('canvas'), G = D.width, I = D.height, O = Math.floor(G / 2), K = Math.floor(I / 2), y = D.getContext('2d', { alpha: !0 === a.alpha }), F = new THREE.Color(0), C = 0, A = 1, L = 0, Q = null, Y = null, R = null, fa = null, V = null, ga = null, J = 0, da, W, N, ca;
  new THREE.RenderableVertex();
  new THREE.RenderableVertex();
  var sa, T, Ja, S, $, Fa, ta = new THREE.Color(), oa = new THREE.Color(), za = new THREE.Color(), Aa = new THREE.Color(), Ua = new THREE.Color(), Va = new THREE.Color(), ka = new THREE.Color(), Ka = new THREE.Color(), la = {}, Ba, Ia, ma, Ca, ba, wa, xa, Da, Wa, La, Ea = new THREE.Box2(), na = new THREE.Box2(), Oa = new THREE.Box2(), hb = new THREE.Color(), ya = new THREE.Color(), ia = new THREE.Color(), Na = new THREE.Vector3(), ha = new THREE.Vector3(), m = new THREE.Matrix3(), Qa, Ma, Pa, qa, cb, qb, db = 16;
  Qa = document.createElement('canvas');
  Qa.width = Qa.height = 2;
  Ma = Qa.getContext('2d');
  Ma.fillStyle = 'rgba(0,0,0,1)';
  Ma.fillRect(0, 0, 2, 2);
  Pa = Ma.getImageData(0, 0, 2, 2);
  qa = Pa.data;
  cb = document.createElement('canvas');
  cb.width = cb.height = db;
  qb = cb.getContext('2d');
  qb.translate(-db / 2, -db / 2);
  qb.scale(db, db);
  db--;
  void 0 === y.setLineDash && (y.setLineDash = void 0 !== y.mozDash ? function (a) {
    y.mozDash = null !== a[0] ? a : null;
  } : function () {
  });
  this.domElement = D;
  this.devicePixelRatio = void 0 !== a.devicePixelRatio ? a.devicePixelRatio : void 0 !== self.devicePixelRatio ? self.devicePixelRatio : 1;
  this.sortElements = this.sortObjects = this.autoClear = !0;
  this.info = {
    render: {
      vertices: 0,
      faces: 0
    }
  };
  this.supportsVertexTextures = function () {
  };
  this.setFaceCulling = function () {
  };
  this.setSize = function (a, b, c) {
    G = a * this.devicePixelRatio;
    I = b * this.devicePixelRatio;
    O = Math.floor(G / 2);
    K = Math.floor(I / 2);
    D.width = G;
    D.height = I;
    1 !== this.devicePixelRatio && !1 !== c && (D.style.width = a + 'px', D.style.height = b + 'px');
    Ea.min.set(-O, -K);
    Ea.max.set(O, K);
    na.min.set(-O, -K);
    na.max.set(O, K);
    A = 1;
    L = 0;
    V = fa = R = Y = Q = null;
  };
  this.setClearColor = function (a, b) {
    F.set(a);
    C = void 0 !== b ? b : 1;
    na.min.set(-O, -K);
    na.max.set(O, K);
  };
  this.setClearColorHex = function (a, b) {
    console.warn('DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.');
    this.setClearColor(a, b);
  };
  this.getMaxAnisotropy = function () {
    return 0;
  };
  this.clear = function () {
    y.setTransform(1, 0, 0, -1, O, K);
    !1 === na.empty() && (na.intersect(Ea), na.expandByScalar(2), 1 > C && y.clearRect(na.min.x | 0, na.min.y | 0, na.max.x - na.min.x | 0, na.max.y - na.min.y | 0), 0 < C && (s(THREE.NormalBlending), n(1), v('rgba(' + Math.floor(255 * F.r) + ',' + Math.floor(255 * F.g) + ',' + Math.floor(255 * F.b) + ',' + C + ')'), y.fillRect(na.min.x | 0, na.min.y | 0, na.max.x - na.min.x | 0, na.max.y - na.min.y | 0)), na.makeEmpty());
  };
  this.clearColor = function () {
  };
  this.clearDepth = function () {
  };
  this.clearStencil = function () {
  };
  this.render = function (a, D) {
    if (!1 === D instanceof THREE.Camera)
      console.error('THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.');
    else {
      !0 === this.autoClear && this.clear();
      y.setTransform(1, 0, 0, -1, O, K);
      x.info.render.vertices = 0;
      x.info.render.faces = 0;
      z = H.projectScene(a, D, this.sortObjects, this.sortElements);
      B = z.elements;
      E = z.lights;
      da = D;
      m.getNormalMatrix(D.matrixWorldInverse);
      hb.setRGB(0, 0, 0);
      ya.setRGB(0, 0, 0);
      ia.setRGB(0, 0, 0);
      for (var I = 0, L = E.length; I < L; I++) {
        var C = E[I], G = C.color;
        C instanceof THREE.AmbientLight ? hb.add(G) : C instanceof THREE.DirectionalLight ? ya.add(G) : C instanceof THREE.PointLight && ia.add(G);
      }
      I = 0;
      for (L = B.length; I < L; I++) {
        var A = B[I], F = A.material;
        if (void 0 !== F && !1 !== F.visible) {
          Oa.makeEmpty();
          if (A instanceof THREE.RenderableSprite) {
            W = A;
            W.x *= O;
            W.y *= K;
            C = W;
            G = F;
            n(G.opacity);
            s(G.blending);
            var J = A.scale.x * O, A = A.scale.y * K, F = 0.5 * Math.sqrt(J * J + A * A);
            Oa.min.set(C.x - F, C.y - F);
            Oa.max.set(C.x + F, C.y + F);
            if (G instanceof THREE.SpriteMaterial || G instanceof THREE.ParticleSystemMaterial) {
              var Q = G.map;
              if (null !== Q) {
                !1 === Q.hasEventListener('update', e) && (void 0 !== Q.image && 0 < Q.image.width && f(Q), Q.addEventListener('update', e));
                F = la[Q.id];
                void 0 !== F ? v(F) : v('rgba( 0, 0, 0, 1 )');
                var R = Q.image, F = R.width * Q.offset.x, Y = R.height * Q.offset.y, V = R.width * Q.repeat.x, Q = R.height * Q.repeat.y, R = J / V, fa = A / Q;
                y.save();
                y.translate(C.x, C.y);
                0 !== G.rotation && y.rotate(G.rotation);
                y.translate(-J / 2, -A / 2);
                y.scale(R, fa);
                y.translate(-F, -Y);
                y.fillRect(F, Y, V, Q);
              } else
                v(G.color.getStyle()), y.save(), y.translate(C.x, C.y), 0 !== G.rotation && y.rotate(G.rotation), y.scale(J, -A), y.fillRect(-0.5, -0.5, 1, 1);
              y.restore();
            } else
              G instanceof THREE.SpriteCanvasMaterial && (p(G.color.getStyle()), v(G.color.getStyle()), y.save(), y.translate(C.x, C.y), 0 !== G.rotation && y.rotate(G.rotation), y.scale(J, A), G.program(y), y.restore());
          } else if (A instanceof THREE.RenderableLine) {
            if (W = A.v1, N = A.v2, W.positionScreen.x *= O, W.positionScreen.y *= K, N.positionScreen.x *= O, N.positionScreen.y *= K, Oa.setFromPoints([
                W.positionScreen,
                N.positionScreen
              ]), !0 === Ea.isIntersectionBox(Oa))
              if (C = W, G = N, J = A, A = F, n(A.opacity), s(A.blending), y.beginPath(), y.moveTo(C.positionScreen.x, C.positionScreen.y), y.lineTo(G.positionScreen.x, G.positionScreen.y), A instanceof THREE.LineBasicMaterial) {
                r(A.linewidth);
                q(A.linecap);
                u(A.linejoin);
                if (A.vertexColors !== THREE.VertexColors)
                  p(A.color.getStyle());
                else if (F = J.vertexColors[0].getStyle(), J = J.vertexColors[1].getStyle(), F === J)
                  p(F);
                else {
                  try {
                    var ga = y.createLinearGradient(C.positionScreen.x, C.positionScreen.y, G.positionScreen.x, G.positionScreen.y);
                    ga.addColorStop(0, F);
                    ga.addColorStop(1, J);
                  } catch (Nb) {
                    ga = F;
                  }
                  p(ga);
                }
                y.stroke();
                Oa.expandByScalar(2 * A.linewidth);
              } else
                A instanceof THREE.LineDashedMaterial && (r(A.linewidth), q(A.linecap), u(A.linejoin), p(A.color.getStyle()), w(A.dashSize, A.gapSize), y.stroke(), Oa.expandByScalar(2 * A.linewidth), w(null, null));
          } else if (A instanceof THREE.RenderableFace) {
            W = A.v1;
            N = A.v2;
            ca = A.v3;
            if (-1 > W.positionScreen.z || 1 < W.positionScreen.z)
              continue;
            if (-1 > N.positionScreen.z || 1 < N.positionScreen.z)
              continue;
            if (-1 > ca.positionScreen.z || 1 < ca.positionScreen.z)
              continue;
            W.positionScreen.x *= O;
            W.positionScreen.y *= K;
            N.positionScreen.x *= O;
            N.positionScreen.y *= K;
            ca.positionScreen.x *= O;
            ca.positionScreen.y *= K;
            0 < F.overdraw && (l(W.positionScreen, N.positionScreen, F.overdraw), l(N.positionScreen, ca.positionScreen, F.overdraw), l(ca.positionScreen, W.positionScreen, F.overdraw));
            Oa.setFromPoints([
              W.positionScreen,
              N.positionScreen,
              ca.positionScreen
            ]);
            if (!0 === Ea.isIntersectionBox(Oa)) {
              C = W;
              G = N;
              J = ca;
              x.info.render.vertices += 3;
              x.info.render.faces++;
              n(F.opacity);
              s(F.blending);
              sa = C.positionScreen.x;
              T = C.positionScreen.y;
              Ja = G.positionScreen.x;
              S = G.positionScreen.y;
              $ = J.positionScreen.x;
              Fa = J.positionScreen.y;
              var Y = sa, V = T, Q = Ja, R = S, fa = $, tc = Fa;
              y.beginPath();
              y.moveTo(Y, V);
              y.lineTo(Q, R);
              y.lineTo(fa, tc);
              y.closePath();
              (F instanceof THREE.MeshLambertMaterial || F instanceof THREE.MeshPhongMaterial) && null === F.map ? (Va.copy(F.color), ka.copy(F.emissive), F.vertexColors === THREE.FaceColors && Va.multiply(A.color), !1 === F.wireframe && F.shading === THREE.SmoothShading && 3 === A.vertexNormalsLength ? (oa.copy(hb), za.copy(hb), Aa.copy(hb), b(A.v1.positionWorld, A.vertexNormalsModel[0], oa), b(A.v2.positionWorld, A.vertexNormalsModel[1], za), b(A.v3.positionWorld, A.vertexNormalsModel[2], Aa), oa.multiply(Va).add(ka), za.multiply(Va).add(ka), Aa.multiply(Va).add(ka), Ua.addColors(za, Aa).multiplyScalar(0.5), ma = k(oa, za, Aa, Ua), h(sa, T, Ja, S, $, Fa, 0, 0, 1, 0, 0, 1, ma)) : (ta.copy(hb), b(A.centroidModel, A.normalModel, ta), ta.multiply(Va).add(ka), !0 === F.wireframe ? c(ta, F.wireframeLinewidth, F.wireframeLinecap, F.wireframeLinejoin) : d(ta))) : F instanceof THREE.MeshBasicMaterial || F instanceof THREE.MeshLambertMaterial || F instanceof THREE.MeshPhongMaterial ? null !== F.map ? F.map.mapping instanceof THREE.UVMapping && (Ca = A.uvs[0], g(sa, T, Ja, S, $, Fa, Ca[0].x, Ca[0].y, Ca[1].x, Ca[1].y, Ca[2].x, Ca[2].y, F.map)) : null !== F.envMap ? F.envMap.mapping instanceof THREE.SphericalReflectionMapping && (ha.copy(A.vertexNormalsModel[0]).applyMatrix3(m), ba = 0.5 * ha.x + 0.5, wa = 0.5 * ha.y + 0.5, ha.copy(A.vertexNormalsModel[1]).applyMatrix3(m), xa = 0.5 * ha.x + 0.5, Da = 0.5 * ha.y + 0.5, ha.copy(A.vertexNormalsModel[2]).applyMatrix3(m), Wa = 0.5 * ha.x + 0.5, La = 0.5 * ha.y + 0.5, g(sa, T, Ja, S, $, Fa, ba, wa, xa, Da, Wa, La, F.envMap)) : (ta.copy(F.color), F.vertexColors === THREE.FaceColors && ta.multiply(A.color), !0 === F.wireframe ? c(ta, F.wireframeLinewidth, F.wireframeLinecap, F.wireframeLinejoin) : d(ta)) : F instanceof THREE.MeshDepthMaterial ? (Ba = da.near, Ia = da.far, oa.r = oa.g = oa.b = 1 - t(C.positionScreen.z * C.positionScreen.w, Ba, Ia), za.r = za.g = za.b = 1 - t(G.positionScreen.z * G.positionScreen.w, Ba, Ia), Aa.r = Aa.g = Aa.b = 1 - t(J.positionScreen.z * J.positionScreen.w, Ba, Ia), Ua.addColors(za, Aa).multiplyScalar(0.5), ma = k(oa, za, Aa, Ua), h(sa, T, Ja, S, $, Fa, 0, 0, 1, 0, 0, 1, ma)) : F instanceof THREE.MeshNormalMaterial && (F.shading === THREE.FlatShading ? (ha.copy(A.normalModel).applyMatrix3(m), ta.setRGB(ha.x, ha.y, ha.z).multiplyScalar(0.5).addScalar(0.5), !0 === F.wireframe ? c(ta, F.wireframeLinewidth, F.wireframeLinecap, F.wireframeLinejoin) : d(ta)) : F.shading === THREE.SmoothShading && (ha.copy(A.vertexNormalsModel[0]).applyMatrix3(m), oa.setRGB(ha.x, ha.y, ha.z).multiplyScalar(0.5).addScalar(0.5), ha.copy(A.vertexNormalsModel[1]).applyMatrix3(m), za.setRGB(ha.x, ha.y, ha.z).multiplyScalar(0.5).addScalar(0.5), ha.copy(A.vertexNormalsModel[2]).applyMatrix3(m), Aa.setRGB(ha.x, ha.y, ha.z).multiplyScalar(0.5).addScalar(0.5), Ua.addColors(za, Aa).multiplyScalar(0.5), ma = k(oa, za, Aa, Ua), h(sa, T, Ja, S, $, Fa, 0, 0, 1, 0, 0, 1, ma)));
            }
          }
          na.union(Oa);
        }
      }
      y.setTransform(1, 0, 0, 1, 0, 0);
    }
  };
};
THREE.ShaderChunk = {
  fog_pars_fragment: '#ifdef USE_FOG\nuniform vec3 fogColor;\n#ifdef FOG_EXP2\nuniform float fogDensity;\n#else\nuniform float fogNear;\nuniform float fogFar;\n#endif\n#endif',
  fog_fragment: '#ifdef USE_FOG\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n#ifdef FOG_EXP2\nconst float LOG2 = 1.442695;\nfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n#else\nfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n#endif\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n#endif',
  envmap_pars_fragment: '#ifdef USE_ENVMAP\nuniform float reflectivity;\nuniform samplerCube envMap;\nuniform float flipEnvMap;\nuniform int combine;\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nuniform bool useRefract;\nuniform float refractionRatio;\n#else\nvarying vec3 vReflect;\n#endif\n#endif',
  envmap_fragment: '#ifdef USE_ENVMAP\nvec3 reflectVec;\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\nif ( useRefract ) {\nreflectVec = refract( cameraToVertex, normal, refractionRatio );\n} else { \nreflectVec = reflect( cameraToVertex, normal );\n}\n#else\nreflectVec = vReflect;\n#endif\n#ifdef DOUBLE_SIDED\nfloat flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\nvec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n#else\nvec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n#endif\n#ifdef GAMMA_INPUT\ncubeColor.xyz *= cubeColor.xyz;\n#endif\nif ( combine == 1 ) {\ngl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );\n} else if ( combine == 2 ) {\ngl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;\n} else {\ngl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );\n}\n#endif',
  envmap_pars_vertex: '#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\nvarying vec3 vReflect;\nuniform float refractionRatio;\nuniform bool useRefract;\n#endif',
  worldpos_vertex: '#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n#ifdef USE_SKINNING\nvec4 worldPosition = modelMatrix * skinned;\n#endif\n#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\nvec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n#endif\n#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\nvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n#endif\n#endif',
  envmap_vertex: '#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\nvec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\nworldNormal = normalize( worldNormal );\nvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\nif ( useRefract ) {\nvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n} else {\nvReflect = reflect( cameraToVertex, worldNormal );\n}\n#endif',
  map_particle_pars_fragment: '#ifdef USE_MAP\nuniform sampler2D map;\n#endif',
  map_particle_fragment: '#ifdef USE_MAP\ngl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\n#endif',
  map_pars_vertex: '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\nvarying vec2 vUv;\nuniform vec4 offsetRepeat;\n#endif',
  map_pars_fragment: '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\nvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\nuniform sampler2D map;\n#endif',
  map_vertex: '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\nvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif',
  map_fragment: '#ifdef USE_MAP\nvec4 texelColor = texture2D( map, vUv );\n#ifdef GAMMA_INPUT\ntexelColor.xyz *= texelColor.xyz;\n#endif\ngl_FragColor = gl_FragColor * texelColor;\n#endif',
  lightmap_pars_fragment: '#ifdef USE_LIGHTMAP\nvarying vec2 vUv2;\nuniform sampler2D lightMap;\n#endif',
  lightmap_pars_vertex: '#ifdef USE_LIGHTMAP\nvarying vec2 vUv2;\n#endif',
  lightmap_fragment: '#ifdef USE_LIGHTMAP\ngl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\n#endif',
  lightmap_vertex: '#ifdef USE_LIGHTMAP\nvUv2 = uv2;\n#endif',
  bumpmap_pars_fragment: '#ifdef USE_BUMPMAP\nuniform sampler2D bumpMap;\nuniform float bumpScale;\nvec2 dHdxy_fwd() {\nvec2 dSTdx = dFdx( vUv );\nvec2 dSTdy = dFdy( vUv );\nfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\nfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\nfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\nreturn vec2( dBx, dBy );\n}\nvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\nvec3 vSigmaX = dFdx( surf_pos );\nvec3 vSigmaY = dFdy( surf_pos );\nvec3 vN = surf_norm;\nvec3 R1 = cross( vSigmaY, vN );\nvec3 R2 = cross( vN, vSigmaX );\nfloat fDet = dot( vSigmaX, R1 );\nvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\nreturn normalize( abs( fDet ) * surf_norm - vGrad );\n}\n#endif',
  normalmap_pars_fragment: '#ifdef USE_NORMALMAP\nuniform sampler2D normalMap;\nuniform vec2 normalScale;\nvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\nvec3 q0 = dFdx( eye_pos.xyz );\nvec3 q1 = dFdy( eye_pos.xyz );\nvec2 st0 = dFdx( vUv.st );\nvec2 st1 = dFdy( vUv.st );\nvec3 S = normalize(  q0 * st1.t - q1 * st0.t );\nvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\nvec3 N = normalize( surf_norm );\nvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\nmapN.xy = normalScale * mapN.xy;\nmat3 tsn = mat3( S, T, N );\nreturn normalize( tsn * mapN );\n}\n#endif',
  specularmap_pars_fragment: '#ifdef USE_SPECULARMAP\nuniform sampler2D specularMap;\n#endif',
  specularmap_fragment: 'float specularStrength;\n#ifdef USE_SPECULARMAP\nvec4 texelSpecular = texture2D( specularMap, vUv );\nspecularStrength = texelSpecular.r;\n#else\nspecularStrength = 1.0;\n#endif',
  lights_lambert_pars_vertex: 'uniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_HEMI_LIGHTS > 0\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n#endif\n#ifdef WRAP_AROUND\nuniform vec3 wrapRGB;\n#endif',
  lights_lambert_vertex: 'vLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\nvLightBack = vec3( 0.0 );\n#endif\ntransformedNormal = normalize( transformedNormal );\n#if MAX_DIR_LIGHTS > 0\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\nvec3 dirVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( transformedNormal, dirVector );\nvec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n#ifdef DOUBLE_SIDED\nvec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n#ifdef WRAP_AROUND\nvec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n#endif\n#endif\n#ifdef WRAP_AROUND\nvec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\ndirectionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\n#ifdef DOUBLE_SIDED\ndirectionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\n#endif\n#endif\nvLightFront += directionalLightColor[ i ] * directionalLightWeighting;\n#ifdef DOUBLE_SIDED\nvLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\n#endif\n}\n#endif\n#if MAX_POINT_LIGHTS > 0\nfor( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\nfloat lDistance = 1.0;\nif ( pointLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\nfloat dotProduct = dot( transformedNormal, lVector );\nvec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\n#ifdef DOUBLE_SIDED\nvec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n#ifdef WRAP_AROUND\nvec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n#endif\n#endif\n#ifdef WRAP_AROUND\nvec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\npointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\n#ifdef DOUBLE_SIDED\npointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\n#endif\n#endif\nvLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\n#ifdef DOUBLE_SIDED\nvLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\n#endif\n}\n#endif\n#if MAX_SPOT_LIGHTS > 0\nfor( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\nif ( spotEffect > spotLightAngleCos[ i ] ) {\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\nfloat lDistance = 1.0;\nif ( spotLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\nfloat dotProduct = dot( transformedNormal, lVector );\nvec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\n#ifdef DOUBLE_SIDED\nvec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n#ifdef WRAP_AROUND\nvec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n#endif\n#endif\n#ifdef WRAP_AROUND\nvec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\nspotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\n#ifdef DOUBLE_SIDED\nspotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\n#endif\n#endif\nvLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\n#ifdef DOUBLE_SIDED\nvLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\n#endif\n}\n}\n#endif\n#if MAX_HEMI_LIGHTS > 0\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\nvec3 lVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( transformedNormal, lVector );\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\nfloat hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\nvLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n#ifdef DOUBLE_SIDED\nvLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n#endif\n}\n#endif\nvLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\n#ifdef DOUBLE_SIDED\nvLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\n#endif',
  lights_phong_pars_vertex: '#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\nvarying vec3 vWorldPosition;\n#endif',
  lights_phong_vertex: '#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\nvWorldPosition = worldPosition.xyz;\n#endif',
  lights_phong_pars_fragment: 'uniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_HEMI_LIGHTS > 0\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\nvarying vec3 vWorldPosition;\n#endif\n#ifdef WRAP_AROUND\nuniform vec3 wrapRGB;\n#endif\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;',
  lights_phong_fragment: 'vec3 normal = normalize( vNormal );\nvec3 viewPosition = normalize( vViewPosition );\n#ifdef DOUBLE_SIDED\nnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n#endif\n#ifdef USE_NORMALMAP\nnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\nnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n#if MAX_POINT_LIGHTS > 0\nvec3 pointDiffuse  = vec3( 0.0 );\nvec3 pointSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz + vViewPosition.xyz;\nfloat lDistance = 1.0;\nif ( pointLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\nfloat dotProduct = dot( normal, lVector );\n#ifdef WRAP_AROUND\nfloat pointDiffuseWeightFull = max( dotProduct, 0.0 );\nfloat pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\nvec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n#else\nfloat pointDiffuseWeight = max( dotProduct, 0.0 );\n#endif\npointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\nvec3 pointHalfVector = normalize( lVector + viewPosition );\nfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\nfloat pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\npointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\n}\n#endif\n#if MAX_SPOT_LIGHTS > 0\nvec3 spotDiffuse  = vec3( 0.0 );\nvec3 spotSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz + vViewPosition.xyz;\nfloat lDistance = 1.0;\nif ( spotLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\nif ( spotEffect > spotLightAngleCos[ i ] ) {\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\nfloat dotProduct = dot( normal, lVector );\n#ifdef WRAP_AROUND\nfloat spotDiffuseWeightFull = max( dotProduct, 0.0 );\nfloat spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\nvec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n#else\nfloat spotDiffuseWeight = max( dotProduct, 0.0 );\n#endif\nspotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\nvec3 spotHalfVector = normalize( lVector + viewPosition );\nfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\nfloat spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\nspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\n}\n}\n#endif\n#if MAX_DIR_LIGHTS > 0\nvec3 dirDiffuse  = vec3( 0.0 );\nvec3 dirSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\nvec3 dirVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( normal, dirVector );\n#ifdef WRAP_AROUND\nfloat dirDiffuseWeightFull = max( dotProduct, 0.0 );\nfloat dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\nvec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n#else\nfloat dirDiffuseWeight = max( dotProduct, 0.0 );\n#endif\ndirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\nvec3 dirHalfVector = normalize( dirVector + viewPosition );\nfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\nfloat dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\ndirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n}\n#endif\n#if MAX_HEMI_LIGHTS > 0\nvec3 hemiDiffuse  = vec3( 0.0 );\nvec3 hemiSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\nvec3 lVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( normal, lVector );\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\nvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\nhemiDiffuse += diffuse * hemiColor;\nvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\nfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\nfloat hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\nvec3 lVectorGround = -lVector;\nvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\nfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\nfloat hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\nfloat dotProductGround = dot( normal, lVectorGround );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\nvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\nhemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n}\n#endif\nvec3 totalDiffuse = vec3( 0.0 );\nvec3 totalSpecular = vec3( 0.0 );\n#if MAX_DIR_LIGHTS > 0\ntotalDiffuse += dirDiffuse;\ntotalSpecular += dirSpecular;\n#endif\n#if MAX_HEMI_LIGHTS > 0\ntotalDiffuse += hemiDiffuse;\ntotalSpecular += hemiSpecular;\n#endif\n#if MAX_POINT_LIGHTS > 0\ntotalDiffuse += pointDiffuse;\ntotalSpecular += pointSpecular;\n#endif\n#if MAX_SPOT_LIGHTS > 0\ntotalDiffuse += spotDiffuse;\ntotalSpecular += spotSpecular;\n#endif\n#ifdef METAL\ngl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\n#else\ngl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n#endif',
  color_pars_fragment: '#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif',
  color_fragment: '#ifdef USE_COLOR\ngl_FragColor = gl_FragColor * vec4( vColor, 1.0 );\n#endif',
  color_pars_vertex: '#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif',
  color_vertex: '#ifdef USE_COLOR\n#ifdef GAMMA_INPUT\nvColor = color * color;\n#else\nvColor = color;\n#endif\n#endif',
  skinning_pars_vertex: '#ifdef USE_SKINNING\n#ifdef BONE_TEXTURE\nuniform sampler2D boneTexture;\nuniform int boneTextureWidth;\nuniform int boneTextureHeight;\nmat4 getBoneMatrix( const in float i ) {\nfloat j = i * 4.0;\nfloat x = mod( j, float( boneTextureWidth ) );\nfloat y = floor( j / float( boneTextureWidth ) );\nfloat dx = 1.0 / float( boneTextureWidth );\nfloat dy = 1.0 / float( boneTextureHeight );\ny = dy * ( y + 0.5 );\nvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\nvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\nvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\nvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\nmat4 bone = mat4( v1, v2, v3, v4 );\nreturn bone;\n}\n#else\nuniform mat4 boneGlobalMatrices[ MAX_BONES ];\nmat4 getBoneMatrix( const in float i ) {\nmat4 bone = boneGlobalMatrices[ int(i) ];\nreturn bone;\n}\n#endif\n#endif',
  skinbase_vertex: '#ifdef USE_SKINNING\nmat4 boneMatX = getBoneMatrix( skinIndex.x );\nmat4 boneMatY = getBoneMatrix( skinIndex.y );\nmat4 boneMatZ = getBoneMatrix( skinIndex.z );\nmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif',
  skinning_vertex: '#ifdef USE_SKINNING\n#ifdef USE_MORPHTARGETS\nvec4 skinVertex = vec4( morphed, 1.0 );\n#else\nvec4 skinVertex = vec4( position, 1.0 );\n#endif\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\nskinned      += boneMatY * skinVertex * skinWeight.y;\nskinned      += boneMatZ * skinVertex * skinWeight.z;\nskinned      += boneMatW * skinVertex * skinWeight.w;\n#endif',
  morphtarget_pars_vertex: '#ifdef USE_MORPHTARGETS\n#ifndef USE_MORPHNORMALS\nuniform float morphTargetInfluences[ 8 ];\n#else\nuniform float morphTargetInfluences[ 4 ];\n#endif\n#endif',
  morphtarget_vertex: '#ifdef USE_MORPHTARGETS\nvec3 morphed = vec3( 0.0 );\nmorphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\nmorphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\nmorphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\nmorphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n#ifndef USE_MORPHNORMALS\nmorphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\nmorphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\nmorphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\nmorphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n#endif\nmorphed += position;\n#endif',
  default_vertex: 'vec4 mvPosition;\n#ifdef USE_SKINNING\nmvPosition = modelViewMatrix * skinned;\n#endif\n#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )\nmvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n#endif\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )\nmvPosition = modelViewMatrix * vec4( position, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;',
  morphnormal_vertex: '#ifdef USE_MORPHNORMALS\nvec3 morphedNormal = vec3( 0.0 );\nmorphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\nmorphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\nmorphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\nmorphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\nmorphedNormal += normal;\n#endif',
  skinnormal_vertex: '#ifdef USE_SKINNING\nmat4 skinMatrix = skinWeight.x * boneMatX;\nskinMatrix \t+= skinWeight.y * boneMatY;\n#ifdef USE_MORPHNORMALS\nvec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n#else\nvec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n#endif\n#endif',
  defaultnormal_vertex: 'vec3 objectNormal;\n#ifdef USE_SKINNING\nobjectNormal = skinnedNormal.xyz;\n#endif\n#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )\nobjectNormal = morphedNormal;\n#endif\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )\nobjectNormal = normal;\n#endif\n#ifdef FLIP_SIDED\nobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;',
  shadowmap_pars_fragment: '#ifdef USE_SHADOWMAP\nuniform sampler2D shadowMap[ MAX_SHADOWS ];\nuniform vec2 shadowMapSize[ MAX_SHADOWS ];\nuniform float shadowDarkness[ MAX_SHADOWS ];\nuniform float shadowBias[ MAX_SHADOWS ];\nvarying vec4 vShadowCoord[ MAX_SHADOWS ];\nfloat unpackDepth( const in vec4 rgba_depth ) {\nconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\nfloat depth = dot( rgba_depth, bit_shift );\nreturn depth;\n}\n#endif',
  shadowmap_fragment: '#ifdef USE_SHADOWMAP\n#ifdef SHADOWMAP_DEBUG\nvec3 frustumColors[3];\nfrustumColors[0] = vec3( 1.0, 0.5, 0.0 );\nfrustumColors[1] = vec3( 0.0, 1.0, 0.8 );\nfrustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n#endif\n#ifdef SHADOWMAP_CASCADE\nint inFrustumCount = 0;\n#endif\nfloat fDepth;\nvec3 shadowColor = vec3( 1.0 );\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\nvec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\nbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\nbool inFrustum = all( inFrustumVec );\n#ifdef SHADOWMAP_CASCADE\ninFrustumCount += int( inFrustum );\nbvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n#else\nbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n#endif\nbool frustumTest = all( frustumTestVec );\nif ( frustumTest ) {\nshadowCoord.z += shadowBias[ i ];\n#if defined( SHADOWMAP_TYPE_PCF )\nfloat shadow = 0.0;\nconst float shadowDelta = 1.0 / 9.0;\nfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\nfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\nfloat dx0 = -1.25 * xPixelOffset;\nfloat dy0 = -1.25 * yPixelOffset;\nfloat dx1 = 1.25 * xPixelOffset;\nfloat dy1 = 1.25 * yPixelOffset;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\nfloat shadow = 0.0;\nfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\nfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\nfloat dx0 = -1.0 * xPixelOffset;\nfloat dy0 = -1.0 * yPixelOffset;\nfloat dx1 = 1.0 * xPixelOffset;\nfloat dy1 = 1.0 * yPixelOffset;\nmat3 shadowKernel;\nmat3 depthKernel;\ndepthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\ndepthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\ndepthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\ndepthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\ndepthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\ndepthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\ndepthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\ndepthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\ndepthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\nvec3 shadowZ = vec3( shadowCoord.z );\nshadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\nshadowKernel[0] *= vec3(0.25);\nshadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\nshadowKernel[1] *= vec3(0.25);\nshadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\nshadowKernel[2] *= vec3(0.25);\nvec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\nshadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\nshadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\nvec4 shadowValues;\nshadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\nshadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\nshadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\nshadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\nshadow = dot( shadowValues, vec4( 1.0 ) );\nshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n#else\nvec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\nfloat fDepth = unpackDepth( rgbaDepth );\nif ( fDepth < shadowCoord.z )\nshadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n#endif\n}\n#ifdef SHADOWMAP_DEBUG\n#ifdef SHADOWMAP_CASCADE\nif ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\n#else\nif ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\n#endif\n#endif\n}\n#ifdef GAMMA_OUTPUT\nshadowColor *= shadowColor;\n#endif\ngl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\n#endif',
  shadowmap_pars_vertex: '#ifdef USE_SHADOWMAP\nvarying vec4 vShadowCoord[ MAX_SHADOWS ];\nuniform mat4 shadowMatrix[ MAX_SHADOWS ];\n#endif',
  shadowmap_vertex: '#ifdef USE_SHADOWMAP\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\nvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n}\n#endif',
  alphatest_fragment: '#ifdef ALPHATEST\nif ( gl_FragColor.a < ALPHATEST ) discard;\n#endif',
  linear_to_gamma_fragment: '#ifdef GAMMA_OUTPUT\ngl_FragColor.xyz = sqrt( gl_FragColor.xyz );\n#endif'
};
THREE.UniformsUtils = {
  merge: function (a) {
    var b, c, d, e = {};
    for (b = 0; b < a.length; b++)
      for (c in d = this.clone(a[b]), d)
        e[c] = d[c];
    return e;
  },
  clone: function (a) {
    var b, c, d, e = {};
    for (b in a)
      for (c in e[b] = {}, a[b])
        d = a[b][c], e[b][c] = d instanceof THREE.Color || d instanceof THREE.Vector2 || d instanceof THREE.Vector3 || d instanceof THREE.Vector4 || d instanceof THREE.Matrix4 || d instanceof THREE.Texture ? d.clone() : d instanceof Array ? d.slice() : d;
    return e;
  }
};
THREE.UniformsLib = {
  common: {
    diffuse: {
      type: 'c',
      value: new THREE.Color(15658734)
    },
    opacity: {
      type: 'f',
      value: 1
    },
    map: {
      type: 't',
      value: null
    },
    offsetRepeat: {
      type: 'v4',
      value: new THREE.Vector4(0, 0, 1, 1)
    },
    lightMap: {
      type: 't',
      value: null
    },
    specularMap: {
      type: 't',
      value: null
    },
    envMap: {
      type: 't',
      value: null
    },
    flipEnvMap: {
      type: 'f',
      value: -1
    },
    useRefract: {
      type: 'i',
      value: 0
    },
    reflectivity: {
      type: 'f',
      value: 1
    },
    refractionRatio: {
      type: 'f',
      value: 0.98
    },
    combine: {
      type: 'i',
      value: 0
    },
    morphTargetInfluences: {
      type: 'f',
      value: 0
    }
  },
  bump: {
    bumpMap: {
      type: 't',
      value: null
    },
    bumpScale: {
      type: 'f',
      value: 1
    }
  },
  normalmap: {
    normalMap: {
      type: 't',
      value: null
    },
    normalScale: {
      type: 'v2',
      value: new THREE.Vector2(1, 1)
    }
  },
  fog: {
    fogDensity: {
      type: 'f',
      value: 0.00025
    },
    fogNear: {
      type: 'f',
      value: 1
    },
    fogFar: {
      type: 'f',
      value: 2000
    },
    fogColor: {
      type: 'c',
      value: new THREE.Color(16777215)
    }
  },
  lights: {
    ambientLightColor: {
      type: 'fv',
      value: []
    },
    directionalLightDirection: {
      type: 'fv',
      value: []
    },
    directionalLightColor: {
      type: 'fv',
      value: []
    },
    hemisphereLightDirection: {
      type: 'fv',
      value: []
    },
    hemisphereLightSkyColor: {
      type: 'fv',
      value: []
    },
    hemisphereLightGroundColor: {
      type: 'fv',
      value: []
    },
    pointLightColor: {
      type: 'fv',
      value: []
    },
    pointLightPosition: {
      type: 'fv',
      value: []
    },
    pointLightDistance: {
      type: 'fv1',
      value: []
    },
    spotLightColor: {
      type: 'fv',
      value: []
    },
    spotLightPosition: {
      type: 'fv',
      value: []
    },
    spotLightDirection: {
      type: 'fv',
      value: []
    },
    spotLightDistance: {
      type: 'fv1',
      value: []
    },
    spotLightAngleCos: {
      type: 'fv1',
      value: []
    },
    spotLightExponent: {
      type: 'fv1',
      value: []
    }
  },
  particle: {
    psColor: {
      type: 'c',
      value: new THREE.Color(15658734)
    },
    opacity: {
      type: 'f',
      value: 1
    },
    size: {
      type: 'f',
      value: 1
    },
    scale: {
      type: 'f',
      value: 1
    },
    map: {
      type: 't',
      value: null
    },
    fogDensity: {
      type: 'f',
      value: 0.00025
    },
    fogNear: {
      type: 'f',
      value: 1
    },
    fogFar: {
      type: 'f',
      value: 2000
    },
    fogColor: {
      type: 'c',
      value: new THREE.Color(16777215)
    }
  },
  shadowmap: {
    shadowMap: {
      type: 'tv',
      value: []
    },
    shadowMapSize: {
      type: 'v2v',
      value: []
    },
    shadowBias: {
      type: 'fv1',
      value: []
    },
    shadowDarkness: {
      type: 'fv1',
      value: []
    },
    shadowMatrix: {
      type: 'm4v',
      value: []
    }
  }
};
THREE.ShaderLib = {
  basic: {
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib.common,
      THREE.UniformsLib.fog,
      THREE.UniformsLib.shadowmap
    ]),
    vertexShader: [
      THREE.ShaderChunk.map_pars_vertex,
      THREE.ShaderChunk.lightmap_pars_vertex,
      THREE.ShaderChunk.envmap_pars_vertex,
      THREE.ShaderChunk.color_pars_vertex,
      THREE.ShaderChunk.morphtarget_pars_vertex,
      THREE.ShaderChunk.skinning_pars_vertex,
      THREE.ShaderChunk.shadowmap_pars_vertex,
      'void main() {',
      THREE.ShaderChunk.map_vertex,
      THREE.ShaderChunk.lightmap_vertex,
      THREE.ShaderChunk.color_vertex,
      THREE.ShaderChunk.skinbase_vertex,
      '#ifdef USE_ENVMAP',
      THREE.ShaderChunk.morphnormal_vertex,
      THREE.ShaderChunk.skinnormal_vertex,
      THREE.ShaderChunk.defaultnormal_vertex,
      '#endif',
      THREE.ShaderChunk.morphtarget_vertex,
      THREE.ShaderChunk.skinning_vertex,
      THREE.ShaderChunk.default_vertex,
      THREE.ShaderChunk.worldpos_vertex,
      THREE.ShaderChunk.envmap_vertex,
      THREE.ShaderChunk.shadowmap_vertex,
      '}'
    ].join('\n'),
    fragmentShader: [
      'uniform vec3 diffuse;\nuniform float opacity;',
      THREE.ShaderChunk.color_pars_fragment,
      THREE.ShaderChunk.map_pars_fragment,
      THREE.ShaderChunk.lightmap_pars_fragment,
      THREE.ShaderChunk.envmap_pars_fragment,
      THREE.ShaderChunk.fog_pars_fragment,
      THREE.ShaderChunk.shadowmap_pars_fragment,
      THREE.ShaderChunk.specularmap_pars_fragment,
      'void main() {\ngl_FragColor = vec4( diffuse, opacity );',
      THREE.ShaderChunk.map_fragment,
      THREE.ShaderChunk.alphatest_fragment,
      THREE.ShaderChunk.specularmap_fragment,
      THREE.ShaderChunk.lightmap_fragment,
      THREE.ShaderChunk.color_fragment,
      THREE.ShaderChunk.envmap_fragment,
      THREE.ShaderChunk.shadowmap_fragment,
      THREE.ShaderChunk.linear_to_gamma_fragment,
      THREE.ShaderChunk.fog_fragment,
      '}'
    ].join('\n')
  },
  lambert: {
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib.common,
      THREE.UniformsLib.fog,
      THREE.UniformsLib.lights,
      THREE.UniformsLib.shadowmap,
      {
        ambient: {
          type: 'c',
          value: new THREE.Color(16777215)
        },
        emissive: {
          type: 'c',
          value: new THREE.Color(0)
        },
        wrapRGB: {
          type: 'v3',
          value: new THREE.Vector3(1, 1, 1)
        }
      }
    ]),
    vertexShader: [
      '#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\nvarying vec3 vLightBack;\n#endif',
      THREE.ShaderChunk.map_pars_vertex,
      THREE.ShaderChunk.lightmap_pars_vertex,
      THREE.ShaderChunk.envmap_pars_vertex,
      THREE.ShaderChunk.lights_lambert_pars_vertex,
      THREE.ShaderChunk.color_pars_vertex,
      THREE.ShaderChunk.morphtarget_pars_vertex,
      THREE.ShaderChunk.skinning_pars_vertex,
      THREE.ShaderChunk.shadowmap_pars_vertex,
      'void main() {',
      THREE.ShaderChunk.map_vertex,
      THREE.ShaderChunk.lightmap_vertex,
      THREE.ShaderChunk.color_vertex,
      THREE.ShaderChunk.morphnormal_vertex,
      THREE.ShaderChunk.skinbase_vertex,
      THREE.ShaderChunk.skinnormal_vertex,
      THREE.ShaderChunk.defaultnormal_vertex,
      THREE.ShaderChunk.morphtarget_vertex,
      THREE.ShaderChunk.skinning_vertex,
      THREE.ShaderChunk.default_vertex,
      THREE.ShaderChunk.worldpos_vertex,
      THREE.ShaderChunk.envmap_vertex,
      THREE.ShaderChunk.lights_lambert_vertex,
      THREE.ShaderChunk.shadowmap_vertex,
      '}'
    ].join('\n'),
    fragmentShader: [
      'uniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\nvarying vec3 vLightBack;\n#endif',
      THREE.ShaderChunk.color_pars_fragment,
      THREE.ShaderChunk.map_pars_fragment,
      THREE.ShaderChunk.lightmap_pars_fragment,
      THREE.ShaderChunk.envmap_pars_fragment,
      THREE.ShaderChunk.fog_pars_fragment,
      THREE.ShaderChunk.shadowmap_pars_fragment,
      THREE.ShaderChunk.specularmap_pars_fragment,
      'void main() {\ngl_FragColor = vec4( vec3 ( 1.0 ), opacity );',
      THREE.ShaderChunk.map_fragment,
      THREE.ShaderChunk.alphatest_fragment,
      THREE.ShaderChunk.specularmap_fragment,
      '#ifdef DOUBLE_SIDED\nif ( gl_FrontFacing )\ngl_FragColor.xyz *= vLightFront;\nelse\ngl_FragColor.xyz *= vLightBack;\n#else\ngl_FragColor.xyz *= vLightFront;\n#endif',
      THREE.ShaderChunk.lightmap_fragment,
      THREE.ShaderChunk.color_fragment,
      THREE.ShaderChunk.envmap_fragment,
      THREE.ShaderChunk.shadowmap_fragment,
      THREE.ShaderChunk.linear_to_gamma_fragment,
      THREE.ShaderChunk.fog_fragment,
      '}'
    ].join('\n')
  },
  phong: {
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib.common,
      THREE.UniformsLib.bump,
      THREE.UniformsLib.normalmap,
      THREE.UniformsLib.fog,
      THREE.UniformsLib.lights,
      THREE.UniformsLib.shadowmap,
      {
        ambient: {
          type: 'c',
          value: new THREE.Color(16777215)
        },
        emissive: {
          type: 'c',
          value: new THREE.Color(0)
        },
        specular: {
          type: 'c',
          value: new THREE.Color(1118481)
        },
        shininess: {
          type: 'f',
          value: 30
        },
        wrapRGB: {
          type: 'v3',
          value: new THREE.Vector3(1, 1, 1)
        }
      }
    ]),
    vertexShader: [
      '#define PHONG\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;',
      THREE.ShaderChunk.map_pars_vertex,
      THREE.ShaderChunk.lightmap_pars_vertex,
      THREE.ShaderChunk.envmap_pars_vertex,
      THREE.ShaderChunk.lights_phong_pars_vertex,
      THREE.ShaderChunk.color_pars_vertex,
      THREE.ShaderChunk.morphtarget_pars_vertex,
      THREE.ShaderChunk.skinning_pars_vertex,
      THREE.ShaderChunk.shadowmap_pars_vertex,
      'void main() {',
      THREE.ShaderChunk.map_vertex,
      THREE.ShaderChunk.lightmap_vertex,
      THREE.ShaderChunk.color_vertex,
      THREE.ShaderChunk.morphnormal_vertex,
      THREE.ShaderChunk.skinbase_vertex,
      THREE.ShaderChunk.skinnormal_vertex,
      THREE.ShaderChunk.defaultnormal_vertex,
      'vNormal = normalize( transformedNormal );',
      THREE.ShaderChunk.morphtarget_vertex,
      THREE.ShaderChunk.skinning_vertex,
      THREE.ShaderChunk.default_vertex,
      'vViewPosition = -mvPosition.xyz;',
      THREE.ShaderChunk.worldpos_vertex,
      THREE.ShaderChunk.envmap_vertex,
      THREE.ShaderChunk.lights_phong_vertex,
      THREE.ShaderChunk.shadowmap_vertex,
      '}'
    ].join('\n'),
    fragmentShader: [
      'uniform vec3 diffuse;\nuniform float opacity;\nuniform vec3 ambient;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;',
      THREE.ShaderChunk.color_pars_fragment,
      THREE.ShaderChunk.map_pars_fragment,
      THREE.ShaderChunk.lightmap_pars_fragment,
      THREE.ShaderChunk.envmap_pars_fragment,
      THREE.ShaderChunk.fog_pars_fragment,
      THREE.ShaderChunk.lights_phong_pars_fragment,
      THREE.ShaderChunk.shadowmap_pars_fragment,
      THREE.ShaderChunk.bumpmap_pars_fragment,
      THREE.ShaderChunk.normalmap_pars_fragment,
      THREE.ShaderChunk.specularmap_pars_fragment,
      'void main() {\ngl_FragColor = vec4( vec3 ( 1.0 ), opacity );',
      THREE.ShaderChunk.map_fragment,
      THREE.ShaderChunk.alphatest_fragment,
      THREE.ShaderChunk.specularmap_fragment,
      THREE.ShaderChunk.lights_phong_fragment,
      THREE.ShaderChunk.lightmap_fragment,
      THREE.ShaderChunk.color_fragment,
      THREE.ShaderChunk.envmap_fragment,
      THREE.ShaderChunk.shadowmap_fragment,
      THREE.ShaderChunk.linear_to_gamma_fragment,
      THREE.ShaderChunk.fog_fragment,
      '}'
    ].join('\n')
  },
  particle_basic: {
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib.particle,
      THREE.UniformsLib.shadowmap
    ]),
    vertexShader: [
      'uniform float size;\nuniform float scale;',
      THREE.ShaderChunk.color_pars_vertex,
      THREE.ShaderChunk.shadowmap_pars_vertex,
      'void main() {',
      THREE.ShaderChunk.color_vertex,
      'vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n#ifdef USE_SIZEATTENUATION\ngl_PointSize = size * ( scale / length( mvPosition.xyz ) );\n#else\ngl_PointSize = size;\n#endif\ngl_Position = projectionMatrix * mvPosition;',
      THREE.ShaderChunk.worldpos_vertex,
      THREE.ShaderChunk.shadowmap_vertex,
      '}'
    ].join('\n'),
    fragmentShader: [
      'uniform vec3 psColor;\nuniform float opacity;',
      THREE.ShaderChunk.color_pars_fragment,
      THREE.ShaderChunk.map_particle_pars_fragment,
      THREE.ShaderChunk.fog_pars_fragment,
      THREE.ShaderChunk.shadowmap_pars_fragment,
      'void main() {\ngl_FragColor = vec4( psColor, opacity );',
      THREE.ShaderChunk.map_particle_fragment,
      THREE.ShaderChunk.alphatest_fragment,
      THREE.ShaderChunk.color_fragment,
      THREE.ShaderChunk.shadowmap_fragment,
      THREE.ShaderChunk.fog_fragment,
      '}'
    ].join('\n')
  },
  dashed: {
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib.common,
      THREE.UniformsLib.fog,
      {
        scale: {
          type: 'f',
          value: 1
        },
        dashSize: {
          type: 'f',
          value: 1
        },
        totalSize: {
          type: 'f',
          value: 2
        }
      }
    ]),
    vertexShader: [
      'uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;',
      THREE.ShaderChunk.color_pars_vertex,
      'void main() {',
      THREE.ShaderChunk.color_vertex,
      'vLineDistance = scale * lineDistance;\nvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n}'
    ].join('\n'),
    fragmentShader: [
      'uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;',
      THREE.ShaderChunk.color_pars_fragment,
      THREE.ShaderChunk.fog_pars_fragment,
      'void main() {\nif ( mod( vLineDistance, totalSize ) > dashSize ) {\ndiscard;\n}\ngl_FragColor = vec4( diffuse, opacity );',
      THREE.ShaderChunk.color_fragment,
      THREE.ShaderChunk.fog_fragment,
      '}'
    ].join('\n')
  },
  depth: {
    uniforms: {
      mNear: {
        type: 'f',
        value: 1
      },
      mFar: {
        type: 'f',
        value: 2000
      },
      opacity: {
        type: 'f',
        value: 1
      }
    },
    vertexShader: 'void main() {\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}',
    fragmentShader: 'uniform float mNear;\nuniform float mFar;\nuniform float opacity;\nvoid main() {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat color = 1.0 - smoothstep( mNear, mFar, depth );\ngl_FragColor = vec4( vec3( color ), opacity );\n}'
  },
  normal: {
    uniforms: {
      opacity: {
        type: 'f',
        value: 1
      }
    },
    vertexShader: [
      'varying vec3 vNormal;',
      THREE.ShaderChunk.morphtarget_pars_vertex,
      'void main() {\nvNormal = normalize( normalMatrix * normal );',
      THREE.ShaderChunk.morphtarget_vertex,
      THREE.ShaderChunk.default_vertex,
      '}'
    ].join('\n'),
    fragmentShader: 'uniform float opacity;\nvarying vec3 vNormal;\nvoid main() {\ngl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );\n}'
  },
  normalmap: {
    uniforms: THREE.UniformsUtils.merge([
      THREE.UniformsLib.fog,
      THREE.UniformsLib.lights,
      THREE.UniformsLib.shadowmap,
      {
        enableAO: {
          type: 'i',
          value: 0
        },
        enableDiffuse: {
          type: 'i',
          value: 0
        },
        enableSpecular: {
          type: 'i',
          value: 0
        },
        enableReflection: {
          type: 'i',
          value: 0
        },
        enableDisplacement: {
          type: 'i',
          value: 0
        },
        tDisplacement: {
          type: 't',
          value: null
        },
        tDiffuse: {
          type: 't',
          value: null
        },
        tCube: {
          type: 't',
          value: null
        },
        tNormal: {
          type: 't',
          value: null
        },
        tSpecular: {
          type: 't',
          value: null
        },
        tAO: {
          type: 't',
          value: null
        },
        uNormalScale: {
          type: 'v2',
          value: new THREE.Vector2(1, 1)
        },
        uDisplacementBias: {
          type: 'f',
          value: 0
        },
        uDisplacementScale: {
          type: 'f',
          value: 1
        },
        diffuse: {
          type: 'c',
          value: new THREE.Color(16777215)
        },
        specular: {
          type: 'c',
          value: new THREE.Color(1118481)
        },
        ambient: {
          type: 'c',
          value: new THREE.Color(16777215)
        },
        shininess: {
          type: 'f',
          value: 30
        },
        opacity: {
          type: 'f',
          value: 1
        },
        useRefract: {
          type: 'i',
          value: 0
        },
        refractionRatio: {
          type: 'f',
          value: 0.98
        },
        reflectivity: {
          type: 'f',
          value: 0.5
        },
        uOffset: {
          type: 'v2',
          value: new THREE.Vector2(0, 0)
        },
        uRepeat: {
          type: 'v2',
          value: new THREE.Vector2(1, 1)
        },
        wrapRGB: {
          type: 'v3',
          value: new THREE.Vector3(1, 1, 1)
        }
      }
    ]),
    fragmentShader: [
      'uniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\nuniform bool enableDiffuse;\nuniform bool enableSpecular;\nuniform bool enableAO;\nuniform bool enableReflection;\nuniform sampler2D tDiffuse;\nuniform sampler2D tNormal;\nuniform sampler2D tSpecular;\nuniform sampler2D tAO;\nuniform samplerCube tCube;\nuniform vec2 uNormalScale;\nuniform bool useRefract;\nuniform float refractionRatio;\nuniform float reflectivity;\nvarying vec3 vTangent;\nvarying vec3 vBinormal;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nuniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_HEMI_LIGHTS > 0\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n#endif\n#ifdef WRAP_AROUND\nuniform vec3 wrapRGB;\n#endif\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;',
      THREE.ShaderChunk.shadowmap_pars_fragment,
      THREE.ShaderChunk.fog_pars_fragment,
      'void main() {\ngl_FragColor = vec4( vec3( 1.0 ), opacity );\nvec3 specularTex = vec3( 1.0 );\nvec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;\nnormalTex.xy *= uNormalScale;\nnormalTex = normalize( normalTex );\nif( enableDiffuse ) {\n#ifdef GAMMA_INPUT\nvec4 texelColor = texture2D( tDiffuse, vUv );\ntexelColor.xyz *= texelColor.xyz;\ngl_FragColor = gl_FragColor * texelColor;\n#else\ngl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );\n#endif\n}\nif( enableAO ) {\n#ifdef GAMMA_INPUT\nvec4 aoColor = texture2D( tAO, vUv );\naoColor.xyz *= aoColor.xyz;\ngl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;\n#else\ngl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;\n#endif\n}\nif( enableSpecular )\nspecularTex = texture2D( tSpecular, vUv ).xyz;\nmat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );\nvec3 finalNormal = tsb * normalTex;\n#ifdef FLIP_SIDED\nfinalNormal = -finalNormal;\n#endif\nvec3 normal = normalize( finalNormal );\nvec3 viewPosition = normalize( vViewPosition );\n#if MAX_POINT_LIGHTS > 0\nvec3 pointDiffuse = vec3( 0.0 );\nvec3 pointSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\nvec3 pointVector = lPosition.xyz + vViewPosition.xyz;\nfloat pointDistance = 1.0;\nif ( pointLightDistance[ i ] > 0.0 )\npointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );\npointVector = normalize( pointVector );\n#ifdef WRAP_AROUND\nfloat pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );\nfloat pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );\nvec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n#else\nfloat pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );\n#endif\npointDiffuse += pointDistance * pointLightColor[ i ] * diffuse * pointDiffuseWeight;\nvec3 pointHalfVector = normalize( pointVector + viewPosition );\nfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\nfloat pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( pointVector, pointHalfVector ), 5.0 );\npointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;\n}\n#endif\n#if MAX_SPOT_LIGHTS > 0\nvec3 spotDiffuse = vec3( 0.0 );\nvec3 spotSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\nvec3 spotVector = lPosition.xyz + vViewPosition.xyz;\nfloat spotDistance = 1.0;\nif ( spotLightDistance[ i ] > 0.0 )\nspotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );\nspotVector = normalize( spotVector );\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\nif ( spotEffect > spotLightAngleCos[ i ] ) {\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\n#ifdef WRAP_AROUND\nfloat spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );\nfloat spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );\nvec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n#else\nfloat spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );\n#endif\nspotDiffuse += spotDistance * spotLightColor[ i ] * diffuse * spotDiffuseWeight * spotEffect;\nvec3 spotHalfVector = normalize( spotVector + viewPosition );\nfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\nfloat spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( spotVector, spotHalfVector ), 5.0 );\nspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;\n}\n}\n#endif\n#if MAX_DIR_LIGHTS > 0\nvec3 dirDiffuse = vec3( 0.0 );\nvec3 dirSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\nvec3 dirVector = normalize( lDirection.xyz );\n#ifdef WRAP_AROUND\nfloat directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );\nfloat directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );\nvec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );\n#else\nfloat dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );\n#endif\ndirDiffuse += directionalLightColor[ i ] * diffuse * dirDiffuseWeight;\nvec3 dirHalfVector = normalize( dirVector + viewPosition );\nfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\nfloat dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\ndirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n}\n#endif\n#if MAX_HEMI_LIGHTS > 0\nvec3 hemiDiffuse  = vec3( 0.0 );\nvec3 hemiSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\nvec3 lVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( normal, lVector );\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\nvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\nhemiDiffuse += diffuse * hemiColor;\nvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\nfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\nfloat hemiSpecularWeightSky = specularTex.r * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\nvec3 lVectorGround = -lVector;\nvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\nfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\nfloat hemiSpecularWeightGround = specularTex.r * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\nfloat dotProductGround = dot( normal, lVectorGround );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\nvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\nhemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n}\n#endif\nvec3 totalDiffuse = vec3( 0.0 );\nvec3 totalSpecular = vec3( 0.0 );\n#if MAX_DIR_LIGHTS > 0\ntotalDiffuse += dirDiffuse;\ntotalSpecular += dirSpecular;\n#endif\n#if MAX_HEMI_LIGHTS > 0\ntotalDiffuse += hemiDiffuse;\ntotalSpecular += hemiSpecular;\n#endif\n#if MAX_POINT_LIGHTS > 0\ntotalDiffuse += pointDiffuse;\ntotalSpecular += pointSpecular;\n#endif\n#if MAX_SPOT_LIGHTS > 0\ntotalDiffuse += spotDiffuse;\ntotalSpecular += spotSpecular;\n#endif\n#ifdef METAL\ngl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient + totalSpecular );\n#else\ngl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n#endif\nif ( enableReflection ) {\nvec3 vReflect;\nvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\nif ( useRefract ) {\nvReflect = refract( cameraToVertex, normal, refractionRatio );\n} else {\nvReflect = reflect( cameraToVertex, normal );\n}\nvec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\n#ifdef GAMMA_INPUT\ncubeColor.xyz *= cubeColor.xyz;\n#endif\ngl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * reflectivity );\n}',
      THREE.ShaderChunk.shadowmap_fragment,
      THREE.ShaderChunk.linear_to_gamma_fragment,
      THREE.ShaderChunk.fog_fragment,
      '}'
    ].join('\n'),
    vertexShader: [
      'attribute vec4 tangent;\nuniform vec2 uOffset;\nuniform vec2 uRepeat;\nuniform bool enableDisplacement;\n#ifdef VERTEX_TEXTURES\nuniform sampler2D tDisplacement;\nuniform float uDisplacementScale;\nuniform float uDisplacementBias;\n#endif\nvarying vec3 vTangent;\nvarying vec3 vBinormal;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;',
      THREE.ShaderChunk.skinning_pars_vertex,
      THREE.ShaderChunk.shadowmap_pars_vertex,
      'void main() {',
      THREE.ShaderChunk.skinbase_vertex,
      THREE.ShaderChunk.skinnormal_vertex,
      '#ifdef USE_SKINNING\nvNormal = normalize( normalMatrix * skinnedNormal.xyz );\nvec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );\nvTangent = normalize( normalMatrix * skinnedTangent.xyz );\n#else\nvNormal = normalize( normalMatrix * normal );\nvTangent = normalize( normalMatrix * tangent.xyz );\n#endif\nvBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );\nvUv = uv * uRepeat + uOffset;\nvec3 displacedPosition;\n#ifdef VERTEX_TEXTURES\nif ( enableDisplacement ) {\nvec3 dv = texture2D( tDisplacement, uv ).xyz;\nfloat df = uDisplacementScale * dv.x + uDisplacementBias;\ndisplacedPosition = position + normalize( normal ) * df;\n} else {\n#ifdef USE_SKINNING\nvec4 skinVertex = vec4( position, 1.0 );\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\nskinned \t  += boneMatY * skinVertex * skinWeight.y;\ndisplacedPosition  = skinned.xyz;\n#else\ndisplacedPosition = position;\n#endif\n}\n#else\n#ifdef USE_SKINNING\nvec4 skinVertex = vec4( position, 1.0 );\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\nskinned \t  += boneMatY * skinVertex * skinWeight.y;\ndisplacedPosition  = skinned.xyz;\n#else\ndisplacedPosition = position;\n#endif\n#endif\nvec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );\nvec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\nvWorldPosition = worldPosition.xyz;\nvViewPosition = -mvPosition.xyz;\n#ifdef USE_SHADOWMAP\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\nvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n}\n#endif\n}'
    ].join('\n')
  },
  cube: {
    uniforms: {
      tCube: {
        type: 't',
        value: null
      },
      tFlip: {
        type: 'f',
        value: -1
      }
    },
    vertexShader: 'varying vec3 vWorldPosition;\nvoid main() {\nvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\nvWorldPosition = worldPosition.xyz;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}',
    fragmentShader: 'uniform samplerCube tCube;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\nvoid main() {\ngl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n}'
  },
  depthRGBA: {
    uniforms: {},
    vertexShader: [
      THREE.ShaderChunk.morphtarget_pars_vertex,
      THREE.ShaderChunk.skinning_pars_vertex,
      'void main() {',
      THREE.ShaderChunk.skinbase_vertex,
      THREE.ShaderChunk.morphtarget_vertex,
      THREE.ShaderChunk.skinning_vertex,
      THREE.ShaderChunk.default_vertex,
      '}'
    ].join('\n'),
    fragmentShader: 'vec4 pack_depth( const in float depth ) {\nconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\nconst vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\nvec4 res = fract( depth * bit_shift );\nres -= res.xxyz * bit_mask;\nreturn res;\n}\nvoid main() {\ngl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\n}'
  }
};
THREE.WebGLRenderer = function (a) {
  function b(a, b) {
    var c = a.vertices.length, d = b.material;
    if (d.attributes) {
      void 0 === a.__webglCustomAttributesList && (a.__webglCustomAttributesList = []);
      for (var e in d.attributes) {
        var f = d.attributes[e];
        if (!f.__webglInitialized || f.createUniqueBuffers) {
          f.__webglInitialized = !0;
          var g = 1;
          'v2' === f.type ? g = 2 : 'v3' === f.type ? g = 3 : 'v4' === f.type ? g = 4 : 'c' === f.type && (g = 3);
          f.size = g;
          f.array = new Float32Array(c * g);
          f.buffer = m.createBuffer();
          f.buffer.belongsToAttribute = e;
          f.needsUpdate = !0;
        }
        a.__webglCustomAttributesList.push(f);
      }
    }
  }
  function c(a, b) {
    var c = b.geometry, g = a.faces3, h = 3 * g.length, k = 1 * g.length, l = 3 * g.length, g = d(b, a), n = f(g), p = e(g), q = g.vertexColors ? g.vertexColors : !1;
    a.__vertexArray = new Float32Array(3 * h);
    p && (a.__normalArray = new Float32Array(3 * h));
    c.hasTangents && (a.__tangentArray = new Float32Array(4 * h));
    q && (a.__colorArray = new Float32Array(3 * h));
    n && (0 < c.faceVertexUvs.length && (a.__uvArray = new Float32Array(2 * h)), 1 < c.faceVertexUvs.length && (a.__uv2Array = new Float32Array(2 * h)));
    b.geometry.skinWeights.length && b.geometry.skinIndices.length && (a.__skinIndexArray = new Float32Array(4 * h), a.__skinWeightArray = new Float32Array(4 * h));
    a.__faceArray = new Uint16Array(3 * k);
    a.__lineArray = new Uint16Array(2 * l);
    if (a.numMorphTargets)
      for (a.__morphTargetsArrays = [], c = 0, n = a.numMorphTargets; c < n; c++)
        a.__morphTargetsArrays.push(new Float32Array(3 * h));
    if (a.numMorphNormals)
      for (a.__morphNormalsArrays = [], c = 0, n = a.numMorphNormals; c < n; c++)
        a.__morphNormalsArrays.push(new Float32Array(3 * h));
    a.__webglFaceCount = 3 * k;
    a.__webglLineCount = 2 * l;
    if (g.attributes) {
      void 0 === a.__webglCustomAttributesList && (a.__webglCustomAttributesList = []);
      for (var r in g.attributes) {
        var k = g.attributes[r], l = {}, s;
        for (s in k)
          l[s] = k[s];
        if (!l.__webglInitialized || l.createUniqueBuffers)
          l.__webglInitialized = !0, c = 1, 'v2' === l.type ? c = 2 : 'v3' === l.type ? c = 3 : 'v4' === l.type ? c = 4 : 'c' === l.type && (c = 3), l.size = c, l.array = new Float32Array(h * c), l.buffer = m.createBuffer(), l.buffer.belongsToAttribute = r, k.needsUpdate = !0, l.__original = k;
        a.__webglCustomAttributesList.push(l);
      }
    }
    a.__inittedArrays = !0;
  }
  function d(a, b) {
    return a.material instanceof THREE.MeshFaceMaterial ? a.material.materials[b.materialIndex] : a.material;
  }
  function e(a) {
    return a instanceof THREE.MeshBasicMaterial && !a.envMap || a instanceof THREE.MeshDepthMaterial ? !1 : a && void 0 !== a.shading && a.shading === THREE.SmoothShading ? THREE.SmoothShading : THREE.FlatShading;
  }
  function f(a) {
    return a.map || a.lightMap || a.bumpMap || a.normalMap || a.specularMap || a instanceof THREE.ShaderMaterial ? !0 : !1;
  }
  function g(a, b, c, d) {
    var e, f, g, k;
    for (f in b)
      g = b[f], e = c[f], 0 <= g && (e ? (k = e.itemSize, m.bindBuffer(m.ARRAY_BUFFER, e.buffer), h(g), m.vertexAttribPointer(g, k, m.FLOAT, !1, 0, d * k * 4)) : a.defaultAttributeValues && (2 === a.defaultAttributeValues[f].length ? m.vertexAttrib2fv(g, a.defaultAttributeValues[f]) : 3 === a.defaultAttributeValues[f].length && m.vertexAttrib3fv(g, a.defaultAttributeValues[f])));
  }
  function h(a) {
    0 === Ea[a] && (m.enableVertexAttribArray(a), Ea[a] = 1);
  }
  function k() {
    for (var a in Ea)
      1 === Ea[a] && (m.disableVertexAttribArray(a), Ea[a] = 0);
  }
  function l(a, b) {
    return a.z !== b.z ? b.z - a.z : a.id - b.id;
  }
  function n(a, b) {
    return b[0] - a[0];
  }
  function s(a, b, c) {
    if (a.length)
      for (var d = 0, e = a.length; d < e; d++)
        Fa = T = null, S = $ = za = oa = la = Ka = Aa = -1, Na = !0, a[d].render(b, c, Wa, La), Fa = T = null, S = $ = za = oa = la = Ka = Aa = -1, Na = !0;
  }
  function r(a, b, c, d, e, f, g, h) {
    var k, m, l, n;
    b ? (m = a.length - 1, n = b = -1) : (m = 0, b = a.length, n = 1);
    for (var p = m; p !== b; p += n)
      if (k = a[p], k.render) {
        m = k.object;
        l = k.buffer;
        if (h)
          k = h;
        else {
          k = k[c];
          if (!k)
            continue;
          g && N.setBlending(k.blending, k.blendEquation, k.blendSrc, k.blendDst);
          N.setDepthTest(k.depthTest);
          N.setDepthWrite(k.depthWrite);
          I(k.polygonOffset, k.polygonOffsetFactor, k.polygonOffsetUnits);
        }
        N.setMaterialFaces(k);
        l instanceof THREE.BufferGeometry ? N.renderBufferDirect(d, e, f, k, l, m) : N.renderBuffer(d, e, f, k, l, m);
      }
  }
  function q(a, b, c, d, e, f, g) {
    for (var h, k, m = 0, l = a.length; m < l; m++)
      if (h = a[m], k = h.object, k.visible) {
        if (g)
          h = g;
        else {
          h = h[b];
          if (!h)
            continue;
          f && N.setBlending(h.blending, h.blendEquation, h.blendSrc, h.blendDst);
          N.setDepthTest(h.depthTest);
          N.setDepthWrite(h.depthWrite);
          I(h.polygonOffset, h.polygonOffsetFactor, h.polygonOffsetUnits);
        }
        N.renderImmediateObject(c, d, e, h, k);
      }
  }
  function u(a, d) {
    var e, f, g;
    if (void 0 === a.__webglInit && (a.__webglInit = !0, a._modelViewMatrix = new THREE.Matrix4(), a._normalMatrix = new THREE.Matrix3(), void 0 !== a.geometry && void 0 === a.geometry.__webglInit && (a.geometry.__webglInit = !0, a.geometry.addEventListener('dispose', Kb)), f = a.geometry, void 0 !== f))
      if (f instanceof THREE.BufferGeometry) {
        var h, k;
        for (g in f.attributes)
          k = 'index' === g ? m.ELEMENT_ARRAY_BUFFER : m.ARRAY_BUFFER, h = f.attributes[g], h.buffer = m.createBuffer(), m.bindBuffer(k, h.buffer), m.bufferData(k, h.array, m.STATIC_DRAW);
      } else if (a instanceof THREE.Mesh)
        for (e in g = a.material, void 0 === f.geometryGroups && f.makeGroups(g instanceof THREE.MeshFaceMaterial), f.geometryGroups) {
          if (g = f.geometryGroups[e], !g.__webglVertexBuffer) {
            h = g;
            h.__webglVertexBuffer = m.createBuffer();
            h.__webglNormalBuffer = m.createBuffer();
            h.__webglTangentBuffer = m.createBuffer();
            h.__webglColorBuffer = m.createBuffer();
            h.__webglUVBuffer = m.createBuffer();
            h.__webglUV2Buffer = m.createBuffer();
            h.__webglSkinIndicesBuffer = m.createBuffer();
            h.__webglSkinWeightsBuffer = m.createBuffer();
            h.__webglFaceBuffer = m.createBuffer();
            h.__webglLineBuffer = m.createBuffer();
            var l = k = void 0;
            if (h.numMorphTargets)
              for (h.__webglMorphTargetsBuffers = [], k = 0, l = h.numMorphTargets; k < l; k++)
                h.__webglMorphTargetsBuffers.push(m.createBuffer());
            if (h.numMorphNormals)
              for (h.__webglMorphNormalsBuffers = [], k = 0, l = h.numMorphNormals; k < l; k++)
                h.__webglMorphNormalsBuffers.push(m.createBuffer());
            N.info.memory.geometries++;
            c(g, a);
            f.verticesNeedUpdate = !0;
            f.morphTargetsNeedUpdate = !0;
            f.elementsNeedUpdate = !0;
            f.uvsNeedUpdate = !0;
            f.normalsNeedUpdate = !0;
            f.tangentsNeedUpdate = !0;
            f.colorsNeedUpdate = !0;
          }
        }
      else
        a instanceof THREE.Line ? f.__webglVertexBuffer || (g = f, g.__webglVertexBuffer = m.createBuffer(), g.__webglColorBuffer = m.createBuffer(), g.__webglLineDistanceBuffer = m.createBuffer(), N.info.memory.geometries++, g = f, h = g.vertices.length, g.__vertexArray = new Float32Array(3 * h), g.__colorArray = new Float32Array(3 * h), g.__lineDistanceArray = new Float32Array(1 * h), g.__webglLineCount = h, b(g, a), f.verticesNeedUpdate = !0, f.colorsNeedUpdate = !0, f.lineDistancesNeedUpdate = !0) : a instanceof THREE.ParticleSystem && !f.__webglVertexBuffer && (g = f, g.__webglVertexBuffer = m.createBuffer(), g.__webglColorBuffer = m.createBuffer(), N.info.memory.geometries++, g = f, h = g.vertices.length, g.__vertexArray = new Float32Array(3 * h), g.__colorArray = new Float32Array(3 * h), g.__sortArray = [], g.__webglParticleCount = h, b(g, a), f.verticesNeedUpdate = !0, f.colorsNeedUpdate = !0);
    if (void 0 === a.__webglActive) {
      if (a instanceof THREE.Mesh)
        if (f = a.geometry, f instanceof THREE.BufferGeometry)
          p(d.__webglObjects, f, a);
        else {
          if (f instanceof THREE.Geometry)
            for (e in f.geometryGroups)
              g = f.geometryGroups[e], p(d.__webglObjects, g, a);
        }
      else
        a instanceof THREE.Line || a instanceof THREE.ParticleSystem ? (f = a.geometry, p(d.__webglObjects, f, a)) : a instanceof THREE.ImmediateRenderObject || a.immediateRenderCallback ? d.__webglObjectsImmediate.push({
          id: null,
          object: a,
          opaque: null,
          transparent: null,
          z: 0
        }) : a instanceof THREE.Sprite ? d.__webglSprites.push(a) : a instanceof THREE.LensFlare && d.__webglFlares.push(a);
      a.__webglActive = !0;
    }
  }
  function p(a, b, c) {
    a.push({
      id: null,
      buffer: b,
      object: c,
      opaque: null,
      transparent: null,
      z: 0
    });
  }
  function v(a) {
    for (var b in a.attributes)
      if (a.attributes[b].needsUpdate)
        return !0;
    return !1;
  }
  function w(a) {
    for (var b in a.attributes)
      a.attributes[b].needsUpdate = !1;
  }
  function t(a, b) {
    a instanceof THREE.Mesh || a instanceof THREE.ParticleSystem || a instanceof THREE.Line ? x(b.__webglObjects, a) : a instanceof THREE.Sprite ? z(b.__webglSprites, a) : a instanceof THREE.LensFlare ? z(b.__webglFlares, a) : (a instanceof THREE.ImmediateRenderObject || a.immediateRenderCallback) && x(b.__webglObjectsImmediate, a);
    delete a.__webglActive;
  }
  function x(a, b) {
    for (var c = a.length - 1; 0 <= c; c--)
      a[c].object === b && a.splice(c, 1);
  }
  function z(a, b) {
    for (var c = a.length - 1; 0 <= c; c--)
      a[c] === b && a.splice(c, 1);
  }
  function B(a, b, c, d, e) {
    ta = 0;
    d.needsUpdate && (d.program && Eb(d), N.initMaterial(d, b, c, e), d.needsUpdate = !1);
    d.morphTargets && !e.__webglMorphTargetInfluences && (e.__webglMorphTargetInfluences = new Float32Array(N.maxMorphTargets));
    var f = !1, g = d.program, h = g.uniforms, k = d.uniforms;
    g !== T && (m.useProgram(g), T = g, f = !0);
    d.id !== S && (S = d.id, f = !0);
    if (f || a !== Fa)
      m.uniformMatrix4fv(h.projectionMatrix, !1, a.projectionMatrix.elements), a !== Fa && (Fa = a);
    if (d.skinning)
      if (ub && e.useVertexTexture) {
        if (null !== h.boneTexture) {
          var l = E();
          m.uniform1i(h.boneTexture, l);
          N.setTexture(e.boneTexture, l);
        }
        null !== h.boneTextureWidth && m.uniform1i(h.boneTextureWidth, e.boneTextureWidth);
        null !== h.boneTextureHeight && m.uniform1i(h.boneTextureHeight, e.boneTextureHeight);
      } else
        null !== h.boneGlobalMatrices && m.uniformMatrix4fv(h.boneGlobalMatrices, !1, e.boneMatrices);
    if (f) {
      c && d.fog && (k.fogColor.value = c.color, c instanceof THREE.Fog ? (k.fogNear.value = c.near, k.fogFar.value = c.far) : c instanceof THREE.FogExp2 && (k.fogDensity.value = c.density));
      if (d instanceof THREE.MeshPhongMaterial || d instanceof THREE.MeshLambertMaterial || d.lights) {
        if (Na) {
          var n, p = l = 0, q = 0, r, s, u, t = ha, v = t.directional.colors, w = t.directional.positions, x = t.point.colors, z = t.point.positions, B = t.point.distances, I = t.spot.colors, C = t.spot.positions, F = t.spot.distances, G = t.spot.directions, O = t.spot.anglesCos, J = t.spot.exponents, Q = t.hemi.skyColors, K = t.hemi.groundColors, ca = t.hemi.positions, R = 0, Y = 0, W = 0, sa = 0, cc = 0, dc = 0, Z = 0, oa = 0, V = n = 0;
          c = u = V = 0;
          for (f = b.length; c < f; c++)
            if (n = b[c], !n.onlyShadow)
              if (r = n.color, s = n.intensity, u = n.distance, n instanceof THREE.AmbientLight)
                n.visible && (N.gammaInput ? (l += r.r * r.r, p += r.g * r.g, q += r.b * r.b) : (l += r.r, p += r.g, q += r.b));
              else if (n instanceof THREE.DirectionalLight) {
                if (cc += 1, n.visible && (ia.setFromMatrixPosition(n.matrixWorld), ya.setFromMatrixPosition(n.target.matrixWorld), ia.sub(ya), ia.normalize(), 0 !== ia.x || 0 !== ia.y || 0 !== ia.z))
                  n = 3 * R, w[n] = ia.x, w[n + 1] = ia.y, w[n + 2] = ia.z, N.gammaInput ? H(v, n, r, s * s) : D(v, n, r, s), R += 1;
              } else
                n instanceof THREE.PointLight ? (dc += 1, n.visible && (V = 3 * Y, N.gammaInput ? H(x, V, r, s * s) : D(x, V, r, s), ya.setFromMatrixPosition(n.matrixWorld), z[V] = ya.x, z[V + 1] = ya.y, z[V + 2] = ya.z, B[Y] = u, Y += 1)) : n instanceof THREE.SpotLight ? (Z += 1, n.visible && (V = 3 * W, N.gammaInput ? H(I, V, r, s * s) : D(I, V, r, s), ya.setFromMatrixPosition(n.matrixWorld), C[V] = ya.x, C[V + 1] = ya.y, C[V + 2] = ya.z, F[W] = u, ia.copy(ya), ya.setFromMatrixPosition(n.target.matrixWorld), ia.sub(ya), ia.normalize(), G[V] = ia.x, G[V + 1] = ia.y, G[V + 2] = ia.z, O[W] = Math.cos(n.angle), J[W] = n.exponent, W += 1)) : n instanceof THREE.HemisphereLight && (oa += 1, n.visible && (ia.setFromMatrixPosition(n.matrixWorld), ia.normalize(), 0 !== ia.x || 0 !== ia.y || 0 !== ia.z)) && (u = 3 * sa, ca[u] = ia.x, ca[u + 1] = ia.y, ca[u + 2] = ia.z, r = n.color, n = n.groundColor, N.gammaInput ? (s *= s, H(Q, u, r, s), H(K, u, n, s)) : (D(Q, u, r, s), D(K, u, n, s)), sa += 1);
          c = 3 * R;
          for (f = Math.max(v.length, 3 * cc); c < f; c++)
            v[c] = 0;
          c = 3 * Y;
          for (f = Math.max(x.length, 3 * dc); c < f; c++)
            x[c] = 0;
          c = 3 * W;
          for (f = Math.max(I.length, 3 * Z); c < f; c++)
            I[c] = 0;
          c = 3 * sa;
          for (f = Math.max(Q.length, 3 * oa); c < f; c++)
            Q[c] = 0;
          c = 3 * sa;
          for (f = Math.max(K.length, 3 * oa); c < f; c++)
            K[c] = 0;
          t.directional.length = R;
          t.point.length = Y;
          t.spot.length = W;
          t.hemi.length = sa;
          t.ambient[0] = l;
          t.ambient[1] = p;
          t.ambient[2] = q;
          Na = !1;
        }
        c = ha;
        k.ambientLightColor.value = c.ambient;
        k.directionalLightColor.value = c.directional.colors;
        k.directionalLightDirection.value = c.directional.positions;
        k.pointLightColor.value = c.point.colors;
        k.pointLightPosition.value = c.point.positions;
        k.pointLightDistance.value = c.point.distances;
        k.spotLightColor.value = c.spot.colors;
        k.spotLightPosition.value = c.spot.positions;
        k.spotLightDistance.value = c.spot.distances;
        k.spotLightDirection.value = c.spot.directions;
        k.spotLightAngleCos.value = c.spot.anglesCos;
        k.spotLightExponent.value = c.spot.exponents;
        k.hemisphereLightSkyColor.value = c.hemi.skyColors;
        k.hemisphereLightGroundColor.value = c.hemi.groundColors;
        k.hemisphereLightDirection.value = c.hemi.positions;
      }
      if (d instanceof THREE.MeshBasicMaterial || d instanceof THREE.MeshLambertMaterial || d instanceof THREE.MeshPhongMaterial) {
        k.opacity.value = d.opacity;
        N.gammaInput ? k.diffuse.value.copyGammaToLinear(d.color) : k.diffuse.value = d.color;
        k.map.value = d.map;
        k.lightMap.value = d.lightMap;
        k.specularMap.value = d.specularMap;
        d.bumpMap && (k.bumpMap.value = d.bumpMap, k.bumpScale.value = d.bumpScale);
        d.normalMap && (k.normalMap.value = d.normalMap, k.normalScale.value.copy(d.normalScale));
        var $;
        d.map ? $ = d.map : d.specularMap ? $ = d.specularMap : d.normalMap ? $ = d.normalMap : d.bumpMap && ($ = d.bumpMap);
        void 0 !== $ && (c = $.offset, $ = $.repeat, k.offsetRepeat.value.set(c.x, c.y, $.x, $.y));
        k.envMap.value = d.envMap;
        k.flipEnvMap.value = d.envMap instanceof THREE.WebGLRenderTargetCube ? 1 : -1;
        k.reflectivity.value = d.reflectivity;
        k.refractionRatio.value = d.refractionRatio;
        k.combine.value = d.combine;
        k.useRefract.value = d.envMap && d.envMap.mapping instanceof THREE.CubeRefractionMapping;
      }
      d instanceof THREE.LineBasicMaterial ? (k.diffuse.value = d.color, k.opacity.value = d.opacity) : d instanceof THREE.LineDashedMaterial ? (k.diffuse.value = d.color, k.opacity.value = d.opacity, k.dashSize.value = d.dashSize, k.totalSize.value = d.dashSize + d.gapSize, k.scale.value = d.scale) : d instanceof THREE.ParticleSystemMaterial ? (k.psColor.value = d.color, k.opacity.value = d.opacity, k.size.value = d.size, k.scale.value = L.height / 2, k.map.value = d.map) : d instanceof THREE.MeshPhongMaterial ? (k.shininess.value = d.shininess, N.gammaInput ? (k.ambient.value.copyGammaToLinear(d.ambient), k.emissive.value.copyGammaToLinear(d.emissive), k.specular.value.copyGammaToLinear(d.specular)) : (k.ambient.value = d.ambient, k.emissive.value = d.emissive, k.specular.value = d.specular), d.wrapAround && k.wrapRGB.value.copy(d.wrapRGB)) : d instanceof THREE.MeshLambertMaterial ? (N.gammaInput ? (k.ambient.value.copyGammaToLinear(d.ambient), k.emissive.value.copyGammaToLinear(d.emissive)) : (k.ambient.value = d.ambient, k.emissive.value = d.emissive), d.wrapAround && k.wrapRGB.value.copy(d.wrapRGB)) : d instanceof THREE.MeshDepthMaterial ? (k.mNear.value = a.near, k.mFar.value = a.far, k.opacity.value = d.opacity) : d instanceof THREE.MeshNormalMaterial && (k.opacity.value = d.opacity);
      if (e.receiveShadow && !d._shadowPass && k.shadowMatrix)
        for (c = $ = 0, f = b.length; c < f; c++)
          l = b[c], l.castShadow && (l instanceof THREE.SpotLight || l instanceof THREE.DirectionalLight && !l.shadowCascade) && (k.shadowMap.value[$] = l.shadowMap, k.shadowMapSize.value[$] = l.shadowMapSize, k.shadowMatrix.value[$] = l.shadowMatrix, k.shadowDarkness.value[$] = l.shadowDarkness, k.shadowBias.value[$] = l.shadowBias, $++);
      b = d.uniformsList;
      k = 0;
      for ($ = b.length; k < $; k++)
        if (f = g.uniforms[b[k][1]])
          if (c = b[k][0], p = c.type, l = c.value, 'i' === p)
            m.uniform1i(f, l);
          else if ('f' === p)
            m.uniform1f(f, l);
          else if ('v2' === p)
            m.uniform2f(f, l.x, l.y);
          else if ('v3' === p)
            m.uniform3f(f, l.x, l.y, l.z);
          else if ('v4' === p)
            m.uniform4f(f, l.x, l.y, l.z, l.w);
          else if ('c' === p)
            m.uniform3f(f, l.r, l.g, l.b);
          else if ('iv1' === p)
            m.uniform1iv(f, l);
          else if ('iv' === p)
            m.uniform3iv(f, l);
          else if ('fv1' === p)
            m.uniform1fv(f, l);
          else if ('fv' === p)
            m.uniform3fv(f, l);
          else if ('v2v' === p) {
            void 0 === c._array && (c._array = new Float32Array(2 * l.length));
            p = 0;
            for (q = l.length; p < q; p++)
              t = 2 * p, c._array[t] = l[p].x, c._array[t + 1] = l[p].y;
            m.uniform2fv(f, c._array);
          } else if ('v3v' === p) {
            void 0 === c._array && (c._array = new Float32Array(3 * l.length));
            p = 0;
            for (q = l.length; p < q; p++)
              t = 3 * p, c._array[t] = l[p].x, c._array[t + 1] = l[p].y, c._array[t + 2] = l[p].z;
            m.uniform3fv(f, c._array);
          } else if ('v4v' === p) {
            void 0 === c._array && (c._array = new Float32Array(4 * l.length));
            p = 0;
            for (q = l.length; p < q; p++)
              t = 4 * p, c._array[t] = l[p].x, c._array[t + 1] = l[p].y, c._array[t + 2] = l[p].z, c._array[t + 3] = l[p].w;
            m.uniform4fv(f, c._array);
          } else if ('m4' === p)
            void 0 === c._array && (c._array = new Float32Array(16)), l.flattenToArray(c._array), m.uniformMatrix4fv(f, !1, c._array);
          else if ('m4v' === p) {
            void 0 === c._array && (c._array = new Float32Array(16 * l.length));
            p = 0;
            for (q = l.length; p < q; p++)
              l[p].flattenToArrayOffset(c._array, 16 * p);
            m.uniformMatrix4fv(f, !1, c._array);
          } else if ('t' === p) {
            if (t = l, l = E(), m.uniform1i(f, l), t)
              if (t.image instanceof Array && 6 === t.image.length) {
                if (c = t, f = l, 6 === c.image.length)
                  if (c.needsUpdate) {
                    c.image.__webglTextureCube || (c.addEventListener('dispose', Cb), c.image.__webglTextureCube = m.createTexture(), N.info.memory.textures++);
                    m.activeTexture(m.TEXTURE0 + f);
                    m.bindTexture(m.TEXTURE_CUBE_MAP, c.image.__webglTextureCube);
                    m.pixelStorei(m.UNPACK_FLIP_Y_WEBGL, c.flipY);
                    f = c instanceof THREE.CompressedTexture;
                    l = [];
                    for (p = 0; 6 > p; p++)
                      N.autoScaleCubemaps && !f ? (q = l, t = p, v = c.image[p], x = db, v.width <= x && v.height <= x || (z = Math.max(v.width, v.height), w = Math.floor(v.width * x / z), x = Math.floor(v.height * x / z), z = document.createElement('canvas'), z.width = w, z.height = x, z.getContext('2d').drawImage(v, 0, 0, v.width, v.height, 0, 0, w, x), v = z), q[t] = v) : l[p] = c.image[p];
                    p = l[0];
                    q = THREE.Math.isPowerOfTwo(p.width) && THREE.Math.isPowerOfTwo(p.height);
                    t = A(c.format);
                    v = A(c.type);
                    y(m.TEXTURE_CUBE_MAP, c, q);
                    for (p = 0; 6 > p; p++)
                      if (f)
                        for (x = l[p].mipmaps, z = 0, B = x.length; z < B; z++)
                          w = x[z], c.format !== THREE.RGBAFormat ? m.compressedTexImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X + p, z, t, w.width, w.height, 0, w.data) : m.texImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X + p, z, t, w.width, w.height, 0, t, v, w.data);
                      else
                        m.texImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X + p, 0, t, t, v, l[p]);
                    c.generateMipmaps && q && m.generateMipmap(m.TEXTURE_CUBE_MAP);
                    c.needsUpdate = !1;
                    if (c.onUpdate)
                      c.onUpdate();
                  } else
                    m.activeTexture(m.TEXTURE0 + f), m.bindTexture(m.TEXTURE_CUBE_MAP, c.image.__webglTextureCube);
              } else
                t instanceof THREE.WebGLRenderTargetCube ? (c = t, m.activeTexture(m.TEXTURE0 + l), m.bindTexture(m.TEXTURE_CUBE_MAP, c.__webglTexture)) : N.setTexture(t, l);
          } else if ('tv' === p) {
            void 0 === c._array && (c._array = []);
            p = 0;
            for (q = c.value.length; p < q; p++)
              c._array[p] = E();
            m.uniform1iv(f, c._array);
            p = 0;
            for (q = c.value.length; p < q; p++)
              t = c.value[p], l = c._array[p], t && N.setTexture(t, l);
          } else
            console.warn('THREE.WebGLRenderer: Unknown uniform type: ' + p);
      (d instanceof THREE.ShaderMaterial || d instanceof THREE.MeshPhongMaterial || d.envMap) && null !== h.cameraPosition && (ya.setFromMatrixPosition(a.matrixWorld), m.uniform3f(h.cameraPosition, ya.x, ya.y, ya.z));
      (d instanceof THREE.MeshPhongMaterial || d instanceof THREE.MeshLambertMaterial || d instanceof THREE.ShaderMaterial || d.skinning) && null !== h.viewMatrix && m.uniformMatrix4fv(h.viewMatrix, !1, a.matrixWorldInverse.elements);
    }
    m.uniformMatrix4fv(h.modelViewMatrix, !1, e._modelViewMatrix.elements);
    h.normalMatrix && m.uniformMatrix3fv(h.normalMatrix, !1, e._normalMatrix.elements);
    null !== h.modelMatrix && m.uniformMatrix4fv(h.modelMatrix, !1, e.matrixWorld.elements);
    return g;
  }
  function E() {
    var a = ta;
    a >= cb && console.warn('WebGLRenderer: trying to use ' + a + ' texture units while this GPU supports only ' + cb);
    ta += 1;
    return a;
  }
  function H(a, b, c, d) {
    a[b] = c.r * c.r * d;
    a[b + 1] = c.g * c.g * d;
    a[b + 2] = c.b * c.b * d;
  }
  function D(a, b, c, d) {
    a[b] = c.r * d;
    a[b + 1] = c.g * d;
    a[b + 2] = c.b * d;
  }
  function G(a) {
    a !== Ca && (m.lineWidth(a), Ca = a);
  }
  function I(a, b, c) {
    Ba !== a && (a ? m.enable(m.POLYGON_OFFSET_FILL) : m.disable(m.POLYGON_OFFSET_FILL), Ba = a);
    !a || Ia === b && ma === c || (m.polygonOffset(b, c), Ia = b, ma = c);
  }
  function O(a) {
    a = a.split('\n');
    for (var b = 0, c = a.length; b < c; b++)
      a[b] = b + 1 + ': ' + a[b];
    return a.join('\n');
  }
  function K(a, b) {
    var c;
    'fragment' === a ? c = m.createShader(m.FRAGMENT_SHADER) : 'vertex' === a && (c = m.createShader(m.VERTEX_SHADER));
    m.shaderSource(c, b);
    m.compileShader(c);
    return m.getShaderParameter(c, m.COMPILE_STATUS) ? c : (console.error(m.getShaderInfoLog(c)), console.error(O(b)), null);
  }
  function y(a, b, c) {
    c ? (m.texParameteri(a, m.TEXTURE_WRAP_S, A(b.wrapS)), m.texParameteri(a, m.TEXTURE_WRAP_T, A(b.wrapT)), m.texParameteri(a, m.TEXTURE_MAG_FILTER, A(b.magFilter)), m.texParameteri(a, m.TEXTURE_MIN_FILTER, A(b.minFilter))) : (m.texParameteri(a, m.TEXTURE_WRAP_S, m.CLAMP_TO_EDGE), m.texParameteri(a, m.TEXTURE_WRAP_T, m.CLAMP_TO_EDGE), m.texParameteri(a, m.TEXTURE_MAG_FILTER, C(b.magFilter)), m.texParameteri(a, m.TEXTURE_MIN_FILTER, C(b.minFilter)));
    Pa && b.type !== THREE.FloatType && (1 < b.anisotropy || b.__oldAnisotropy) && (m.texParameterf(a, Pa.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(b.anisotropy, Bb)), b.__oldAnisotropy = b.anisotropy);
  }
  function F(a, b) {
    m.bindRenderbuffer(m.RENDERBUFFER, a);
    b.depthBuffer && !b.stencilBuffer ? (m.renderbufferStorage(m.RENDERBUFFER, m.DEPTH_COMPONENT16, b.width, b.height), m.framebufferRenderbuffer(m.FRAMEBUFFER, m.DEPTH_ATTACHMENT, m.RENDERBUFFER, a)) : b.depthBuffer && b.stencilBuffer ? (m.renderbufferStorage(m.RENDERBUFFER, m.DEPTH_STENCIL, b.width, b.height), m.framebufferRenderbuffer(m.FRAMEBUFFER, m.DEPTH_STENCIL_ATTACHMENT, m.RENDERBUFFER, a)) : m.renderbufferStorage(m.RENDERBUFFER, m.RGBA4, b.width, b.height);
  }
  function C(a) {
    return a === THREE.NearestFilter || a === THREE.NearestMipMapNearestFilter || a === THREE.NearestMipMapLinearFilter ? m.NEAREST : m.LINEAR;
  }
  function A(a) {
    if (a === THREE.RepeatWrapping)
      return m.REPEAT;
    if (a === THREE.ClampToEdgeWrapping)
      return m.CLAMP_TO_EDGE;
    if (a === THREE.MirroredRepeatWrapping)
      return m.MIRRORED_REPEAT;
    if (a === THREE.NearestFilter)
      return m.NEAREST;
    if (a === THREE.NearestMipMapNearestFilter)
      return m.NEAREST_MIPMAP_NEAREST;
    if (a === THREE.NearestMipMapLinearFilter)
      return m.NEAREST_MIPMAP_LINEAR;
    if (a === THREE.LinearFilter)
      return m.LINEAR;
    if (a === THREE.LinearMipMapNearestFilter)
      return m.LINEAR_MIPMAP_NEAREST;
    if (a === THREE.LinearMipMapLinearFilter)
      return m.LINEAR_MIPMAP_LINEAR;
    if (a === THREE.UnsignedByteType)
      return m.UNSIGNED_BYTE;
    if (a === THREE.UnsignedShort4444Type)
      return m.UNSIGNED_SHORT_4_4_4_4;
    if (a === THREE.UnsignedShort5551Type)
      return m.UNSIGNED_SHORT_5_5_5_1;
    if (a === THREE.UnsignedShort565Type)
      return m.UNSIGNED_SHORT_5_6_5;
    if (a === THREE.ByteType)
      return m.BYTE;
    if (a === THREE.ShortType)
      return m.SHORT;
    if (a === THREE.UnsignedShortType)
      return m.UNSIGNED_SHORT;
    if (a === THREE.IntType)
      return m.INT;
    if (a === THREE.UnsignedIntType)
      return m.UNSIGNED_INT;
    if (a === THREE.FloatType)
      return m.FLOAT;
    if (a === THREE.AlphaFormat)
      return m.ALPHA;
    if (a === THREE.RGBFormat)
      return m.RGB;
    if (a === THREE.RGBAFormat)
      return m.RGBA;
    if (a === THREE.LuminanceFormat)
      return m.LUMINANCE;
    if (a === THREE.LuminanceAlphaFormat)
      return m.LUMINANCE_ALPHA;
    if (a === THREE.AddEquation)
      return m.FUNC_ADD;
    if (a === THREE.SubtractEquation)
      return m.FUNC_SUBTRACT;
    if (a === THREE.ReverseSubtractEquation)
      return m.FUNC_REVERSE_SUBTRACT;
    if (a === THREE.ZeroFactor)
      return m.ZERO;
    if (a === THREE.OneFactor)
      return m.ONE;
    if (a === THREE.SrcColorFactor)
      return m.SRC_COLOR;
    if (a === THREE.OneMinusSrcColorFactor)
      return m.ONE_MINUS_SRC_COLOR;
    if (a === THREE.SrcAlphaFactor)
      return m.SRC_ALPHA;
    if (a === THREE.OneMinusSrcAlphaFactor)
      return m.ONE_MINUS_SRC_ALPHA;
    if (a === THREE.DstAlphaFactor)
      return m.DST_ALPHA;
    if (a === THREE.OneMinusDstAlphaFactor)
      return m.ONE_MINUS_DST_ALPHA;
    if (a === THREE.DstColorFactor)
      return m.DST_COLOR;
    if (a === THREE.OneMinusDstColorFactor)
      return m.ONE_MINUS_DST_COLOR;
    if (a === THREE.SrcAlphaSaturateFactor)
      return m.SRC_ALPHA_SATURATE;
    if (void 0 !== qa) {
      if (a === THREE.RGB_S3TC_DXT1_Format)
        return qa.COMPRESSED_RGB_S3TC_DXT1_EXT;
      if (a === THREE.RGBA_S3TC_DXT1_Format)
        return qa.COMPRESSED_RGBA_S3TC_DXT1_EXT;
      if (a === THREE.RGBA_S3TC_DXT3_Format)
        return qa.COMPRESSED_RGBA_S3TC_DXT3_EXT;
      if (a === THREE.RGBA_S3TC_DXT5_Format)
        return qa.COMPRESSED_RGBA_S3TC_DXT5_EXT;
    }
    return 0;
  }
  console.log('THREE.WebGLRenderer', THREE.REVISION);
  a = a || {};
  var L = void 0 !== a.canvas ? a.canvas : document.createElement('canvas'), Q = void 0 !== a.context ? a.context : null, Y = void 0 !== a.precision ? a.precision : 'highp', R = void 0 !== a.alpha ? a.alpha : !1, fa = void 0 !== a.premultipliedAlpha ? a.premultipliedAlpha : !0, V = void 0 !== a.antialias ? a.antialias : !1, ga = void 0 !== a.stencil ? a.stencil : !0, J = void 0 !== a.preserveDrawingBuffer ? a.preserveDrawingBuffer : !1, da = new THREE.Color(0), W = 0;
  this.domElement = L;
  this.context = null;
  this.devicePixelRatio = void 0 !== a.devicePixelRatio ? a.devicePixelRatio : void 0 !== self.devicePixelRatio ? self.devicePixelRatio : 1;
  this.autoUpdateObjects = this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0;
  this.shadowMapEnabled = this.gammaOutput = this.gammaInput = !1;
  this.shadowMapAutoUpdate = !0;
  this.shadowMapType = THREE.PCFShadowMap;
  this.shadowMapCullFace = THREE.CullFaceFront;
  this.shadowMapCascade = this.shadowMapDebug = !1;
  this.maxMorphTargets = 8;
  this.maxMorphNormals = 4;
  this.autoScaleCubemaps = !0;
  this.renderPluginsPre = [];
  this.renderPluginsPost = [];
  this.info = {
    memory: {
      programs: 0,
      geometries: 0,
      textures: 0
    },
    render: {
      calls: 0,
      vertices: 0,
      faces: 0,
      points: 0
    }
  };
  var N = this, ca = [], sa = 0, T = null, Ja = null, S = -1, $ = null, Fa = null, ta = 0, oa = -1, za = -1, Aa = -1, Ua = -1, Va = -1, ka = -1, Ka = -1, la = -1, Ba = null, Ia = null, ma = null, Ca = null, ba = 0, wa = 0, xa = L.width, Da = L.height, Wa = 0, La = 0, Ea = new Uint8Array(16), na = new THREE.Frustum(), Oa = new THREE.Matrix4(), hb = new THREE.Matrix4(), ya = new THREE.Vector3(), ia = new THREE.Vector3(), Na = !0, ha = {
      ambient: [
        0,
        0,
        0
      ],
      directional: {
        length: 0,
        colors: [],
        positions: []
      },
      point: {
        length: 0,
        colors: [],
        positions: [],
        distances: []
      },
      spot: {
        length: 0,
        colors: [],
        positions: [],
        distances: [],
        directions: [],
        anglesCos: [],
        exponents: []
      },
      hemi: {
        length: 0,
        skyColors: [],
        groundColors: [],
        positions: []
      }
    }, m, Qa, Ma, Pa, qa;
  (function () {
    try {
      var a = {
          alpha: R,
          premultipliedAlpha: fa,
          antialias: V,
          stencil: ga,
          preserveDrawingBuffer: J
        };
      m = Q || L.getContext('webgl', a) || L.getContext('experimental-webgl', a);
      if (null === m)
        throw 'Error creating WebGL context.';
    } catch (b) {
      console.error(b);
    }
    Qa = m.getExtension('OES_texture_float');
    m.getExtension('OES_texture_float_linear');
    Ma = m.getExtension('OES_standard_derivatives');
    Pa = m.getExtension('EXT_texture_filter_anisotropic') || m.getExtension('MOZ_EXT_texture_filter_anisotropic') || m.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
    qa = m.getExtension('WEBGL_compressed_texture_s3tc') || m.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || m.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
    Qa || console.log('THREE.WebGLRenderer: Float textures not supported.');
    Ma || console.log('THREE.WebGLRenderer: Standard derivatives not supported.');
    Pa || console.log('THREE.WebGLRenderer: Anisotropic texture filtering not supported.');
    qa || console.log('THREE.WebGLRenderer: S3TC compressed textures not supported.');
    void 0 === m.getShaderPrecisionFormat && (m.getShaderPrecisionFormat = function () {
      return {
        rangeMin: 1,
        rangeMax: 1,
        precision: 1
      };
    });
  }());
  m.clearColor(0, 0, 0, 1);
  m.clearDepth(1);
  m.clearStencil(0);
  m.enable(m.DEPTH_TEST);
  m.depthFunc(m.LEQUAL);
  m.frontFace(m.CCW);
  m.cullFace(m.BACK);
  m.enable(m.CULL_FACE);
  m.enable(m.BLEND);
  m.blendEquation(m.FUNC_ADD);
  m.blendFunc(m.SRC_ALPHA, m.ONE_MINUS_SRC_ALPHA);
  m.viewport(ba, wa, xa, Da);
  m.clearColor(da.r, da.g, da.b, W);
  this.context = m;
  var cb = m.getParameter(m.MAX_TEXTURE_IMAGE_UNITS), qb = m.getParameter(m.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
  m.getParameter(m.MAX_TEXTURE_SIZE);
  var db = m.getParameter(m.MAX_CUBE_MAP_TEXTURE_SIZE), Bb = Pa ? m.getParameter(Pa.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0, yb = 0 < qb, ub = yb && Qa;
  qa && m.getParameter(m.COMPRESSED_TEXTURE_FORMATS);
  var Yb = m.getShaderPrecisionFormat(m.VERTEX_SHADER, m.HIGH_FLOAT), Zb = m.getShaderPrecisionFormat(m.VERTEX_SHADER, m.MEDIUM_FLOAT);
  m.getShaderPrecisionFormat(m.VERTEX_SHADER, m.LOW_FLOAT);
  var $b = m.getShaderPrecisionFormat(m.FRAGMENT_SHADER, m.HIGH_FLOAT), ac = m.getShaderPrecisionFormat(m.FRAGMENT_SHADER, m.MEDIUM_FLOAT);
  m.getShaderPrecisionFormat(m.FRAGMENT_SHADER, m.LOW_FLOAT);
  m.getShaderPrecisionFormat(m.VERTEX_SHADER, m.HIGH_INT);
  m.getShaderPrecisionFormat(m.VERTEX_SHADER, m.MEDIUM_INT);
  m.getShaderPrecisionFormat(m.VERTEX_SHADER, m.LOW_INT);
  m.getShaderPrecisionFormat(m.FRAGMENT_SHADER, m.HIGH_INT);
  m.getShaderPrecisionFormat(m.FRAGMENT_SHADER, m.MEDIUM_INT);
  m.getShaderPrecisionFormat(m.FRAGMENT_SHADER, m.LOW_INT);
  var bc = 0 < Yb.precision && 0 < $b.precision, Jb = 0 < Zb.precision && 0 < ac.precision;
  'highp' !== Y || bc || (Jb ? (Y = 'mediump', console.warn('WebGLRenderer: highp not supported, using mediump')) : (Y = 'lowp', console.warn('WebGLRenderer: highp and mediump not supported, using lowp')));
  'mediump' !== Y || Jb || (Y = 'lowp', console.warn('WebGLRenderer: mediump not supported, using lowp'));
  this.getContext = function () {
    return m;
  };
  this.supportsVertexTextures = function () {
    return yb;
  };
  this.supportsFloatTextures = function () {
    return Qa;
  };
  this.supportsStandardDerivatives = function () {
    return Ma;
  };
  this.supportsCompressedTextureS3TC = function () {
    return qa;
  };
  this.getMaxAnisotropy = function () {
    return Bb;
  };
  this.getPrecision = function () {
    return Y;
  };
  this.setSize = function (a, b, c) {
    L.width = a * this.devicePixelRatio;
    L.height = b * this.devicePixelRatio;
    1 !== this.devicePixelRatio && !1 !== c && (L.style.width = a + 'px', L.style.height = b + 'px');
    this.setViewport(0, 0, a, b);
  };
  this.setViewport = function (a, b, c, d) {
    ba = a * this.devicePixelRatio;
    wa = b * this.devicePixelRatio;
    xa = c * this.devicePixelRatio;
    Da = d * this.devicePixelRatio;
    m.viewport(ba, wa, xa, Da);
  };
  this.setScissor = function (a, b, c, d) {
    m.scissor(a * this.devicePixelRatio, b * this.devicePixelRatio, c * this.devicePixelRatio, d * this.devicePixelRatio);
  };
  this.enableScissorTest = function (a) {
    a ? m.enable(m.SCISSOR_TEST) : m.disable(m.SCISSOR_TEST);
  };
  this.setClearColor = function (a, b) {
    da.set(a);
    W = void 0 !== b ? b : 1;
    m.clearColor(da.r, da.g, da.b, W);
  };
  this.setClearColorHex = function (a, b) {
    console.warn('DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.');
    this.setClearColor(a, b);
  };
  this.getClearColor = function () {
    return da;
  };
  this.getClearAlpha = function () {
    return W;
  };
  this.clear = function (a, b, c) {
    var d = 0;
    if (void 0 === a || a)
      d |= m.COLOR_BUFFER_BIT;
    if (void 0 === b || b)
      d |= m.DEPTH_BUFFER_BIT;
    if (void 0 === c || c)
      d |= m.STENCIL_BUFFER_BIT;
    m.clear(d);
  };
  this.clearColor = function () {
    m.clear(m.COLOR_BUFFER_BIT);
  };
  this.clearDepth = function () {
    m.clear(m.DEPTH_BUFFER_BIT);
  };
  this.clearStencil = function () {
    m.clear(m.STENCIL_BUFFER_BIT);
  };
  this.clearTarget = function (a, b, c, d) {
    this.setRenderTarget(a);
    this.clear(b, c, d);
  };
  this.addPostPlugin = function (a) {
    a.init(this);
    this.renderPluginsPost.push(a);
  };
  this.addPrePlugin = function (a) {
    a.init(this);
    this.renderPluginsPre.push(a);
  };
  this.updateShadowMap = function (a, b) {
    T = null;
    S = $ = la = Ka = Aa = -1;
    Na = !0;
    za = oa = -1;
    this.shadowMapPlugin.update(a, b);
  };
  var Kb = function (a) {
      a = a.target;
      a.removeEventListener('dispose', Kb);
      a.__webglInit = void 0;
      if (a instanceof THREE.BufferGeometry) {
        var b = a.attributes, c;
        for (c in b)
          void 0 !== b[c].buffer && m.deleteBuffer(b[c].buffer);
        N.info.memory.geometries--;
      } else if (void 0 !== a.geometryGroups)
        for (b in a.geometryGroups) {
          c = a.geometryGroups[b];
          if (void 0 !== c.numMorphTargets)
            for (var d = 0, e = c.numMorphTargets; d < e; d++)
              m.deleteBuffer(c.__webglMorphTargetsBuffers[d]);
          if (void 0 !== c.numMorphNormals)
            for (d = 0, e = c.numMorphNormals; d < e; d++)
              m.deleteBuffer(c.__webglMorphNormalsBuffers[d]);
          Db(c);
        }
      else
        Db(a);
    }, Cb = function (a) {
      a = a.target;
      a.removeEventListener('dispose', Cb);
      a.image && a.image.__webglTextureCube ? m.deleteTexture(a.image.__webglTextureCube) : a.__webglInit && (a.__webglInit = !1, m.deleteTexture(a.__webglTexture));
      N.info.memory.textures--;
    }, Lb = function (a) {
      a = a.target;
      a.removeEventListener('dispose', Lb);
      if (a && a.__webglTexture)
        if (m.deleteTexture(a.__webglTexture), a instanceof THREE.WebGLRenderTargetCube)
          for (var b = 0; 6 > b; b++)
            m.deleteFramebuffer(a.__webglFramebuffer[b]), m.deleteRenderbuffer(a.__webglRenderbuffer[b]);
        else
          m.deleteFramebuffer(a.__webglFramebuffer), m.deleteRenderbuffer(a.__webglRenderbuffer);
      N.info.memory.textures--;
    }, Mb = function (a) {
      a = a.target;
      a.removeEventListener('dispose', Mb);
      Eb(a);
    }, Db = function (a) {
      void 0 !== a.__webglVertexBuffer && m.deleteBuffer(a.__webglVertexBuffer);
      void 0 !== a.__webglNormalBuffer && m.deleteBuffer(a.__webglNormalBuffer);
      void 0 !== a.__webglTangentBuffer && m.deleteBuffer(a.__webglTangentBuffer);
      void 0 !== a.__webglColorBuffer && m.deleteBuffer(a.__webglColorBuffer);
      void 0 !== a.__webglUVBuffer && m.deleteBuffer(a.__webglUVBuffer);
      void 0 !== a.__webglUV2Buffer && m.deleteBuffer(a.__webglUV2Buffer);
      void 0 !== a.__webglSkinIndicesBuffer && m.deleteBuffer(a.__webglSkinIndicesBuffer);
      void 0 !== a.__webglSkinWeightsBuffer && m.deleteBuffer(a.__webglSkinWeightsBuffer);
      void 0 !== a.__webglFaceBuffer && m.deleteBuffer(a.__webglFaceBuffer);
      void 0 !== a.__webglLineBuffer && m.deleteBuffer(a.__webglLineBuffer);
      void 0 !== a.__webglLineDistanceBuffer && m.deleteBuffer(a.__webglLineDistanceBuffer);
      if (void 0 !== a.__webglCustomAttributesList)
        for (var b in a.__webglCustomAttributesList)
          m.deleteBuffer(a.__webglCustomAttributesList[b].buffer);
      N.info.memory.geometries--;
    }, Eb = function (a) {
      var b = a.program;
      if (void 0 !== b) {
        a.program = void 0;
        var c, d, e = !1;
        a = 0;
        for (c = ca.length; a < c; a++)
          if (d = ca[a], d.program === b) {
            d.usedTimes--;
            0 === d.usedTimes && (e = !0);
            break;
          }
        if (!0 === e) {
          e = [];
          a = 0;
          for (c = ca.length; a < c; a++)
            d = ca[a], d.program !== b && e.push(d);
          ca = e;
          m.deleteProgram(b);
          N.info.memory.programs--;
        }
      }
    };
  this.renderBufferImmediate = function (a, b, c) {
    a.hasPositions && !a.__webglVertexBuffer && (a.__webglVertexBuffer = m.createBuffer());
    a.hasNormals && !a.__webglNormalBuffer && (a.__webglNormalBuffer = m.createBuffer());
    a.hasUvs && !a.__webglUvBuffer && (a.__webglUvBuffer = m.createBuffer());
    a.hasColors && !a.__webglColorBuffer && (a.__webglColorBuffer = m.createBuffer());
    a.hasPositions && (m.bindBuffer(m.ARRAY_BUFFER, a.__webglVertexBuffer), m.bufferData(m.ARRAY_BUFFER, a.positionArray, m.DYNAMIC_DRAW), m.enableVertexAttribArray(b.attributes.position), m.vertexAttribPointer(b.attributes.position, 3, m.FLOAT, !1, 0, 0));
    if (a.hasNormals) {
      m.bindBuffer(m.ARRAY_BUFFER, a.__webglNormalBuffer);
      if (c.shading === THREE.FlatShading) {
        var d, e, f, g, h, k, l, n, p, q, r, s = 3 * a.count;
        for (r = 0; r < s; r += 9)
          q = a.normalArray, d = q[r], e = q[r + 1], f = q[r + 2], g = q[r + 3], k = q[r + 4], n = q[r + 5], h = q[r + 6], l = q[r + 7], p = q[r + 8], d = (d + g + h) / 3, e = (e + k + l) / 3, f = (f + n + p) / 3, q[r] = d, q[r + 1] = e, q[r + 2] = f, q[r + 3] = d, q[r + 4] = e, q[r + 5] = f, q[r + 6] = d, q[r + 7] = e, q[r + 8] = f;
      }
      m.bufferData(m.ARRAY_BUFFER, a.normalArray, m.DYNAMIC_DRAW);
      m.enableVertexAttribArray(b.attributes.normal);
      m.vertexAttribPointer(b.attributes.normal, 3, m.FLOAT, !1, 0, 0);
    }
    a.hasUvs && c.map && (m.bindBuffer(m.ARRAY_BUFFER, a.__webglUvBuffer), m.bufferData(m.ARRAY_BUFFER, a.uvArray, m.DYNAMIC_DRAW), m.enableVertexAttribArray(b.attributes.uv), m.vertexAttribPointer(b.attributes.uv, 2, m.FLOAT, !1, 0, 0));
    a.hasColors && c.vertexColors !== THREE.NoColors && (m.bindBuffer(m.ARRAY_BUFFER, a.__webglColorBuffer), m.bufferData(m.ARRAY_BUFFER, a.colorArray, m.DYNAMIC_DRAW), m.enableVertexAttribArray(b.attributes.color), m.vertexAttribPointer(b.attributes.color, 3, m.FLOAT, !1, 0, 0));
    m.drawArrays(m.TRIANGLES, 0, a.count);
    a.count = 0;
  };
  this.renderBufferDirect = function (a, b, c, d, e, f) {
    if (!1 !== d.visible) {
      var l, n, p, q;
      l = B(a, b, c, d, f);
      a = l.attributes;
      b = e.attributes;
      c = !1;
      l = 16777215 * e.id + 2 * l.id + (d.wireframe ? 1 : 0);
      l !== $ && ($ = l, c = !0);
      c && k();
      if (f instanceof THREE.Mesh)
        if (f = b.index) {
          e = e.offsets;
          1 < e.length && (c = !0);
          for (var r = 0, s = e.length; r < s; r++) {
            var t = e[r].index;
            if (c) {
              for (n in a)
                p = a[n], l = b[n], 0 <= p && (l ? (q = l.itemSize, m.bindBuffer(m.ARRAY_BUFFER, l.buffer), h(p), m.vertexAttribPointer(p, q, m.FLOAT, !1, 0, t * q * 4)) : d.defaultAttributeValues && (2 === d.defaultAttributeValues[n].length ? m.vertexAttrib2fv(p, d.defaultAttributeValues[n]) : 3 === d.defaultAttributeValues[n].length && m.vertexAttrib3fv(p, d.defaultAttributeValues[n])));
              m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, f.buffer);
            }
            m.drawElements(m.TRIANGLES, e[r].count, m.UNSIGNED_SHORT, 2 * e[r].start);
            N.info.render.calls++;
            N.info.render.vertices += e[r].count;
            N.info.render.faces += e[r].count / 3;
          }
        } else {
          if (c)
            for (n in a)
              'index' !== n && (p = a[n], l = b[n], 0 <= p && (l ? (q = l.itemSize, m.bindBuffer(m.ARRAY_BUFFER, l.buffer), h(p), m.vertexAttribPointer(p, q, m.FLOAT, !1, 0, 0)) : d.defaultAttributeValues && d.defaultAttributeValues[n] && (2 === d.defaultAttributeValues[n].length ? m.vertexAttrib2fv(p, d.defaultAttributeValues[n]) : 3 === d.defaultAttributeValues[n].length && m.vertexAttrib3fv(p, d.defaultAttributeValues[n]))));
          d = e.attributes.position;
          m.drawArrays(m.TRIANGLES, 0, d.array.length / 3);
          N.info.render.calls++;
          N.info.render.vertices += d.array.length / 3;
          N.info.render.faces += d.array.length / 3 / 3;
        }
      else if (f instanceof THREE.ParticleSystem) {
        if (c)
          for (n in a)
            p = a[n], l = b[n], 0 <= p && (l ? (q = l.itemSize, m.bindBuffer(m.ARRAY_BUFFER, l.buffer), h(p), m.vertexAttribPointer(p, q, m.FLOAT, !1, 0, 0)) : d.defaultAttributeValues && d.defaultAttributeValues[n] && (2 === d.defaultAttributeValues[n].length ? m.vertexAttrib2fv(p, d.defaultAttributeValues[n]) : 3 === d.defaultAttributeValues[n].length && m.vertexAttrib3fv(p, d.defaultAttributeValues[n])));
        d = b.position;
        m.drawArrays(m.POINTS, 0, d.array.length / 3);
        N.info.render.calls++;
        N.info.render.points += d.array.length / 3;
      } else if (f instanceof THREE.Line)
        if (n = f.type === THREE.LineStrip ? m.LINE_STRIP : m.LINES, G(d.linewidth), f = b.index)
          for (e = e.offsets, 1 < e.length && (c = !0), r = 0, s = e.length; r < s; r++)
            t = e[r].index, c && (g(d, a, b, t), m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, f.buffer)), m.drawElements(m.LINES, e[r].count, m.UNSIGNED_SHORT, 2 * e[r].start), N.info.render.calls++, N.info.render.vertices += e[r].count;
        else
          c && g(d, a, b, 0), d = b.position, m.drawArrays(n, 0, d.array.length / 3), N.info.render.calls++, N.info.render.points += d.array.length;
    }
  };
  this.renderBuffer = function (a, b, c, d, e, f) {
    if (!1 !== d.visible) {
      var g, l;
      c = B(a, b, c, d, f);
      a = c.attributes;
      b = !1;
      c = 16777215 * e.id + 2 * c.id + (d.wireframe ? 1 : 0);
      c !== $ && ($ = c, b = !0);
      b && k();
      if (!d.morphTargets && 0 <= a.position)
        b && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglVertexBuffer), h(a.position), m.vertexAttribPointer(a.position, 3, m.FLOAT, !1, 0, 0));
      else if (f.morphTargetBase) {
        c = d.program.attributes;
        -1 !== f.morphTargetBase && 0 <= c.position ? (m.bindBuffer(m.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[f.morphTargetBase]), h(c.position), m.vertexAttribPointer(c.position, 3, m.FLOAT, !1, 0, 0)) : 0 <= c.position && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglVertexBuffer), h(c.position), m.vertexAttribPointer(c.position, 3, m.FLOAT, !1, 0, 0));
        if (f.morphTargetForcedOrder.length) {
          var p = 0;
          l = f.morphTargetForcedOrder;
          for (g = f.morphTargetInfluences; p < d.numSupportedMorphTargets && p < l.length;)
            0 <= c['morphTarget' + p] && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[l[p]]), h(c['morphTarget' + p]), m.vertexAttribPointer(c['morphTarget' + p], 3, m.FLOAT, !1, 0, 0)), 0 <= c['morphNormal' + p] && d.morphNormals && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglMorphNormalsBuffers[l[p]]), h(c['morphNormal' + p]), m.vertexAttribPointer(c['morphNormal' + p], 3, m.FLOAT, !1, 0, 0)), f.__webglMorphTargetInfluences[p] = g[l[p]], p++;
        } else {
          l = [];
          g = f.morphTargetInfluences;
          var q, r = g.length;
          for (q = 0; q < r; q++)
            p = g[q], 0 < p && l.push([
              p,
              q
            ]);
          l.length > d.numSupportedMorphTargets ? (l.sort(n), l.length = d.numSupportedMorphTargets) : l.length > d.numSupportedMorphNormals ? l.sort(n) : 0 === l.length && l.push([
            0,
            0
          ]);
          for (p = 0; p < d.numSupportedMorphTargets;)
            l[p] ? (q = l[p][1], 0 <= c['morphTarget' + p] && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[q]), h(c['morphTarget' + p]), m.vertexAttribPointer(c['morphTarget' + p], 3, m.FLOAT, !1, 0, 0)), 0 <= c['morphNormal' + p] && d.morphNormals && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglMorphNormalsBuffers[q]), h(c['morphNormal' + p]), m.vertexAttribPointer(c['morphNormal' + p], 3, m.FLOAT, !1, 0, 0)), f.__webglMorphTargetInfluences[p] = g[q]) : f.__webglMorphTargetInfluences[p] = 0, p++;
        }
        null !== d.program.uniforms.morphTargetInfluences && m.uniform1fv(d.program.uniforms.morphTargetInfluences, f.__webglMorphTargetInfluences);
      }
      if (b) {
        if (e.__webglCustomAttributesList)
          for (g = 0, l = e.__webglCustomAttributesList.length; g < l; g++)
            c = e.__webglCustomAttributesList[g], 0 <= a[c.buffer.belongsToAttribute] && (m.bindBuffer(m.ARRAY_BUFFER, c.buffer), h(a[c.buffer.belongsToAttribute]), m.vertexAttribPointer(a[c.buffer.belongsToAttribute], c.size, m.FLOAT, !1, 0, 0));
        0 <= a.color && (0 < f.geometry.colors.length || 0 < f.geometry.faces.length ? (m.bindBuffer(m.ARRAY_BUFFER, e.__webglColorBuffer), h(a.color), m.vertexAttribPointer(a.color, 3, m.FLOAT, !1, 0, 0)) : d.defaultAttributeValues && m.vertexAttrib3fv(a.color, d.defaultAttributeValues.color));
        0 <= a.normal && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglNormalBuffer), h(a.normal), m.vertexAttribPointer(a.normal, 3, m.FLOAT, !1, 0, 0));
        0 <= a.tangent && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglTangentBuffer), h(a.tangent), m.vertexAttribPointer(a.tangent, 4, m.FLOAT, !1, 0, 0));
        0 <= a.uv && (f.geometry.faceVertexUvs[0] ? (m.bindBuffer(m.ARRAY_BUFFER, e.__webglUVBuffer), h(a.uv), m.vertexAttribPointer(a.uv, 2, m.FLOAT, !1, 0, 0)) : d.defaultAttributeValues && m.vertexAttrib2fv(a.uv, d.defaultAttributeValues.uv));
        0 <= a.uv2 && (f.geometry.faceVertexUvs[1] ? (m.bindBuffer(m.ARRAY_BUFFER, e.__webglUV2Buffer), h(a.uv2), m.vertexAttribPointer(a.uv2, 2, m.FLOAT, !1, 0, 0)) : d.defaultAttributeValues && m.vertexAttrib2fv(a.uv2, d.defaultAttributeValues.uv2));
        d.skinning && 0 <= a.skinIndex && 0 <= a.skinWeight && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglSkinIndicesBuffer), h(a.skinIndex), m.vertexAttribPointer(a.skinIndex, 4, m.FLOAT, !1, 0, 0), m.bindBuffer(m.ARRAY_BUFFER, e.__webglSkinWeightsBuffer), h(a.skinWeight), m.vertexAttribPointer(a.skinWeight, 4, m.FLOAT, !1, 0, 0));
        0 <= a.lineDistance && (m.bindBuffer(m.ARRAY_BUFFER, e.__webglLineDistanceBuffer), h(a.lineDistance), m.vertexAttribPointer(a.lineDistance, 1, m.FLOAT, !1, 0, 0));
      }
      f instanceof THREE.Mesh ? (d.wireframe ? (G(d.wireframeLinewidth), b && m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, e.__webglLineBuffer), m.drawElements(m.LINES, e.__webglLineCount, m.UNSIGNED_SHORT, 0)) : (b && m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, e.__webglFaceBuffer), m.drawElements(m.TRIANGLES, e.__webglFaceCount, m.UNSIGNED_SHORT, 0)), N.info.render.calls++, N.info.render.vertices += e.__webglFaceCount, N.info.render.faces += e.__webglFaceCount / 3) : f instanceof THREE.Line ? (f = f.type === THREE.LineStrip ? m.LINE_STRIP : m.LINES, G(d.linewidth), m.drawArrays(f, 0, e.__webglLineCount), N.info.render.calls++) : f instanceof THREE.ParticleSystem && (m.drawArrays(m.POINTS, 0, e.__webglParticleCount), N.info.render.calls++, N.info.render.points += e.__webglParticleCount);
    }
  };
  this.render = function (a, b, c, d) {
    if (!1 === b instanceof THREE.Camera)
      console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
    else {
      var e, f, g, h, k = a.__lights, p = a.fog;
      S = -1;
      Na = !0;
      !0 === a.autoUpdate && a.updateMatrixWorld();
      void 0 === b.parent && b.updateMatrixWorld();
      b.matrixWorldInverse.getInverse(b.matrixWorld);
      Oa.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse);
      na.setFromMatrix(Oa);
      this.autoUpdateObjects && this.initWebGLObjects(a);
      s(this.renderPluginsPre, a, b);
      N.info.render.calls = 0;
      N.info.render.vertices = 0;
      N.info.render.faces = 0;
      N.info.render.points = 0;
      this.setRenderTarget(c);
      (this.autoClear || d) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
      h = a.__webglObjects;
      d = 0;
      for (e = h.length; d < e; d++)
        if (f = h[d], g = f.object, f.id = d, f.render = !1, g.visible && (!(g instanceof THREE.Mesh || g instanceof THREE.ParticleSystem) || !g.frustumCulled || na.intersectsObject(g))) {
          var n = g;
          n._modelViewMatrix.multiplyMatrices(b.matrixWorldInverse, n.matrixWorld);
          n._normalMatrix.getNormalMatrix(n._modelViewMatrix);
          var n = f, t = n.object, u = n.buffer, v = t.geometry, t = t.material;
          t instanceof THREE.MeshFaceMaterial ? (t = t.materials[v instanceof THREE.BufferGeometry ? 0 : u.materialIndex], t.transparent ? (n.transparent = t, n.opaque = null) : (n.opaque = t, n.transparent = null)) : t && (t.transparent ? (n.transparent = t, n.opaque = null) : (n.opaque = t, n.transparent = null));
          f.render = !0;
          !0 === this.sortObjects && (null !== g.renderDepth ? f.z = g.renderDepth : (ya.setFromMatrixPosition(g.matrixWorld), ya.applyProjection(Oa), f.z = ya.z));
        }
      this.sortObjects && h.sort(l);
      h = a.__webglObjectsImmediate;
      d = 0;
      for (e = h.length; d < e; d++)
        f = h[d], g = f.object, g.visible && (g._modelViewMatrix.multiplyMatrices(b.matrixWorldInverse, g.matrixWorld), g._normalMatrix.getNormalMatrix(g._modelViewMatrix), g = f.object.material, g.transparent ? (f.transparent = g, f.opaque = null) : (f.opaque = g, f.transparent = null));
      a.overrideMaterial ? (d = a.overrideMaterial, this.setBlending(d.blending, d.blendEquation, d.blendSrc, d.blendDst), this.setDepthTest(d.depthTest), this.setDepthWrite(d.depthWrite), I(d.polygonOffset, d.polygonOffsetFactor, d.polygonOffsetUnits), r(a.__webglObjects, !1, '', b, k, p, !0, d), q(a.__webglObjectsImmediate, '', b, k, p, !1, d)) : (d = null, this.setBlending(THREE.NoBlending), r(a.__webglObjects, !0, 'opaque', b, k, p, !1, d), q(a.__webglObjectsImmediate, 'opaque', b, k, p, !1, d), r(a.__webglObjects, !1, 'transparent', b, k, p, !0, d), q(a.__webglObjectsImmediate, 'transparent', b, k, p, !0, d));
      s(this.renderPluginsPost, a, b);
      c && c.generateMipmaps && c.minFilter !== THREE.NearestFilter && c.minFilter !== THREE.LinearFilter && (c instanceof THREE.WebGLRenderTargetCube ? (m.bindTexture(m.TEXTURE_CUBE_MAP, c.__webglTexture), m.generateMipmap(m.TEXTURE_CUBE_MAP), m.bindTexture(m.TEXTURE_CUBE_MAP, null)) : (m.bindTexture(m.TEXTURE_2D, c.__webglTexture), m.generateMipmap(m.TEXTURE_2D), m.bindTexture(m.TEXTURE_2D, null)));
      this.setDepthTest(!0);
      this.setDepthWrite(!0);
    }
  };
  this.renderImmediateObject = function (a, b, c, d, e) {
    var f = B(a, b, c, d, e);
    $ = -1;
    N.setMaterialFaces(d);
    e.immediateRenderCallback ? e.immediateRenderCallback(f, m, na) : e.render(function (a) {
      N.renderBufferImmediate(a, f, d);
    });
  };
  this.initWebGLObjects = function (a) {
    a.__webglObjects || (a.__webglObjects = [], a.__webglObjectsImmediate = [], a.__webglSprites = [], a.__webglFlares = []);
    for (; a.__objectsAdded.length;)
      u(a.__objectsAdded[0], a), a.__objectsAdded.splice(0, 1);
    for (; a.__objectsRemoved.length;)
      t(a.__objectsRemoved[0], a), a.__objectsRemoved.splice(0, 1);
    for (var b = 0, g = a.__webglObjects.length; b < g; b++) {
      var h = a.__webglObjects[b].object;
      void 0 === h.__webglInit && (void 0 !== h.__webglActive && t(h, a), u(h, a));
      var k = h, l = k.geometry, p = void 0, q = void 0, r = void 0;
      if (l instanceof THREE.BufferGeometry) {
        var s = m.DYNAMIC_DRAW, x = l.attributes, z = void 0, y = void 0;
        for (z in x)
          y = x[z], y.needsUpdate && ('index' === z ? (m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, y.buffer), m.bufferData(m.ELEMENT_ARRAY_BUFFER, y.array, s)) : (m.bindBuffer(m.ARRAY_BUFFER, y.buffer), m.bufferData(m.ARRAY_BUFFER, y.array, s)), y.needsUpdate = !1);
      } else if (k instanceof THREE.Mesh) {
        for (var B = 0, I = l.geometryGroupsList.length; B < I; B++)
          if (p = l.geometryGroupsList[B], r = d(k, p), l.buffersNeedUpdate && c(p, k), q = r.attributes && v(r), l.verticesNeedUpdate || l.morphTargetsNeedUpdate || l.elementsNeedUpdate || l.uvsNeedUpdate || l.normalsNeedUpdate || l.colorsNeedUpdate || l.tangentsNeedUpdate || q) {
            var A = p, D = k, C = m.DYNAMIC_DRAW, F = !l.dynamic, G = r;
            if (A.__inittedArrays) {
              var H = e(G), O = G.vertexColors ? G.vertexColors : !1, L = f(G), N = H === THREE.SmoothShading, E = void 0, J = void 0, Q = void 0, K = void 0, ca = void 0, R = void 0, Y = void 0, W = void 0, V = void 0, $ = void 0, sa = void 0, S = void 0, T = void 0, Z = void 0, oa = void 0, ta = void 0, Fa = void 0, da = void 0, Ja = void 0, fa = void 0, ga = void 0, ha = void 0, za = void 0, ka = void 0, ia = void 0, la = void 0, na = void 0, qa = void 0, Aa = void 0, ba = void 0, Ea = void 0, Ca = void 0, Ka = void 0, Ia = void 0, ma = void 0, La = void 0, wa = void 0, xa = void 0, Ua = void 0, Va = void 0, Ba = 0, Da = 0, Na = 0, Pa = 0, Qa = 0, ib = 0, Ya = 0, Ma = 0, eb = 0, va = 0, Ga = 0, P = 0, Xa = void 0, jb = A.__vertexArray, cb = A.__uvArray, db = A.__uv2Array, Wa = A.__normalArray, Za = A.__tangentArray, kb = A.__colorArray, $a = A.__skinIndexArray, ab = A.__skinWeightArray, qb = A.__morphTargetsArrays, yb = A.__morphNormalsArrays, ub = A.__webglCustomAttributesList, M = void 0, Ob = A.__faceArray, vb = A.__lineArray, Ra = D.geometry, Cb = Ra.elementsNeedUpdate, Bb = Ra.uvsNeedUpdate, Jb = Ra.normalsNeedUpdate, Kb = Ra.tangentsNeedUpdate, Lb = Ra.colorsNeedUpdate, Mb = Ra.morphTargetsNeedUpdate, ec = Ra.vertices, ea = A.faces3, lb = Ra.faces, Db = Ra.faceVertexUvs[0], Eb = Ra.faceVertexUvs[1], fc = Ra.skinIndices, Pb = Ra.skinWeights, Qb = Ra.morphTargets, kc = Ra.morphNormals;
              if (Ra.verticesNeedUpdate) {
                E = 0;
                for (J = ea.length; E < J; E++)
                  K = lb[ea[E]], S = ec[K.a], T = ec[K.b], Z = ec[K.c], jb[Da] = S.x, jb[Da + 1] = S.y, jb[Da + 2] = S.z, jb[Da + 3] = T.x, jb[Da + 4] = T.y, jb[Da + 5] = T.z, jb[Da + 6] = Z.x, jb[Da + 7] = Z.y, jb[Da + 8] = Z.z, Da += 9;
                m.bindBuffer(m.ARRAY_BUFFER, A.__webglVertexBuffer);
                m.bufferData(m.ARRAY_BUFFER, jb, C);
              }
              if (Mb)
                for (ma = 0, La = Qb.length; ma < La; ma++) {
                  E = Ga = 0;
                  for (J = ea.length; E < J; E++)
                    Ua = ea[E], K = lb[Ua], S = Qb[ma].vertices[K.a], T = Qb[ma].vertices[K.b], Z = Qb[ma].vertices[K.c], wa = qb[ma], wa[Ga] = S.x, wa[Ga + 1] = S.y, wa[Ga + 2] = S.z, wa[Ga + 3] = T.x, wa[Ga + 4] = T.y, wa[Ga + 5] = T.z, wa[Ga + 6] = Z.x, wa[Ga + 7] = Z.y, wa[Ga + 8] = Z.z, G.morphNormals && (N ? (Va = kc[ma].vertexNormals[Ua], da = Va.a, Ja = Va.b, fa = Va.c) : fa = Ja = da = kc[ma].faceNormals[Ua], xa = yb[ma], xa[Ga] = da.x, xa[Ga + 1] = da.y, xa[Ga + 2] = da.z, xa[Ga + 3] = Ja.x, xa[Ga + 4] = Ja.y, xa[Ga + 5] = Ja.z, xa[Ga + 6] = fa.x, xa[Ga + 7] = fa.y, xa[Ga + 8] = fa.z), Ga += 9;
                  m.bindBuffer(m.ARRAY_BUFFER, A.__webglMorphTargetsBuffers[ma]);
                  m.bufferData(m.ARRAY_BUFFER, qb[ma], C);
                  G.morphNormals && (m.bindBuffer(m.ARRAY_BUFFER, A.__webglMorphNormalsBuffers[ma]), m.bufferData(m.ARRAY_BUFFER, yb[ma], C));
                }
              if (Pb.length) {
                E = 0;
                for (J = ea.length; E < J; E++)
                  K = lb[ea[E]], ka = Pb[K.a], ia = Pb[K.b], la = Pb[K.c], ab[va] = ka.x, ab[va + 1] = ka.y, ab[va + 2] = ka.z, ab[va + 3] = ka.w, ab[va + 4] = ia.x, ab[va + 5] = ia.y, ab[va + 6] = ia.z, ab[va + 7] = ia.w, ab[va + 8] = la.x, ab[va + 9] = la.y, ab[va + 10] = la.z, ab[va + 11] = la.w, na = fc[K.a], qa = fc[K.b], Aa = fc[K.c], $a[va] = na.x, $a[va + 1] = na.y, $a[va + 2] = na.z, $a[va + 3] = na.w, $a[va + 4] = qa.x, $a[va + 5] = qa.y, $a[va + 6] = qa.z, $a[va + 7] = qa.w, $a[va + 8] = Aa.x, $a[va + 9] = Aa.y, $a[va + 10] = Aa.z, $a[va + 11] = Aa.w, va += 12;
                0 < va && (m.bindBuffer(m.ARRAY_BUFFER, A.__webglSkinIndicesBuffer), m.bufferData(m.ARRAY_BUFFER, $a, C), m.bindBuffer(m.ARRAY_BUFFER, A.__webglSkinWeightsBuffer), m.bufferData(m.ARRAY_BUFFER, ab, C));
              }
              if (Lb && O) {
                E = 0;
                for (J = ea.length; E < J; E++)
                  K = lb[ea[E]], Y = K.vertexColors, W = K.color, 3 === Y.length && O === THREE.VertexColors ? (ga = Y[0], ha = Y[1], za = Y[2]) : za = ha = ga = W, kb[eb] = ga.r, kb[eb + 1] = ga.g, kb[eb + 2] = ga.b, kb[eb + 3] = ha.r, kb[eb + 4] = ha.g, kb[eb + 5] = ha.b, kb[eb + 6] = za.r, kb[eb + 7] = za.g, kb[eb + 8] = za.b, eb += 9;
                0 < eb && (m.bindBuffer(m.ARRAY_BUFFER, A.__webglColorBuffer), m.bufferData(m.ARRAY_BUFFER, kb, C));
              }
              if (Kb && Ra.hasTangents) {
                E = 0;
                for (J = ea.length; E < J; E++)
                  K = lb[ea[E]], V = K.vertexTangents, oa = V[0], ta = V[1], Fa = V[2], Za[Ya] = oa.x, Za[Ya + 1] = oa.y, Za[Ya + 2] = oa.z, Za[Ya + 3] = oa.w, Za[Ya + 4] = ta.x, Za[Ya + 5] = ta.y, Za[Ya + 6] = ta.z, Za[Ya + 7] = ta.w, Za[Ya + 8] = Fa.x, Za[Ya + 9] = Fa.y, Za[Ya + 10] = Fa.z, Za[Ya + 11] = Fa.w, Ya += 12;
                m.bindBuffer(m.ARRAY_BUFFER, A.__webglTangentBuffer);
                m.bufferData(m.ARRAY_BUFFER, Za, C);
              }
              if (Jb && H) {
                E = 0;
                for (J = ea.length; E < J; E++)
                  if (K = lb[ea[E]], ca = K.vertexNormals, R = K.normal, 3 === ca.length && N)
                    for (ba = 0; 3 > ba; ba++)
                      Ca = ca[ba], Wa[ib] = Ca.x, Wa[ib + 1] = Ca.y, Wa[ib + 2] = Ca.z, ib += 3;
                  else
                    for (ba = 0; 3 > ba; ba++)
                      Wa[ib] = R.x, Wa[ib + 1] = R.y, Wa[ib + 2] = R.z, ib += 3;
                m.bindBuffer(m.ARRAY_BUFFER, A.__webglNormalBuffer);
                m.bufferData(m.ARRAY_BUFFER, Wa, C);
              }
              if (Bb && Db && L) {
                E = 0;
                for (J = ea.length; E < J; E++)
                  if (Q = ea[E], $ = Db[Q], void 0 !== $)
                    for (ba = 0; 3 > ba; ba++)
                      Ka = $[ba], cb[Na] = Ka.x, cb[Na + 1] = Ka.y, Na += 2;
                0 < Na && (m.bindBuffer(m.ARRAY_BUFFER, A.__webglUVBuffer), m.bufferData(m.ARRAY_BUFFER, cb, C));
              }
              if (Bb && Eb && L) {
                E = 0;
                for (J = ea.length; E < J; E++)
                  if (Q = ea[E], sa = Eb[Q], void 0 !== sa)
                    for (ba = 0; 3 > ba; ba++)
                      Ia = sa[ba], db[Pa] = Ia.x, db[Pa + 1] = Ia.y, Pa += 2;
                0 < Pa && (m.bindBuffer(m.ARRAY_BUFFER, A.__webglUV2Buffer), m.bufferData(m.ARRAY_BUFFER, db, C));
              }
              if (Cb) {
                E = 0;
                for (J = ea.length; E < J; E++)
                  Ob[Qa] = Ba, Ob[Qa + 1] = Ba + 1, Ob[Qa + 2] = Ba + 2, Qa += 3, vb[Ma] = Ba, vb[Ma + 1] = Ba + 1, vb[Ma + 2] = Ba, vb[Ma + 3] = Ba + 2, vb[Ma + 4] = Ba + 1, vb[Ma + 5] = Ba + 2, Ma += 6, Ba += 3;
                m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, A.__webglFaceBuffer);
                m.bufferData(m.ELEMENT_ARRAY_BUFFER, Ob, C);
                m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, A.__webglLineBuffer);
                m.bufferData(m.ELEMENT_ARRAY_BUFFER, vb, C);
              }
              if (ub)
                for (ba = 0, Ea = ub.length; ba < Ea; ba++)
                  if (M = ub[ba], M.__original.needsUpdate) {
                    P = 0;
                    if (1 === M.size)
                      if (void 0 === M.boundTo || 'vertices' === M.boundTo)
                        for (E = 0, J = ea.length; E < J; E++)
                          K = lb[ea[E]], M.array[P] = M.value[K.a], M.array[P + 1] = M.value[K.b], M.array[P + 2] = M.value[K.c], P += 3;
                      else {
                        if ('faces' === M.boundTo)
                          for (E = 0, J = ea.length; E < J; E++)
                            Xa = M.value[ea[E]], M.array[P] = Xa, M.array[P + 1] = Xa, M.array[P + 2] = Xa, P += 3;
                      }
                    else if (2 === M.size)
                      if (void 0 === M.boundTo || 'vertices' === M.boundTo)
                        for (E = 0, J = ea.length; E < J; E++)
                          K = lb[ea[E]], S = M.value[K.a], T = M.value[K.b], Z = M.value[K.c], M.array[P] = S.x, M.array[P + 1] = S.y, M.array[P + 2] = T.x, M.array[P + 3] = T.y, M.array[P + 4] = Z.x, M.array[P + 5] = Z.y, P += 6;
                      else {
                        if ('faces' === M.boundTo)
                          for (E = 0, J = ea.length; E < J; E++)
                            Z = T = S = Xa = M.value[ea[E]], M.array[P] = S.x, M.array[P + 1] = S.y, M.array[P + 2] = T.x, M.array[P + 3] = T.y, M.array[P + 4] = Z.x, M.array[P + 5] = Z.y, P += 6;
                      }
                    else if (3 === M.size) {
                      var ua;
                      ua = 'c' === M.type ? [
                        'r',
                        'g',
                        'b'
                      ] : [
                        'x',
                        'y',
                        'z'
                      ];
                      if (void 0 === M.boundTo || 'vertices' === M.boundTo)
                        for (E = 0, J = ea.length; E < J; E++)
                          K = lb[ea[E]], S = M.value[K.a], T = M.value[K.b], Z = M.value[K.c], M.array[P] = S[ua[0]], M.array[P + 1] = S[ua[1]], M.array[P + 2] = S[ua[2]], M.array[P + 3] = T[ua[0]], M.array[P + 4] = T[ua[1]], M.array[P + 5] = T[ua[2]], M.array[P + 6] = Z[ua[0]], M.array[P + 7] = Z[ua[1]], M.array[P + 8] = Z[ua[2]], P += 9;
                      else if ('faces' === M.boundTo)
                        for (E = 0, J = ea.length; E < J; E++)
                          Z = T = S = Xa = M.value[ea[E]], M.array[P] = S[ua[0]], M.array[P + 1] = S[ua[1]], M.array[P + 2] = S[ua[2]], M.array[P + 3] = T[ua[0]], M.array[P + 4] = T[ua[1]], M.array[P + 5] = T[ua[2]], M.array[P + 6] = Z[ua[0]], M.array[P + 7] = Z[ua[1]], M.array[P + 8] = Z[ua[2]], P += 9;
                      else if ('faceVertices' === M.boundTo)
                        for (E = 0, J = ea.length; E < J; E++)
                          Xa = M.value[ea[E]], S = Xa[0], T = Xa[1], Z = Xa[2], M.array[P] = S[ua[0]], M.array[P + 1] = S[ua[1]], M.array[P + 2] = S[ua[2]], M.array[P + 3] = T[ua[0]], M.array[P + 4] = T[ua[1]], M.array[P + 5] = T[ua[2]], M.array[P + 6] = Z[ua[0]], M.array[P + 7] = Z[ua[1]], M.array[P + 8] = Z[ua[2]], P += 9;
                    } else if (4 === M.size)
                      if (void 0 === M.boundTo || 'vertices' === M.boundTo)
                        for (E = 0, J = ea.length; E < J; E++)
                          K = lb[ea[E]], S = M.value[K.a], T = M.value[K.b], Z = M.value[K.c], M.array[P] = S.x, M.array[P + 1] = S.y, M.array[P + 2] = S.z, M.array[P + 3] = S.w, M.array[P + 4] = T.x, M.array[P + 5] = T.y, M.array[P + 6] = T.z, M.array[P + 7] = T.w, M.array[P + 8] = Z.x, M.array[P + 9] = Z.y, M.array[P + 10] = Z.z, M.array[P + 11] = Z.w, P += 12;
                      else if ('faces' === M.boundTo)
                        for (E = 0, J = ea.length; E < J; E++)
                          Z = T = S = Xa = M.value[ea[E]], M.array[P] = S.x, M.array[P + 1] = S.y, M.array[P + 2] = S.z, M.array[P + 3] = S.w, M.array[P + 4] = T.x, M.array[P + 5] = T.y, M.array[P + 6] = T.z, M.array[P + 7] = T.w, M.array[P + 8] = Z.x, M.array[P + 9] = Z.y, M.array[P + 10] = Z.z, M.array[P + 11] = Z.w, P += 12;
                      else if ('faceVertices' === M.boundTo)
                        for (E = 0, J = ea.length; E < J; E++)
                          Xa = M.value[ea[E]], S = Xa[0], T = Xa[1], Z = Xa[2], M.array[P] = S.x, M.array[P + 1] = S.y, M.array[P + 2] = S.z, M.array[P + 3] = S.w, M.array[P + 4] = T.x, M.array[P + 5] = T.y, M.array[P + 6] = T.z, M.array[P + 7] = T.w, M.array[P + 8] = Z.x, M.array[P + 9] = Z.y, M.array[P + 10] = Z.z, M.array[P + 11] = Z.w, P += 12;
                    m.bindBuffer(m.ARRAY_BUFFER, M.buffer);
                    m.bufferData(m.ARRAY_BUFFER, M.array, C);
                  }
              F && (delete A.__inittedArrays, delete A.__colorArray, delete A.__normalArray, delete A.__tangentArray, delete A.__uvArray, delete A.__uv2Array, delete A.__faceArray, delete A.__vertexArray, delete A.__lineArray, delete A.__skinIndexArray, delete A.__skinWeightArray);
            }
          }
        l.verticesNeedUpdate = !1;
        l.morphTargetsNeedUpdate = !1;
        l.elementsNeedUpdate = !1;
        l.uvsNeedUpdate = !1;
        l.normalsNeedUpdate = !1;
        l.colorsNeedUpdate = !1;
        l.tangentsNeedUpdate = !1;
        l.buffersNeedUpdate = !1;
        r.attributes && w(r);
      } else if (k instanceof THREE.Line) {
        r = d(k, l);
        q = r.attributes && v(r);
        if (l.verticesNeedUpdate || l.colorsNeedUpdate || l.lineDistancesNeedUpdate || q) {
          var bb = l, Rb = m.DYNAMIC_DRAW, Fb = void 0, Gb = void 0, Hb = void 0, Sb = void 0, ra = void 0, Tb = void 0, lc = bb.vertices, mc = bb.colors, nc = bb.lineDistances, Yb = lc.length, Zb = mc.length, $b = nc.length, Ub = bb.__vertexArray, Vb = bb.__colorArray, oc = bb.__lineDistanceArray, ac = bb.colorsNeedUpdate, bc = bb.lineDistancesNeedUpdate, gc = bb.__webglCustomAttributesList, Wb = void 0, pc = void 0, Ha = void 0, zb = void 0, Sa = void 0, pa = void 0;
          if (bb.verticesNeedUpdate) {
            for (Fb = 0; Fb < Yb; Fb++)
              Sb = lc[Fb], ra = 3 * Fb, Ub[ra] = Sb.x, Ub[ra + 1] = Sb.y, Ub[ra + 2] = Sb.z;
            m.bindBuffer(m.ARRAY_BUFFER, bb.__webglVertexBuffer);
            m.bufferData(m.ARRAY_BUFFER, Ub, Rb);
          }
          if (ac) {
            for (Gb = 0; Gb < Zb; Gb++)
              Tb = mc[Gb], ra = 3 * Gb, Vb[ra] = Tb.r, Vb[ra + 1] = Tb.g, Vb[ra + 2] = Tb.b;
            m.bindBuffer(m.ARRAY_BUFFER, bb.__webglColorBuffer);
            m.bufferData(m.ARRAY_BUFFER, Vb, Rb);
          }
          if (bc) {
            for (Hb = 0; Hb < $b; Hb++)
              oc[Hb] = nc[Hb];
            m.bindBuffer(m.ARRAY_BUFFER, bb.__webglLineDistanceBuffer);
            m.bufferData(m.ARRAY_BUFFER, oc, Rb);
          }
          if (gc)
            for (Wb = 0, pc = gc.length; Wb < pc; Wb++)
              if (pa = gc[Wb], pa.needsUpdate && (void 0 === pa.boundTo || 'vertices' === pa.boundTo)) {
                ra = 0;
                zb = pa.value.length;
                if (1 === pa.size)
                  for (Ha = 0; Ha < zb; Ha++)
                    pa.array[Ha] = pa.value[Ha];
                else if (2 === pa.size)
                  for (Ha = 0; Ha < zb; Ha++)
                    Sa = pa.value[Ha], pa.array[ra] = Sa.x, pa.array[ra + 1] = Sa.y, ra += 2;
                else if (3 === pa.size)
                  if ('c' === pa.type)
                    for (Ha = 0; Ha < zb; Ha++)
                      Sa = pa.value[Ha], pa.array[ra] = Sa.r, pa.array[ra + 1] = Sa.g, pa.array[ra + 2] = Sa.b, ra += 3;
                  else
                    for (Ha = 0; Ha < zb; Ha++)
                      Sa = pa.value[Ha], pa.array[ra] = Sa.x, pa.array[ra + 1] = Sa.y, pa.array[ra + 2] = Sa.z, ra += 3;
                else if (4 === pa.size)
                  for (Ha = 0; Ha < zb; Ha++)
                    Sa = pa.value[Ha], pa.array[ra] = Sa.x, pa.array[ra + 1] = Sa.y, pa.array[ra + 2] = Sa.z, pa.array[ra + 3] = Sa.w, ra += 4;
                m.bindBuffer(m.ARRAY_BUFFER, pa.buffer);
                m.bufferData(m.ARRAY_BUFFER, pa.array, Rb);
              }
        }
        l.verticesNeedUpdate = !1;
        l.colorsNeedUpdate = !1;
        l.lineDistancesNeedUpdate = !1;
        r.attributes && w(r);
      } else if (k instanceof THREE.ParticleSystem) {
        r = d(k, l);
        q = r.attributes && v(r);
        if (l.verticesNeedUpdate || l.colorsNeedUpdate || k.sortParticles || q) {
          var mb = l, hc = m.DYNAMIC_DRAW, Ib = k, Ta = void 0, nb = void 0, ob = void 0, X = void 0, pb = void 0, tb = void 0, Xb = mb.vertices, ic = Xb.length, jc = mb.colors, qc = jc.length, wb = mb.__vertexArray, xb = mb.__colorArray, rb = mb.__sortArray, rc = mb.verticesNeedUpdate, sc = mb.colorsNeedUpdate, sb = mb.__webglCustomAttributesList, fb = void 0, Ab = void 0, aa = void 0, gb = void 0, ja = void 0, U = void 0;
          if (Ib.sortParticles) {
            hb.copy(Oa);
            hb.multiply(Ib.matrixWorld);
            for (Ta = 0; Ta < ic; Ta++)
              ob = Xb[Ta], ya.copy(ob), ya.applyProjection(hb), rb[Ta] = [
                ya.z,
                Ta
              ];
            rb.sort(n);
            for (Ta = 0; Ta < ic; Ta++)
              ob = Xb[rb[Ta][1]], X = 3 * Ta, wb[X] = ob.x, wb[X + 1] = ob.y, wb[X + 2] = ob.z;
            for (nb = 0; nb < qc; nb++)
              X = 3 * nb, tb = jc[rb[nb][1]], xb[X] = tb.r, xb[X + 1] = tb.g, xb[X + 2] = tb.b;
            if (sb)
              for (fb = 0, Ab = sb.length; fb < Ab; fb++)
                if (U = sb[fb], void 0 === U.boundTo || 'vertices' === U.boundTo)
                  if (X = 0, gb = U.value.length, 1 === U.size)
                    for (aa = 0; aa < gb; aa++)
                      pb = rb[aa][1], U.array[aa] = U.value[pb];
                  else if (2 === U.size)
                    for (aa = 0; aa < gb; aa++)
                      pb = rb[aa][1], ja = U.value[pb], U.array[X] = ja.x, U.array[X + 1] = ja.y, X += 2;
                  else if (3 === U.size)
                    if ('c' === U.type)
                      for (aa = 0; aa < gb; aa++)
                        pb = rb[aa][1], ja = U.value[pb], U.array[X] = ja.r, U.array[X + 1] = ja.g, U.array[X + 2] = ja.b, X += 3;
                    else
                      for (aa = 0; aa < gb; aa++)
                        pb = rb[aa][1], ja = U.value[pb], U.array[X] = ja.x, U.array[X + 1] = ja.y, U.array[X + 2] = ja.z, X += 3;
                  else if (4 === U.size)
                    for (aa = 0; aa < gb; aa++)
                      pb = rb[aa][1], ja = U.value[pb], U.array[X] = ja.x, U.array[X + 1] = ja.y, U.array[X + 2] = ja.z, U.array[X + 3] = ja.w, X += 4;
          } else {
            if (rc)
              for (Ta = 0; Ta < ic; Ta++)
                ob = Xb[Ta], X = 3 * Ta, wb[X] = ob.x, wb[X + 1] = ob.y, wb[X + 2] = ob.z;
            if (sc)
              for (nb = 0; nb < qc; nb++)
                tb = jc[nb], X = 3 * nb, xb[X] = tb.r, xb[X + 1] = tb.g, xb[X + 2] = tb.b;
            if (sb)
              for (fb = 0, Ab = sb.length; fb < Ab; fb++)
                if (U = sb[fb], U.needsUpdate && (void 0 === U.boundTo || 'vertices' === U.boundTo))
                  if (gb = U.value.length, X = 0, 1 === U.size)
                    for (aa = 0; aa < gb; aa++)
                      U.array[aa] = U.value[aa];
                  else if (2 === U.size)
                    for (aa = 0; aa < gb; aa++)
                      ja = U.value[aa], U.array[X] = ja.x, U.array[X + 1] = ja.y, X += 2;
                  else if (3 === U.size)
                    if ('c' === U.type)
                      for (aa = 0; aa < gb; aa++)
                        ja = U.value[aa], U.array[X] = ja.r, U.array[X + 1] = ja.g, U.array[X + 2] = ja.b, X += 3;
                    else
                      for (aa = 0; aa < gb; aa++)
                        ja = U.value[aa], U.array[X] = ja.x, U.array[X + 1] = ja.y, U.array[X + 2] = ja.z, X += 3;
                  else if (4 === U.size)
                    for (aa = 0; aa < gb; aa++)
                      ja = U.value[aa], U.array[X] = ja.x, U.array[X + 1] = ja.y, U.array[X + 2] = ja.z, U.array[X + 3] = ja.w, X += 4;
          }
          if (rc || Ib.sortParticles)
            m.bindBuffer(m.ARRAY_BUFFER, mb.__webglVertexBuffer), m.bufferData(m.ARRAY_BUFFER, wb, hc);
          if (sc || Ib.sortParticles)
            m.bindBuffer(m.ARRAY_BUFFER, mb.__webglColorBuffer), m.bufferData(m.ARRAY_BUFFER, xb, hc);
          if (sb)
            for (fb = 0, Ab = sb.length; fb < Ab; fb++)
              if (U = sb[fb], U.needsUpdate || Ib.sortParticles)
                m.bindBuffer(m.ARRAY_BUFFER, U.buffer), m.bufferData(m.ARRAY_BUFFER, U.array, hc);
        }
        l.verticesNeedUpdate = !1;
        l.colorsNeedUpdate = !1;
        r.attributes && w(r);
      }
    }
  };
  this.initMaterial = function (a, b, c, d) {
    var e, f, g, h;
    a.addEventListener('dispose', Mb);
    var k, l, p, n, r;
    a instanceof THREE.MeshDepthMaterial ? r = 'depth' : a instanceof THREE.MeshNormalMaterial ? r = 'normal' : a instanceof THREE.MeshBasicMaterial ? r = 'basic' : a instanceof THREE.MeshLambertMaterial ? r = 'lambert' : a instanceof THREE.MeshPhongMaterial ? r = 'phong' : a instanceof THREE.LineBasicMaterial ? r = 'basic' : a instanceof THREE.LineDashedMaterial ? r = 'dashed' : a instanceof THREE.ParticleSystemMaterial && (r = 'particle_basic');
    if (r) {
      var q = THREE.ShaderLib[r];
      a.uniforms = THREE.UniformsUtils.clone(q.uniforms);
      a.vertexShader = q.vertexShader;
      a.fragmentShader = q.fragmentShader;
    }
    var s = e = 0, t = 0, u = q = 0;
    for (f = b.length; u < f; u++)
      g = b[u], g.onlyShadow || !1 === g.visible || (g instanceof THREE.DirectionalLight && e++, g instanceof THREE.PointLight && s++, g instanceof THREE.SpotLight && t++, g instanceof THREE.HemisphereLight && q++);
    f = s;
    g = t;
    h = q;
    t = q = 0;
    for (s = b.length; t < s; t++)
      u = b[t], u.castShadow && (u instanceof THREE.SpotLight && q++, u instanceof THREE.DirectionalLight && !u.shadowCascade && q++);
    n = q;
    ub && d && d.useVertexTexture ? p = 1024 : (b = m.getParameter(m.MAX_VERTEX_UNIFORM_VECTORS), b = Math.floor((b - 20) / 4), void 0 !== d && d instanceof THREE.SkinnedMesh && (b = Math.min(d.bones.length, b), b < d.bones.length && console.warn('WebGLRenderer: too many bones - ' + d.bones.length + ', this GPU supports just ' + b + ' (try OpenGL instead of ANGLE)')), p = b);
    a: {
      t = a.fragmentShader;
      s = a.vertexShader;
      q = a.uniforms;
      b = a.attributes;
      u = a.defines;
      c = {
        map: !!a.map,
        envMap: !!a.envMap,
        lightMap: !!a.lightMap,
        bumpMap: !!a.bumpMap,
        normalMap: !!a.normalMap,
        specularMap: !!a.specularMap,
        vertexColors: a.vertexColors,
        fog: c,
        useFog: a.fog,
        fogExp: c instanceof THREE.FogExp2,
        sizeAttenuation: a.sizeAttenuation,
        skinning: a.skinning,
        maxBones: p,
        useVertexTexture: ub && d && d.useVertexTexture,
        morphTargets: a.morphTargets,
        morphNormals: a.morphNormals,
        maxMorphTargets: this.maxMorphTargets,
        maxMorphNormals: this.maxMorphNormals,
        maxDirLights: e,
        maxPointLights: f,
        maxSpotLights: g,
        maxHemiLights: h,
        maxShadows: n,
        shadowMapEnabled: this.shadowMapEnabled && d.receiveShadow && 0 < n,
        shadowMapType: this.shadowMapType,
        shadowMapDebug: this.shadowMapDebug,
        shadowMapCascade: this.shadowMapCascade,
        alphaTest: a.alphaTest,
        metal: a.metal,
        wrapAround: a.wrapAround,
        doubleSided: a.side === THREE.DoubleSide,
        flipSided: a.side === THREE.BackSide
      };
      d = a.index0AttributeName;
      var v, w, x;
      e = [];
      r ? e.push(r) : (e.push(t), e.push(s));
      for (w in u)
        e.push(w), e.push(u[w]);
      for (v in c)
        e.push(v), e.push(c[v]);
      r = e.join();
      v = 0;
      for (w = ca.length; v < w; v++)
        if (e = ca[v], e.code === r) {
          e.usedTimes++;
          l = e.program;
          break a;
        }
      v = 'SHADOWMAP_TYPE_BASIC';
      c.shadowMapType === THREE.PCFShadowMap ? v = 'SHADOWMAP_TYPE_PCF' : c.shadowMapType === THREE.PCFSoftShadowMap && (v = 'SHADOWMAP_TYPE_PCF_SOFT');
      w = [];
      for (x in u)
        e = u[x], !1 !== e && (e = '#define ' + x + ' ' + e, w.push(e));
      e = w.join('\n');
      x = m.createProgram();
      w = [
        'precision ' + Y + ' float;',
        'precision ' + Y + ' int;',
        e,
        yb ? '#define VERTEX_TEXTURES' : '',
        N.gammaInput ? '#define GAMMA_INPUT' : '',
        N.gammaOutput ? '#define GAMMA_OUTPUT' : '',
        '#define MAX_DIR_LIGHTS ' + c.maxDirLights,
        '#define MAX_POINT_LIGHTS ' + c.maxPointLights,
        '#define MAX_SPOT_LIGHTS ' + c.maxSpotLights,
        '#define MAX_HEMI_LIGHTS ' + c.maxHemiLights,
        '#define MAX_SHADOWS ' + c.maxShadows,
        '#define MAX_BONES ' + c.maxBones,
        c.map ? '#define USE_MAP' : '',
        c.envMap ? '#define USE_ENVMAP' : '',
        c.lightMap ? '#define USE_LIGHTMAP' : '',
        c.bumpMap ? '#define USE_BUMPMAP' : '',
        c.normalMap ? '#define USE_NORMALMAP' : '',
        c.specularMap ? '#define USE_SPECULARMAP' : '',
        c.vertexColors ? '#define USE_COLOR' : '',
        c.skinning ? '#define USE_SKINNING' : '',
        c.useVertexTexture ? '#define BONE_TEXTURE' : '',
        c.morphTargets ? '#define USE_MORPHTARGETS' : '',
        c.morphNormals ? '#define USE_MORPHNORMALS' : '',
        c.wrapAround ? '#define WRAP_AROUND' : '',
        c.doubleSided ? '#define DOUBLE_SIDED' : '',
        c.flipSided ? '#define FLIP_SIDED' : '',
        c.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        c.shadowMapEnabled ? '#define ' + v : '',
        c.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
        c.shadowMapCascade ? '#define SHADOWMAP_CASCADE' : '',
        c.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
        'uniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\nattribute vec2 uv2;\n#ifdef USE_COLOR\nattribute vec3 color;\n#endif\n#ifdef USE_MORPHTARGETS\nattribute vec3 morphTarget0;\nattribute vec3 morphTarget1;\nattribute vec3 morphTarget2;\nattribute vec3 morphTarget3;\n#ifdef USE_MORPHNORMALS\nattribute vec3 morphNormal0;\nattribute vec3 morphNormal1;\nattribute vec3 morphNormal2;\nattribute vec3 morphNormal3;\n#else\nattribute vec3 morphTarget4;\nattribute vec3 morphTarget5;\nattribute vec3 morphTarget6;\nattribute vec3 morphTarget7;\n#endif\n#endif\n#ifdef USE_SKINNING\nattribute vec4 skinIndex;\nattribute vec4 skinWeight;\n#endif\n'
      ].join('\n');
      v = [
        'precision ' + Y + ' float;',
        'precision ' + Y + ' int;',
        c.bumpMap || c.normalMap ? '#extension GL_OES_standard_derivatives : enable' : '',
        e,
        '#define MAX_DIR_LIGHTS ' + c.maxDirLights,
        '#define MAX_POINT_LIGHTS ' + c.maxPointLights,
        '#define MAX_SPOT_LIGHTS ' + c.maxSpotLights,
        '#define MAX_HEMI_LIGHTS ' + c.maxHemiLights,
        '#define MAX_SHADOWS ' + c.maxShadows,
        c.alphaTest ? '#define ALPHATEST ' + c.alphaTest : '',
        N.gammaInput ? '#define GAMMA_INPUT' : '',
        N.gammaOutput ? '#define GAMMA_OUTPUT' : '',
        c.useFog && c.fog ? '#define USE_FOG' : '',
        c.useFog && c.fogExp ? '#define FOG_EXP2' : '',
        c.map ? '#define USE_MAP' : '',
        c.envMap ? '#define USE_ENVMAP' : '',
        c.lightMap ? '#define USE_LIGHTMAP' : '',
        c.bumpMap ? '#define USE_BUMPMAP' : '',
        c.normalMap ? '#define USE_NORMALMAP' : '',
        c.specularMap ? '#define USE_SPECULARMAP' : '',
        c.vertexColors ? '#define USE_COLOR' : '',
        c.metal ? '#define METAL' : '',
        c.wrapAround ? '#define WRAP_AROUND' : '',
        c.doubleSided ? '#define DOUBLE_SIDED' : '',
        c.flipSided ? '#define FLIP_SIDED' : '',
        c.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        c.shadowMapEnabled ? '#define ' + v : '',
        c.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
        c.shadowMapCascade ? '#define SHADOWMAP_CASCADE' : '',
        'uniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\n'
      ].join('\n');
      w = K('vertex', w + s);
      v = K('fragment', v + t);
      m.attachShader(x, w);
      m.attachShader(x, v);
      void 0 !== d && m.bindAttribLocation(x, 0, d);
      m.linkProgram(x);
      !1 === m.getProgramParameter(x, m.LINK_STATUS) && (console.error('Could not initialise shader'), console.error('gl.VALIDATE_STATUS', m.getProgramParameter(x, m.VALIDATE_STATUS)), console.error('gl.getError()', m.getError()));
      '' !== m.getProgramInfoLog(x) && console.error('gl.getProgramInfoLog()', m.getProgramInfoLog(x));
      m.deleteShader(v);
      m.deleteShader(w);
      x.uniforms = {};
      x.attributes = {};
      var z;
      v = 'viewMatrix modelViewMatrix projectionMatrix normalMatrix modelMatrix cameraPosition morphTargetInfluences'.split(' ');
      c.useVertexTexture ? (v.push('boneTexture'), v.push('boneTextureWidth'), v.push('boneTextureHeight')) : v.push('boneGlobalMatrices');
      for (z in q)
        v.push(z);
      z = v;
      v = 0;
      for (w = z.length; v < w; v++)
        q = z[v], x.uniforms[q] = m.getUniformLocation(x, q);
      v = 'position normal uv uv2 tangent color skinIndex skinWeight lineDistance'.split(' ');
      for (z = 0; z < c.maxMorphTargets; z++)
        v.push('morphTarget' + z);
      for (z = 0; z < c.maxMorphNormals; z++)
        v.push('morphNormal' + z);
      for (l in b)
        v.push(l);
      l = v;
      z = 0;
      for (b = l.length; z < b; z++)
        v = l[z], x.attributes[v] = m.getAttribLocation(x, v);
      x.id = sa++;
      ca.push({
        program: x,
        code: r,
        usedTimes: 1
      });
      N.info.memory.programs = ca.length;
      l = x;
    }
    a.program = l;
    z = a.program.attributes;
    if (a.morphTargets)
      for (a.numSupportedMorphTargets = 0, b = 'morphTarget', l = 0; l < this.maxMorphTargets; l++)
        x = b + l, 0 <= z[x] && a.numSupportedMorphTargets++;
    if (a.morphNormals)
      for (a.numSupportedMorphNormals = 0, b = 'morphNormal', l = 0; l < this.maxMorphNormals; l++)
        x = b + l, 0 <= z[x] && a.numSupportedMorphNormals++;
    a.uniformsList = [];
    for (k in a.uniforms)
      a.uniformsList.push([
        a.uniforms[k],
        k
      ]);
  };
  this.setFaceCulling = function (a, b) {
    a === THREE.CullFaceNone ? m.disable(m.CULL_FACE) : (b === THREE.FrontFaceDirectionCW ? m.frontFace(m.CW) : m.frontFace(m.CCW), a === THREE.CullFaceBack ? m.cullFace(m.BACK) : a === THREE.CullFaceFront ? m.cullFace(m.FRONT) : m.cullFace(m.FRONT_AND_BACK), m.enable(m.CULL_FACE));
  };
  this.setMaterialFaces = function (a) {
    var b = a.side === THREE.DoubleSide;
    a = a.side === THREE.BackSide;
    oa !== b && (b ? m.disable(m.CULL_FACE) : m.enable(m.CULL_FACE), oa = b);
    za !== a && (a ? m.frontFace(m.CW) : m.frontFace(m.CCW), za = a);
  };
  this.setDepthTest = function (a) {
    Ka !== a && (a ? m.enable(m.DEPTH_TEST) : m.disable(m.DEPTH_TEST), Ka = a);
  };
  this.setDepthWrite = function (a) {
    la !== a && (m.depthMask(a), la = a);
  };
  this.setBlending = function (a, b, c, d) {
    a !== Aa && (a === THREE.NoBlending ? m.disable(m.BLEND) : a === THREE.AdditiveBlending ? (m.enable(m.BLEND), m.blendEquation(m.FUNC_ADD), m.blendFunc(m.SRC_ALPHA, m.ONE)) : a === THREE.SubtractiveBlending ? (m.enable(m.BLEND), m.blendEquation(m.FUNC_ADD), m.blendFunc(m.ZERO, m.ONE_MINUS_SRC_COLOR)) : a === THREE.MultiplyBlending ? (m.enable(m.BLEND), m.blendEquation(m.FUNC_ADD), m.blendFunc(m.ZERO, m.SRC_COLOR)) : a === THREE.CustomBlending ? m.enable(m.BLEND) : (m.enable(m.BLEND), m.blendEquationSeparate(m.FUNC_ADD, m.FUNC_ADD), m.blendFuncSeparate(m.SRC_ALPHA, m.ONE_MINUS_SRC_ALPHA, m.ONE, m.ONE_MINUS_SRC_ALPHA)), Aa = a);
    if (a === THREE.CustomBlending) {
      if (b !== Ua && (m.blendEquation(A(b)), Ua = b), c !== Va || d !== ka)
        m.blendFunc(A(c), A(d)), Va = c, ka = d;
    } else
      ka = Va = Ua = null;
  };
  this.setTexture = function (a, b) {
    if (a.needsUpdate) {
      a.__webglInit || (a.__webglInit = !0, a.addEventListener('dispose', Cb), a.__webglTexture = m.createTexture(), N.info.memory.textures++);
      m.activeTexture(m.TEXTURE0 + b);
      m.bindTexture(m.TEXTURE_2D, a.__webglTexture);
      m.pixelStorei(m.UNPACK_FLIP_Y_WEBGL, a.flipY);
      m.pixelStorei(m.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha);
      m.pixelStorei(m.UNPACK_ALIGNMENT, a.unpackAlignment);
      var c = a.image, d = THREE.Math.isPowerOfTwo(c.width) && THREE.Math.isPowerOfTwo(c.height), e = A(a.format), f = A(a.type);
      y(m.TEXTURE_2D, a, d);
      var g = a.mipmaps;
      if (a instanceof THREE.DataTexture)
        if (0 < g.length && d) {
          for (var h = 0, k = g.length; h < k; h++)
            c = g[h], m.texImage2D(m.TEXTURE_2D, h, e, c.width, c.height, 0, e, f, c.data);
          a.generateMipmaps = !1;
        } else
          m.texImage2D(m.TEXTURE_2D, 0, e, c.width, c.height, 0, e, f, c.data);
      else if (a instanceof THREE.CompressedTexture)
        for (h = 0, k = g.length; h < k; h++)
          c = g[h], a.format !== THREE.RGBAFormat ? m.compressedTexImage2D(m.TEXTURE_2D, h, e, c.width, c.height, 0, c.data) : m.texImage2D(m.TEXTURE_2D, h, e, c.width, c.height, 0, e, f, c.data);
      else if (0 < g.length && d) {
        h = 0;
        for (k = g.length; h < k; h++)
          c = g[h], m.texImage2D(m.TEXTURE_2D, h, e, e, f, c);
        a.generateMipmaps = !1;
      } else
        m.texImage2D(m.TEXTURE_2D, 0, e, e, f, a.image);
      a.generateMipmaps && d && m.generateMipmap(m.TEXTURE_2D);
      a.needsUpdate = !1;
      if (a.onUpdate)
        a.onUpdate();
    } else
      m.activeTexture(m.TEXTURE0 + b), m.bindTexture(m.TEXTURE_2D, a.__webglTexture);
  };
  this.setRenderTarget = function (a) {
    var b = a instanceof THREE.WebGLRenderTargetCube;
    if (a && !a.__webglFramebuffer) {
      void 0 === a.depthBuffer && (a.depthBuffer = !0);
      void 0 === a.stencilBuffer && (a.stencilBuffer = !0);
      a.addEventListener('dispose', Lb);
      a.__webglTexture = m.createTexture();
      N.info.memory.textures++;
      var c = THREE.Math.isPowerOfTwo(a.width) && THREE.Math.isPowerOfTwo(a.height), d = A(a.format), e = A(a.type);
      if (b) {
        a.__webglFramebuffer = [];
        a.__webglRenderbuffer = [];
        m.bindTexture(m.TEXTURE_CUBE_MAP, a.__webglTexture);
        y(m.TEXTURE_CUBE_MAP, a, c);
        for (var f = 0; 6 > f; f++) {
          a.__webglFramebuffer[f] = m.createFramebuffer();
          a.__webglRenderbuffer[f] = m.createRenderbuffer();
          m.texImage2D(m.TEXTURE_CUBE_MAP_POSITIVE_X + f, 0, d, a.width, a.height, 0, d, e, null);
          var g = a, h = m.TEXTURE_CUBE_MAP_POSITIVE_X + f;
          m.bindFramebuffer(m.FRAMEBUFFER, a.__webglFramebuffer[f]);
          m.framebufferTexture2D(m.FRAMEBUFFER, m.COLOR_ATTACHMENT0, h, g.__webglTexture, 0);
          F(a.__webglRenderbuffer[f], a);
        }
        c && m.generateMipmap(m.TEXTURE_CUBE_MAP);
      } else
        a.__webglFramebuffer = m.createFramebuffer(), a.__webglRenderbuffer = a.shareDepthFrom ? a.shareDepthFrom.__webglRenderbuffer : m.createRenderbuffer(), m.bindTexture(m.TEXTURE_2D, a.__webglTexture), y(m.TEXTURE_2D, a, c), m.texImage2D(m.TEXTURE_2D, 0, d, a.width, a.height, 0, d, e, null), d = m.TEXTURE_2D, m.bindFramebuffer(m.FRAMEBUFFER, a.__webglFramebuffer), m.framebufferTexture2D(m.FRAMEBUFFER, m.COLOR_ATTACHMENT0, d, a.__webglTexture, 0), a.shareDepthFrom ? a.depthBuffer && !a.stencilBuffer ? m.framebufferRenderbuffer(m.FRAMEBUFFER, m.DEPTH_ATTACHMENT, m.RENDERBUFFER, a.__webglRenderbuffer) : a.depthBuffer && a.stencilBuffer && m.framebufferRenderbuffer(m.FRAMEBUFFER, m.DEPTH_STENCIL_ATTACHMENT, m.RENDERBUFFER, a.__webglRenderbuffer) : F(a.__webglRenderbuffer, a), c && m.generateMipmap(m.TEXTURE_2D);
      b ? m.bindTexture(m.TEXTURE_CUBE_MAP, null) : m.bindTexture(m.TEXTURE_2D, null);
      m.bindRenderbuffer(m.RENDERBUFFER, null);
      m.bindFramebuffer(m.FRAMEBUFFER, null);
    }
    a ? (b = b ? a.__webglFramebuffer[a.activeCubeFace] : a.__webglFramebuffer, c = a.width, a = a.height, e = d = 0) : (b = null, c = xa, a = Da, d = ba, e = wa);
    b !== Ja && (m.bindFramebuffer(m.FRAMEBUFFER, b), m.viewport(d, e, c, a), Ja = b);
    Wa = c;
    La = a;
  };
  this.shadowMapPlugin = new THREE.ShadowMapPlugin();
  this.addPrePlugin(this.shadowMapPlugin);
  this.addPostPlugin(new THREE.SpritePlugin());
  this.addPostPlugin(new THREE.LensFlarePlugin());
};
THREE.WebGLRenderTarget = function (a, b, c) {
  this.width = a;
  this.height = b;
  c = c || {};
  this.wrapS = void 0 !== c.wrapS ? c.wrapS : THREE.ClampToEdgeWrapping;
  this.wrapT = void 0 !== c.wrapT ? c.wrapT : THREE.ClampToEdgeWrapping;
  this.magFilter = void 0 !== c.magFilter ? c.magFilter : THREE.LinearFilter;
  this.minFilter = void 0 !== c.minFilter ? c.minFilter : THREE.LinearMipMapLinearFilter;
  this.anisotropy = void 0 !== c.anisotropy ? c.anisotropy : 1;
  this.offset = new THREE.Vector2(0, 0);
  this.repeat = new THREE.Vector2(1, 1);
  this.format = void 0 !== c.format ? c.format : THREE.RGBAFormat;
  this.type = void 0 !== c.type ? c.type : THREE.UnsignedByteType;
  this.depthBuffer = void 0 !== c.depthBuffer ? c.depthBuffer : !0;
  this.stencilBuffer = void 0 !== c.stencilBuffer ? c.stencilBuffer : !0;
  this.generateMipmaps = !0;
  this.shareDepthFrom = null;
};
THREE.WebGLRenderTarget.prototype = {
  constructor: THREE.WebGLRenderTarget,
  clone: function () {
    var a = new THREE.WebGLRenderTarget(this.width, this.height);
    a.wrapS = this.wrapS;
    a.wrapT = this.wrapT;
    a.magFilter = this.magFilter;
    a.minFilter = this.minFilter;
    a.anisotropy = this.anisotropy;
    a.offset.copy(this.offset);
    a.repeat.copy(this.repeat);
    a.format = this.format;
    a.type = this.type;
    a.depthBuffer = this.depthBuffer;
    a.stencilBuffer = this.stencilBuffer;
    a.generateMipmaps = this.generateMipmaps;
    a.shareDepthFrom = this.shareDepthFrom;
    return a;
  },
  dispose: function () {
    this.dispatchEvent({ type: 'dispose' });
  }
};
THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype);
THREE.WebGLRenderTargetCube = function (a, b, c) {
  THREE.WebGLRenderTarget.call(this, a, b, c);
  this.activeCubeFace = 0;
};
THREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype);
THREE.RenderableVertex = function () {
  this.position = new THREE.Vector3();
  this.positionWorld = new THREE.Vector3();
  this.positionScreen = new THREE.Vector4();
  this.visible = !0;
};
THREE.RenderableVertex.prototype.copy = function (a) {
  this.positionWorld.copy(a.positionWorld);
  this.positionScreen.copy(a.positionScreen);
};
THREE.RenderableFace = function () {
  this.id = 0;
  this.v1 = new THREE.RenderableVertex();
  this.v2 = new THREE.RenderableVertex();
  this.v3 = new THREE.RenderableVertex();
  this.centroidModel = new THREE.Vector3();
  this.normalModel = new THREE.Vector3();
  this.vertexNormalsModel = [
    new THREE.Vector3(),
    new THREE.Vector3(),
    new THREE.Vector3()
  ];
  this.vertexNormalsLength = 0;
  this.material = this.color = null;
  this.uvs = [[]];
  this.z = 0;
};
THREE.RenderableObject = function () {
  this.id = 0;
  this.object = null;
  this.z = 0;
};
THREE.RenderableSprite = function () {
  this.id = 0;
  this.object = null;
  this.rotation = this.z = this.y = this.x = 0;
  this.scale = new THREE.Vector2();
  this.material = null;
};
THREE.RenderableLine = function () {
  this.id = 0;
  this.v1 = new THREE.RenderableVertex();
  this.v2 = new THREE.RenderableVertex();
  this.vertexColors = [
    new THREE.Color(),
    new THREE.Color()
  ];
  this.material = null;
  this.z = 0;
};
THREE.GeometryUtils = {
  merge: function (a, b, c) {
    var d, e, f = a.vertices.length, g = b instanceof THREE.Mesh ? b.geometry : b, h = a.vertices, k = g.vertices, l = a.faces, n = g.faces;
    a = a.faceVertexUvs[0];
    g = g.faceVertexUvs[0];
    void 0 === c && (c = 0);
    b instanceof THREE.Mesh && (b.matrixAutoUpdate && b.updateMatrix(), d = b.matrix, e = new THREE.Matrix3().getNormalMatrix(d));
    b = 0;
    for (var s = k.length; b < s; b++) {
      var r = k[b].clone();
      d && r.applyMatrix4(d);
      h.push(r);
    }
    b = 0;
    for (s = n.length; b < s; b++) {
      var r = n[b], q, u, p = r.vertexNormals, v = r.vertexColors;
      q = new THREE.Face3(r.a + f, r.b + f, r.c + f);
      q.normal.copy(r.normal);
      e && q.normal.applyMatrix3(e).normalize();
      h = 0;
      for (k = p.length; h < k; h++)
        u = p[h].clone(), e && u.applyMatrix3(e).normalize(), q.vertexNormals.push(u);
      q.color.copy(r.color);
      h = 0;
      for (k = v.length; h < k; h++)
        u = v[h], q.vertexColors.push(u.clone());
      q.materialIndex = r.materialIndex + c;
      q.centroid.copy(r.centroid);
      d && q.centroid.applyMatrix4(d);
      l.push(q);
    }
    b = 0;
    for (s = g.length; b < s; b++) {
      c = g[b];
      d = [];
      h = 0;
      for (k = c.length; h < k; h++)
        d.push(new THREE.Vector2(c[h].x, c[h].y));
      a.push(d);
    }
  },
  randomPointInTriangle: function () {
    var a = new THREE.Vector3();
    return function (b, c, d) {
      var e = new THREE.Vector3(), f = THREE.Math.random16(), g = THREE.Math.random16();
      1 < f + g && (f = 1 - f, g = 1 - g);
      var h = 1 - f - g;
      e.copy(b);
      e.multiplyScalar(f);
      a.copy(c);
      a.multiplyScalar(g);
      e.add(a);
      a.copy(d);
      a.multiplyScalar(h);
      e.add(a);
      return e;
    };
  }(),
  randomPointInFace: function (a, b, c) {
    return THREE.GeometryUtils.randomPointInTriangle(b.vertices[a.a], b.vertices[a.b], b.vertices[a.c]);
  },
  randomPointsInGeometry: function (a, b) {
    function c(a) {
      function b(c, d) {
        if (d < c)
          return c;
        var e = c + Math.floor((d - c) / 2);
        return l[e] > a ? b(c, e - 1) : l[e] < a ? b(e + 1, d) : e;
      }
      return b(0, l.length - 1);
    }
    var d, e, f = a.faces, g = a.vertices, h = f.length, k = 0, l = [], n, s, r;
    for (e = 0; e < h; e++)
      d = f[e], n = g[d.a], s = g[d.b], r = g[d.c], d._area = THREE.GeometryUtils.triangleArea(n, s, r), k += d._area, l[e] = k;
    d = [];
    for (e = 0; e < b; e++)
      g = THREE.Math.random16() * k, g = c(g), d[e] = THREE.GeometryUtils.randomPointInFace(f[g], a, !0);
    return d;
  },
  triangleArea: function () {
    var a = new THREE.Vector3(), b = new THREE.Vector3();
    return function (c, d, e) {
      a.subVectors(d, c);
      b.subVectors(e, c);
      a.cross(b);
      return 0.5 * a.length();
    };
  }(),
  center: function (a) {
    a.computeBoundingBox();
    var b = a.boundingBox, c = new THREE.Vector3();
    c.addVectors(b.min, b.max);
    c.multiplyScalar(-0.5);
    a.applyMatrix(new THREE.Matrix4().makeTranslation(c.x, c.y, c.z));
    a.computeBoundingBox();
    return c;
  },
  triangulateQuads: function (a) {
    var b, c, d, e, f = [], g = [];
    b = 0;
    for (c = a.faceVertexUvs.length; b < c; b++)
      g[b] = [];
    b = 0;
    for (c = a.faces.length; b < c; b++)
      for (f.push(a.faces[b]), d = 0, e = a.faceVertexUvs.length; d < e; d++)
        g[d].push(a.faceVertexUvs[d][b]);
    a.faces = f;
    a.faceVertexUvs = g;
    a.computeCentroids();
    a.computeFaceNormals();
    a.computeVertexNormals();
    a.hasTangents && a.computeTangents();
  }
};
THREE.ImageUtils = {
  crossOrigin: void 0,
  loadTexture: function (a, b, c, d) {
    d = new THREE.ImageLoader();
    d.crossOrigin = this.crossOrigin;
    var e = new THREE.Texture(void 0, b);
    b = d.load(a, function () {
      e.needsUpdate = !0;
      c && c(e);
    });
    e.image = b;
    e.sourceFile = a;
    return e;
  },
  loadCompressedTexture: function (a, b, c, d) {
    var e = new THREE.CompressedTexture();
    e.mapping = b;
    var f = new XMLHttpRequest();
    f.onload = function () {
      var a = THREE.ImageUtils.parseDDS(f.response, !0);
      e.format = a.format;
      e.mipmaps = a.mipmaps;
      e.image.width = a.width;
      e.image.height = a.height;
      e.generateMipmaps = !1;
      e.needsUpdate = !0;
      c && c(e);
    };
    f.onerror = d;
    f.open('GET', a, !0);
    f.responseType = 'arraybuffer';
    f.send(null);
    return e;
  },
  loadTextureCube: function (a, b, c, d) {
    var e = [];
    e.loadCount = 0;
    var f = new THREE.Texture();
    f.image = e;
    void 0 !== b && (f.mapping = b);
    f.flipY = !1;
    b = 0;
    for (var g = a.length; b < g; ++b) {
      var h = new Image();
      e[b] = h;
      h.onload = function () {
        e.loadCount += 1;
        6 === e.loadCount && (f.needsUpdate = !0, c && c(f));
      };
      h.onerror = d;
      h.crossOrigin = this.crossOrigin;
      h.src = a[b];
    }
    return f;
  },
  loadCompressedTextureCube: function (a, b, c, d) {
    var e = [];
    e.loadCount = 0;
    var f = new THREE.CompressedTexture();
    f.image = e;
    void 0 !== b && (f.mapping = b);
    f.flipY = !1;
    f.generateMipmaps = !1;
    b = function (a, b) {
      return function () {
        var d = THREE.ImageUtils.parseDDS(a.response, !0);
        b.format = d.format;
        b.mipmaps = d.mipmaps;
        b.width = d.width;
        b.height = d.height;
        e.loadCount += 1;
        6 === e.loadCount && (f.format = d.format, f.needsUpdate = !0, c && c(f));
      };
    };
    if (a instanceof Array)
      for (var g = 0, h = a.length; g < h; ++g) {
        var k = {};
        e[g] = k;
        var l = new XMLHttpRequest();
        l.onload = b(l, k);
        l.onerror = d;
        k = a[g];
        l.open('GET', k, !0);
        l.responseType = 'arraybuffer';
        l.send(null);
      }
    else
      l = new XMLHttpRequest(), l.onload = function () {
        var a = THREE.ImageUtils.parseDDS(l.response, !0);
        if (a.isCubemap) {
          for (var b = a.mipmaps.length / a.mipmapCount, d = 0; d < b; d++) {
            e[d] = { mipmaps: [] };
            for (var g = 0; g < a.mipmapCount; g++)
              e[d].mipmaps.push(a.mipmaps[d * a.mipmapCount + g]), e[d].format = a.format, e[d].width = a.width, e[d].height = a.height;
          }
          f.format = a.format;
          f.needsUpdate = !0;
          c && c(f);
        }
      }, l.onerror = d, l.open('GET', a, !0), l.responseType = 'arraybuffer', l.send(null);
    return f;
  },
  loadDDSTexture: function (a, b, c, d) {
    var e = [];
    e.loadCount = 0;
    var f = new THREE.CompressedTexture();
    f.image = e;
    void 0 !== b && (f.mapping = b);
    f.flipY = !1;
    f.generateMipmaps = !1;
    var g = new XMLHttpRequest();
    g.onload = function () {
      var a = THREE.ImageUtils.parseDDS(g.response, !0);
      if (a.isCubemap)
        for (var b = a.mipmaps.length / a.mipmapCount, d = 0; d < b; d++) {
          e[d] = { mipmaps: [] };
          for (var n = 0; n < a.mipmapCount; n++)
            e[d].mipmaps.push(a.mipmaps[d * a.mipmapCount + n]), e[d].format = a.format, e[d].width = a.width, e[d].height = a.height;
        }
      else
        f.image.width = a.width, f.image.height = a.height, f.mipmaps = a.mipmaps;
      f.format = a.format;
      f.needsUpdate = !0;
      c && c(f);
    };
    g.onerror = d;
    g.open('GET', a, !0);
    g.responseType = 'arraybuffer';
    g.send(null);
    return f;
  },
  parseDDS: function (a, b) {
    function c(a) {
      return a.charCodeAt(0) + (a.charCodeAt(1) << 8) + (a.charCodeAt(2) << 16) + (a.charCodeAt(3) << 24);
    }
    function d(a, b, c, d) {
      var e = c * d * 4;
      a = new Uint8Array(a, b, e);
      for (var e = new Uint8Array(e), f = b = 0, g = 0; g < d; g++)
        for (var h = 0; h < c; h++) {
          var k = a[f];
          f++;
          var l = a[f];
          f++;
          var n = a[f];
          f++;
          var q = a[f];
          f++;
          e[b] = n;
          b++;
          e[b] = l;
          b++;
          e[b] = k;
          b++;
          e[b] = q;
          b++;
        }
      return e;
    }
    var e = {
        mipmaps: [],
        width: 0,
        height: 0,
        format: null,
        mipmapCount: 1
      }, f = c('DXT1'), g = c('DXT3'), h = c('DXT5'), k = new Int32Array(a, 0, 31);
    if (542327876 !== k[0])
      return console.error('ImageUtils.parseDDS(): Invalid magic number in DDS header'), e;
    if (!k[20] & 4)
      return console.error('ImageUtils.parseDDS(): Unsupported format, must contain a FourCC code'), e;
    var l = k[21], n = !1;
    switch (l) {
    case f:
      f = 8;
      e.format = THREE.RGB_S3TC_DXT1_Format;
      break;
    case g:
      f = 16;
      e.format = THREE.RGBA_S3TC_DXT3_Format;
      break;
    case h:
      f = 16;
      e.format = THREE.RGBA_S3TC_DXT5_Format;
      break;
    default:
      if (32 == k[22] && k[23] & 16711680 && k[24] & 65280 && k[25] & 255 && k[26] & 4278190080)
        n = !0, f = 64, e.format = THREE.RGBAFormat;
      else
        return console.error('ImageUtils.parseDDS(): Unsupported FourCC code: ', String.fromCharCode(l & 255, l >> 8 & 255, l >> 16 & 255, l >> 24 & 255)), e;
    }
    e.mipmapCount = 1;
    k[2] & 131072 && !1 !== b && (e.mipmapCount = Math.max(1, k[7]));
    e.isCubemap = k[28] & 512 ? !0 : !1;
    e.width = k[4];
    e.height = k[3];
    for (var k = k[1] + 4, g = e.width, h = e.height, l = e.isCubemap ? 6 : 1, s = 0; s < l; s++) {
      for (var r = 0; r < e.mipmapCount; r++) {
        if (n)
          var q = d(a, k, g, h), u = q.length;
        else
          u = Math.max(4, g) / 4 * Math.max(4, h) / 4 * f, q = new Uint8Array(a, k, u);
        e.mipmaps.push({
          data: q,
          width: g,
          height: h
        });
        k += u;
        g = Math.max(0.5 * g, 1);
        h = Math.max(0.5 * h, 1);
      }
      g = e.width;
      h = e.height;
    }
    return e;
  },
  getNormalMap: function (a, b) {
    var c = function (a) {
      var b = Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
      return [
        a[0] / b,
        a[1] / b,
        a[2] / b
      ];
    };
    b |= 1;
    var d = a.width, e = a.height, f = document.createElement('canvas');
    f.width = d;
    f.height = e;
    var g = f.getContext('2d');
    g.drawImage(a, 0, 0);
    for (var h = g.getImageData(0, 0, d, e).data, k = g.createImageData(d, e), l = k.data, n = 0; n < d; n++)
      for (var s = 0; s < e; s++) {
        var r = 0 > s - 1 ? 0 : s - 1, q = s + 1 > e - 1 ? e - 1 : s + 1, u = 0 > n - 1 ? 0 : n - 1, p = n + 1 > d - 1 ? d - 1 : n + 1, v = [], w = [
            0,
            0,
            h[4 * (s * d + n)] / 255 * b
          ];
        v.push([
          -1,
          0,
          h[4 * (s * d + u)] / 255 * b
        ]);
        v.push([
          -1,
          -1,
          h[4 * (r * d + u)] / 255 * b
        ]);
        v.push([
          0,
          -1,
          h[4 * (r * d + n)] / 255 * b
        ]);
        v.push([
          1,
          -1,
          h[4 * (r * d + p)] / 255 * b
        ]);
        v.push([
          1,
          0,
          h[4 * (s * d + p)] / 255 * b
        ]);
        v.push([
          1,
          1,
          h[4 * (q * d + p)] / 255 * b
        ]);
        v.push([
          0,
          1,
          h[4 * (q * d + n)] / 255 * b
        ]);
        v.push([
          -1,
          1,
          h[4 * (q * d + u)] / 255 * b
        ]);
        r = [];
        u = v.length;
        for (q = 0; q < u; q++) {
          var p = v[q], t = v[(q + 1) % u], p = [
              p[0] - w[0],
              p[1] - w[1],
              p[2] - w[2]
            ], t = [
              t[0] - w[0],
              t[1] - w[1],
              t[2] - w[2]
            ];
          r.push(c([
            p[1] * t[2] - p[2] * t[1],
            p[2] * t[0] - p[0] * t[2],
            p[0] * t[1] - p[1] * t[0]
          ]));
        }
        v = [
          0,
          0,
          0
        ];
        for (q = 0; q < r.length; q++)
          v[0] += r[q][0], v[1] += r[q][1], v[2] += r[q][2];
        v[0] /= r.length;
        v[1] /= r.length;
        v[2] /= r.length;
        w = 4 * (s * d + n);
        l[w] = (v[0] + 1) / 2 * 255 | 0;
        l[w + 1] = (v[1] + 1) / 2 * 255 | 0;
        l[w + 2] = 255 * v[2] | 0;
        l[w + 3] = 255;
      }
    g.putImageData(k, 0, 0);
    return f;
  },
  generateDataTexture: function (a, b, c) {
    var d = a * b, e = new Uint8Array(3 * d), f = Math.floor(255 * c.r), g = Math.floor(255 * c.g);
    c = Math.floor(255 * c.b);
    for (var h = 0; h < d; h++)
      e[3 * h] = f, e[3 * h + 1] = g, e[3 * h + 2] = c;
    a = new THREE.DataTexture(e, a, b, THREE.RGBFormat);
    a.needsUpdate = !0;
    return a;
  }
};
THREE.SceneUtils = {
  createMultiMaterialObject: function (a, b) {
    for (var c = new THREE.Object3D(), d = 0, e = b.length; d < e; d++)
      c.add(new THREE.Mesh(a, b[d]));
    return c;
  },
  detach: function (a, b, c) {
    a.applyMatrix(b.matrixWorld);
    b.remove(a);
    c.add(a);
  },
  attach: function (a, b, c) {
    var d = new THREE.Matrix4();
    d.getInverse(c.matrixWorld);
    a.applyMatrix(d);
    b.remove(a);
    c.add(a);
  }
};
THREE.FontUtils = {
  faces: {},
  face: 'helvetiker',
  weight: 'normal',
  style: 'normal',
  size: 150,
  divisions: 10,
  getFace: function () {
    return this.faces[this.face][this.weight][this.style];
  },
  loadFace: function (a) {
    var b = a.familyName.toLowerCase();
    this.faces[b] = this.faces[b] || {};
    this.faces[b][a.cssFontWeight] = this.faces[b][a.cssFontWeight] || {};
    this.faces[b][a.cssFontWeight][a.cssFontStyle] = a;
    return this.faces[b][a.cssFontWeight][a.cssFontStyle] = a;
  },
  drawText: function (a) {
    var b = this.getFace(), c = this.size / b.resolution, d = 0, e = String(a).split(''), f = e.length, g = [];
    for (a = 0; a < f; a++) {
      var h = new THREE.Path(), h = this.extractGlyphPoints(e[a], b, c, d, h), d = d + h.offset;
      g.push(h.path);
    }
    return {
      paths: g,
      offset: d / 2
    };
  },
  extractGlyphPoints: function (a, b, c, d, e) {
    var f = [], g, h, k, l, n, s, r, q, u, p, v, w = b.glyphs[a] || b.glyphs['?'];
    if (w) {
      if (w.o)
        for (b = w._cachedOutline || (w._cachedOutline = w.o.split(' ')), l = b.length, a = 0; a < l;)
          switch (k = b[a++], k) {
          case 'm':
            k = b[a++] * c + d;
            n = b[a++] * c;
            e.moveTo(k, n);
            break;
          case 'l':
            k = b[a++] * c + d;
            n = b[a++] * c;
            e.lineTo(k, n);
            break;
          case 'q':
            k = b[a++] * c + d;
            n = b[a++] * c;
            q = b[a++] * c + d;
            u = b[a++] * c;
            e.quadraticCurveTo(q, u, k, n);
            if (g = f[f.length - 1])
              for (s = g.x, r = g.y, g = 1, h = this.divisions; g <= h; g++) {
                var t = g / h;
                THREE.Shape.Utils.b2(t, s, q, k);
                THREE.Shape.Utils.b2(t, r, u, n);
              }
            break;
          case 'b':
            if (k = b[a++] * c + d, n = b[a++] * c, q = b[a++] * c + d, u = b[a++] * -c, p = b[a++] * c + d, v = b[a++] * -c, e.bezierCurveTo(k, n, q, u, p, v), g = f[f.length - 1])
              for (s = g.x, r = g.y, g = 1, h = this.divisions; g <= h; g++)
                t = g / h, THREE.Shape.Utils.b3(t, s, q, p, k), THREE.Shape.Utils.b3(t, r, u, v, n);
          }
      return {
        offset: w.ha * c,
        path: e
      };
    }
  }
};
THREE.FontUtils.generateShapes = function (a, b) {
  b = b || {};
  var c = void 0 !== b.curveSegments ? b.curveSegments : 4, d = void 0 !== b.font ? b.font : 'helvetiker', e = void 0 !== b.weight ? b.weight : 'normal', f = void 0 !== b.style ? b.style : 'normal';
  THREE.FontUtils.size = void 0 !== b.size ? b.size : 100;
  THREE.FontUtils.divisions = c;
  THREE.FontUtils.face = d;
  THREE.FontUtils.weight = e;
  THREE.FontUtils.style = f;
  c = THREE.FontUtils.drawText(a).paths;
  d = [];
  e = 0;
  for (f = c.length; e < f; e++)
    Array.prototype.push.apply(d, c[e].toShapes());
  return d;
};
(function (a) {
  var b = function (a) {
    for (var b = a.length, e = 0, f = b - 1, g = 0; g < b; f = g++)
      e += a[f].x * a[g].y - a[g].x * a[f].y;
    return 0.5 * e;
  };
  a.Triangulate = function (a, d) {
    var e = a.length;
    if (3 > e)
      return null;
    var f = [], g = [], h = [], k, l, n;
    if (0 < b(a))
      for (l = 0; l < e; l++)
        g[l] = l;
    else
      for (l = 0; l < e; l++)
        g[l] = e - 1 - l;
    var s = 2 * e;
    for (l = e - 1; 2 < e;) {
      if (0 >= s--) {
        console.log('Warning, unable to triangulate polygon!');
        break;
      }
      k = l;
      e <= k && (k = 0);
      l = k + 1;
      e <= l && (l = 0);
      n = l + 1;
      e <= n && (n = 0);
      var r;
      a: {
        var q = r = void 0, u = void 0, p = void 0, v = void 0, w = void 0, t = void 0, x = void 0, z = void 0, q = a[g[k]].x, u = a[g[k]].y, p = a[g[l]].x, v = a[g[l]].y, w = a[g[n]].x, t = a[g[n]].y;
        if (1e-10 > (p - q) * (t - u) - (v - u) * (w - q))
          r = !1;
        else {
          var B = void 0, E = void 0, H = void 0, D = void 0, G = void 0, I = void 0, O = void 0, K = void 0, y = void 0, F = void 0, y = K = O = z = x = void 0, B = w - p, E = t - v, H = q - w, D = u - t, G = p - q, I = v - u;
          for (r = 0; r < e; r++)
            if (x = a[g[r]].x, z = a[g[r]].y, !(x === q && z === u || x === p && z === v || x === w && z === t) && (O = x - q, K = z - u, y = x - p, F = z - v, x -= w, z -= t, y = B * F - E * y, O = G * K - I * O, K = H * z - D * x, -1e-10 <= y && -1e-10 <= K && -1e-10 <= O)) {
              r = !1;
              break a;
            }
          r = !0;
        }
      }
      if (r) {
        f.push([
          a[g[k]],
          a[g[l]],
          a[g[n]]
        ]);
        h.push([
          g[k],
          g[l],
          g[n]
        ]);
        k = l;
        for (n = l + 1; n < e; k++, n++)
          g[k] = g[n];
        e--;
        s = 2 * e;
      }
    }
    return d ? h : f;
  };
  a.Triangulate.area = b;
  return a;
}(THREE.FontUtils));
self._typeface_js = {
  faces: THREE.FontUtils.faces,
  loadFace: THREE.FontUtils.loadFace
};
THREE.typeface_js = self._typeface_js;
THREE.Curve = function () {
};
THREE.Curve.prototype.getPoint = function (a) {
  console.log('Warning, getPoint() not implemented!');
  return null;
};
THREE.Curve.prototype.getPointAt = function (a) {
  a = this.getUtoTmapping(a);
  return this.getPoint(a);
};
THREE.Curve.prototype.getPoints = function (a) {
  a || (a = 5);
  var b, c = [];
  for (b = 0; b <= a; b++)
    c.push(this.getPoint(b / a));
  return c;
};
THREE.Curve.prototype.getSpacedPoints = function (a) {
  a || (a = 5);
  var b, c = [];
  for (b = 0; b <= a; b++)
    c.push(this.getPointAt(b / a));
  return c;
};
THREE.Curve.prototype.getLength = function () {
  var a = this.getLengths();
  return a[a.length - 1];
};
THREE.Curve.prototype.getLengths = function (a) {
  a || (a = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200);
  if (this.cacheArcLengths && this.cacheArcLengths.length == a + 1 && !this.needsUpdate)
    return this.cacheArcLengths;
  this.needsUpdate = !1;
  var b = [], c, d = this.getPoint(0), e, f = 0;
  b.push(0);
  for (e = 1; e <= a; e++)
    c = this.getPoint(e / a), f += c.distanceTo(d), b.push(f), d = c;
  return this.cacheArcLengths = b;
};
THREE.Curve.prototype.updateArcLengths = function () {
  this.needsUpdate = !0;
  this.getLengths();
};
THREE.Curve.prototype.getUtoTmapping = function (a, b) {
  var c = this.getLengths(), d = 0, e = c.length, f;
  f = b ? b : a * c[e - 1];
  for (var g = 0, h = e - 1, k; g <= h;)
    if (d = Math.floor(g + (h - g) / 2), k = c[d] - f, 0 > k)
      g = d + 1;
    else if (0 < k)
      h = d - 1;
    else {
      h = d;
      break;
    }
  d = h;
  if (c[d] == f)
    return d / (e - 1);
  g = c[d];
  return c = (d + (f - g) / (c[d + 1] - g)) / (e - 1);
};
THREE.Curve.prototype.getTangent = function (a) {
  var b = a - 0.0001;
  a += 0.0001;
  0 > b && (b = 0);
  1 < a && (a = 1);
  b = this.getPoint(b);
  return this.getPoint(a).clone().sub(b).normalize();
};
THREE.Curve.prototype.getTangentAt = function (a) {
  a = this.getUtoTmapping(a);
  return this.getTangent(a);
};
THREE.Curve.Utils = {
  tangentQuadraticBezier: function (a, b, c, d) {
    return 2 * (1 - a) * (c - b) + 2 * a * (d - c);
  },
  tangentCubicBezier: function (a, b, c, d, e) {
    return -3 * b * (1 - a) * (1 - a) + 3 * c * (1 - a) * (1 - a) - 6 * a * c * (1 - a) + 6 * a * d * (1 - a) - 3 * a * a * d + 3 * a * a * e;
  },
  tangentSpline: function (a, b, c, d, e) {
    return 6 * a * a - 6 * a + (3 * a * a - 4 * a + 1) + (-6 * a * a + 6 * a) + (3 * a * a - 2 * a);
  },
  interpolate: function (a, b, c, d, e) {
    a = 0.5 * (c - a);
    d = 0.5 * (d - b);
    var f = e * e;
    return (2 * b - 2 * c + a + d) * e * f + (-3 * b + 3 * c - 2 * a - d) * f + a * e + b;
  }
};
THREE.Curve.create = function (a, b) {
  a.prototype = Object.create(THREE.Curve.prototype);
  a.prototype.getPoint = b;
  return a;
};
THREE.CurvePath = function () {
  this.curves = [];
  this.bends = [];
  this.autoClose = !1;
};
THREE.CurvePath.prototype = Object.create(THREE.Curve.prototype);
THREE.CurvePath.prototype.add = function (a) {
  this.curves.push(a);
};
THREE.CurvePath.prototype.checkConnection = function () {
};
THREE.CurvePath.prototype.closePath = function () {
  var a = this.curves[0].getPoint(0), b = this.curves[this.curves.length - 1].getPoint(1);
  a.equals(b) || this.curves.push(new THREE.LineCurve(b, a));
};
THREE.CurvePath.prototype.getPoint = function (a) {
  var b = a * this.getLength(), c = this.getCurveLengths();
  for (a = 0; a < c.length;) {
    if (c[a] >= b)
      return b = c[a] - b, a = this.curves[a], b = 1 - b / a.getLength(), a.getPointAt(b);
    a++;
  }
  return null;
};
THREE.CurvePath.prototype.getLength = function () {
  var a = this.getCurveLengths();
  return a[a.length - 1];
};
THREE.CurvePath.prototype.getCurveLengths = function () {
  if (this.cacheLengths && this.cacheLengths.length == this.curves.length)
    return this.cacheLengths;
  var a = [], b = 0, c, d = this.curves.length;
  for (c = 0; c < d; c++)
    b += this.curves[c].getLength(), a.push(b);
  return this.cacheLengths = a;
};
THREE.CurvePath.prototype.getBoundingBox = function () {
  var a = this.getPoints(), b, c, d, e, f, g;
  b = c = Number.NEGATIVE_INFINITY;
  e = f = Number.POSITIVE_INFINITY;
  var h, k, l, n, s = a[0] instanceof THREE.Vector3;
  n = s ? new THREE.Vector3() : new THREE.Vector2();
  k = 0;
  for (l = a.length; k < l; k++)
    h = a[k], h.x > b ? b = h.x : h.x < e && (e = h.x), h.y > c ? c = h.y : h.y < f && (f = h.y), s && (h.z > d ? d = h.z : h.z < g && (g = h.z)), n.add(h);
  a = {
    minX: e,
    minY: f,
    maxX: b,
    maxY: c,
    centroid: n.divideScalar(l)
  };
  s && (a.maxZ = d, a.minZ = g);
  return a;
};
THREE.CurvePath.prototype.createPointsGeometry = function (a) {
  a = this.getPoints(a, !0);
  return this.createGeometry(a);
};
THREE.CurvePath.prototype.createSpacedPointsGeometry = function (a) {
  a = this.getSpacedPoints(a, !0);
  return this.createGeometry(a);
};
THREE.CurvePath.prototype.createGeometry = function (a) {
  for (var b = new THREE.Geometry(), c = 0; c < a.length; c++)
    b.vertices.push(new THREE.Vector3(a[c].x, a[c].y, a[c].z || 0));
  return b;
};
THREE.CurvePath.prototype.addWrapPath = function (a) {
  this.bends.push(a);
};
THREE.CurvePath.prototype.getTransformedPoints = function (a, b) {
  var c = this.getPoints(a), d, e;
  b || (b = this.bends);
  d = 0;
  for (e = b.length; d < e; d++)
    c = this.getWrapPoints(c, b[d]);
  return c;
};
THREE.CurvePath.prototype.getTransformedSpacedPoints = function (a, b) {
  var c = this.getSpacedPoints(a), d, e;
  b || (b = this.bends);
  d = 0;
  for (e = b.length; d < e; d++)
    c = this.getWrapPoints(c, b[d]);
  return c;
};
THREE.CurvePath.prototype.getWrapPoints = function (a, b) {
  var c = this.getBoundingBox(), d, e, f, g, h, k;
  d = 0;
  for (e = a.length; d < e; d++)
    f = a[d], g = f.x, h = f.y, k = g / c.maxX, k = b.getUtoTmapping(k, g), g = b.getPoint(k), k = b.getTangent(k), k.set(-k.y, k.x).multiplyScalar(h), f.x = g.x + k.x, f.y = g.y + k.y;
  return a;
};
THREE.Gyroscope = function () {
  THREE.Object3D.call(this);
};
THREE.Gyroscope.prototype = Object.create(THREE.Object3D.prototype);
THREE.Gyroscope.prototype.updateMatrixWorld = function (a) {
  this.matrixAutoUpdate && this.updateMatrix();
  if (this.matrixWorldNeedsUpdate || a)
    this.parent ? (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorld.decompose(this.translationWorld, this.quaternionWorld, this.scaleWorld), this.matrix.decompose(this.translationObject, this.quaternionObject, this.scaleObject), this.matrixWorld.compose(this.translationWorld, this.quaternionObject, this.scaleWorld)) : this.matrixWorld.copy(this.matrix), this.matrixWorldNeedsUpdate = !1, a = !0;
  for (var b = 0, c = this.children.length; b < c; b++)
    this.children[b].updateMatrixWorld(a);
};
THREE.Gyroscope.prototype.translationWorld = new THREE.Vector3();
THREE.Gyroscope.prototype.translationObject = new THREE.Vector3();
THREE.Gyroscope.prototype.quaternionWorld = new THREE.Quaternion();
THREE.Gyroscope.prototype.quaternionObject = new THREE.Quaternion();
THREE.Gyroscope.prototype.scaleWorld = new THREE.Vector3();
THREE.Gyroscope.prototype.scaleObject = new THREE.Vector3();
THREE.Path = function (a) {
  THREE.CurvePath.call(this);
  this.actions = [];
  a && this.fromPoints(a);
};
THREE.Path.prototype = Object.create(THREE.CurvePath.prototype);
THREE.PathActions = {
  MOVE_TO: 'moveTo',
  LINE_TO: 'lineTo',
  QUADRATIC_CURVE_TO: 'quadraticCurveTo',
  BEZIER_CURVE_TO: 'bezierCurveTo',
  CSPLINE_THRU: 'splineThru',
  ARC: 'arc',
  ELLIPSE: 'ellipse'
};
THREE.Path.prototype.fromPoints = function (a) {
  this.moveTo(a[0].x, a[0].y);
  for (var b = 1, c = a.length; b < c; b++)
    this.lineTo(a[b].x, a[b].y);
};
THREE.Path.prototype.moveTo = function (a, b) {
  var c = Array.prototype.slice.call(arguments);
  this.actions.push({
    action: THREE.PathActions.MOVE_TO,
    args: c
  });
};
THREE.Path.prototype.lineTo = function (a, b) {
  var c = Array.prototype.slice.call(arguments), d = this.actions[this.actions.length - 1].args, d = new THREE.LineCurve(new THREE.Vector2(d[d.length - 2], d[d.length - 1]), new THREE.Vector2(a, b));
  this.curves.push(d);
  this.actions.push({
    action: THREE.PathActions.LINE_TO,
    args: c
  });
};
THREE.Path.prototype.quadraticCurveTo = function (a, b, c, d) {
  var e = Array.prototype.slice.call(arguments), f = this.actions[this.actions.length - 1].args, f = new THREE.QuadraticBezierCurve(new THREE.Vector2(f[f.length - 2], f[f.length - 1]), new THREE.Vector2(a, b), new THREE.Vector2(c, d));
  this.curves.push(f);
  this.actions.push({
    action: THREE.PathActions.QUADRATIC_CURVE_TO,
    args: e
  });
};
THREE.Path.prototype.bezierCurveTo = function (a, b, c, d, e, f) {
  var g = Array.prototype.slice.call(arguments), h = this.actions[this.actions.length - 1].args, h = new THREE.CubicBezierCurve(new THREE.Vector2(h[h.length - 2], h[h.length - 1]), new THREE.Vector2(a, b), new THREE.Vector2(c, d), new THREE.Vector2(e, f));
  this.curves.push(h);
  this.actions.push({
    action: THREE.PathActions.BEZIER_CURVE_TO,
    args: g
  });
};
THREE.Path.prototype.splineThru = function (a) {
  var b = Array.prototype.slice.call(arguments), c = this.actions[this.actions.length - 1].args, c = [new THREE.Vector2(c[c.length - 2], c[c.length - 1])];
  Array.prototype.push.apply(c, a);
  c = new THREE.SplineCurve(c);
  this.curves.push(c);
  this.actions.push({
    action: THREE.PathActions.CSPLINE_THRU,
    args: b
  });
};
THREE.Path.prototype.arc = function (a, b, c, d, e, f) {
  var g = this.actions[this.actions.length - 1].args;
  this.absarc(a + g[g.length - 2], b + g[g.length - 1], c, d, e, f);
};
THREE.Path.prototype.absarc = function (a, b, c, d, e, f) {
  this.absellipse(a, b, c, c, d, e, f);
};
THREE.Path.prototype.ellipse = function (a, b, c, d, e, f, g) {
  var h = this.actions[this.actions.length - 1].args;
  this.absellipse(a + h[h.length - 2], b + h[h.length - 1], c, d, e, f, g);
};
THREE.Path.prototype.absellipse = function (a, b, c, d, e, f, g) {
  var h = Array.prototype.slice.call(arguments), k = new THREE.EllipseCurve(a, b, c, d, e, f, g);
  this.curves.push(k);
  k = k.getPoint(1);
  h.push(k.x);
  h.push(k.y);
  this.actions.push({
    action: THREE.PathActions.ELLIPSE,
    args: h
  });
};
THREE.Path.prototype.getSpacedPoints = function (a, b) {
  a || (a = 40);
  for (var c = [], d = 0; d < a; d++)
    c.push(this.getPoint(d / a));
  return c;
};
THREE.Path.prototype.getPoints = function (a, b) {
  if (this.useSpacedPoints)
    return console.log('tata'), this.getSpacedPoints(a, b);
  a = a || 12;
  var c = [], d, e, f, g, h, k, l, n, s, r, q, u, p;
  d = 0;
  for (e = this.actions.length; d < e; d++)
    switch (f = this.actions[d], g = f.action, f = f.args, g) {
    case THREE.PathActions.MOVE_TO:
      c.push(new THREE.Vector2(f[0], f[1]));
      break;
    case THREE.PathActions.LINE_TO:
      c.push(new THREE.Vector2(f[0], f[1]));
      break;
    case THREE.PathActions.QUADRATIC_CURVE_TO:
      h = f[2];
      k = f[3];
      s = f[0];
      r = f[1];
      0 < c.length ? (g = c[c.length - 1], q = g.x, u = g.y) : (g = this.actions[d - 1].args, q = g[g.length - 2], u = g[g.length - 1]);
      for (f = 1; f <= a; f++)
        p = f / a, g = THREE.Shape.Utils.b2(p, q, s, h), p = THREE.Shape.Utils.b2(p, u, r, k), c.push(new THREE.Vector2(g, p));
      break;
    case THREE.PathActions.BEZIER_CURVE_TO:
      h = f[4];
      k = f[5];
      s = f[0];
      r = f[1];
      l = f[2];
      n = f[3];
      0 < c.length ? (g = c[c.length - 1], q = g.x, u = g.y) : (g = this.actions[d - 1].args, q = g[g.length - 2], u = g[g.length - 1]);
      for (f = 1; f <= a; f++)
        p = f / a, g = THREE.Shape.Utils.b3(p, q, s, l, h), p = THREE.Shape.Utils.b3(p, u, r, n, k), c.push(new THREE.Vector2(g, p));
      break;
    case THREE.PathActions.CSPLINE_THRU:
      g = this.actions[d - 1].args;
      p = [new THREE.Vector2(g[g.length - 2], g[g.length - 1])];
      g = a * f[0].length;
      p = p.concat(f[0]);
      p = new THREE.SplineCurve(p);
      for (f = 1; f <= g; f++)
        c.push(p.getPointAt(f / g));
      break;
    case THREE.PathActions.ARC:
      h = f[0];
      k = f[1];
      r = f[2];
      l = f[3];
      g = f[4];
      s = !!f[5];
      q = g - l;
      u = 2 * a;
      for (f = 1; f <= u; f++)
        p = f / u, s || (p = 1 - p), p = l + p * q, g = h + r * Math.cos(p), p = k + r * Math.sin(p), c.push(new THREE.Vector2(g, p));
      break;
    case THREE.PathActions.ELLIPSE:
      for (h = f[0], k = f[1], r = f[2], n = f[3], l = f[4], g = f[5], s = !!f[6], q = g - l, u = 2 * a, f = 1; f <= u; f++)
        p = f / u, s || (p = 1 - p), p = l + p * q, g = h + r * Math.cos(p), p = k + n * Math.sin(p), c.push(new THREE.Vector2(g, p));
    }
  d = c[c.length - 1];
  1e-10 > Math.abs(d.x - c[0].x) && 1e-10 > Math.abs(d.y - c[0].y) && c.splice(c.length - 1, 1);
  b && c.push(c[0]);
  return c;
};
THREE.Path.prototype.toShapes = function (a) {
  function b(a, b) {
    for (var c = b.length, d = !1, e = c - 1, f = 0; f < c; e = f++) {
      var g = b[e], h = b[f], k = h.x - g.x, l = h.y - g.y;
      if (1e-10 < Math.abs(l)) {
        if (0 > l && (g = b[f], k = -k, h = b[e], l = -l), !(a.y < g.y || a.y > h.y))
          if (a.y == g.y) {
            if (a.x == g.x)
              return !0;
          } else {
            e = l * (a.x - g.x) - k * (a.y - g.y);
            if (0 == e)
              return !0;
            0 > e || (d = !d);
          }
      } else if (a.y == g.y && (h.x <= a.x && a.x <= g.x || g.x <= a.x && a.x <= h.x))
        return !0;
    }
    return d;
  }
  var c, d, e, f, g = [], h = new THREE.Path();
  c = 0;
  for (d = this.actions.length; c < d; c++)
    e = this.actions[c], f = e.args, e = e.action, e == THREE.PathActions.MOVE_TO && 0 != h.actions.length && (g.push(h), h = new THREE.Path()), h[e].apply(h, f);
  0 != h.actions.length && g.push(h);
  if (0 == g.length)
    return [];
  var k, l, n;
  f = [];
  if (1 == g.length)
    return l = g[0], n = new THREE.Shape(), n.actions = l.actions, n.curves = l.curves, f.push(n), f;
  var s = !THREE.Shape.Utils.isClockWise(g[0].getPoints()), s = a ? !s : s;
  n = [];
  h = [];
  e = [];
  var r = 0, q;
  h[r] = void 0;
  e[r] = [];
  c = 0;
  for (d = g.length; c < d; c++)
    l = g[c], q = l.getPoints(), k = THREE.Shape.Utils.isClockWise(q), (k = a ? !k : k) ? (!s && h[r] && r++, h[r] = {
      s: new THREE.Shape(),
      p: q
    }, h[r].s.actions = l.actions, h[r].s.curves = l.curves, s && r++, e[r] = []) : e[r].push({
      h: l,
      p: q[0]
    });
  if (1 < h.length) {
    c = !1;
    d = [];
    a = 0;
    for (g = h.length; a < g; a++)
      n[a] = [];
    a = 0;
    for (g = h.length; a < g; a++)
      for (l = e[a], k = 0; k < l.length; k++) {
        s = l[k];
        r = !0;
        for (q = 0; q < h.length; q++)
          b(s.p, h[q].p) && (a != q && d.push({
            froms: a,
            tos: q,
            hole: k
          }), r ? (r = !1, n[q].push(s)) : c = !0);
        r && n[a].push(s);
      }
    0 < d.length && (c || (e = n));
  }
  c = 0;
  for (d = h.length; c < d; c++)
    for (n = h[c].s, f.push(n), a = e[c], g = 0, l = a.length; g < l; g++)
      n.holes.push(a[g].h);
  return f;
};
THREE.Shape = function () {
  THREE.Path.apply(this, arguments);
  this.holes = [];
};
THREE.Shape.prototype = Object.create(THREE.Path.prototype);
THREE.Shape.prototype.extrude = function (a) {
  return new THREE.ExtrudeGeometry(this, a);
};
THREE.Shape.prototype.makeGeometry = function (a) {
  return new THREE.ShapeGeometry(this, a);
};
THREE.Shape.prototype.getPointsHoles = function (a) {
  var b, c = this.holes.length, d = [];
  for (b = 0; b < c; b++)
    d[b] = this.holes[b].getTransformedPoints(a, this.bends);
  return d;
};
THREE.Shape.prototype.getSpacedPointsHoles = function (a) {
  var b, c = this.holes.length, d = [];
  for (b = 0; b < c; b++)
    d[b] = this.holes[b].getTransformedSpacedPoints(a, this.bends);
  return d;
};
THREE.Shape.prototype.extractAllPoints = function (a) {
  return {
    shape: this.getTransformedPoints(a),
    holes: this.getPointsHoles(a)
  };
};
THREE.Shape.prototype.extractPoints = function (a) {
  return this.useSpacedPoints ? this.extractAllSpacedPoints(a) : this.extractAllPoints(a);
};
THREE.Shape.prototype.extractAllSpacedPoints = function (a) {
  return {
    shape: this.getTransformedSpacedPoints(a),
    holes: this.getSpacedPointsHoles(a)
  };
};
THREE.Shape.Utils = {
  triangulateShape: function (a, b) {
    function c(a, b, c) {
      return a.x != b.x ? a.x < b.x ? a.x <= c.x && c.x <= b.x : b.x <= c.x && c.x <= a.x : a.y < b.y ? a.y <= c.y && c.y <= b.y : b.y <= c.y && c.y <= a.y;
    }
    function d(a, b, d, e, f) {
      var g = b.x - a.x, h = b.y - a.y, k = e.x - d.x, l = e.y - d.y, n = a.x - d.x, s = a.y - d.y, H = h * k - g * l, D = h * n - g * s;
      if (1e-10 < Math.abs(H)) {
        if (0 < H) {
          if (0 > D || D > H)
            return [];
          k = l * n - k * s;
          if (0 > k || k > H)
            return [];
        } else {
          if (0 < D || D < H)
            return [];
          k = l * n - k * s;
          if (0 < k || k < H)
            return [];
        }
        if (0 == k)
          return !f || 0 != D && D != H ? [a] : [];
        if (k == H)
          return !f || 0 != D && D != H ? [b] : [];
        if (0 == D)
          return [d];
        if (D == H)
          return [e];
        f = k / H;
        return [{
            x: a.x + f * g,
            y: a.y + f * h
          }];
      }
      if (0 != D || l * n != k * s)
        return [];
      h = 0 == g && 0 == h;
      k = 0 == k && 0 == l;
      if (h && k)
        return a.x != d.x || a.y != d.y ? [] : [a];
      if (h)
        return c(d, e, a) ? [a] : [];
      if (k)
        return c(a, b, d) ? [d] : [];
      0 != g ? (a.x < b.x ? (g = a, k = a.x, h = b, a = b.x) : (g = b, k = b.x, h = a, a = a.x), d.x < e.x ? (b = d, H = d.x, l = e, d = e.x) : (b = e, H = e.x, l = d, d = d.x)) : (a.y < b.y ? (g = a, k = a.y, h = b, a = b.y) : (g = b, k = b.y, h = a, a = a.y), d.y < e.y ? (b = d, H = d.y, l = e, d = e.y) : (b = e, H = e.y, l = d, d = d.y));
      return k <= H ? a < H ? [] : a == H ? f ? [] : [b] : a <= d ? [
        b,
        h
      ] : [
        b,
        l
      ] : k > d ? [] : k == d ? f ? [] : [g] : a <= d ? [
        g,
        h
      ] : [
        g,
        l
      ];
    }
    function e(a, b, c, d) {
      var e = b.x - a.x, f = b.y - a.y;
      b = c.x - a.x;
      c = c.y - a.y;
      var g = d.x - a.x;
      d = d.y - a.y;
      a = e * c - f * b;
      e = e * d - f * g;
      return 1e-10 < Math.abs(a) ? (b = g * c - d * b, 0 < a ? 0 <= e && 0 <= b : 0 <= e || 0 <= b) : 0 < e;
    }
    var f, g, h, k, l, n = {};
    h = a.concat();
    f = 0;
    for (g = b.length; f < g; f++)
      Array.prototype.push.apply(h, b[f]);
    f = 0;
    for (g = h.length; f < g; f++)
      l = h[f].x + ':' + h[f].y, void 0 !== n[l] && console.log('Duplicate point', l), n[l] = f;
    f = function (a, b) {
      function c(a, b) {
        var d = h.length - 1, f = a - 1;
        0 > f && (f = d);
        var g = a + 1;
        g > d && (g = 0);
        d = e(h[a], h[f], h[g], k[b]);
        if (!d)
          return !1;
        d = k.length - 1;
        f = b - 1;
        0 > f && (f = d);
        g = b + 1;
        g > d && (g = 0);
        return (d = e(k[b], k[f], k[g], h[a])) ? !0 : !1;
      }
      function f(a, b) {
        var c, e;
        for (c = 0; c < h.length; c++)
          if (e = c + 1, e %= h.length, e = d(a, b, h[c], h[e], !0), 0 < e.length)
            return !0;
        return !1;
      }
      function g(a, c) {
        var e, f, h, k;
        for (e = 0; e < l.length; e++)
          for (f = b[l[e]], h = 0; h < f.length; h++)
            if (k = h + 1, k %= f.length, k = d(a, c, f[h], f[k], !0), 0 < k.length)
              return !0;
        return !1;
      }
      var h = a.concat(), k, l = [], n, s, E, H, D, G = [], I, O, K, y = 0;
      for (n = b.length; y < n; y++)
        l.push(y);
      for (var F = 2 * l.length; 0 < l.length;) {
        F--;
        if (0 > F) {
          console.log('Infinite Loop! Holes left:' + l.length + ', Probably Hole outside Shape!');
          break;
        }
        for (s = 0; s < h.length; s++) {
          E = h[s];
          n = -1;
          for (y = 0; y < l.length; y++)
            if (H = l[y], D = E.x + ':' + E.y + ':' + H, void 0 === G[D]) {
              k = b[H];
              for (I = 0; I < k.length; I++)
                if (H = k[I], c(s, I) && !f(E, H) && !g(E, H)) {
                  n = I;
                  l.splice(y, 1);
                  H = h.slice(0, s + 1);
                  I = h.slice(s);
                  O = k.slice(n);
                  K = k.slice(0, n + 1);
                  h = H.concat(O).concat(K).concat(I);
                  break;
                }
              if (0 <= n)
                break;
              G[D] = !0;
            }
          if (0 <= n)
            break;
        }
      }
      return h;
    }(a, b);
    var s = THREE.FontUtils.Triangulate(f, !1);
    f = 0;
    for (g = s.length; f < g; f++)
      for (k = s[f], h = 0; 3 > h; h++)
        l = k[h].x + ':' + k[h].y, l = n[l], void 0 !== l && (k[h] = l);
    return s.concat();
  },
  isClockWise: function (a) {
    return 0 > THREE.FontUtils.Triangulate.area(a);
  },
  b2p0: function (a, b) {
    var c = 1 - a;
    return c * c * b;
  },
  b2p1: function (a, b) {
    return 2 * (1 - a) * a * b;
  },
  b2p2: function (a, b) {
    return a * a * b;
  },
  b2: function (a, b, c, d) {
    return this.b2p0(a, b) + this.b2p1(a, c) + this.b2p2(a, d);
  },
  b3p0: function (a, b) {
    var c = 1 - a;
    return c * c * c * b;
  },
  b3p1: function (a, b) {
    var c = 1 - a;
    return 3 * c * c * a * b;
  },
  b3p2: function (a, b) {
    return 3 * (1 - a) * a * a * b;
  },
  b3p3: function (a, b) {
    return a * a * a * b;
  },
  b3: function (a, b, c, d, e) {
    return this.b3p0(a, b) + this.b3p1(a, c) + this.b3p2(a, d) + this.b3p3(a, e);
  }
};
THREE.LineCurve = function (a, b) {
  this.v1 = a;
  this.v2 = b;
};
THREE.LineCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.LineCurve.prototype.getPoint = function (a) {
  var b = this.v2.clone().sub(this.v1);
  b.multiplyScalar(a).add(this.v1);
  return b;
};
THREE.LineCurve.prototype.getPointAt = function (a) {
  return this.getPoint(a);
};
THREE.LineCurve.prototype.getTangent = function (a) {
  return this.v2.clone().sub(this.v1).normalize();
};
THREE.QuadraticBezierCurve = function (a, b, c) {
  this.v0 = a;
  this.v1 = b;
  this.v2 = c;
};
THREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.QuadraticBezierCurve.prototype.getPoint = function (a) {
  var b;
  b = THREE.Shape.Utils.b2(a, this.v0.x, this.v1.x, this.v2.x);
  a = THREE.Shape.Utils.b2(a, this.v0.y, this.v1.y, this.v2.y);
  return new THREE.Vector2(b, a);
};
THREE.QuadraticBezierCurve.prototype.getTangent = function (a) {
  var b;
  b = THREE.Curve.Utils.tangentQuadraticBezier(a, this.v0.x, this.v1.x, this.v2.x);
  a = THREE.Curve.Utils.tangentQuadraticBezier(a, this.v0.y, this.v1.y, this.v2.y);
  b = new THREE.Vector2(b, a);
  b.normalize();
  return b;
};
THREE.CubicBezierCurve = function (a, b, c, d) {
  this.v0 = a;
  this.v1 = b;
  this.v2 = c;
  this.v3 = d;
};
THREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.CubicBezierCurve.prototype.getPoint = function (a) {
  var b;
  b = THREE.Shape.Utils.b3(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x);
  a = THREE.Shape.Utils.b3(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
  return new THREE.Vector2(b, a);
};
THREE.CubicBezierCurve.prototype.getTangent = function (a) {
  var b;
  b = THREE.Curve.Utils.tangentCubicBezier(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x);
  a = THREE.Curve.Utils.tangentCubicBezier(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
  b = new THREE.Vector2(b, a);
  b.normalize();
  return b;
};
THREE.SplineCurve = function (a) {
  this.points = void 0 == a ? [] : a;
};
THREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.SplineCurve.prototype.getPoint = function (a) {
  var b = new THREE.Vector2(), c = [], d = this.points, e;
  e = (d.length - 1) * a;
  a = Math.floor(e);
  e -= a;
  c[0] = 0 == a ? a : a - 1;
  c[1] = a;
  c[2] = a > d.length - 2 ? d.length - 1 : a + 1;
  c[3] = a > d.length - 3 ? d.length - 1 : a + 2;
  b.x = THREE.Curve.Utils.interpolate(d[c[0]].x, d[c[1]].x, d[c[2]].x, d[c[3]].x, e);
  b.y = THREE.Curve.Utils.interpolate(d[c[0]].y, d[c[1]].y, d[c[2]].y, d[c[3]].y, e);
  return b;
};
THREE.EllipseCurve = function (a, b, c, d, e, f, g) {
  this.aX = a;
  this.aY = b;
  this.xRadius = c;
  this.yRadius = d;
  this.aStartAngle = e;
  this.aEndAngle = f;
  this.aClockwise = g;
};
THREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.EllipseCurve.prototype.getPoint = function (a) {
  var b;
  b = this.aEndAngle - this.aStartAngle;
  0 > b && (b += 2 * Math.PI);
  b > 2 * Math.PI && (b -= 2 * Math.PI);
  b = !0 === this.aClockwise ? this.aEndAngle + (1 - a) * (2 * Math.PI - b) : this.aStartAngle + a * b;
  a = this.aX + this.xRadius * Math.cos(b);
  b = this.aY + this.yRadius * Math.sin(b);
  return new THREE.Vector2(a, b);
};
THREE.ArcCurve = function (a, b, c, d, e, f) {
  THREE.EllipseCurve.call(this, a, b, c, c, d, e, f);
};
THREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype);
THREE.LineCurve3 = THREE.Curve.create(function (a, b) {
  this.v1 = a;
  this.v2 = b;
}, function (a) {
  var b = new THREE.Vector3();
  b.subVectors(this.v2, this.v1);
  b.multiplyScalar(a);
  b.add(this.v1);
  return b;
});
THREE.QuadraticBezierCurve3 = THREE.Curve.create(function (a, b, c) {
  this.v0 = a;
  this.v1 = b;
  this.v2 = c;
}, function (a) {
  var b, c;
  b = THREE.Shape.Utils.b2(a, this.v0.x, this.v1.x, this.v2.x);
  c = THREE.Shape.Utils.b2(a, this.v0.y, this.v1.y, this.v2.y);
  a = THREE.Shape.Utils.b2(a, this.v0.z, this.v1.z, this.v2.z);
  return new THREE.Vector3(b, c, a);
});
THREE.CubicBezierCurve3 = THREE.Curve.create(function (a, b, c, d) {
  this.v0 = a;
  this.v1 = b;
  this.v2 = c;
  this.v3 = d;
}, function (a) {
  var b, c;
  b = THREE.Shape.Utils.b3(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x);
  c = THREE.Shape.Utils.b3(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
  a = THREE.Shape.Utils.b3(a, this.v0.z, this.v1.z, this.v2.z, this.v3.z);
  return new THREE.Vector3(b, c, a);
});
THREE.SplineCurve3 = THREE.Curve.create(function (a) {
  this.points = void 0 == a ? [] : a;
}, function (a) {
  var b = new THREE.Vector3(), c = [], d = this.points, e;
  a *= d.length - 1;
  e = Math.floor(a);
  a -= e;
  c[0] = 0 == e ? e : e - 1;
  c[1] = e;
  c[2] = e > d.length - 2 ? d.length - 1 : e + 1;
  c[3] = e > d.length - 3 ? d.length - 1 : e + 2;
  e = d[c[0]];
  var f = d[c[1]], g = d[c[2]], c = d[c[3]];
  b.x = THREE.Curve.Utils.interpolate(e.x, f.x, g.x, c.x, a);
  b.y = THREE.Curve.Utils.interpolate(e.y, f.y, g.y, c.y, a);
  b.z = THREE.Curve.Utils.interpolate(e.z, f.z, g.z, c.z, a);
  return b;
});
THREE.ClosedSplineCurve3 = THREE.Curve.create(function (a) {
  this.points = void 0 == a ? [] : a;
}, function (a) {
  var b = new THREE.Vector3(), c = [], d = this.points, e;
  e = (d.length - 0) * a;
  a = Math.floor(e);
  e -= a;
  a += 0 < a ? 0 : (Math.floor(Math.abs(a) / d.length) + 1) * d.length;
  c[0] = (a - 1) % d.length;
  c[1] = a % d.length;
  c[2] = (a + 1) % d.length;
  c[3] = (a + 2) % d.length;
  b.x = THREE.Curve.Utils.interpolate(d[c[0]].x, d[c[1]].x, d[c[2]].x, d[c[3]].x, e);
  b.y = THREE.Curve.Utils.interpolate(d[c[0]].y, d[c[1]].y, d[c[2]].y, d[c[3]].y, e);
  b.z = THREE.Curve.Utils.interpolate(d[c[0]].z, d[c[1]].z, d[c[2]].z, d[c[3]].z, e);
  return b;
});
THREE.AnimationHandler = function () {
  var a = [], b = {}, c = {
      update: function (b) {
        for (var c = 0; c < a.length; c++)
          a[c].update(b);
      },
      addToUpdate: function (b) {
        -1 === a.indexOf(b) && a.push(b);
      },
      removeFromUpdate: function (b) {
        b = a.indexOf(b);
        -1 !== b && a.splice(b, 1);
      },
      add: function (a) {
        void 0 !== b[a.name] && console.log('THREE.AnimationHandler.add: Warning! ' + a.name + ' already exists in library. Overwriting.');
        b[a.name] = a;
        if (!0 !== a.initialized) {
          for (var c = 0; c < a.hierarchy.length; c++) {
            for (var d = 0; d < a.hierarchy[c].keys.length; d++)
              if (0 > a.hierarchy[c].keys[d].time && (a.hierarchy[c].keys[d].time = 0), void 0 !== a.hierarchy[c].keys[d].rot && !(a.hierarchy[c].keys[d].rot instanceof THREE.Quaternion)) {
                var h = a.hierarchy[c].keys[d].rot;
                a.hierarchy[c].keys[d].rot = new THREE.Quaternion(h[0], h[1], h[2], h[3]);
              }
            if (a.hierarchy[c].keys.length && void 0 !== a.hierarchy[c].keys[0].morphTargets) {
              h = {};
              for (d = 0; d < a.hierarchy[c].keys.length; d++)
                for (var k = 0; k < a.hierarchy[c].keys[d].morphTargets.length; k++) {
                  var l = a.hierarchy[c].keys[d].morphTargets[k];
                  h[l] = -1;
                }
              a.hierarchy[c].usedMorphTargets = h;
              for (d = 0; d < a.hierarchy[c].keys.length; d++) {
                var n = {};
                for (l in h) {
                  for (k = 0; k < a.hierarchy[c].keys[d].morphTargets.length; k++)
                    if (a.hierarchy[c].keys[d].morphTargets[k] === l) {
                      n[l] = a.hierarchy[c].keys[d].morphTargetsInfluences[k];
                      break;
                    }
                  k === a.hierarchy[c].keys[d].morphTargets.length && (n[l] = 0);
                }
                a.hierarchy[c].keys[d].morphTargetsInfluences = n;
              }
            }
            for (d = 1; d < a.hierarchy[c].keys.length; d++)
              a.hierarchy[c].keys[d].time === a.hierarchy[c].keys[d - 1].time && (a.hierarchy[c].keys.splice(d, 1), d--);
            for (d = 0; d < a.hierarchy[c].keys.length; d++)
              a.hierarchy[c].keys[d].index = d;
          }
          a.initialized = !0;
        }
      },
      get: function (a) {
        if ('string' === typeof a) {
          if (b[a])
            return b[a];
          console.log('THREE.AnimationHandler.get: Couldn\'t find animation ' + a);
          return null;
        }
      },
      parse: function (a) {
        var b = [];
        if (a instanceof THREE.SkinnedMesh)
          for (var c = 0; c < a.bones.length; c++)
            b.push(a.bones[c]);
        else
          d(a, b);
        return b;
      }
    }, d = function (a, b) {
      b.push(a);
      for (var c = 0; c < a.children.length; c++)
        d(a.children[c], b);
    };
  c.LINEAR = 0;
  c.CATMULLROM = 1;
  c.CATMULLROM_FORWARD = 2;
  return c;
}();
THREE.Animation = function (a, b) {
  this.root = a;
  this.data = THREE.AnimationHandler.get(b);
  this.hierarchy = THREE.AnimationHandler.parse(a);
  this.currentTime = 0;
  this.timeScale = 1;
  this.isPlaying = !1;
  this.loop = this.isPaused = !0;
  this.interpolationType = THREE.AnimationHandler.LINEAR;
};
THREE.Animation.prototype.play = function (a) {
  this.currentTime = void 0 !== a ? a : 0;
  !1 === this.isPlaying && (this.isPlaying = !0, this.reset(), this.update(0));
  this.isPaused = !1;
  THREE.AnimationHandler.addToUpdate(this);
};
THREE.Animation.prototype.pause = function () {
  !0 === this.isPaused ? THREE.AnimationHandler.addToUpdate(this) : THREE.AnimationHandler.removeFromUpdate(this);
  this.isPaused = !this.isPaused;
};
THREE.Animation.prototype.stop = function () {
  this.isPaused = this.isPlaying = !1;
  THREE.AnimationHandler.removeFromUpdate(this);
};
THREE.Animation.prototype.reset = function () {
  for (var a = 0, b = this.hierarchy.length; a < b; a++) {
    var c = this.hierarchy[a];
    c.matrixAutoUpdate = !0;
    void 0 === c.animationCache && (c.animationCache = {}, c.animationCache.prevKey = {
      pos: 0,
      rot: 0,
      scl: 0
    }, c.animationCache.nextKey = {
      pos: 0,
      rot: 0,
      scl: 0
    }, c.animationCache.originalMatrix = c instanceof THREE.Bone ? c.skinMatrix : c.matrix);
    var d = c.animationCache.prevKey, c = c.animationCache.nextKey;
    d.pos = this.data.hierarchy[a].keys[0];
    d.rot = this.data.hierarchy[a].keys[0];
    d.scl = this.data.hierarchy[a].keys[0];
    c.pos = this.getNextKeyWith('pos', a, 1);
    c.rot = this.getNextKeyWith('rot', a, 1);
    c.scl = this.getNextKeyWith('scl', a, 1);
  }
};
THREE.Animation.prototype.update = function () {
  var a = [], b = new THREE.Vector3(), c = function (a, b) {
      var c = [], h = [], k, l, n, s, r, q;
      k = (a.length - 1) * b;
      l = Math.floor(k);
      k -= l;
      c[0] = 0 === l ? l : l - 1;
      c[1] = l;
      c[2] = l > a.length - 2 ? l : l + 1;
      c[3] = l > a.length - 3 ? l : l + 2;
      l = a[c[0]];
      s = a[c[1]];
      r = a[c[2]];
      q = a[c[3]];
      c = k * k;
      n = k * c;
      h[0] = d(l[0], s[0], r[0], q[0], k, c, n);
      h[1] = d(l[1], s[1], r[1], q[1], k, c, n);
      h[2] = d(l[2], s[2], r[2], q[2], k, c, n);
      return h;
    }, d = function (a, b, c, d, k, l, n) {
      a = 0.5 * (c - a);
      d = 0.5 * (d - b);
      return (2 * (b - c) + a + d) * n + (-3 * (b - c) - 2 * a - d) * l + a * k + b;
    };
  return function (d) {
    if (!1 !== this.isPlaying) {
      this.currentTime += d * this.timeScale;
      var f;
      d = [
        'pos',
        'rot',
        'scl'
      ];
      var g = this.data.length;
      if (!0 === this.loop && this.currentTime > g)
        this.currentTime %= g, this.reset();
      else if (!1 === this.loop && this.currentTime > g) {
        this.stop();
        return;
      }
      this.currentTime = Math.min(this.currentTime, g);
      for (var g = 0, h = this.hierarchy.length; g < h; g++)
        for (var k = this.hierarchy[g], l = k.animationCache, n = 0; 3 > n; n++) {
          f = d[n];
          var s = l.prevKey[f], r = l.nextKey[f];
          if (r.time <= this.currentTime) {
            s = this.data.hierarchy[g].keys[0];
            for (r = this.getNextKeyWith(f, g, 1); r.time < this.currentTime && r.index > s.index;)
              s = r, r = this.getNextKeyWith(f, g, r.index + 1);
            l.prevKey[f] = s;
            l.nextKey[f] = r;
          }
          k.matrixAutoUpdate = !0;
          k.matrixWorldNeedsUpdate = !0;
          var q = (this.currentTime - s.time) / (r.time - s.time), u = s[f], p = r[f];
          0 > q && (q = 0);
          1 < q && (q = 1);
          if ('pos' === f)
            if (f = k.position, this.interpolationType === THREE.AnimationHandler.LINEAR)
              f.x = u[0] + (p[0] - u[0]) * q, f.y = u[1] + (p[1] - u[1]) * q, f.z = u[2] + (p[2] - u[2]) * q;
            else {
              if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD)
                a[0] = this.getPrevKeyWith('pos', g, s.index - 1).pos, a[1] = u, a[2] = p, a[3] = this.getNextKeyWith('pos', g, r.index + 1).pos, q = 0.33 * q + 0.33, s = c(a, q), f.x = s[0], f.y = s[1], f.z = s[2], this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD && (q = c(a, 1.01 * q), b.set(q[0], q[1], q[2]), b.sub(f), b.y = 0, b.normalize(), f = Math.atan2(b.x, b.z), k.rotation.set(0, f, 0));
            }
          else
            'rot' === f ? THREE.Quaternion.slerp(u, p, k.quaternion, q) : 'scl' === f && (f = k.scale, f.x = u[0] + (p[0] - u[0]) * q, f.y = u[1] + (p[1] - u[1]) * q, f.z = u[2] + (p[2] - u[2]) * q);
        }
    }
  };
}();
THREE.Animation.prototype.getNextKeyWith = function (a, b, c) {
  var d = this.data.hierarchy[b].keys;
  for (c = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? c < d.length - 1 ? c : d.length - 1 : c % d.length; c < d.length; c++)
    if (void 0 !== d[c][a])
      return d[c];
  return this.data.hierarchy[b].keys[0];
};
THREE.Animation.prototype.getPrevKeyWith = function (a, b, c) {
  var d = this.data.hierarchy[b].keys;
  for (c = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? 0 < c ? c : 0 : 0 <= c ? c : c + d.length; 0 <= c; c--)
    if (void 0 !== d[c][a])
      return d[c];
  return this.data.hierarchy[b].keys[d.length - 1];
};
THREE.KeyFrameAnimation = function (a, b) {
  this.root = a;
  this.data = THREE.AnimationHandler.get(b);
  this.hierarchy = THREE.AnimationHandler.parse(a);
  this.currentTime = 0;
  this.timeScale = 0.001;
  this.isPlaying = !1;
  this.loop = this.isPaused = !0;
  for (var c = 0, d = this.hierarchy.length; c < d; c++) {
    var e = this.data.hierarchy[c].sids, f = this.hierarchy[c];
    if (this.data.hierarchy[c].keys.length && e) {
      for (var g = 0; g < e.length; g++) {
        var h = e[g], k = this.getNextKeyWith(h, c, 0);
        k && k.apply(h);
      }
      f.matrixAutoUpdate = !1;
      this.data.hierarchy[c].node.updateMatrix();
      f.matrixWorldNeedsUpdate = !0;
    }
  }
};
THREE.KeyFrameAnimation.prototype.play = function (a) {
  this.currentTime = void 0 !== a ? a : 0;
  if (!1 === this.isPlaying) {
    this.isPlaying = !0;
    var b = this.hierarchy.length, c, d;
    for (a = 0; a < b; a++)
      c = this.hierarchy[a], d = this.data.hierarchy[a], void 0 === d.animationCache && (d.animationCache = {}, d.animationCache.prevKey = null, d.animationCache.nextKey = null, d.animationCache.originalMatrix = c instanceof THREE.Bone ? c.skinMatrix : c.matrix), c = this.data.hierarchy[a].keys, c.length && (d.animationCache.prevKey = c[0], d.animationCache.nextKey = c[1], this.startTime = Math.min(c[0].time, this.startTime), this.endTime = Math.max(c[c.length - 1].time, this.endTime));
    this.update(0);
  }
  this.isPaused = !1;
  THREE.AnimationHandler.addToUpdate(this);
};
THREE.KeyFrameAnimation.prototype.pause = function () {
  this.isPaused ? THREE.AnimationHandler.addToUpdate(this) : THREE.AnimationHandler.removeFromUpdate(this);
  this.isPaused = !this.isPaused;
};
THREE.KeyFrameAnimation.prototype.stop = function () {
  this.isPaused = this.isPlaying = !1;
  THREE.AnimationHandler.removeFromUpdate(this);
  for (var a = 0; a < this.data.hierarchy.length; a++) {
    var b = this.hierarchy[a], c = this.data.hierarchy[a];
    if (void 0 !== c.animationCache) {
      var d = c.animationCache.originalMatrix;
      b instanceof THREE.Bone ? (d.copy(b.skinMatrix), b.skinMatrix = d) : (d.copy(b.matrix), b.matrix = d);
      delete c.animationCache;
    }
  }
};
THREE.KeyFrameAnimation.prototype.update = function (a) {
  if (!1 !== this.isPlaying) {
    this.currentTime += a * this.timeScale;
    a = this.data.length;
    !0 === this.loop && this.currentTime > a && (this.currentTime %= a);
    this.currentTime = Math.min(this.currentTime, a);
    a = 0;
    for (var b = this.hierarchy.length; a < b; a++) {
      var c = this.hierarchy[a], d = this.data.hierarchy[a], e = d.keys, d = d.animationCache;
      if (e.length) {
        var f = d.prevKey, g = d.nextKey;
        if (g.time <= this.currentTime) {
          for (; g.time < this.currentTime && g.index > f.index;)
            f = g, g = e[f.index + 1];
          d.prevKey = f;
          d.nextKey = g;
        }
        g.time >= this.currentTime ? f.interpolate(g, this.currentTime) : f.interpolate(g, g.time);
        this.data.hierarchy[a].node.updateMatrix();
        c.matrixWorldNeedsUpdate = !0;
      }
    }
  }
};
THREE.KeyFrameAnimation.prototype.getNextKeyWith = function (a, b, c) {
  b = this.data.hierarchy[b].keys;
  for (c %= b.length; c < b.length; c++)
    if (b[c].hasTarget(a))
      return b[c];
  return b[0];
};
THREE.KeyFrameAnimation.prototype.getPrevKeyWith = function (a, b, c) {
  b = this.data.hierarchy[b].keys;
  for (c = 0 <= c ? c : c + b.length; 0 <= c; c--)
    if (b[c].hasTarget(a))
      return b[c];
  return b[b.length - 1];
};
THREE.MorphAnimation = function (a) {
  this.mesh = a;
  this.frames = a.morphTargetInfluences.length;
  this.currentTime = 0;
  this.duration = 1000;
  this.loop = !0;
  this.isPlaying = !1;
};
THREE.MorphAnimation.prototype = {
  play: function () {
    this.isPlaying = !0;
  },
  pause: function () {
    this.isPlaying = !1;
  },
  update: function () {
    var a = 0, b = 0;
    return function (c) {
      if (!1 !== this.isPlaying) {
        this.currentTime += c;
        !0 === this.loop && this.currentTime > this.duration && (this.currentTime %= this.duration);
        this.currentTime = Math.min(this.currentTime, this.duration);
        c = this.duration / this.frames;
        var d = Math.floor(this.currentTime / c);
        d != b && (this.mesh.morphTargetInfluences[a] = 0, this.mesh.morphTargetInfluences[b] = 1, this.mesh.morphTargetInfluences[d] = 0, a = b, b = d);
        this.mesh.morphTargetInfluences[d] = this.currentTime % c / c;
        this.mesh.morphTargetInfluences[a] = 1 - this.mesh.morphTargetInfluences[d];
      }
    };
  }()
};
THREE.CubeCamera = function (a, b, c) {
  THREE.Object3D.call(this);
  var d = new THREE.PerspectiveCamera(90, 1, a, b);
  d.up.set(0, -1, 0);
  d.lookAt(new THREE.Vector3(1, 0, 0));
  this.add(d);
  var e = new THREE.PerspectiveCamera(90, 1, a, b);
  e.up.set(0, -1, 0);
  e.lookAt(new THREE.Vector3(-1, 0, 0));
  this.add(e);
  var f = new THREE.PerspectiveCamera(90, 1, a, b);
  f.up.set(0, 0, 1);
  f.lookAt(new THREE.Vector3(0, 1, 0));
  this.add(f);
  var g = new THREE.PerspectiveCamera(90, 1, a, b);
  g.up.set(0, 0, -1);
  g.lookAt(new THREE.Vector3(0, -1, 0));
  this.add(g);
  var h = new THREE.PerspectiveCamera(90, 1, a, b);
  h.up.set(0, -1, 0);
  h.lookAt(new THREE.Vector3(0, 0, 1));
  this.add(h);
  var k = new THREE.PerspectiveCamera(90, 1, a, b);
  k.up.set(0, -1, 0);
  k.lookAt(new THREE.Vector3(0, 0, -1));
  this.add(k);
  this.renderTarget = new THREE.WebGLRenderTargetCube(c, c, {
    format: THREE.RGBFormat,
    magFilter: THREE.LinearFilter,
    minFilter: THREE.LinearFilter
  });
  this.updateCubeMap = function (a, b) {
    var c = this.renderTarget, r = c.generateMipmaps;
    c.generateMipmaps = !1;
    c.activeCubeFace = 0;
    a.render(b, d, c);
    c.activeCubeFace = 1;
    a.render(b, e, c);
    c.activeCubeFace = 2;
    a.render(b, f, c);
    c.activeCubeFace = 3;
    a.render(b, g, c);
    c.activeCubeFace = 4;
    a.render(b, h, c);
    c.generateMipmaps = r;
    c.activeCubeFace = 5;
    a.render(b, k, c);
  };
};
THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype);
THREE.CombinedCamera = function (a, b, c, d, e, f, g) {
  THREE.Camera.call(this);
  this.fov = c;
  this.left = -a / 2;
  this.right = a / 2;
  this.top = b / 2;
  this.bottom = -b / 2;
  this.cameraO = new THREE.OrthographicCamera(a / -2, a / 2, b / 2, b / -2, f, g);
  this.cameraP = new THREE.PerspectiveCamera(c, a / b, d, e);
  this.zoom = 1;
  this.toPerspective();
};
THREE.CombinedCamera.prototype = Object.create(THREE.Camera.prototype);
THREE.CombinedCamera.prototype.toPerspective = function () {
  this.near = this.cameraP.near;
  this.far = this.cameraP.far;
  this.cameraP.fov = this.fov / this.zoom;
  this.cameraP.updateProjectionMatrix();
  this.projectionMatrix = this.cameraP.projectionMatrix;
  this.inPerspectiveMode = !0;
  this.inOrthographicMode = !1;
};
THREE.CombinedCamera.prototype.toOrthographic = function () {
  var a = this.cameraP.aspect, b = (this.cameraP.near + this.cameraP.far) / 2, b = Math.tan(this.fov / 2) * b, a = 2 * b * a / 2, b = b / this.zoom, a = a / this.zoom;
  this.cameraO.left = -a;
  this.cameraO.right = a;
  this.cameraO.top = b;
  this.cameraO.bottom = -b;
  this.cameraO.updateProjectionMatrix();
  this.near = this.cameraO.near;
  this.far = this.cameraO.far;
  this.projectionMatrix = this.cameraO.projectionMatrix;
  this.inPerspectiveMode = !1;
  this.inOrthographicMode = !0;
};
THREE.CombinedCamera.prototype.setSize = function (a, b) {
  this.cameraP.aspect = a / b;
  this.left = -a / 2;
  this.right = a / 2;
  this.top = b / 2;
  this.bottom = -b / 2;
};
THREE.CombinedCamera.prototype.setFov = function (a) {
  this.fov = a;
  this.inPerspectiveMode ? this.toPerspective() : this.toOrthographic();
};
THREE.CombinedCamera.prototype.updateProjectionMatrix = function () {
  this.inPerspectiveMode ? this.toPerspective() : (this.toPerspective(), this.toOrthographic());
};
THREE.CombinedCamera.prototype.setLens = function (a, b) {
  void 0 === b && (b = 24);
  var c = 2 * THREE.Math.radToDeg(Math.atan(b / (2 * a)));
  this.setFov(c);
  return c;
};
THREE.CombinedCamera.prototype.setZoom = function (a) {
  this.zoom = a;
  this.inPerspectiveMode ? this.toPerspective() : this.toOrthographic();
};
THREE.CombinedCamera.prototype.toFrontView = function () {
  this.rotation.x = 0;
  this.rotation.y = 0;
  this.rotation.z = 0;
  this.rotationAutoUpdate = !1;
};
THREE.CombinedCamera.prototype.toBackView = function () {
  this.rotation.x = 0;
  this.rotation.y = Math.PI;
  this.rotation.z = 0;
  this.rotationAutoUpdate = !1;
};
THREE.CombinedCamera.prototype.toLeftView = function () {
  this.rotation.x = 0;
  this.rotation.y = -Math.PI / 2;
  this.rotation.z = 0;
  this.rotationAutoUpdate = !1;
};
THREE.CombinedCamera.prototype.toRightView = function () {
  this.rotation.x = 0;
  this.rotation.y = Math.PI / 2;
  this.rotation.z = 0;
  this.rotationAutoUpdate = !1;
};
THREE.CombinedCamera.prototype.toTopView = function () {
  this.rotation.x = -Math.PI / 2;
  this.rotation.y = 0;
  this.rotation.z = 0;
  this.rotationAutoUpdate = !1;
};
THREE.CombinedCamera.prototype.toBottomView = function () {
  this.rotation.x = Math.PI / 2;
  this.rotation.y = 0;
  this.rotation.z = 0;
  this.rotationAutoUpdate = !1;
};
THREE.BoxGeometry = function (a, b, c, d, e, f) {
  function g(a, b, c, d, e, f, g, p) {
    var v, w = h.widthSegments, t = h.heightSegments, x = e / 2, z = f / 2, B = h.vertices.length;
    if ('x' === a && 'y' === b || 'y' === a && 'x' === b)
      v = 'z';
    else if ('x' === a && 'z' === b || 'z' === a && 'x' === b)
      v = 'y', t = h.depthSegments;
    else if ('z' === a && 'y' === b || 'y' === a && 'z' === b)
      v = 'x', w = h.depthSegments;
    var E = w + 1, H = t + 1, D = e / w, G = f / t, I = new THREE.Vector3();
    I[v] = 0 < g ? 1 : -1;
    for (e = 0; e < H; e++)
      for (f = 0; f < E; f++) {
        var O = new THREE.Vector3();
        O[a] = (f * D - x) * c;
        O[b] = (e * G - z) * d;
        O[v] = g;
        h.vertices.push(O);
      }
    for (e = 0; e < t; e++)
      for (f = 0; f < w; f++)
        z = f + E * e, a = f + E * (e + 1), b = f + 1 + E * (e + 1), c = f + 1 + E * e, d = new THREE.Vector2(f / w, 1 - e / t), g = new THREE.Vector2(f / w, 1 - (e + 1) / t), v = new THREE.Vector2((f + 1) / w, 1 - (e + 1) / t), x = new THREE.Vector2((f + 1) / w, 1 - e / t), z = new THREE.Face3(z + B, a + B, c + B), z.normal.copy(I), z.vertexNormals.push(I.clone(), I.clone(), I.clone()), z.materialIndex = p, h.faces.push(z), h.faceVertexUvs[0].push([
          d,
          g,
          x
        ]), z = new THREE.Face3(a + B, b + B, c + B), z.normal.copy(I), z.vertexNormals.push(I.clone(), I.clone(), I.clone()), z.materialIndex = p, h.faces.push(z), h.faceVertexUvs[0].push([
          g.clone(),
          v,
          x.clone()
        ]);
  }
  THREE.Geometry.call(this);
  var h = this;
  this.width = a;
  this.height = b;
  this.depth = c;
  this.widthSegments = d || 1;
  this.heightSegments = e || 1;
  this.depthSegments = f || 1;
  a = this.width / 2;
  b = this.height / 2;
  c = this.depth / 2;
  g('z', 'y', -1, -1, this.depth, this.height, a, 0);
  g('z', 'y', 1, -1, this.depth, this.height, -a, 1);
  g('x', 'z', 1, 1, this.width, this.depth, b, 2);
  g('x', 'z', 1, -1, this.width, this.depth, -b, 3);
  g('x', 'y', 1, -1, this.width, this.height, c, 4);
  g('x', 'y', -1, -1, this.width, this.height, -c, 5);
  this.computeCentroids();
  this.mergeVertices();
};
THREE.BoxGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.CircleGeometry = function (a, b, c, d) {
  THREE.Geometry.call(this);
  this.radius = a = a || 50;
  this.segments = b = void 0 !== b ? Math.max(3, b) : 8;
  this.thetaStart = c = void 0 !== c ? c : 0;
  this.thetaLength = d = void 0 !== d ? d : 2 * Math.PI;
  var e, f = [];
  e = new THREE.Vector3();
  var g = new THREE.Vector2(0.5, 0.5);
  this.vertices.push(e);
  f.push(g);
  for (e = 0; e <= b; e++) {
    var h = new THREE.Vector3(), k = c + e / b * d;
    h.x = a * Math.cos(k);
    h.y = a * Math.sin(k);
    this.vertices.push(h);
    f.push(new THREE.Vector2((h.x / a + 1) / 2, (h.y / a + 1) / 2));
  }
  c = new THREE.Vector3(0, 0, 1);
  for (e = 1; e <= b; e++)
    this.faces.push(new THREE.Face3(e, e + 1, 0, [
      c.clone(),
      c.clone(),
      c.clone()
    ])), this.faceVertexUvs[0].push([
      f[e].clone(),
      f[e + 1].clone(),
      g.clone()
    ]);
  this.computeCentroids();
  this.computeFaceNormals();
  this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), a);
};
THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.CubeGeometry = THREE.BoxGeometry;
THREE.CylinderGeometry = function (a, b, c, d, e, f) {
  THREE.Geometry.call(this);
  this.radiusTop = a = void 0 !== a ? a : 20;
  this.radiusBottom = b = void 0 !== b ? b : 20;
  this.height = c = void 0 !== c ? c : 100;
  this.radialSegments = d = d || 8;
  this.heightSegments = e = e || 1;
  this.openEnded = f = void 0 !== f ? f : !1;
  var g = c / 2, h, k, l = [], n = [];
  for (k = 0; k <= e; k++) {
    var s = [], r = [], q = k / e, u = q * (b - a) + a;
    for (h = 0; h <= d; h++) {
      var p = h / d, v = new THREE.Vector3();
      v.x = u * Math.sin(p * Math.PI * 2);
      v.y = -q * c + g;
      v.z = u * Math.cos(p * Math.PI * 2);
      this.vertices.push(v);
      s.push(this.vertices.length - 1);
      r.push(new THREE.Vector2(p, 1 - q));
    }
    l.push(s);
    n.push(r);
  }
  c = (b - a) / c;
  for (h = 0; h < d; h++)
    for (0 !== a ? (s = this.vertices[l[0][h]].clone(), r = this.vertices[l[0][h + 1]].clone()) : (s = this.vertices[l[1][h]].clone(), r = this.vertices[l[1][h + 1]].clone()), s.setY(Math.sqrt(s.x * s.x + s.z * s.z) * c).normalize(), r.setY(Math.sqrt(r.x * r.x + r.z * r.z) * c).normalize(), k = 0; k < e; k++) {
      var q = l[k][h], u = l[k + 1][h], p = l[k + 1][h + 1], v = l[k][h + 1], w = s.clone(), t = s.clone(), x = r.clone(), z = r.clone(), B = n[k][h].clone(), E = n[k + 1][h].clone(), H = n[k + 1][h + 1].clone(), D = n[k][h + 1].clone();
      this.faces.push(new THREE.Face3(q, u, v, [
        w,
        t,
        z
      ]));
      this.faceVertexUvs[0].push([
        B,
        E,
        D
      ]);
      this.faces.push(new THREE.Face3(u, p, v, [
        t.clone(),
        x,
        z.clone()
      ]));
      this.faceVertexUvs[0].push([
        E.clone(),
        H,
        D.clone()
      ]);
    }
  if (!1 === f && 0 < a)
    for (this.vertices.push(new THREE.Vector3(0, g, 0)), h = 0; h < d; h++)
      q = l[0][h], u = l[0][h + 1], p = this.vertices.length - 1, w = new THREE.Vector3(0, 1, 0), t = new THREE.Vector3(0, 1, 0), x = new THREE.Vector3(0, 1, 0), B = n[0][h].clone(), E = n[0][h + 1].clone(), H = new THREE.Vector2(E.x, 0), this.faces.push(new THREE.Face3(q, u, p, [
        w,
        t,
        x
      ])), this.faceVertexUvs[0].push([
        B,
        E,
        H
      ]);
  if (!1 === f && 0 < b)
    for (this.vertices.push(new THREE.Vector3(0, -g, 0)), h = 0; h < d; h++)
      q = l[k][h + 1], u = l[k][h], p = this.vertices.length - 1, w = new THREE.Vector3(0, -1, 0), t = new THREE.Vector3(0, -1, 0), x = new THREE.Vector3(0, -1, 0), B = n[k][h + 1].clone(), E = n[k][h].clone(), H = new THREE.Vector2(E.x, 1), this.faces.push(new THREE.Face3(q, u, p, [
        w,
        t,
        x
      ])), this.faceVertexUvs[0].push([
        B,
        E,
        H
      ]);
  this.computeCentroids();
  this.computeFaceNormals();
};
THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ExtrudeGeometry = function (a, b) {
  'undefined' !== typeof a && (THREE.Geometry.call(this), a = a instanceof Array ? a : [a], this.shapebb = a[a.length - 1].getBoundingBox(), this.addShapeList(a, b), this.computeCentroids(), this.computeFaceNormals());
};
THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ExtrudeGeometry.prototype.addShapeList = function (a, b) {
  for (var c = a.length, d = 0; d < c; d++)
    this.addShape(a[d], b);
};
THREE.ExtrudeGeometry.prototype.addShape = function (a, b) {
  function c(a, b, c) {
    b || console.log('die');
    return b.clone().multiplyScalar(c).add(a);
  }
  function d(a, b, c) {
    var d = THREE.Math.sign, e = 1, e = a.x - b.x, f = a.y - b.y, g = c.x - a.x, h = c.y - a.y, k = e * e + f * f;
    if (1e-10 < Math.abs(e * h - f * g)) {
      var l = Math.sqrt(k), d = Math.sqrt(g * g + h * h), k = b.x - f / l;
      b = b.y + e / l;
      g = ((c.x - h / d - k) * h - (c.y + g / d - b) * g) / (e * h - f * g);
      c = k + e * g - a.x;
      a = b + f * g - a.y;
      e = c * c + a * a;
      if (2 >= e)
        return new THREE.Vector2(c, a);
      e = Math.sqrt(e / 2);
    } else
      a = !1, 1e-10 < e ? 1e-10 < g && (a = !0) : -1e-10 > e ? -1e-10 > g && (a = !0) : d(f) == d(h) && (a = !0), a ? (c = -f, a = e, e = Math.sqrt(k)) : (c = e, a = f, e = Math.sqrt(k / 2));
    return new THREE.Vector2(c / e, a / e);
  }
  function e(c, d) {
    var e, f;
    for (J = c.length; 0 <= --J;) {
      e = J;
      f = J - 1;
      0 > f && (f = c.length - 1);
      for (var g = 0, h = q + 2 * n, g = 0; g < h; g++) {
        var k = fa * g, l = fa * (g + 1), p = d + e + k, k = d + f + k, r = d + f + l, l = d + e + l, s = c, u = g, v = h, w = e, y = f, p = p + K, k = k + K, r = r + K, l = l + K;
        O.faces.push(new THREE.Face3(p, k, l, null, null, t));
        O.faces.push(new THREE.Face3(k, r, l, null, null, t));
        p = x.generateSideWallUV(O, a, s, b, p, k, r, l, u, v, w, y);
        O.faceVertexUvs[0].push([
          p[0],
          p[1],
          p[3]
        ]);
        O.faceVertexUvs[0].push([
          p[1],
          p[2],
          p[3]
        ]);
      }
    }
  }
  function f(a, b, c) {
    O.vertices.push(new THREE.Vector3(a, b, c));
  }
  function g(c, d, e, f) {
    c += K;
    d += K;
    e += K;
    O.faces.push(new THREE.Face3(c, d, e, null, null, w));
    c = f ? x.generateBottomUV(O, a, b, c, d, e) : x.generateTopUV(O, a, b, c, d, e);
    O.faceVertexUvs[0].push(c);
  }
  var h = void 0 !== b.amount ? b.amount : 100, k = void 0 !== b.bevelThickness ? b.bevelThickness : 6, l = void 0 !== b.bevelSize ? b.bevelSize : k - 2, n = void 0 !== b.bevelSegments ? b.bevelSegments : 3, s = void 0 !== b.bevelEnabled ? b.bevelEnabled : !0, r = void 0 !== b.curveSegments ? b.curveSegments : 12, q = void 0 !== b.steps ? b.steps : 1, u = b.extrudePath, p, v = !1, w = b.material, t = b.extrudeMaterial, x = void 0 !== b.UVGenerator ? b.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator, z, B, E, H;
  u && (p = u.getSpacedPoints(q), v = !0, s = !1, z = void 0 !== b.frames ? b.frames : new THREE.TubeGeometry.FrenetFrames(u, q, !1), B = new THREE.Vector3(), E = new THREE.Vector3(), H = new THREE.Vector3());
  s || (l = k = n = 0);
  var D, G, I, O = this, K = this.vertices.length, u = a.extractPoints(r), r = u.shape, y = u.holes;
  if (u = !THREE.Shape.Utils.isClockWise(r)) {
    r = r.reverse();
    G = 0;
    for (I = y.length; G < I; G++)
      D = y[G], THREE.Shape.Utils.isClockWise(D) && (y[G] = D.reverse());
    u = !1;
  }
  var F = THREE.Shape.Utils.triangulateShape(r, y), C = r;
  G = 0;
  for (I = y.length; G < I; G++)
    D = y[G], r = r.concat(D);
  var A, L, Q, Y, R, fa = r.length, V, ga = F.length, u = [], J = 0;
  Q = C.length;
  A = Q - 1;
  for (L = J + 1; J < Q; J++, A++, L++)
    A === Q && (A = 0), L === Q && (L = 0), u[J] = d(C[J], C[A], C[L]);
  var da = [], W, N = u.concat();
  G = 0;
  for (I = y.length; G < I; G++) {
    D = y[G];
    W = [];
    J = 0;
    Q = D.length;
    A = Q - 1;
    for (L = J + 1; J < Q; J++, A++, L++)
      A === Q && (A = 0), L === Q && (L = 0), W[J] = d(D[J], D[A], D[L]);
    da.push(W);
    N = N.concat(W);
  }
  for (A = 0; A < n; A++) {
    Q = A / n;
    Y = k * (1 - Q);
    L = l * Math.sin(Q * Math.PI / 2);
    J = 0;
    for (Q = C.length; J < Q; J++)
      R = c(C[J], u[J], L), f(R.x, R.y, -Y);
    G = 0;
    for (I = y.length; G < I; G++)
      for (D = y[G], W = da[G], J = 0, Q = D.length; J < Q; J++)
        R = c(D[J], W[J], L), f(R.x, R.y, -Y);
  }
  L = l;
  for (J = 0; J < fa; J++)
    R = s ? c(r[J], N[J], L) : r[J], v ? (E.copy(z.normals[0]).multiplyScalar(R.x), B.copy(z.binormals[0]).multiplyScalar(R.y), H.copy(p[0]).add(E).add(B), f(H.x, H.y, H.z)) : f(R.x, R.y, 0);
  for (Q = 1; Q <= q; Q++)
    for (J = 0; J < fa; J++)
      R = s ? c(r[J], N[J], L) : r[J], v ? (E.copy(z.normals[Q]).multiplyScalar(R.x), B.copy(z.binormals[Q]).multiplyScalar(R.y), H.copy(p[Q]).add(E).add(B), f(H.x, H.y, H.z)) : f(R.x, R.y, h / q * Q);
  for (A = n - 1; 0 <= A; A--) {
    Q = A / n;
    Y = k * (1 - Q);
    L = l * Math.sin(Q * Math.PI / 2);
    J = 0;
    for (Q = C.length; J < Q; J++)
      R = c(C[J], u[J], L), f(R.x, R.y, h + Y);
    G = 0;
    for (I = y.length; G < I; G++)
      for (D = y[G], W = da[G], J = 0, Q = D.length; J < Q; J++)
        R = c(D[J], W[J], L), v ? f(R.x, R.y + p[q - 1].y, p[q - 1].x + Y) : f(R.x, R.y, h + Y);
  }
  (function () {
    if (s) {
      var a;
      a = 0 * fa;
      for (J = 0; J < ga; J++)
        V = F[J], g(V[2] + a, V[1] + a, V[0] + a, !0);
      a = q + 2 * n;
      a *= fa;
      for (J = 0; J < ga; J++)
        V = F[J], g(V[0] + a, V[1] + a, V[2] + a, !1);
    } else {
      for (J = 0; J < ga; J++)
        V = F[J], g(V[2], V[1], V[0], !0);
      for (J = 0; J < ga; J++)
        V = F[J], g(V[0] + fa * q, V[1] + fa * q, V[2] + fa * q, !1);
    }
  }());
  (function () {
    var a = 0;
    e(C, a);
    a += C.length;
    G = 0;
    for (I = y.length; G < I; G++)
      D = y[G], e(D, a), a += D.length;
  }());
};
THREE.ExtrudeGeometry.WorldUVGenerator = {
  generateTopUV: function (a, b, c, d, e, f) {
    b = a.vertices[e].x;
    e = a.vertices[e].y;
    c = a.vertices[f].x;
    f = a.vertices[f].y;
    return [
      new THREE.Vector2(a.vertices[d].x, a.vertices[d].y),
      new THREE.Vector2(b, e),
      new THREE.Vector2(c, f)
    ];
  },
  generateBottomUV: function (a, b, c, d, e, f) {
    return this.generateTopUV(a, b, c, d, e, f);
  },
  generateSideWallUV: function (a, b, c, d, e, f, g, h, k, l, n, s) {
    b = a.vertices[e].x;
    c = a.vertices[e].y;
    e = a.vertices[e].z;
    d = a.vertices[f].x;
    k = a.vertices[f].y;
    f = a.vertices[f].z;
    l = a.vertices[g].x;
    n = a.vertices[g].y;
    g = a.vertices[g].z;
    s = a.vertices[h].x;
    var r = a.vertices[h].y;
    a = a.vertices[h].z;
    return 0.01 > Math.abs(c - k) ? [
      new THREE.Vector2(b, 1 - e),
      new THREE.Vector2(d, 1 - f),
      new THREE.Vector2(l, 1 - g),
      new THREE.Vector2(s, 1 - a)
    ] : [
      new THREE.Vector2(c, 1 - e),
      new THREE.Vector2(k, 1 - f),
      new THREE.Vector2(n, 1 - g),
      new THREE.Vector2(r, 1 - a)
    ];
  }
};
THREE.ExtrudeGeometry.__v1 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v2 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v3 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v4 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v5 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v6 = new THREE.Vector2();
THREE.ShapeGeometry = function (a, b) {
  THREE.Geometry.call(this);
  !1 === a instanceof Array && (a = [a]);
  this.shapebb = a[a.length - 1].getBoundingBox();
  this.addShapeList(a, b);
  this.computeCentroids();
  this.computeFaceNormals();
};
THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ShapeGeometry.prototype.addShapeList = function (a, b) {
  for (var c = 0, d = a.length; c < d; c++)
    this.addShape(a[c], b);
  return this;
};
THREE.ShapeGeometry.prototype.addShape = function (a, b) {
  void 0 === b && (b = {});
  var c = b.material, d = void 0 === b.UVGenerator ? THREE.ExtrudeGeometry.WorldUVGenerator : b.UVGenerator, e, f, g, h = this.vertices.length;
  e = a.extractPoints(void 0 !== b.curveSegments ? b.curveSegments : 12);
  var k = e.shape, l = e.holes;
  if (!THREE.Shape.Utils.isClockWise(k))
    for (k = k.reverse(), e = 0, f = l.length; e < f; e++)
      g = l[e], THREE.Shape.Utils.isClockWise(g) && (l[e] = g.reverse());
  var n = THREE.Shape.Utils.triangulateShape(k, l);
  e = 0;
  for (f = l.length; e < f; e++)
    g = l[e], k = k.concat(g);
  l = k.length;
  f = n.length;
  for (e = 0; e < l; e++)
    g = k[e], this.vertices.push(new THREE.Vector3(g.x, g.y, 0));
  for (e = 0; e < f; e++)
    l = n[e], k = l[0] + h, g = l[1] + h, l = l[2] + h, this.faces.push(new THREE.Face3(k, g, l, null, null, c)), this.faceVertexUvs[0].push(d.generateBottomUV(this, a, b, k, g, l));
};
THREE.LatheGeometry = function (a, b, c, d) {
  THREE.Geometry.call(this);
  b = b || 12;
  c = c || 0;
  d = d || 2 * Math.PI;
  for (var e = 1 / (a.length - 1), f = 1 / b, g = 0, h = b; g <= h; g++)
    for (var k = c + g * f * d, l = Math.cos(k), n = Math.sin(k), k = 0, s = a.length; k < s; k++) {
      var r = a[k], q = new THREE.Vector3();
      q.x = l * r.x - n * r.y;
      q.y = n * r.x + l * r.y;
      q.z = r.z;
      this.vertices.push(q);
    }
  c = a.length;
  g = 0;
  for (h = b; g < h; g++)
    for (k = 0, s = a.length - 1; k < s; k++) {
      b = n = k + c * g;
      d = n + c;
      var l = n + 1 + c, n = n + 1, r = g * f, q = k * e, u = r + f, p = q + e;
      this.faces.push(new THREE.Face3(b, d, n));
      this.faceVertexUvs[0].push([
        new THREE.Vector2(r, q),
        new THREE.Vector2(u, q),
        new THREE.Vector2(r, p)
      ]);
      this.faces.push(new THREE.Face3(d, l, n));
      this.faceVertexUvs[0].push([
        new THREE.Vector2(u, q),
        new THREE.Vector2(u, p),
        new THREE.Vector2(r, p)
      ]);
    }
  this.mergeVertices();
  this.computeCentroids();
  this.computeFaceNormals();
  this.computeVertexNormals();
};
THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.PlaneGeometry = function (a, b, c, d) {
  THREE.Geometry.call(this);
  this.width = a;
  this.height = b;
  this.widthSegments = c || 1;
  this.heightSegments = d || 1;
  var e = a / 2, f = b / 2;
  c = this.widthSegments;
  d = this.heightSegments;
  var g = c + 1, h = d + 1, k = this.width / c, l = this.height / d, n = new THREE.Vector3(0, 0, 1);
  for (a = 0; a < h; a++)
    for (b = 0; b < g; b++)
      this.vertices.push(new THREE.Vector3(b * k - e, -(a * l - f), 0));
  for (a = 0; a < d; a++)
    for (b = 0; b < c; b++) {
      var s = b + g * a, e = b + g * (a + 1), f = b + 1 + g * (a + 1), h = b + 1 + g * a, k = new THREE.Vector2(b / c, 1 - a / d), l = new THREE.Vector2(b / c, 1 - (a + 1) / d), r = new THREE.Vector2((b + 1) / c, 1 - (a + 1) / d), q = new THREE.Vector2((b + 1) / c, 1 - a / d), s = new THREE.Face3(s, e, h);
      s.normal.copy(n);
      s.vertexNormals.push(n.clone(), n.clone(), n.clone());
      this.faces.push(s);
      this.faceVertexUvs[0].push([
        k,
        l,
        q
      ]);
      s = new THREE.Face3(e, f, h);
      s.normal.copy(n);
      s.vertexNormals.push(n.clone(), n.clone(), n.clone());
      this.faces.push(s);
      this.faceVertexUvs[0].push([
        l.clone(),
        r,
        q.clone()
      ]);
    }
  this.computeCentroids();
};
THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.RingGeometry = function (a, b, c, d, e, f) {
  THREE.Geometry.call(this);
  a = a || 0;
  b = b || 50;
  e = void 0 !== e ? e : 0;
  f = void 0 !== f ? f : 2 * Math.PI;
  c = void 0 !== c ? Math.max(3, c) : 8;
  d = void 0 !== d ? Math.max(3, d) : 8;
  var g, h = [], k = a, l = (b - a) / d;
  for (a = 0; a <= d; a++) {
    for (g = 0; g <= c; g++) {
      var n = new THREE.Vector3(), s = e + g / c * f;
      n.x = k * Math.cos(s);
      n.y = k * Math.sin(s);
      this.vertices.push(n);
      h.push(new THREE.Vector2((n.x / b + 1) / 2, (n.y / b + 1) / 2));
    }
    k += l;
  }
  b = new THREE.Vector3(0, 0, 1);
  for (a = 0; a < d; a++)
    for (e = a * c, g = 0; g <= c; g++)
      s = g + e, f = s + a, l = s + c + a, n = s + c + 1 + a, this.faces.push(new THREE.Face3(f, l, n, [
        b.clone(),
        b.clone(),
        b.clone()
      ])), this.faceVertexUvs[0].push([
        h[f].clone(),
        h[l].clone(),
        h[n].clone()
      ]), f = s + a, l = s + c + 1 + a, n = s + 1 + a, this.faces.push(new THREE.Face3(f, l, n, [
        b.clone(),
        b.clone(),
        b.clone()
      ])), this.faceVertexUvs[0].push([
        h[f].clone(),
        h[l].clone(),
        h[n].clone()
      ]);
  this.computeCentroids();
  this.computeFaceNormals();
  this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), k);
};
THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.SphereGeometry = function (a, b, c, d, e, f, g) {
  THREE.Geometry.call(this);
  this.radius = a = a || 50;
  this.widthSegments = b = Math.max(3, Math.floor(b) || 8);
  this.heightSegments = c = Math.max(2, Math.floor(c) || 6);
  this.phiStart = d = void 0 !== d ? d : 0;
  this.phiLength = e = void 0 !== e ? e : 2 * Math.PI;
  this.thetaStart = f = void 0 !== f ? f : 0;
  this.thetaLength = g = void 0 !== g ? g : Math.PI;
  var h, k, l = [], n = [];
  for (k = 0; k <= c; k++) {
    var s = [], r = [];
    for (h = 0; h <= b; h++) {
      var q = h / b, u = k / c, p = new THREE.Vector3();
      p.x = -a * Math.cos(d + q * e) * Math.sin(f + u * g);
      p.y = a * Math.cos(f + u * g);
      p.z = a * Math.sin(d + q * e) * Math.sin(f + u * g);
      this.vertices.push(p);
      s.push(this.vertices.length - 1);
      r.push(new THREE.Vector2(q, 1 - u));
    }
    l.push(s);
    n.push(r);
  }
  for (k = 0; k < this.heightSegments; k++)
    for (h = 0; h < this.widthSegments; h++) {
      b = l[k][h + 1];
      c = l[k][h];
      d = l[k + 1][h];
      e = l[k + 1][h + 1];
      f = this.vertices[b].clone().normalize();
      g = this.vertices[c].clone().normalize();
      var s = this.vertices[d].clone().normalize(), r = this.vertices[e].clone().normalize(), q = n[k][h + 1].clone(), u = n[k][h].clone(), p = n[k + 1][h].clone(), v = n[k + 1][h + 1].clone();
      Math.abs(this.vertices[b].y) === this.radius ? (q.x = (q.x + u.x) / 2, this.faces.push(new THREE.Face3(b, d, e, [
        f,
        s,
        r
      ])), this.faceVertexUvs[0].push([
        q,
        p,
        v
      ])) : Math.abs(this.vertices[d].y) === this.radius ? (p.x = (p.x + v.x) / 2, this.faces.push(new THREE.Face3(b, c, d, [
        f,
        g,
        s
      ])), this.faceVertexUvs[0].push([
        q,
        u,
        p
      ])) : (this.faces.push(new THREE.Face3(b, c, e, [
        f,
        g,
        r
      ])), this.faceVertexUvs[0].push([
        q,
        u,
        v
      ]), this.faces.push(new THREE.Face3(c, d, e, [
        g.clone(),
        s,
        r.clone()
      ])), this.faceVertexUvs[0].push([
        u.clone(),
        p,
        v.clone()
      ]));
    }
  this.computeCentroids();
  this.computeFaceNormals();
  this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), a);
};
THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TextGeometry = function (a, b) {
  b = b || {};
  var c = THREE.FontUtils.generateShapes(a, b);
  b.amount = void 0 !== b.height ? b.height : 50;
  void 0 === b.bevelThickness && (b.bevelThickness = 10);
  void 0 === b.bevelSize && (b.bevelSize = 8);
  void 0 === b.bevelEnabled && (b.bevelEnabled = !1);
  THREE.ExtrudeGeometry.call(this, c, b);
};
THREE.TextGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype);
THREE.TorusGeometry = function (a, b, c, d, e) {
  THREE.Geometry.call(this);
  this.radius = a || 100;
  this.tube = b || 40;
  this.radialSegments = c || 8;
  this.tubularSegments = d || 6;
  this.arc = e || 2 * Math.PI;
  e = new THREE.Vector3();
  a = [];
  b = [];
  for (c = 0; c <= this.radialSegments; c++)
    for (d = 0; d <= this.tubularSegments; d++) {
      var f = d / this.tubularSegments * this.arc, g = c / this.radialSegments * Math.PI * 2;
      e.x = this.radius * Math.cos(f);
      e.y = this.radius * Math.sin(f);
      var h = new THREE.Vector3();
      h.x = (this.radius + this.tube * Math.cos(g)) * Math.cos(f);
      h.y = (this.radius + this.tube * Math.cos(g)) * Math.sin(f);
      h.z = this.tube * Math.sin(g);
      this.vertices.push(h);
      a.push(new THREE.Vector2(d / this.tubularSegments, c / this.radialSegments));
      b.push(h.clone().sub(e).normalize());
    }
  for (c = 1; c <= this.radialSegments; c++)
    for (d = 1; d <= this.tubularSegments; d++) {
      e = (this.tubularSegments + 1) * c + d - 1;
      var f = (this.tubularSegments + 1) * (c - 1) + d - 1, g = (this.tubularSegments + 1) * (c - 1) + d, h = (this.tubularSegments + 1) * c + d, k = new THREE.Face3(e, f, h, [
          b[e].clone(),
          b[f].clone(),
          b[h].clone()
        ]);
      this.faces.push(k);
      this.faceVertexUvs[0].push([
        a[e].clone(),
        a[f].clone(),
        a[h].clone()
      ]);
      k = new THREE.Face3(f, g, h, [
        b[f].clone(),
        b[g].clone(),
        b[h].clone()
      ]);
      this.faces.push(k);
      this.faceVertexUvs[0].push([
        a[f].clone(),
        a[g].clone(),
        a[h].clone()
      ]);
    }
  this.computeCentroids();
  this.computeFaceNormals();
};
THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TorusKnotGeometry = function (a, b, c, d, e, f, g) {
  function h(a, b, c, d, e) {
    var f = Math.cos(a), g = Math.sin(a);
    a *= b / c;
    b = Math.cos(a);
    f *= d * (2 + b) * 0.5;
    g = d * (2 + b) * g * 0.5;
    d = e * d * Math.sin(a) * 0.5;
    return new THREE.Vector3(f, g, d);
  }
  THREE.Geometry.call(this);
  this.radius = a || 100;
  this.tube = b || 40;
  this.radialSegments = c || 64;
  this.tubularSegments = d || 8;
  this.p = e || 2;
  this.q = f || 3;
  this.heightScale = g || 1;
  this.grid = Array(this.radialSegments);
  c = new THREE.Vector3();
  d = new THREE.Vector3();
  e = new THREE.Vector3();
  for (a = 0; a < this.radialSegments; ++a)
    for (this.grid[a] = Array(this.tubularSegments), b = a / this.radialSegments * 2 * this.p * Math.PI, f = h(b, this.q, this.p, this.radius, this.heightScale), b = h(b + 0.01, this.q, this.p, this.radius, this.heightScale), c.subVectors(b, f), d.addVectors(b, f), e.crossVectors(c, d), d.crossVectors(e, c), e.normalize(), d.normalize(), b = 0; b < this.tubularSegments; ++b) {
      var k = b / this.tubularSegments * 2 * Math.PI;
      g = -this.tube * Math.cos(k);
      var k = this.tube * Math.sin(k), l = new THREE.Vector3();
      l.x = f.x + g * d.x + k * e.x;
      l.y = f.y + g * d.y + k * e.y;
      l.z = f.z + g * d.z + k * e.z;
      this.grid[a][b] = this.vertices.push(l) - 1;
    }
  for (a = 0; a < this.radialSegments; ++a)
    for (b = 0; b < this.tubularSegments; ++b) {
      e = (a + 1) % this.radialSegments;
      f = (b + 1) % this.tubularSegments;
      c = this.grid[a][b];
      d = this.grid[e][b];
      e = this.grid[e][f];
      f = this.grid[a][f];
      g = new THREE.Vector2(a / this.radialSegments, b / this.tubularSegments);
      var k = new THREE.Vector2((a + 1) / this.radialSegments, b / this.tubularSegments), l = new THREE.Vector2((a + 1) / this.radialSegments, (b + 1) / this.tubularSegments), n = new THREE.Vector2(a / this.radialSegments, (b + 1) / this.tubularSegments);
      this.faces.push(new THREE.Face3(c, d, f));
      this.faceVertexUvs[0].push([
        g,
        k,
        n
      ]);
      this.faces.push(new THREE.Face3(d, e, f));
      this.faceVertexUvs[0].push([
        k.clone(),
        l,
        n.clone()
      ]);
    }
  this.computeCentroids();
  this.computeFaceNormals();
  this.computeVertexNormals();
};
THREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TubeGeometry = function (a, b, c, d, e) {
  THREE.Geometry.call(this);
  this.path = a;
  this.segments = b || 64;
  this.radius = c || 1;
  this.radialSegments = d || 8;
  this.closed = e || !1;
  this.grid = [];
  var f, g;
  d = this.segments + 1;
  var h, k, l;
  e = new THREE.Vector3();
  var n, s;
  b = new THREE.TubeGeometry.FrenetFrames(this.path, this.segments, this.closed);
  n = b.normals;
  s = b.binormals;
  this.tangents = b.tangents;
  this.normals = n;
  this.binormals = s;
  for (b = 0; b < d; b++)
    for (this.grid[b] = [], c = b / (d - 1), l = a.getPointAt(c), f = n[b], g = s[b], c = 0; c < this.radialSegments; c++)
      h = c / this.radialSegments * 2 * Math.PI, k = -this.radius * Math.cos(h), h = this.radius * Math.sin(h), e.copy(l), e.x += k * f.x + h * g.x, e.y += k * f.y + h * g.y, e.z += k * f.z + h * g.z, this.grid[b][c] = this.vertices.push(new THREE.Vector3(e.x, e.y, e.z)) - 1;
  for (b = 0; b < this.segments; b++)
    for (c = 0; c < this.radialSegments; c++)
      e = this.closed ? (b + 1) % this.segments : b + 1, n = (c + 1) % this.radialSegments, a = this.grid[b][c], d = this.grid[e][c], e = this.grid[e][n], n = this.grid[b][n], s = new THREE.Vector2(b / this.segments, c / this.radialSegments), f = new THREE.Vector2((b + 1) / this.segments, c / this.radialSegments), g = new THREE.Vector2((b + 1) / this.segments, (c + 1) / this.radialSegments), k = new THREE.Vector2(b / this.segments, (c + 1) / this.radialSegments), this.faces.push(new THREE.Face3(a, d, n)), this.faceVertexUvs[0].push([
        s,
        f,
        k
      ]), this.faces.push(new THREE.Face3(d, e, n)), this.faceVertexUvs[0].push([
        f.clone(),
        g,
        k.clone()
      ]);
  this.computeCentroids();
  this.computeFaceNormals();
  this.computeVertexNormals();
};
THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TubeGeometry.FrenetFrames = function (a, b, c) {
  new THREE.Vector3();
  var d = new THREE.Vector3();
  new THREE.Vector3();
  var e = [], f = [], g = [], h = new THREE.Vector3(), k = new THREE.Matrix4();
  b += 1;
  var l, n, s;
  this.tangents = e;
  this.normals = f;
  this.binormals = g;
  for (l = 0; l < b; l++)
    n = l / (b - 1), e[l] = a.getTangentAt(n), e[l].normalize();
  f[0] = new THREE.Vector3();
  g[0] = new THREE.Vector3();
  a = Number.MAX_VALUE;
  l = Math.abs(e[0].x);
  n = Math.abs(e[0].y);
  s = Math.abs(e[0].z);
  l <= a && (a = l, d.set(1, 0, 0));
  n <= a && (a = n, d.set(0, 1, 0));
  s <= a && d.set(0, 0, 1);
  h.crossVectors(e[0], d).normalize();
  f[0].crossVectors(e[0], h);
  g[0].crossVectors(e[0], f[0]);
  for (l = 1; l < b; l++)
    f[l] = f[l - 1].clone(), g[l] = g[l - 1].clone(), h.crossVectors(e[l - 1], e[l]), 0.0001 < h.length() && (h.normalize(), d = Math.acos(THREE.Math.clamp(e[l - 1].dot(e[l]), -1, 1)), f[l].applyMatrix4(k.makeRotationAxis(h, d))), g[l].crossVectors(e[l], f[l]);
  if (c)
    for (d = Math.acos(THREE.Math.clamp(f[0].dot(f[b - 1]), -1, 1)), d /= b - 1, 0 < e[0].dot(h.crossVectors(f[0], f[b - 1])) && (d = -d), l = 1; l < b; l++)
      f[l].applyMatrix4(k.makeRotationAxis(e[l], d * l)), g[l].crossVectors(e[l], f[l]);
};
THREE.PolyhedronGeometry = function (a, b, c, d) {
  function e(a) {
    var b = a.normalize().clone();
    b.index = k.vertices.push(b) - 1;
    var c = Math.atan2(a.z, -a.x) / 2 / Math.PI + 0.5;
    a = Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + 0.5;
    b.uv = new THREE.Vector2(c, 1 - a);
    return b;
  }
  function f(a, b, c) {
    var d = new THREE.Face3(a.index, b.index, c.index, [
        a.clone(),
        b.clone(),
        c.clone()
      ]);
    d.centroid.add(a).add(b).add(c).divideScalar(3);
    k.faces.push(d);
    d = d.centroid;
    d = Math.atan2(d.z, -d.x);
    k.faceVertexUvs[0].push([
      h(a.uv, a, d),
      h(b.uv, b, d),
      h(c.uv, c, d)
    ]);
  }
  function g(a, b) {
    var c = Math.pow(2, b);
    Math.pow(4, b);
    for (var d = e(k.vertices[a.a]), g = e(k.vertices[a.b]), h = e(k.vertices[a.c]), l = [], n = 0; n <= c; n++) {
      l[n] = [];
      for (var q = e(d.clone().lerp(h, n / c)), r = e(g.clone().lerp(h, n / c)), s = c - n, u = 0; u <= s; u++)
        l[n][u] = 0 == u && n == c ? q : e(q.clone().lerp(r, u / s));
    }
    for (n = 0; n < c; n++)
      for (u = 0; u < 2 * (c - n) - 1; u++)
        d = Math.floor(u / 2), 0 == u % 2 ? f(l[n][d + 1], l[n + 1][d], l[n][d]) : f(l[n][d + 1], l[n + 1][d + 1], l[n + 1][d]);
  }
  function h(a, b, c) {
    0 > c && 1 === a.x && (a = new THREE.Vector2(a.x - 1, a.y));
    0 === b.x && 0 === b.z && (a = new THREE.Vector2(c / 2 / Math.PI + 0.5, a.y));
    return a.clone();
  }
  THREE.Geometry.call(this);
  c = c || 1;
  d = d || 0;
  for (var k = this, l = 0, n = a.length; l < n; l++)
    e(new THREE.Vector3(a[l][0], a[l][1], a[l][2]));
  a = this.vertices;
  for (var s = [], l = 0, n = b.length; l < n; l++) {
    var r = a[b[l][0]], q = a[b[l][1]], u = a[b[l][2]];
    s[l] = new THREE.Face3(r.index, q.index, u.index, [
      r.clone(),
      q.clone(),
      u.clone()
    ]);
  }
  l = 0;
  for (n = s.length; l < n; l++)
    g(s[l], d);
  l = 0;
  for (n = this.faceVertexUvs[0].length; l < n; l++)
    b = this.faceVertexUvs[0][l], d = b[0].x, a = b[1].x, s = b[2].x, r = Math.max(d, Math.max(a, s)), q = Math.min(d, Math.min(a, s)), 0.9 < r && 0.1 > q && (0.2 > d && (b[0].x += 1), 0.2 > a && (b[1].x += 1), 0.2 > s && (b[2].x += 1));
  l = 0;
  for (n = this.vertices.length; l < n; l++)
    this.vertices[l].multiplyScalar(c);
  this.mergeVertices();
  this.computeCentroids();
  this.computeFaceNormals();
  this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), c);
};
THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.IcosahedronGeometry = function (a, b) {
  this.radius = a;
  this.detail = b;
  var c = (1 + Math.sqrt(5)) / 2;
  THREE.PolyhedronGeometry.call(this, [
    [
      -1,
      c,
      0
    ],
    [
      1,
      c,
      0
    ],
    [
      -1,
      -c,
      0
    ],
    [
      1,
      -c,
      0
    ],
    [
      0,
      -1,
      c
    ],
    [
      0,
      1,
      c
    ],
    [
      0,
      -1,
      -c
    ],
    [
      0,
      1,
      -c
    ],
    [
      c,
      0,
      -1
    ],
    [
      c,
      0,
      1
    ],
    [
      -c,
      0,
      -1
    ],
    [
      -c,
      0,
      1
    ]
  ], [
    [
      0,
      11,
      5
    ],
    [
      0,
      5,
      1
    ],
    [
      0,
      1,
      7
    ],
    [
      0,
      7,
      10
    ],
    [
      0,
      10,
      11
    ],
    [
      1,
      5,
      9
    ],
    [
      5,
      11,
      4
    ],
    [
      11,
      10,
      2
    ],
    [
      10,
      7,
      6
    ],
    [
      7,
      1,
      8
    ],
    [
      3,
      9,
      4
    ],
    [
      3,
      4,
      2
    ],
    [
      3,
      2,
      6
    ],
    [
      3,
      6,
      8
    ],
    [
      3,
      8,
      9
    ],
    [
      4,
      9,
      5
    ],
    [
      2,
      4,
      11
    ],
    [
      6,
      2,
      10
    ],
    [
      8,
      6,
      7
    ],
    [
      9,
      8,
      1
    ]
  ], a, b);
};
THREE.IcosahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.OctahedronGeometry = function (a, b) {
  THREE.PolyhedronGeometry.call(this, [
    [
      1,
      0,
      0
    ],
    [
      -1,
      0,
      0
    ],
    [
      0,
      1,
      0
    ],
    [
      0,
      -1,
      0
    ],
    [
      0,
      0,
      1
    ],
    [
      0,
      0,
      -1
    ]
  ], [
    [
      0,
      2,
      4
    ],
    [
      0,
      4,
      3
    ],
    [
      0,
      3,
      5
    ],
    [
      0,
      5,
      2
    ],
    [
      1,
      2,
      5
    ],
    [
      1,
      5,
      3
    ],
    [
      1,
      3,
      4
    ],
    [
      1,
      4,
      2
    ]
  ], a, b);
};
THREE.OctahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TetrahedronGeometry = function (a, b) {
  THREE.PolyhedronGeometry.call(this, [
    [
      1,
      1,
      1
    ],
    [
      -1,
      -1,
      1
    ],
    [
      -1,
      1,
      -1
    ],
    [
      1,
      -1,
      -1
    ]
  ], [
    [
      2,
      1,
      0
    ],
    [
      0,
      3,
      2
    ],
    [
      1,
      3,
      0
    ],
    [
      2,
      3,
      1
    ]
  ], a, b);
};
THREE.TetrahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ParametricGeometry = function (a, b, c) {
  THREE.Geometry.call(this);
  var d = this.vertices, e = this.faces, f = this.faceVertexUvs[0], g, h, k, l, n = b + 1;
  for (g = 0; g <= c; g++)
    for (l = g / c, h = 0; h <= b; h++)
      k = h / b, k = a(k, l), d.push(k);
  var s, r, q, u;
  for (g = 0; g < c; g++)
    for (h = 0; h < b; h++)
      a = g * n + h, d = g * n + h + 1, l = (g + 1) * n + h + 1, k = (g + 1) * n + h, s = new THREE.Vector2(h / b, g / c), r = new THREE.Vector2((h + 1) / b, g / c), q = new THREE.Vector2((h + 1) / b, (g + 1) / c), u = new THREE.Vector2(h / b, (g + 1) / c), e.push(new THREE.Face3(a, d, k)), f.push([
        s,
        r,
        u
      ]), e.push(new THREE.Face3(d, l, k)), f.push([
        r.clone(),
        q,
        u.clone()
      ]);
  this.computeCentroids();
  this.computeFaceNormals();
  this.computeVertexNormals();
};
THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.AxisHelper = function (a) {
  a = a || 1;
  var b = new THREE.Geometry();
  b.vertices.push(new THREE.Vector3(), new THREE.Vector3(a, 0, 0), new THREE.Vector3(), new THREE.Vector3(0, a, 0), new THREE.Vector3(), new THREE.Vector3(0, 0, a));
  b.colors.push(new THREE.Color(16711680), new THREE.Color(16755200), new THREE.Color(65280), new THREE.Color(11206400), new THREE.Color(255), new THREE.Color(43775));
  a = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors });
  THREE.Line.call(this, b, a, THREE.LinePieces);
};
THREE.AxisHelper.prototype = Object.create(THREE.Line.prototype);
THREE.ArrowHelper = function (a, b, c, d, e, f) {
  THREE.Object3D.call(this);
  void 0 === d && (d = 16776960);
  void 0 === c && (c = 1);
  void 0 === e && (e = 0.2 * c);
  void 0 === f && (f = 0.2 * e);
  this.position = b;
  b = new THREE.Geometry();
  b.vertices.push(new THREE.Vector3(0, 0, 0));
  b.vertices.push(new THREE.Vector3(0, 1, 0));
  this.line = new THREE.Line(b, new THREE.LineBasicMaterial({ color: d }));
  this.line.matrixAutoUpdate = !1;
  this.add(this.line);
  b = new THREE.CylinderGeometry(0, 0.5, 1, 5, 1);
  b.applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.5, 0));
  this.cone = new THREE.Mesh(b, new THREE.MeshBasicMaterial({ color: d }));
  this.cone.matrixAutoUpdate = !1;
  this.add(this.cone);
  this.setDirection(a);
  this.setLength(c, e, f);
};
THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.ArrowHelper.prototype.setDirection = function () {
  var a = new THREE.Vector3(), b;
  return function (c) {
    0.99999 < c.y ? this.quaternion.set(0, 0, 0, 1) : -0.99999 > c.y ? this.quaternion.set(1, 0, 0, 0) : (a.set(c.z, 0, -c.x).normalize(), b = Math.acos(c.y), this.quaternion.setFromAxisAngle(a, b));
  };
}();
THREE.ArrowHelper.prototype.setLength = function (a, b, c) {
  void 0 === b && (b = 0.2 * a);
  void 0 === c && (c = 0.2 * b);
  this.line.scale.set(1, a, 1);
  this.line.updateMatrix();
  this.cone.scale.set(c, b, c);
  this.cone.position.y = a;
  this.cone.updateMatrix();
};
THREE.ArrowHelper.prototype.setColor = function (a) {
  this.line.material.color.setHex(a);
  this.cone.material.color.setHex(a);
};
THREE.BoxHelper = function (a) {
  var b = [
      new THREE.Vector3(1, 1, 1),
      new THREE.Vector3(-1, 1, 1),
      new THREE.Vector3(-1, -1, 1),
      new THREE.Vector3(1, -1, 1),
      new THREE.Vector3(1, 1, -1),
      new THREE.Vector3(-1, 1, -1),
      new THREE.Vector3(-1, -1, -1),
      new THREE.Vector3(1, -1, -1)
    ];
  this.vertices = b;
  var c = new THREE.Geometry();
  c.vertices.push(b[0], b[1], b[1], b[2], b[2], b[3], b[3], b[0], b[4], b[5], b[5], b[6], b[6], b[7], b[7], b[4], b[0], b[4], b[1], b[5], b[2], b[6], b[3], b[7]);
  THREE.Line.call(this, c, new THREE.LineBasicMaterial({ color: 16776960 }), THREE.LinePieces);
  void 0 !== a && this.update(a);
};
THREE.BoxHelper.prototype = Object.create(THREE.Line.prototype);
THREE.BoxHelper.prototype.update = function (a) {
  var b = a.geometry;
  null === b.boundingBox && b.computeBoundingBox();
  var c = b.boundingBox.min, b = b.boundingBox.max, d = this.vertices;
  d[0].set(b.x, b.y, b.z);
  d[1].set(c.x, b.y, b.z);
  d[2].set(c.x, c.y, b.z);
  d[3].set(b.x, c.y, b.z);
  d[4].set(b.x, b.y, c.z);
  d[5].set(c.x, b.y, c.z);
  d[6].set(c.x, c.y, c.z);
  d[7].set(b.x, c.y, c.z);
  this.geometry.computeBoundingSphere();
  this.geometry.verticesNeedUpdate = !0;
  this.matrixAutoUpdate = !1;
  this.matrixWorld = a.matrixWorld;
};
THREE.BoundingBoxHelper = function (a, b) {
  var c = void 0 !== b ? b : 8947848;
  this.object = a;
  this.box = new THREE.Box3();
  THREE.Mesh.call(this, new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({
    color: c,
    wireframe: !0
  }));
};
THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype);
THREE.BoundingBoxHelper.prototype.update = function () {
  this.box.setFromObject(this.object);
  this.box.size(this.scale);
  this.box.center(this.position);
};
THREE.CameraHelper = function (a) {
  function b(a, b, d) {
    c(a, d);
    c(b, d);
  }
  function c(a, b) {
    d.vertices.push(new THREE.Vector3());
    d.colors.push(new THREE.Color(b));
    void 0 === f[a] && (f[a] = []);
    f[a].push(d.vertices.length - 1);
  }
  var d = new THREE.Geometry(), e = new THREE.LineBasicMaterial({
      color: 16777215,
      vertexColors: THREE.FaceColors
    }), f = {};
  b('n1', 'n2', 16755200);
  b('n2', 'n4', 16755200);
  b('n4', 'n3', 16755200);
  b('n3', 'n1', 16755200);
  b('f1', 'f2', 16755200);
  b('f2', 'f4', 16755200);
  b('f4', 'f3', 16755200);
  b('f3', 'f1', 16755200);
  b('n1', 'f1', 16755200);
  b('n2', 'f2', 16755200);
  b('n3', 'f3', 16755200);
  b('n4', 'f4', 16755200);
  b('p', 'n1', 16711680);
  b('p', 'n2', 16711680);
  b('p', 'n3', 16711680);
  b('p', 'n4', 16711680);
  b('u1', 'u2', 43775);
  b('u2', 'u3', 43775);
  b('u3', 'u1', 43775);
  b('c', 't', 16777215);
  b('p', 'c', 3355443);
  b('cn1', 'cn2', 3355443);
  b('cn3', 'cn4', 3355443);
  b('cf1', 'cf2', 3355443);
  b('cf3', 'cf4', 3355443);
  THREE.Line.call(this, d, e, THREE.LinePieces);
  this.camera = a;
  this.matrixWorld = a.matrixWorld;
  this.matrixAutoUpdate = !1;
  this.pointMap = f;
  this.update();
};
THREE.CameraHelper.prototype = Object.create(THREE.Line.prototype);
THREE.CameraHelper.prototype.update = function () {
  var a = new THREE.Vector3(), b = new THREE.Camera(), c = new THREE.Projector();
  return function () {
    function d(d, g, h, k) {
      a.set(g, h, k);
      c.unprojectVector(a, b);
      d = e.pointMap[d];
      if (void 0 !== d)
        for (g = 0, h = d.length; g < h; g++)
          e.geometry.vertices[d[g]].copy(a);
    }
    var e = this;
    b.projectionMatrix.copy(this.camera.projectionMatrix);
    d('c', 0, 0, -1);
    d('t', 0, 0, 1);
    d('n1', -1, -1, -1);
    d('n2', 1, -1, -1);
    d('n3', -1, 1, -1);
    d('n4', 1, 1, -1);
    d('f1', -1, -1, 1);
    d('f2', 1, -1, 1);
    d('f3', -1, 1, 1);
    d('f4', 1, 1, 1);
    d('u1', 0.7, 1.1, -1);
    d('u2', -0.7, 1.1, -1);
    d('u3', 0, 2, -1);
    d('cf1', -1, 0, 1);
    d('cf2', 1, 0, 1);
    d('cf3', 0, -1, 1);
    d('cf4', 0, 1, 1);
    d('cn1', -1, 0, -1);
    d('cn2', 1, 0, -1);
    d('cn3', 0, -1, -1);
    d('cn4', 0, 1, -1);
    this.geometry.verticesNeedUpdate = !0;
  };
}();
THREE.DirectionalLightHelper = function (a, b) {
  THREE.Object3D.call(this);
  this.light = a;
  this.light.updateMatrixWorld();
  this.matrixWorld = a.matrixWorld;
  this.matrixAutoUpdate = !1;
  b = b || 1;
  var c = new THREE.PlaneGeometry(b, b), d = new THREE.MeshBasicMaterial({
      wireframe: !0,
      fog: !1
    });
  d.color.copy(this.light.color).multiplyScalar(this.light.intensity);
  this.lightPlane = new THREE.Mesh(c, d);
  this.add(this.lightPlane);
  c = new THREE.Geometry();
  c.vertices.push(new THREE.Vector3());
  c.vertices.push(new THREE.Vector3());
  d = new THREE.LineBasicMaterial({ fog: !1 });
  d.color.copy(this.light.color).multiplyScalar(this.light.intensity);
  this.targetLine = new THREE.Line(c, d);
  this.add(this.targetLine);
  this.update();
};
THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.DirectionalLightHelper.prototype.dispose = function () {
  this.lightPlane.geometry.dispose();
  this.lightPlane.material.dispose();
  this.targetLine.geometry.dispose();
  this.targetLine.material.dispose();
};
THREE.DirectionalLightHelper.prototype.update = function () {
  var a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Vector3();
  return function () {
    a.setFromMatrixPosition(this.light.matrixWorld);
    b.setFromMatrixPosition(this.light.target.matrixWorld);
    c.subVectors(b, a);
    this.lightPlane.lookAt(c);
    this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    this.targetLine.geometry.vertices[1].copy(c);
    this.targetLine.geometry.verticesNeedUpdate = !0;
    this.targetLine.material.color.copy(this.lightPlane.material.color);
  };
}();
THREE.EdgesHelper = function (a, b) {
  var c = void 0 !== b ? b : 16777215, d = [
      0,
      0
    ], e = {}, f = function (a, b) {
      return a - b;
    }, g = [
      'a',
      'b',
      'c'
    ], h = new THREE.BufferGeometry(), k = a.geometry.clone();
  k.mergeVertices();
  k.computeFaceNormals();
  for (var l = k.vertices, k = k.faces, n = 0, s = 0, r = k.length; s < r; s++)
    for (var q = k[s], u = 0; 3 > u; u++) {
      d[0] = q[g[u]];
      d[1] = q[g[(u + 1) % 3]];
      d.sort(f);
      var p = d.toString();
      void 0 === e[p] ? (e[p] = {
        vert1: d[0],
        vert2: d[1],
        face1: s,
        face2: void 0
      }, n++) : e[p].face2 = s;
    }
  h.addAttribute('position', Float32Array, 2 * n, 3);
  d = h.attributes.position.array;
  f = 0;
  for (p in e)
    if (g = e[p], void 0 === g.face2 || 0.9999 > k[g.face1].normal.dot(k[g.face2].normal))
      n = l[g.vert1], d[f++] = n.x, d[f++] = n.y, d[f++] = n.z, n = l[g.vert2], d[f++] = n.x, d[f++] = n.y, d[f++] = n.z;
  THREE.Line.call(this, h, new THREE.LineBasicMaterial({ color: c }), THREE.LinePieces);
  this.matrixAutoUpdate = !1;
  this.matrixWorld = a.matrixWorld;
};
THREE.EdgesHelper.prototype = Object.create(THREE.Line.prototype);
THREE.FaceNormalsHelper = function (a, b, c, d) {
  this.object = a;
  this.size = void 0 !== b ? b : 1;
  a = void 0 !== c ? c : 16776960;
  d = void 0 !== d ? d : 1;
  b = new THREE.Geometry();
  c = 0;
  for (var e = this.object.geometry.faces.length; c < e; c++)
    b.vertices.push(new THREE.Vector3()), b.vertices.push(new THREE.Vector3());
  THREE.Line.call(this, b, new THREE.LineBasicMaterial({
    color: a,
    linewidth: d
  }), THREE.LinePieces);
  this.matrixAutoUpdate = !1;
  this.normalMatrix = new THREE.Matrix3();
  this.update();
};
THREE.FaceNormalsHelper.prototype = Object.create(THREE.Line.prototype);
THREE.FaceNormalsHelper.prototype.update = function (a) {
  var b = new THREE.Vector3();
  return function (a) {
    this.object.updateMatrixWorld(!0);
    this.normalMatrix.getNormalMatrix(this.object.matrixWorld);
    a = this.geometry.vertices;
    for (var d = this.object.geometry.faces, e = this.object.matrixWorld, f = 0, g = d.length; f < g; f++) {
      var h = d[f];
      b.copy(h.normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);
      var k = 2 * f;
      a[k].copy(h.centroid).applyMatrix4(e);
      a[k + 1].addVectors(a[k], b);
    }
    this.geometry.verticesNeedUpdate = !0;
    return this;
  };
}();
THREE.GridHelper = function (a, b) {
  var c = new THREE.Geometry(), d = new THREE.LineBasicMaterial({ vertexColors: THREE.VertexColors });
  this.color1 = new THREE.Color(4473924);
  this.color2 = new THREE.Color(8947848);
  for (var e = -a; e <= a; e += b) {
    c.vertices.push(new THREE.Vector3(-a, 0, e), new THREE.Vector3(a, 0, e), new THREE.Vector3(e, 0, -a), new THREE.Vector3(e, 0, a));
    var f = 0 === e ? this.color1 : this.color2;
    c.colors.push(f, f, f, f);
  }
  THREE.Line.call(this, c, d, THREE.LinePieces);
};
THREE.GridHelper.prototype = Object.create(THREE.Line.prototype);
THREE.GridHelper.prototype.setColors = function (a, b) {
  this.color1.set(a);
  this.color2.set(b);
  this.geometry.colorsNeedUpdate = !0;
};
THREE.HemisphereLightHelper = function (a, b, c, d) {
  THREE.Object3D.call(this);
  this.light = a;
  this.light.updateMatrixWorld();
  this.matrixWorld = a.matrixWorld;
  this.matrixAutoUpdate = !1;
  this.colors = [
    new THREE.Color(),
    new THREE.Color()
  ];
  a = new THREE.SphereGeometry(b, 4, 2);
  a.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
  for (b = 0; 8 > b; b++)
    a.faces[b].color = this.colors[4 > b ? 0 : 1];
  b = new THREE.MeshBasicMaterial({
    vertexColors: THREE.FaceColors,
    wireframe: !0
  });
  this.lightSphere = new THREE.Mesh(a, b);
  this.add(this.lightSphere);
  this.update();
};
THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.HemisphereLightHelper.prototype.dispose = function () {
  this.lightSphere.geometry.dispose();
  this.lightSphere.material.dispose();
};
THREE.HemisphereLightHelper.prototype.update = function () {
  var a = new THREE.Vector3();
  return function () {
    this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity);
    this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity);
    this.lightSphere.lookAt(a.setFromMatrixPosition(this.light.matrixWorld).negate());
    this.lightSphere.geometry.colorsNeedUpdate = !0;
  };
}();
THREE.PointLightHelper = function (a, b) {
  this.light = a;
  this.light.updateMatrixWorld();
  var c = new THREE.SphereGeometry(b, 4, 2), d = new THREE.MeshBasicMaterial({
      wireframe: !0,
      fog: !1
    });
  d.color.copy(this.light.color).multiplyScalar(this.light.intensity);
  THREE.Mesh.call(this, c, d);
  this.matrixWorld = this.light.matrixWorld;
  this.matrixAutoUpdate = !1;
};
THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype);
THREE.PointLightHelper.prototype.dispose = function () {
  this.geometry.dispose();
  this.material.dispose();
};
THREE.PointLightHelper.prototype.update = function () {
  this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
};
THREE.SpotLightHelper = function (a) {
  THREE.Object3D.call(this);
  this.light = a;
  this.light.updateMatrixWorld();
  this.matrixWorld = a.matrixWorld;
  this.matrixAutoUpdate = !1;
  a = new THREE.CylinderGeometry(0, 1, 1, 8, 1, !0);
  a.applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.5, 0));
  a.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
  var b = new THREE.MeshBasicMaterial({
      wireframe: !0,
      fog: !1
    });
  this.cone = new THREE.Mesh(a, b);
  this.add(this.cone);
  this.update();
};
THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.SpotLightHelper.prototype.dispose = function () {
  this.cone.geometry.dispose();
  this.cone.material.dispose();
};
THREE.SpotLightHelper.prototype.update = function () {
  var a = new THREE.Vector3(), b = new THREE.Vector3();
  return function () {
    var c = this.light.distance ? this.light.distance : 10000, d = c * Math.tan(this.light.angle);
    this.cone.scale.set(d, d, c);
    a.setFromMatrixPosition(this.light.matrixWorld);
    b.setFromMatrixPosition(this.light.target.matrixWorld);
    this.cone.lookAt(b.sub(a));
    this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
  };
}();
THREE.VertexNormalsHelper = function (a, b, c, d) {
  this.object = a;
  this.size = void 0 !== b ? b : 1;
  b = void 0 !== c ? c : 16711680;
  d = void 0 !== d ? d : 1;
  c = new THREE.Geometry();
  a = a.geometry.faces;
  for (var e = 0, f = a.length; e < f; e++)
    for (var g = 0, h = a[e].vertexNormals.length; g < h; g++)
      c.vertices.push(new THREE.Vector3()), c.vertices.push(new THREE.Vector3());
  THREE.Line.call(this, c, new THREE.LineBasicMaterial({
    color: b,
    linewidth: d
  }), THREE.LinePieces);
  this.matrixAutoUpdate = !1;
  this.normalMatrix = new THREE.Matrix3();
  this.update();
};
THREE.VertexNormalsHelper.prototype = Object.create(THREE.Line.prototype);
THREE.VertexNormalsHelper.prototype.update = function (a) {
  var b = new THREE.Vector3();
  return function (a) {
    a = [
      'a',
      'b',
      'c',
      'd'
    ];
    this.object.updateMatrixWorld(!0);
    this.normalMatrix.getNormalMatrix(this.object.matrixWorld);
    for (var d = this.geometry.vertices, e = this.object.geometry.vertices, f = this.object.geometry.faces, g = this.object.matrixWorld, h = 0, k = 0, l = f.length; k < l; k++)
      for (var n = f[k], s = 0, r = n.vertexNormals.length; s < r; s++) {
        var q = n.vertexNormals[s];
        d[h].copy(e[n[a[s]]]).applyMatrix4(g);
        b.copy(q).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);
        b.add(d[h]);
        h += 1;
        d[h].copy(b);
        h += 1;
      }
    this.geometry.verticesNeedUpdate = !0;
    return this;
  };
}();
THREE.VertexTangentsHelper = function (a, b, c, d) {
  this.object = a;
  this.size = void 0 !== b ? b : 1;
  b = void 0 !== c ? c : 255;
  d = void 0 !== d ? d : 1;
  c = new THREE.Geometry();
  a = a.geometry.faces;
  for (var e = 0, f = a.length; e < f; e++)
    for (var g = 0, h = a[e].vertexTangents.length; g < h; g++)
      c.vertices.push(new THREE.Vector3()), c.vertices.push(new THREE.Vector3());
  THREE.Line.call(this, c, new THREE.LineBasicMaterial({
    color: b,
    linewidth: d
  }), THREE.LinePieces);
  this.matrixAutoUpdate = !1;
  this.update();
};
THREE.VertexTangentsHelper.prototype = Object.create(THREE.Line.prototype);
THREE.VertexTangentsHelper.prototype.update = function (a) {
  var b = new THREE.Vector3();
  return function (a) {
    a = [
      'a',
      'b',
      'c',
      'd'
    ];
    this.object.updateMatrixWorld(!0);
    for (var d = this.geometry.vertices, e = this.object.geometry.vertices, f = this.object.geometry.faces, g = this.object.matrixWorld, h = 0, k = 0, l = f.length; k < l; k++)
      for (var n = f[k], s = 0, r = n.vertexTangents.length; s < r; s++) {
        var q = n.vertexTangents[s];
        d[h].copy(e[n[a[s]]]).applyMatrix4(g);
        b.copy(q).transformDirection(g).multiplyScalar(this.size);
        b.add(d[h]);
        h += 1;
        d[h].copy(b);
        h += 1;
      }
    this.geometry.verticesNeedUpdate = !0;
    return this;
  };
}();
THREE.WireframeHelper = function (a, b) {
  var c = void 0 !== b ? b : 16777215, d = [
      0,
      0
    ], e = {}, f = function (a, b) {
      return a - b;
    }, g = [
      'a',
      'b',
      'c'
    ], h = new THREE.BufferGeometry();
  if (a.geometry instanceof THREE.Geometry) {
    for (var k = a.geometry.vertices, l = a.geometry.faces, n = 0, s = new Uint32Array(6 * l.length), r = 0, q = l.length; r < q; r++)
      for (var u = l[r], p = 0; 3 > p; p++) {
        d[0] = u[g[p]];
        d[1] = u[g[(p + 1) % 3]];
        d.sort(f);
        var v = d.toString();
        void 0 === e[v] && (s[2 * n] = d[0], s[2 * n + 1] = d[1], e[v] = !0, n++);
      }
    h.addAttribute('position', Float32Array, 2 * n, 3);
    d = h.attributes.position.array;
    r = 0;
    for (q = n; r < q; r++)
      for (p = 0; 2 > p; p++)
        n = k[s[2 * r + p]], g = 6 * r + 3 * p, d[g + 0] = n.x, d[g + 1] = n.y, d[g + 2] = n.z;
  } else if (a.geometry instanceof THREE.BufferGeometry && void 0 !== a.geometry.attributes.index) {
    for (var k = a.geometry.attributes.position.array, q = a.geometry.attributes.index.array, l = a.geometry.offsets, n = 0, s = new Uint32Array(2 * q.length), u = 0, w = l.length; u < w; ++u)
      for (var p = l[u].start, v = l[u].count, g = l[u].index, r = p, t = p + v; r < t; r += 3)
        for (p = 0; 3 > p; p++)
          d[0] = g + q[r + p], d[1] = g + q[r + (p + 1) % 3], d.sort(f), v = d.toString(), void 0 === e[v] && (s[2 * n] = d[0], s[2 * n + 1] = d[1], e[v] = !0, n++);
    h.addAttribute('position', Float32Array, 2 * n, 3);
    d = h.attributes.position.array;
    r = 0;
    for (q = n; r < q; r++)
      for (p = 0; 2 > p; p++)
        g = 6 * r + 3 * p, n = 3 * s[2 * r + p], d[g + 0] = k[n], d[g + 1] = k[n + 1], d[g + 2] = k[n + 2];
  } else if (a.geometry instanceof THREE.BufferGeometry)
    for (k = a.geometry.attributes.position.array, n = k.length / 3, s = n / 3, h.addAttribute('position', Float32Array, 2 * n, 3), d = h.attributes.position.array, r = 0, q = s; r < q; r++)
      for (p = 0; 3 > p; p++)
        g = 18 * r + 6 * p, s = 9 * r + 3 * p, d[g + 0] = k[s], d[g + 1] = k[s + 1], d[g + 2] = k[s + 2], n = 9 * r + (p + 1) % 3 * 3, d[g + 3] = k[n], d[g + 4] = k[n + 1], d[g + 5] = k[n + 2];
  THREE.Line.call(this, h, new THREE.LineBasicMaterial({ color: c }), THREE.LinePieces);
  this.matrixAutoUpdate = !1;
  this.matrixWorld = a.matrixWorld;
};
THREE.WireframeHelper.prototype = Object.create(THREE.Line.prototype);
THREE.ImmediateRenderObject = function () {
  THREE.Object3D.call(this);
  this.render = function (a) {
  };
};
THREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype);
THREE.LensFlare = function (a, b, c, d, e) {
  THREE.Object3D.call(this);
  this.lensFlares = [];
  this.positionScreen = new THREE.Vector3();
  this.customUpdateCallback = void 0;
  void 0 !== a && this.add(a, b, c, d, e);
};
THREE.LensFlare.prototype = Object.create(THREE.Object3D.prototype);
THREE.LensFlare.prototype.add = function (a, b, c, d, e, f) {
  void 0 === b && (b = -1);
  void 0 === c && (c = 0);
  void 0 === f && (f = 1);
  void 0 === e && (e = new THREE.Color(16777215));
  void 0 === d && (d = THREE.NormalBlending);
  c = Math.min(c, Math.max(0, c));
  this.lensFlares.push({
    texture: a,
    size: b,
    distance: c,
    x: 0,
    y: 0,
    z: 0,
    scale: 1,
    rotation: 1,
    opacity: f,
    color: e,
    blending: d
  });
};
THREE.LensFlare.prototype.updateLensFlares = function () {
  var a, b = this.lensFlares.length, c, d = 2 * -this.positionScreen.x, e = 2 * -this.positionScreen.y;
  for (a = 0; a < b; a++)
    c = this.lensFlares[a], c.x = this.positionScreen.x + d * c.distance, c.y = this.positionScreen.y + e * c.distance, c.wantedRotation = c.x * Math.PI * 0.25, c.rotation += 0.25 * (c.wantedRotation - c.rotation);
};
THREE.MorphBlendMesh = function (a, b) {
  THREE.Mesh.call(this, a, b);
  this.animationsMap = {};
  this.animationsList = [];
  var c = this.geometry.morphTargets.length;
  this.createAnimation('__default', 0, c - 1, c / 1);
  this.setAnimationWeight('__default', 1);
};
THREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype);
THREE.MorphBlendMesh.prototype.createAnimation = function (a, b, c, d) {
  b = {
    startFrame: b,
    endFrame: c,
    length: c - b + 1,
    fps: d,
    duration: (c - b) / d,
    lastFrame: 0,
    currentFrame: 0,
    active: !1,
    time: 0,
    direction: 1,
    weight: 1,
    directionBackwards: !1,
    mirroredLoop: !1
  };
  this.animationsMap[a] = b;
  this.animationsList.push(b);
};
THREE.MorphBlendMesh.prototype.autoCreateAnimations = function (a) {
  for (var b = /([a-z]+)(\d+)/, c, d = {}, e = this.geometry, f = 0, g = e.morphTargets.length; f < g; f++) {
    var h = e.morphTargets[f].name.match(b);
    if (h && 1 < h.length) {
      var k = h[1];
      d[k] || (d[k] = {
        start: Infinity,
        end: -Infinity
      });
      h = d[k];
      f < h.start && (h.start = f);
      f > h.end && (h.end = f);
      c || (c = k);
    }
  }
  for (k in d)
    h = d[k], this.createAnimation(k, h.start, h.end, a);
  this.firstAnimation = c;
};
THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function (a) {
  if (a = this.animationsMap[a])
    a.direction = 1, a.directionBackwards = !1;
};
THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function (a) {
  if (a = this.animationsMap[a])
    a.direction = -1, a.directionBackwards = !0;
};
THREE.MorphBlendMesh.prototype.setAnimationFPS = function (a, b) {
  var c = this.animationsMap[a];
  c && (c.fps = b, c.duration = (c.end - c.start) / c.fps);
};
THREE.MorphBlendMesh.prototype.setAnimationDuration = function (a, b) {
  var c = this.animationsMap[a];
  c && (c.duration = b, c.fps = (c.end - c.start) / c.duration);
};
THREE.MorphBlendMesh.prototype.setAnimationWeight = function (a, b) {
  var c = this.animationsMap[a];
  c && (c.weight = b);
};
THREE.MorphBlendMesh.prototype.setAnimationTime = function (a, b) {
  var c = this.animationsMap[a];
  c && (c.time = b);
};
THREE.MorphBlendMesh.prototype.getAnimationTime = function (a) {
  var b = 0;
  if (a = this.animationsMap[a])
    b = a.time;
  return b;
};
THREE.MorphBlendMesh.prototype.getAnimationDuration = function (a) {
  var b = -1;
  if (a = this.animationsMap[a])
    b = a.duration;
  return b;
};
THREE.MorphBlendMesh.prototype.playAnimation = function (a) {
  var b = this.animationsMap[a];
  b ? (b.time = 0, b.active = !0) : console.warn('animation[' + a + '] undefined');
};
THREE.MorphBlendMesh.prototype.stopAnimation = function (a) {
  if (a = this.animationsMap[a])
    a.active = !1;
};
THREE.MorphBlendMesh.prototype.update = function (a) {
  for (var b = 0, c = this.animationsList.length; b < c; b++) {
    var d = this.animationsList[b];
    if (d.active) {
      var e = d.duration / d.length;
      d.time += d.direction * a;
      if (d.mirroredLoop) {
        if (d.time > d.duration || 0 > d.time)
          d.direction *= -1, d.time > d.duration && (d.time = d.duration, d.directionBackwards = !0), 0 > d.time && (d.time = 0, d.directionBackwards = !1);
      } else
        d.time %= d.duration, 0 > d.time && (d.time += d.duration);
      var f = d.startFrame + THREE.Math.clamp(Math.floor(d.time / e), 0, d.length - 1), g = d.weight;
      f !== d.currentFrame && (this.morphTargetInfluences[d.lastFrame] = 0, this.morphTargetInfluences[d.currentFrame] = 1 * g, this.morphTargetInfluences[f] = 0, d.lastFrame = d.currentFrame, d.currentFrame = f);
      e = d.time % e / e;
      d.directionBackwards && (e = 1 - e);
      this.morphTargetInfluences[d.currentFrame] = e * g;
      this.morphTargetInfluences[d.lastFrame] = (1 - e) * g;
    }
  }
};
THREE.LensFlarePlugin = function () {
  function a(a, c) {
    var d = b.createProgram(), e = b.createShader(b.FRAGMENT_SHADER), f = b.createShader(b.VERTEX_SHADER), g = 'precision ' + c + ' float;\n';
    b.shaderSource(e, g + a.fragmentShader);
    b.shaderSource(f, g + a.vertexShader);
    b.compileShader(e);
    b.compileShader(f);
    b.attachShader(d, e);
    b.attachShader(d, f);
    b.linkProgram(d);
    return d;
  }
  var b, c, d, e, f, g, h, k, l, n, s, r, q;
  this.init = function (u) {
    b = u.context;
    c = u;
    d = u.getPrecision();
    e = new Float32Array(16);
    f = new Uint16Array(6);
    u = 0;
    e[u++] = -1;
    e[u++] = -1;
    e[u++] = 0;
    e[u++] = 0;
    e[u++] = 1;
    e[u++] = -1;
    e[u++] = 1;
    e[u++] = 0;
    e[u++] = 1;
    e[u++] = 1;
    e[u++] = 1;
    e[u++] = 1;
    e[u++] = -1;
    e[u++] = 1;
    e[u++] = 0;
    e[u++] = 1;
    u = 0;
    f[u++] = 0;
    f[u++] = 1;
    f[u++] = 2;
    f[u++] = 0;
    f[u++] = 2;
    f[u++] = 3;
    g = b.createBuffer();
    h = b.createBuffer();
    b.bindBuffer(b.ARRAY_BUFFER, g);
    b.bufferData(b.ARRAY_BUFFER, e, b.STATIC_DRAW);
    b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, h);
    b.bufferData(b.ELEMENT_ARRAY_BUFFER, f, b.STATIC_DRAW);
    k = b.createTexture();
    l = b.createTexture();
    b.bindTexture(b.TEXTURE_2D, k);
    b.texImage2D(b.TEXTURE_2D, 0, b.RGB, 16, 16, 0, b.RGB, b.UNSIGNED_BYTE, null);
    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE);
    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE);
    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.NEAREST);
    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.NEAREST);
    b.bindTexture(b.TEXTURE_2D, l);
    b.texImage2D(b.TEXTURE_2D, 0, b.RGBA, 16, 16, 0, b.RGBA, b.UNSIGNED_BYTE, null);
    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE);
    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE);
    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.NEAREST);
    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.NEAREST);
    0 >= b.getParameter(b.MAX_VERTEX_TEXTURE_IMAGE_UNITS) ? (n = !1, s = a(THREE.ShaderFlares.lensFlare, d)) : (n = !0, s = a(THREE.ShaderFlares.lensFlareVertexTexture, d));
    r = {};
    q = {};
    r.vertex = b.getAttribLocation(s, 'position');
    r.uv = b.getAttribLocation(s, 'uv');
    q.renderType = b.getUniformLocation(s, 'renderType');
    q.map = b.getUniformLocation(s, 'map');
    q.occlusionMap = b.getUniformLocation(s, 'occlusionMap');
    q.opacity = b.getUniformLocation(s, 'opacity');
    q.color = b.getUniformLocation(s, 'color');
    q.scale = b.getUniformLocation(s, 'scale');
    q.rotation = b.getUniformLocation(s, 'rotation');
    q.screenPosition = b.getUniformLocation(s, 'screenPosition');
  };
  this.render = function (a, d, e, f) {
    a = a.__webglFlares;
    var t = a.length;
    if (t) {
      var x = new THREE.Vector3(), z = f / e, B = 0.5 * e, E = 0.5 * f, H = 16 / f, D = new THREE.Vector2(H * z, H), G = new THREE.Vector3(1, 1, 0), I = new THREE.Vector2(1, 1), O = q, H = r;
      b.useProgram(s);
      b.enableVertexAttribArray(r.vertex);
      b.enableVertexAttribArray(r.uv);
      b.uniform1i(O.occlusionMap, 0);
      b.uniform1i(O.map, 1);
      b.bindBuffer(b.ARRAY_BUFFER, g);
      b.vertexAttribPointer(H.vertex, 2, b.FLOAT, !1, 16, 0);
      b.vertexAttribPointer(H.uv, 2, b.FLOAT, !1, 16, 8);
      b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, h);
      b.disable(b.CULL_FACE);
      b.depthMask(!1);
      var K, y, F, C, A;
      for (K = 0; K < t; K++)
        if (H = 16 / f, D.set(H * z, H), C = a[K], x.set(C.matrixWorld.elements[12], C.matrixWorld.elements[13], C.matrixWorld.elements[14]), x.applyMatrix4(d.matrixWorldInverse), x.applyProjection(d.projectionMatrix), G.copy(x), I.x = G.x * B + B, I.y = G.y * E + E, n || 0 < I.x && I.x < e && 0 < I.y && I.y < f)
          for (b.activeTexture(b.TEXTURE1), b.bindTexture(b.TEXTURE_2D, k), b.copyTexImage2D(b.TEXTURE_2D, 0, b.RGB, I.x - 8, I.y - 8, 16, 16, 0), b.uniform1i(O.renderType, 0), b.uniform2f(O.scale, D.x, D.y), b.uniform3f(O.screenPosition, G.x, G.y, G.z), b.disable(b.BLEND), b.enable(b.DEPTH_TEST), b.drawElements(b.TRIANGLES, 6, b.UNSIGNED_SHORT, 0), b.activeTexture(b.TEXTURE0), b.bindTexture(b.TEXTURE_2D, l), b.copyTexImage2D(b.TEXTURE_2D, 0, b.RGBA, I.x - 8, I.y - 8, 16, 16, 0), b.uniform1i(O.renderType, 1), b.disable(b.DEPTH_TEST), b.activeTexture(b.TEXTURE1), b.bindTexture(b.TEXTURE_2D, k), b.drawElements(b.TRIANGLES, 6, b.UNSIGNED_SHORT, 0), C.positionScreen.copy(G), C.customUpdateCallback ? C.customUpdateCallback(C) : C.updateLensFlares(), b.uniform1i(O.renderType, 2), b.enable(b.BLEND), y = 0, F = C.lensFlares.length; y < F; y++)
            A = C.lensFlares[y], 0.001 < A.opacity && 0.001 < A.scale && (G.x = A.x, G.y = A.y, G.z = A.z, H = A.size * A.scale / f, D.x = H * z, D.y = H, b.uniform3f(O.screenPosition, G.x, G.y, G.z), b.uniform2f(O.scale, D.x, D.y), b.uniform1f(O.rotation, A.rotation), b.uniform1f(O.opacity, A.opacity), b.uniform3f(O.color, A.color.r, A.color.g, A.color.b), c.setBlending(A.blending, A.blendEquation, A.blendSrc, A.blendDst), c.setTexture(A.texture, 1), b.drawElements(b.TRIANGLES, 6, b.UNSIGNED_SHORT, 0));
      b.enable(b.CULL_FACE);
      b.enable(b.DEPTH_TEST);
      b.depthMask(!0);
    }
  };
};
THREE.ShadowMapPlugin = function () {
  var a, b, c, d, e, f, g = new THREE.Frustum(), h = new THREE.Matrix4(), k = new THREE.Vector3(), l = new THREE.Vector3(), n = new THREE.Vector3();
  this.init = function (g) {
    a = g.context;
    b = g;
    g = THREE.ShaderLib.depthRGBA;
    var h = THREE.UniformsUtils.clone(g.uniforms);
    c = new THREE.ShaderMaterial({
      fragmentShader: g.fragmentShader,
      vertexShader: g.vertexShader,
      uniforms: h
    });
    d = new THREE.ShaderMaterial({
      fragmentShader: g.fragmentShader,
      vertexShader: g.vertexShader,
      uniforms: h,
      morphTargets: !0
    });
    e = new THREE.ShaderMaterial({
      fragmentShader: g.fragmentShader,
      vertexShader: g.vertexShader,
      uniforms: h,
      skinning: !0
    });
    f = new THREE.ShaderMaterial({
      fragmentShader: g.fragmentShader,
      vertexShader: g.vertexShader,
      uniforms: h,
      morphTargets: !0,
      skinning: !0
    });
    c._shadowPass = !0;
    d._shadowPass = !0;
    e._shadowPass = !0;
    f._shadowPass = !0;
  };
  this.render = function (a, c) {
    b.shadowMapEnabled && b.shadowMapAutoUpdate && this.update(a, c);
  };
  this.update = function (s, r) {
    var q, u, p, v, w, t, x, z, B, E = [];
    v = 0;
    a.clearColor(1, 1, 1, 1);
    a.disable(a.BLEND);
    a.enable(a.CULL_FACE);
    a.frontFace(a.CCW);
    b.shadowMapCullFace === THREE.CullFaceFront ? a.cullFace(a.FRONT) : a.cullFace(a.BACK);
    b.setDepthTest(!0);
    q = 0;
    for (u = s.__lights.length; q < u; q++)
      if (p = s.__lights[q], p.castShadow)
        if (p instanceof THREE.DirectionalLight && p.shadowCascade)
          for (w = 0; w < p.shadowCascadeCount; w++) {
            var H;
            if (p.shadowCascadeArray[w])
              H = p.shadowCascadeArray[w];
            else {
              B = p;
              x = w;
              H = new THREE.DirectionalLight();
              H.isVirtual = !0;
              H.onlyShadow = !0;
              H.castShadow = !0;
              H.shadowCameraNear = B.shadowCameraNear;
              H.shadowCameraFar = B.shadowCameraFar;
              H.shadowCameraLeft = B.shadowCameraLeft;
              H.shadowCameraRight = B.shadowCameraRight;
              H.shadowCameraBottom = B.shadowCameraBottom;
              H.shadowCameraTop = B.shadowCameraTop;
              H.shadowCameraVisible = B.shadowCameraVisible;
              H.shadowDarkness = B.shadowDarkness;
              H.shadowBias = B.shadowCascadeBias[x];
              H.shadowMapWidth = B.shadowCascadeWidth[x];
              H.shadowMapHeight = B.shadowCascadeHeight[x];
              H.pointsWorld = [];
              H.pointsFrustum = [];
              z = H.pointsWorld;
              t = H.pointsFrustum;
              for (var D = 0; 8 > D; D++)
                z[D] = new THREE.Vector3(), t[D] = new THREE.Vector3();
              z = B.shadowCascadeNearZ[x];
              B = B.shadowCascadeFarZ[x];
              t[0].set(-1, -1, z);
              t[1].set(1, -1, z);
              t[2].set(-1, 1, z);
              t[3].set(1, 1, z);
              t[4].set(-1, -1, B);
              t[5].set(1, -1, B);
              t[6].set(-1, 1, B);
              t[7].set(1, 1, B);
              H.originalCamera = r;
              t = new THREE.Gyroscope();
              t.position = p.shadowCascadeOffset;
              t.add(H);
              t.add(H.target);
              r.add(t);
              p.shadowCascadeArray[w] = H;
              console.log('Created virtualLight', H);
            }
            x = p;
            z = w;
            B = x.shadowCascadeArray[z];
            B.position.copy(x.position);
            B.target.position.copy(x.target.position);
            B.lookAt(B.target);
            B.shadowCameraVisible = x.shadowCameraVisible;
            B.shadowDarkness = x.shadowDarkness;
            B.shadowBias = x.shadowCascadeBias[z];
            t = x.shadowCascadeNearZ[z];
            x = x.shadowCascadeFarZ[z];
            B = B.pointsFrustum;
            B[0].z = t;
            B[1].z = t;
            B[2].z = t;
            B[3].z = t;
            B[4].z = x;
            B[5].z = x;
            B[6].z = x;
            B[7].z = x;
            E[v] = H;
            v++;
          }
        else
          E[v] = p, v++;
    q = 0;
    for (u = E.length; q < u; q++) {
      p = E[q];
      p.shadowMap || (w = THREE.LinearFilter, b.shadowMapType === THREE.PCFSoftShadowMap && (w = THREE.NearestFilter), p.shadowMap = new THREE.WebGLRenderTarget(p.shadowMapWidth, p.shadowMapHeight, {
        minFilter: w,
        magFilter: w,
        format: THREE.RGBAFormat
      }), p.shadowMapSize = new THREE.Vector2(p.shadowMapWidth, p.shadowMapHeight), p.shadowMatrix = new THREE.Matrix4());
      if (!p.shadowCamera) {
        if (p instanceof THREE.SpotLight)
          p.shadowCamera = new THREE.PerspectiveCamera(p.shadowCameraFov, p.shadowMapWidth / p.shadowMapHeight, p.shadowCameraNear, p.shadowCameraFar);
        else if (p instanceof THREE.DirectionalLight)
          p.shadowCamera = new THREE.OrthographicCamera(p.shadowCameraLeft, p.shadowCameraRight, p.shadowCameraTop, p.shadowCameraBottom, p.shadowCameraNear, p.shadowCameraFar);
        else {
          console.error('Unsupported light type for shadow');
          continue;
        }
        s.add(p.shadowCamera);
        !0 === s.autoUpdate && s.updateMatrixWorld();
      }
      p.shadowCameraVisible && !p.cameraHelper && (p.cameraHelper = new THREE.CameraHelper(p.shadowCamera), p.shadowCamera.add(p.cameraHelper));
      if (p.isVirtual && H.originalCamera == r) {
        w = r;
        v = p.shadowCamera;
        t = p.pointsFrustum;
        B = p.pointsWorld;
        k.set(Infinity, Infinity, Infinity);
        l.set(-Infinity, -Infinity, -Infinity);
        for (x = 0; 8 > x; x++)
          z = B[x], z.copy(t[x]), THREE.ShadowMapPlugin.__projector.unprojectVector(z, w), z.applyMatrix4(v.matrixWorldInverse), z.x < k.x && (k.x = z.x), z.x > l.x && (l.x = z.x), z.y < k.y && (k.y = z.y), z.y > l.y && (l.y = z.y), z.z < k.z && (k.z = z.z), z.z > l.z && (l.z = z.z);
        v.left = k.x;
        v.right = l.x;
        v.top = l.y;
        v.bottom = k.y;
        v.updateProjectionMatrix();
      }
      v = p.shadowMap;
      t = p.shadowMatrix;
      w = p.shadowCamera;
      w.position.setFromMatrixPosition(p.matrixWorld);
      n.setFromMatrixPosition(p.target.matrixWorld);
      w.lookAt(n);
      w.updateMatrixWorld();
      w.matrixWorldInverse.getInverse(w.matrixWorld);
      p.cameraHelper && (p.cameraHelper.visible = p.shadowCameraVisible);
      p.shadowCameraVisible && p.cameraHelper.update();
      t.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
      t.multiply(w.projectionMatrix);
      t.multiply(w.matrixWorldInverse);
      h.multiplyMatrices(w.projectionMatrix, w.matrixWorldInverse);
      g.setFromMatrix(h);
      b.setRenderTarget(v);
      b.clear();
      B = s.__webglObjects;
      p = 0;
      for (v = B.length; p < v; p++)
        x = B[p], t = x.object, x.render = !1, !t.visible || !t.castShadow || (t instanceof THREE.Mesh || t instanceof THREE.ParticleSystem) && t.frustumCulled && !g.intersectsObject(t) || (t._modelViewMatrix.multiplyMatrices(w.matrixWorldInverse, t.matrixWorld), x.render = !0);
      p = 0;
      for (v = B.length; p < v; p++)
        x = B[p], x.render && (t = x.object, x = x.buffer, D = t.material instanceof THREE.MeshFaceMaterial ? t.material.materials[0] : t.material, z = void 0 !== t.geometry.morphTargets && 0 < t.geometry.morphTargets.length && D.morphTargets, D = t instanceof THREE.SkinnedMesh && D.skinning, z = t.customDepthMaterial ? t.customDepthMaterial : D ? z ? f : e : z ? d : c, x instanceof THREE.BufferGeometry ? b.renderBufferDirect(w, s.__lights, null, z, x, t) : b.renderBuffer(w, s.__lights, null, z, x, t));
      B = s.__webglObjectsImmediate;
      p = 0;
      for (v = B.length; p < v; p++)
        x = B[p], t = x.object, t.visible && t.castShadow && (t._modelViewMatrix.multiplyMatrices(w.matrixWorldInverse, t.matrixWorld), b.renderImmediateObject(w, s.__lights, null, c, t));
    }
    q = b.getClearColor();
    u = b.getClearAlpha();
    a.clearColor(q.r, q.g, q.b, u);
    a.enable(a.BLEND);
    b.shadowMapCullFace === THREE.CullFaceFront && a.cullFace(a.BACK);
  };
};
THREE.ShadowMapPlugin.__projector = new THREE.Projector();
THREE.SpritePlugin = function () {
  var a, b, c, d, e, f, g, h, k, l, n, s, r, q, u, p, v;
  function w(a, b) {
    return a.z !== b.z ? b.z - a.z : b.id - a.id;
  }
  var t, x, z, B, E, H, D, G;
  this.init = function (w) {
    t = w.context;
    x = w;
    B = new Float32Array([
      -0.5,
      -0.5,
      0,
      0,
      0.5,
      -0.5,
      1,
      0,
      0.5,
      0.5,
      1,
      1,
      -0.5,
      0.5,
      0,
      1
    ]);
    E = new Uint16Array([
      0,
      1,
      2,
      0,
      2,
      3
    ]);
    H = t.createBuffer();
    D = t.createBuffer();
    t.bindBuffer(t.ARRAY_BUFFER, H);
    t.bufferData(t.ARRAY_BUFFER, B, t.STATIC_DRAW);
    t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, D);
    t.bufferData(t.ELEMENT_ARRAY_BUFFER, E, t.STATIC_DRAW);
    w = t.createProgram();
    var O = t.createShader(t.VERTEX_SHADER), K = t.createShader(t.FRAGMENT_SHADER);
    t.shaderSource(O, [
      'precision ' + x.getPrecision() + ' float;',
      'uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 scale;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uvOffset + uv * uvScale;\nvec2 alignedPosition = position * scale;\nvec2 rotatedPosition;\nrotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\nrotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\nvec4 finalPosition;\nfinalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\nfinalPosition.xy += rotatedPosition;\nfinalPosition = projectionMatrix * finalPosition;\ngl_Position = finalPosition;\n}'
    ].join('\n'));
    t.shaderSource(K, [
      'precision ' + x.getPrecision() + ' float;',
      'uniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nuniform int fogType;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\nvarying vec2 vUV;\nvoid main() {\nvec4 texture = texture2D( map, vUV );\nif ( texture.a < alphaTest ) discard;\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\nif ( fogType > 0 ) {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat fogFactor = 0.0;\nif ( fogType == 1 ) {\nfogFactor = smoothstep( fogNear, fogFar, depth );\n} else {\nconst float LOG2 = 1.442695;\nfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n}\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n}\n}'
    ].join('\n'));
    t.compileShader(O);
    t.compileShader(K);
    t.attachShader(w, O);
    t.attachShader(w, K);
    t.linkProgram(w);
    G = w;
    p = t.getAttribLocation(G, 'position');
    v = t.getAttribLocation(G, 'uv');
    a = t.getUniformLocation(G, 'uvOffset');
    b = t.getUniformLocation(G, 'uvScale');
    c = t.getUniformLocation(G, 'rotation');
    d = t.getUniformLocation(G, 'scale');
    e = t.getUniformLocation(G, 'color');
    f = t.getUniformLocation(G, 'map');
    g = t.getUniformLocation(G, 'opacity');
    h = t.getUniformLocation(G, 'modelViewMatrix');
    k = t.getUniformLocation(G, 'projectionMatrix');
    l = t.getUniformLocation(G, 'fogType');
    n = t.getUniformLocation(G, 'fogDensity');
    s = t.getUniformLocation(G, 'fogNear');
    r = t.getUniformLocation(G, 'fogFar');
    q = t.getUniformLocation(G, 'fogColor');
    u = t.getUniformLocation(G, 'alphaTest');
    w = document.createElement('canvas');
    w.width = 8;
    w.height = 8;
    O = w.getContext('2d');
    O.fillStyle = '#ffffff';
    O.fillRect(0, 0, w.width, w.height);
    z = new THREE.Texture(w);
    z.needsUpdate = !0;
  };
  this.render = function (E, B, K, y) {
    K = E.__webglSprites;
    if (y = K.length) {
      t.useProgram(G);
      t.enableVertexAttribArray(p);
      t.enableVertexAttribArray(v);
      t.disable(t.CULL_FACE);
      t.enable(t.BLEND);
      t.bindBuffer(t.ARRAY_BUFFER, H);
      t.vertexAttribPointer(p, 2, t.FLOAT, !1, 16, 0);
      t.vertexAttribPointer(v, 2, t.FLOAT, !1, 16, 8);
      t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, D);
      t.uniformMatrix4fv(k, !1, B.projectionMatrix.elements);
      t.activeTexture(t.TEXTURE0);
      t.uniform1i(f, 0);
      var F = 0, C = 0, A = E.fog;
      A ? (t.uniform3f(q, A.color.r, A.color.g, A.color.b), A instanceof THREE.Fog ? (t.uniform1f(s, A.near), t.uniform1f(r, A.far), t.uniform1i(l, 1), C = F = 1) : A instanceof THREE.FogExp2 && (t.uniform1f(n, A.density), t.uniform1i(l, 2), C = F = 2)) : (t.uniform1i(l, 0), C = F = 0);
      for (var L, Q = [], A = 0; A < y; A++)
        L = K[A], !1 !== L.visible && (L._modelViewMatrix.multiplyMatrices(B.matrixWorldInverse, L.matrixWorld), L.z = -L._modelViewMatrix.elements[14]);
      K.sort(w);
      for (A = 0; A < y; A++)
        L = K[A], !1 !== L.visible && (B = L.material, t.uniform1f(u, B.alphaTest), t.uniformMatrix4fv(h, !1, L._modelViewMatrix.elements), Q[0] = L.scale.x, Q[1] = L.scale.y, L = E.fog && B.fog ? C : 0, F !== L && (t.uniform1i(l, L), F = L), null !== B.map ? (t.uniform2f(a, B.map.offset.x, B.map.offset.y), t.uniform2f(b, B.map.repeat.x, B.map.repeat.y)) : (t.uniform2f(a, 0, 0), t.uniform2f(b, 1, 1)), t.uniform1f(g, B.opacity), t.uniform3f(e, B.color.r, B.color.g, B.color.b), t.uniform1f(c, B.rotation), t.uniform2fv(d, Q), x.setBlending(B.blending, B.blendEquation, B.blendSrc, B.blendDst), x.setDepthTest(B.depthTest), x.setDepthWrite(B.depthWrite), B.map && B.map.image && B.map.image.width ? x.setTexture(B.map, 0) : x.setTexture(z, 0), t.drawElements(t.TRIANGLES, 6, t.UNSIGNED_SHORT, 0));
      t.enable(t.CULL_FACE);
    }
  };
};
THREE.DepthPassPlugin = function () {
  this.enabled = !1;
  this.renderTarget = null;
  var a, b, c, d, e, f, g = new THREE.Frustum(), h = new THREE.Matrix4();
  this.init = function (g) {
    a = g.context;
    b = g;
    g = THREE.ShaderLib.depthRGBA;
    var h = THREE.UniformsUtils.clone(g.uniforms);
    c = new THREE.ShaderMaterial({
      fragmentShader: g.fragmentShader,
      vertexShader: g.vertexShader,
      uniforms: h
    });
    d = new THREE.ShaderMaterial({
      fragmentShader: g.fragmentShader,
      vertexShader: g.vertexShader,
      uniforms: h,
      morphTargets: !0
    });
    e = new THREE.ShaderMaterial({
      fragmentShader: g.fragmentShader,
      vertexShader: g.vertexShader,
      uniforms: h,
      skinning: !0
    });
    f = new THREE.ShaderMaterial({
      fragmentShader: g.fragmentShader,
      vertexShader: g.vertexShader,
      uniforms: h,
      morphTargets: !0,
      skinning: !0
    });
    c._shadowPass = !0;
    d._shadowPass = !0;
    e._shadowPass = !0;
    f._shadowPass = !0;
  };
  this.render = function (a, b) {
    this.enabled && this.update(a, b);
  };
  this.update = function (k, l) {
    var n, s, r, q, u, p;
    a.clearColor(1, 1, 1, 1);
    a.disable(a.BLEND);
    b.setDepthTest(!0);
    !0 === k.autoUpdate && k.updateMatrixWorld();
    l.matrixWorldInverse.getInverse(l.matrixWorld);
    h.multiplyMatrices(l.projectionMatrix, l.matrixWorldInverse);
    g.setFromMatrix(h);
    b.setRenderTarget(this.renderTarget);
    b.clear();
    p = k.__webglObjects;
    n = 0;
    for (s = p.length; n < s; n++)
      r = p[n], u = r.object, r.render = !1, !u.visible || (u instanceof THREE.Mesh || u instanceof THREE.ParticleSystem) && u.frustumCulled && !g.intersectsObject(u) || (u._modelViewMatrix.multiplyMatrices(l.matrixWorldInverse, u.matrixWorld), r.render = !0);
    var v;
    n = 0;
    for (s = p.length; n < s; n++)
      r = p[n], r.render && (u = r.object, r = r.buffer, u instanceof THREE.ParticleSystem && !u.customDepthMaterial || ((v = u.material instanceof THREE.MeshFaceMaterial ? u.material.materials[0] : u.material) && b.setMaterialFaces(u.material), q = 0 < u.geometry.morphTargets.length && v.morphTargets, v = u instanceof THREE.SkinnedMesh && v.skinning, q = u.customDepthMaterial ? u.customDepthMaterial : v ? q ? f : e : q ? d : c, r instanceof THREE.BufferGeometry ? b.renderBufferDirect(l, k.__lights, null, q, r, u) : b.renderBuffer(l, k.__lights, null, q, r, u)));
    p = k.__webglObjectsImmediate;
    n = 0;
    for (s = p.length; n < s; n++)
      r = p[n], u = r.object, u.visible && (u._modelViewMatrix.multiplyMatrices(l.matrixWorldInverse, u.matrixWorld), b.renderImmediateObject(l, k.__lights, null, c, u));
    n = b.getClearColor();
    s = b.getClearAlpha();
    a.clearColor(n.r, n.g, n.b, s);
    a.enable(a.BLEND);
  };
};
THREE.ShaderFlares = {
  lensFlareVertexTexture: {
    vertexShader: 'uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nuniform sampler2D occlusionMap;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif( renderType == 2 ) {\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\nvVisibility =        visibility.r / 9.0;\nvVisibility *= 1.0 - visibility.g / 9.0;\nvVisibility *=       visibility.b / 9.0;\nvVisibility *= 1.0 - visibility.a / 9.0;\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}',
    fragmentShader: 'uniform lowp int renderType;\nuniform sampler2D map;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nif( renderType == 0 ) {\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\n} else if( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * vVisibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}'
  },
  lensFlare: {
    vertexShader: 'uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif( renderType == 2 ) {\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}',
    fragmentShader: 'precision mediump float;\nuniform lowp int renderType;\nuniform sampler2D map;\nuniform sampler2D occlusionMap;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvoid main() {\nif( renderType == 0 ) {\ngl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\n} else if( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nfloat visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\nvisibility = ( 1.0 - visibility / 4.0 );\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * visibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}'
  }
};
'use strict';
void 0 === Date.now && (Date.now = function () {
  return new Date().valueOf();
});
var TWEEN = TWEEN || function () {
    var a = [];
    return {
      REVISION: '12',
      getAll: function () {
        return a;
      },
      removeAll: function () {
        a = [];
      },
      add: function (c) {
        a.push(c);
      },
      remove: function (c) {
        c = a.indexOf(c);
        -1 !== c && a.splice(c, 1);
      },
      update: function (c) {
        if (0 === a.length)
          return !1;
        for (var b = 0, c = void 0 !== c ? c : 'undefined' !== typeof window && void 0 !== window.performance && void 0 !== window.performance.now ? window.performance.now() : Date.now(); b < a.length;)
          a[b].update(c) ? b++ : a.splice(b, 1);
        return !0;
      }
    };
  }();
TWEEN.Tween = function (a) {
  var c = {}, b = {}, d = {}, e = 1000, g = 0, h = !1, j = !1, q = 0, m = null, v = TWEEN.Easing.Linear.None, w = TWEEN.Interpolation.Linear, n = [], r = null, s = !1, t = null, u = null, k;
  for (k in a)
    c[k] = parseFloat(a[k], 10);
  this.to = function (a, c) {
    void 0 !== c && (e = c);
    b = a;
    return this;
  };
  this.start = function (e) {
    TWEEN.add(this);
    j = !0;
    s = !1;
    m = void 0 !== e ? e : 'undefined' !== typeof window && void 0 !== window.performance && void 0 !== window.performance.now ? window.performance.now() : Date.now();
    m += q;
    for (var f in b) {
      if (b[f] instanceof Array) {
        if (0 === b[f].length)
          continue;
        b[f] = [a[f]].concat(b[f]);
      }
      c[f] = a[f];
      !1 === c[f] instanceof Array && (c[f] *= 1);
      d[f] = c[f] || 0;
    }
    return this;
  };
  this.stop = function () {
    if (!j)
      return this;
    TWEEN.remove(this);
    j = !1;
    this.stopChainedTweens();
    return this;
  };
  this.stopChainedTweens = function () {
    for (var a = 0, b = n.length; a < b; a++)
      n[a].stop();
  };
  this.delay = function (a) {
    q = a;
    return this;
  };
  this.repeat = function (a) {
    g = a;
    return this;
  };
  this.yoyo = function (a) {
    h = a;
    return this;
  };
  this.easing = function (a) {
    v = a;
    return this;
  };
  this.interpolation = function (a) {
    w = a;
    return this;
  };
  this.chain = function () {
    n = arguments;
    return this;
  };
  this.onStart = function (a) {
    r = a;
    return this;
  };
  this.onUpdate = function (a) {
    t = a;
    return this;
  };
  this.onComplete = function (a) {
    u = a;
    return this;
  };
  this.update = function (p) {
    var f;
    if (p < m)
      return !0;
    !1 === s && (null !== r && r.call(a), s = !0);
    var i = (p - m) / e, i = 1 < i ? 1 : i, j = v(i);
    for (f in b) {
      var k = c[f] || 0, l = b[f];
      l instanceof Array ? a[f] = w(l, j) : ('string' === typeof l && (l = k + parseFloat(l, 10)), 'number' === typeof l && (a[f] = k + (l - k) * j));
    }
    null !== t && t.call(a, j);
    if (1 == i)
      if (0 < g) {
        isFinite(g) && g--;
        for (f in d)
          'string' === typeof b[f] && (d[f] += parseFloat(b[f], 10)), h && (i = d[f], d[f] = b[f], b[f] = i), c[f] = d[f];
        m = p + q;
      } else {
        null !== u && u.call(a);
        f = 0;
        for (i = n.length; f < i; f++)
          n[f].start(p);
        return !1;
      }
    return !0;
  };
};
TWEEN.Easing = {
  Linear: {
    None: function (a) {
      return a;
    }
  },
  Quadratic: {
    In: function (a) {
      return a * a;
    },
    Out: function (a) {
      return a * (2 - a);
    },
    InOut: function (a) {
      return 1 > (a *= 2) ? 0.5 * a * a : -0.5 * (--a * (a - 2) - 1);
    }
  },
  Cubic: {
    In: function (a) {
      return a * a * a;
    },
    Out: function (a) {
      return --a * a * a + 1;
    },
    InOut: function (a) {
      return 1 > (a *= 2) ? 0.5 * a * a * a : 0.5 * ((a -= 2) * a * a + 2);
    }
  },
  Quartic: {
    In: function (a) {
      return a * a * a * a;
    },
    Out: function (a) {
      return 1 - --a * a * a * a;
    },
    InOut: function (a) {
      return 1 > (a *= 2) ? 0.5 * a * a * a * a : -0.5 * ((a -= 2) * a * a * a - 2);
    }
  },
  Quintic: {
    In: function (a) {
      return a * a * a * a * a;
    },
    Out: function (a) {
      return --a * a * a * a * a + 1;
    },
    InOut: function (a) {
      return 1 > (a *= 2) ? 0.5 * a * a * a * a * a : 0.5 * ((a -= 2) * a * a * a * a + 2);
    }
  },
  Sinusoidal: {
    In: function (a) {
      return 1 - Math.cos(a * Math.PI / 2);
    },
    Out: function (a) {
      return Math.sin(a * Math.PI / 2);
    },
    InOut: function (a) {
      return 0.5 * (1 - Math.cos(Math.PI * a));
    }
  },
  Exponential: {
    In: function (a) {
      return 0 === a ? 0 : Math.pow(1024, a - 1);
    },
    Out: function (a) {
      return 1 === a ? 1 : 1 - Math.pow(2, -10 * a);
    },
    InOut: function (a) {
      return 0 === a ? 0 : 1 === a ? 1 : 1 > (a *= 2) ? 0.5 * Math.pow(1024, a - 1) : 0.5 * (-Math.pow(2, -10 * (a - 1)) + 2);
    }
  },
  Circular: {
    In: function (a) {
      return 1 - Math.sqrt(1 - a * a);
    },
    Out: function (a) {
      return Math.sqrt(1 - --a * a);
    },
    InOut: function (a) {
      return 1 > (a *= 2) ? -0.5 * (Math.sqrt(1 - a * a) - 1) : 0.5 * (Math.sqrt(1 - (a -= 2) * a) + 1);
    }
  },
  Elastic: {
    In: function (a) {
      var c, b = 0.1;
      if (0 === a)
        return 0;
      if (1 === a)
        return 1;
      !b || 1 > b ? (b = 1, c = 0.1) : c = 0.4 * Math.asin(1 / b) / (2 * Math.PI);
      return -(b * Math.pow(2, 10 * (a -= 1)) * Math.sin((a - c) * 2 * Math.PI / 0.4));
    },
    Out: function (a) {
      var c, b = 0.1;
      if (0 === a)
        return 0;
      if (1 === a)
        return 1;
      !b || 1 > b ? (b = 1, c = 0.1) : c = 0.4 * Math.asin(1 / b) / (2 * Math.PI);
      return b * Math.pow(2, -10 * a) * Math.sin((a - c) * 2 * Math.PI / 0.4) + 1;
    },
    InOut: function (a) {
      var c, b = 0.1;
      if (0 === a)
        return 0;
      if (1 === a)
        return 1;
      !b || 1 > b ? (b = 1, c = 0.1) : c = 0.4 * Math.asin(1 / b) / (2 * Math.PI);
      return 1 > (a *= 2) ? -0.5 * b * Math.pow(2, 10 * (a -= 1)) * Math.sin((a - c) * 2 * Math.PI / 0.4) : 0.5 * b * Math.pow(2, -10 * (a -= 1)) * Math.sin((a - c) * 2 * Math.PI / 0.4) + 1;
    }
  },
  Back: {
    In: function (a) {
      return a * a * (2.70158 * a - 1.70158);
    },
    Out: function (a) {
      return --a * a * (2.70158 * a + 1.70158) + 1;
    },
    InOut: function (a) {
      return 1 > (a *= 2) ? 0.5 * a * a * (3.5949095 * a - 2.5949095) : 0.5 * ((a -= 2) * a * (3.5949095 * a + 2.5949095) + 2);
    }
  },
  Bounce: {
    In: function (a) {
      return 1 - TWEEN.Easing.Bounce.Out(1 - a);
    },
    Out: function (a) {
      return a < 1 / 2.75 ? 7.5625 * a * a : a < 2 / 2.75 ? 7.5625 * (a -= 1.5 / 2.75) * a + 0.75 : a < 2.5 / 2.75 ? 7.5625 * (a -= 2.25 / 2.75) * a + 0.9375 : 7.5625 * (a -= 2.625 / 2.75) * a + 0.984375;
    },
    InOut: function (a) {
      return 0.5 > a ? 0.5 * TWEEN.Easing.Bounce.In(2 * a) : 0.5 * TWEEN.Easing.Bounce.Out(2 * a - 1) + 0.5;
    }
  }
};
TWEEN.Interpolation = {
  Linear: function (a, c) {
    var b = a.length - 1, d = b * c, e = Math.floor(d), g = TWEEN.Interpolation.Utils.Linear;
    return 0 > c ? g(a[0], a[1], d) : 1 < c ? g(a[b], a[b - 1], b - d) : g(a[e], a[e + 1 > b ? b : e + 1], d - e);
  },
  Bezier: function (a, c) {
    var b = 0, d = a.length - 1, e = Math.pow, g = TWEEN.Interpolation.Utils.Bernstein, h;
    for (h = 0; h <= d; h++)
      b += e(1 - c, d - h) * e(c, h) * a[h] * g(d, h);
    return b;
  },
  CatmullRom: function (a, c) {
    var b = a.length - 1, d = b * c, e = Math.floor(d), g = TWEEN.Interpolation.Utils.CatmullRom;
    return a[0] === a[b] ? (0 > c && (e = Math.floor(d = b * (1 + c))), g(a[(e - 1 + b) % b], a[e], a[(e + 1) % b], a[(e + 2) % b], d - e)) : 0 > c ? a[0] - (g(a[0], a[0], a[1], a[1], -d) - a[0]) : 1 < c ? a[b] - (g(a[b], a[b], a[b - 1], a[b - 1], d - b) - a[b]) : g(a[e ? e - 1 : 0], a[e], a[b < e + 1 ? b : e + 1], a[b < e + 2 ? b : e + 2], d - e);
  },
  Utils: {
    Linear: function (a, c, b) {
      return (c - a) * b + a;
    },
    Bernstein: function (a, c) {
      var b = TWEEN.Interpolation.Utils.Factorial;
      return b(a) / b(c) / b(a - c);
    },
    Factorial: function () {
      var a = [1];
      return function (c) {
        var b = 1, d;
        if (a[c])
          return a[c];
        for (d = c; 1 < d; d--)
          b *= d;
        return a[c] = b;
      };
    }(),
    CatmullRom: function (a, c, b, d, e) {
      var a = 0.5 * (b - a), d = 0.5 * (d - c), g = e * e;
      return (2 * c - 2 * b + a + d) * e * g + (-3 * c + 3 * b - 2 * a - d) * g + a * e + c;
    }
  }
};
(function ($window, $document, tagName, url, namespace, a, m) {
  $window['GoogleAnalyticsObject'] = namespace;
  $window[namespace] = $window[namespace] || function () {
    ($window[namespace].q = $window[namespace].q || []).push(arguments);
  }, $window[namespace].l = 1 * new Date();
  a = $document.createElement(tagName), m = $document.getElementsByTagName(tagName)[0];
  a.async = 1;
  a.src = url;
  m.parentNode.insertBefore(a, m);
}(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga'));
var Stats = function () {
  var startTime = Date.now(), prevTime = startTime;
  var ms = 0, msMin = Infinity, msMax = 0;
  var fps = 0, fpsMin = Infinity, fpsMax = 0;
  var frames = 0, mode = 0;
  var container = document.createElement('div');
  container.id = 'stats';
  container.addEventListener('mousedown', function (event) {
    event.preventDefault();
    setMode(++mode % 2);
  }, false);
  container.style.cssText = 'width:80px;opacity:0.9;cursor:pointer';
  var fpsDiv = document.createElement('div');
  fpsDiv.id = 'fps';
  fpsDiv.style.cssText = 'padding:0 0 3px 3px;text-align:left;background-color:#002';
  container.appendChild(fpsDiv);
  var fpsText = document.createElement('div');
  fpsText.id = 'fpsText';
  fpsText.style.cssText = 'color:#0ff;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px';
  fpsText.innerHTML = 'FPS';
  fpsDiv.appendChild(fpsText);
  var fpsGraph = document.createElement('div');
  fpsGraph.id = 'fpsGraph';
  fpsGraph.style.cssText = 'position:relative;width:74px;height:30px;background-color:#0ff';
  fpsDiv.appendChild(fpsGraph);
  while (fpsGraph.children.length < 74) {
    var bar = document.createElement('span');
    bar.style.cssText = 'width:1px;height:30px;float:left;background-color:#113';
    fpsGraph.appendChild(bar);
  }
  var msDiv = document.createElement('div');
  msDiv.id = 'ms';
  msDiv.style.cssText = 'padding:0 0 3px 3px;text-align:left;background-color:#020;display:none';
  container.appendChild(msDiv);
  var msText = document.createElement('div');
  msText.id = 'msText';
  msText.style.cssText = 'color:#0f0;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px';
  msText.innerHTML = 'MS';
  msDiv.appendChild(msText);
  var msGraph = document.createElement('div');
  msGraph.id = 'msGraph';
  msGraph.style.cssText = 'position:relative;width:74px;height:30px;background-color:#0f0';
  msDiv.appendChild(msGraph);
  while (msGraph.children.length < 74) {
    var bar = document.createElement('span');
    bar.style.cssText = 'width:1px;height:30px;float:left;background-color:#131';
    msGraph.appendChild(bar);
  }
  var setMode = function (value) {
    mode = value;
    switch (mode) {
    case 0:
      fpsDiv.style.display = 'block';
      msDiv.style.display = 'none';
      break;
    case 1:
      fpsDiv.style.display = 'none';
      msDiv.style.display = 'block';
      break;
    }
  };
  var updateGraph = function (dom, value) {
    var child = dom.appendChild(dom.firstChild);
    child.style.height = value + 'px';
  };
  return {
    REVISION: 11,
    domElement: container,
    setMode: setMode,
    begin: function () {
      startTime = Date.now();
    },
    end: function () {
      var time = Date.now();
      ms = time - startTime;
      msMin = Math.min(msMin, ms);
      msMax = Math.max(msMax, ms);
      msText.textContent = ms + ' MS (' + msMin + '-' + msMax + ')';
      updateGraph(msGraph, Math.min(30, 30 - ms / 200 * 30));
      frames++;
      if (time > prevTime + 1000) {
        fps = Math.round(frames * 1000 / (time - prevTime));
        fpsMin = Math.min(fpsMin, fps);
        fpsMax = Math.max(fpsMax, fps);
        fpsText.textContent = fps + ' FPS (' + fpsMin + '-' + fpsMax + ')';
        updateGraph(fpsGraph, Math.min(30, 30 - fps / 100 * 30));
        prevTime = time;
        frames = 0;
      }
      return time;
    },
    update: function () {
      startTime = this.end();
    }
  };
};
(function () {
  var app;
  app = angular.module('app', [
    'async',
    'jed',
    'jquery',
    'underscore'
  ]);
  app.run([
    '$rootScope',
    '$window',
    '$location',
    'cookie',
    'i18n',
    function ($rootScope, $window, $location, cookie, i18n) {
      var GITHUB_APPLICATION_CLIENT_ID_COOKIE_NAME, GITHUB_LOGIN_COOKIE_NAME, GITHUB_TOKEN_COOKIE_NAME, isMenuLocation;
      GITHUB_APPLICATION_CLIENT_ID_COOKIE_NAME = 'github-application-client-id';
      GITHUB_TOKEN_COOKIE_NAME = 'github-token';
      GITHUB_LOGIN_COOKIE_NAME = 'github-login';
      $rootScope.i18n = i18n;
      $rootScope.breadcrumbStrategy = { progressive: false };
      $rootScope.clientId = function () {
        return cookie.getItem(GITHUB_APPLICATION_CLIENT_ID_COOKIE_NAME);
      };
      $rootScope.log = function (thing) {
      };
      $rootScope.alert = function (thing) {
        return alert(thing);
      };
      $rootScope.isLoggedIn = function () {
        return cookie.hasItem(GITHUB_TOKEN_COOKIE_NAME);
      };
      $rootScope.loginEnabled = function () {
        return !cookie.hasItem(GITHUB_TOKEN_COOKIE_NAME);
      };
      $rootScope.logout = function () {
        cookie.removeItem(GITHUB_TOKEN_COOKIE_NAME);
        return cookie.removeItem(GITHUB_LOGIN_COOKIE_NAME);
      };
      $rootScope.login = function () {
        var clientId;
        clientId = cookie.getItem(GITHUB_APPLICATION_CLIENT_ID_COOKIE_NAME);
        return $window.location.href = 'https://github.com/login/oauth/authorize?client_id=' + clientId + '&amp;scope=repo,user,gist';
      };
      $rootScope.userLogin = function () {
        return cookie.getItem(GITHUB_LOGIN_COOKIE_NAME);
      };
      $rootScope.headerEnabled = function () {
        return true;
      };
      isMenuLocation = function () {
        if ($window.location && $window.location.href) {
          return !$window.location.href.match(new RegExp('/workbench$')) && !$window.location.href.match(new RegExp('/users/')) && !$window.location.href.match(new RegExp('/gists/'));
        } else {
          return false;
        }
      };
      $rootScope.isHomePage = function () {
        return true;
      };
      $rootScope.jumpIcon = function () {
        if (isMenuLocation()) {
          return 'icon-edit';
        } else {
          return 'icon-home';
        }
      };
      $rootScope.jumpText = function () {
        if (isMenuLocation()) {
          return 'Workbench';
        } else {
          return 'Home';
        }
      };
      return $rootScope.jumpHRef = function () {
        if (isMenuLocation()) {
          return '/workbench';
        } else {
          return '/';
        }
      };
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('EmbedCtrl', [
    '$rootScope',
    '$scope',
    '$location',
    '$window',
    '$routeParams',
    '$',
    '_',
    'GitHub',
    'Base64',
    'cookie',
    'GitHubAuthManager',
    function ($rootScope, $scope, $location, $window, $routeParams, $, _, github, base64, cookie, authManager) {
      var EVENT_CATEGORY, GITHUB_TOKEN_COOKIE_NAME, code, editor, isFullScreen, n, setFullScreen, steps, token, winHeight, winWidth, _i;
      EVENT_CATEGORY = 'embed';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/embed');
      ga('send', 'pageview');
      authManager.handleLoginCallback(function (err, token) {
        if (err) {
          return $window.alert(err.message);
        }
      });
      GITHUB_TOKEN_COOKIE_NAME = 'github-token';
      token = cookie.getItem(GITHUB_TOKEN_COOKIE_NAME);
      $scope.messages = [];
      $scope.contextItem = {};
      $scope.contextGist = {};
      if ($routeParams.user && $routeParams.repo) {
        $scope.user = { login: $routeParams.user };
        $scope.repo = { name: $routeParams.repo };
        $scope.branch = { name: $routeParams.branch };
        steps = [];
        for (n = _i = 0; _i <= 6; n = ++_i) {
          if ($routeParams['step' + n]) {
            steps.push($routeParams['step' + n]);
          }
        }
        $scope.path = steps.join('/');
        $scope.contextItem.name = $routeParams.repo;
        $scope.contextItem.type = 'repo';
        github.getPathContents(token, $scope.user.login, $scope.repo.name, $scope.path, function (err, file) {
          var contextItem;
          if (!err) {
            contextItem = {
              name: file.name,
              path: file.path,
              sha: file.sha,
              type: file.type,
              parentItem: $scope.contextItem,
              childItems: []
            };
            $scope.contextItem = contextItem;
            if (file.encoding === 'base64') {
              return editor.setValue(base64.decode(file.content));
            } else {
              return alert('Unknown encoding: ' + file.encoding);
            }
          } else {
            return alert('Error retrieving the page');
          }
        });
      } else if ($routeParams.gistId) {
        github.getGist(token, $routeParams.gistId, function (err, gist) {
          if (!err) {
            $scope.contextGist = gist;
            $scope.contextItem.name = 'main.py';
            return editor.setValue(gist.files['main.py'].content);
          } else {
            return alert('Error retrieving the Gist.');
          }
        });
      } else {
        $scope.contextItem.name = 'Untitled';
        $scope.contextItem.type = void 0;
      }
      winHeight = function () {
        return $window.innerHeight || ($window.document.documentElement || $window.document.body).clientHeight;
      };
      winWidth = function () {
        return $window.innerWidth || ($window.document.documentElement || $window.document.body).clientWidth;
      };
      isFullScreen = function (cm) {
        return /\bCodeMirror-fullscreen\b/.test(cm.getWrapperElement().className);
      };
      setFullScreen = function (cm, full) {
        var wrapperElement;
        wrapperElement = cm.getWrapperElement();
        if (full) {
          wrapperElement.className += ' CodeMirror-fullscreen';
          wrapperElement.style.height = winHeight() + 'px';
          document.documentElement.style.overflow = 'hidden';
        } else {
          wrapperElement.className = wrapperElement.className.replace(' CodeMirror-fullscreen', '');
          wrapperElement.style.height = '600px';
          document.documentElement.style.overflow = '';
        }
        return cm.refresh();
      };
      code = document.getElementById('code');
      if (code) {
        editor = CodeMirror.fromTextArea(code, {
          'autofocus': false,
          'indentUnit': 4,
          'lineNumbers': true,
          'lineWrapping': true,
          'autoMatchParens': true,
          'parserConfig': {
            'pythonVersion': 2,
            'strictErrors': true
          },
          'theme': 'twilight',
          'extraKeys': {
            'Tab': function (cm) {
              var spaces;
              spaces = Array(cm.getOption('indentUnit') + 1).join(' ');
              return cm.replaceSelection(spaces, 'end', '+input');
            },
            'Ctrl-Enter': function (cm) {
              return $scope.run();
            }
          }
        });
      } else {
        alert('The code element could not be found');
      }
      $scope.run = function () {
        var e, message, name, prog, text;
        ga('send', 'event', EVENT_CATEGORY, 'run');
        $rootScope.$broadcast('reset');
        $scope.messages.length = 0;
        prog = editor.getValue();
        Sk.canvas = 'canvas';
        Sk.python3 = true;
        Sk.configure({
          'output': function (text) {
            return $rootScope.$broadcast('print', text);
          },
          'debugout': function (arg) {
            return console.log('' + JSON.stringify(arg, null, 2));
          },
          'read': function (searchPath) {
            if (Sk.builtinFiles === void 0 || Sk.builtinFiles['files'][searchPath] === void 0) {
              throw new Error('File not found: \'' + searchPath + '\'');
            } else {
              return Sk.builtinFiles['files'][searchPath];
            }
          }
        });
        if (prog.trim().length > 0) {
          try {
            return eval(Sk.importMainWithBody('<stdin>', false, prog.trim()));
          } catch (_error) {
            e = _error;
            if (typeof e !== 'undefined') {
              if (typeof e.toString === 'function') {
                message = e.toString();
                name = message.substring(0, message.indexOf(':'));
                text = message.substring(message.indexOf(':') + 1);
                return $scope.messages.push({
                  name: name,
                  text: text,
                  severity: 'error'
                });
              } else {
                return console.log(JSON.stringify(e, null, 2));
              }
            }
          }
        }
      };
      $scope.saveFile = function () {
        var content, data, description, files;
        ga('send', 'event', EVENT_CATEGORY, 'savePage');
        content = base64.encode(editor.getValue());
        if ($scope.user) {
          return github.putFile(token, $scope.user.login, $scope.repo.name, $scope.contextItem.path, 'Save file.', content, $scope.contextItem.sha, function (err, response, status, headers, config) {
            if (!err) {
              return $scope.contextItem.sha = response.content.sha;
            } else {
              return alert('Error saving file to repository. Cause: ' + err.message);
            }
          });
        } else {
          if ($scope.contextGist.id) {
            description = $scope.contextGist.description;
            files = { 'main.py': { content: editor.getValue() } };
            return github.patchGist(token, $scope.contextGist.id, {
              description: description,
              files: files
            }, function (err, response, status, headers, config) {
              if (!err) {
              } else {
                return alert('Error patching Gist. Cause: ' + err.message);
              }
            });
          } else {
            files = { 'main.py': { content: editor.getValue() } };
            data = {};
            data.description = 'GeometryZen Gist';
            data['public'] = true;
            data.files = files;
            return github.postGist(token, data, function (err, response, status, headers, config) {
              if (!err) {
                return $location.path('/gists/' + response.id);
              } else {
                return alert('Error posting Gist. Cause: ' + err.message);
              }
            });
          }
        }
      };
      $scope.homeBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active';
        } else {
          return '';
        }
      };
      $scope.userBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active';
        } else {
          return '';
        }
      };
      $scope.repoBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active';
        } else {
          if ($scope.workEnabled()) {
            return '';
          } else {
            return 'active';
          }
        }
      };
      $scope.repoEnabled = function () {
        return $scope.repo && $scope.repo.name;
      };
      $scope.workEnabled = function () {
        return $scope.contextItem && $scope.contextItem.type === 'file' || !($scope.repo && $scope.repo.name);
      };
      $scope.saveEnabled = function () {
        if ($scope.user) {
          return $scope.isLoggedIn() && $scope.userLogin() === $scope.user.login && $scope.contextItem && $scope.contextItem.type === 'file';
        } else {
          return true;
        }
      };
      $scope.runEnabled = function () {
        return $scope.workEnabled();
      };
      $rootScope.headerEnabled = function () {
        return false;
      };
      $scope.iconFromItem = function (item) {
        switch (item.type) {
        case 'file':
          return 'icon-file';
        case 'dir':
          return 'icon-dir';
        default:
          return 'icon-question';
        }
      };
      if (editor) {
        setFullScreen(editor, false);
      }
      CodeMirror.on($window, 'resize', function () {
        var showing;
        showing = $window.document.body.getElementsByClassName('CodeMirror-fullscreen')[0];
        if (showing) {
          return showing.CodeMirror.getWrapperElement().style.height = winHeight() + 'px';
        } else {
        }
      });
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('HomeCtrl', [
    '$rootScope',
    '$scope',
    '$http',
    '$location',
    '$window',
    'GitHubAuthManager',
    function ($rootScope, $scope, $http, $location, $window, authManager) {
      var EVENT_CATEGORY;
      EVENT_CATEGORY = 'home';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/home');
      ga('send', 'pageview');
      authManager.handleLoginCallback(function (err, token) {
        if (err) {
          return $window.alert(err.message);
        }
      });
      $scope.work = function () {
        ga('send', 'event', EVENT_CATEGORY, 'work');
        $location.path('/work');
      };
      $scope.browse = function () {
        ga('send', 'event', EVENT_CATEGORY, 'browse');
        $location.path('/browse');
      };
      return $scope.user = function () {
        var path;
        ga('send', 'event', EVENT_CATEGORY, 'user');
        path = '/users/' + $scope.userLogin();
        $location.path(path);
      };
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('NewFileCtrl', [
    '$scope',
    'GitHub',
    'Base64',
    'cookie',
    '$',
    '_',
    function ($scope, github, base64, cookie, $, _) {
      var EVENT_CATEGORY, GITHUB_TOKEN_COOKIE_NAME, token;
      EVENT_CATEGORY = 'new-file';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/new-file');
      ga('send', 'pageview');
      GITHUB_TOKEN_COOKIE_NAME = 'github-token';
      token = cookie.getItem(GITHUB_TOKEN_COOKIE_NAME);
      $('#new-file-dialog').on('show', function () {
        return $scope.file = {
          name: '',
          message: ''
        };
      });
      $('#new-file-dialog').on('shown', function () {
      });
      $('#new-file-dialog').on('hide', function () {
      });
      $('#new-file-dialog').on('hidden', function () {
      });
      return $scope.createFile = function () {
        var content, path;
        ga('send', 'event', EVENT_CATEGORY, 'createFile');
        content = base64.encode('# ' + $scope.file.name + '\n');
        path = $scope.path ? '' + $scope.path + '/' + $scope.file.name : $scope.file.name;
        return github.putFile(token, $scope.user.login, $scope.repo.name, path, $scope.file.message, content, void 0, function (err, response, status, headers, config) {
          var messages;
          if (!err) {
            $scope.$emit('createdFile', $scope.user, $scope.repo, response.content, response.commit);
            return $('#new-file-dialog').modal('hide');
          } else {
            messages = _.map(response.errors, function (error) {
              return error.message;
            }).join();
            return alert(messages);
          }
        });
      };
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('NewGistCtrl', [
    '$scope',
    'GitHub',
    'cookie',
    '$',
    '_',
    function ($scope, github, cookie, $, _) {
      var EVENT_CATEGORY, GITHUB_TOKEN_COOKIE_NAME, token;
      EVENT_CATEGORY = 'new-gist';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/new-gist');
      ga('send', 'pageview');
      GITHUB_TOKEN_COOKIE_NAME = 'github-token';
      token = cookie.getItem(GITHUB_TOKEN_COOKIE_NAME);
      $('#new-gist-dialog').on('show', function () {
        return $scope.gist = {
          path: '',
          description: '',
          'private': 'false',
          markdownReadme: true,
          pythonReadme: true
        };
      });
      $('#new-gist-dialog').on('shown', function () {
      });
      $('#new-gist-dialog').on('hide', function () {
      });
      $('#new-gist-dialog').on('hidden', function () {
      });
      return $scope.createGist = function () {
        var data;
        ga('send', 'event', EVENT_CATEGORY, 'createGist');
        data = {};
        data.description = $scope.gist.description;
        data['public'] = true;
        data.files = { 'main.py': { 'content': '# main.py' } };
        return github.postGist(token, data, function (err, response, status, headers, config) {
          var messages;
          if (!err) {
            $scope.$emit('createdGist', $scope.user, response);
            return $('#new-gist-dialog').modal('hide');
          } else {
            messages = _.map(response.errors, function (error) {
              return error.message;
            }).join();
            return alert(messages);
          }
        });
      };
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('NewRepoCtrl', [
    '$scope',
    'GitHub',
    'cookie',
    '$',
    '_',
    function ($scope, github, cookie, $, _) {
      var EVENT_CATEGORY, GITHUB_TOKEN_COOKIE_NAME, token;
      EVENT_CATEGORY = 'new-repo';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/new-repo');
      ga('send', 'pageview');
      GITHUB_TOKEN_COOKIE_NAME = 'github-token';
      token = cookie.getItem(GITHUB_TOKEN_COOKIE_NAME);
      $('#new-repo-dialog').on('show', function () {
        return $scope.repo = {
          path: '',
          description: '',
          'private': 'false',
          markdownReadme: true,
          pythonReadme: true
        };
      });
      $('#new-repo-dialog').on('shown', function () {
      });
      $('#new-repo-dialog').on('hide', function () {
      });
      $('#new-repo-dialog').on('hidden', function () {
      });
      return $scope.createRepo = function () {
        ga('send', 'event', EVENT_CATEGORY, 'createRepo');
        return github.postRepo(token, $scope.repo.name, $scope.repo.description, false, $scope.repo.markdownReadme, function (err, repo) {
          var messages;
          if (!err) {
            $scope.$emit('createdRepo', $scope.user, repo);
            return $('#new-repo-dialog').modal('hide');
          } else {
            messages = _.map(response.errors, function (error) {
              return error.message;
            }).join();
            return alert(messages);
          }
        });
      };
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('PrinterCtrl', [
    '$scope',
    function ($scope) {
      var EVENT_CATEGORY, PRESERVE_ELEMENT_ID, escapeHtml;
      EVENT_CATEGORY = 'printer';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/printer');
      ga('send', 'pageview');
      PRESERVE_ELEMENT_ID = 'a5f435e0-c92e-11e2-8b8b-0800200c9a66';
      escapeHtml = function (s) {
        return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
      };
      $scope.$on('reset', function (e) {
        var elem;
        elem = document.getElementById(PRESERVE_ELEMENT_ID);
        if (elem) {
          return elem.innerHTML = '';
        } else {
          return console.log('Unable to find element with Id ' + PRESERVE_ELEMENT_ID);
        }
      });
      return $scope.$on('print', function (e, text) {
        var elem;
        elem = document.getElementById(PRESERVE_ELEMENT_ID);
        if (elem) {
          return elem.innerHTML = elem.innerHTML + escapeHtml(text);
        } else {
          return console.log('Unable to find element with Id ' + PRESERVE_ELEMENT_ID);
        }
      });
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('TreeCtrl', [
    '$rootScope',
    '$scope',
    '$window',
    '$routeParams',
    '$',
    '_',
    'GitHub',
    'Base64',
    'cookie',
    function ($rootScope, $scope, $window, $routeParams, $, _, github, base64, cookie) {
      var EVENT_CATEGORY, GITHUB_TOKEN_COOKIE_NAME, n, steps, token, _i;
      EVENT_CATEGORY = 'tree';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/tree');
      ga('send', 'pageview');
      GITHUB_TOKEN_COOKIE_NAME = 'github-token';
      token = cookie.getItem(GITHUB_TOKEN_COOKIE_NAME);
      $scope.messages = [];
      $('.carousel').carousel({ interval: false });
      $scope.contextItem = {};
      if ($routeParams.user && $routeParams.repo) {
        $scope.user = { login: $routeParams.user };
        $scope.repo = { name: $routeParams.repo };
        $scope.branch = { name: $routeParams.branch };
        steps = [];
        for (n = _i = 0; _i <= 6; n = ++_i) {
          if ($routeParams['step' + n]) {
            steps.push($routeParams['step' + n]);
          }
        }
        $scope.path = steps.join('/');
        $scope.contextItem.name = $scope.repo.name;
        $scope.contextItem.type = 'repo';
        github.getPathContents(token, $scope.user.login, $scope.repo.name, $scope.path, function (err, response, status, headers, config) {
          if (!err) {
            return $scope.contextItem.childItems = response;
          } else {
            console.log('err: ' + err + ', reponse: ' + response + ', status ' + status);
            return alert('' + err.message + '. Cause: ' + response.message + '.');
          }
        });
      } else {
        $scope.contextItem.name = '';
        $scope.contextItem.type = void 0;
      }
      $scope.isNewFileEnabled = function () {
        return $scope.isLoggedIn() && $scope.userLogin() === $scope.user.login;
      };
      $scope.newFile = function () {
        if ($scope.isNewFileEnabled()) {
          return $('#new-file-dialog').modal({
            show: true,
            backdrop: true
          });
        } else {
          return alert('Create a New File is not enabled.');
        }
      };
      $scope.$on('createdFile', function (e, user, repo, item, commit) {
        return $scope.contextItem.childItems.push(item);
      });
      $scope.isDeleteItemEnabled = function () {
        return $scope.isLoggedIn() && $scope.userLogin() === $scope.user.login;
      };
      $scope.deleteItem = function (idx) {
        var childItem;
        ga('send', 'event', EVENT_CATEGORY, 'deleteItem');
        childItem = $scope.contextItem.childItems[idx];
        return github.deleteFile(token, $scope.user.login, $scope.repo.name, childItem.path, 'Delete item.', childItem.sha, function (err, response, status, headers, config) {
          if (!err) {
            return $scope.contextItem.childItems.splice(idx, 1);
          } else {
            return alert('Error deleting item: ' + err);
          }
        });
      };
      $scope.homeBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active';
        } else {
          return '';
        }
      };
      $scope.userBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active';
        } else {
          return '';
        }
      };
      $scope.repoBreadcrumbClass = function () {
        return 'active';
      };
      $scope.hrefFromItem = function (item) {
        var collectionName;
        collectionName = item.type === 'file' ? 'blob' : item.type === 'dir' ? 'tree' : 'unknown';
        return '/users/' + $scope.user.login + '/repos/' + $scope.repo.name + '/' + collectionName + '/' + $scope.branch.name + '/' + item.path;
      };
      $scope.iconFromItem = function (item) {
        switch (item.type) {
        case 'file':
          return 'icon-file';
        case 'dir':
          return 'icon-dir';
        default:
          return 'icon-question';
        }
      };
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('UserCtrl', [
    '$rootScope',
    '$scope',
    '$routeParams',
    'GitHub',
    'cookie',
    '$',
    '_',
    'async',
    function ($rootScope, $scope, $routeParams, github, cookie, $, _, async) {
      var EVENT_CATEGORY, GITHUB_TOKEN_COOKIE_NAME, findIndex, loadGists, loadRepos, token;
      EVENT_CATEGORY = 'user';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/user');
      ga('send', 'pageview');
      GITHUB_TOKEN_COOKIE_NAME = 'github-token';
      token = cookie.getItem(GITHUB_TOKEN_COOKIE_NAME);
      loadGists = function (callback) {
        return github.getGists(token, function (err, gists) {
          if (!err) {
            $scope.gists = _.filter(_.map(gists, function (gist) {
              return {
                'id': gist.id,
                'description': gist.description,
                'html_url': gist.html_url
              };
            }), function (gist) {
              return true;
            });
          } else {
            alert('Error retrieving user Gists');
          }
          return callback(err, gists);
        });
      };
      loadRepos = function (callback) {
        return github.getUserRepos(token, function (err, repos) {
          if (!err) {
            $scope.repos = _.filter(repos, function (repo) {
              return repo.language === 'Python';
            });
          } else {
            alert('Error retrieving user Repositories');
          }
          return callback(err, repos);
        });
      };
      async.parallel([
        function (callback) {
          return github.getUser(token, function (err, user) {
            if (!err) {
              $scope.user = user;
            } else {
              alert('Error retrieving user profile');
            }
            return callback(err, user);
          });
        },
        function (callback) {
          return loadRepos(callback);
        },
        function (callback) {
          return loadGists(callback);
        }
      ], function (err, results) {
      });
      $scope.homeBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active distance-1';
        } else {
          return '';
        }
      };
      $scope.userBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active distance-0';
        } else {
          return 'active distance-0';
        }
      };
      $scope.newGist = function () {
        return $('#new-gist-dialog').modal({
          show: true,
          backdrop: true
        });
      };
      findIndex = function (xs, match) {
        var i, length, x, _i, _ref;
        length = xs;
        for (i = _i = 0, _ref = length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          x = xs[i];
          if (match(x)) {
            return x;
          }
        }
        return -1;
      };
      $scope.deleteGist = function (owner, id) {
        ga('send', 'event', EVENT_CATEGORY, 'deleteGist');
        return github.deleteGist(token, owner, id, function (err, response, status, headers, config) {
          var index;
          if (!err) {
            index = findIndex($scope.gists, function (gist) {
              return gist.id === id;
            });
            return $scope.gists.splice(index, 1);
          } else {
            return alert('Error deleting gist: ' + err);
          }
        });
      };
      $scope.$on('createdGist', function (e, user, gist) {
        return $scope.gists.push(gist);
      });
      $scope.newRepo = function (owner) {
        return $('#new-repo-dialog').modal({
          show: true,
          backdrop: true
        });
      };
      $scope.deleteRepo = function (owner, repo) {
        ga('send', 'event', EVENT_CATEGORY, 'deleteRepo');
        return github.deleteRepo(token, owner, repo, function (err, response, status, headers, config) {
          if (!err) {
          } else {
            return alert('Error deleting repo: ' + err);
          }
        });
      };
      return $scope.$on('createdRepo', function (e, user, repo) {
        return $scope.repos.push(repo);
      });
    }
  ]);
}.call(this));
(function () {
  angular.module('app').controller('WorkCtrl', [
    '$rootScope',
    '$scope',
    '$location',
    '$window',
    '$routeParams',
    '$',
    '_',
    'GitHub',
    'Base64',
    'cookie',
    'GitHubAuthManager',
    function ($rootScope, $scope, $location, $window, $routeParams, $, _, github, base64, cookie, authManager) {
      var EVENT_CATEGORY, GITHUB_TOKEN_COOKIE_NAME, code, editor, isFullScreen, n, setFullScreen, steps, token, winHeight, winWidth, _i;
      EVENT_CATEGORY = 'work';
      ga('create', 'UA-41504069-1', 'geometryzen.org');
      ga('set', 'page', '/work');
      ga('send', 'pageview');
      authManager.handleLoginCallback(function (err, token) {
        if (err) {
          return $window.alert(err.message);
        }
      });
      GITHUB_TOKEN_COOKIE_NAME = 'github-token';
      token = cookie.getItem(GITHUB_TOKEN_COOKIE_NAME);
      $scope.messages = [];
      $scope.contextItem = {};
      $scope.contextGist = {};
      if ($routeParams.user && $routeParams.repo) {
        $scope.user = { login: $routeParams.user };
        $scope.repo = { name: $routeParams.repo };
        $scope.branch = { name: $routeParams.branch };
        steps = [];
        for (n = _i = 0; _i <= 6; n = ++_i) {
          if ($routeParams['step' + n]) {
            steps.push($routeParams['step' + n]);
          }
        }
        $scope.path = steps.join('/');
        $scope.contextItem.name = $routeParams.repo;
        $scope.contextItem.type = 'repo';
        github.getPathContents(token, $scope.user.login, $scope.repo.name, $scope.path, function (err, file) {
          var contextItem;
          if (!err) {
            contextItem = {
              name: file.name,
              path: file.path,
              sha: file.sha,
              type: file.type,
              parentItem: $scope.contextItem,
              childItems: []
            };
            $scope.contextItem = contextItem;
            if (file.encoding === 'base64') {
              return editor.setValue(base64.decode(file.content));
            } else {
              return alert('Unknown encoding: ' + file.encoding);
            }
          } else {
            return alert('Error retrieving the page');
          }
        });
      } else if ($routeParams.gistId) {
        github.getGist(token, $routeParams.gistId, function (err, gist) {
          if (!err) {
            $scope.contextGist = gist;
            $scope.contextItem.name = 'main.py';
            return editor.setValue(gist.files['main.py'].content);
          } else {
            return alert('Error retrieving the Gist.');
          }
        });
      } else {
        $scope.contextItem.name = 'Untitled';
        $scope.contextItem.type = void 0;
      }
      winHeight = function () {
        return $window.innerHeight || ($window.document.documentElement || $window.document.body).clientHeight;
      };
      winWidth = function () {
        return $window.innerWidth || ($window.document.documentElement || $window.document.body).clientWidth;
      };
      isFullScreen = function (cm) {
        return /\bCodeMirror-fullscreen\b/.test(cm.getWrapperElement().className);
      };
      setFullScreen = function (cm, full) {
        var wrapperElement;
        wrapperElement = cm.getWrapperElement();
        if (full) {
          wrapperElement.className += ' CodeMirror-fullscreen';
          wrapperElement.style.height = winHeight() + 'px';
          document.documentElement.style.overflow = 'hidden';
        } else {
          wrapperElement.className = wrapperElement.className.replace(' CodeMirror-fullscreen', '');
          wrapperElement.style.height = '600px';
          document.documentElement.style.overflow = '';
        }
        return cm.refresh();
      };
      code = document.getElementById('code');
      if (code) {
        editor = CodeMirror.fromTextArea(code, {
          'autofocus': false,
          'indentUnit': 4,
          'lineNumbers': true,
          'lineWrapping': true,
          'autoMatchParens': true,
          'parserConfig': {
            'pythonVersion': 2,
            'strictErrors': true
          },
          'theme': 'twilight',
          'extraKeys': {
            'Tab': function (cm) {
              var spaces;
              spaces = Array(cm.getOption('indentUnit') + 1).join(' ');
              return cm.replaceSelection(spaces, 'end', '+input');
            },
            'Ctrl-S': function (cm) {
              return $scope.saveFile();
            },
            'Ctrl-Enter': function (cm) {
              return $scope.run();
            }
          }
        });
      } else {
        alert('The code element could not be found');
      }
      $scope.run = function () {
        var e, message, name, prog, text;
        ga('send', 'event', EVENT_CATEGORY, 'run');
        $rootScope.$broadcast('reset');
        $scope.messages.length = 0;
        prog = editor.getValue();
        Sk.canvas = 'canvas';
        Sk.python3 = false;
        Sk.configure({
          'output': function (text) {
            return $rootScope.$broadcast('print', text);
          },
          'debugout': function (arg) {
            return console.log('' + JSON.stringify(arg, null, 2));
          },
          'read': function (searchPath) {
            if (Sk.builtinFiles === void 0 || Sk.builtinFiles['files'][searchPath] === void 0) {
              throw new Error('File not found: \'' + searchPath + '\'');
            } else {
              return Sk.builtinFiles['files'][searchPath];
            }
          }
        });
        if (prog.trim().length > 0) {
          try {
            return eval(Sk.importMainWithBody('<stdin>', false, prog.trim()));
          } catch (_error) {
            e = _error;
            if (typeof e !== 'undefined') {
              if (typeof e.toString === 'function') {
                message = e.toString();
                name = message.substring(0, message.indexOf(':'));
                text = message.substring(message.indexOf(':') + 1);
                return $scope.messages.push({
                  name: name,
                  text: text,
                  severity: 'error'
                });
              } else {
                return console.log(JSON.stringify(e, null, 2));
              }
            }
          }
        }
      };
      $scope.saveFile = function () {
        var content, data, description, files;
        ga('send', 'event', EVENT_CATEGORY, 'savePage');
        content = base64.encode(editor.getValue());
        if ($scope.user) {
          return github.putFile(token, $scope.user.login, $scope.repo.name, $scope.contextItem.path, 'Save file.', content, $scope.contextItem.sha, function (err, response, status, headers, config) {
            if (!err) {
              return $scope.contextItem.sha = response.content.sha;
            } else {
              return alert('Error saving file to repository. Cause: ' + err.message);
            }
          });
        } else {
          if ($scope.contextGist.id) {
            description = $scope.contextGist.description;
            files = { 'main.py': { content: editor.getValue() } };
            return github.patchGist(token, $scope.contextGist.id, {
              description: description,
              files: files
            }, function (err, response, status, headers, config) {
              if (!err) {
              } else {
                return alert('Error patching Gist. Cause: ' + err.message);
              }
            });
          } else {
            files = { 'main.py': { content: editor.getValue() } };
            data = {};
            data.description = 'GeometryZen Gist';
            data['public'] = true;
            data.files = files;
            return github.postGist(token, data, function (err, response, status, headers, config) {
              if (!err) {
                return $location.path('/gists/' + response.id);
              } else {
                return alert('Error posting Gist. Cause: ' + err.message);
              }
            });
          }
        }
      };
      $scope.homeBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active';
        } else {
          return '';
        }
      };
      $scope.userBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active';
        } else {
          return '';
        }
      };
      $scope.repoBreadcrumbClass = function () {
        if ($rootScope.breadcrumbStrategy.progressive) {
          return 'active';
        } else {
          if ($scope.workEnabled()) {
            return '';
          } else {
            return 'active';
          }
        }
      };
      $scope.repoEnabled = function () {
        return $scope.repo && $scope.repo.name;
      };
      $scope.workEnabled = function () {
        return $scope.contextItem && $scope.contextItem.type === 'file' || !($scope.repo && $scope.repo.name);
      };
      $scope.saveEnabled = function () {
        if ($scope.user) {
          return $scope.isLoggedIn() && $scope.userLogin() === $scope.user.login && $scope.contextItem && $scope.contextItem.type === 'file';
        } else {
          return true;
        }
      };
      $scope.runEnabled = function () {
        return $scope.workEnabled();
      };
      $scope.iconFromItem = function (item) {
        switch (item.type) {
        case 'file':
          return 'icon-file';
        case 'dir':
          return 'icon-dir';
        default:
          return 'icon-question';
        }
      };
      if (editor) {
        setFullScreen(editor, false);
      }
      CodeMirror.on($window, 'resize', function () {
        var showing;
        showing = $window.document.body.getElementsByClassName('CodeMirror-fullscreen')[0];
        if (showing) {
          return showing.CodeMirror.getWrapperElement().style.height = winHeight() + 'px';
        } else {
        }
      });
    }
  ]);
}.call(this));
(function () {
  var module;
  module = angular.module('app');
  module.directive('aHome', function () {
    return {
      restrict: 'E',
      replace: true,
      templateUrl: 'angular/a-home.html'
    };
  });
}.call(this));
(function () {
  angular.module('app').directive('githubAuthorize', function () {
    return {
      restrict: 'E',
      replace: true,
      templateUrl: 'angular/github-authorize.html'
    };
  });
}.call(this));
(function () {
  angular.module('app').directive('printer', function () {
    return {
      restrict: 'E',
      templateUrl: 'angular/printer.html'
    };
  });
}.call(this));
(function () {
  var module;
  module = angular.module('app');
  module.directive('userLinks', function () {
    return {
      restrict: 'E',
      replace: true,
      template: '<div class="user-links">\n  <a class="btn btn-secondary" ng-href="{{jumpHRef()}}">\n    <i class="{{jumpIcon()}}"/>\n    <span>{{jumpText()}}</span>\n  </a>\n  <button class="btn btn-secondary" ng-click="logout()" href="#" ng-show="isLoggedIn()">\n    <i class="icon-signout"></i>\n    <span>{{userLogin()}}</span>\n  </button>\n  <a class="btn btn-secondary" ng-hide="isLoggedIn()" ng-click="login()">\n    <i class="icon-signin"/>\n    <span>Sign in</span>\n  </a>\n</div>'
    };
  });
}.call(this));
(function () {
  var app;
  app = angular.module('app');
  app.config([
    '$routeProvider',
    '$locationProvider',
    function ($routeProvider, $locationProvider) {
      $routeProvider.when('/', {
        templateUrl: 'angular/home.html',
        controller: 'HomeCtrl'
      });
      $routeProvider.when('/workbench', {
        templateUrl: 'angular/work.html',
        controller: 'WorkCtrl'
      });
      $routeProvider.when('/gists/:gistId', {
        templateUrl: 'angular/work.html',
        controller: 'WorkCtrl'
      });
      $routeProvider.when('/embed/users/:user/repos/:repo/blob/:branch/:step0/:step1/:step2/:step3/:step4', {
        templateUrl: 'angular/embed.html',
        controller: 'EmbedCtrl'
      });
      $routeProvider.when('/embed/users/:user/repos/:repo/blob/:branch/:step0/:step1/:step2/:step3', {
        templateUrl: 'angular/embed.html',
        controller: 'EmbedCtrl'
      });
      $routeProvider.when('/embed/users/:user/repos/:repo/blob/:branch/:step0/:step1/:step2', {
        templateUrl: 'angular/embed.html',
        controller: 'EmbedCtrl'
      });
      $routeProvider.when('/embed/users/:user/repos/:repo/blob/:branch/:step0/:step1', {
        templateUrl: 'angular/embed.html',
        controller: 'EmbedCtrl'
      });
      $routeProvider.when('/embed/users/:user/repos/:repo/blob/:branch/:step0', {
        templateUrl: 'angular/embed.html',
        controller: 'EmbedCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/blob/:branch/:step0/:step1/:step2/:step3/:step4', {
        templateUrl: 'angular/work.html',
        controller: 'WorkCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/blob/:branch/:step0/:step1/:step2/:step3', {
        templateUrl: 'angular/work.html',
        controller: 'WorkCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/blob/:branch/:step0/:step1/:step2', {
        templateUrl: 'angular/work.html',
        controller: 'WorkCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/blob/:branch/:step0/:step1', {
        templateUrl: 'angular/work.html',
        controller: 'WorkCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/blob/:branch/:step0', {
        templateUrl: 'angular/work.html',
        controller: 'WorkCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/tree/:branch/:step0/:step1/:step2/:step3/:step4', {
        templateUrl: 'angular/tree.html',
        controller: 'TreeCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/tree/:branch/:step0/:step1/:step2/:step3', {
        templateUrl: 'angular/tree.html',
        controller: 'TreeCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/tree/:branch/:step0/:step1/:step2', {
        templateUrl: 'angular/tree.html',
        controller: 'TreeCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/tree/:branch/:step0/:step1', {
        templateUrl: 'angular/tree.html',
        controller: 'TreeCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/tree/:branch/:step0', {
        templateUrl: 'angular/tree.html',
        controller: 'TreeCtrl'
      });
      $routeProvider.when('/users/:user/repos/:repo/tree/:branch', {
        templateUrl: 'angular/tree.html',
        controller: 'TreeCtrl'
      });
      $routeProvider.when('/users/:user', {
        templateUrl: 'angular/user.html',
        controller: 'UserCtrl'
      });
      $routeProvider.otherwise({ redirectTo: '/' });
      return $locationProvider.html5Mode(true);
    }
  ]);
}.call(this));
(function () {
  var _keyStr, _utf8_decode, _utf8_encode;
  _keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
  _utf8_decode = function (utftext) {
    var c, c1, c2, c3, i, string;
    string = '';
    i = 0;
    c = c1 = c2 = 0;
    while (i < utftext.length) {
      c = utftext.charCodeAt(i);
      if (c < 128) {
        string += String.fromCharCode(c);
        i++;
      } else if (c > 191 && c < 224) {
        c2 = utftext.charCodeAt(i + 1);
        string += String.fromCharCode((c & 31) << 6 | c2 & 63);
        i += 2;
      } else {
        c2 = utftext.charCodeAt(i + 1);
        c3 = utftext.charCodeAt(i + 2);
        string += String.fromCharCode((c & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
        i += 3;
      }
    }
    return string;
  };
  _utf8_encode = function (string) {
    var c, n, utftext, _i, _ref;
    string = string.replace(/\r\n/g, '\n');
    utftext = '';
    for (n = _i = 0, _ref = string.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; n = 0 <= _ref ? ++_i : --_i) {
      c = string.charCodeAt(n);
      if (c < 128) {
        utftext += String.fromCharCode(c);
      } else if (c > 127 && c < 2048) {
        utftext += String.fromCharCode(c >> 6 | 192);
        utftext += String.fromCharCode(c & 63 | 128);
      } else {
        utftext += String.fromCharCode(c >> 12 | 224);
        utftext += String.fromCharCode(c >> 6 & 63 | 128);
        utftext += String.fromCharCode(c & 63 | 128);
      }
    }
    return utftext;
  };
  angular.module('app').factory('Base64', [
    '$window',
    function ($window) {
      return {
        decode: function (input) {
          var chr1, chr2, chr3, enc1, enc2, enc3, enc4, i, output;
          output = '';
          i = 0;
          input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
          while (i < input.length) {
            enc1 = _keyStr.indexOf(input.charAt(i++));
            enc2 = _keyStr.indexOf(input.charAt(i++));
            enc3 = _keyStr.indexOf(input.charAt(i++));
            enc4 = _keyStr.indexOf(input.charAt(i++));
            chr1 = enc1 << 2 | enc2 >> 4;
            chr2 = (enc2 & 15) << 4 | enc3 >> 2;
            chr3 = (enc3 & 3) << 6 | enc4;
            output = output + String.fromCharCode(chr1);
            if (enc3 !== 64) {
              output = output + String.fromCharCode(chr2);
            }
            if (enc4 !== 64) {
              output = output + String.fromCharCode(chr3);
            }
          }
          output = _utf8_decode(output);
          return output;
        },
        encode: function (input) {
          var chr1, chr2, chr3, enc1, enc2, enc3, enc4, i, output;
          output = '';
          i = 0;
          input = _utf8_encode(input);
          while (i < input.length) {
            chr1 = input.charCodeAt(i++);
            chr2 = input.charCodeAt(i++);
            chr3 = input.charCodeAt(i++);
            enc1 = chr1 >> 2;
            enc2 = (chr1 & 3) << 4 | chr2 >> 4;
            enc3 = (chr2 & 15) << 2 | chr3 >> 6;
            enc4 = chr3 & 63;
            if (isNaN(chr2)) {
              enc3 = enc4 = 64;
            } else if (isNaN(chr3)) {
              enc4 = 64;
            }
            output = output + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4);
          }
          return output;
        }
      };
    }
  ]);
}.call(this));
(function () {
  angular.module('app').factory('GitHub', [
    '$http',
    function ($http) {
      var GITHUB_DOMAIN, GITHUB_PROTOCOL, Gist, HTTP_METHOD_DELETE, HTTP_METHOD_GET, HTTP_METHOD_PATCH, HTTP_METHOD_POST, HTTP_METHOD_PUT, Repo, User;
      GITHUB_PROTOCOL = 'https';
      GITHUB_DOMAIN = 'api.github.com';
      HTTP_METHOD_DELETE = 'DELETE';
      HTTP_METHOD_GET = 'GET';
      HTTP_METHOD_PATCH = 'PATCH';
      HTTP_METHOD_POST = 'POST';
      HTTP_METHOD_PUT = 'PUT';
      User = function () {
        function User(name, login) {
          this.name = name;
          this.login = login;
        }
        return User;
      }();
      Gist = function () {
        function Gist(id, description, isPublic, files, html_url) {
          this.id = id;
          this.description = description;
          this['public'] = isPublic;
          this.files = files;
          this.html_url = html_url;
        }
        return Gist;
      }();
      Repo = function () {
        function Repo(name, description, language, html_url) {
          this.name = name;
          this.description = description;
          this.language = language;
          this.html_url = html_url;
        }
        return Repo;
      }();
      return {
        getUser: function (token, done) {
          var headers;
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            method: HTTP_METHOD_GET,
            url: '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/user',
            headers: headers
          }).success(function (user, status, headers, config) {
            return done(null, new User(user.name, user.login), status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        getUserRepos: function (token, done) {
          var headers;
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            method: HTTP_METHOD_GET,
            url: '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/user/repos',
            headers: headers
          }).success(function (repos, status, headers, config) {
            repos = _.map(repos, function (repo) {
              return new Repo(repo.name, repo.description, repo.language, repo.html_url);
            });
            return done(null, repos, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        getRepoContents: function (token, user, repo, done) {
          var url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/repos/' + user + '/' + repo + '/contents';
          return $http({
            'method': HTTP_METHOD_GET,
            'url': url,
            'headers': { Authorization: 'token ' + token }
          }).success(function (contents, status, headers, config) {
            return done(null, contents, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        getPathContents: function (token, user, repo, path, done) {
          var headers, url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/repos/' + user + '/' + repo + '/contents';
          if (path) {
            url = '' + url + '/' + path;
          }
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            'method': HTTP_METHOD_GET,
            'url': url,
            'headers': headers
          }).success(function (contents, status, headers, config) {
            return done(null, contents, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        putFile: function (token, owner, repo, path, message, content, sha, done) {
          var data, headers, url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/repos/' + owner + '/' + repo + '/contents/' + path;
          data = {
            message: message,
            content: content
          };
          if (sha) {
            data.sha = sha;
          }
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            method: HTTP_METHOD_PUT,
            url: url,
            data: data,
            headers: headers
          }).success(function (file, status, headers, config) {
            return done(null, file, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        deleteFile: function (token, owner, repo, path, message, sha, done) {
          var data, url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/repos/' + owner + '/' + repo + '/contents/' + path;
          data = {
            message: message,
            sha: sha
          };
          return $http({
            method: HTTP_METHOD_DELETE,
            url: url,
            data: data,
            headers: { Authorization: 'token ' + token }
          }).success(function (file, status, headers, config) {
            return done(null, file, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        postRepo: function (token, name, description, priv, autoInit, done) {
          var data, headers, url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/user/repos';
          data = {
            name: name,
            description: description,
            'private': priv,
            auto_init: autoInit
          };
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            method: HTTP_METHOD_POST,
            url: url,
            data: data,
            headers: headers
          }).success(function (repo, status, headers, config) {
            return done(null, repo, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        deleteRepo: function (token, owner, repo, done) {
          var url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/repos/' + owner + '/' + repo;
          return $http({
            method: HTTP_METHOD_DELETE,
            url: url,
            headers: { Authorization: 'token ' + token }
          }).success(function (repo, status, headers, config) {
            return done(null, repo, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        getGist: function (token, id, done) {
          var headers, url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/gists/' + id;
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            'method': HTTP_METHOD_GET,
            'url': url,
            'headers': headers
          }).success(function (contents, status, headers, config) {
            return done(null, contents, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        patchGist: function (token, gistId, data, done) {
          var headers, url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/gists/' + gistId;
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            method: HTTP_METHOD_PATCH,
            url: url,
            data: data,
            headers: headers
          }).success(function (file, status, headers, config) {
            return done(null, file, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        postGist: function (token, data, done) {
          var headers, url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/gists';
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            method: HTTP_METHOD_POST,
            url: url,
            data: data,
            headers: headers
          }).success(function (response, status, headers, config) {
            return done(null, response, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        deleteGist: function (token, owner, id, done) {
          var url;
          url = '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/gists/' + id;
          return $http({
            method: HTTP_METHOD_DELETE,
            url: url,
            headers: { Authorization: 'token ' + token }
          }).success(function (response, status, headers, config) {
            return done(null, response, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        getUserGists: function (token, user, done) {
          var headers;
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            method: HTTP_METHOD_GET,
            url: '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/users/' + user + '/gists',
            headers: headers
          }).success(function (gists, status, headers, config) {
            gists = _.map(gists, function (gist) {
              return gist;
            });
            return done(null, gists, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        },
        getGists: function (token, done) {
          var headers;
          headers = token ? { 'Authorization': 'token ' + token } : {};
          return $http({
            method: HTTP_METHOD_GET,
            url: '' + GITHUB_PROTOCOL + '://' + GITHUB_DOMAIN + '/gists',
            headers: headers
          }).success(function (gists, status, headers, config) {
            console.log;
            gists = _.map(gists, function (gist) {
              return new Gist(gist.id, gist.description, gist['public'], gist.files, gist.html_url);
            });
            return done(null, gists, status, headers, config);
          }).error(function (response, status, headers, config) {
            return done(new Error(response.message), response, status, headers, config);
          });
        }
      };
    }
  ]);
}.call(this));
(function () {
  var module;
  module = angular.module('app');
  module.service('GitHubAuthManager', [
    '$http',
    '$location',
    '$window',
    'cookie',
    'GitHub',
    function ($http, $location, $window, cookie, github) {
      return this.handleLoginCallback = function (done) {
        var GATEKEEPER_DOMAIN, GITHUB_LOGIN_COOKIE_NAME, GITHUB_TOKEN_COOKIE_NAME, code, match;
        GATEKEEPER_DOMAIN = '' + $location.protocol() + '://' + $location.host() + ':' + $location.port();
        GITHUB_TOKEN_COOKIE_NAME = 'github-token';
        GITHUB_LOGIN_COOKIE_NAME = 'github-login';
        match = $window.location.href.match(/\?code=([a-z0-9]*)/);
        if (match) {
          $location.search({});
          code = match[1];
          return $http.get('' + GATEKEEPER_DOMAIN + '/authenticate/' + code).success(function (data, status, headers, config) {
            var token;
            token = data.token;
            cookie.setItem(GITHUB_TOKEN_COOKIE_NAME, token);
            return github.getUser(token, function (error, user) {
              if (!error) {
                cookie.setItem(GITHUB_LOGIN_COOKIE_NAME, user.login);
                return done(null, token);
              } else {
                return done(new Error('Unable to retrieve your user information.'));
              }
            });
          }).error(function (data, status, headers, config) {
            return done(new Error('Unable to retrieve your authentication token.'));
          });
        } else if ($window.location.href.match(/\?error=access_denied/)) {
          return $location.search({});
        }
      };
    }
  ]);
}.call(this));
(function () {
  var module;
  module = angular.module('async', []);
  module.factory('async', [
    '$window',
    function ($window) {
      return $window.async;
    }
  ]);
}.call(this));
(function () {
  angular.module('app').factory('cookie', [function () {
      return {
        getItem: function (name) {
          var escapedName;
          escapedName = escape(name).replace(/[\-\.\+\*]/g, '\\$&');
          return unescape(document.cookie.replace(new RegExp('(?:(?:^|.*;)\\s*' + escapedName + '\\s*\\=\\s*([^;]*).*$)|^.*$'), '$1')) || null;
        },
        setItem: function (name, value, end, path, domain, secure) {
          var cookie, expires;
          if (!name || /^(?:expires|max\-age|path|domain|secure)$/i.test(name)) {
            throw new Error('Illegal name');
          }
          if (end) {
            switch (end.constructor) {
            case Number:
              expires = end === Infinity ? '; expires=Fri, 31 Dec 9999 23:59:59 GMT' : '; max-age=' + end;
              break;
            case String:
              expires = '; expires=' + end;
              break;
            case Date:
              expires = '; expires=' + end.toGMTString();
              break;
            default:
              expires = '';
            }
          } else {
            expires = '';
          }
          domain = domain ? '; domain=' + domain : '';
          path = path ? '; path=' + path : '';
          secure = secure ? '; secure' : '';
          cookie = '' + escape(name) + '=' + escape(value) + expires + domain + path + secure;
          document.cookie = cookie;
        },
        removeItem: function (name, path) {
          if (!name || !this.hasItem(name)) {
            return false;
          }
          return this.setItem(name, '', new Date(0), path);
        },
        hasItem: function (name) {
          return new RegExp('(?:^|;\\s*)' + escape(name).replace(/[\-\.\+\*]/g, '\\$&') + '\\s*\\=').test(document.cookie);
        }
      };
    }]);
}.call(this));
(function () {
  var locale_data_multi;
  locale_data_multi = {
    'messages_3': {
      '': {
        domain: 'messages_3',
        lang: 'en',
        'plural-forms': 'nplurals=2; plural=(n != 1);'
      },
      'test': [
        null,
        'test_1'
      ],
      'test singular': [
        'test plural',
        'test_1 singular',
        'test_1 plural'
      ],
      'context\x04test': [
        null,
        'test_1 context'
      ],
      'context\x04test singular': [
        'test context plural',
        'test_1 context singular',
        'test_1 context plural'
      ]
    },
    'messages_4': {
      '': {
        domain: 'messages_4',
        lang: 'en',
        'plural-forms': 'nplurals=2; plural=(n != 1);'
      },
      'test': [
        null,
        'test_2'
      ],
      'test singular': [
        'test plural',
        'test_2 singular',
        'test_2 plural'
      ],
      'context\x04test': [
        null,
        'test_2 context'
      ],
      'context\x04test singular': [
        'test context plural',
        'test_2 context singular',
        'test_2 context plural'
      ]
    }
  };
  angular.module('jed', []).factory('i18n', [
    '$window',
    function (w) {
      return new w.Jed({
        domain: 'the_domain',
        missing_key_callback: function (key) {
          return console.log(key);
        },
        locale_data: {
          'the_domain': {
            '': {
              domain: 'the_domain',
              lang: 'en',
              'plural-forms': 'nplurals=2; plural=(n != 1);'
            },
            'Create a New Gist': [
              null,
              'Create a New Gist'
            ],
            'Create gist': [
              null,
              'Create gist'
            ],
            'Gist': [
              null,
              'Gist',
              'Gists'
            ],
            'Gist name': [
              null,
              'Gist name'
            ],
            'My Gist': [
              null,
              'My Gist',
              'My Gists'
            ],
            'Great gist names are short and memorable.': [
              null,
              'Great gist names are short and memorable.'
            ],
            'Initialize this gist with a README.md': [
              null,
              'Initialize this gist with a README.md'
            ],
            'This will allow you to clone the gist immediately in GitHub.': [
              null,
              'This will allow you to clone the gist immediately in GitHub.'
            ],
            'Create a New Repo': [
              null,
              'Create a New Repository'
            ],
            'Create repo': [
              null,
              'Create repository'
            ],
            'Repo': [
              null,
              'Repository',
              'Repositories'
            ],
            'Repo name': [
              null,
              'Repository name'
            ],
            'My Repo': [
              null,
              'My Repository',
              'My Repository'
            ],
            'Great repo names are short and memorable.': [
              null,
              'Great repository names are short and memorable.'
            ],
            'Initialize this repo with a README.md': [
              null,
              'Initialize this repository with a README.md'
            ],
            'This will allow you to clone the repo immediately in GitHub.': [
              null,
              'This will allow you to clone the repository immediately in GitHub.'
            ],
            'Create a New File': [
              null,
              'Create a New File'
            ],
            'Create file': [
              null,
              'Create file'
            ],
            'File': [
              null,
              'File',
              'Files'
            ],
            'File name': [
              null,
              'File name'
            ],
            'My Space': [
              null,
              'My Universe'
            ],
            'icon-gist': [
              null,
              'icon-briefcase'
            ],
            'icon-repo': [
              null,
              'icon-briefcase'
            ],
            'icon-dir': [
              null,
              'icon-book'
            ],
            'icon-file': [
              null,
              'icon-file-alt'
            ],
            'icon-question': [
              null,
              'icon-question'
            ]
          }
        }
      });
    }
  ]);
}.call(this));
(function () {
  angular.module('jquery', []).factory('$', [
    '$window',
    function ($window) {
      return $window.$;
    }
  ]);
}.call(this));
(function () {
  angular.module('underscore', []).factory('_', [
    '$window',
    function ($window) {
      return $window._;
    }
  ]);
}.call(this));
angular.module('app').run([
  '$templateCache',
  function ($templateCache) {
    $templateCache.put('angular/a-home.html', '<a href="/">\n' + '  <i class="icon-home"></i>\n' + '  <span>Home</span>\n' + '</a>\n');
    $templateCache.put('angular/embed.html', '<div id="embed-view">\n' + '  <div class="subnavbar">\n' + '    <div class="subnavbar-inner">\n' + '      <div class="container">\n' + '        <a class="btn-subnavbar collapsed" data-toggle="collapse" data-target=".subnav-collapse">\n' + '          <i class="icon-reorder"></i>\n' + '        </a>\n' + '        <div class="subnav-collapse collapse">\n' + '          <ul class="mainnav">\n' + '            <!--\n' + '            <li ng-show="isLoggedIn()" class="{{userBreadcrumbClass()}}">\n' + '              <a ng-href="/users/{{user.name}}">\n' + '                <i class="icon-user"></i>\n' + '                <span>{{i18n.translate("My Space").fetch()}}</span>\n' + '              </a>\n' + '            </li>\n' + '            -->\n' + '            <!--\n' + '            <li class="active">\n' + '              <a ng-click="reload()" href="#">\n' + '                <i class="icon-edit"></i>\n' + '                <span>Workbench</span>\n' + '              </a>\n' + '            </li>\n' + '            -->\n' + '            <!--\n' + '            <li ng-show="saveEnabled()">\n' + '              <a ng-click="saveFile()" href="#">\n' + '                <i class="icon-save"></i>\n' + '                <span>Save</span>\n' + '              </a>\n' + '            </li>\n' + '            -->\n' + '            <li ng-show="runEnabled()">\n' + '              <a ng-click="run()" href="#">\n' + '                <i class="icon-cogs"></i>\n' + '                <span>Run</span>\n' + '              </a>\n' + '            </li>\n' + '            <li class="dropdown">\n' + '              <a href="javascript:;" class="dropdown-toggle" data-toggle="dropdown">\n' + '                <i class="icon-book"></i>\n' + '                <span>Help</span>\n' + '                <b class="caret"></b>\n' + '              </a>\n' + '              <ul class="dropdown-menu">\n' + '                <li><a href="https://docs.python.org/3.4/" target="_blank">Python documentation</a></li>\n' + '                <li><a href="http://docs.scipy.org/doc/" target="_blank">Numpy documentation</a></li>\n' + '                <li><a href="http://threejs.org/docs/" target="_blank">three.js documentation</a></li>\n' + '                <li><a href="http://jsxgraph.uni-bayreuth.de/wp/documentation/" target="_blank">JSXGraph documentation</a></li>\n' + '              </ul>\n' + '            </li>\n' + '          </ul>\n' + '        </div>\n' + '      </div>\n' + '    </div>\n' + '  </div>\n' + '  \n' + '  <div id="embed-layout" class="container-fluid">\n' + '\n' + '    <div class="row-fluid">\n' + '      <div class="span7">\n' + '        <div class="alert alert-block alert-{{message.severity}}" ng-repeat="message in messages"  ng-show="messages.length &gt; 0">\n' + '          <button type="button" class="close" data-dismiss="alert">&times;</button>\n' + '          <h4>{{message.name}}</h4>\n' + '          {{message.text}}\n' + '        </div>\n' + '        <div id="textarea-container">\n' + '          <textarea id="code"></textarea>\n' + '        </div>\n' + '      </div>\n' + '      <div class="span5">\n' + '        <div id="printer-container">\n' + '          <printer></printer>\n' + '        </div>\n' + '        <div id="graph-container">\n' + '          <div id="box" class="jxgbox" style="width:600px; height:600px;"></div>\n' + '        </div>\n' + '        <div id="canvas-container">\n' + '        </div>\n' + '      </div>\n' + '    </div>\n' + '\n' + '  </div>\n' + '</div>');
    $templateCache.put('angular/github-authorize.html', '<li>\n' + '  <!-- When logged out, present the user with an OAuth link-->\n' + '  <a ng-hide="isLoggedIn()" ng-href="https://github.com/login/oauth/authorize?client_id={{clientId()}}&amp;scope=repo,user,gist">\n' + '    <i class="icon-signin"></i>\n' + '    <span>Log In</span>\n' + '  </a>\n' + '\n' + '  <!-- TODO: When logged in, we would like to have a dropdown menu-->\n' + '  <a ng-show="isLoggedIn()" ng-click="logout()" href="#">\n' + '    <i class="icon-signout icon-white"></i>\n' + '    <span>{{userLogin()}}</span>\n' + '  </a>\n' + '</li>');
    $templateCache.put('angular/home.html', '<div id="home-view">\n' + '  <div class="subnavbar">\n' + '    <div class="subnavbar-inner">\n' + '      <div class="container">\n' + '        <a class="btn-subnavbar collapsed" data-toggle="collapse" data-target=".subnav-collapse">\n' + '          <i class="icon-reorder"></i>\n' + '        </a>\n' + '        <div class="subnav-collapse collapse">\n' + '          <ul class="mainnav">\n' + '            <li class="active">\n' + '              <a-home></a-home>\n' + '            </li>\n' + '            <li ng-show="isLoggedIn()">\n' + '              <a ng-href="/users/{{userLogin()}}">\n' + '                <i class="icon-user"></i>\n' + '                <span>{{i18n.translate("My Space").fetch()}}</span>\n' + '              </a>\n' + '            </li>\n' + '            <li class="dropdown">\n' + '              <a href="javascript:;" class="dropdown-toggle" data-toggle="dropdown">\n' + '                <i class="icon-eye-open"></i>\n' + '                <span>Learn</span>\n' + '                <b class="caret"></b>\n' + '              </a>\n' + '              <ul class="dropdown-menu">\n' + '                <li><a href="http://geometryzen.github.io/mission/" target="_blank">Our Mission</a></li>\n' + '                <li><a href="/users/geometryzen/repos/demos/tree/master">Browse Examples</a></li>\n' + '                <li><a href="http://geometryzen.github.io/start/" target="_blank">Getting Started</a></li>\n' + '              </ul>\n' + '            </li>\n' + '            <li class="dropdown">\n' + '              <a href="javascript:;" class="dropdown-toggle" data-toggle="dropdown">\n' + '                <i class="icon-external-link"></i>\n' + '                <span>Discuss</span>\n' + '                <b class="caret"></b>\n' + '              </a>\n' + '              <ul class="dropdown-menu">\n' + '                <li><a href="http://groups.google.com/group/geometryzen?src=email&amp;hl=en" target="_blank">Mailing List</a></li>\n' + '                <li><a href="http://webchat.freenode.net/?channels=geometryzen&amp;uio=d4" target="_blank">Web Chat</a></li>\n' + '                <li class="divider"></li>\n' + '                <li><a href="https://twitter.com/#!/geometryzen" target="_blank">Twitter</a></li>\n' + '                <li><a href="https://plus.google.com/u/0/s/Geometry%20Zen/communities" target="_blank">Google+</a></li>\n' + '                <li class="divider"></li>\n' + '                <li class="dropdown-submenu">\n' + '                  <a href="#">Source Code</a>\n' + '                  <ul class="dropdown-menu">\n' + '                    <li><a href="https://github.com/david-geo-holmes/geometry-zen" target="_blank">Application Repository</a></li>\n' + '                    <li><a href="https://github.com/geometryzen/geometryzen.github.io" target="_blank">Documentation Repository</a></li>\n' + '                  </ul>\n' + '                </li>\n' + '                <li class="divider"></li>\n' + '                <li><a href="https://github.com/geometryzen/geometryzen/issues" target="_blank">Issue Tracker</a></li>\n' + '              </ul>\n' + '            </li>\n' + '            <li>\n' + '              <a href="http://geometryzen.github.io/faq/" target="_blank" style="text-decoration: none">\n' + '                <i class="icon-question-sign"></i>\n' + '                <span>FAQ</span>\n' + '              </a>\n' + '            </li>\n' + '            <li>\n' + '              <a href="http://geometryzen.github.io/" target="_blank" style="text-decoration: none">\n' + '                <i class="icon-book"></i>\n' + '                <span>Pages</span>\n' + '              </a>\n' + '            </li>\n' + '          </ul>\n' + '        </div>\n' + '      </div>\n' + '    </div>\n' + '  </div>\n' + '\n' + '  <div class="container-fluid">\n' + '    <div class="row-fluid">\n' + '      <div class="span12">\n' + '        <div class="widget">\n' + '          <div class="widget-content">\n' + '            <div class="text-center">\n' + '              <h1>\n' + '                <large>Geometry Zen</large>\n' + '              </h1>\n' + '              <h1>\n' + '                <small><em>Educational Computational Physics, Modeling and Geometry</em></small>\n' + '              </h1>\n' + '              <br/>\n' + '              <p><em>Geometry Zen</em> is a free, online, open-source, and collaborative tool for <em>Educational Computational Physics, Modeling and Geometry</em> combining the <em>Python</em> programming language, <em>3D visualization</em> (WebGL), <em>Physical Units</em>, and <em>Geometric Algebra</em>, the <em>Unified Mathematical Language for Physics and Engineering in the 21st Century</em>.</p>\n' + '              <p></p>\n' + '              <br/>\n' + '            </div>\n' + '            <div class="text-center">\n' + '              <a href="/users/geometryzen/repos/demos/tree/master" class="btn btn-primary">\n' + '                <i class="icon-th"></i>\n' + '                <span>Browse Examples</span>\n' + '              </a>\n' + '              <a href="{{jumpHRef()}}" class="btn btn-secondary">\n' + '                <i class="{{jumpIcon()}}"></i>\n' + '                <span>{{jumpText()}}</span>\n' + '              </a>\n' + '            </div>\n' + '            <hr/>\n' + '            <div class="text-center">\n' + '\n' + '              <h3>Example: Introduction to Functions with Units (units, numpy, JSXGraph)</h3>\n' + '              <iframe width="1000" height="760" src="http://www.geometryzen.org/embed/users/geometryzen/repos/demos/blob/master/Modeling/functions/intro.py" frameborder="0">\n' + '              </iframe>\n' + '              <hr/>\n' + '              <div class="text-right">\n' + '                <blockquote>\n' + '                  <p class="muted">Science is what we understand well enough to explain to a computer.<br/>Art is everything else we do.</p>\n' + '                  <small>Donald Knuth</small>\n' + '                </blockquote>\n' + '              </div>\n' + '              <hr/>\n' + '\n' + '              <h3>Example: Introduction to Vectors (e2ga, MathJax, JSXGraph) Press Esc to quit</h3>\n' + '              <iframe width="1000" height="760" src="http://www.geometryzen.org/embed/users/geometryzen/repos/demos/blob/master/Modeling/vectors/intro.py" frameborder="0">\n' + '              </iframe>\n' + '              <hr/>\n' + '              <div class="text-right">\n' + '                <blockquote>\n' + '                  <p class="muted">The purpose of computing is insight, not numbers!</p>\n' + '                  <small>Richard Wesley Hamming</small>\n' + '                </blockquote>\n' + '              </div>\n' + '              <hr/>\n' + '\n' + '              <h3>Example: Simple Harmonic Motion using Euler (e3ga, numpy, JSXGraph)</h3>\n' + '              <iframe width="1000" height="760" src="http://www.geometryzen.org/embed/users/geometryzen/repos/demos/blob/master/Modeling/ode/euler.py" frameborder="0">\n' + '              </iframe>\n' + '              <hr/>\n' + '              <div class="text-right">\n' + '                <blockquote>\n' + '                  <p class="muted">What I cannot create, I do not understand.</p>\n' + '                  <small>Richard Phillips Feynmann</small>\n' + '                </blockquote>\n' + '              </div>\n' + '              <hr/>\n' + '\n' + '              <h3>Example: Damped Simple Harmonic Motion using RK4 (e3ga, units, numpy, JSXGraph)</h3>\n' + '              <iframe width="1000" height="760" src="http://www.geometryzen.org/embed/users/geometryzen/repos/demos/blob/master/Modeling/ode/runge-kutta-4-with-units.py" frameborder="0">\n' + '              </iframe>\n' + '              <hr/>\n' + '              <div class="text-right">\n' + '                <blockquote>\n' + '                  <p class="muted">There is no science in this world like physics. Nothing comes close to the precision with which physics enables you to understand the world around you.</p>\n' + '                  <small>Neil deGrasse Tyson</small>\n' + '                </blockquote>\n' + '              </div>\n' + '              <hr/>\n' + '\n' + '              <h3>Example: Charged Particle near a Wire (e3ga, three) Press Esc to quit</h3>\n' + '              <iframe width="1000" height="760" src="http://www.geometryzen.org/embed/users/geometryzen/repos/demos/blob/master/Physics/charged-particle-wire-2.py" frameborder="0">\n' + '              </iframe>\n' + '              <hr/>\n' + '              <div class="text-right">\n' + '                <blockquote>\n' + '                  <p class="muted">If I have not seen as far as others, it is because \n' + '     giants were standing on my shoulders.</p>\n' + '                  <small>Hal Abelson</small>\n' + '                </blockquote>\n' + '              </div>\n' + '              <hr/>\n' + '\n' + '              <h3>Example: Mouse Tracking for fun (d3py) Press Esc to quit</h3>\n' + '              <iframe width="1000" height="760" src="http://www.geometryzen.org/embed/users/geometryzen/repos/demos/blob/master/D3/basic.py" frameborder="0">\n' + '              </iframe>\n' + '            </div>\n' + '            <div class="text-center">\n' + '              <a href="/users/geometryzen/repos/demos/tree/master" class="btn btn-primary">\n' + '                <i class="icon-th"></i>\n' + '                <span>Browse Examples</span>\n' + '              </a>\n' + '              <a href="{{jumpHRef()}}" class="btn btn-secondary">\n' + '                <i class="{{jumpIcon()}}"></i>\n' + '                <span>{{jumpText()}}</span>\n' + '              </a>\n' + '            </div>\n' + '          </div>\n' + '        </div>\n' + '      </div>\n' + '    </div>\n' + '  </div>\n' + '</div>\n');
    $templateCache.put('angular/printer.html', '<div ng-controller="PrinterCtrl" class="container-fluid">\n' + '  <div class="row-fluid">\n' + '    <div class="span12">\n' + '      <!-- Using anything other than a pre(serve) element is likely too be slow -->\n' + '      <!-- PRESERVE_ELEMENT_ID is defined in the printer controller -->\n' + '      <pre id="a5f435e0-c92e-11e2-8b8b-0800200c9a66" class="printer"></pre>\n' + '    </div>\n' + '  </div>\n' + '</div>\n' + '\n');
    $templateCache.put('angular/tree.html', '<div id="repo-view">\n' + '\n' + '  <div class="subnavbar">\n' + '    <div class="subnavbar-inner">\n' + '      <div class="container">\n' + '        <a class="btn-subnavbar collapsed" data-toggle="collapse" data-target=".subnav-collapse">\n' + '          <i class="icon-reorder"></i>\n' + '        </a>\n' + '        <div class="subnav-collapse collapse">\n' + '          <ul class="mainnav">\n' + '            <li ng-show="isLoggedIn()" class="{{userBreadcrumbClass()}}">\n' + '              <a ng-href="/users/{{user.login}}">\n' + '                <i class="icon-user"></i>\n' + '                <span>{{i18n.translate("My Space").fetch()}}</span>\n' + '              </a>\n' + '            </li>\n' + '            <li class="{{repoBreadcrumbClass()}}">\n' + '              <a ng-click="bookView()" href="#">\n' + '                <i class="{{i18n.translate(\'icon-repo\').fetch()}}"></i>\n' + '                <span>{{i18n.translate("Repo").fetch()}}</span>\n' + '              </a>\n' + '            </li>\n' + '          </ul>\n' + '        </div>\n' + '      </div>\n' + '    </div>\n' + '  </div>\n' + '  \n' + '  <div id="work-layout" class="container-fluid">\n' + '    <div class="row-fluid">\n' + '      <div class="widget">\n' + '        <div class="widget-header">\n' + '          <i class="{{i18n.translate(\'icon-repo\').fetch()}}"></i>\n' + '          <h3>{{repo.name}}</h3>\n' + '        </div>\n' + '        <div class="widget-content">\n' + '          <div>\n' + '            <!--\n' + '            <i class="icon-user muted"></i>\n' + '            <span><a ng-href="/users/{{user.login}}">{{user.login}}</a></span>\n' + '            -->\n' + '            <!--\n' + '            <a ng-href="https://github.com/{{user.login}}" target="_blank" class="muted">\n' + '              <i class="icon-github"></i>\n' + '            </a>\n' + '            -->\n' + '            <span>{{repo.description}}</span>\n' + '          </div>\n' + '          <ul class="nav nav-tabs" id="myTab">\n' + '            <li><a data-target="#items" data-toggle="tab">{{i18n.translate(\'File\').ifPlural(2, \'Files\').fetch()}}</a></li>\n' + '            <!--li><a data-target="#commits" data-toggle="tab">Commits</a></li-->\n' + '            <!--li><a data-target="#branches" data-toggle="tab">Branches</a></li-->\n' + '          </ul>\n' + '          <div class="tab-content">\n' + '            <div class="tab-pane" id="items">\n' + '              <div class ="row-fluid">\n' + '                <table class="table table-condensed">\n' + '                  <tbody>\n' + '                    <tr ng-show="isNewFileEnabled()">\n' + '                      <td nowrap=nowrap>\n' + '                        <!--input type="text" placeHolder="Filter..."></input-->\n' + '                      </td>\n' + '                      <td nowrap=nowrap>\n' + '                        <button ng-click="newFile()" ng-show="isNewFileEnabled()" class="btn btn-primary">\n' + '                          <i class="icon-plus-sign-alt"></i> <i class="{{i18n.translate(\'icon-file\').fetch()}}"></i>\n' + '                          <span>{{i18n.translate("Create a New File").fetch()}}</span>\n' + '                        </button>\n' + '                      </td>\n' + '                    </tr>\n' + '                    <!-- Reminder: An item is a book or a page -->\n' + '                    <tr ng-repeat="item in contextItem.childItems">\n' + '                      <td nowrap=nowrap>\n' + '                        <h3>\n' + '                          <i class="{{i18n.translate(iconFromItem(item)).fetch()}} muted"></i>\n' + '                          <a href="{{hrefFromItem(item)}}" class="btn btn-link">\n' + '                            <span>{{item.name}}</span>\n' + '                          </a>\n' + '                        </h3>\n' + '                      </td>\n' + '                      <td nowrap=nowrap>\n' + '                        <a href="{{item.html_url}}" target="_blank" class="btn btn-secondary">\n' + '                          <i class="icon-github"></i>\n' + '                          <span>GitHub</span>\n' + '                        </a>\n' + '                      </td>\n' + '                    </tr>\n' + '                  </tbody>\n' + '                </table>\n' + '              </div>\n' + '            </div>\n' + '            <div class="tab-pane" id="commits">\n' + '              <p>Under Construction: Commits</p>\n' + '            </div>\n' + '            <div class="tab-pane" id="branches">\n' + '              <p>Under Construction: Branches</p>\n' + '            </div>\n' + '          </div>\n' + '          <script>\n' + '            $(function () {\n' + '              $(\'#myTab a[data-target="#items"]\').tab(\'show\');\n' + '            })\n' + '          </script>\n' + '          <script>\n' + '            $(\'#myTab a[data-target="#items"]\').click(function(e) {\n' + '              e.preventDefault();\n' + '              $(this).tab(\'show\');\n' + '            });\n' + '          </script>\n' + '          <script>\n' + '            $(\'#myTab a[data-target="#commits"]\').click(function(e) {\n' + '              e.preventDefault();\n' + '              $(this).tab(\'show\');\n' + '            });\n' + '          </script>\n' + '          <script>\n' + '            $(\'#myTab a[data-target="#branches"]\').click(function(e) {\n' + '              e.preventDefault();\n' + '              $(this).tab(\'show\');\n' + '            });\n' + '          </script>\n' + '        </div> <!-- div.widget-content -->\n' + '      </div> <!-- div.widget -->\n' + '    </div> <!-- div.row-fluid -->\n' + '  </div> <!-- div.container-fluid -->\n' + '  <div id="new-file-dialog" class="modal hide fade" tabindex="-1" role="dialog" aria-labelledby="new-file-dialog-label" aria-hidden="true">\n' + '    <div class="modal-header">\n' + '      <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>\n' + '      <h3 id="new-file-dialog-label"><i class="icon-plus-sign-alt muted"></i> <i class="{{i18n.translate(\'icon-file\').fetch()}} muted"></i> {{i18n.translate("Create a New File").fetch()}}</h3>\n' + '    </div>\n' + '    <form ng-controller="NewFileCtrl">\n' + '      <fieldset>\n' + '        <div class="modal-body">\n' + '          <label>{{i18n.translate(\'File name\').fetch()}}</label>\n' + '          <input type="text" name="name" ng-model="file.name"></input>\n' + '          <label>Commit message:</label>\n' + '          <input type="text" name="message" ng-model="file.message" placeholder="{{i18n.translate(\'Create file\').fetch()}}"></input>\n' + '        </div>\n' + '        <div class="modal-footer">\n' + '          <button id="btnCancel" class="btn" data-dismiss="modal" aria-hidden="true">Close</button>\n' + '          <button type="submit" ng-click="createFile()" id="btnOK" class="btn btn-primary">{{i18n.translate("Create file").fetch()}}</button>\n' + '        </div>\n' + '      </fieldset>\n' + '    </form>\n' + '  </div>\n' + '</div>\n');
    $templateCache.put('angular/user.html', '<div id="user-view">\n' + '  <div class="subnavbar">\n' + '    <div class="subnavbar-inner">\n' + '      <div class="container">\n' + '        <a class="btn-subnavbar collapsed" data-toggle="collapse" data-target=".subnav-collapse">\n' + '          <i class="icon-reorder"></i>\n' + '        </a>\n' + '        <div class="subnav-collapse collapse">\n' + '          <ul class="mainnav">\n' + '            <li class="{{userBreadcrumbClass()}}">\n' + '              <a ng-href="/users/{{user.login}}">\n' + '                <i class="icon-user"></i>\n' + '                <span>{{i18n.translate("My Space").fetch()}}</span>\n' + '              </a>\n' + '            </li>\n' + '            <li>\n' + '              <a ng-href="/workbench" href="#">\n' + '                <i class="icon-edit"></i>\n' + '                <span>Workbench</span>\n' + '              </a>\n' + '            </li>\n' + '          </ul>\n' + '        </div> <!-- /.subnav-collapse -->\n' + '      </div> <!-- /container -->\n' + '    </div> <!-- /subnavbar-inner -->\n' + '  </div> <!-- /subnavbar -->\n' + '\n' + '  <div class="container-fluid">\n' + '    <div class="row-fluid">\n' + '      <div class="span4">\n' + '        <div class="widget">\n' + '          <div class="widget-header">\n' + '              <i class="icon-user"></i>\n' + '              <h3>Profile</h3>\n' + '          </div>\n' + '          <div class="widget-content">\n' + '            <h3>\n' + '              <span>{{user.name}}</span>\n' + '            </h3>\n' + '            <h4>\n' + '              <span>{{user.login}}</span>\n' + '            </h4>\n' + '            <!-- HATEOAS GitHub link? -->\n' + '            <!--\n' + '            <a href="https://github.com/{{user.login}}?tab=repositories" target="_blank" class="btn btn-secondary">\n' + '              <i class="icon-github"></i>\n' + '              <span>GitHub</span>\n' + '            </a>\n' + '            -->\n' + '          </div>\n' + '        </div>\n' + '      </div>\n' + '      <div class="span8">\n' + '        <div class="widget stacked">\n' + '          <div class="widget-content">\n' + '            <ul class="nav nav-tabs" id="myTab">\n' + '              <li><a data-target="#gists" data-toggle="tab">{{i18n.translate("Gist").ifPlural(2, "Gists").fetch()}}</a></li>\n' + '              <li><a data-target="#repos" data-toggle="tab">{{i18n.translate("Repo").ifPlural(2, "Repos").fetch()}}</a></li>\n' + '            </ul>\n' + '            <div class="tab-content">\n' + '              <div class="tab-pane" id="gists">\n' + '                <div class ="row-fluid">\n' + '                  <table class="table table-condensed">\n' + '                    <tbody>\n' + '                      <tr>\n' + '                        <td nowrap=nowrap>\n' + '                          <!--input type="text" placeHolder="Filter..."></input-->\n' + '                        </td>\n' + '                        <td nowrap=nowrap>\n' + '                          <button ng-click="newGist()" class="btn btn-primary">\n' + '                            <i class="icon-plus-sign-alt"></i> <i class="{{i18n.translate(\'icon-gist\').fetch()}}"></i>\n' + '                            <span>{{i18n.translate("Create a New Gist").fetch()}}</span>\n' + '                          </button>\n' + '                        </td>\n' + '                      </tr>\n' + '                      <tr ng-repeat="gist in gists">\n' + '                        <td nowrap=nowrap>\n' + '                          <h3>\n' + '                            <i class="{{i18n.translate(\'icon-gist\').fetch()}} muted"></i>\n' + '                            <a href="/gists/{{gist.id}}" class="btn btn-link">\n' + '                              <span>{{gist.id}}</span>\n' + '                            </a>\n' + '                          </h3>\n' + '                          <p>{{gist.description}}</p>\n' + '                        </td>\n' + '                        <td nowrap=nowrap>\n' + '                          <a href="{{gist.html_url}}" target="_blank" class="btn btn-secondary">\n' + '                            <i class="icon-github"></i>\n' + '                            <span>GitHub</span>\n' + '                          </a>\n' + '                          <!--\n' + '                          <button ng-click="deleteGist(user.login, gist.id)" class="btn btn-tertiary">\n' + '                            <i class="icon-minus-sign-alt"></i>\n' + '                            <span>Delete</span>\n' + '                          </button>\n' + '                          -->\n' + '                        </td>\n' + '                      </tr>\n' + '                    </tbody>\n' + '                  </table>\n' + '                </div>\n' + '              </div>\n' + '              <div class="tab-pane" id="repos">\n' + '                <div class ="row-fluid">\n' + '                  <table class="table table-condensed">\n' + '                    <tbody>\n' + '                      <tr>\n' + '                        <td nowrap=nowrap>\n' + '                          <!--input type="text" placeHolder="Filter..."></input-->\n' + '                        </td>\n' + '                        <td nowrap=nowrap>\n' + '                          <button ng-click="newRepo(user.login)" class="btn btn-primary">\n' + '                            <i class="icon-plus-sign-alt"></i> <i class="{{i18n.translate(\'icon-repo\').fetch()}}"></i>\n' + '                            <span>{{i18n.translate("Create a New Repo").fetch()}}</span>\n' + '                          </button>\n' + '                        </td>\n' + '                      </tr>\n' + '                      <tr ng-repeat="repo in repos">\n' + '                        <td nowrap=nowrap>\n' + '                          <h3>\n' + '                            <i class="{{i18n.translate(\'icon-repo\').fetch()}} muted"></i>\n' + '                            <a href="/users/{{user.login}}/repos/{{repo.name}}/tree/master" class="btn btn-link">\n' + '                              <span>{{repo.name}}</span>\n' + '                            </a>\n' + '                          </h3>\n' + '                          <p>{{repo.description}}</p>\n' + '                        </td>\n' + '                        <td nowrap=nowrap>\n' + '                          <a href="{{repo.html_url}}" target="_blank" class="btn btn-secondary">\n' + '                            <i class="icon-github"></i>\n' + '                            <span>GitHub</span>\n' + '                          </a>\n' + '                          <!--\n' + '                          <button ng-click="deleteRepo(user.login, repo.name)" class="btn btn-tertiary">\n' + '                            <i class="icon-minus-sign-alt"></i>\n' + '                            <span>Delete</span>\n' + '                          </button>\n' + '                          -->\n' + '                        </td>\n' + '                      </tr>\n' + '                    </tbody>\n' + '                  </table>\n' + '                </div>\n' + '              </div>\n' + '            </div>\n' + '            <script>\n' + '              $(function () {\n' + '                $(\'#myTab a[data-target="#gists"]\').tab(\'show\');\n' + '              })\n' + '            </script>\n' + '            <script>\n' + '              $(\'#myTab a[data-target="#gists"]\').click(function(e) {\n' + '                e.preventDefault();\n' + '                $(this).tab(\'show\');\n' + '              });\n' + '            </script>\n' + '            <script>\n' + '              $(\'#myTab a[data-target="#repos"]\').click(function(e) {\n' + '                e.preventDefault();\n' + '                $(this).tab(\'show\');\n' + '              });\n' + '            </script>\n' + '          </div>\n' + '        </div>\n' + '\n' + '        <div id="new-gist-dialog" class="modal hide fade" tabindex="-1" role="dialog" aria-labelledby="new-gist-dialog-label" aria-hidden="true">\n' + '          <div class="modal-header">\n' + '            <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>\n' + '            <h3 id="new-gist-dialog-label"><i class="icon-plus-sign-alt muted"></i> <i class="{{i18n.translate(\'icon-gist\').fetch()}} muted"></i> {{i18n.translate("Create a New Gist").fetch()}}</h3>\n' + '          </div>\n' + '          <form ng-controller="NewGistCtrl">\n' + '            <fieldset>\n' + '              <div class="modal-body">\n' + '                <label>Description<span class="muted"> (optional)</span></label>\n' + '                <input type="text" name="description" ng-model="gist.description"></input>\n' + '              </div>\n' + '              <div class="modal-footer">\n' + '                <button id="btnCancel" class="btn" data-dismiss="modal" aria-hidden="true">Close</button>\n' + '                <button type="submit" ng-click="createGist()" id="btnOK" class="btn btn-primary">{{i18n.translate("Create gist").fetch()}}</button>\n' + '              </div>\n' + '            </fieldset>\n' + '          </form>\n' + '        </div>\n' + '\n' + '        <div id="new-repo-dialog" class="modal hide fade" tabindex="-1" role="dialog" aria-labelledby="new-repo-dialog-label" aria-hidden="true">\n' + '          <div class="modal-header">\n' + '            <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>\n' + '            <h3 id="new-repo-dialog-label"><i class="icon-plus-sign-alt muted"></i> <i class="{{i18n.translate(\'icon-repo\').fetch()}} muted"></i> {{i18n.translate("Create a New Repo").fetch()}}</h3>\n' + '          </div>\n' + '          <form ng-controller="NewRepoCtrl">\n' + '            <fieldset>\n' + '              <div class="modal-body">\n' + '                <label>{{i18n.translate("Repo name").fetch()}}</label>\n' + '                <input type="text" name="repo" ng-model="repo.name"></input>\n' + '                <span class="help-block">{{i18n.translate("Great repo names are short and memorable.").fetch()}}</span>\n' + '                <label>Description<span class="muted"> (optional)</span></label>\n' + '                <input type="text" name="description" ng-model="repo.description"></input>\n' + '                <!--\n' + '                <hr/>\n' + '                <input type="radio" ng-model="repo.private" value="false"> <i class="{{i18n.translate(\'icon-repo\').fetch()}} muted"></i> Public<br/>\n' + '                <span class="help-block">Anyone can see this repository. You choose who can commit.</span>\n' + '                <input type="radio" ng-model="repo.private" value="true"> Private <br/>\n' + '                <span class="help-block">You choose who can see and commit to this repository.</span>\n' + '                -->\n' + '                <hr/>\n' + '                <label class="checkbox">\n' + '                  <input type="checkbox" name="markdown-readme" ng-model="repo.markdownReadme"> {{i18n.translate("Initialize this repo with a README.md").fetch()}}</input>\n' + '                </label>\n' + '                <span class="help-block">{{i18n.translate("This will allow you to clone the repo immediately in GitHub.").fetch()}}</span>\n' + '                <!--\n' + '                <label class="checkbox">\n' + '                  <input type="checkbox" name="python-readme" ng-model="repo.pythonReadme"> Initialize this book with a README.py</input>\n' + '                </label>\n' + '                <span class="help-block">Having at least one Python file will ensure that the GitHub repository is visible to Geometry Zen.</span>\n' + '                -->\n' + '              </div>\n' + '              <div class="modal-footer">\n' + '                <button id="btnCancel" class="btn" data-dismiss="modal" aria-hidden="true">Close</button>\n' + '                <button type="submit" ng-click="createRepo()" id="btnOK" class="btn btn-primary">{{i18n.translate("Create repo").fetch()}}</button>\n' + '              </div>\n' + '            </fieldset>\n' + '          </form>\n' + '        </div>\n' + '\n' + '      </div>\n' + '    </div>\n' + '  </div>\n' + '</div>');
    $templateCache.put('angular/work.html', '<div id="work-view">\n' + '  <div class="subnavbar">\n' + '    <div class="subnavbar-inner">\n' + '      <div class="container">\n' + '        <a class="btn-subnavbar collapsed" data-toggle="collapse" data-target=".subnav-collapse">\n' + '          <i class="icon-reorder"></i>\n' + '        </a>\n' + '        <div class="subnav-collapse collapse">\n' + '          <ul class="mainnav">\n' + '            <li ng-show="isLoggedIn()" class="{{userBreadcrumbClass()}}">\n' + '              <a ng-href="/users/{{user.name}}">\n' + '                <i class="icon-user"></i>\n' + '                <span>{{i18n.translate("My Space").fetch()}}</span>\n' + '              </a>\n' + '            </li>\n' + '            <li class="active">\n' + '              <a ng-click="reload()" href="#">\n' + '                <i class="icon-edit"></i>\n' + '                <span>Workbench</span>\n' + '              </a>\n' + '            </li>\n' + '            <li ng-show="saveEnabled()">\n' + '              <a ng-click="saveFile()" href="#">\n' + '                <i class="icon-save"></i>\n' + '                <span>Save</span>\n' + '              </a>\n' + '            </li>\n' + '            <li ng-show="runEnabled()">\n' + '              <a ng-click="run()" href="#">\n' + '                <i class="icon-cogs"></i>\n' + '                <span>Run</span>\n' + '              </a>\n' + '            </li>\n' + '            <li class="dropdown">\n' + '              <a href="javascript:;" class="dropdown-toggle" data-toggle="dropdown">\n' + '                <i class="icon-book"></i>\n' + '                <span>Help</span>\n' + '                <b class="caret"></b>\n' + '              </a>\n' + '              <ul class="dropdown-menu">\n' + '                <li><a href="https://docs.python.org/3.4/" target="_blank">Python documentation</a></li>\n' + '                <li><a href="http://docs.scipy.org/doc/" target="_blank">Numpy documentation</a></li>\n' + '                <li><a href="http://threejs.org/docs/" target="_blank">three.js documentation</a></li>\n' + '                <li><a href="http://jsxgraph.uni-bayreuth.de/wp/documentation/" target="_blank">JSXGraph documentation</a></li>\n' + '              </ul>\n' + '            </li>\n' + '          </ul>\n' + '        </div>\n' + '      </div>\n' + '    </div>\n' + '  </div>\n' + '  \n' + '  <div id="work-layout" class="container-fluid">\n' + '\n' + '    <div class="row-fluid">\n' + '      <div class="span7">\n' + '        <div class="alert alert-block alert-{{message.severity}}" ng-repeat="message in messages"  ng-show="messages.length &gt; 0">\n' + '          <button type="button" class="close" data-dismiss="alert">&times;</button>\n' + '          <h4>{{message.name}}</h4>\n' + '          {{message.text}}\n' + '        </div>\n' + '        <div id="textarea-container">\n' + '          <textarea id="code"></textarea>\n' + '        </div>\n' + '      </div>\n' + '      <div class="span5">\n' + '        <div id="printer-container">\n' + '          <printer></printer>\n' + '        </div>\n' + '        <div id="graph-container">\n' + '          <div id="box" class="jxgbox" style="width:600px; height:600px;"></div>\n' + '        </div>\n' + '        <div id="canvas-container">\n' + '        </div>\n' + '      </div>\n' + '    </div>\n' + '\n' + '  </div>\n' + '</div>');
  }
]);